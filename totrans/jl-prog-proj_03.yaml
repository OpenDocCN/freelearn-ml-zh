- en: Setting Up the Wiki Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you're excited about Julia by now. The friendly, expressive, and intuitive
    syntax, the powerful **read-eval-print loop** (**REPL**), the great performance,
    and the richness of both built-in and third-party libraries are a game-changing
    combination for data science in particular—and programming in general. The fact
    that in just two introductory chapters we were able to grasp the basics of the
    language and configure a data science setup powerful enough to analyze the Iris
    dataset is quite amazing—congratulations, we've done a great job!
  prefs: []
  type: TYPE_NORMAL
- en: But we are literally just starting. The foundation we've laid is now strong
    enough to allow us to develop pretty much any kind of program using Julia. Hard
    to believe? Well, here's the proof—in the next three chapters, we'll develop a
    web-based game with Julia!
  prefs: []
  type: TYPE_NORMAL
- en: It will follow the narrative of the internet-famous *Six Degrees of Wikipedia*.
    If you've never heard of it, the idea is that any two articles on Wikipedia can
    be connected, using only the links on the pages, in six clicks or fewer. It is
    also called **six degrees of separation**.
  prefs: []
  type: TYPE_NORMAL
- en: In case you're wondering what this has to do with Julia, it is a playful excuse
    to learn about data mining and web scraping and to learn more about the language
    and apply our newly acquired knowledge to build a web app.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will lay the foundations of the web scraper. We'll take
    a look at how requests are made over the web in a client-server architecture and
    how to use the `HTTP` package to fetch web pages. We'll learn about HTML documents,
    HTML and CSS selectors, and `Gumbo`, a HTML parser for Julia. In the process,
    we'll experiment with more code in the REPL and we'll learn about other key features
    of the language, such as dictionaries, error handling, functions, and conditional
    statements. We'll also get to set up our first Julia project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What web scraping is and how it is used for data harvesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Julia to make requests and fetch web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `Pair` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the dictionary, one of Julia's more versatile data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling, to help us capture errors in our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions, the basic building blocks and one of the most important code units
    in Julia—we'll learn how to define and use them to create reusable, modular code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A handful of useful Julia tricks, such as the pipe operator and short-circuit
    evaluation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Julia project using `Pkg`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to install a specific version of a package you need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Data harvesting through web scraping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technique for extracting data from web pages using software is called **web
    scraping**. It is an important component of data harvesting, typically implemented
    through programs called **web crawlers**. Data harvesting or data mining is a
    useful technique, often used in data science workflows to collect information
    from the internet, usually from websites (as opposed to APIs), and then to process
    that data for different purposes using various algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: At a very high level, the process involves making a request for a web page,
    fetching its content, parsing its structure, and then extracting the desired information.
    This can be images, paragraphs of text, or tabular data containing stock information
    and prices, for example—pretty much anything that is present on a web page. If
    the content is spread across multiple web pages, the crawler will also extract
    the links and will automatically follow them to pull the rest of the pages, repeatedly
    applying the same crawling process.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use of web scrapers is for web indexing, as done by search engines
    such as Google or Bing. Online price monitoring and price comparison, personal
    data mining (or contact scraping), and online reputation systems, as well as product
    review platforms, represent other common use cases for web scrapers.
  prefs: []
  type: TYPE_NORMAL
- en: How the web works – a crash course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The internet has become an integral part of our lives over the last decade.
    Most of us use it extensively to access a wealth of information, day in and day
    out. Googling things like rambunctious (noisy and lacking in restraint or discipline),
    catching up with friends on social networks, checking out the latest gourmet restaurants
    on Instagram, watching a blockbuster on Netflix, or reading the Wikipedia entry
    about Attitogon (a place in Togo where they practice voodoo)—they're all just
    a click away. All these, although different in nature, function in pretty much
    the same way.
  prefs: []
  type: TYPE_NORMAL
- en: An internet-connected device, be it a computer using Wi-Fi or a smartphone connected
    to a mobile data network, together with an app for accessing the web (generally
    a web browser such as Chrome or Firefox, but also a dedicated one such as Facebook
    or Netflix's mobile apps), represent *the client*. At the other end we have *the
    server—*a computer that stores the information, be it in the form of web pages,
    videos, or entire web apps.
  prefs: []
  type: TYPE_NORMAL
- en: When a client wants to access the information available on the server, it initiates
    a *request*. If the server determines that the client has the permission to access
    the resource, a copy of the information is downloaded from the server onto the
    client, to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Hypertext Transfer Protocol** (**HTTP**) is a communication protocol for
    transmitting documents over a network. It was designed for communication between
    web browsers and web servers. HTTP implements the standard client-server model,
    where a client opens a connection and makes a request, then waits for a response.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP defines a set of request methods to indicate the action to be performed
    for a given resource. The most common method is `GET`, which is meant to retrieve
    data from the server. It is used when navigating the internet using links. The
    `POST` method requests the server to accept an enclosed data payload, most commonly
    the result of submitting a web form. There are a few more methods, including `HEAD`,
    `PUT`, `DELETE`, `PATCH`, and others—but they are less used and less supported
    by clients and web servers. As we won't need them for our web crawler, they won't
    be covered.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested, you can read about them at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HTTP Secure** (**HTTPS**) is basically HTTP over an encrypted connection.
    It started as an alternative protocol used primarily for processing payments over
    the web and transferring sensitive corporate information. But in recent years,
    it has begun to see widespread usage, with a push from major companies to replace
    plain HTTP connections on the internet. For the purpose of our discussion, HTTP
    and HTTPS can be used interchangeably.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTML documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to extract data from the fetched web pages, we need to isolate and
    manipulate the structural elements that contain the desired information. That's
    why a basic understanding of the generic structure of the web pages is helpful
    when performing web scraping. If you've done web scraping before, maybe using
    a different programming language, or if you just know enough about HTML documents,
    feel free to skip this section. On the other hand, if you're new to this or just
    need a quick refresher, please read on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypertext Markup Language **(**HTML**) is the gold standard for creating
    web pages and web applications. HTML goes hand in hand with HTTP, the protocol
    for transmitting HTML documents over the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks of HTML pages are the *HTML elements*. They provide both
    the content and the structure of a web page. They can be nested to define complex
    relationships with each other (such as parents, children, siblings, ancestors,
    and so on). HTML elements are denoted by *tags*, written between angle brackets
    (`<tag>...</tag>`). The official W3C specification defines a wealth of such tags,
    representing everything from headings and paragraphs, to lists, forms, links,
    images, quotes, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you an idea, here''s how the main heading is represented in HTML on
    Julia''s Wikipedia page at [https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This HTML code renders in a modern browser, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6a9965d-2c15-4643-bd33-f82a58f07ae4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A more elaborate example can present a nested structure such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/651176fc-fa07-42b3-84e8-e8926b7e6d81.png)'
  prefs: []
  type: TYPE_IMG
- en: HTML selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML's purpose is to provide content and structure. That's all we need in order
    to convey any kind of information, no matter how complex. However, as computers
    and web browsers became more powerful and the use of web pages more widespread,
    users and developers wanted more. They asked for ways to extend HTML to also include
    beautiful formatting (design) and rich behavior (interactivity).
  prefs: []
  type: TYPE_NORMAL
- en: That is why **Cascading Style Sheets **(**CSS**) was created—a style language
    that defines the design of HTML documents. Additionally, JavaScript emerged as
    the programming language of choice for the client side, adding interactivity to
    web pages.
  prefs: []
  type: TYPE_NORMAL
- en: The style rules and the interactive features provided by CSS and JavaScript
    are associated with well-defined HTML elements. That is, styling and interactivity
    have to explicitly target elements from the associated HTML document. For example,
    a CSS rule can target the main heading of the page—or a JavaScript validation
    rule can target text input in the login form. If you think of a web page as a
    structured collection of HTML elements, this targeting is achieved by *selecting*
    (sub-collections of) elements.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting elements can be done, in its simplest form, by identifying the HTML
    tags by type and structure (hierarchy). In the previous example, where we looked
    at representing a list of Julia's features, we can select all the list items (the
    `<li>` elements) by indicating a hierarchy like `div > ul > li`, representing
    all the `li` items, nested within a `ul` element, nested within a `div`. These
    are called **HTML selectors**.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach has limitations. On the one hand, when dealing with large,
    complex, and deeply nested HTML documents, we have to handle equally complex hierarchies,
    a tedious and error-prone task. On the other hand, such an approach might not
    provide enough specificity to allow us to select the element we want to target.
    For example, on the same Julia Wikipedia page, how would we differentiate the
    list of features from the list of external links? They both have similar structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of **External links** on Julia''s Wikipedia page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d619d904-331b-4876-829a-c4fda798db99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Language features** section has a similar structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd81a3ab-09e3-4adb-aa2a-1b209715d3b1.png)'
  prefs: []
  type: TYPE_IMG
- en: The fact that the two HTML elements are structurally identical makes it difficult
    to select the list items for the language features alone.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the HTML attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where HTML attributes come into play. These are key-value pairs that
    enhance HTML tags, providing extra information. For example, in order to define
    a link, we're going to use the `<a>` tag—`<a>This is a link</a>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But clearly, this is not enough. If this is a link, what does it link to? As
    developers, we need to provide extra information about the linked location. This
    is done by adding the `href` attribute with its corresponding value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Ah yes, now we're talking! A super handy link to Julia's home page.
  prefs: []
  type: TYPE_NORMAL
- en: In general, all the attributes can be used when selecting HTML elements. But
    not all of them are equally useful. The most important one is arguably the `id`
    attribute. It allows us to assign a unique identifier to an element and then reference
    it in a very efficient way. Another important attribute is the `class`, extensively
    used for CSS styling rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our previous example would look like with extra attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Learning about CSS and JavaScript selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, JavaScript started off using selectors based on the `id` attribute
    and the names of the HTML elements (the tags). Later on, the CSS specification
    came with a more powerful set of selectors, employing not only the `class`, the
    `id`, and the tags, but also the presence of attributes and their values, states
    of the elements (such as `focused` or `disabled`), and more specific element hierarchies
    that take into account relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of CSS selectors that can be used to target the previously
    discussed `<a>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#julia_link` is the selector for the `id` attribute (the `#`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.external_link` is the selector for the `class` attribute (the `.`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a` is the selector for the `<a>` tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a[href*="julialang.org"]` will select all the `<a>` tags with a `href` attribute
    that contains `"julialang.org"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about CSS selectors at [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors).
    It's worth keeping this resource close as web scraping relies heavily on CSS selectors,
    as we'll see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the structure of a link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Links, in technical lingo called **Uniform Resource Locators** (**URLs**), are
    strings of characters that uniquely identify a resource on the internet. They
    are informally known as **web addresses**. Sometimes you might see them called
    **Uniform Resource Identifiers** (**URIs**).
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, Julia's Wikipedia web page was accessible at the URL
    [https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language)).
    This URL refers to the resource `/wiki/Julia_(programming_language)` whose representation,
    as a HTML document, can be requested via the HTTPS protocol (`https:`) from a
    network host whose domain name is `wikipedia.org`. (Wow, that's a mouthful, but
    now you can understand how complex the process of requesting a web page on the
    internet is).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, a common URL can be broken down into the following parts—`scheme://host/path?query#fragment`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we take a look at [https://en.wikipedia.org/wiki/Julia_(programming_language)?uselang=en#Interaction](https://en.wikipedia.org/wiki/Julia_(programming_language)?uselang=en#Interaction),
    we have `https` as the `scheme`, `en.wikipedia.org` as the `host`, `/wiki/Julia_(programming_language)` as
    the `path`, `?uselang=en` as the `query`, and, finally, `#Interaction` as the
    `fragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the internet from Julia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a good understanding of how web pages are accessed on the
    internet through client-server interactions, let's see how we can do this with
    Julia.
  prefs: []
  type: TYPE_NORMAL
- en: The most common web clients are the web browsers—apps such as Chrome or Firefox.
    However, these are meant to be used by human users, rendering web pages with fancy
    styled UIs and sophisticated interactions. Web scraping can be done manually through
    a web browser, it's true, but the most efficient and scalable way is through a
    fully automated, software-driven process. Although web browsers can be automated
    (with something like Selenium from [https://www.seleniumhq.org](https://www.seleniumhq.org)),
    it's a more difficult, error-prone, and resource-intensive task. For most use
    cases, the preferred approach is to use a dedicated HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: Making requests with the HTTP package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Pkg`, Julia''s built-in package manager, provides access to the excellent
    `HTTP` package. It exposes a powerful functionality for building web clients and
    servers—and we''ll use it extensively.'
  prefs: []
  type: TYPE_NORMAL
- en: As you're already accustomed to, extra functionality is only two commands away—`pkg>
    add HTTP` and `julia> using HTTP`.
  prefs: []
  type: TYPE_NORMAL
- en: Recall our discussion about HTTP methods from the previous section; the most
    important ones were `GET`, used to ask for a resource from the server, and `POST`,
    which sends a data payload to the server and accepts the response. The `HTTP`
    package exposes a matching set of functions—we get access to `HTTP.get`, `HTTP.post`,
    `HTTP.delete`, `HTTP.put`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to request Julia''s Wikipedia page. All we need is the page''s
    URL and the `HTTP.get` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be a `Response` object that represents Julia''s Wikipedia page
    in all its glory. The REPL displays the headers and the first lines of the response
    body, truncating the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40970dc4-f4d3-409d-bccf-6a67b91a9cc1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The screenshot shows the details of the `HTTP.Messages.Response` object we
    received—the list of HTTP headers and the first part of the response body. Let''s
    make sure we keep it in a variable so we can reference it later. Remember that
    Julia provisionally stores the result of the last computation in the `ans` REPL
    variable, so let''s pick it up from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Handling HTTP responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After receiving and processing a request, the server sends back a HTTP response
    message. These messages have a standardized structure. They contain a wealth of
    information, with the most important pieces being the status code, the headers,
    and the body.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The status code is a three-digit integer where the first digit represents the
    category, while the next two digits are used to define the subcategory. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1XX - Informational**: Request was received. This indicates a provisional
    response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2XX - Success**: This is the most important response status, acknowledging
    that the request was successfully received, understood, and accepted. It''s what
    we''re looking for in our web-mining scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3XX - Redirection**: This class of status codes indicates that the client
    must take additional action. It usually means that additional requests must be
    made in order to get to the resource, so our scripts will have to handle this
    scenario. We also need to actively prevent cyclical redirects. We won''t deal
    with such complex scenarios in our project, but in real-life applications, 3XX
    status codes will require specialized handling based on the subcategory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wikipedia provides a good description of the various 3XX status codes and instructions
    for what to do in each case: [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection).'
  prefs: []
  type: TYPE_NORMAL
- en: '**4XX - Client Error**: This means that we''ve probably made a mistake when
    sending our request. Maybe the URL is wrong and the resource cannot be found (`404`)
    or maybe we''re not allowed to access the page (`401` and `403` status codes).
    There''s a long list of 4XX response codes and, similar to 3XX ones, our program
    should handle the various scenarios to ensure that the requests are eventually
    successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5XX - Server Error**: Congratulations, you found or caused a problem on the
    server! Depending on the actual status code, this may or may not be actionable.
    `503` (service unavailable) or `504` (gateway timeout) are relevant as they indicate
    that we should try again later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP headers allow the client and the server to pass additional information.
    We won''t go into the details of header transmission since Julia''s `HTTP` library
    saves us from having to deal with raw headers. However, a few are worth mentioning,
    as they are important for web scraping:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Age`, `Cache-Control`, and `Expires` represent the validity of the page and
    can be used to set data refresh times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Last-Modified`, `Etag`, and `If-Modified-Since` can be used for content versioning,
    to check if the page has changed since it was last retrieved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cookie` and `Set-Cookie` have to be used in order to read and write cookies
    that are required for correct communication with the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Content-*` family of headers, such as `Content-Disposition`, `Content-Length`,
    `Content-Type`, `Content-Encoding`, and so on, help when handling and validating
    the response message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
    and [https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)
    for a complete discussion on the HTTP header fields.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP message body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The message body, the most important part and the reason for web scraping (the
    content of the web page itself), is actually an optional part of the response.
    The presence of the body, its properties, and its size are specified by the `Content-*`
    family of headers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The result of the `HTTP.get` invocation is an object that closely mirrors a
    raw HTTP response. The package makes our lives easier by extracting the raw HTTP
    data and neatly setting it up in a data structure, which makes manipulating it
    a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at its properties (or *fields* in Julia''s lingo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `fieldnames` function accepts a type as its argument and returns a tuple
    containing the names of the fields (or properties) of the argument. In order to
    get the type of a value, we can use the `typeof` function, like in the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Right! The `status`, `headers`, and `body` fields should by now sound familiar.
    The `version` field represents the version of the HTTP protocol (the `HTTP/1.1` part
    in the first line of the response). Most web servers on the internet today use
    version 1.1 of the protocol, but a new major version, 2.0, is almost ready for
    wide deployment. Finally, the `request` field holds a reference to the `HTTP.Messages.Request`
    object that triggered the current response.
  prefs: []
  type: TYPE_NORMAL
- en: The status code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, we got back a valid response, hereby confirmed by the `200` status
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What about the headers? As already mentioned, they contain critical information
    indicating whether a message body is present. Let''s check them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f152978-7e46-46bd-b503-682191cc7121.png)'
  prefs: []
  type: TYPE_IMG
- en: Your output will be different in regard to some of the values, but it should
    be easy to spot the key HTTP headers we mentioned before. `Content-Length` confirms
    the presence of a response body. The `Content-Type` provides information about
    how to interpret the encoding of the message body (it's a HTML document using
    UTF-8 character encoding). And we can use the `Last-Modified` value to optimize
    the caching and the update frequency of our web crawler.
  prefs: []
  type: TYPE_NORMAL
- en: The message body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we just confirmed that we have a response body, let''s see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops, that doesn''t look like the web page we were expecting. No worries though,
    these are the bytes of the raw response—which we can easily convert to a human-readable
    HTML string. Remember that I mentioned the `String` method when learning about
    strings? Well, this is where it comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Your REPL should now be outputting a long HTML string that represents Julia's
    Wikipedia page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the first `500` characters, we''ll start to see familiar
    patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aa4f988-cd12-4e2b-b699-c9e9fa77d70f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sure enough, using Chrome''s view page source will reveal the same HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/837384ea-fd70-4459-80ae-71b4b2f99c81.png)'
  prefs: []
  type: TYPE_IMG
- en: It's confirmed—we just took our first successful step toward building our web
    crawler!
  prefs: []
  type: TYPE_NORMAL
- en: Learning about pairs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While looking at the response header, you might''ve noticed that its type is
    an `Array` of `Pair` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A `Pair` represents a Julia data structure—and the corresponding type. The `Pair`
    contains a couple of values that are generally used to reference key-value relationships.
    The types of the two elements determine the concrete type of the `Pair`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can construct a `Pair` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check its type we''ll see that it''s a `Pair` of `Symbol` and `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create `Pairs` by using the `x => y` literal notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `=>` double arrow should look familiar. It''s what we saw in the response
    header, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, once created, it is possible to access the values stored in a `Pair`.
    One way to do it is by indexing into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also access the `first` and `second` fields in order to get to the `first`
    and `second` values, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the tuples, the `Pairs` are immutable, so this won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Pairs` are one of the building blocks of Julia and can be used, among other
    things, for creating dictionaries, one of the most important types and data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dictionary, called `Dict`, is one of Julia's most powerful and versatile
    data structures. It's an associative collection—it *associates *keys with values.
    You can think of a `Dict` as a look-up table implementation—given a single piece
    of information, the key, it will return the corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating an empty instance of a `Dict` is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The information between the curly brackets, `{Any,Any}`, represents the types
    of keys and values of the `Dict`. Thus, the concrete type of a `Dict` itself is
    defined by the type of its keys and values. The compiler will do its best to infer
    the type of the collection from the types of its parts. In this case, since the
    dictionary was empty, no information could be inferred, so Julia defaulted to
    `Any` and `Any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `{Any,Any}` type of `Dict` allows us to add any kind of data, indiscriminately.
    We can use the `setindex!` method to add a new key-value pair to the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, adding values to a `Dict` is routinely done using the square bracket
    notation (which is similar to indexing into it, while also performing an assignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Till now, we''ve only added `Strings`—but like I said, because our `Dict` accepts
    any kind of keys and value, there aren''t any constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `Dict` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that the key `=>` value pairs are not in the order in which we added them.
    `Dicts` are not ordered collections in Julia. We'll talk more about this in a
    few paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the key already exists, the corresponding value will be updated, returning
    the new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our updated `Dict`. Note that `"Hello"` now points to `"Earth"` and
    not `"World"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we provide some initial data when instantiating the `Dict`, the compiler
    will be able to do better at identifying the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the type of the `Dict` is now constraining the keys to be `String`,
    and the values to be `Int`—which are the types of the `Pair` we used to instantiate
    the `Dict`. Now, if a different type is passed for a key or a value, Julia will
    attempt to convert it—if that fails, an error will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In some instances, the automatic conversion works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Julia has silently converted `2.0` to the corresponding `Int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'But that won''t always work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can store randomly complex data in a `Dict` and its type will be correctly
    inferred by Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify and constrain the type of `Dict` upon constructing it,
    instead of leaving it up to Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how the type definition overruled the type of the `2.0` value,
    which is a `Float64` (of course, as in the previous example, Julia has converted
    `2.0` to its integer counterpart).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `Pairs` to create a `Dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use an `Array` of `Pair`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same with arrays of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a `Dict` can be constructed using comprehensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Your output will be different as it's likely that the keys won't be ordered
    from `1` to `7`. That's a very important point—as already mentioned, in Julia,
    the `Dict` is not ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Ordered dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you ever need your dictionaries to stay ordered, you can use the `OrderedCollections` package
    ([https://github.com/JuliaCollections/ OrderedCollections.jl](https://github.com/JuliaCollections/%20OrderedCollections.jl)),
    specifically the `OrderedDict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now the elements are stored in the order in which they are added to the collection
    (from `1` to `12`).
  prefs: []
  type: TYPE_NORMAL
- en: Working with dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve already seen, we can index into a `Dict` using the square bracket
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to access a key that has not been defined will result in a `KeyError`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid such situations, we can check if the key exists in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, if we want to also get a default value when the key does
    not exist, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` function has a more powerful twin, `get!`, which also stores the
    searched key into the `Dict`, using the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In case you're wondering, the exclamation mark at the end of the function name
    is valid—and denotes an important Julia naming convention. It should be taken
    as a warning that using the function will modify its arguments' data. In this
    case, the `get!` function will add the `:baz = 100` `Pair` to the `d` `Dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing a key-value `Pair` is just a matter of invoking `delete!` (note the
    presence of the exclamation mark here too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As requested, the `:baz` key and its corresponding value have vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can ask for the collections of keys and values using the aptly named functions
    `keys` and `values`. They will return iterators over their underlying collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `collect` to retrieve the corresponding arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine a `Dict` with another `Dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If some of the keys are present in multiple dictionaries, the values from the
    last collection will be preserved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Using the HTTP response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Armed with a good understanding of Julia's dictionary data structure, we can
    now take a closer look at the `headers` property of `resp`, our `HTTP` response
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier to access the various headers, first let''s convert the array
    of `Pair` to a `Dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the `Content-Length` value to determine whether or not we have
    a response body. If it''s larger than `0`, that means we got back a HTML message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to remember that all the values in the `headers` dictionary
    are strings, so we can''t go comparing them straight away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need to parse it into an integer first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating the response body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we read the response body into a `String` and stored it into the `resp_body`
    variable. It's a long HTML string and, in theory, we could use `Regex` and other
    string-processing functions to find and extract the data that we need. However,
    such an approach would be extremely complicated and error-prone. The best way
    to search for content in a HTML document is via HTML and CSS selectors. The only
    problem is that these selectors don't operate on strings—they only work against
    a **Document Object Model** (**DOM**).
  prefs: []
  type: TYPE_NORMAL
- en: Building a DOM representation of the page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DOM represents an in-memory structure of an HTML document. It is a data
    structure that allows us to programmatically manipulate the underlying HTML elements.
    The DOM represents a document as a logical tree, and we can use selectors to traverse
    and query this hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing HTML with Gumbo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia's `Pkg` ecosystem provides access to `Gumbo`, a HTML parser library. Provided
    with a HTML string, `Gumbo` will parse it into a document and its corresponding
    DOM. This package is an important tool for web scraping with Julia, so let's add
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, install using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to parse the HTML string into a DOM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dom` variable now references a `Gumbo.HTMLDocument`, an in-memory Julia
    representation of the web page. It''s a simple object that has only two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doctype` represents the HTML `<!DOCTYPE html>` element, which is what
    the Wikipedia page uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s focus on the `root` property. This is effectively the outermost
    element of the HTML page—the `<html>` tag containing the rest of the elements.
    It provides us with an entry point into the DOM. We can ask `Gumbo` about its
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a `Dict`, the keys representing HTML attributes and the values—the attributes''
    values. And sure enough, they match the page''s HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0902ff6-5eb5-4e1e-9b3f-e3f3d130e397.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s also a similar `attrs` method, which serves the same purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When in doubt, we can just ask about the name of an element using the `tag` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`Gumbo` exposes a `children` method which returns an array containing all the
    nested `HTMLElement`. If you just go ahead and execute `julia> children(dom.root)`,
    the REPL output will be hard to follow. The REPL representation of an `HTMLElement`
    is its HTML code, which, for top-level elements with many children, will fill
    up many Terminal screens. Let''s use a `for` loop to iterate over the children
    and show just their tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Much better!
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the children are part of a collection, we can index into them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the closing semicolon (`;`). When used in the REPL at the end of
    an expression, it will suppress the output (so we won''t see the very long HTML
    code of the `<body>` that would otherwise be output). The `body` variable will
    now reference an instance of `HTMLElement{:body}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The last method that we''ll need is `getattr`, which returns the value of an
    attribute name. If the attribute is not defined for the element, it raises a `KeyError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Asking about the `href` attribute of a `<html>` tag doesn't make any sense.
    And sure enough, we promptly got a `KeyError`, since `href` was not an attribute
    of this `HTMLElement`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding defensively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An error like the previous one, when part of a larger script, has the potential
    to completely alter a program's execution, leading to undesired and potentially
    costly results. In general, when something unexpected occurs during the execution
    of a program, it may leave the software in an erroneous state, making it impossible
    to return a correct value. In such cases, rather than pushing on and potentially
    propagating the problem throughout the whole execution stack, it's preferable
    to explicitly notify the calling code about the situation by throwing an `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: Many functions, both in Julia's core and within third-party packages, make good
    use of the error-throwing mechanism. It's good practice to check the docs for
    the functions you use and to see what kinds of errors they throw. An error is
    called an exception in programming lingo.
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of `getattr`, the author of the `Gumbo` package warned us that
    attempting to read an attribute that was not defined would result in a `KeyError`
    exception. We'll learn soon how to handle exceptions by capturing them in our
    code, getting info about the problem, and stopping or allowing the exception to
    propagate further up the call stack. Sometimes it's the best approach, but it's
    not a technique we want to abuse since handling errors this way can be resource-intensive.
    Dealing with exceptions is considerably slower than performing simple data integrity
    checks and branching.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our project, the first line of defense is to simply check if the attribute
    is in fact defined in the element. We can do this by retrieving the keys of the
    attributes `Dict` and checking if the one we want is part of the collection. It''s
    a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, `href` is not an attribute of the `<html>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, we can easily write logic to check for the existence of
    an attribute before we attempt to look up its value.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading multiple nested functions can be taxing on the brain. The previous example,
    `collect(keys(attrs(dom.root)))`, can be rewritten to improve readability using
    Julia's pipe operator, `|>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following snippet nests three function calls, each inner function
    becoming the argument of the outermost one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be rewritten for improved readability as a chain of functions using
    the pipe operator. This code produces the exact same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: What the `|>` operator does is that it takes the output of the first value and
    *pipes* it as the argument of the next function. So `dom.root |> attrs` is identical
    to `attrs(dom.root)`. Unfortunately, the pipe operator works only for one-argument
    functions. But it's still very useful for decluttering code, massively improving
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: For more advanced piping functionality you can check out the `Lazy` package,
    specifically `@>` and `@>>` at [https://github.com/MikeInnes/Lazy.jl#macros.](https://github.com/MikeInnes/Lazy.jl#macros)
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors like a pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, coding defensively won't be the solution. Maybe a key part of your
    program requires reading a file on the network or accessing a database. If the
    resource can't be accessed due to a temporary network failure, there's really
    not much you can do in the absence of the data.
  prefs: []
  type: TYPE_NORMAL
- en: The try...catch statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you identify parts of your code where you think the execution can go off
    the rails due to conditions that are out of your control (that is, *exceptional*
    conditions—hence the name *exception*), you can use Julia's `try...catch` statements.
    This is exactly what it sounds like—you instruct the compiler to *try* a piece
    of code and if, as a result of a problem, an exception is *thrown**,* to *catch*
    it. The fact that an exception is *caught* implies that it won't propagate throughout
    the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this example, once an error is encountered, the execution of the code in
    the `try` branch is stopped exactly at that point, and the execution flow continues
    right away, in the `catch` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'It becomes clearer if we modify the snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The newly added line, `println("I'm here too")`, is not executed, as demonstrated
    by the fact that the message is not output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, things change if no exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `catch` construct takes an optional argument, the `Exception` object that's
    been thrown by the `try` block. This allows us to inspect the exception and branch
    our code depending on its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the `KeyError` exception is built into Julia. It is thrown
    when we attempt to access or delete a non-existent element (such as a key in a
    `Dict` or an attribute of a `HTMLElement`). All instances of `KeyError` have a
    key property, which provides information about the missing data. Thus, we can
    make our code more generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we pass the exception into the `catch` block as the `ex` variable. We
    then check if we''re dealing with a `KeyError` exception—if we are, we use this
    information to display a custom error by accessing the `ex.key` field to retrieve
    the missing key. If it''s a different type of exception, we show a generic error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The finally clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In code that performs state changes or uses resources such as files or databases,
    there is typically some clean-up work (such as closing files or database connections)
    that needs to be done when the code is finished. This code would normally go into
    the `try` branch—but what happens if an exception is thrown?
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, the `finally` clause comes into play. This can be added after
    a `try` or after a `catch` branch. The code within the `finally` block is *guaranteed*
    to be executed, regardless of whether exceptions are thrown or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'It is illegal to have a `try` without a `catch` or a `finally`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We need to provide either a `catch` or a `finally` block (or both).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `try/catch/finally` blocks will return the last expression evaluated, so
    we can capture it in a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Throwing exceptions on errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we too have the option to create and throw exceptions when our
    code encounters a problem and shouldn't continue. Julia provides a long list of
    built-in exceptions that cover a multitude of use cases. You can read about them
    at [https://docs.julialang.org/en/stable/manual/control-flow/#Built-in-Exceptions-1](https://docs.julialang.org/en/stable/manual/control-flow/#Built-in-Exceptions-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to throw an exception, we use the aptly named `throw` function. For
    example, if we want to replicate the error raised by Gumbo''s `getattr` method,
    all we have to do is call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If the built-in exceptions provided by Julia aren''t relevant enough for your
    situation, the language provides a generic error type, the `ErrorException`. It
    takes an additional `msg` argument which should offer more details about the nature
    of the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Julia provides a shortcut for throwing `ErrorException`, the `error` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Rethrowing exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But what do we do if we realize that the exception we've caught cannot (or should
    not) be handled by our code? For example, say we were expecting to catch a possible
    missing attribute, but it turned out we got a `Gumbo` parsing exception instead.
    Such an issue would have to be handled higher up the execution stack, maybe by
    trying to fetch the web page again and reparsing it, or by logging an error message
    for the admin.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we `throw` the exception ourselves, the origin (the `stacktrace`) of the
    initial error would be lost. For such cases, Julia provides the `rethrow` function,
    which can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'If we simply throw the exception ourselves, this is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We throw the `KeyError` exception, but the origin of the exception is lost;
    it appears as if it originates in our code in the `catch` block. Contrast this
    with the following example, where we use `rethrow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The original exception is being rethrown, without changing the stacktrace. Now
    we can see that the exception originated within the `dict.jl` file.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get to write our first full-fledged Julia program, the web crawler,
    we need to take yet another important detour. It's the last one, I promise.
  prefs: []
  type: TYPE_NORMAL
- en: As our code becomes more and more complex, we should start using functions.
    The REPL is great for exploratory programming due to its quick input-output feedback
    loop, but for any non-trivial piece of software, using functions is the way to
    go. Functions are an integral part of Julia, promoting readability, code reuse,
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Julia, a function is an object that takes a tuple of values as an argument
    and returns a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also a compact *assignment form* for function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This second form is great for simple one-line functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking a function is simply a matter of calling its name and passing it the
    required arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The return keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have previous programming experience, you might be surprised to see that
    invoking the `add` function correctly returns the expected value, despite the
    fact that we didn't put any explicit `return` statement in the function's body.
    In Julia, a function automatically returns the result of the last expression that
    was evaluated. This is usually the last expression in the body of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'An explicit `return` keyword is also available. Using it will cause the function
    to exit immediately, with the value passed to the `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Returning multiple values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although Julia does not support returning multiple values, it does offer a
    neat trick that''s very close to the actual thing. Any function can return a tuple.
    And because constructing and destructing tuples is very flexible, this approach
    is very powerful and readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Here we defined a function, `addremove`, which returns a tuple of two integers.
    We can extract the values within the tuple by simply assigning a variable corresponding
    to each of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Optional arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function arguments can have sensible defaults. For such situations, Julia allows
    defining default values. When they are provided, the corresponding arguments no
    longer have to be passed explicitly on every call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has default values for both `x` and `y`. We can invoke it without
    passing any of the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This snippet demonstrates how Julia uses the default values when they are not
    provided upon function invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass the first argument only—and for the second one, the default value
    will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can pass both arguments; all the defaults will be overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Keyword arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functions that require a long list of arguments can be hard to use, as the
    programmer has to remember the order and the types of the expected values. For
    such cases, we can define functions that accept labeled arguments instead. These
    are called **keyword arguments**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to define functions that accept keyword arguments, we need to add
    a semicolon after the function''s list of unlabeled arguments and follow it with
    one or more `keyword=value` pairs. We actually encountered such functions in [Chapter
    2](b9056286-1d26-4cb4-bf90-bdc76722b3fb.xhtml), *Creating Our First Julia App*,
    when we used `Gadfly` to plot the Iris flower dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `x`, `y`, and `color` are all keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a function with keyword arguments looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a new function, `thermal_confort`, which has two required arguments,
    `temperature` and `humidity`. The function also accepts two keyword arguments,
    `scale` and `age`, which have the default values of `:celsius` and `35`, respectively.
    It is necessary for all the keyword arguments to have default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking such a function implies using the positional as well as the keyword
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: If the values for the keyword arguments are not supplied, the default values
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword argument default values are evaluated left to right, which means that
    default expressions may refer to prior keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Note that we reference the keyword argument `age` in the default value of `health_risk`.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia comes out of the box with powerful code-documenting features. The usage
    is straightforward—any string appearing at the top level, right before an object,
    will be interpreted as documentation (it's called a **docstring**). The docstring
    is interpreted as markdown, so we can use markup for rich formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation for the `thermal_confort` function could be as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]julia-repl'
  prefs: []
  type: TYPE_NORMAL
- en: julia> thermal_confort(32, 78)
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can access the documentation of our function by using the REPL''s help
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12ccbd57-9f44-4685-8595-dbdfb105fecc.png)'
  prefs: []
  type: TYPE_IMG
- en: Pretty useful, isn't it? Docstrings can also be used to generate complete documentation
    for your Julia projects, with the help of external packages which build full API
    docs as standalone websites, markdown documents, PDF documents, etcetera. We'll
    see how to do this in [Chapter 11](8391f749-e95c-4ff9-ba40-d71c91b1d7fd.xhtml),
    *Creating Julia Packages*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic web crawler – take one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're now ready to write our first fully-fledged Julia program—a simple web
    crawler. This first iteration will make a request for Julia's Wikipedia page,
    will parse it and extract all the internal URLs, storing them in an `Array`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is to set up a dedicated project. This is done
    by using `Pkg`. It is a very important step as it allows us to efficiently manage
    and version the packages on which our program depends.
  prefs: []
  type: TYPE_NORMAL
- en: 'For starters, we need a folder for our software. Create one—let''s call it
    `WebCrawler`. I''ll use Julia to make it, but you do it however you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use `Pkg` to add the dependencies. When we start a new project,
    we need to initialise it. This is achieved with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells `Pkg` that we want to manage dependencies in the current project
    as opposed to doing it globally. You will notice that the cursor has changed,
    indicating the name of the active project, `WebCrawler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'All the other packages we installed up until this point were in the global
    environment, which was indicated by the `(v1.0)` cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '`(v1.0)` is the global environment, labeled with the currently installed Julia
    version. If you try the examples on a different Julia version, you''ll get a different
    label.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we check the status, we''ll see that no packages were installed yet in the
    project''s environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Our software will have two dependencies—`HTTP` and `Gumbo`. It''s time to add
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a new file to host our code. Let''s call it `webcrawler.jl`.
    It can be created using Julia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Writing a Julia program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike our previous work in the REPL and IJulia notebooks, this will be a standalone
    program: all the logic will go inside this `webcrawler.jl` file, and when ready,
    we''ll use the `julia` binary to execute it.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia files are parsed top to bottom, so we need to provide all the necessary
    instructions in the right order (using statements, variables initialization, function
    definitions, etcetera). We'll pretty much condense all the steps we took so far
    in this chapter to build this small program.
  prefs: []
  type: TYPE_NORMAL
- en: To make things simpler, it's best to use a full-fledged Julia editor. Open `webcrawler.jl`
    in Atom/Juno or Visual Studio Code (or whatever your favorite editor is).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is to inform Julia that we plan on using the
    `HTTP` and `Gumbo` packages. We can write a single `using` statement and list
    multiple dependencies, separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we decided that we wanted to use Julia''s Wikipedia page to test our
    crawler. The link is [https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language)).
    It''s good practice to store such configuration-like values in constants, rather
    than spreading *magic strings* throughout the whole code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We also said that we wanted to store all the links in an `Array`—let''s set
    that up too. Remember that constants in Julia are concerned mostly with types,
    so there is no problem if we push values into the array after it''s declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Here, we initialize the `LINKS` constant as an empty `Array` of `String`. The
    notation `String[]` produces the same result as `Array{String,1}()` and `Vector{String}()`.
    It basically represents the empty `Array` literal `[]` plus the `Type` constraint
    `String`—creating a `Vector` of `String` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next steps are—fetch the page, look for a successful response (status `200`),
    and then check the headers to see if we received a message body (`Content-Length`
    greater than zero). In this first iteration, we only have to do this one time.
    But thinking ahead, for the final version of our game, we''ll have to repeat this
    process up to six times per game session (because there will be up to Six Degrees
    of Wikipedia, so we''ll have to crawl up to six pages). The best thing we can
    do is to write a generic function which takes a page URL as its only parameter,
    fetches the page, performs the necessary checks, and returns the message body
    if available. Let''s call this function `fetchpage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: First, we call `HTTP.get(url)`, storing the `HTTP.Messages.Response` object
    in the `response` variable. Then we check if the response status is `200` and
    if the `Content-Length` header is greater than `0`. If they are, we read the message
    body into a string. If not, we return an empty string, `""`, to represent the
    empty body. That's a lot of *ifs*—looks like it's time we take a closer look at
    the conditional `if/else` statements, as they're really important.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional evaluation of if, elseif, and else statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All, except maybe the most basic, programs must be able to evaluate variables
    and execute different logical branches depending on their current values. Conditional
    evaluation allows portions of the code to be executed (or not) depending on the
    value of a Boolean expression. Julia provides the `if`, `elseif`, and `else` statements
    for writing conditional expressions. They work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: If the condition `x < 0` is true, then its underlying block is evaluated. If
    not, the expression `x > 0` is evaluated, as part of the `elseif` branch. If it
    is true, its corresponding block is evaluated. If neither expression is true,
    the `else` block is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `elseif` and `else` blocks are optional, and we can use as many `elseif`
    blocks as we want. The conditions in the `if`,`elseif` and `else` construct are
    evaluated until the first one returns `true`. Then the associated block is evaluated
    and its last computed value is returned, exiting the conditional evaluation. Thus,
    conditional statements in Julia also return a value—the last executed statement
    in the branch that was chosen. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s very important to keep in mind that `if` blocks do not introduce
    local scope. That is, variables defined within them will be accessible after the
    block is exited (of course, provided that the respective branch has been evaluated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that the `y` variable, initialized within the `elseif` block,
    is still accessible outside the conditional expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be avoided if we declare the variable to be `local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: When declared `local`, the variable no longer *leaks* outside the `if` block.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `if`,`then` and `else` type of condition can be expressed using the ternary
    operator `? :`. Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'If `x` is true, the expression `y` is evaluated—otherwise, `z` gets evaluated
    instead. For instance, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Short-circuit evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Julia provides an even more concise type of evaluation—short-circuit evaluation.
    In a series of Boolean expressions connected by `&&` and `||` operators, only
    the minimum number of expressions are evaluated—as many as are necessary in order
    to determine the final Boolean value of the entire chain. We can exploit this
    to return certain values, depending on what gets to be evaluated. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In an expression `A && B`, the second expression `B` is only evaluated if and
    only if `A` evaluates to `true`. In this case, the whole expression has the return
    value of the sub-expression `B`, which in the previous example is `bigger than
    5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the contrary, `A` evaluates to `false`, `B` does not get evaluated at
    all. Thus, beware—the whole expression will return a `false` Boolean (not a string!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The same logic applies to the logical `or` operator, `||`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'In an expression `A || B`, the second expression `B` is only evaluated if `A`
    evaluates to `false`. The same logic applies when the first sub-expression is
    evaluated to `true`; `true` will be the return value of the whole expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Beware of operator precedence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes short-circuit expressions can confuse the compiler, resulting in
    errors or unexpected results. For example, short-circuit expressions are often
    used with assignment operations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fail with the `syntax: invalid assignment location "(x > 15) || message"`
    error because the `=` assignment operator has higher precedence than logical `or` and `||`.
    It can easily be fixed by using brackets to explicitly control the evaluation
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: It's something to keep in mind as it's a common source of errors for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: Carrying on with the crawler's implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, your code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: It should be now clear that either the response body or an empty string is returned
    by the `if/else` statement. And since this is the last piece of code evaluated
    inside the `fetchpage` function, this value also becomes the return value of the
    whole function.
  prefs: []
  type: TYPE_NORMAL
- en: 'All good, we can now use the `fetchpage` function to get the HTML content of
    the Wikipedia page and store it in the `content` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'If the fetch operation is successful and the `content` is not an empty string,
    we can pass the HTML string to `Gumbo` to construct the DOM. Then, we can loop
    through all the children of this DOM''s `root` element and look for links (using
    the `a` tag selector). For each element, we want to check the `href` attribute
    and store its value only if it points to another Wikipedia page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The function for extracting the links is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Here, we declare an `extractlinks` function which takes a `Gumbo` element, called
    `elem`, as its only parameter. We then check if `elem` is a `HTMLElement` and,
    if it is, we check if it corresponds to a link tag (the `:a` Julia `Symbol` which
    represents an `<a>` HTML tag). Then we check if the element defines a `href` attribute
    in order to avoid getting a `KeyError`. If all is good, we get the value of the
    `href` element. And finally, if the value of the `href` is an internal URL—that
    is, a URL that starts with `/wiki/`—we add it to our `LINKS` `Array`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we're done checking the element for links, we check if it contains other
    nested HTML elements. If it does, we want to repeat the same process for each
    of its children. That's what the final `for` loop does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do is to display the populated `LINKS` `Array`, at the
    very end of our file. Since some of the links might come up in the page more than
    once, let''s make sure we reduce the `Array` to the unique elements only, by using
    the `unique` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Now we can execute this script by opening a terminal in the folder where the
    file is stored. And then run—`$ julia webcrawler.jl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s plenty of links, so the output will be quite long. Here''s the top
    of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: By looking at the output, we'll notice that in the first optimization some links
    point to special Wikipedia pages—the ones containing parts such as `/File:`, `/Category:`,
    `/Help:`, `/Special:`, and so on. So we can just go ahead and skip all the URLs
    that contain a column, `:`, since these are not articles and are not useful for
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, look for the line that reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding line with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program now, you should see a list of all the URLs from Julia's
    Wikipedia page that link to other Wikipedia articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the full code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web scraping is a key component of data mining and Julia provides a powerful
    toolbox for handling these tasks. In this chapter, we addressed the fundamentals
    of building a web crawler. We learned how to request web pages with a Julia web
    client and how to read the responses, how to work with Julia's powerful `Dict`
    data structure to read HTTP information, how to make our software more resilient
    by handling errors, how to better organize our code by writing functions and documenting
    them, and how to use conditional logic to make decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, we built the first version of our web crawler. In
    the next chapter, we will improve it and will use it to extract the data for our
    upcoming Wiki game. In the process, we'll dive deeper into the language, learning
    about types, methods and modules, and how to interact with relational databases.
  prefs: []
  type: TYPE_NORMAL
