- en: Setting Up the Wiki Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Wiki 游戏
- en: I hope you're excited about Julia by now. The friendly, expressive, and intuitive
    syntax, the powerful **read-eval-print loop** (**REPL**), the great performance,
    and the richness of both built-in and third-party libraries are a game-changing
    combination for data science in particular—and programming in general. The fact
    that in just two introductory chapters we were able to grasp the basics of the
    language and configure a data science setup powerful enough to analyze the Iris
    dataset is quite amazing—congratulations, we've done a great job!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在对 Julia 感到兴奋。友好、表达丰富且直观的语法，强大的 **read-eval-print 循环**（**REPL**），出色的性能，以及内置和第三方库的丰富性，对于数据科学（尤其是编程）来说是一个颠覆性的组合。事实上，仅仅在两个入门章节中，我们就能够掌握语言的基础，并配置一个足够强大的数据科学环境来分析
    Iris 数据集，这相当令人惊讶——恭喜，我们做得很好！
- en: But we are literally just starting. The foundation we've laid is now strong
    enough to allow us to develop pretty much any kind of program using Julia. Hard
    to believe? Well, here's the proof—in the next three chapters, we'll develop a
    web-based game with Julia!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们实际上才刚刚开始。我们奠定的基础现在足够强大，可以让我们使用 Julia 开发几乎任何类型的程序。难以置信吗？好吧，这里是证据——在接下来的三个章节中，我们将使用
    Julia 开发一个基于网页的游戏！
- en: It will follow the narrative of the internet-famous *Six Degrees of Wikipedia*.
    If you've never heard of it, the idea is that any two articles on Wikipedia can
    be connected, using only the links on the pages, in six clicks or fewer. It is
    also called **six degrees of separation**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它将遵循互联网上著名的 *六度分隔 Wikipedia* 的叙事。如果你从未听说过它，其想法是任何两篇维基百科文章都可以通过页面上的链接连接起来，只需点击六次或更少。它也被称为
    **六度分隔**。
- en: In case you're wondering what this has to do with Julia, it is a playful excuse
    to learn about data mining and web scraping and to learn more about the language
    and apply our newly acquired knowledge to build a web app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想这与 Julia 有什么关系，这是一个有趣的理由来学习数据挖掘和网页抓取，并且更多地了解这门语言，将我们新获得的知识应用到构建网页应用中。
- en: In this chapter, we will lay the foundations of the web scraper. We'll take
    a look at how requests are made over the web in a client-server architecture and
    how to use the `HTTP` package to fetch web pages. We'll learn about HTML documents,
    HTML and CSS selectors, and `Gumbo`, a HTML parser for Julia. In the process,
    we'll experiment with more code in the REPL and we'll learn about other key features
    of the language, such as dictionaries, error handling, functions, and conditional
    statements. We'll also get to set up our first Julia project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将奠定网页抓取的基础。我们将探讨在客户端-服务器架构中如何在网络上发出请求，以及如何使用 `HTTP` 包抓取网页。我们将学习关于 HTML
    文档、HTML 和 CSS 选择器，以及 `Gumbo`，Julia 的 HTML 解析器。在这个过程中，我们将在 REPL 中实验更多代码，并了解语言的其他关键特性，如字典、错误处理、函数和条件语句。我们还将设置我们的第一个
    Julia 项目。
- en: 'The topics we will cover in this chapter include the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: What web scraping is and how it is used for data harvesting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页抓取是什么以及它是如何用于数据采集的
- en: How to use Julia to make requests and fetch web pages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Julia 发出请求和抓取网页
- en: Understanding the `Pair` type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `Pair` 类型
- en: Learning about the dictionary, one of Julia's more versatile data structures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解字典，这是 Julia 中更灵活的数据结构之一
- en: Exception handling, to help us capture errors in our code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理，帮助我们捕获代码中的错误
- en: Functions, the basic building blocks and one of the most important code units
    in Julia—we'll learn how to define and use them to create reusable, modular code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数，Julia 的基本构建块和最重要的代码单元之一——我们将学习如何定义和使用它们来创建可重用、模块化的代码
- en: A handful of useful Julia tricks, such as the pipe operator and short-circuit
    evaluation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些有用的 Julia 技巧，例如管道操作符和短路评估
- en: Setting up a Julia project using `Pkg`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Pkg` 设置 Julia 项目
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 包生态系统正在持续发展中，并且每天都有新的包版本发布。大多数时候，这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍然处于测试版（版本
    0.x），任何新版本都可能引入破坏性更改。因此，书中展示的代码可能会停止工作。为了确保您的代码能够产生与书中描述相同的结果，建议使用相同的包版本。以下是本章使用的外部包及其具体版本：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，您需要运行：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过下载章节提供的`Project.toml`文件并使用`pkg>`实例化来安装所有使用的包：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Data harvesting through web scraping
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过网络爬虫进行数据采集
- en: The technique for extracting data from web pages using software is called **web
    scraping**. It is an important component of data harvesting, typically implemented
    through programs called **web crawlers**. Data harvesting or data mining is a
    useful technique, often used in data science workflows to collect information
    from the internet, usually from websites (as opposed to APIs), and then to process
    that data for different purposes using various algorithms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用软件从网页中提取数据的技术称为**网络爬虫**。它是数据采集的重要组件，通常通过称为**网络爬虫**的程序实现。数据采集或数据挖掘是一种有用的技术，常用于数据科学工作流程中，从互联网上收集信息，通常是从网站（而不是API）上，然后使用各种算法对数据进行处理，以达到不同的目的。
- en: At a very high level, the process involves making a request for a web page,
    fetching its content, parsing its structure, and then extracting the desired information.
    This can be images, paragraphs of text, or tabular data containing stock information
    and prices, for example—pretty much anything that is present on a web page. If
    the content is spread across multiple web pages, the crawler will also extract
    the links and will automatically follow them to pull the rest of the pages, repeatedly
    applying the same crawling process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常高的层面上，这个过程涉及对网页发出请求，获取其内容，解析其结构，然后提取所需的信息。这可能包括图像、文本段落或包含股票信息和价格的表格数据，例如——几乎任何在网页上存在的内容。如果内容分布在多个网页上，爬虫还会提取链接，并自动跟随它们以拉取其余页面，反复应用相同的爬取过程。
- en: The most common use of web scrapers is for web indexing, as done by search engines
    such as Google or Bing. Online price monitoring and price comparison, personal
    data mining (or contact scraping), and online reputation systems, as well as product
    review platforms, represent other common use cases for web scrapers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 网络爬虫最常见的使用是用于网络索引，如Google或Bing等搜索引擎所做的那样。在线价格监控和价格比较、个人数据挖掘（或联系爬取）、在线声誉系统，以及产品评论平台，都是网络爬虫的其他常见用例。
- en: How the web works – a crash course
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络工作原理——快速入门
- en: The internet has become an integral part of our lives over the last decade.
    Most of us use it extensively to access a wealth of information, day in and day
    out. Googling things like rambunctious (noisy and lacking in restraint or discipline),
    catching up with friends on social networks, checking out the latest gourmet restaurants
    on Instagram, watching a blockbuster on Netflix, or reading the Wikipedia entry
    about Attitogon (a place in Togo where they practice voodoo)—they're all just
    a click away. All these, although different in nature, function in pretty much
    the same way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年里，互联网已经成为我们生活的一个基本组成部分。我们中的大多数人都广泛地使用它来获取大量的信息，日复一日。无论是搜索“rambunctious”（喧闹且缺乏自律或纪律），在社交网络上与朋友保持联系，在Instagram上查看最新的美食餐厅，在Netflix上观看热门电影，还是阅读关于Attitogon（多哥的一个地方，那里的人们练习巫毒教）的维基百科条目——所有这些，尽管性质不同，但基本上都以相同的方式运作。
- en: An internet-connected device, be it a computer using Wi-Fi or a smartphone connected
    to a mobile data network, together with an app for accessing the web (generally
    a web browser such as Chrome or Firefox, but also a dedicated one such as Facebook
    or Netflix's mobile apps), represent *the client*. At the other end we have *the
    server—*a computer that stores the information, be it in the form of web pages,
    videos, or entire web apps.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个连接到互联网的设备，无论是使用Wi-Fi的计算机还是连接到移动数据网络的智能手机，以及一个用于访问网络的程序（通常是一个Web浏览器，如Chrome或Firefox，也可以是专门的程序，如Facebook或Netflix的移动应用），代表*客户端*。在另一端是*服务器*——一个存储信息的计算机，无论是以网页、视频还是整个Web应用的形式。
- en: When a client wants to access the information available on the server, it initiates
    a *request*. If the server determines that the client has the permission to access
    the resource, a copy of the information is downloaded from the server onto the
    client, to be displayed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要访问服务器上的信息时，它会发起一个*请求*。如果服务器确定客户端有权访问资源，信息的一个副本将从服务器下载到客户端，以便显示。
- en: Making HTTP requests
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送HTTP请求
- en: The **Hypertext Transfer Protocol** (**HTTP**) is a communication protocol for
    transmitting documents over a network. It was designed for communication between
    web browsers and web servers. HTTP implements the standard client-server model,
    where a client opens a connection and makes a request, then waits for a response.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）是一种用于在网络上传输文档的通信协议。它是为了在Web浏览器和Web服务器之间进行通信而设计的。HTTP实现了标准的客户端-服务器模型，其中客户端打开一个连接并发出请求，然后等待响应。'
- en: Learning about HTTP methods
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解HTTP方法
- en: HTTP defines a set of request methods to indicate the action to be performed
    for a given resource. The most common method is `GET`, which is meant to retrieve
    data from the server. It is used when navigating the internet using links. The
    `POST` method requests the server to accept an enclosed data payload, most commonly
    the result of submitting a web form. There are a few more methods, including `HEAD`,
    `PUT`, `DELETE`, `PATCH`, and others—but they are less used and less supported
    by clients and web servers. As we won't need them for our web crawler, they won't
    be covered.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP定义了一组请求方法，用于指示对给定资源要执行的操作。最常见的方法是`GET`，它的目的是从服务器检索数据。当通过链接在互联网上导航时使用。`POST`方法请求服务器接受一个包含的数据有效负载，通常是提交网页表单的结果。还有一些其他方法，包括`HEAD`、`PUT`、`DELETE`、`PATCH`等——但它们使用较少，并且客户端和Web服务器支持较少。由于我们不需要它们进行我们的网络爬虫，所以不会涉及这些。
- en: If you're interested, you can read about them at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对它们感兴趣，可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)上阅读有关内容。
- en: Understanding HTTPS
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTTPS
- en: '**HTTP Secure** (**HTTPS**) is basically HTTP over an encrypted connection.
    It started as an alternative protocol used primarily for processing payments over
    the web and transferring sensitive corporate information. But in recent years,
    it has begun to see widespread usage, with a push from major companies to replace
    plain HTTP connections on the internet. For the purpose of our discussion, HTTP
    and HTTPS can be used interchangeably.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP安全**（**HTTPS**）基本上是在加密连接上运行的HTTP。它最初是一种主要用于在互联网上处理支付和传输敏感企业信息的替代协议。但近年来，它已经开始得到广泛的使用，主要公司推动在互联网上用HTTPS替换普通的HTTP连接。在我们的讨论中，HTTP和HTTPS可以互换使用。'
- en: Understanding HTML documents
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTML文档
- en: In order to extract data from the fetched web pages, we need to isolate and
    manipulate the structural elements that contain the desired information. That's
    why a basic understanding of the generic structure of the web pages is helpful
    when performing web scraping. If you've done web scraping before, maybe using
    a different programming language, or if you just know enough about HTML documents,
    feel free to skip this section. On the other hand, if you're new to this or just
    need a quick refresher, please read on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从获取的网页中提取数据，我们需要隔离和操作包含所需信息的结构元素。这就是为什么在执行网络爬取时，对网页通用结构的了解很有帮助。如果你之前进行过网络爬取，可能使用的是不同的编程语言，或者如果你对HTML文档了解足够多，可以自由跳过这一部分。另一方面，如果你是新手或者只是需要快速复习，请继续阅读。
- en: '**Hypertext Markup Language **(**HTML**) is the gold standard for creating
    web pages and web applications. HTML goes hand in hand with HTTP, the protocol
    for transmitting HTML documents over the internet.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本标记语言（HTML**）是创建网页和网页应用的黄金标准。HTML与HTTP协议相辅相成，该协议用于在互联网上传输HTML文档。'
- en: The building blocks of HTML pages are the *HTML elements*. They provide both
    the content and the structure of a web page. They can be nested to define complex
    relationships with each other (such as parents, children, siblings, ancestors,
    and so on). HTML elements are denoted by *tags*, written between angle brackets
    (`<tag>...</tag>`). The official W3C specification defines a wealth of such tags,
    representing everything from headings and paragraphs, to lists, forms, links,
    images, quotes, and much more.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面的构建块是**HTML元素**。它们提供了网页的内容和结构。它们可以通过嵌套来定义彼此之间的复杂关系（如父元素、子元素、兄弟元素、祖先元素等）。HTML元素通过*标签*表示，标签写在大括号之间（`<tag>...</tag>`）。官方W3C规范定义了大量的此类标签，代表从标题和段落到列表、表单、链接、图片、引语等一切内容。
- en: 'To give you an idea, here''s how the main heading is represented in HTML on
    Julia''s Wikipedia page at [https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language)):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您有一个概念，以下是如何在Julia的维基百科页面[https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language))上用HTML表示主要标题的示例：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This HTML code renders in a modern browser, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代浏览器中，这段HTML代码会呈现如下：
- en: '![](img/f6a9965d-2c15-4643-bd33-f82a58f07ae4.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6a9965d-2c15-4643-bd33-f82a58f07ae4.png)'
- en: 'A more elaborate example can present a nested structure such as the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更详细的例子可以展示一个嵌套结构，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/651176fc-fa07-42b3-84e8-e8926b7e6d81.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/651176fc-fa07-42b3-84e8-e8926b7e6d81.png)'
- en: HTML selectors
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML选择器
- en: HTML's purpose is to provide content and structure. That's all we need in order
    to convey any kind of information, no matter how complex. However, as computers
    and web browsers became more powerful and the use of web pages more widespread,
    users and developers wanted more. They asked for ways to extend HTML to also include
    beautiful formatting (design) and rich behavior (interactivity).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: HTML的目的是提供内容和结构。这就是我们传达任何类型信息所需的一切，无论信息多么复杂。然而，随着计算机和网页浏览器的变得更加强大，以及网页的使用变得更加普遍，用户和开发者想要更多。他们要求扩展HTML，以便包括美丽的格式（设计）和丰富的行为（交互性）。
- en: That is why **Cascading Style Sheets **(**CSS**) was created—a style language
    that defines the design of HTML documents. Additionally, JavaScript emerged as
    the programming language of choice for the client side, adding interactivity to
    web pages.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，**层叠样式表（CSS**）被创建出来——一种定义HTML文档设计的样式语言。此外，JavaScript也成为了客户端编程语言的首选，为网页增加了交互性。
- en: The style rules and the interactive features provided by CSS and JavaScript
    are associated with well-defined HTML elements. That is, styling and interactivity
    have to explicitly target elements from the associated HTML document. For example,
    a CSS rule can target the main heading of the page—or a JavaScript validation
    rule can target text input in the login form. If you think of a web page as a
    structured collection of HTML elements, this targeting is achieved by *selecting*
    (sub-collections of) elements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CSS和JavaScript提供的样式规则和交互功能与定义良好的HTML元素相关联。也就是说，样式和交互必须明确针对相关的HTML文档中的元素。例如，一个CSS规则可以针对页面的主要标题——或者一个JavaScript验证规则可以针对登录表单中的文本输入。如果您将网页视为一个结构化的HTML元素集合，这种针对是通过*选择*（子集合）元素来实现的。
- en: Selecting elements can be done, in its simplest form, by identifying the HTML
    tags by type and structure (hierarchy). In the previous example, where we looked
    at representing a list of Julia's features, we can select all the list items (the
    `<li>` elements) by indicating a hierarchy like `div > ul > li`, representing
    all the `li` items, nested within a `ul` element, nested within a `div`. These
    are called **HTML selectors**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 选择元素可以通过简单地识别HTML标签的类型和结构（层次结构）来完成。在先前的例子中，我们查看如何表示Julia的功能列表时，我们可以通过指定一个层次结构如`div
    > ul > li`来选择所有列表项（`<li>`元素），这表示所有嵌套在`ul`元素中的`li`元素，而`ul`元素又嵌套在`div`元素中。这些被称为**HTML选择器**。
- en: However, this approach has limitations. On the one hand, when dealing with large,
    complex, and deeply nested HTML documents, we have to handle equally complex hierarchies,
    a tedious and error-prone task. On the other hand, such an approach might not
    provide enough specificity to allow us to select the element we want to target.
    For example, on the same Julia Wikipedia page, how would we differentiate the
    list of features from the list of external links? They both have similar structures.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有其局限性。一方面，当处理大型、复杂且深度嵌套的 HTML 文档时，我们必须处理同样复杂的层次结构，这是一项繁琐且容易出错的任务。另一方面，这种方法可能不足以提供足够的特定性，使我们能够选择我们想要的目标元素。例如，在相同的
    Julia 维基百科页面上，我们如何区分功能列表和外部链接列表？它们都有相似的结构。
- en: 'The list of **External links** on Julia''s Wikipedia page looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 维基百科页面上的 **外部链接** 列表看起来是这样的：
- en: '![](img/d619d904-331b-4876-829a-c4fda798db99.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d619d904-331b-4876-829a-c4fda798db99.png)'
- en: 'The **Language features** section has a similar structure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言功能** 部分有类似的结构：'
- en: '![](img/fd81a3ab-09e3-4adb-aa2a-1b209715d3b1.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd81a3ab-09e3-4adb-aa2a-1b209715d3b1.png)'
- en: The fact that the two HTML elements are structurally identical makes it difficult
    to select the list items for the language features alone.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 HTML 元素在结构上相同的事实使得单独选择语言功能列表项变得困难。
- en: Learning about the HTML attributes
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 HTML 属性
- en: This is where HTML attributes come into play. These are key-value pairs that
    enhance HTML tags, providing extra information. For example, in order to define
    a link, we're going to use the `<a>` tag—`<a>This is a link</a>`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 HTML 属性发挥作用的地方。这些是键值对，它们增强了 HTML 标签，提供了额外信息。例如，为了定义一个链接，我们将使用 `<a>` 标签——`<a>This
    is a link</a>`。
- en: 'But clearly, this is not enough. If this is a link, what does it link to? As
    developers, we need to provide extra information about the linked location. This
    is done by adding the `href` attribute with its corresponding value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但显然，这还不够。如果这是一个链接，它链接到什么？作为开发者，我们需要提供有关链接位置的一些额外信息。这是通过添加带有相应值的 `href` 属性来完成的：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ah yes, now we're talking! A super handy link to Julia's home page.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，现在我们说到点子上了！一个超级方便的链接到 Julia 的主页。
- en: In general, all the attributes can be used when selecting HTML elements. But
    not all of them are equally useful. The most important one is arguably the `id`
    attribute. It allows us to assign a unique identifier to an element and then reference
    it in a very efficient way. Another important attribute is the `class`, extensively
    used for CSS styling rules.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有属性都可以在选择 HTML 元素时使用。但并非所有属性都同样有用。其中最重要的可能是 `id` 属性。它允许我们为元素分配一个唯一的标识符，然后以非常高效的方式引用它。另一个重要的属性是
    `class`，它被广泛用于 CSS 样式规则。
- en: 'This is what our previous example would look like with extra attributes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们之前的例子添加额外属性后的样子：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Learning about CSS and JavaScript selectors
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 CSS 和 JavaScript 选择器
- en: Historically, JavaScript started off using selectors based on the `id` attribute
    and the names of the HTML elements (the tags). Later on, the CSS specification
    came with a more powerful set of selectors, employing not only the `class`, the
    `id`, and the tags, but also the presence of attributes and their values, states
    of the elements (such as `focused` or `disabled`), and more specific element hierarchies
    that take into account relationships.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，JavaScript 最初使用基于 `id` 属性和 HTML 元素（标签）名称的选择器。后来，CSS 规范带来了一组更强大的选择器，不仅包括
    `class`、`id` 和标签，还包括属性及其值、元素的状态（如 `focused` 或 `disabled`），以及更具体的元素层次结构，它考虑了关系。
- en: 'Here are a few examples of CSS selectors that can be used to target the previously
    discussed `<a>` tag:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以用来定位之前讨论的 `<a>` 标签的 CSS 选择器示例：
- en: '`#julia_link` is the selector for the `id` attribute (the `#`)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#julia_link` 是 `id` 属性的选择器（`#`）'
- en: '`.external_link` is the selector for the `class` attribute (the `.`)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.external_link` 是 `class` 属性（`.`）的选择器'
- en: '`a` is the selector for the `<a>` tag'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a` 是 `<a>` 标签的选择器'
- en: '`a[href*="julialang.org"]` will select all the `<a>` tags with a `href` attribute
    that contains `"julialang.org"`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a[href*="julialang.org"]` 将选择所有具有包含 `"julialang.org"` 的 `href` 属性的 `<a>` 标签'
- en: You can read more about CSS selectors at [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors).
    It's worth keeping this resource close as web scraping relies heavily on CSS selectors,
    as we'll see in the next chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors)了解更多关于
    CSS 选择器的信息。这个资源值得保留在身边，因为网络爬虫在很大程度上依赖于 CSS 选择器，正如我们将在下一章中看到的。
- en: Understanding the structure of a link
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解链接的结构
- en: Links, in technical lingo called **Uniform Resource Locators** (**URLs**), are
    strings of characters that uniquely identify a resource on the internet. They
    are informally known as **web addresses**. Sometimes you might see them called
    **Uniform Resource Identifiers** (**URIs**).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术术语中被称为**统一资源定位符**（**URLs**）的链接，是一系列字符，它们唯一地标识了互联网上的资源。它们非正式地被称为**网页地址**。有时你可能看到它们被称为**统一资源标识符**（**URIs**）。
- en: In our previous example, Julia's Wikipedia web page was accessible at the URL
    [https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language)).
    This URL refers to the resource `/wiki/Julia_(programming_language)` whose representation,
    as a HTML document, can be requested via the HTTPS protocol (`https:`) from a
    network host whose domain name is `wikipedia.org`. (Wow, that's a mouthful, but
    now you can understand how complex the process of requesting a web page on the
    internet is).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，Julia 的维基百科网页可以通过 URL [https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language))
    访问。这个 URL 指的是资源 `/wiki/Julia_(programming_language)`，其表示形式，作为一个 HTML 文档，可以通过 HTTPS
    协议（`https:`）从域名是 `wikipedia.org` 的网络主机请求。（哇，这听起来很复杂，但现在你可以理解请求互联网上网页的过程是多么复杂了）。
- en: Thus, a common URL can be broken down into the following parts—`scheme://host/path?query#fragment`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个常见的 URL 可以分解为以下部分——`scheme://host/path?query#fragment`。
- en: For example, if we take a look at [https://en.wikipedia.org/wiki/Julia_(programming_language)?uselang=en#Interaction](https://en.wikipedia.org/wiki/Julia_(programming_language)?uselang=en#Interaction),
    we have `https` as the `scheme`, `en.wikipedia.org` as the `host`, `/wiki/Julia_(programming_language)` as
    the `path`, `?uselang=en` as the `query`, and, finally, `#Interaction` as the
    `fragment`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们查看[https://en.wikipedia.org/wiki/Julia_(programming_language)?uselang=en#Interaction](https://en.wikipedia.org/wiki/Julia_(programming_language)?uselang=en#Interaction)，我们有`https`作为`scheme`，`en.wikipedia.org`作为`host`，`/wiki/Julia_(programming_language)`作为`path`，`?uselang=en`作为`query`，最后，`#Interaction`作为`fragment`。
- en: Accessing the internet from Julia
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Julia 访问互联网
- en: Now that you have a good understanding of how web pages are accessed on the
    internet through client-server interactions, let's see how we can do this with
    Julia.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地理解了如何通过客户端-服务器交互在互联网上访问网页，让我们看看我们如何使用 Julia 来实现这一点。
- en: The most common web clients are the web browsers—apps such as Chrome or Firefox.
    However, these are meant to be used by human users, rendering web pages with fancy
    styled UIs and sophisticated interactions. Web scraping can be done manually through
    a web browser, it's true, but the most efficient and scalable way is through a
    fully automated, software-driven process. Although web browsers can be automated
    (with something like Selenium from [https://www.seleniumhq.org](https://www.seleniumhq.org)),
    it's a more difficult, error-prone, and resource-intensive task. For most use
    cases, the preferred approach is to use a dedicated HTTP client.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的网络客户端是网络浏览器——如 Chrome 或 Firefox 这样的应用程序。然而，这些是为人类用户设计的，它们使用花哨的样式 UI 和复杂的交互来渲染网页。虽然可以通过网络浏览器手动进行网络爬取，但最有效和可扩展的方式是通过完全自动化的、软件驱动的流程。尽管网络浏览器可以被自动化（例如使用来自
    [https://www.seleniumhq.org](https://www.seleniumhq.org) 的 Selenium），但这是一项更困难、更容易出错且资源密集的任务。对于大多数用例，首选的方法是使用专门的
    HTTP 客户端。
- en: Making requests with the HTTP package
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP 包进行请求
- en: '`Pkg`, Julia''s built-in package manager, provides access to the excellent
    `HTTP` package. It exposes a powerful functionality for building web clients and
    servers—and we''ll use it extensively.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pkg`，Julia 的内置包管理器，提供了对优秀的 `HTTP` 包的访问。它暴露了构建网络客户端和服务器的高级功能——我们将广泛使用它。'
- en: As you're already accustomed to, extra functionality is only two commands away—`pkg>
    add HTTP` and `julia> using HTTP`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经习惯的，额外的功能只需两个命令——`pkg> add HTTP` 和 `julia> using HTTP`。
- en: Recall our discussion about HTTP methods from the previous section; the most
    important ones were `GET`, used to ask for a resource from the server, and `POST`,
    which sends a data payload to the server and accepts the response. The `HTTP`
    package exposes a matching set of functions—we get access to `HTTP.get`, `HTTP.post`,
    `HTTP.delete`, `HTTP.put`, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一节关于 HTTP 方法的讨论；最重要的方法是 `GET`，用于从服务器请求资源，以及 `POST`，它将数据有效负载发送到服务器并接受响应。`HTTP`
    包暴露了一组匹配的函数——我们可以访问 `HTTP.get`、`HTTP.post`、`HTTP.delete`、`HTTP.put` 等等。
- en: 'Let''s say we want to request Julia''s Wikipedia page. All we need is the page''s
    URL and the `HTTP.get` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要请求朱莉娅的维基百科页面。我们需要的只是页面的 URL 和 `HTTP.get` 方法：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result will be a `Response` object that represents Julia''s Wikipedia page
    in all its glory. The REPL displays the headers and the first lines of the response
    body, truncating the rest:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个 `Response` 对象，它代表了朱莉娅的维基百科页面及其所有细节。REPL 显示了头部和响应主体的前几行，其余部分被截断：
- en: '![](img/40970dc4-f4d3-409d-bccf-6a67b91a9cc1.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40970dc4-f4d3-409d-bccf-6a67b91a9cc1.png)'
- en: 'The screenshot shows the details of the `HTTP.Messages.Response` object we
    received—the list of HTTP headers and the first part of the response body. Let''s
    make sure we keep it in a variable so we can reference it later. Remember that
    Julia provisionally stores the result of the last computation in the `ans` REPL
    variable, so let''s pick it up from there:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了我们所接收的 `HTTP.Messages.Response` 对象的详细信息——HTTP 头部的列表和响应主体的第一部分。让我们确保我们将其保存在变量中，以便稍后引用。记住，Julia
    将上一次计算的结果暂时存储在 `ans` REPL 变量中，所以让我们从那里获取：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Handling HTTP responses
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 HTTP 响应
- en: After receiving and processing a request, the server sends back a HTTP response
    message. These messages have a standardized structure. They contain a wealth of
    information, with the most important pieces being the status code, the headers,
    and the body.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收和处理请求后，服务器会发送一个 HTTP 响应消息。这些消息具有标准化的结构。它们包含大量信息，其中最重要的部分是状态码、头信息和主体。
- en: HTTP status codes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: 'The status code is a three-digit integer where the first digit represents the
    category, while the next two digits are used to define the subcategory. They are
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码是一个三位整数，其中第一位数字表示类别，而接下来的两位数字用于定义子类别。它们如下：
- en: '**1XX - Informational**: Request was received. This indicates a provisional
    response.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1XX - 信息性**: 请求已接收。这表示有一个临时响应。'
- en: '**2XX - Success**: This is the most important response status, acknowledging
    that the request was successfully received, understood, and accepted. It''s what
    we''re looking for in our web-mining scripts.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2XX - 成功**：这是最重要的响应状态，表示请求已被成功接收、理解和接受。这是我们网络挖掘脚本所寻找的。'
- en: '**3XX - Redirection**: This class of status codes indicates that the client
    must take additional action. It usually means that additional requests must be
    made in order to get to the resource, so our scripts will have to handle this
    scenario. We also need to actively prevent cyclical redirects. We won''t deal
    with such complex scenarios in our project, but in real-life applications, 3XX
    status codes will require specialized handling based on the subcategory.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3XX - 重定向**：这类状态码表示客户端必须采取额外行动。这通常意味着必须进行额外的请求才能到达资源，因此我们的脚本将不得不处理这种情况。我们还需要积极防止循环重定向。在我们的项目中，我们不会处理这种复杂的情况，但在实际应用中，3XX
    状态码将需要根据子类别进行专门处理。'
- en: 'Wikipedia provides a good description of the various 3XX status codes and instructions
    for what to do in each case: [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科提供了关于各种 3XX 状态码及其每种情况下应采取的操作的良好描述：[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection)。
- en: '**4XX - Client Error**: This means that we''ve probably made a mistake when
    sending our request. Maybe the URL is wrong and the resource cannot be found (`404`)
    or maybe we''re not allowed to access the page (`401` and `403` status codes).
    There''s a long list of 4XX response codes and, similar to 3XX ones, our program
    should handle the various scenarios to ensure that the requests are eventually
    successful.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4XX - 客户端错误**：这意味着我们在发送请求时可能犯了一个错误。可能是 URL 错误，资源无法找到（`404`），或者我们可能无法访问页面（`401`
    和 `403` 状态码）。4XX 响应代码有很多，类似于 3XX 代码，我们的程序应该处理各种情况，以确保请求最终成功。'
- en: '**5XX - Server Error**: Congratulations, you found or caused a problem on the
    server! Depending on the actual status code, this may or may not be actionable.
    `503` (service unavailable) or `504` (gateway timeout) are relevant as they indicate
    that we should try again later.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5XX - 服务器错误**：恭喜你，你在服务器上找到了或导致了问题！根据实际的状态码，这可能或可能不是可操作的。`503`（服务不可用）或`504`（网关超时）是相关的，因为它们表明我们应该稍后再尝试。'
- en: Learning about HTTP headers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习HTTP头信息
- en: 'HTTP headers allow the client and the server to pass additional information.
    We won''t go into the details of header transmission since Julia''s `HTTP` library
    saves us from having to deal with raw headers. However, a few are worth mentioning,
    as they are important for web scraping:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头信息允许客户端和服务器传递额外的信息。我们不会深入讨论头信息的传输细节，因为Julia的`HTTP`库帮我们避免了处理原始头信息的麻烦。然而，有一些值得提及，因为它们对于网络爬虫很重要：
- en: '`Age`, `Cache-Control`, and `Expires` represent the validity of the page and
    can be used to set data refresh times'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Age`、`Cache-Control`和`Expires`代表页面的有效性，可以用来设置数据刷新时间。'
- en: '`Last-Modified`, `Etag`, and `If-Modified-Since` can be used for content versioning,
    to check if the page has changed since it was last retrieved'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Last-Modified`、`Etag`和`If-Modified-Since`可用于内容版本控制，以检查页面自上次检索以来是否已更改。'
- en: '`Cookie` and `Set-Cookie` have to be used in order to read and write cookies
    that are required for correct communication with the server'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cookie`和`Set-Cookie`必须使用，以便读取和写入与服务器正确通信所需的cookie。'
- en: The `Content-*` family of headers, such as `Content-Disposition`, `Content-Length`,
    `Content-Type`, `Content-Encoding`, and so on, help when handling and validating
    the response message
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-*`系列头信息，例如`Content-Disposition`、`Content-Length`、`Content-Type`、`Content-Encoding`等，在处理和验证响应信息时非常有用。'
- en: Check [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
    and [https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)
    for a complete discussion on the HTTP header fields.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 查看https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers和https://en.wikipedia.org/wiki/List_of_HTTP_header_fields以获取关于HTTP头信息的完整讨论。
- en: The HTTP message body
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP消息体
- en: The message body, the most important part and the reason for web scraping (the
    content of the web page itself), is actually an optional part of the response.
    The presence of the body, its properties, and its size are specified by the `Content-*`
    family of headers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 消息体，网络爬虫最重要的部分和原因（网页本身的内容），实际上是响应的一个可选部分。是否存在消息体、其属性及其大小由`Content-*`系列头信息指定。
- en: Understanding HTTP responses
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTTP响应
- en: The result of the `HTTP.get` invocation is an object that closely mirrors a
    raw HTTP response. The package makes our lives easier by extracting the raw HTTP
    data and neatly setting it up in a data structure, which makes manipulating it
    a breeze.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTP.get`调用的结果是对象，它紧密地反映了原始HTTP响应。该包通过提取原始HTTP数据并将其整洁地设置在数据结构中，使我们的生活变得更简单，这使得操作它变得轻而易举。'
- en: 'Let''s take a look at its properties (or *fields* in Julia''s lingo):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的属性（或Julia语言中的*字段*）：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `fieldnames` function accepts a type as its argument and returns a tuple
    containing the names of the fields (or properties) of the argument. In order to
    get the type of a value, we can use the `typeof` function, like in the previous
    example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`fieldnames`函数接受一个类型作为其参数，并返回一个包含字段（或属性）名称的元组。为了获取值的类型，我们可以使用`typeof`函数，就像前面的例子一样。'
- en: Right! The `status`, `headers`, and `body` fields should by now sound familiar.
    The `version` field represents the version of the HTTP protocol (the `HTTP/1.1` part
    in the first line of the response). Most web servers on the internet today use
    version 1.1 of the protocol, but a new major version, 2.0, is almost ready for
    wide deployment. Finally, the `request` field holds a reference to the `HTTP.Messages.Request`
    object that triggered the current response.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对了！到如今，`status`、`headers`和`body`字段应该听起来很熟悉。`version`字段表示HTTP协议的版本（响应第一行中的`HTTP/1.1`部分）。今天互联网上的大多数Web服务器都使用协议的1.1版本，但一个新的主要版本2.0几乎准备广泛部署。最后，`request`字段包含触发当前响应的`HTTP.Messages.Request`对象的引用。
- en: The status code
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态码
- en: 'Let''s take a closer look at the status code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看状态码：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sure enough, we got back a valid response, hereby confirmed by the `200` status
    code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们得到了一个有效的响应，这通过`200`状态码得到了确认。
- en: The headers
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头信息
- en: 'What about the headers? As already mentioned, they contain critical information
    indicating whether a message body is present. Let''s check them out:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于头信息呢？如前所述，它们包含指示消息体是否存在的重要信息。让我们来看看：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/3f152978-7e46-46bd-b503-682191cc7121.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f152978-7e46-46bd-b503-682191cc7121.png)'
- en: Your output will be different in regard to some of the values, but it should
    be easy to spot the key HTTP headers we mentioned before. `Content-Length` confirms
    the presence of a response body. The `Content-Type` provides information about
    how to interpret the encoding of the message body (it's a HTML document using
    UTF-8 character encoding). And we can use the `Last-Modified` value to optimize
    the caching and the update frequency of our web crawler.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出在有些值上可能会有所不同，但应该很容易找到我们之前提到的关键HTTP头。`Content-Length`确认了响应体的存在。`Content-Type`提供了关于如何解释消息体编码的信息（它是一个使用UTF-8字符编码的HTML文档）。我们可以使用`Last-Modified`值来优化我们的网络爬虫的缓存和更新频率。
- en: The message body
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息体
- en: 'Since we just confirmed that we have a response body, let''s see it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确认我们有一个响应体，让我们看看它：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Oops, that doesn''t look like the web page we were expecting. No worries though,
    these are the bytes of the raw response—which we can easily convert to a human-readable
    HTML string. Remember that I mentioned the `String` method when learning about
    strings? Well, this is where it comes in handy:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这看起来不像我们预期的网页。不过别担心，这些是原始响应的字节——我们可以轻松地将它们转换为可读的HTML字符串。记得我提到过学习字符串时的`String`方法吗？嗯，这就是它派上用场的地方：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Your REPL should now be outputting a long HTML string that represents Julia's
    Wikipedia page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您的REPL现在应该正在输出一个代表Julia维基百科页面的长HTML字符串。
- en: 'If we take a look at the first `500` characters, we''ll start to see familiar
    patterns:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看前`500`个字符，我们开始看到熟悉的模式：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/8aa4f988-cd12-4e2b-b699-c9e9fa77d70f.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8aa4f988-cd12-4e2b-b699-c9e9fa77d70f.png)'
- en: 'Sure enough, using Chrome''s view page source will reveal the same HTML:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，使用Chrome的查看页面源代码将揭示相同的HTML：
- en: '![](img/837384ea-fd70-4459-80ae-71b4b2f99c81.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/837384ea-fd70-4459-80ae-71b4b2f99c81.png)'
- en: It's confirmed—we just took our first successful step toward building our web
    crawler!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 已经确认了——我们刚刚迈出了建立我们的网络爬虫的第一步！
- en: Learning about pairs
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解关于`Pair`的知识
- en: 'While looking at the response header, you might''ve noticed that its type is
    an `Array` of `Pair` objects:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看响应头时，您可能已经注意到它的类型是一个`Array`的`Pair`对象：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A `Pair` represents a Julia data structure—and the corresponding type. The `Pair`
    contains a couple of values that are generally used to reference key-value relationships.
    The types of the two elements determine the concrete type of the `Pair`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pair`代表一个Julia数据结构及其对应的类型。`Pair`包含一些值，通常用于引用键值关系。两个元素的类型决定了`Pair`的具体类型。'
- en: 'For example, we can construct a `Pair` with the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以用以下方式构造一个`Pair`：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we check its type we''ll see that it''s a `Pair` of `Symbol` and `String`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查它的类型，我们会看到它是一个`Symbol`和`String`的`Pair`：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also create `Pairs` by using the `x => y` literal notation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用`x => y`字面量表示法来创建`Pairs`：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `=>` double arrow should look familiar. It''s what we saw in the response
    header, for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`=>`双箭头应该很熟悉。这是我们之前在响应头中看到的，例如：'
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Obviously, once created, it is possible to access the values stored in a `Pair`.
    One way to do it is by indexing into it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一旦创建，就可以访问存储在`Pair`中的值。一种方法是通过索引它：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also access the `first` and `second` fields in order to get to the `first`
    and `second` values, respectively:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以访问`first`和`second`字段，分别获取`first`和`second`值：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Just like the tuples, the `Pairs` are immutable, so this won''t work:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像元组一样，`Pairs`是不可变的，所以这不会起作用：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Pairs` are one of the building blocks of Julia and can be used, among other
    things, for creating dictionaries, one of the most important types and data structures.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pairs`是Julia的构建块之一，可以用于创建字典，这是最重要的类型之一和数据结构。'
- en: Dictionaries
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: The dictionary, called `Dict`, is one of Julia's most powerful and versatile
    data structures. It's an associative collection—it *associates *keys with values.
    You can think of a `Dict` as a look-up table implementation—given a single piece
    of information, the key, it will return the corresponding value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 字典，称为`Dict`，是Julia最强大和多功能的数据结构之一。它是一个关联集合——它将键与值相关联。您可以将`Dict`视为查找表实现——给定一个单一的信息，即键，它将返回相应的值。
- en: Constructing dictionaries
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建字典
- en: 'Creating an empty instance of a `Dict` is as simple as the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的`Dict`实例就像以下这样：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The information between the curly brackets, `{Any,Any}`, represents the types
    of keys and values of the `Dict`. Thus, the concrete type of a `Dict` itself is
    defined by the type of its keys and values. The compiler will do its best to infer
    the type of the collection from the types of its parts. In this case, since the
    dictionary was empty, no information could be inferred, so Julia defaulted to
    `Any` and `Any`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号内的信息`{Any,Any}`表示`Dict`的键和值的类型。因此，`Dict`本身的具体类型由其键和值的类型定义。编译器将尽最大努力从其部分类型推断集合的类型。在这种情况下，由于字典为空，无法推断信息，因此Julia默认为`Any`和`Any`。
- en: 'An `{Any,Any}` type of `Dict` allows us to add any kind of data, indiscriminately.
    We can use the `setindex!` method to add a new key-value pair to the collection:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`{Any,Any}`类型的`Dict`允许我们添加任何类型的数据，不加区分。我们可以使用`setindex!`方法向集合中添加新的键值对：'
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, adding values to a `Dict` is routinely done using the square bracket
    notation (which is similar to indexing into it, while also performing an assignment):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，向`Dict`中添加值通常使用方括号符号（这与对其索引类似，同时执行赋值操作）：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Till now, we''ve only added `Strings`—but like I said, because our `Dict` accepts
    any kind of keys and value, there aren''t any constraints:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只添加了`Strings`——但正如我所说的，因为我们的`Dict`接受任何类型的键和值，所以没有约束：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is our `Dict` now:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们的`Dict`：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the key `=>` value pairs are not in the order in which we added them.
    `Dicts` are not ordered collections in Julia. We'll talk more about this in a
    few paragraphs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，键`=>`值对不是我们添加它们的顺序。在Julia中，`Dict`不是有序集合。我们将在接下来的几段中更多地讨论这一点。
- en: 'If the key already exists, the corresponding value will be updated, returning
    the new value:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键已存在，相应的值将被更新，返回新值：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s our updated `Dict`. Note that `"Hello"` now points to `"Earth"` and
    not `"World"`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的更新后的`Dict`。注意，现在`"Hello"`指向`"Earth"`而不是`"World"`：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we provide some initial data when instantiating the `Dict`, the compiler
    will be able to do better at identifying the types:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在实例化`Dict`时提供一些初始数据，编译器将能够更好地识别类型：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see that the type of the `Dict` is now constraining the keys to be `String`,
    and the values to be `Int`—which are the types of the `Pair` we used to instantiate
    the `Dict`. Now, if a different type is passed for a key or a value, Julia will
    attempt to convert it—if that fails, an error will occur:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`Dict`的类型现在限制了键必须是`String`，值必须是`Int`——这是我们用来实例化`Dict`的`Pair`的类型。现在，如果传递了不同类型的键或值，Julia将尝试转换它——如果失败，将发生错误：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In some instances, the automatic conversion works:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，自动转换是有效的：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Julia has silently converted `2.0` to the corresponding `Int` value:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Julia已静默地将`2.0`转换为相应的`Int`值：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But that won''t always work:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不总是有效：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can store randomly complex data in a `Dict` and its type will be correctly
    inferred by Julia:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Dict`中存储随机复杂的数据，Julia会正确推断其类型：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also specify and constrain the type of `Dict` upon constructing it,
    instead of leaving it up to Julia:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在构建时指定和约束`Dict`的类型，而不是让Julia来决定：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we can see how the type definition overruled the type of the `2.0` value,
    which is a `Float64` (of course, as in the previous example, Julia has converted
    `2.0` to its integer counterpart).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到类型定义如何覆盖了`2.0`值（这是一个`Float64`类型，当然，如前例所示，Julia已将`2.0`转换为它的整数等价物）。
- en: 'We can also use `Pairs` to create a `Dict`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Pairs`来创建`Dict`：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also use an `Array` of `Pair`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Pair`的数组：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can do the same with arrays of tuples:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用元组的数组来做同样的事情：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, a `Dict` can be constructed using comprehensions:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用列表推导式来构建`Dict`：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Your output will be different as it's likely that the keys won't be ordered
    from `1` to `7`. That's a very important point—as already mentioned, in Julia,
    the `Dict` is not ordered.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出可能会有所不同，因为键可能不会按`1`到`7`的顺序排列。这是一个非常重要的观点——如前所述，在Julia中，`Dict`是无序的。
- en: Ordered dictionaries
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有序字典
- en: 'If you ever need your dictionaries to stay ordered, you can use the `OrderedCollections` package
    ([https://github.com/JuliaCollections/ OrderedCollections.jl](https://github.com/JuliaCollections/%20OrderedCollections.jl)),
    specifically the `OrderedDict`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要您的字典保持有序，可以使用`OrderedCollections`包（[https://github.com/JuliaCollections/OrderedCollections.jl](https://github.com/JuliaCollections/OrderedCollections.jl)），特别是`OrderedDict`：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now the elements are stored in the order in which they are added to the collection
    (from `1` to `12`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在元素是按照它们添加到集合中的顺序存储的（从 `1` 到 `12`）。
- en: Working with dictionaries
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与字典一起工作
- en: 'As we''ve already seen, we can index into a `Dict` using the square bracket
    notation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，我们可以使用方括号符号索引 `Dict`：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Attempting to access a key that has not been defined will result in a `KeyError`,
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问一个未定义的键将导致 `KeyError`，如下所示：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To avoid such situations, we can check if the key exists in the first place:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们可以检查键是否首先存在：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As an alternative, if we want to also get a default value when the key does
    not exist, we can use the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方法，如果我们想在键不存在时也获取默认值，我们可以使用以下方法：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `get` function has a more powerful twin, `get!`, which also stores the
    searched key into the `Dict`, using the default value:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 函数有一个更强大的双胞胎，`get!`，它也会将搜索到的键存储到 `Dict` 中，使用默认值：'
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In case you're wondering, the exclamation mark at the end of the function name
    is valid—and denotes an important Julia naming convention. It should be taken
    as a warning that using the function will modify its arguments' data. In this
    case, the `get!` function will add the `:baz = 100` `Pair` to the `d` `Dict`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想，函数名末尾的感叹号是有效的——它表示一个重要的 Julia 命名约定。这应该被视为一个警告，即使用该函数将修改其参数的数据。在这种情况下，`get!`
    函数将添加 `:baz = 100` 的 `Pair` 到 `d` 的 `Dict` 中。
- en: 'Removing a key-value `Pair` is just a matter of invoking `delete!` (note the
    presence of the exclamation mark here too):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 删除键值 `Pair` 只需调用 `delete!`（注意这里也有感叹号的存在）：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As requested, the `:baz` key and its corresponding value have vanished.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如请求所示，`:baz` 键及其对应值已经消失。
- en: 'We can ask for the collections of keys and values using the aptly named functions
    `keys` and `values`. They will return iterators over their underlying collections:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用名为 `keys` 和 `values` 的函数请求键和值的集合。它们将返回它们底层集合的迭代器：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use `collect` to retrieve the corresponding arrays:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `collect` 获取相应的数组：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can combine a `Dict` with another `Dict`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个 `Dict` 与另一个 `Dict` 结合：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If some of the keys are present in multiple dictionaries, the values from the
    last collection will be preserved:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一些键在多个字典中存在，则将保留最后一个集合中的值：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Using the HTTP response
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP 响应
- en: Armed with a good understanding of Julia's dictionary data structure, we can
    now take a closer look at the `headers` property of `resp`, our `HTTP` response
    object.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 Julia 的字典数据结构之后，我们现在可以更仔细地查看 `resp` 的 `headers` 属性，我们的 `HTTP` 响应对象。
- en: 'To make it easier to access the various headers, first let''s convert the array
    of `Pair` to a `Dict`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易访问各种标题，首先让我们将 `Pair` 数组转换为 `Dict`：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can check the `Content-Length` value to determine whether or not we have
    a response body. If it''s larger than `0`, that means we got back a HTML message:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查 `Content-Length` 值以确定是否有响应体。如果它大于 `0`，这意味着我们收到了一个 HTML 消息：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It''s important to remember that all the values in the `headers` dictionary
    are strings, so we can''t go comparing them straight away:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，`headers` 字典中的所有值都是字符串，因此我们不能直接比较它们：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''ll need to parse it into an integer first:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先将其解析为整数：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Manipulating the response body
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作响应体
- en: Earlier, we read the response body into a `String` and stored it into the `resp_body`
    variable. It's a long HTML string and, in theory, we could use `Regex` and other
    string-processing functions to find and extract the data that we need. However,
    such an approach would be extremely complicated and error-prone. The best way
    to search for content in a HTML document is via HTML and CSS selectors. The only
    problem is that these selectors don't operate on strings—they only work against
    a **Document Object Model** (**DOM**).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们将响应体读入一个 `String` 并存储在 `resp_body` 变量中。它是一个长的 HTML 字符串，从理论上讲，我们可以使用 `Regex`
    和其他字符串处理函数来查找和提取我们所需的数据。然而，这种方法将非常复杂且容易出错。在 HTML 文档中搜索内容最好的方法是使用 HTML 和 CSS 选择器。唯一的问题是这些选择器不作用于字符串——它们只对
    **文档对象模型**（**DOM**）起作用。
- en: Building a DOM representation of the page
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建页面 DOM 表示
- en: The DOM represents an in-memory structure of an HTML document. It is a data
    structure that allows us to programmatically manipulate the underlying HTML elements.
    The DOM represents a document as a logical tree, and we can use selectors to traverse
    and query this hierarchy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: DOM代表HTML文档的内存结构。它是一种数据结构，允许我们以编程方式操作底层HTML元素。DOM将文档表示为一个逻辑树，我们可以使用选择器来遍历和查询这个层次结构。
- en: Parsing HTML with Gumbo
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gumbo解析HTML
- en: Julia's `Pkg` ecosystem provides access to `Gumbo`, a HTML parser library. Provided
    with a HTML string, `Gumbo` will parse it into a document and its corresponding
    DOM. This package is an important tool for web scraping with Julia, so let's add
    it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的`Pkg`生态系统提供了对`Gumbo`的访问，这是一个HTML解析库。提供HTML字符串后，`Gumbo`会将其解析成文档及其对应的DOM。这个包是使用Julia进行网络爬取的重要工具，所以让我们添加它。
- en: 'As usual, install using the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，使用以下命令安装：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We''re now ready to parse the HTML string into a DOM as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将HTML字符串解析成DOM，如下所示：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `dom` variable now references a `Gumbo.HTMLDocument`, an in-memory Julia
    representation of the web page. It''s a simple object that has only two fields:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`dom`变量现在引用了一个`Gumbo.HTMLDocument`，这是网页的内存中Julia表示。它是一个只有两个字段的简单对象：'
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `doctype` represents the HTML `<!DOCTYPE html>` element, which is what
    the Wikipedia page uses:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctype`代表HTML的`<!DOCTYPE html>`元素，这是维基百科页面使用的：'
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let''s focus on the `root` property. This is effectively the outermost
    element of the HTML page—the `<html>` tag containing the rest of the elements.
    It provides us with an entry point into the DOM. We can ask `Gumbo` about its
    attributes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注`root`属性。这实际上是HTML页面的最外层元素——包含其余元素的`<html>`标签。它为我们提供了进入DOM的入口点。我们可以询问`Gumbo`它的属性：
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It''s a `Dict`, the keys representing HTML attributes and the values—the attributes''
    values. And sure enough, they match the page''s HTML:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个`Dict`，键代表HTML属性，值是属性的值。确实，它们与页面的HTML相匹配：
- en: '![](img/c0902ff6-5eb5-4e1e-9b3f-e3f3d130e397.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0902ff6-5eb5-4e1e-9b3f-e3f3d130e397.png)'
- en: 'There''s also a similar `attrs` method, which serves the same purpose:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个类似的`attrs`方法，它具有相同的作用：
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When in doubt, we can just ask about the name of an element using the `tag` method:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当不确定时，我们可以使用`tag`方法来询问元素的名称：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`Gumbo` exposes a `children` method which returns an array containing all the
    nested `HTMLElement`. If you just go ahead and execute `julia> children(dom.root)`,
    the REPL output will be hard to follow. The REPL representation of an `HTMLElement`
    is its HTML code, which, for top-level elements with many children, will fill
    up many Terminal screens. Let''s use a `for` loop to iterate over the children
    and show just their tags:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gumbo`提供了一个`children`方法，它返回一个包含所有嵌套`HTMLElement`的数组。如果你直接执行`julia> children(dom.root)`，REPL的输出将难以跟踪。`HTMLElement`的REPL表示是其HTML代码，对于具有许多子元素的最高层元素，它将填满许多终端屏幕。让我们使用`for`循环遍历子元素并仅显示它们的标签：'
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Much better!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！
- en: 'Since the children are part of a collection, we can index into them:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子元素是集合的一部分，我们可以对它们进行索引：
- en: '[PRE65]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Please note the closing semicolon (`;`). When used in the REPL at the end of
    an expression, it will suppress the output (so we won''t see the very long HTML
    code of the `<body>` that would otherwise be output). The `body` variable will
    now reference an instance of `HTMLElement{:body}`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意分号（`;`）的用法。当在REPL（Read-Eval-Print Loop，即交互式解释器）的语句末尾使用时，它会抑制输出（因此我们不会看到其他情况下会输出的非常长的`<body>`
    HTML代码）。现在`body`变量将引用一个`HTMLElement{:body}`的实例：
- en: '[PRE66]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The last method that we''ll need is `getattr`, which returns the value of an
    attribute name. If the attribute is not defined for the element, it raises a `KeyError`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个方法是`getattr`，它返回属性名称的值。如果元素没有定义该属性，它将引发一个`KeyError`：
- en: '[PRE67]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Asking about the `href` attribute of a `<html>` tag doesn't make any sense.
    And sure enough, we promptly got a `KeyError`, since `href` was not an attribute
    of this `HTMLElement`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 询问`<html>`标签的`href`属性没有意义。果然，我们很快得到了一个`KeyError`，因为`href`不是这个`HTMLElement`的属性。
- en: Coding defensively
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码防御性
- en: An error like the previous one, when part of a larger script, has the potential
    to completely alter a program's execution, leading to undesired and potentially
    costly results. In general, when something unexpected occurs during the execution
    of a program, it may leave the software in an erroneous state, making it impossible
    to return a correct value. In such cases, rather than pushing on and potentially
    propagating the problem throughout the whole execution stack, it's preferable
    to explicitly notify the calling code about the situation by throwing an `Exception`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前的错误一样，当它是更大脚本的一部分时，有可能完全改变程序的执行，导致不希望的结果，甚至可能造成损失。一般来说，当程序执行过程中发生意外时，它可能会使软件处于错误状态，使得无法返回正确的值。在这种情况下，而不是继续执行并可能在整个执行堆栈中传播问题，最好通过抛出
    `Exception` 明确通知调用代码关于这种情况。
- en: Many functions, both in Julia's core and within third-party packages, make good
    use of the error-throwing mechanism. It's good practice to check the docs for
    the functions you use and to see what kinds of errors they throw. An error is
    called an exception in programming lingo.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数，无论是 Julia 的核心函数还是第三方包中的函数，都很好地使用了错误抛出机制。检查你使用的函数的文档并查看它们抛出什么类型的错误是一个好习惯。在编程术语中，错误被称为异常。
- en: As in the case of `getattr`, the author of the `Gumbo` package warned us that
    attempting to read an attribute that was not defined would result in a `KeyError`
    exception. We'll learn soon how to handle exceptions by capturing them in our
    code, getting info about the problem, and stopping or allowing the exception to
    propagate further up the call stack. Sometimes it's the best approach, but it's
    not a technique we want to abuse since handling errors this way can be resource-intensive.
    Dealing with exceptions is considerably slower than performing simple data integrity
    checks and branching.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `getattr` 的情况一样，`Gumbo` 包的作者警告我们，尝试读取未定义的属性将导致 `KeyError` 异常。我们将很快学习如何通过在代码中捕获异常、获取有关问题的信息以及停止或允许异常进一步向上传播调用堆栈来处理异常。有时这是最好的方法，但我们不希望过度使用这种方法，因为以这种方式处理错误可能会消耗大量资源。处理异常比执行简单的数据完整性检查和分支要慢得多。
- en: 'For our project, the first line of defense is to simply check if the attribute
    is in fact defined in the element. We can do this by retrieving the keys of the
    attributes `Dict` and checking if the one we want is part of the collection. It''s
    a one-liner:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，第一道防线是简单地检查属性是否确实定义在元素中。我们可以通过检索属性 `Dict` 的键并检查我们想要的键是否是集合的一部分来实现这一点。这是一个单行代码：
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Clearly, `href` is not an attribute of the `<html>` tag.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`href` 不是 `<html>` 标签的属性。
- en: Using this approach, we can easily write logic to check for the existence of
    an attribute before we attempt to look up its value.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以在尝试查找属性值之前轻松地编写逻辑来检查属性的存在。
- en: The pipe operator
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道操作符
- en: Reading multiple nested functions can be taxing on the brain. The previous example,
    `collect(keys(attrs(dom.root)))`, can be rewritten to improve readability using
    Julia's pipe operator, `|>`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读多层嵌套函数可能会对大脑造成负担。上一个例子 `collect(keys(attrs(dom.root)))` 可以使用 Julia 的管道操作符
    `|>` 重新编写以提高可读性。
- en: 'For example, the following snippet nests three function calls, each inner function
    becoming the argument of the outermost one:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段嵌套了三个函数调用，每个内部函数都成为最外层函数的参数：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This can be rewritten for improved readability as a chain of functions using
    the pipe operator. This code produces the exact same result:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用管道操作符将函数链式调用重写以提高可读性。这段代码会产生完全相同的结果：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: What the `|>` operator does is that it takes the output of the first value and
    *pipes* it as the argument of the next function. So `dom.root |> attrs` is identical
    to `attrs(dom.root)`. Unfortunately, the pipe operator works only for one-argument
    functions. But it's still very useful for decluttering code, massively improving
    readability.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`|>` 操作符的作用是取第一个值的输出，并将其作为下一个函数的参数。所以 `dom.root |> attrs` 等同于 `attrs(dom.root)`。不幸的是，管道操作符仅适用于单参数函数。但它在清理代码、大幅提高可读性方面仍然非常有用。'
- en: For more advanced piping functionality you can check out the `Lazy` package,
    specifically `@>` and `@>>` at [https://github.com/MikeInnes/Lazy.jl#macros.](https://github.com/MikeInnes/Lazy.jl#macros)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的管道功能，你可以查看 `Lazy` 包，特别是 `@>` 和 `@>>`，请参阅 [https://github.com/MikeInnes/Lazy.jl#macros](https://github.com/MikeInnes/Lazy.jl#macros)。
- en: Handling errors like a pro
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像专业人士一样处理错误
- en: Sometimes, coding defensively won't be the solution. Maybe a key part of your
    program requires reading a file on the network or accessing a database. If the
    resource can't be accessed due to a temporary network failure, there's really
    not much you can do in the absence of the data.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，编写防御性代码可能不是解决方案。也许你的程序的关键部分需要从网络上读取文件或访问数据库。如果由于临时网络故障无法访问资源，在没有数据的情况下，你实际上真的无能为力。
- en: The try...catch statements
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try...catch语句
- en: If you identify parts of your code where you think the execution can go off
    the rails due to conditions that are out of your control (that is, *exceptional*
    conditions—hence the name *exception*), you can use Julia's `try...catch` statements.
    This is exactly what it sounds like—you instruct the compiler to *try* a piece
    of code and if, as a result of a problem, an exception is *thrown**,* to *catch*
    it. The fact that an exception is *caught* implies that it won't propagate throughout
    the whole application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定你的代码中某些部分可能会因为超出你控制的条件（即*异常*条件——因此得名*异常*）而执行偏离轨道，你可以使用Julia的`try...catch`语句。这正是它的名字——你指示编译器*尝试*一段代码，如果由于问题而抛出异常，就*捕获*它。异常被捕获的事实意味着它不会在整个应用程序中传播。
- en: 'Let''s see it in action:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE71]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this example, once an error is encountered, the execution of the code in
    the `try` branch is stopped exactly at that point, and the execution flow continues
    right away, in the `catch` branch.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一旦遇到错误，`try`分支中的代码执行就会在 exactly 那个点停止，并且立即在`catch`分支中继续执行。
- en: 'It becomes clearer if we modify the snippet as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按如下方式修改代码片段，就会更清晰：
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The newly added line, `println("I'm here too")`, is not executed, as demonstrated
    by the fact that the message is not output.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加的行`println("I'm here too")`没有执行，正如消息没有输出的事实所证明的那样。
- en: 'Of course, things change if no exception is thrown:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有抛出异常，事情就会变得清晰：
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `catch` construct takes an optional argument, the `Exception` object that's
    been thrown by the `try` block. This allows us to inspect the exception and branch
    our code depending on its properties.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`构造函数接受一个可选参数，即由`try`块抛出的`Exception`对象。这允许我们检查异常并根据其属性分支我们的代码。'
- en: 'In our example, the `KeyError` exception is built into Julia. It is thrown
    when we attempt to access or delete a non-existent element (such as a key in a
    `Dict` or an attribute of a `HTMLElement`). All instances of `KeyError` have a
    key property, which provides information about the missing data. Thus, we can
    make our code more generic:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`KeyError`异常是Julia内置的。当我们尝试访问或删除一个不存在的元素（例如`Dict`中的键或`HTMLElement`的属性）时，会抛出`KeyError`异常。所有`KeyError`实例都有一个键属性，它提供了有关缺失数据的信息。因此，我们可以使我们的代码更加通用：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here, we pass the exception into the `catch` block as the `ex` variable. We
    then check if we''re dealing with a `KeyError` exception—if we are, we use this
    information to display a custom error by accessing the `ex.key` field to retrieve
    the missing key. If it''s a different type of exception, we show a generic error
    message:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将异常作为`ex`变量传递到`catch`块中。然后我们检查是否处理的是`KeyError`异常——如果是，我们使用这个信息通过访问`ex.key`字段来检索缺失的键来显示自定义错误。如果它是一种不同类型的异常，我们显示一个通用的错误消息：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The finally clause
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: finally子句
- en: In code that performs state changes or uses resources such as files or databases,
    there is typically some clean-up work (such as closing files or database connections)
    that needs to be done when the code is finished. This code would normally go into
    the `try` branch—but what happens if an exception is thrown?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行状态改变或使用文件或数据库等资源的代码中，通常需要在代码完成后进行一些清理工作（例如关闭文件或数据库连接）。这段代码通常会进入`try`分支——但是，如果抛出了异常会发生什么呢？
- en: 'In such cases, the `finally` clause comes into play. This can be added after
    a `try` or after a `catch` branch. The code within the `finally` block is *guaranteed*
    to be executed, regardless of whether exceptions are thrown or not:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`finally`子句就派上用场了。这可以在`try`之后或`catch`分支之后添加。`finally`块中的代码将被**保证**执行，无论是否抛出异常：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'It is illegal to have a `try` without a `catch` or a `finally`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`catch`或`finally`的`try`是非法的：
- en: '[PRE77]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We need to provide either a `catch` or a `finally` block (or both).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个`catch`或`finally`块（或两者都提供）。
- en: 'The `try/catch/finally` blocks will return the last expression evaluated, so
    we can capture it in a variable:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`try/catch/finally`块将返回最后评估的表达式，因此我们可以将其捕获到变量中：'
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Throwing exceptions on errors
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在错误上抛出异常
- en: As developers, we too have the option to create and throw exceptions when our
    code encounters a problem and shouldn't continue. Julia provides a long list of
    built-in exceptions that cover a multitude of use cases. You can read about them
    at [https://docs.julialang.org/en/stable/manual/control-flow/#Built-in-Exceptions-1](https://docs.julialang.org/en/stable/manual/control-flow/#Built-in-Exceptions-1).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，当我们的代码遇到问题且不应继续执行时，我们也有创建和抛出异常的选项。Julia提供了一系列内置异常，涵盖了多种用例。您可以在[https://docs.julialang.org/en/stable/manual/control-flow/#Built-in-Exceptions-1](https://docs.julialang.org/en/stable/manual/control-flow/#Built-in-Exceptions-1)上了解它们。
- en: 'In order to throw an exception, we use the aptly named `throw` function. For
    example, if we want to replicate the error raised by Gumbo''s `getattr` method,
    all we have to do is call the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抛出异常，我们使用名为`throw`的函数。例如，如果我们想复制Gumbo的`getattr`方法引发的错误，我们只需调用以下操作：
- en: '[PRE79]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If the built-in exceptions provided by Julia aren''t relevant enough for your
    situation, the language provides a generic error type, the `ErrorException`. It
    takes an additional `msg` argument which should offer more details about the nature
    of the error:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Julia提供的内置异常对于您的情况来说不够相关，该语言提供了一个通用的错误类型，即`ErrorException`。它接受一个额外的`msg`参数，该参数应提供更多关于错误本质的详细信息：
- en: '[PRE80]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Julia provides a shortcut for throwing `ErrorException`, the `error` function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了抛出`ErrorException`的快捷方式，即`error`函数：
- en: '[PRE81]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Rethrowing exceptions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新抛出异常
- en: But what do we do if we realize that the exception we've caught cannot (or should
    not) be handled by our code? For example, say we were expecting to catch a possible
    missing attribute, but it turned out we got a `Gumbo` parsing exception instead.
    Such an issue would have to be handled higher up the execution stack, maybe by
    trying to fetch the web page again and reparsing it, or by logging an error message
    for the admin.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们意识到我们捕获的异常无法（或不应）由我们的代码处理怎么办？例如，假设我们预计会捕获一个可能缺失的属性，但结果我们得到了一个`Gumbo`解析异常。这种问题必须在上层的执行堆栈中处理，可能尝试再次获取网页并重新解析，或者为管理员记录一个错误信息。
- en: 'If we `throw` the exception ourselves, the origin (the `stacktrace`) of the
    initial error would be lost. For such cases, Julia provides the `rethrow` function,
    which can be used as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们自行`throw`异常，初始错误的来源（堆栈跟踪）将会丢失。对于这种情况，Julia提供了`rethrow`函数，可以使用如下方式：
- en: '[PRE82]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If we simply throw the exception ourselves, this is what happens:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简单地自行抛出异常，这就是会发生的情况：
- en: '[PRE83]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We throw the `KeyError` exception, but the origin of the exception is lost;
    it appears as if it originates in our code in the `catch` block. Contrast this
    with the following example, where we use `rethrow`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们抛出`KeyError`异常，但异常的来源丢失；它看起来像是在我们的代码的`catch`块中产生的。与以下示例进行对比，其中我们使用了`rethrow`：
- en: '[PRE84]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The original exception is being rethrown, without changing the stacktrace. Now
    we can see that the exception originated within the `dict.jl` file.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 原始异常正在被重新抛出，而不改变堆栈跟踪。现在我们可以看到异常起源于`dict.jl`文件。
- en: Learning about functions
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习函数
- en: Before we get to write our first full-fledged Julia program, the web crawler,
    we need to take yet another important detour. It's the last one, I promise.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写第一个完整的Julia程序（网络爬虫）之前，我们还需要进行另一个重要的转折。这是最后一个，我保证。
- en: As our code becomes more and more complex, we should start using functions.
    The REPL is great for exploratory programming due to its quick input-output feedback
    loop, but for any non-trivial piece of software, using functions is the way to
    go. Functions are an integral part of Julia, promoting readability, code reuse,
    and performance.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码变得越来越复杂，我们应该开始使用函数。REPL由于其快速输入输出反馈循环，非常适合探索性编程，但对于任何非平凡的软件，使用函数是最佳选择。函数是Julia的核心部分，它促进了可读性、代码重用和性能。
- en: 'In Julia, a function is an object that takes a tuple of values as an argument
    and returns a value:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，一个函数是一个对象，它接受一个值元组作为参数并返回一个值：
- en: '[PRE85]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'There''s also a compact *assignment form* for function declaration:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数声明，还有一个紧凑的*赋值形式*：
- en: '[PRE86]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This second form is great for simple one-line functions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第二种形式非常适合简单的单行函数。
- en: 'Invoking a function is simply a matter of calling its name and passing it the
    required arguments:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数只是简单地调用它的名字并传递所需的参数：
- en: '[PRE87]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The return keyword
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回关键字
- en: If you have previous programming experience, you might be surprised to see that
    invoking the `add` function correctly returns the expected value, despite the
    fact that we didn't put any explicit `return` statement in the function's body.
    In Julia, a function automatically returns the result of the last expression that
    was evaluated. This is usually the last expression in the body of the function.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有过编程经验，你可能会惊讶地看到，尽管我们没有在函数体中放置任何显式的`return`语句，调用`add`函数仍然可以正确地返回预期的值。在Julia中，函数会自动返回最后一个评估的表达式的结果。这通常是函数体中的最后一个表达式。
- en: 'An explicit `return` keyword is also available. Using it will cause the function
    to exit immediately, with the value passed to the `return` statement:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的`return`关键字也是可用的。使用它将导致函数立即退出，并将传递给`return`语句的值返回：
- en: '[PRE88]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Returning multiple values
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回多个值
- en: 'Although Julia does not support returning multiple values, it does offer a
    neat trick that''s very close to the actual thing. Any function can return a tuple.
    And because constructing and destructing tuples is very flexible, this approach
    is very powerful and readable:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Julia不支持返回多个值，但它确实提供了一个非常接近实际操作的巧妙技巧。任何函数都可以返回一个元组。由于元组的构造和析构非常灵活，这种方法非常强大且易于阅读：
- en: '[PRE89]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Here we defined a function, `addremove`, which returns a tuple of two integers.
    We can extract the values within the tuple by simply assigning a variable corresponding
    to each of its elements.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`addremove`的函数，它返回一个包含两个整数的元组。我们可以通过简单地给每个元素分配一个变量来提取元组内的值。
- en: Optional arguments
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选参数
- en: 'Function arguments can have sensible defaults. For such situations, Julia allows
    defining default values. When they are provided, the corresponding arguments no
    longer have to be passed explicitly on every call:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数可以有合理的默认值。在这种情况下，Julia允许定义默认值。当它们被提供时，相应的参数在每次调用时不再需要显式传递：
- en: '[PRE90]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This function has default values for both `x` and `y`. We can invoke it without
    passing any of the arguments:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数为`x`和`y`都设置了默认值。我们可以不传递任何参数来调用它：
- en: '[PRE91]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This snippet demonstrates how Julia uses the default values when they are not
    provided upon function invocation.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段演示了当在函数调用时没有提供默认值时，Julia如何使用默认值。
- en: 'We can pass the first argument only—and for the second one, the default value
    will be used:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能传递第一个参数——对于第二个参数，将使用默认值：
- en: '[PRE92]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, we can pass both arguments; all the defaults will be overwritten:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以传递两个参数；所有默认值都将被覆盖：
- en: '[PRE93]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Keyword arguments
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字参数
- en: The functions that require a long list of arguments can be hard to use, as the
    programmer has to remember the order and the types of the expected values. For
    such cases, we can define functions that accept labeled arguments instead. These
    are called **keyword arguments**.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 需要长列表参数的函数可能难以使用，因为程序员必须记住期望值的顺序和类型。对于这种情况，我们可以定义接受标记参数的函数。这些被称为**关键字参数**。
- en: 'In order to define functions that accept keyword arguments, we need to add
    a semicolon after the function''s list of unlabeled arguments and follow it with
    one or more `keyword=value` pairs. We actually encountered such functions in [Chapter
    2](b9056286-1d26-4cb4-bf90-bdc76722b3fb.xhtml), *Creating Our First Julia App*,
    when we used `Gadfly` to plot the Iris flower dataset:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义接受关键字参数的函数，我们需要在函数未标记参数列表之后添加一个分号，并跟随着一个或多个`keyword=value`对。实际上，我们在[第2章](b9056286-1d26-4cb4-bf90-bdc76722b3fb.xhtml)，*创建我们的第一个Julia应用程序*时遇到了这样的函数，当时我们使用`Gadfly`绘制了鸢尾花数据集：
- en: '[PRE94]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this example, `x`, `y`, and `color` are all keyword arguments.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`x`、`y`和`color`都是关键字参数。
- en: 'The definition of a function with keyword arguments looks like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数函数的定义如下：
- en: '[PRE95]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, we define a new function, `thermal_confort`, which has two required arguments,
    `temperature` and `humidity`. The function also accepts two keyword arguments,
    `scale` and `age`, which have the default values of `:celsius` and `35`, respectively.
    It is necessary for all the keyword arguments to have default values.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个新的函数`thermal_confort`，它有两个必需的参数`temperature`和`humidity`。该函数还接受两个关键字参数`scale`和`age`，分别具有默认值`:celsius`和`35`。对于所有关键字参数来说，具有默认值是必要的。
- en: 'Invoking such a function implies using the positional as well as the keyword
    arguments:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此类函数意味着同时使用位置参数和关键字参数：
- en: '[PRE96]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: If the values for the keyword arguments are not supplied, the default values
    are used.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供关键字参数的值，将使用默认值。
- en: 'Keyword argument default values are evaluated left to right, which means that
    default expressions may refer to prior keyword arguments:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数默认值是从左到右评估的，这意味着默认表达式可以引用先前的关键字参数：
- en: '[PRE97]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Note that we reference the keyword argument `age` in the default value of `health_risk`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`health_risk`的默认值中引用了关键字参数`age`。
- en: Documenting functions
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录函数
- en: Julia comes out of the box with powerful code-documenting features. The usage
    is straightforward—any string appearing at the top level, right before an object,
    will be interpreted as documentation (it's called a **docstring**). The docstring
    is interpreted as markdown, so we can use markup for rich formatting.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Julia自带强大的代码文档功能。使用方法简单——任何出现在对象之前顶级字符串都将被解释为文档（它被称为**docstring**）。docstring被解释为Markdown，因此我们可以使用标记来丰富格式。
- en: 'The documentation for the `thermal_confort` function could be as follow:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`thermal_confort`函数的文档可能如下所示：'
- en: '[PRE98]julia-repl'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE98]julia-repl'
- en: julia> thermal_confort(32, 78)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: julia> thermal_confort(32, 78)
- en: '12'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '[PRE99]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now we can access the documentation of our function by using the REPL''s help
    mode:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用REPL的帮助模式来访问我们函数的文档：
- en: '[PRE100]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output is as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/12ccbd57-9f44-4685-8595-dbdfb105fecc.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12ccbd57-9f44-4685-8595-dbdfb105fecc.png)'
- en: Pretty useful, isn't it? Docstrings can also be used to generate complete documentation
    for your Julia projects, with the help of external packages which build full API
    docs as standalone websites, markdown documents, PDF documents, etcetera. We'll
    see how to do this in [Chapter 11](8391f749-e95c-4ff9-ba40-d71c91b1d7fd.xhtml),
    *Creating Julia Packages*.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有用，不是吗？文档字符串也可以用来为你的Julia项目生成完整的文档，这需要外部包的帮助，这些包构建完整的API文档作为独立的网站、Markdown文档、PDF文档等。我们将在[第11章](8391f749-e95c-4ff9-ba40-d71c91b1d7fd.xhtml)中看到如何做到这一点，*创建Julia包*。
- en: Writing a basic web crawler – take one
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基本的网络爬虫 – 开始
- en: We're now ready to write our first fully-fledged Julia program—a simple web
    crawler. This first iteration will make a request for Julia's Wikipedia page,
    will parse it and extract all the internal URLs, storing them in an `Array`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好编写我们的第一个完整的Julia程序——一个简单的网络爬虫。这个迭代将向Julia的维基百科页面发起请求，解析它并提取所有内部URL，将它们存储在`Array`中。
- en: Setting up our project
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的项目
- en: The first thing we need to do is to set up a dedicated project. This is done
    by using `Pkg`. It is a very important step as it allows us to efficiently manage
    and version the packages on which our program depends.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是设置一个专用项目。这是通过使用`Pkg`来完成的。这是一个非常重要的步骤，因为它允许我们有效地管理和版本化程序所依赖的包。
- en: 'For starters, we need a folder for our software. Create one—let''s call it
    `WebCrawler`. I''ll use Julia to make it, but you do it however you like:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的软件创建一个文件夹。创建一个——让我们称它为`WebCrawler`。我会使用Julia来做这件事，但你可以按照你喜欢的任何方式来做：
- en: '[PRE101]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now we can use `Pkg` to add the dependencies. When we start a new project,
    we need to initialise it. This is achieved with the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`Pkg`来添加依赖项。当我们开始一个新的项目时，我们需要初始化它。这是通过以下方式实现的：
- en: '[PRE102]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This tells `Pkg` that we want to manage dependencies in the current project
    as opposed to doing it globally. You will notice that the cursor has changed,
    indicating the name of the active project, `WebCrawler`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`Pkg`我们想要在当前项目中管理依赖项，而不是全局操作。你会注意到光标已经改变，指示了活动项目的名称，`WebCrawler`：
- en: '[PRE103]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'All the other packages we installed up until this point were in the global
    environment, which was indicated by the `(v1.0)` cursor:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们安装的所有其他包都在全局环境中，这可以通过`(v1.0)`光标来指示：
- en: '[PRE104]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`(v1.0)` is the global environment, labeled with the currently installed Julia
    version. If you try the examples on a different Julia version, you''ll get a different
    label.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v1.0)`是全局环境，标记了当前安装的Julia版本。如果你在不同的Julia版本上尝试这些示例，你会得到不同的标签。'
- en: 'If we check the status, we''ll see that no packages were installed yet in the
    project''s environment:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查状态，我们会看到在项目的环境中还没有安装任何包：
- en: '[PRE105]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Our software will have two dependencies—`HTTP` and `Gumbo`. It''s time to add
    them:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们软件将有两个依赖项——`HTTP`和`Gumbo`。是时候添加它们了：
- en: '[PRE106]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now we can create a new file to host our code. Let''s call it `webcrawler.jl`.
    It can be created using Julia:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的文件来存放我们的代码。让我们称它为`webcrawler.jl`。它可以由Julia创建：
- en: '[PRE107]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Writing a Julia program
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Julia程序
- en: 'Unlike our previous work in the REPL and IJulia notebooks, this will be a standalone
    program: all the logic will go inside this `webcrawler.jl` file, and when ready,
    we''ll use the `julia` binary to execute it.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在 REPL 和 IJulia 笔记本中的先前工作不同，这将是一个独立的程序：所有逻辑都将放在这个 `webcrawler.jl` 文件中，准备好后，我们将使用
    `julia` 二进制文件来执行它。
- en: Julia files are parsed top to bottom, so we need to provide all the necessary
    instructions in the right order (using statements, variables initialization, function
    definitions, etcetera). We'll pretty much condense all the steps we took so far
    in this chapter to build this small program.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 文件是从上到下解析的，所以我们需要按正确的顺序提供所有必要的指令（使用语句、变量初始化、函数定义等）。我们将基本上将本章中迄今为止所采取的所有步骤压缩到这个小程序中。
- en: To make things simpler, it's best to use a full-fledged Julia editor. Open `webcrawler.jl`
    in Atom/Juno or Visual Studio Code (or whatever your favorite editor is).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更简单，最好使用一个完整的 Julia 编辑器。在 Atom/Juno 或 Visual Studio Code（或你喜欢的任何编辑器）中打开
    `webcrawler.jl`。
- en: 'The first thing we want to do is to inform Julia that we plan on using the
    `HTTP` and `Gumbo` packages. We can write a single `using` statement and list
    multiple dependencies, separated by a comma:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是通知 Julia 我们计划使用 `HTTP` 和 `Gumbo` 包。我们可以写一个单独的 `using` 语句并列出多个依赖项，用逗号分隔：
- en: '[PRE108]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Also, we decided that we wanted to use Julia''s Wikipedia page to test our
    crawler. The link is [https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language)).
    It''s good practice to store such configuration-like values in constants, rather
    than spreading *magic strings* throughout the whole code base:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们决定我们想要使用 Julia 的维基百科页面来测试我们的爬虫。链接是 [https://en.wikipedia.org/wiki/Julia_(programming_language)](https://en.wikipedia.org/wiki/Julia_(programming_language))。将此类配置值存储在常量中而不是在整个代码库中散布
    *魔法字符串* 是一种好的做法：
- en: '[PRE109]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We also said that we wanted to store all the links in an `Array`—let''s set
    that up too. Remember that constants in Julia are concerned mostly with types,
    so there is no problem if we push values into the array after it''s declared:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还说过我们想要将所有链接存储在一个 `Array` 中——让我们也设置一下。记住，Julia 中的常量主要与类型相关，所以在我们声明后向数组中推入值是没有问题的：
- en: '[PRE110]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here, we initialize the `LINKS` constant as an empty `Array` of `String`. The
    notation `String[]` produces the same result as `Array{String,1}()` and `Vector{String}()`.
    It basically represents the empty `Array` literal `[]` plus the `Type` constraint
    `String`—creating a `Vector` of `String` values.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `LINKS` 常量初始化为一个空的 `String` 数组。记法 `String[]` 与 `Array{String,1}()` 和
    `Vector{String}()` 产生相同的结果。它基本上表示空的 `Array` 字面量 `[]` 加上 `Type` 约束 `String`——创建一个
    `String` 值的 `Vector`。
- en: 'The next steps are—fetch the page, look for a successful response (status `200`),
    and then check the headers to see if we received a message body (`Content-Length`
    greater than zero). In this first iteration, we only have to do this one time.
    But thinking ahead, for the final version of our game, we''ll have to repeat this
    process up to six times per game session (because there will be up to Six Degrees
    of Wikipedia, so we''ll have to crawl up to six pages). The best thing we can
    do is to write a generic function which takes a page URL as its only parameter,
    fetches the page, performs the necessary checks, and returns the message body
    if available. Let''s call this function `fetchpage`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是——获取页面，寻找成功的响应（状态 `200`），然后检查头信息以查看是否收到了消息体（`Content-Length` 大于零）。在这个第一次迭代中，我们只需要做一次。但向前看，对于游戏的最终版本，我们可能需要在每个游戏会话中重复这个过程多达六次（因为会有多达六度维基百科，所以我们需要爬取多达六个页面）。我们能做的最好的事情是编写一个通用函数，它只接受页面
    URL 作为其唯一参数，获取页面，执行必要的检查，并在可用的情况下返回消息体。让我们把这个函数叫做 `fetchpage`：
- en: '[PRE111]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: First, we call `HTTP.get(url)`, storing the `HTTP.Messages.Response` object
    in the `response` variable. Then we check if the response status is `200` and
    if the `Content-Length` header is greater than `0`. If they are, we read the message
    body into a string. If not, we return an empty string, `""`, to represent the
    empty body. That's a lot of *ifs*—looks like it's time we take a closer look at
    the conditional `if/else` statements, as they're really important.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用 `HTTP.get(url)`，将 `HTTP.Messages.Response` 对象存储在 `response` 变量中。然后我们检查响应状态是否为
    `200`，以及 `Content-Length` 头是否大于 `0`。如果是，我们将消息体读取到字符串中。如果不是，我们返回一个空字符串 `""` 来表示空体。这里有很多
    *if* 条件——看起来是时候我们仔细看看条件 `if/else` 语句了，因为它们真的很重要。
- en: Conditional evaluation of if, elseif, and else statements
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if、elseif 和 else 语句的条件评估
- en: 'All, except maybe the most basic, programs must be able to evaluate variables
    and execute different logical branches depending on their current values. Conditional
    evaluation allows portions of the code to be executed (or not) depending on the
    value of a Boolean expression. Julia provides the `if`, `elseif`, and `else` statements
    for writing conditional expressions. They work like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 所有程序，除了最基础的，都必须能够评估变量并根据它们的当前值执行不同的逻辑分支。条件评估允许根据布尔表达式的值执行（或不执行）代码的一部分。Julia
    提供了 `if`、`elseif` 和 `else` 语句来编写条件表达式。它们的工作方式如下：
- en: '[PRE112]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: If the condition `x < 0` is true, then its underlying block is evaluated. If
    not, the expression `x > 0` is evaluated, as part of the `elseif` branch. If it
    is true, its corresponding block is evaluated. If neither expression is true,
    the `else` block is evaluated.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件 `x < 0` 为真，则其基础块将被评估。如果不为真，则表达式 `x > 0` 作为 `elseif` 分支的一部分被评估。如果为真，则评估其对应的块。如果两个表达式都不为真，则评估
    `else` 块。
- en: 'The `elseif` and `else` blocks are optional, and we can use as many `elseif`
    blocks as we want. The conditions in the `if`,`elseif` and `else` construct are
    evaluated until the first one returns `true`. Then the associated block is evaluated
    and its last computed value is returned, exiting the conditional evaluation. Thus,
    conditional statements in Julia also return a value—the last executed statement
    in the branch that was chosen. The following code shows this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`elseif` 和 `else` 块是可选的，我们可以使用任意数量的 `elseif` 块。在 `if`、`elseif` 和 `else` 构造中的条件会被评估，直到第一个返回
    `true`。然后评估相关的块，并返回其最后计算出的值，退出条件评估。因此，Julia 中的条件语句也会返回一个值——所选择分支中最后执行语句的值。以下代码展示了这一点：'
- en: '[PRE113]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Finally, it''s very important to keep in mind that `if` blocks do not introduce
    local scope. That is, variables defined within them will be accessible after the
    block is exited (of course, provided that the respective branch has been evaluated):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，非常重要的一点是要记住，`if` 块不会引入局部作用域。也就是说，在其中定义的变量在块退出后仍然可访问（当然，前提是相应的分支已被评估）：
- en: '[PRE114]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We can see here that the `y` variable, initialized within the `elseif` block,
    is still accessible outside the conditional expression.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在 `elseif` 块中初始化的 `y` 变量在条件表达式外部仍然可访问。
- en: 'This can be avoided if we declare the variable to be `local`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们声明变量为 `local`，则可以避免这种情况：
- en: '[PRE115]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: When declared `local`, the variable no longer *leaks* outside the `if` block.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明为 `local` 时，变量不再会从 `if` 块中 *泄漏*。
- en: The ternary operator
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'An `if`,`then` and `else` type of condition can be expressed using the ternary
    operator `? :`. Its syntax is as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用三元运算符 `? :` 表达 `if`、`then` 和 `else` 类型的条件。其语法如下：
- en: '[PRE116]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'If `x` is true, the expression `y` is evaluated—otherwise, `z` gets evaluated
    instead. For instance, consider the following code:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 为真，则评估表达式 `y`；否则，评估 `z`。例如，考虑以下代码：
- en: '[PRE117]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Short-circuit evaluation
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短路评估
- en: 'Julia provides an even more concise type of evaluation—short-circuit evaluation.
    In a series of Boolean expressions connected by `&&` and `||` operators, only
    the minimum number of expressions are evaluated—as many as are necessary in order
    to determine the final Boolean value of the entire chain. We can exploit this
    to return certain values, depending on what gets to be evaluated. For instance:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了一种更简洁的评估类型——短路评估。在一系列由 `&&` 和 `||` 操作符连接的布尔表达式中，只评估最小数量的表达式——只要足以确定整个链的最终布尔值。我们可以利用这一点来返回某些值，具体取决于什么被评估。例如：
- en: '[PRE118]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In an expression `A && B`, the second expression `B` is only evaluated if and
    only if `A` evaluates to `true`. In this case, the whole expression has the return
    value of the sub-expression `B`, which in the previous example is `bigger than
    5`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式 `A && B` 中，只有当 `A` 评估为 `true` 时，第二个表达式 `B` 才会进行评估。在这种情况下，整个表达式的返回值是子表达式
    `B` 的返回值，在先前的例子中是 `大于 5`。
- en: 'If, on the contrary, `A` evaluates to `false`, `B` does not get evaluated at
    all. Thus, beware—the whole expression will return a `false` Boolean (not a string!):'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果 `A` 评估为 `false`，则 `B` 完全不会进行评估。因此，请注意——整个表达式将返回一个 `false` 布尔值（而不是字符串！）：
- en: '[PRE119]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The same logic applies to the logical `or` operator, `||`:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑适用于逻辑 `or` 操作符，`||`：
- en: '[PRE120]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In an expression `A || B`, the second expression `B` is only evaluated if `A`
    evaluates to `false`. The same logic applies when the first sub-expression is
    evaluated to `true`; `true` will be the return value of the whole expression:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式 `A || B` 中，只有当 `A` 评估为 `false` 时，第二个表达式 `B` 才会被评估。当第一个子表达式评估为 `true` 时，同样的逻辑也适用；`true`
    将是整个表达式的返回值：
- en: '[PRE121]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Beware of operator precedence
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意运算符优先级
- en: 'Sometimes short-circuit expressions can confuse the compiler, resulting in
    errors or unexpected results. For example, short-circuit expressions are often
    used with assignment operations, as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 有时短路表达式可能会让编译器困惑，导致错误或意外结果。例如，短路表达式经常与赋值操作一起使用，如下所示：
- en: '[PRE122]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This will fail with the `syntax: invalid assignment location "(x > 15) || message"`
    error because the `=` assignment operator has higher precedence than logical `or` and `||`.
    It can easily be fixed by using brackets to explicitly control the evaluation
    order:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '这将因为 `syntax: invalid assignment location "(x > 15) || message"` 错误而失败，因为 `=`
    赋值运算符的优先级高于逻辑 `or` 和 `||`。可以通过使用括号来显式控制评估顺序来轻松修复：'
- en: '[PRE123]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: It's something to keep in mind as it's a common source of errors for beginners.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件需要记住的事情，因为它是初学者常见的错误来源。
- en: Carrying on with the crawler's implementation
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续爬虫的实现
- en: 'So far, your code should look like this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的代码应该看起来像这样：
- en: '[PRE124]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: It should be now clear that either the response body or an empty string is returned
    by the `if/else` statement. And since this is the last piece of code evaluated
    inside the `fetchpage` function, this value also becomes the return value of the
    whole function.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很清楚，`if/else` 语句返回的是响应体或空字符串。由于这是 `fetchpage` 函数内部最后评估的代码片段，这个值也成为了整个函数的返回值。
- en: 'All good, we can now use the `fetchpage` function to get the HTML content of
    the Wikipedia page and store it in the `content` variable:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 所有都很好，我们现在可以使用 `fetchpage` 函数获取维基百科页面的 HTML 内容并将其存储在 `content` 变量中：
- en: '[PRE125]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If the fetch operation is successful and the `content` is not an empty string,
    we can pass the HTML string to `Gumbo` to construct the DOM. Then, we can loop
    through all the children of this DOM''s `root` element and look for links (using
    the `a` tag selector). For each element, we want to check the `href` attribute
    and store its value only if it points to another Wikipedia page:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获取操作成功且 `content` 不是空字符串，我们可以将 HTML 字符串传递给 `Gumbo` 以构建 DOM。然后，我们可以遍历此 DOM
    的 `root` 元素的子元素并查找链接（使用 `a` 标签选择器）。对于每个元素，我们想要检查 `href` 属性，并且只有当它指向另一个维基百科页面时才存储其值：
- en: '[PRE126]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The function for extracting the links is:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 提取链接的函数是：
- en: '[PRE127]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Here, we declare an `extractlinks` function which takes a `Gumbo` element, called
    `elem`, as its only parameter. We then check if `elem` is a `HTMLElement` and,
    if it is, we check if it corresponds to a link tag (the `:a` Julia `Symbol` which
    represents an `<a>` HTML tag). Then we check if the element defines a `href` attribute
    in order to avoid getting a `KeyError`. If all is good, we get the value of the
    `href` element. And finally, if the value of the `href` is an internal URL—that
    is, a URL that starts with `/wiki/`—we add it to our `LINKS` `Array`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明一个 `extractlinks` 函数，它接受一个名为 `elem` 的 `Gumbo` 元素作为其唯一参数。然后我们检查 `elem`
    是否是一个 `HTMLElement`，如果是，我们检查它是否对应于一个链接标签（表示 `<a>` HTML 标签的 Julia `Symbol` `:a`）。然后我们检查该元素是否定义了
    `href` 属性，以避免出现 `KeyError`。如果一切正常，我们获取 `href` 元素的值。最后，如果 `href` 的值是一个内部 URL——即以
    `/wiki/` 开头的 URL——我们将它添加到我们的 `LINKS` `数组` 中。
- en: Once we're done checking the element for links, we check if it contains other
    nested HTML elements. If it does, we want to repeat the same process for each
    of its children. That's what the final `for` loop does.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们检查完元素中的链接，我们检查它是否包含其他嵌套的 HTML 元素。如果包含，我们想要对其每个子元素重复相同的流程。这就是最终 `for` 循环所做的。
- en: 'The only thing left to do is to display the populated `LINKS` `Array`, at the
    very end of our file. Since some of the links might come up in the page more than
    once, let''s make sure we reduce the `Array` to the unique elements only, by using
    the `unique` function:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一任务是显示我们文件末尾填充好的 `LINKS` `数组`。由于一些链接可能会在页面中出现多次，让我们确保通过使用 `unique` 函数将 `数组`
    精简为仅包含唯一元素：
- en: '[PRE128]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Now we can execute this script by opening a terminal in the folder where the
    file is stored. And then run—`$ julia webcrawler.jl`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在存储文件的文件夹中打开终端来执行此脚本。然后运行——`$ julia webcrawler.jl`。
- en: 'There''s plenty of links, so the output will be quite long. Here''s the top
    of the list:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 链接很多，所以输出将会相当长。以下是列表的顶部：
- en: '[PRE129]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: By looking at the output, we'll notice that in the first optimization some links
    point to special Wikipedia pages—the ones containing parts such as `/File:`, `/Category:`,
    `/Help:`, `/Special:`, and so on. So we can just go ahead and skip all the URLs
    that contain a column, `:`, since these are not articles and are not useful for
    our game.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看输出，我们会注意到在第一次优化中，一些链接指向特殊的维基百科页面——包含如 `File:`, `/Category:`, `/Help:`, `/Special:`
    等部分的页面。因此，我们可以直接跳过所有包含列，即 `:`, 的 URL，因为这些不是文章，对我们游戏没有用。
- en: 'To do this, look for the line that reads:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请查找以下行：
- en: '[PRE130]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Replace the preceding line with the following:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下内容：
- en: '[PRE131]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: If you run the program now, you should see a list of all the URLs from Julia's
    Wikipedia page that link to other Wikipedia articles.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，你应该会看到来自 Julia 维基百科页面的所有链接到其他维基百科文章的 URL 列表。
- en: 'This is the full code:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的代码：
- en: '[PRE132]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Summary
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Web scraping is a key component of data mining and Julia provides a powerful
    toolbox for handling these tasks. In this chapter, we addressed the fundamentals
    of building a web crawler. We learned how to request web pages with a Julia web
    client and how to read the responses, how to work with Julia's powerful `Dict`
    data structure to read HTTP information, how to make our software more resilient
    by handling errors, how to better organize our code by writing functions and documenting
    them, and how to use conditional logic to make decisions.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 网络爬虫是数据挖掘的关键组成部分，Julia 提供了一个强大的工具箱来处理这些任务。在本章中，我们讨论了构建网络爬虫的基本原理。我们学习了如何使用 Julia
    网络客户端请求网页以及如何读取响应，如何使用 Julia 强大的 `Dict` 数据结构读取 HTTP 信息，如何通过处理错误来使我们的软件更具鲁棒性，如何通过编写函数并对其进行文档化来更好地组织我们的代码，以及如何使用条件逻辑来做出决策。
- en: Armed with this knowledge, we built the first version of our web crawler. In
    the next chapter, we will improve it and will use it to extract the data for our
    upcoming Wiki game. In the process, we'll dive deeper into the language, learning
    about types, methods and modules, and how to interact with relational databases.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们构建了我们网络爬虫的第一个版本。在下一章中，我们将对其进行改进，并使用它来提取即将推出的 Wiki 游戏的数据。在这个过程中，我们将更深入地了解语言，学习类型、方法和模块，以及如何与关系型数据库交互。
