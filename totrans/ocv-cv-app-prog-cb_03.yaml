- en: Chapter 3. Processing Color Images with Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用类处理颜色图像
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Using the Strategy pattern in an algorithm design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在算法设计中使用策略模式
- en: Using a Controller design pattern to communicate with processing modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制器设计模式与处理模块通信
- en: Converting color representations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换颜色表示
- en: Representing colors with hue, saturation, and brightness
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用色调、饱和度和亮度表示颜色
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Good computer vision programs begin with good programming practices. Building
    a bug-free application is just the beginning. What you really want is an application
    that you and the programmers working with you will be able to easily adapt and
    evolve as new requirements come in. This chapter will show you how to make the
    best use of some of the object-oriented programming principles in order to build
    good quality software programs. In particular, we will introduce a few important
    design patterns that will help you build applications with components that are
    easy to test, maintain, and reuse.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的计算机视觉程序始于良好的编程实践。构建一个无错误的程序只是开始。你真正想要的是一个你可以和与你一起工作的程序员轻松适应和演化的应用程序。本章将向你展示如何充分利用面向对象编程的一些原则，以构建高质量的软件程序。特别是，我们将介绍一些重要的设计模式，这些模式将帮助你构建易于测试、维护和重用的应用程序组件。
- en: Design patterns are a well-known concept in software engineering. Basically,
    a design pattern is a sound, reusable solution to a generic problem that occurs
    frequently in software designing. Many software patterns have been introduced
    and well documented. Good programmers should build a working knowledge of these
    existing patterns.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是软件工程中一个众所周知的概念。基本上，设计模式是对软件设计中频繁出现的通用问题的合理、可重用解决方案。已经引入了许多软件模式，并且得到了很好的记录。优秀的程序员应该掌握这些现有模式的工作知识。
- en: This chapter also has a secondary objective. It will teach you how to play with
    image colors. The example used throughout this chapter will show you how to detect
    the pixels of a given color, and the last two recipes will explain how to work
    with different color spaces.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还有一个次要目标。它将教会你如何玩转图像颜色。本章使用的示例将展示如何检测给定颜色的像素，最后两个菜谱将解释如何处理不同的颜色空间。
- en: Using the Strategy pattern in an algorithm design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在算法设计中使用策略模式
- en: The objective of the Strategy design pattern is to encapsulate an algorithm
    in a class. This way, it becomes easier to replace a given algorithm by another
    one or to chain several algorithms together in order to build a more complex process.
    In addition, this pattern facilitates the deployment of an algorithm by hiding
    as much of its complexity as possible behind an intuitive programming interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 策略设计模式的目标是将算法封装在一个类中。这样，替换给定算法或链式连接几个算法以构建更复杂的过程就变得更容易了。此外，该模式通过尽可能隐藏其复杂性，简化了算法的部署，提供了一个直观的编程接口。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's say we want to build a simple algorithm that will identify all of the
    pixels in an image that have a given color. For this, the algorithm has to accept
    an image and a color as input and will return a binary image showing the pixels
    that have the specified color. The tolerance with which we want to accept a color
    will be another parameter to be specified before running the algorithm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要构建一个简单的算法，该算法将识别图像中所有具有给定颜色的像素。为此，该算法必须接受一个图像和一个颜色作为输入，并将返回一个二值图像，显示具有指定颜色的像素。我们希望接受颜色的容差将是运行算法前要指定的另一个参数。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Once an algorithm has been encapsulated in a class using the Strategy design
    pattern, it can be deployed by creating an instance of this class. Typically,
    the instance will be created when the program is initialized. At the time of construction,
    the class instance will initialize the different parameters of the algorithm with
    their default values such that it will immediately be ready to be used. The algorithm's
    parameter values can also be read and set using appropriate methods. In the case
    of an application with a GUI, these parameters can be displayed and modified using
    different widgets (text fields, sliders, and so on) so that a user can easily
    play with them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用策略设计模式将算法封装在类中，就可以通过创建这个类的实例来部署它。通常，实例会在程序初始化时创建。在构建时，类实例将使用默认值初始化算法的不同参数，这样它就可以立即投入使用。算法的参数值也可以通过适当的方法进行读取和设置。在具有图形用户界面的应用程序中，这些参数可以通过不同的小部件（文本字段、滑块等）显示和修改，以便用户可以轻松地与之互动。
- en: 'We will show you the structure of a Strategy class in the next section; let''s
    start with an example on how it can be deployed and used. Let''s write a simple
    main function that will run our proposed color detection algorithm:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中向您展示策略类的结构；让我们从一个示例开始，说明它如何部署和使用。让我们编写一个简单的main函数，该函数将运行我们提出的颜色检测算法：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running this program to detect a blue sky in the colored version of the *Castle*
    image presented in the previous chapter produces the following output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序以检测前一章中呈现的彩色版本 *城堡* 图像中的蓝天，会产生以下输出：
- en: '![How to do it…](img/00019.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/00019.jpeg)'
- en: Here, a white pixel indicates a positive detection of the sought color, and
    black indicates negative.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，白色像素表示所寻求颜色的积极检测，而黑色表示消极。
- en: Obviously, the algorithm we encapsulated in this class is relatively simple
    (as we will see next, it is composed of just one scanning loop and one tolerance
    parameter). The Strategy design pattern becomes really powerful when the algorithm
    to be implemented is more complex, has many steps, and includes several parameters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们在这个类中封装的算法相对简单（正如我们将在下面看到的那样，它仅由一个扫描循环和一个容差参数组成）。当要实现的算法更复杂、有多个步骤并包含多个参数时，策略设计模式才真正强大。
- en: How it works…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The core process of this algorithm is easy to build. It is a simple scanning
    loop that goes over each pixel, comparing its color with the target color. Using
    what we learned in the *Scanning an image with iterators* recipe of the previous
    chapter, this loop can be written as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法的核心过程很容易构建。它是一个简单的扫描循环，遍历每个像素，比较其颜色与目标颜色。使用我们在前一章的 *使用迭代器扫描图像* 章节中学到的知识，这个循环可以写成以下形式：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `cv::Mat` variable''s `image` refers to the input image, while `result`
    refers to the binary output image. Therefore, the first step consists of setting
    up the required iterators. The scanning loop then becomes easy to implement. The
    distance between the current pixel color and the target color is evaluated on
    each iteration in order to check whether it is within the tolerance parameter
    defined by `maxDist`. If that is the case, the value `255` (white) is then assigned
    to the output image; if not, `0` (black) is assigned. To compute the distance
    to the target color, the `getDistanceToTargetColor` method is used. There are
    different ways to compute this distance. One could, for example, calculate the
    Euclidean distance between the three vectors that contain the RGB color values.
    To keep this computation simple, we simply sum the absolute differences of the
    RGB values (this is also known as the city-block distance) in our case. Note that
    in modern architecture, a floating-point Euclidean distance can be faster to compute
    than a simple city-block distance; this is also something to take into consideration
    in your design. Also, for more flexibility, we write the `getDistanceToTargetColor`
    method in terms of a `getColorDistance` method, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Mat` 变量的 `image` 指的是输入图像，而 `result` 指的是二值输出图像。因此，第一步是设置所需的迭代器。然后扫描循环就变得容易实现了。在每次迭代中，都会评估当前像素颜色与目标颜色之间的距离，以检查它是否在由
    `maxDist` 定义的容差参数内。如果是这样，则将值 `255`（白色）分配给输出图像；如果不是，则分配 `0`（黑色）。为了计算到目标颜色的距离，使用
    `getDistanceToTargetColor` 方法。有几种计算这种距离的方法。例如，可以计算包含 RGB 颜色值的三个向量的欧几里得距离。为了使这个计算简单，我们只是将
    RGB 值的绝对差值相加（这通常也称为曼哈顿距离）在我们的情况下。请注意，在现代架构中，浮点欧几里得距离可能比简单的曼哈顿距离计算得更快；这也是在设计时需要考虑的事情。此外，为了增加灵活性，我们用
    `getColorDistance` 方法来编写 `getDistanceToTargetColor` 方法，如下所示：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note how we used `cv::Vec3d` to hold the three unsigned char that represent
    the RGB values of a color. The `target` variable obviously refers to the specified
    target color, and as we will see, it is defined as a member variable in the class
    algorithm that we will define. Now, let''s complete the definition of the processing
    method. Users will provide an input image, and the result will be returned once
    the image scanning is completed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用 `cv::Vec3d` 来保存代表一个颜色 RGB 值的三个无符号字符。`target` 变量显然指的是指定的目标颜色，正如我们将看到的，它被定义为我们将定义的类算法的一个成员变量。现在，让我们完成处理方法的定义。用户将提供一个输入图像，一旦图像扫描完成，结果就会被返回：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each time this method is called, it is important to check if the output image
    that contains the resulting binary map needs to be reallocated to fit the size
    of the input image. This is why we use the `create` method of `cv::Mat`. Remember
    that this method will only proceed to reallocation if the specified size or depth
    do not correspond to the current image structure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用此方法时，检查包含结果的二值图的输出图像是否需要重新分配以适应输入图像的大小是很重要的。这就是为什么我们使用 `cv::Mat` 的 `create`
    方法。记住，只有当指定的尺寸或深度与当前图像结构不对应时，此方法才会进行重新分配。
- en: 'Now that we have the core processing method defined, let''s see what additional
    methods should be added in order to deploy this algorithm. We have previously
    determined what input and output data our algorithm requires. Therefore, we will
    first define the class attributes that will hold this data:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了核心处理方法，让我们看看还需要添加哪些附加方法来部署这个算法。我们之前已经确定了我们的算法需要哪些输入和输出数据。因此，我们首先将定义将持有这些数据的类属性：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to create an instance of the class that encapsulates our algorithm
    (which we have named `ColorDetector`), we need to define a constructor. Remember
    that one of the objectives of the Strategy design pattern is to make algorithm
    deployment as easy as possible. The simplest constructor that can be defined is
    an empty one. It will create an instance of the class algorithm in a valid state.
    We then want the constructor to initialize all the input parameters to their default
    values (or the values that are known to generally give a good result). In our
    case, we decided that a distance of `100` is generally an acceptable tolerance
    parameter. We also set the default target color. We chose black for no particular
    reason. The idea is to make sure we always start with predictable and valid input
    values:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个封装我们算法（我们命名为`ColorDetector`）的类的实例，我们需要定义一个构造函数。记住，策略设计模式的一个目标是将算法部署尽可能简单。可以定义的最简单的构造函数是一个空的构造函数。它将创建一个处于有效状态的类算法实例。然后我们希望构造函数将所有输入参数初始化为其默认值（或通常能给出良好结果的值）。在我们的例子中，我们决定`100`的距离通常是一个可接受的容差参数。我们还设置了默认的目标颜色。我们选择黑色没有特别的原因。目的是确保我们始终以可预测和有效的输入值开始：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, a user who creates an instance of our class algorithm can immediately
    call the process method with a valid image and obtain a valid output. This is
    another objective of the Strategy pattern, that is, to make sure that the algorithm
    always runs with valid parameters. Obviously, the users of this class will want
    to use their own settings. This is done by providing the user with the appropriate
    getters and setters. Let''s start with the `color` tolerance parameter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，创建我们类算法实例的用户可以立即使用有效的图像调用process方法并获得有效的输出。这是策略模式的另一个目标，即确保算法始终使用有效的参数运行。显然，这个类的用户将想要使用他们自己的设置。这是通过向用户提供适当的getter和setter来实现的。让我们从`color`容差参数开始：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note how we first check the validity of the input. Again, this is to make sure
    that our algorithm will never be run in an invalid state. The target color can
    be set in a similar manner as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们首先检查输入的有效性。再次强调，这是为了确保我们的算法永远不会在无效状态下运行。目标颜色可以按照以下方式设置：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time it is interesting to note that we have provided the user with two
    definitions of the `setTargetColor` method. In the first version of the definition,
    the three color components are specified as three arguments, while in the second
    version, `cv::Vec3b` is used to hold the color values. Again, the objective is
    to facilitate the use of our class algorithm. The user can simply select the setter
    that best fits their needs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这次有趣的是，我们为用户提供了`setTargetColor`方法的两种定义。在定义的第一版本中，三个颜色分量被指定为三个参数，而在第二版本中，使用`cv::Vec3b`来存储颜色值。再次强调，目的是为了方便用户使用我们的类算法。用户可以简单地选择最适合他们需求的设置器。
- en: There's more…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe introduced you to the idea of encapsulating an algorithm in a class
    using the Strategy design pattern. The example algorithm used in this recipe consisted
    of identifying the pixels of an image that has a color sufficiently close to a
    specified target color. This computation could have been done otherwise. Also,
    the implementation of a Strategy design pattern could be complemented using function
    objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方向您介绍了使用策略设计模式将算法封装在类中的想法。在这个配方中使用的示例算法包括识别图像中颜色足够接近指定目标颜色的像素。这种计算也可以用其他方法完成。此外，可以使用函数对象来补充实现策略设计模式。
- en: Computing the distance between two color vectors
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算两个颜色向量之间的距离
- en: 'To compute the distance between two color vectors, we used the following simple
    formula:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算两个颜色向量之间的距离，我们使用了以下简单的公式：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, OpenCV includes a function to compute the Euclidean norm of a vector.
    Consequently, we could have computed our distance as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，OpenCV 包含一个用于计算向量欧几里得范数的函数。因此，我们可以按照以下方式计算我们的距离：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A very similar result would then be obtained using this definition of the `getDistance`
    method. Here, we use `cv::Vec3i` (a 3-vector array of integers) because the result
    of the subtraction is an integer value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`getDistance`方法的定义，可以得到一个非常相似的结果。在这里，我们使用`cv::Vec3i`（一个整数的3向量数组）因为减法的结果是一个整数值。
- en: 'It is also interesting to recall from [Chapter 2](part0019_split_000.html#page
    "Chapter 2. Manipulating Pixels"), *Manipulating Pixels*, that the OpenCV matrix
    and vector data structures include a definition of the basic arithmetic operators.
    Consequently, one could have proposed the following definition for the distance
    computation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有趣的是，从 [第 2 章](part0019_split_000.html#page "第 2 章. 操作像素") 的 *操作像素* 中回忆起，OpenCV
    矩阵和向量数据结构包括基本算术运算符的定义。因此，可以提出以下距离计算的以下定义：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This definition may look right at the first glance; however, it is wrong. This
    is because all these operators always include a call to `saturate_cast` (see the
    *Scanning an image with neighbor access* recipe in the previous chapter) in order
    to ensure that the results stay within the domain of the input type (here, it
    is `uchar`). Therefore, in the cases where the target value is greater than the
    corresponding color value, the value `0` will be assigned instead of the negative
    value that one would have expected. A correct formulation would then be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义乍一看似乎是正确的；然而，它是错误的。这是因为所有这些算子总是包含对 `saturate_cast` 的调用（参见前一章中 *使用邻域访问扫描图像*
    的配方），以确保结果保持在输入类型的域内（在这里，它是 `uchar`）。因此，在目标值大于相应颜色值的情况下，将分配值 `0` 而不是预期的负值。正确的公式如下：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: However, using two function calls to compute the distance between two 3-vector
    arrays is inefficient.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用两次函数调用来计算两个 3 向量数组的距离是不高效的。
- en: Using OpenCV functions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OpenCV 函数
- en: 'In this recipe, we used a loop with iterators in order to perform our computation.
    Alternatively, we could have achieved the same result by calling a sequence of
    OpenCV functions. The color detection method will then be written as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用循环和迭代器来执行我们的计算。或者，我们也可以通过调用一系列 OpenCV 函数来达到相同的结果。颜色检测方法将如下编写：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method uses the `absdiff` function that computes the absolute difference
    between the pixels of an image and, in this case, a scalar value. Instead of a
    scalar value, another image can be provided as the second argument to this function.
    In the latter case, a pixel-by-pixel difference will be applied; consequently,
    the two images must be of the same size. The individual channels of the difference
    image are then extracted using the `split` function (discussed in the *There's
    more…* section of the *Performing simple image arithmetic* recipe of [Chapter
    2](part0019_split_000.html#page "Chapter 2. Manipulating Pixels"), *Manipulating
    Pixels*) in order to be able to add them together. It is important to note that
    the result of this sum may sometimes be greater than `255`, but because saturation
    is always applied, the result will be stopped at `255`. The consequence is that
    with this version, the `maxDist` parameter must also be less than `256`; this
    should be corrected if you consider this behavior unacceptable. The last step
    is to create a binary image by using the threshold function. This function is
    commonly used to compare all the pixels with a threshold value (the third parameter),
    and in the regular thresholding mode (`cv::THRESH_BINARY`), it assigns the defined
    maximum value (the fourth parameter) to all the pixels greater than threshold
    and `0`. Here, we used the inverse mode (`cv::THRESH_BINARY_INV`) in which the
    defined maximum value is assigned to the pixels that have a value lower than or
    equal to the threshold. Of interest are also the `cv::THRESH_TOZERO_INV` and `cv::THRESH_TOZERO_INV`
    modes, which leave the pixels greater than or lower than the threshold unchanged.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `absdiff` 函数，该函数计算图像像素与标量值之间的绝对差值。除了标量值之外，还可以提供另一个图像作为此函数的第二个参数。在后一种情况下，将应用逐像素差异；因此，两个图像必须具有相同的大小。然后使用
    `split` 函数（在 [第 2 章](part0019_split_000.html#page "第 2 章. 操作像素") 的 *执行简单的图像算术*
    配方的 *更多内容...* 部分中讨论）提取差异图像的各个通道，以便能够将它们相加。需要注意的是，这个总和有时可能大于 `255`，但由于总是应用饱和度，结果将停止在
    `255`。结果是，在这个版本中，`maxDist` 参数也必须小于 `256`；如果你认为这种行为不可接受，应该进行修正。最后一步是使用阈值函数创建二值图像。这个函数通常用于将所有像素与阈值值（第三个参数）进行比较，在常规阈值模式（`cv::THRESH_BINARY`）中，它将定义的最大值（第四个参数）分配给所有大于阈值的像素，并将
    `0` 分配给其他像素。在这里，我们使用了逆模式（`cv::THRESH_BINARY_INV`），其中定义的最大值分配给值低于或等于阈值的像素。同样值得注意的是
    `cv::THRESH_TOZERO_INV` 和 `cv::THRESH_TOZERO` 模式，它们将保持高于或低于阈值的像素不变。
- en: Using the OpenCV functions is always a good idea. You can then quickly build
    complex applications and potentially reduce the number of bugs. The result is
    often more efficient (thanks to the optimization efforts invested by the OpenCV
    contributors). However, when many intermediate steps are performed, you may find
    that the resulting method consumes more memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 函数总是一个好主意。这样，你可以快速构建复杂的应用程序，并可能减少错误数量。结果通常更高效（归功于 OpenCV 贡献者的优化努力）。然而，当执行许多中间步骤时，你可能会发现结果方法消耗了更多的内存。
- en: The functor or function object
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数对象或函数
- en: 'Using the C++ operator overloading, it is possible to create a class for which
    its instances behave as functions. The idea is to overload the `operator()` method
    such that a call to the processing method of a class behaves exactly like a simple
    function call. The resulting class instance is called a function object or a **functor**.
    Often, a functor includes a full constructor such that it can be used immediately
    after being created. For example, you can add the following constructor to your
    `ColorDetector` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++ 运算符重载，可以创建一个类，其实例的行为就像函数。想法是重载 `operator()` 方法，使得对类处理方法的调用表现得就像一个简单的函数调用。结果类实例被称为函数对象或**函数**。通常，函数对象包括一个完整的构造函数，这样它就可以在创建后立即使用。例如，你可以在你的
    `ColorDetector` 类中添加以下构造函数：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Obviously, you can still use the setters and getters that have been defined
    previously. The functor method can be defined as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你仍然可以使用之前定义的设置器和获取器。函数方法可以定义如下：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To detect a given color with this functor method, simply write the following
    code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个函数方法检测给定的颜色，只需编写以下代码片段：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the call to the color detection method now looks like a function
    call. As a matter of fact, the `colordetector` variable can be used as if it were
    the name of a function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，颜色检测方法的调用现在看起来就像一个函数调用。实际上，`colordetector` 变量可以被用作函数的名称。
- en: See also
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关阅读
- en: The policy-based class design, introduced by A. Alexandrescu, is an interesting
    variant of the Strategy design pattern in which algorithms are selected at compile
    time
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 A. Alexandrescu 引入的策略类设计是策略设计模式的一个有趣变体，其中算法在编译时被选择
- en: 'The *Design Patterns: Elements of Reusable Object-Oriented Software*, *Erich
    Gamma et al, Addison-Wesley, 1994*, is one of the classic books on the subject'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式：可复用面向对象软件元素》，Erich Gamma 等著，Addison-Wesley，1994年，是关于该主题的经典书籍之一
- en: Using a Controller design pattern to communicate with processing modules
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制器设计模式与处理模块进行通信
- en: As you build more complex applications, you will need to create multiple algorithms
    that can be combined together in order to accomplish some advanced tasks. Consequently,
    to properly set up the application and have all the classes communicate together
    will become more and more complex. It then becomes advantageous to centralize
    the control of the application in a single class. This is the idea behind the
    Controller design pattern. A Controller is a particular object that plays a central
    role in an application, and we will explore this in this recipe.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你构建更复杂的应用程序，你需要创建多个算法，这些算法可以组合在一起以完成一些高级任务。因此，正确设置应用程序并让所有类进行通信将变得越来越复杂。这时，将应用程序的控制集中在一个类中就变得有利。这就是控制器设计模式背后的想法。控制器是一个在应用程序中扮演中心角色的特定对象，我们将在本食谱中探讨这一点。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Using your favorite IDE, create a simple dialog-based application with two
    buttons; one button to select an image, and another button to start the processing,
    shown as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的 IDE，创建一个简单的基于对话框的应用程序，包含两个按钮；一个按钮用于选择图像，另一个按钮用于开始处理，如下所示：
- en: '![Getting ready](img/00020.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00020.jpeg)'
- en: Here, we use the `ColorDetector` class of the previous recipe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用前一个食谱中的 `ColorDetector` 类。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The role of the `Controller` class is to first create the classes required
    to execute the application. Here, there is only one class, but in a more complex
    application, several classes would be created. In addition, we need two member
    variables in order to hold a reference to the input and output results:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller` 类的作用是首先创建执行应用程序所需的类。在这里，只有一个类，但在更复杂的应用程序中，会创建多个类。此外，我们还需要两个成员变量来保存输入和输出结果：'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we chose to use a dynamic allocation for our class; you can also simply
    declare a class variable. You then need to define all of the setters and getters
    that a user would need to control the application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择为我们类使用动态分配；你也可以简单地声明一个类变量。然后你需要定义所有用户需要控制应用程序的设置器和获取器：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You also need a method, which will be invoked, to start the process:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个将被调用的方法来启动过程：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Moreover, you will need a method to obtain the result of the processing:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要一个方法来获取处理的结果：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, it is important to clean up everything when the application terminates
    (and the `Controller` class is released):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当应用程序终止（并且`Controller`类被释放）时，重要的是要清理一切：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the previously mentioned `Controller` class, a programmer can easily build
    an interface for an application that will execute your algorithm. There is no
    need for the programmer to understand how all the classes are connected together
    or to find out which methods in which class must be called to have everything
    running properly. All this is done by the `Controller` class. The only requirement
    is to create an instance of the `Controller` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的`Controller`类，程序员可以轻松地为将执行你的算法的应用程序构建一个界面。程序员不需要了解所有类是如何连接在一起的，或者找出哪些类中的哪些方法必须被调用才能使一切正常运行。所有这些都是由`Controller`类完成的。唯一的要求是创建`Controller`类的一个实例。
- en: The setters and getters that are defined in the `Controller` class are the ones
    that are required to deploy your algorithm. Most often, these methods simply call
    the corresponding ones in the appropriate class. The simple example used here
    includes only one class algorithm, but in general, several class instances will
    be involved. Therefore, the role of `Controller` is to redirect the request to
    the appropriate class (in object-oriented programming, this mechanism is called
    delegation). Another objective of the Controller pattern is to simplify the interface
    for the application classes. As an example of such simplification, consider the
    `setTargetColor` and `getTargetColor` methods. Both use `uchar` to set and get
    the color of interest. This eliminates the necessity for the application programmer
    to know anything about the `cv::Vec3b` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Controller`类中定义的设置器和获取器是部署你的算法所必需的。通常，这些方法只是调用适当类中的相应方法。这里使用的简单示例只包括一个类算法，但在一般情况下，将涉及多个类实例。因此，`Controller`的作用是将请求重定向到适当的类（在面向对象编程中，这种机制称为委托）。控制器模式的另一个目标是简化应用程序类的接口。作为一个这样的简化的例子，考虑`setTargetColor`和`getTargetColor`方法。这两个方法都使用`uchar`来设置和获取感兴趣的颜色。这消除了应用程序程序员了解`cv::Vec3b`类的必要性。
- en: In some cases, the Controller also prepares the data provided by the application
    programmer. This is what we did in the case of the `setInputImage` method, in
    which the image that corresponds to the given filename is loaded in the memory.
    The method returns `true` or `false` depending on whether the loading operation
    was successful (an exception could also have been thrown to handle this situation).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，控制器也会准备应用程序程序员提供的数据。这就是我们在`setInputImage`方法中所做的，其中将对应给定文件名的图像加载到内存中。该方法根据加载操作是否成功返回`true`或`false`（也可能抛出异常来处理这种情况）。
- en: Finally, the `process` method is the one that runs the algorithm. This method
    does not return a result, and another method must be called in order to get the
    result of the latest processing performed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`process`方法是运行算法的方法。此方法不返回结果，必须调用另一个方法才能获取最新处理的结果。
- en: 'Now, to create a very basic dialog-based application using this controller,
    just add a `ColorDetectController` member variable to the dialog class (called
    `colordetect` here). As an example, using the MS Visual Studio framework, the
    `Open button` callback method of an MFC dialog would look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个使用此控制器的基本基于对话框的应用程序，只需将`ColorDetectController`成员变量添加到对话框类中（这里称为`colordetect`）。作为一个例子，使用MS
    Visual Studio框架，MFC对话框的`Open按钮`回调方法如下所示：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second button executes the `Process` method and displays the result as
    follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个按钮执行`Process`方法，并显示结果如下：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Obviously, a more complete application would include additional widgets in order
    to allow the user to set the algorithm parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一个更完整的应用程序将包括额外的小部件，以便允许用户设置算法参数。
- en: There's more…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When you build an application, always take the time to structure it such that
    it will be easy to maintain and evolve. There exist a number of architectural
    patterns that can help you meet this objective.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个应用程序时，总是花时间将其结构化，使其易于维护和演进。存在许多架构模式可以帮助你实现这一目标。
- en: The Model-View-Controller architecture
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型-视图-控制器架构
- en: The **Model-View-Controller** (**MVC**) architecture has the objective to produce
    an application that clearly separates the application logic from the user interface.
    As the name suggests, the MVC pattern involves three main components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（MVC）架构的目的是生成一个将应用程序逻辑与用户界面明确分离的应用程序。正如其名称所暗示的，MVC模式涉及三个主要组件。'
- en: The **Model** contains information concerning the application. It holds all
    the data that is processed by the application. When new data is produced, it will
    inform the Controller (often asynchronously), which in turn will ask the view
    to display the new results. Often, the Model will group together several algorithms,
    possibly implemented following the Strategy pattern. All these algorithms are
    a part of the Model.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**包含有关应用程序的信息。它保存了应用程序处理的所有数据。当生成新数据时，它会通知控制器（通常是异步的），然后控制器会要求视图显示新结果。通常，模型会组合几个算法，这些算法可能遵循策略模式实现。所有这些算法都是模型的一部分。'
- en: The **View** corresponds to the user interface. It is composed of the different
    widgets that present the data to the user and allow the user to interact with
    the application. One of its roles is to send the commands issued by the user to
    the Controller. When new data is available, it refreshes itself in order to display
    the new information.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**对应于用户界面。它由不同的小部件组成，这些小部件向用户展示数据并允许用户与应用程序交互。其一个角色是将用户发出的命令发送到控制器。当有新数据可用时，它会刷新自己以显示新信息。'
- en: The **Controller** is the module that bridges the View and the Model together.
    It receives requests from the View and relays them to the appropriate methods
    in the model. It is also informed when the Model changes its state; consequently,
    the Controller asks the View to refresh in order to display this new information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**是连接视图和模型的模块。它接收来自视图的请求，并将它们转发到模型中适当的方法。当模型改变其状态时，它也会被告知；因此，控制器要求视图刷新以显示新信息。'
- en: Under the MVC architecture, the user interface calls the Controller methods.
    It does not contain any application data and does not implement any application
    logic. Consequently, it is easy to substitute an interface with another one. The
    designer of the GUI does not need to understand the functioning of the application.
    Reciprocally, the application logic can be modified without the GUI being affected.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC架构下，用户界面调用控制器方法。它不包含任何应用程序数据，也不实现任何应用程序逻辑。因此，很容易用另一个界面替换它。GUI的设计者不需要理解应用程序的工作原理。反过来，修改应用程序逻辑也不会影响GUI。
- en: Converting color representations
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换颜色表示
- en: The earlier recipes taught you how to encapsulate an algorithm into a class.
    This way, the algorithm becomes easier to use through a simplified interface.
    Encapsulation also permits you to modify an algorithm's implementation without
    impacting the classes that use it. This principle is illustrated in the next recipe,
    where we will modify the `ColorDetector` class algorithm in order to use another
    color space. Therefore, this recipe will also be an opportunity to introduce color
    conversions with OpenCV.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的食谱教了你如何将算法封装到类中。这样，算法通过简化的接口变得更容易使用。封装还允许你在不影响使用它的类的情况下修改算法的实现。这一点在下一个食谱中得到了说明，我们将修改`ColorDetector`类的算法以使用另一个颜色空间。因此，这个食谱也将是一个介绍使用OpenCV进行颜色转换的机会。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The RGB color space is based on the use of the red, green, and blue additive
    primary colors. These have been selected because when they are combined together,
    they can produce a wide gamut of different colors. In fact, the human visual system
    is also based on the trichromatic perception of colors, with cone cell sensitivity
    located around the red, green, and blue spectrum. It is often the default color
    space in digital imagery because that is the way they are acquired. Captured light
    goes through the red, green, and blue filters. Additionally, in digital images,
    the red, green, and blue channels are adjusted such that when combined in equal
    amounts, a gray-level intensity is obtained, that is, from black `(0,0,0)` to
    white `(255,255,255)`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: RGB颜色空间基于红色、绿色和蓝色加色原色的使用。这些颜色被选中是因为当它们组合在一起时，可以产生广泛的颜色范围。实际上，人类视觉系统也是基于颜色的三色感知，其锥体细胞敏感性位于红色、绿色和蓝色光谱周围。它通常是数字图像中的默认颜色空间，因为它们就是这样被获取的。捕获的光线通过红色、绿色和蓝色过滤器。此外，在数字图像中，红色、绿色和蓝色通道被调整，以便当它们以相等比例组合时，可以获得灰度强度，即从黑色`(0,0,0)`到白色`(255,255,255)`。
- en: Unfortunately, computing the distance between the colors using the RGB color
    space is not the best way to measure the similarity between two given colors.
    Indeed, RGB is not a perceptually uniform color space. This means that two colors
    at a given distance might look very similar, while two other colors separated
    by the same distance might look very different.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用RGB颜色空间计算颜色之间的距离并不是衡量两种给定颜色相似性的最佳方式。事实上，RGB不是一个感知均匀的颜色空间。这意味着在给定距离的两个颜色可能看起来非常相似，而相隔相同距离的另外两种颜色可能看起来非常不同。
- en: To solve this problem, other color representations that have the property of
    being perceptually uniform have been introduced. In particular, the CIE L*a*b*
    is one such color model. By converting our images to this representation, the
    Euclidean distance between an image pixel and the target color will then be a
    meaningful measure of the visual similarity between the two colors. In this recipe,
    we will show you how to modify the previous application in order to work with
    CIE L*a*b*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，已经引入了具有感知均匀性的其他颜色表示。特别是，CIE L*a*b*就是这样一种颜色模型。通过将我们的图像转换为这种表示，图像像素与目标颜色之间的欧几里得距离将变成衡量两种颜色视觉相似性的一个有意义的度量。在这个菜谱中，我们将向您展示如何修改前面的应用程序以便与CIE
    L*a*b*一起工作。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Conversion of images between different color spaces is easily done through
    the use of the `cv::cvtColor` OpenCV function. Let''s convert the input image
    to the CIE L*a*b* color space at the beginning of the process method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`cv::cvtColor` OpenCV函数，可以在不同颜色空间之间轻松转换图像。让我们在处理方法的开始将输入图像转换为CIE L*a*b*颜色空间：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The converted variable contains the image after color conversion. In the `ColorDetector`
    class, it is defined as a class attribute:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的变量包含颜色转换后的图像。在`ColorDetector`类中，它被定义为类属性：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You also need to convert the input target color. You can do this by creating
    a temporary image that contains only one pixel. Note that you need to keep the
    same signature as in the earlier recipes, that is, the user continues to supply
    the target color in RGB:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要将输入的目标颜色进行转换。您可以通过创建一个只包含一个像素的临时图像来完成此操作。请注意，您需要保持与早期菜谱相同的签名，即用户继续以RGB格式提供目标颜色：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the application of the preceding recipe is compiled with this modified class,
    it will now detect the pixels of the target color using the CIE L*a*b* color model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将先前的菜谱的应用程序与这个修改后的类编译，现在它将使用CIE L*a*b*颜色模型检测目标颜色的像素。
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When an image is converted from one color space to another, a linear or nonlinear
    transformation is applied on each input pixel to produce the output pixels. The
    pixel type of the output image will match the one of the input image. Even if
    you work with 8-bit pixels most of the time, you can also use a color conversion
    with floating-point images (in which case, the pixel values are generally assumed
    to vary between `0` and `1.0`) or with integer images (with pixels generally varying
    between `0` and `65535`). However, the exact domain of the pixel values depends
    on the specific color space and destination image type. For example, with the
    CIE L*a*b* color space, the `L` channel, which represents the brightness of each
    pixel, varies between `0` and `100`, and it is rescaled between `0` and `255`
    in the case of the 8-bit images. The `a` and `b` channels correspond to the chromaticity
    components. These channels contain information about the color of a pixel, independent
    of its brightness. Their values vary between `-127` and `127`; for 8-bit images,
    `128` is added to each value in order to make it fit within the `0` to `255` interval.
    However, note that the 8-bit color conversion will introduce rounding errors that
    will make the transformation imperfectly reversible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像从一个色彩空间转换为另一个色彩空间时，会对每个输入像素应用线性或非线性转换以生成输出像素。输出图像的像素类型将与输入图像的类型相匹配。即使您大多数时候使用8位像素，您也可以使用浮点图像进行色彩转换（在这种情况下，像素值通常假设在`0`和`1.0`之间变化）或使用整数图像（像素通常在`0`和`65535`之间变化）。然而，像素值的精确范围取决于特定的色彩空间和目标图像类型。例如，在CIE
    L*a*b*色彩空间中，表示每个像素亮度的`L`通道在`0`和`100`之间变化，在8位图像的情况下，它被重新缩放到`0`和`255`之间。`a`和`b`通道对应于色度成分。这些通道包含有关像素颜色的信息，与其亮度无关。它们的值在`-127`和`127`之间变化；对于8位图像，每个值都加上`128`，以便使其适合`0`到`255`的区间。然而，请注意，8位色彩转换将引入舍入误差，这将使转换不可完美逆转。
- en: Most commonly used color spaces are available. It is just a question of providing
    the right color space conversion code to the OpenCV function (for CIE L*a*b*,
    this code is `CV_BGR2Lab`). Among these is YCrCb, which is the color space used
    in a JPEG compression. To convert a color space from BGR to YCrCb, the code will
    be `CV_BGR2YCrCb`. Note that all the conversions that involve the three regular
    primary colors, red, green, and blue, are available in the RGB and BGR order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数常用的色彩空间都是可用的。这只是一个将正确的色彩空间转换代码提供给OpenCV函数（对于CIE L*a*b*，此代码为`CV_BGR2Lab`）的问题。其中之一是YCrCb，这是JPEG压缩中使用的色彩空间。要将色彩空间从BGR转换为YCrCb，代码将是`CV_BGR2YCrCb`。请注意，所有涉及三种常规原色（红色、绿色和蓝色）的转换都在RGB和BGR顺序中可用。
- en: The CIE L*u*v* color space is another perceptually uniform color space. You
    can convert from BGR to CIE L*u*v by using the `CV_BGR2Luv` code. Both L*a*b*
    and L*u*v* use the same conversion formula for the brightness channel but use
    a different representation for the chromaticity channels. Also, note that since
    these two color spaces distort the RGB color domain in order to make it perceptually
    uniform, these transformations are nonlinear (therefore, they are costly to compute).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CIE L*u*v*色彩空间是另一种感知均匀的色彩空间。您可以使用`CV_BGR2Luv`代码将BGR转换为CIE L*u*v。L*a*b*和L*u*v*使用相同的转换公式来表示亮度通道，但使用不同的表示来表示色度通道。此外，请注意，由于这两个色彩空间为了使其感知均匀而扭曲RGB色彩域，这些转换是非线性的（因此，它们在计算上成本较高）。
- en: There is also the CIE XYZ color space (with the `CV_BGR2XYZ` code). It is a
    standard color space used to represent any perceptible color in a device-independent
    way. In the computation of the L*u*v and L*a*b color spaces, the XYZ color space
    is used as an intermediate representation. The transformation between RGB and
    XYZ is linear. It is also interesting to note that the `Y` channel corresponds
    to a gray-level version of the image.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还有CIE XYZ色彩空间（使用`CV_BGR2XYZ`代码）。这是一个用于以设备无关的方式表示任何可感知颜色的标准色彩空间。在L*u*v和L*a*b色彩空间的计算中，XYZ色彩空间被用作中间表示。RGB和XYZ之间的转换是线性的。值得注意的是，`Y`通道对应于图像的灰度版本。
- en: HSV and HLS are interesting color spaces because they decompose the colors into
    their hue and saturation components plus the value or luminance component, which
    is a more natural way for humans to describe colors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HSV和HLS是有趣的色彩空间，因为它们将颜色分解为其色调和饱和度成分以及亮度或明度成分，这是人类描述颜色的一种更自然的方式。
- en: 'You can also convert color images to a gray-level intensity. The output will
    be a one-channel image:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将彩色图像转换为灰度强度。输出将是一个单通道图像：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is also possible to do the conversion in another direction, but the three
    channels of the resulting color image will then be identically filled with the
    corresponding values in the gray-level image.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在另一个方向进行转换，但结果色彩图像的三个通道将完全填充与灰度图像中相应的值。
- en: See also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the mean shift algorithm to find an object* recipe in [Chapter 4](part0032_split_000.html#page
    "Chapter 4. Counting the Pixels with Histograms"), *Counting the Pixels with Histograms*,
    uses the HSV color space in order to find an object in an image.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 4 章](part0032_split_000.html#page "第 4 章. 使用直方图计数像素")中，“使用均值漂移算法寻找对象”的菜谱在
    *Counting the Pixels with Histograms* 中使用 HSV 色彩空间来在图像中寻找对象。'
- en: 'Many good references are available on the color space theory. Among them, the
    following is a complete reference: *The Structure and Properties of Color Spaces
    and the Representation of Color Images*, *E. Dubois*, *Morgan and Claypool Publishers*,
    *2009*.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于色彩空间理论的许多良好参考资料都可用。其中之一是以下完整的参考书籍：*《色彩空间的结构与性质以及彩色图像的表示》，E. Dubois，Morgan
    and Claypool Publishers，2009*。
- en: Representing colors with hue, saturation, and brightness
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用色调、饱和度和亮度表示颜色
- en: In this chapter, we played with image colors. We used different color spaces
    and tried to identify image areas that have a specific color. The RGB color space,
    for instance, was considered, and although it is an effective representation for
    the capture and display of colors in electronic imaging systems, this representation
    is not very intuitive. This is not the way humans think about colors. We talk
    about colors in terms of their tint, brightness, or colorfulness (that is, whether
    it is a vivid or pastel color). The **phenomenal color spaces** based on the concept
    of hue, saturation, and brightness were introduced to help users to specify the
    colors using properties that are more intuitive to them. In this recipe, we will
    explore the concepts of hue, saturation, and brightness as a means to describe
    colors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们玩转了图像颜色。我们使用了不同的色彩空间并尝试识别具有特定颜色的图像区域。例如，RGB 色彩空间被认为是有效的，因为它在电子成像系统的捕获和显示颜色方面是有效的，但这种表示方法并不直观。这不是人类思考颜色的方式。我们谈论颜色时，会提到它们的色调、亮度或色彩度（也就是说，它是鲜艳的还是柔和的颜色）。基于色调、饱和度和亮度的
    **现象级色彩空间** 被引入，以帮助用户使用对他们来说更直观的属性来指定颜色。在本菜谱中，我们将探讨色调、饱和度和亮度作为描述颜色的手段。
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The conversion of a BGR image into a phenomenal color space is done using the
    `cv::cvtColor` function that was explored in the previous recipe. Here, we will
    use the `CV_BGR2HSV` conversion code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将 BGR 图像转换为现象级色彩空间是通过之前菜谱中探讨的 `cv::cvtColor` 函数完成的。在这里，我们将使用 `CV_BGR2HSV` 转换代码：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can go back to the BGR space using the `CV_HSV2BGR` code. We can visualize
    each of the HSV components by splitting the converted image channels into three
    independent images, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `CV_HSV2BGR` 代码回到 BGR 空间。我们可以通过将转换后的图像通道分割成三个独立的图像来可视化每个 HSV 分量，如下所示：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since we are working on 8-bit images, OpenCV rescales the channel values to
    cover the `0` to `255` range (except for the hue, which is rescaled between `0`
    and `180` as it will be explained in the next section). This is very convenient
    as we are able to display these channels as gray-level images. The value channel
    of the castle image will then look as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理 8 位图像，OpenCV 将通道值重新缩放以覆盖 `0` 到 `255` 的范围（除了色调，它将在下一节解释，其范围重新缩放为 `0`
    到 `180`）。这非常方便，因为我们能够将这些通道作为灰度图像显示。城堡图像的值通道将如下所示：
- en: '![How to do it…](img/00021.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/00021.jpeg)'
- en: 'The same image in the saturation channel will look as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在饱和度通道中的相同图像将如下所示：
- en: '![How to do it…](img/00022.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/00022.jpeg)'
- en: 'Finally, the image with the hue channel is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，色调通道的图像如下所示：
- en: '![How to do it…](img/00023.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/00023.jpeg)'
- en: These images are interpreted in the next section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像将在下一节进行解释。
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The phenomenal color spaces have been introduced because they correspond to
    the way humans tend to naturally organize colors. Indeed, humans prefer to describe
    colors with intuitive attributes such as tint, colorfulness, and brightness. These
    three attributes are the basis of most phenomenal color spaces. **Hue** designates
    the dominant color; the names that we give to colors (such as green, yellow, blue,
    and red) correspond to the different hue values. **Saturation** tells us how vivid
    the color is; pastel colors have low saturation, while the colors of the rainbow
    are highly saturated. Finally, **brightness** is a subjective attribute that refers
    to the luminosity of a color. Other phenomenal color spaces use the concept of
    color **value** or color **lightness** as a way to characterize the relative color
    intensity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现象颜色空间被引入，因为它们对应于人类倾向于自然组织颜色的方式。确实，人类更喜欢用直观属性来描述颜色，如色调、色彩丰富度和亮度。这三个属性是大多数现象颜色空间的基础。**色调**表示主导颜色；我们给颜色取的名字（如绿色、黄色、蓝色和红色）对应于不同的色调值。**饱和度**告诉我们颜色的鲜艳程度；柔和的颜色饱和度低，而彩虹的颜色饱和度高。最后，**亮度**是一个主观属性，指的是颜色的亮度。其他现象颜色空间使用颜色**值**或颜色**亮度**的概念作为表征相对颜色强度的方法。
- en: 'These color components try to mimic the intuitive human perception of colors.
    In consequence, there is no standard definition for them. In the literature, you
    will find several different definitions and formulae of the hue, saturation, and
    brightness. OpenCV proposes two implementations of phenomenal color spaces: the
    HSV and the HLS color spaces. The conversion formulas are slightly different,
    but they give very similar results.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些颜色成分试图模仿人类对颜色的直观感知。因此，它们没有标准定义。在文献中，你会找到关于色调、饱和度和亮度的几种不同定义和公式。OpenCV提出了两种现象颜色空间的实现：HSV颜色空间和HLS颜色空间。转换公式略有不同，但它们给出了非常相似的结果。
- en: The value component is probably the easiest to interpret. In the OpenCV implementation
    of the HSV space, it is defined as the maximum value of the three BGR components.
    It is a very simplistic implementation of the brightness concept. For a definition
    that matches the human visual system better, you should use the `L` channel of
    the L*a*b* or L*u*v* color spaces.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 价值成分可能是最容易解释的。在OpenCV对HSV空间的实现中，它被定义为三个BGR组件中的最大值。这是一个非常简单的亮度概念的实现。为了更好地匹配人类视觉系统，你应该使用L*a*b*或L*u*v*颜色空间的L通道。
- en: 'To compute the saturation, OpenCV uses a formula based on the minimum and maximum
    values of the BGR components:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算饱和度，OpenCV使用基于BGR组件的最小值和最大值的公式：
- en: '![How it works…](img/00024.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/00024.jpeg)'
- en: The idea is that a grayscale color in which the three R, G, and B components
    are all equal will correspond to a perfectly desaturated color; therefore, it
    will have a saturation value of `0`. Saturation is then a value between `0` and
    `1.0`. For 8-bit images, saturation is rescaled to a value between `0` and `255`,
    and when displayed as a gray-level image, brighter areas correspond to the colors
    that have a higher saturation color. For example, from the saturation image in
    the previous section, it can be seen that the blue of the water is more saturated
    than the light blue pastel color of the sky, as expected. The different shades
    of gray have, by definition, a saturation value equal to zero (because, in this
    case, all the three BGR components are equal). This can be observed on the different
    roofs of the castle, which are made of a dark gray stone. Finally, in the saturation
    image, you may have noticed some white spots located at areas that correspond
    to very dark regions of the original image. These are a consequence of the used
    definition for saturation. Indeed, because saturation measures only the relative
    difference between the maximum and minimum BGR values, a triplet such as (1,0,0)
    gives a perfect saturation of `1.0`, even if this color would be seen as black.
    Consequently, the saturation values measured at dark regions are unreliable and
    should not be considered.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是，当三个 R、G 和 B 分量都相等时，对应的灰度颜色将是一个完美的未饱和颜色；因此，它将有 `0` 的饱和度值。饱和度是一个介于 `0` 和 `1.0`
    之间的值。对于 8 位图像，饱和度被缩放到 `0` 到 `255` 之间的值，并且当以灰度图像显示时，亮度较高的区域对应于饱和度较高的颜色。例如，从上一节中的饱和度图像中可以看出，水的蓝色比天空的浅蓝色蜡笔颜色饱和度更高，正如预期的那样。根据定义，不同灰度的饱和度值等于零（因为在这种情况下，所有三个
    BGR 分量都相等）。这可以在城堡的不同屋顶上观察到，这些屋顶是由深灰色石头制成的。最后，在饱和度图像中，您可能会注意到一些位于原始图像非常暗的区域对应的白色斑点。这是由于饱和度使用的定义造成的。确实，因为饱和度只测量最大和最小
    BGR 值之间的相对差异，所以像 (1,0,0) 这样的三元组给出完美的饱和度 `1.0`，即使这种颜色看起来是黑色的。因此，在暗区域测量的饱和度值是不可靠的，不应予以考虑。
- en: The hue of a color is generally represented by an angle value between `0` and
    `360`, with the red color at `0` degree. In the case of an 8-bit image, OpenCV
    divides this angle by two to fit within the single byte range. Therefore, each
    hue value corresponds to a given color tint independent of its brightness and
    saturation. For example, both the sky and the water have the same hue value, approximately
    `200` degrees (intensity, `100`), which corresponds to the blue shade; the green
    color of the trees in the background has a hue of around `90` degrees. It is important
    to note that hue is less reliable when evaluated for colors that have a very low
    saturation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的色调通常用一个介于 `0` 到 `360` 度之间的角度值来表示，红色在 `0` 度。在 8 位图像的情况下，OpenCV 将这个角度除以二以适应单字节范围。因此，每个色调值对应于一个特定的颜色色调，与其亮度和饱和度无关。例如，天空和水都有相同的色调值，大约
    `200` 度（强度，`100`），这对应于蓝色调；背景中树木的绿色色调大约为 `90` 度。需要注意的是，当评估饱和度非常低的颜色时，色调的可靠性较低。
- en: The HSB color space is often represented by a cone, where each point inside
    corresponds to a particular color. The angular position corresponds to the hue
    of the color, the saturation is the distance from the central axis, and the brightness
    is given by the height. The tip of the cone corresponds to the black color for
    which the hue and saturation are undefined.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: HSB 颜色空间通常用一个圆锥体来表示，其中圆锥体内部的每一个点都对应一种特定的颜色。角度位置对应颜色的色调，饱和度是距离中心轴的距离，亮度由高度决定。圆锥体的尖端对应于黑色，其色调和饱和度都是未定义的。
- en: '![How it works…](img/00025.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/00025.jpeg)'
- en: 'Interesting effects can be created by playing with the HSV values. Several
    color effects that can be created using photo editing software are accomplished
    by this color space. For example, you may decide to modify an image by assigning
    a constant brightness to all the pixels of an image without changing the hue and
    saturation. This can be done as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整 HSV 值可以创建有趣的效果。使用照片编辑软件可以创建的几种颜色效果是通过这个颜色空间实现的。例如，您可能决定通过为图像的所有像素分配一个恒定的亮度来修改图像，而不改变色调和饱和度。这可以按以下方式完成：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This gives the following screenshot, which now looks like a drawing (see the
    book''s graphic bundle to view this image in color):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下截图，现在看起来像一幅画（参见书中的图形附件以查看此图像的颜色）：
- en: '![How it works…](img/00026.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/00026.jpeg)'
- en: There's more…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The HSV color space can also be very convenient to use when you want to look
    for objects of specific colors.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要寻找特定颜色的对象时，HSV颜色空间也非常方便使用。
- en: Using colors for detection – skin tone detection
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用颜色进行检测 – 肤色检测
- en: Color information can be very useful for the initial detection of specific objects.
    For example, the detection of road signs in a driver-assistance application could
    rely on the colors of standard signs in order to quickly extract potential road
    sign candidates. The detection of skin color is another example in which the detected
    skin regions could be used as an indicator of the presence of a human in an image;
    this approach is very often used in gesture recognition where skin tone detection
    is used to detect hand positions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色信息对于特定对象的初步检测非常有用。例如，在驾驶辅助应用中检测道路标志可能依赖于标准标志的颜色，以便快速提取潜在的标志候选对象。检测肤色是另一个例子，其中检测到的皮肤区域可以用作图像中存在人类的指示器；这种方法在手势识别中非常常用，其中肤色检测用于检测手部位置。
- en: 'In general, to detect an object using color, you first need to collect a large
    database of image samples that contain the object captured from different viewing
    conditions. These will be used to define the parameters of your classifier. You
    also need to select the color representation that you will use for classification.
    For skin tone detection, many studies have shown that skin color from the diverse
    ethnical groups clusters well in the hue-saturation space. For this reason, we
    will simply use the hue and saturation values to identify the skin tones in the
    following image (see the book''s graphic bundle to view this image in color):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要使用颜色检测对象，您首先需要收集包含从不同观察条件下捕获的对象的大数据库图像样本。这些将被用来定义您分类器的参数。您还需要选择您将用于分类的颜色表示。对于肤色检测，许多研究表明，来自不同种族群体的肤色在色调-饱和度空间中聚类良好。因此，我们将简单地使用色调和饱和度值来识别以下图像中的肤色（请参阅书籍的图形附件以查看此图像的颜色版本）：
- en: '![Using colors for detection – skin tone detection](img/00027.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![使用颜色进行检测 – 肤色检测](img/00027.jpeg)'
- en: 'Therefore, we have defined a function that classifies the pixels of an image
    as skin or non-skin simply based on an interval of values (the minimum and maximum
    hue, and the minimum and maximum saturation):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个函数，该函数仅基于值的区间（最小和最大色调，以及最小和最大饱和度）将图像的像素分类为皮肤或非皮肤：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Having a large set of skin (and non-skin) samples at our disposal, we could
    have used a probabilistic approach in which the likelihood of observing a given
    color in the skin class versus that of observing the same color in the non-skin
    class. Here, we empirically defined an acceptable hue-saturation interval for
    our test image (remember that the 8-bit version of the hue goes from 0 to 180
    and saturation goes from 0 to 255):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有大量的皮肤（和非皮肤）样本可供使用，我们本可以使用一种概率方法，其中观察给定颜色在皮肤类别中的可能性与观察相同颜色在非皮肤类别中的可能性。在这里，我们根据经验定义了我们测试图像的可接受色调-饱和度区间（请记住，色调的8位版本从0到180，饱和度从0到255）：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following detection image is obtained as the result:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下检测图像是结果：
- en: '![Using colors for detection – skin tone detection](img/00028.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用颜色进行检测 – 肤色检测](img/00028.jpeg)'
- en: Note that, for simplicity, we have not considered color saturation in the detection.
    In practice, excluding the colors with a high saturation would have reduced the
    possibility of the wrong detection of bright reddish colors as skin. Obviously,
    a reliable and accurate detection of skin color would require a much more elaborate
    analysis that would have to be based on a large number of skin samples. It is
    also very difficult to guarantee good detection across different images because
    many factors influence the color rendering in photography, such as white balancing
    and lighting conditions. Nevertheless, as shown in this chapter, only using hue
    information as an initial detector gives us acceptable results.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了简单起见，我们没有考虑检测中的颜色饱和度。在实践中，排除高饱和度的颜色会减少将明亮的红色误检为皮肤的可能性。显然，可靠的肤色检测需要更复杂、基于大量皮肤样本的分析。同时，保证在不同图像上都有良好的检测效果也非常困难，因为许多因素会影响摄影中的颜色渲染，例如白平衡和照明条件。尽管如此，正如本章所示，仅使用色调信息作为初始检测器就给出了可接受的结果。
