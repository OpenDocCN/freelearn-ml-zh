["```py\nfrom qiskit import *\n\n```", "```py\n\nq_0: \n\nq_1: \n\nc_0: \n\nc_1:\n\n```", "```py\n\nqreg1 = QuantumRegister(size = 2, name = \"qrg1\") \n\nqreg2 = QuantumRegister(1, \"qrg2\") \n\ncreg = ClassicalRegister(1, \"oldschool\") \n\nqc = QuantumCircuit(qreg1, creg, qreg2)\n\n```", "```py\n\n   qrg1_0: \n\n   qrg1_1: \n\n     qrg2: \n\noldschool:\n\n```", "```py\n\nimport numpy as np \n\nqc = QuantumCircuit(2) # Initialise the circuit. \n\n# We can now apply the gates sequentially. \n\nqc.x(0) \n\nqc.rx(np.pi/4, 1) \n\nqc.cx(0, 1) \n\nqc.u(np.pi/3, 0, np.pi, 0)\n\n```", "```py\n\nfrom qiskit.providers.aer import AerSimulator\n\n```", "```py\n\nsim = AerSimulator() \n\nsim_GPU = AerSimulator(device = ’GPU’)\n\n```", "```py\n\nqc = QuantumCircuit(2, 2) \n\nqc.h(0) \n\nqc.measure(range(2), range(2)) \n\njob = execute(qc, sim, shots = 1024) \n\nresult = job.result() \n\ncounts = result.get_counts() \n\nprint(counts)\n\n```", "```py\n\n{’01’: 519, ’00’: 505}\n\n```", "```py\n\nfrom qiskit.visualization import * \n\nplot_histogram(counts)\n\n```", "```py\n\nqc = QuantumCircuit(2, 2) \n\nqc.h(0) \n\nqc.save_statevector() \n\nqc.measure(0,0) \n\nqc.measure(1,1) \n\nresult = execute(qc, sim, shots = 1024).result() \n\nsv = result.get_statevector() \n\nprint(sv) \n\ncounts = result.get_counts() \n\nprint(counts)\n\n```", "```py\n\nStatevector([0.70710678+0.j, 0.70710678+0.j, 0\\.        +0.j, \n             0\\.        +0.j], \n            dims=(2, 2)) \n{’00’: 486, ’01’: 538}\n\n```", "```py\n\nsim_u = AerSimulator(method = ’unitary’) \n\nqc = QuantumCircuit(1) \n\nqc.h(0) \n\nqc.save_unitary() \n\nresult = execute(qc, sim_u).result() \n\nU = result.get_unitary(decimals = 4) \n\nprint(U)\n\n```", "```py\n\nOperator([[ 0.7071+0.j,  0.7071-0.j], \n\n          [ 0.7071+0.j, -0.7071+0.j]], \n\n         input_dims=(2,), output_dims=(2,))\n\n```", "```py\n\nprovider = IBMQ.load_account() \n\nprint(provider.backends(simulator = False))\n\n```", "```py\n\n[<IBMQBackend(’ibmq_lima’) from IBMQ(hub=’ibm-q’, \n    group=’open’, project=’main’)>, \n<IBMQBackend(’ibmq_belem’) from IBMQ(hub=’ibm-q’, \n    group=’open’, project=’main’)>, \n<IBMQBackend(’ibmq_quito’) from IBMQ(hub=’ibm-q’, \n    group=’open’, project=’main’)>, \n<IBMQBackend(’ibmq_manila’) from IBMQ(hub=’ibm-q’, \n    group=’open’, project=’main’)>, \n<IBMQBackend(’ibm_nairobi’) from IBMQ(hub=’ibm-q’, \n    group=’open’, project=’main’)>, \n<IBMQBackend(’ibm_oslo’) from IBMQ(hub=’ibm-q’, \n    group=’open’, project=’main’)>]\n\n```", "```py\n\ndev_list = provider.backends( \n\n    filters = lambda x: x.configuration().n_qubits >= 5, \n\n    simulator = False)\n\n```", "```py\n\nfrom qiskit.providers.ibmq import * \n\ndev = least_busy(dev_list)\n\n```", "```py\n\nfrom qiskit.providers.ibmq.job import job_monitor \n\n# Let us set up a simple circuit. \n\nqc = QuantumCircuit(2) \n\nqc.h(0) \n\nqc.cx(0,1) \n\nqc.measure_all() \n\n# First, we run the circuit using the statevector simulator. \n\nsim = AerSimulator() \n\nresult = execute(qc, sim, shots = 1024).result() \n\ncounts_sim = result.get_counts() \n\n# Now we run it on the real device that we selected before. \n\njob = execute(qc, dev, shots = 1024) \n\njob_monitor(job) \n\nresult = job.result() \n\ncounts_dev = result.get_counts()\n\n```", "```py\n\nprint(counts_sim) \n\nprint(counts_dev)\n\n```", "```py\n\n{’11’: 506, ’00’: 518} \n{’00’: 431, ’01’: 48, ’10’: 26, ’11’: 519}\n\n```", "```py\n\nimport pennylane as qml\n\n```", "```py\n\ndev = qml.device(’default.qubit’, wires = 2)\n\n```", "```py\n\ndef qc(): \n\n    qml.PauliX(wires = 0) \n\n    qml.Hadamard(wires = 0) \n\n    return qml.state()\n\n```", "```py\n\nqcirc = qml.QNode(qc, dev) # Assemble the circuit & the device. \n\nqcirc() # Run it!\n\n```", "```py\n\ntensor([ 0.70710678+0.j,  0\\.        +0.j, -0.70710678+0.j, \n         0\\.        +0.j], requires_grad=True)\n\n```", "```py\n\n@qml.qnode(dev) # We add this decorator to use the device dev. \n\ndef qcirc(): \n\n    qml.PauliX(wires = 0) \n\n    qml.Hadamard(wires = 0) \n\n    return qml.state() \n\n# Now qcirc is already a QNode. We can just run it! \n\nqcirc()\n\n```", "```py\n\ndev = qml.device(’default.qubit’, wires = 1) \n\n@qml.qnode(dev) \n\ndef qcirc(theta): \n\n    qml.RX(theta, wires = 0) \n\n    return qml.state()\n\n```", "```py\n\nprint(qml.draw(qcirc)(theta = 2))\n\n```", "```py\n\n0: --RX(2.00)--|  State\n\n```", "```py\n\ndev = qml.device(’default.qubit’, wires = 3) \n\n# Get probabilities \n\n@qml.qnode(dev) \n\ndef qcirc(): \n\n    qml.Hadamard(wires = 1) \n\n    return qml.probs(wires = [1, 2]) # Only the last 2 wires. \n\nprob = qcirc() \n\nprint(\"Probs. wires [1, 2] with H in wire 1:\", prob) \n\n# Get a sample, not having specified shots in the device. \n\n@qml.qnode(dev) \n\ndef qcirc(): \n\n    qml.Hadamard(wires = 0) \n\n    return qml.sample(wires = 0) # Only the first wire. \n\ns1 = qcirc(shots = 4) # We specify the shots here. \n\nprint(\"Sample 1 after H:\", s1) \n\n# Get a sample with shots in the device. \n\ndev = qml.device(’default.qubit’, wires = 2, shots = 4) \n\n@qml.qnode(dev) \n\ndef qcirc(): \n\n    qml.Hadamard(wires=0) \n\n    return qml.sample() # Will sample all wires. \n\ns2 = qcirc() \n\nprint(\"Sample 2 after H x I:\", s2)\n\n```", "```py\n\nProbs. wires [1, 2] with H in wire 1: [0.5 0\\.  0.5 0\\. ] \nSample 1 after H: [0 1 0 0] \nSample 2 after H x I: [[1 0], [0 0], [0 0], [1 0]]\n\n```", "```py\n\ndev = qml.device(’qiskit.aer’, wires = 2) \n\n@qml.qnode(dev) \n\ndef qcirc(): \n\n    qml.Hadamard(wires = 0) \n\n    return qml.probs(wires = 0) \n\ns = qcirc() \n\nprint(\"The probabilities are\", s)\n\n```", "```py\n\nThe probabilities are [0.48535156 0.51464844]\n\n```", "```py\n\ndev = qml.device(’qiskit.aer’, wires = 2, \n\n    backend=’aer_simulator_statevector’, shots = None)\n\n```", "```py\n\nfrom qiskit import * \n\nfrom qiskit.providers.ibmq import * \n\n# Save our token if we haven’t already. \n\nIBMQ.save_account(’TOKEN’) \n\n# Load the account and get the name of the least busy backend. \n\nprov = IBMQ.load_account() \n\nbck = least_busy(prov.backends(simulator = False)).name() \n\n# Invoke the PennyLane IBMQ device. \n\ndev = qml.device(’qiskit.ibmq’, wires = 1, \n\n    backend = bck, provider = prov) \n\n# Send a circuit and get some results! \n\n@qml.qnode(dev) \n\ndef qcirc(): \n\n    qml.Hadamard(wires = 0) \n\n    return qml.probs(wires = 0) \n\nprint(qcirc())\n\n```", "```py\n\n[0.51660156 0.48339844]\n\n```"]