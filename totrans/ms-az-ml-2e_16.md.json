["```py\nfrom scipy import spatial\nf1 = df.iloc[0, :]\nf2 = df.iloc[1, :]\n# compute the cosine distance between the first 2 rows\ncosine_distance = spatial.distance.cosine(f1, f2)\nprint(cosine_distance)\n# compute the cosine similarity between the first 2 rows\ncosine_similarity = 1 - spatial.distance.cosine(f1, f2)\nprint(cosine_similarity)\n```", "```py\n    params = {\n        'task': 'train',\n        'boosting_type': 'gbdt',\n        'num_class': 1,\n        'objective': \"binary\",\n        'metric': \"auc\",\n        'num_leaves': 64,\n        'min_data': 20,\n        'boost_from_average': True,\n        'feature_fraction': 0.8,\n        'learning_rate': 0.15,\n    }\n    ```", "```py\n    lgb_train = lgb.Dataset(x_train,\n                            y_train.reshape(-1),\n                            params=params)\n    lgb_test = lgb.Dataset(x_test,\n                           y_test.reshape(-1),\n                           reference=lgb_train)\n    ```", "```py\n    lgb_model = lgb.train(params,\n                          lgb_train,\n                          num_boost_round=100)\n    ```", "```py\n    y_pred = lgb_model.predict(x_test)\n    auc = roc_auc_score(np.asarray(y_test.reshape(-1)), \n                        np.asarray(y_pred))\n    ```", "```py\nimport numpy as np\ndef normalize_ratings(df,\n                      rating_col=\"rating\",\n                      user_col=\"user\"):    \n    groups = df.groupby(user_col)[rating_col]    \n    # computes group-wise mean/std    \n    mean = groups.transform(np.mean)    \n    std = groups.transform(np.std)    \n    return (df[rating_col] - mean) / std\ndf[\"rating_normalized\"] = normalize_ratings(df)\n```", "```py\nimport numpy as np\ndef cumsum_days(s, duration='D'):    \n    diff = s.diff().astype('timedelta64[%s]' % duration)\n    return diff.fillna(0).cumsum().values\n\ndef decay_ratings(df,\n                  decay=1,\n                  rating_col=\"rating\",\n                  time_col=\"t\"):\n    weight = np.exp(-cumsum_days(df[time_col]) * decay)\n    return df[rating_col] * weight\nhalf_life_t = 1\ndecay = np.log(2) / half_life_t\ndf[\"rating_decayed\"] = decay_ratings(df, decay=decay)\n```", "```py\n    import pyspark\n    from pyspark.ml.recommendation import ALS\n    sc = pyspark.SparkContext('local[*]')\n    n_iter = 10\n    rank = 10\n    l2_reg = 1\n    als = ALS() \\\n        .setMaxIter(n_iter) \\\n        .setRank(rank) \\\n        .setRegParam(l2_reg)\n    ```", "```py\n    model = als.fit(train_data)\n    ```", "```py\n    y_test = model.transform(test_data)\n    ```", "```py\n    from pyspark.ml.evaluation import RegressionEvaluator\n    scoring = RegressionEvaluator(metricName=\"rmse\",\n                                  labelCol=\"rating\",\n                                  predictionCol=\"y\")\n    ```", "```py\n    rmse = scoring.evaluate(y_test)\n    ```", "```py\npip install azure-cognitiveservices-personalizer\n```", "```py\n    personalization_base_url = \n      \"https://<name>.cognitiveservices.azure.com/\"\n    resource_key = \"<your-resource-key>\"\n    rank_url = personalization_base_url \\\n        + \"personalizer/v1.0/rank\"\n    reward_url = personalization_base_url \\\n        + \"personalizer/v1.0/events/\"\n    ```", "```py\n    eventid = uuid.uuid4().hex\n    data = {\n        \"eventid\": eventid,\n        \"contextFeatures\": user_features,\n        \"actions\": item_features\n    }\n    response = requests.post(rank_url,\n                             headers=headers,\n                             json=data)\n    ```", "```py\n    {\n      \"result\": {\n        \"ranking\": [\n          {\n            \"id\": \"ai-for-earth\",\n            \"probability\": 0.664000034\n          }, ...\n        ],\n        \"eventId\": \"482d82bc-2ff8-4721-8e92-607310a0a415\",\n        \"rewardActionId\": \"ai-for-earth\"\n      }\n    }\n    ```", "```py\n    action_id = response.json()[\"rewardActionId\"]\n    prediction = json.dumps(action_id).replace('\"','')\n    ```", "```py\n    reward_url = reward_url + eventid + \"/reward\"\n    response = requests.post(reward_url,\n                             headers=headers,\n                             json = {\"value\": reward})\n    ```"]