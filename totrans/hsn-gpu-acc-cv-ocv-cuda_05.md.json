["```py\n$ cd opencv\n$ mkdir build\n$ cd build \n```", "```py\ncmake -D CMAKE_BUILD_TYPE=RELEASE CMAKE_INSTALL_PREFIX=/usr/local WITH_CUDA=ON  ENABLE_FAST_MATH=1 CUDA_FAST_MATH=1 -D WITH_CUBLAS=1 OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib/modules BUILD_EXAMPLES=ON ..\n```", "```py\nMat img;\nimg= imread(\"cameraman.tif\");\n```", "```py\nMat img1(6,6,CV_8UC1); \n//This defines img1 object with size of 6x6, unsigned 8-bit integers and single channel.\n\nMat img2(256,256, CV_32FC1)\n//This defines img2 object with size of 256x256, 32 bit floating point numbers and single channel.\n\nMat img3(1960,1024, CV_64FC3)\n//This defines img3 object with size of 1960x1024, 64 bit floating point numbers and three channels.\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n  // Read the image \n  Mat img = imread(\"images/cameraman.tif\",0);\n\n  // Check for failure in reading an Image\n  if (img.empty()) \n  {\n    cout << \"Could not open an image\" << endl;\n    return -1;\n  }\n  //Name of the window\n  String win_name = \"My First Opencv Program\"; \n\n  // Create a window\n  namedWindow(win_name); \n\n  // Show our image inside the created window.\n  imshow(win_name, img); \n\n  // Wait for any keystroke in the window \n  waitKey(0); \n\n  //destroy the created window\n  destroyWindow(win_name); \n\n  return 0;\n}\n```", "```py\nMat img = cv::imread(\"cameraman.tif\")\n```", "```py\nFor compilation:\n$ g++ -std = c++11 image_read.cpp 'pkg_config --libs --cflags opencv' -o image_read \nFor execution:\n$./image_read\n```", "```py\nMat img = imread(\"images/autumn.tif\",1);\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n  //Create blank black grayscale Image with size 256x256\n  Mat img(256, 256, CV_8UC1, Scalar(0)); \n  String win_name = \"Blank Image\"; \n  namedWindow(win_name); \n  imshow(win_name, img); \n  waitKey(0); \n  destroyWindow(win_name); \n  return 0;\n}\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n  //Create blank blue color Image with size 256x256\n  Mat img(256, 256, CV_8UC3, Scalar(255,0,0)); \n  String win_name = \"Blank Blue Color Image\"; \n  namedWindow(win_name); \n  imshow(win_name, img); \n  waitKey(0); \n  destroyWindow(win_name); \n  return 0;\n}\n\n```", "```py\nMat img(512, 512, CV_8UC3, Scalar(0,0,0)); \n```", "```py\nline(img,Point(0,0),Point(511,511),Scalar(0,255,0),7);\n```", "```py\nrectangle(img,Point(384,0),Point(510,128),Scalar(255,255,0),5);\n```", "```py\ncircle(img,Point(447,63), 63, Scalar(0,0,255), -1);\n```", "```py\nellipse(img,Point(256,256),Point(100,100),0,0,180,255,-1);\n```", "```py\nputText( img, \"OpenCV!\", Point(10,500), FONT_HERSHEY_SIMPLEX, 3,Scalar(255, 255, 255), 5, 8 );\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char** argv)\n{\n\n  Mat img(512, 512, CV_8UC3, Scalar(0,0,0)); \n  line(img,Point(0,0),Point(511,511),Scalar(0,255,0),7);\n  rectangle(img,Point(384,0),Point(510,128),Scalar(255,255,0),5);\n  circle(img,Point(447,63), 63, Scalar(0,0,255), -1);\n  ellipse(img,Point(256,256),Point(100,100),0,0,180,255,-1);\n  putText( img, \"OpenCV!\", Point(10,500), FONT_HERSHEY_SIMPLEX, 3,Scalar(255, 255,  255), 5, 8 );\n  String win_name = \"Shapes on blank Image\"; \n  namedWindow(win_name); \n  imshow(win_name, img); \n  waitKey(0); \n  destroyWindow(win_name); \n  return 0;\n}\n```", "```py\nbool flag = imwrite(\"images/save_image.jpg\", img);\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\nusing namespace cv;\nusing namespace std;\nint main(int argc, char* argv[])\n{\n  //open the video file from PC\n  VideoCapture cap(\"images/rhinos.avi\"); \n  // if not success, exit program\n  if (cap.isOpened() == false) \n  {\n    cout << \"Cannot open the video file\" << endl;\n    return -1;\n  }\n  cout<<\"Press Q to Quit\" << endl;\n  String win_name = \"First Video\";\n  namedWindow(win_name); \n  while (true)\n  {\n    Mat frame;\n    // read a frame\n    bool flag = cap.read(frame); \n\n    //Breaking the while loop at the end of the video\n    if (flag == false) \n    {\n      break;\n    }\n    //display the frame \n    imshow(win_name, frame);\n    //Wait for 100 ms and key 'q' for exit\n    if (waitKey(100) == 'q')\n    {\n      break;\n    }\n  }\n  destroyWindow(win_name);\n  return 0;\n}\n```", "```py\ndouble frames_per_second = cap.get(CAP_PROP_FPS); \ncout << \"Frames per seconds of the video is : \" << frames_per_second ;\n```", "```py\n#include <opencv2/opencv.hpp>\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n  //open the Webcam\n  VideoCapture cap(0); \n  // if not success, exit program\n  if (cap.isOpened() == false) \n  {\n    cout << \"Cannot open Webcam\" << endl;\n    return -1;\n  }\n  //get the frames rate of the video from webcam\n  double frames_per_second = cap.get(CAP_PROP_FPS); \n  cout << \"Frames per seconds : \" << frames_per_second << endl;\n  cout<<\"Press Q to Quit\" <<endl;\n  String win_name = \"Webcam Video\";\n  namedWindow(win_name); //create a window\n  while (true)\n  {\n    Mat frame;\n    bool flag = cap.read(frame); // read a new frame from video \n    //show the frame in the created window\n    imshow(win_name, frame);\n    if (waitKey(1) == 'q')\n    {\n      break;\n    }\n  }\n  return 0;\n}\n```", "```py\nSize frame_size(640, 640);\nint frames_per_second = 30;\n\nVideoWriter v_writer(\"images/video.avi\", VideoWriter::fourcc('M', 'J', 'P', 'G'), frames_per_second, frame_size, true); \n\n//Inside while loop\nv_writer.write(frame); \n\n//After finishing video write\nv_writer.release();\n\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\n\nint main (int argc, char* argv[])\n{\n  //Read Two Images \n  cv::Mat h_img1 = cv::imread(\"images/cameraman.tif\");\n  cv::Mat h_img2 = cv::imread(\"images/circles.png\");\n  //Create Memory for storing Images on device\n  cv::cuda::GpuMat d_result1,d_img1, d_img2;\n  cv::Mat h_result1;\n  //Upload Images to device     \n  d_img1.upload(h_img1);\n  d_img2.upload(h_img2);\n\n  cv::cuda::add(d_img1,d_img2, d_result1);\n  //Download Result back to host\n  d_result1.download(h_result1);\n  cv::imshow(\"Image1 \", h_img1);\n  cv::imshow(\"Image2 \", h_img2);\n  cv::imshow(\"Result addition \", h_result1);\n  cv::imwrite(\"images/result_add.png\", h_result1);\n  cv::waitKey();\n  return 0;\n}\n```", "```py\n//d_result1 = d_img1 - d_img2\ncv::cuda::subtract(d_img1, d_img2,d_result1);\n```", "```py\nresult = α * img1 + β * img2 + γ \n```", "```py\ncv::cuda::addWeighted(d_img1,0.7,d_img2,0.3,0,d_result1)\n```", "```py\nresult_image = 255 - input_image\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\n\nint main (int argc, char* argv[])\n{\n  cv::Mat h_img1 = cv::imread(\"images/circles.png\");\n  //Create Device variables\n  cv::cuda::GpuMat d_result1,d_img1;\n  cv::Mat h_result1;     \n  //Upload Image to device\n  d_img1.upload(h_img1);\n\n  cv::cuda::bitwise_not(d_img1,d_result1);\n\n  //Download result back  to host\n  d_result1.download(h_result1);\n  cv::imshow(\"Result inversion \", h_result1);\n  cv::imwrite(\"images/result_inversion.png\", h_result1);\n  cv::waitKey();\n  return 0;\n}\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\n\nint main (int argc, char* argv[])\n{\n  cv::Mat h_img1 = cv::imread(\"images/autumn.tif\");\n  //Define device variables\n  cv::cuda::GpuMat d_result1,d_result2,d_result3,d_result4,d_img1;\n  //Upload Image to device\n  d_img1.upload(h_img1);\n\n  //Convert image to different color spaces\n  cv::cuda::cvtColor(d_img1, d_result1,cv::COLOR_BGR2GRAY);\n  cv::cuda::cvtColor(d_img1, d_result2,cv::COLOR_BGR2RGB);\n  cv::cuda::cvtColor(d_img1, d_result3,cv::COLOR_BGR2HSV);\n  cv::cuda::cvtColor(d_img1, d_result4,cv::COLOR_BGR2YCrCb);\n\n  cv::Mat h_result1,h_result2,h_result3,h_result4;\n  //Download results back to host\n  d_result1.download(h_result1);\n  d_result2.download(h_result2);\n  d_result3.download(h_result3);\n  d_result4.download(h_result4);\n\n  cv::imshow(\"Result in Gray \", h_result1);\n  cv::imshow(\"Result in RGB\", h_result2);\n  cv::imshow(\"Result in HSV \", h_result3);\n  cv::imshow(\"Result in YCrCb \", h_result4);\n\n  cv::waitKey();\n  return 0;\n}\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\n\nint main (int argc, char* argv[])\n{\n  cv::Mat h_img1 = cv::imread(\"images/cameraman.tif\", 0);\n  //Define device variables\n  cv::cuda::GpuMat d_result1,d_result2,d_result3,d_result4,d_result5, d_img1;\n  //Upload image on device\n  d_img1.upload(h_img1);\n\n  //Perform different thresholding techniques on device\n  cv::cuda::threshold(d_img1, d_result1, 128.0, 255.0, cv::THRESH_BINARY);\n  cv::cuda::threshold(d_img1, d_result2, 128.0, 255.0, cv::THRESH_BINARY_INV);\n  cv::cuda::threshold(d_img1, d_result3, 128.0, 255.0, cv::THRESH_TRUNC);\n  cv::cuda::threshold(d_img1, d_result4, 128.0, 255.0, cv::THRESH_TOZERO);\n  cv::cuda::threshold(d_img1, d_result5, 128.0, 255.0, cv::THRESH_TOZERO_INV);\n\n  cv::Mat h_result1,h_result2,h_result3,h_result4,h_result5;\n  //Copy results back to host\n  d_result1.download(h_result1);\n  d_result2.download(h_result2);\n  d_result3.download(h_result3);\n  d_result4.download(h_result4);\n  d_result5.download(h_result5);\n  cv::imshow(\"Result Threshhold binary \", h_result1);\n  cv::imshow(\"Result Threshhold binary inverse \", h_result2);\n  cv::imshow(\"Result Threshhold truncated \", h_result3);\n  cv::imshow(\"Result Threshhold truncated to zero \", h_result4);\n  cv::imshow(\"Result Threshhold truncated to zero inverse \", h_result5);\n  cv::waitKey();\n\n  return 0;\n}\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\nusing namespace cv;\nusing namespace std;\n\nint main (int argc, char* argv[])\n{\n  cv::Mat src = cv::imread(\"images/cameraman.tif\", 0);\n  cv::Mat result_host1,result_host2,result_host3,result_host4,result_host5;\n\n  //Get initial time in miliseconds\n  int64 work_begin = getTickCount(); \n  cv::threshold(src, result_host1, 128.0, 255.0, cv::THRESH_BINARY);\n  cv::threshold(src, result_host2, 128.0, 255.0,   cv::THRESH_BINARY_INV);\n  cv::threshold(src, result_host3, 128.0, 255.0, cv::THRESH_TRUNC);\n  cv::threshold(src, result_host4, 128.0, 255.0, cv::THRESH_TOZERO);\n  cv::threshold(src, result_host5, 128.0, 255.0, cv::THRESH_TOZERO_INV);\n\n  //Get time after work has finished     \n  int64 delta = getTickCount() - work_begin;\n  //Frequency of timer\n  double freq = getTickFrequency();\n  double work_fps = freq / delta;\n  std::cout<<\"Performance of Thresholding on CPU: \" <<std::endl;\n  std::cout <<\"Time: \" << (1/work_fps) <<std::endl;\n  std::cout <<\"FPS: \" <<work_fps <<std::endl;\n  return 0;\n}\n```", "```py\n#include <iostream>\n#include \"opencv2/opencv.hpp\"\n\nint main (int argc, char* argv[])\n{\n  cv::Mat h_img1 = cv::imread(\"images/cameraman.tif\", 0);\n  cv::cuda::GpuMat d_result1,d_result2,d_result3,d_result4,d_result5, d_img1;\n  //Measure initial time ticks\n  int64 work_begin = getTickCount(); \n  d_img1.upload(h_img1);\n  cv::cuda::threshold(d_img1, d_result1, 128.0, 255.0,   cv::THRESH_BINARY);\n  cv::cuda::threshold(d_img1, d_result2, 128.0, 255.0,   cv::THRESH_BINARY_INV);\n  cv::cuda::threshold(d_img1, d_result3, 128.0, 255.0, cv::THRESH_TRUNC);\n  cv::cuda::threshold(d_img1, d_result4, 128.0, 255.0, cv::THRESH_TOZERO);\n  cv::cuda::threshold(d_img1, d_result5, 128.0, 255.0, cv::THRESH_TOZERO_INV);\n\n  cv::Mat h_result1,h_result2,h_result3,h_result4,h_result5;\n  d_result1.download(h_result1);\n  d_result2.download(h_result2);\n  d_result3.download(h_result3);\n  d_result4.download(h_result4);\n  d_result5.download(h_result5);\n  //Measure difference in time ticks\n  int64 delta = getTickCount() - work_begin;\n  double freq = getTickFrequency();\n  //Measure frames per second\n  double work_fps = freq / delta;\n  std::cout <<\"Performance of Thresholding on GPU: \" <<std::endl;\n  std::cout <<\"Time: \" << (1/work_fps) <<std::endl;\n  std::cout <<\"FPS: \" <<work_fps <<std::endl;\n  return 0;\n}\n```"]