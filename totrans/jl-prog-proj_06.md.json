["```py\nCSV@v0.4.3\nDataFrames@v0.15.2\nDistances@v0.7.4\nIJulia@v1.14.1\nPlots@v0.22.0\nStatPlots@v0.8.2\n```", "```py\npkg> add PackageName@vX.Y.Z \n```", "```py\npkg> add IJulia@v1.14.1\n```", "```py\njulia> download(\"https://raw.githubusercontent.com/PacktPublishing/Julia-Programming-Projects/master/Chapter06/Project.toml\", \"Project.toml\")\npkg> activate . \npkg> instantiate\n```", "```py\njulia> using DelimitedFiles \nJulia> movies = readdlm(\"top_10_movies.tsv\", '\\t', skipstart=1) \nskipstart=1 tells Julia to skip the first line when reading the *Tab* separated top_10_movies.tsv file—otherwise, Julia would interpret the header row as a data row as well.\n```", "```py\n 10×9 Array{Any,2}: \n \"Moonlight (2016)\"                   0  0  0  1  0  0  0  0 \n \"Zootopia (2016)\"                    1  1  1  0  0  0  0  0 \n \"Arrival (2016)\"                     0  0  0  1  0  1  0  1 \n \"Hell or High Water (2016)\"          0  0  0  1  0  1  0  0 \n \"La La Land (2016)\"                  0  0  1  1  0  0  1  0 \n \"The Jungle Book (2016)\"             1  0  0  0  1  0  0  0 \n \"Manchester by the Sea (2016)\"       0  0  0  1  0  0  0  0 \n \"Finding Dory (2016)\"                0  1  0  0  0  0  0  0 \n \"Captain America: Civil War (2016)\"  1  0  0  0  0  0  0  1 \n \"Moana (2016)\"                       1  1  0  0  0  0  0  0 \n```", "```py\njulia> nemo = [\"Finding Nemo (2003)\", 0, 1, 1, 0, 1, 0, 0, 0] 9-element Array{Any,1}: \n  \"Finding Nemo (2003)\" \n 0 \n 1 \n 1 \n 0 \n 1 \n 0 \n 0 \n 0 \n```", "```py\njulia> using Pkg \npkg> add Distances  \njulia> using Distances \n```", "```py\njulia> distances = Dict{String,Int}() \nDict{String,Int64} with 0 entries \n\njulia> for i in 1:size(movies, 1) \n            distances[movies[i,:][1]] = hamming(Int[movies[i,2:end]...], Int[nemo[2:end]...]) \n       end \nFinding Nemo (2003). To do this, we only extracted the genres (leaving off the name of the movie) and converted the list of values into an array of Int. Finally, we placed the result of the computation into the distances Dict we defined previously, which uses the name of the movie as the key, and the distance as the value.\n```", "```py\njulia> distances \nDict{String,Int64} with 10 entries: \n  \"The Jungle Book (2016)\"            => 3 \n  \"Hell or High Water (2016)\"         => 5 \n  \"Arrival (2016)\"                    => 6 \n  \"La La Land (2016)\"                 => 4 \n  \"Moana (2016)\"                      => 3 \n  \"Captain America: Civil War (2016)\" => 5 \n  \"Moonlight (2016)\"                  => 4 \n  \"Finding Dory (2016)\"               => 2 \n  \"Zootopia (2016)\"                   => 2 \n  \"Manchester by the Sea (2016)\"      => 4\n```", "```py\nmovies = readdlm(\"/path/to/top_10_movies_user_rankings.csv\", ';') \n```", "```py\npkg> add DataFrames CSV \n```", "```py\njulia> movies = CSV.read(\"top_10_movies_user_rankings.csv\", delim = ';') \n```", "```py\njulia> describe(movies) \n```", "```py\njulia> movies[1,2] \nmissing\n\njulia> ismissing(movies[1, 2]) \ntrue \n```", "```py\njulia> for c in names(movies)[2:end] \n           movies[ismissing.(movies[c]), c] = 0 \n       end \n```", "```py\njulia> CSV.write(\"top_10_movies_user_rankings.tsv\", movies, delim='\\t') \n```", "```py\njulia> acton_and_annie = movies[:, 1:3] \n```", "```py\njulia> acton_and_annie_in_common = acton_and_annie[(acton_and_annie[:Acton] .> 0) .& (acton_and_annie[:Annie] .> 0), :] \n(acton_and_annie[:Acton] .> 0) .& (acton_and_annie[:Annie] .> 0) expression to check element-wise if the values in the Acton and Annie columns are greater than 0. Each comparison will return an array of true/false values—more exactly two 10-element BitArrays, as follows:\n```", "```py\njulia> acton_and_annie[:Acton] .> 0 \n10-element BitArray{1}: \n false \n  true \n  true \n  true \n  true \n  true \n false \n  true \n  true \n  true \n\njulia> acton_and_annie[:Annie] .> 0 \n10-element BitArray{1}: \n  true \n  true \n false \n false \n false \n  true \n false \n  true \n false \n  true \n```", "```py\njulia> (acton_and_annie[:Acton] .> 0) .& (acton_and_annie[:Annie] .> 0) \n10-element BitArray{1}: \n false \n  true \n false \n false \n false \n  true \n false \n  true \n false \n  true \nDataFrame that contains only the movies that have been rated by both Acton and Annie:\n```", "```py\njulia> plot(acton_and_annie_in_common[:,2], acton_and_annie_in_common[:,3], seriestype=:scatter, xticks=0:10, yticks=0:10, lims=(0,11), label=\"\")\nplot function, passing it Acton's and Annie's ratings. As options, we ask it to produce a scatter plot. We also want to make sure that the axes start at 0 and end at 11 (so that value 10 is fully visible), with ticks at each unit. We'll end up with the following plot:\n```", "```py\njulia> @df acton_and_annie_in_common scatter([:Acton], [:Annie], smooth = true, line = :red, linewidth = 2, title = \"Acton and Annie\", legend = false, xlimits = (5, 11), ylimits = (5, 11)) \n```", "```py\njulia> using Statistics \njulia> cor(acton_and_annie_in_common[:Acton], acton_and_annie_in_common[:Annie]) \n\n0.6324555320336759 \n```", "```py\njulia> annies_recommendations = acton_and_annie[(acton_and_annie[:Annie] .== 0) .&  (acton_and_annie[:Acton] .> 0), :]\nacton_and_annie DataFrame, we only select the rows where Annie's score is 0 (she hasn't rated the movie) and Acton's is greater than 0 (he has rated the movie).\n```", "```py\njulia> annies_recommendations = acton_and_annie[(acton_and_annie[:Annie] .== 0) .&(acton_and_annie[:Acton] .>= 7 ), :] \n```", "```py\nusing CSV, DataFrames, Statistics\n\nconst minimum_similarity = 0.8\nconst movies = CSV.read(\"top_10_movies_user_rankings.tsv\", delim = '\\t')\n\nfunction user_similarity(target_user)\n    similarity = Dict{Symbol,Float64}()\n    for user in names(movies[:, 2:end])\n        user == target_user && continue\n        ratings = movies[:, [user, target_user]]\n        common_movies = ratings[(ratings[user] .> 0) .& (ratings[target_user] .> 0), :]\n\n        correlation = try\n            cor(common_movies[user], common_movies[target_user])\n        catch\n            0.0\n        end\n\n        similarity[user] = correlation\n    end\n\n    similarity\nend\n\nfunction recommendations(target_user)\n    recommended = Dict{String,Float64}()\n    for (user,similarity) in user_similarity(target_user)\n        similarity > minimum_similarity || continue\n        ratings = movies[:, [Symbol(\"Movie title\"), user, target_user]]\n        recommended_movies = ratings[(ratings[user] .>= 7) .& (ratings[target_user] .== 0), :]\n\n        for movie in eachrow(recommended_movies)\n            recommended[movie[Symbol(\"Movie title\")]] = movie[user] * similarity\n        end\n    end\n\n    recommended\nend\n\nfor user in names(movies)[2:end]\n    println(\"Recommendations for $user: $(recommendations(user))\")\nend\nuser_similarity and recommendations. They both take, as their single argument, a user's name in the form of a Symbol. This argument matches the column name in our movies DataFrame.\n```", "```py\nDict(\n    :Comey => 1.0,\n    :Dean => 0.907841,\n    :Missie => NaN,\n    :Kit => 0.774597,\n    :Musk => 0.797512,\n    :Sam => 0.0,\n    :Acton => 0.632456\n)\n```", "```py\nRecommendations for Acton: Dict(\"Moonlight (2016)\"=>9.0)\nRecommendations for Annie: Dict(\"La La Land (2016)\"=>8.0)\nRecommendations for Comey: Dict(\"The Jungle Book (2016)\"=>7.0,\"Moana (2016)\"=>7.0,\"Moonlight (2016)\"=>9.0)\nRecommendations for Dean: Dict(\"Moana (2016)\"=>10.0,\"Zootopia (2016)\"=>10.0)\nRecommendations for Kit: Dict(\"Hell or High Water (2016)\"=>10.0,\"Arrival (2016)\"=>10.0,\"La La Land (2016)\"=>9.0,\"Moonlight (2016)\"=>10.0,\"Manchester by the Sea (2016)\"=>8.0)\nRecommendations for Missie: Dict(\"The Jungle Book (2016)\"=>8.0,\n\"Moana (2016)\"=>8.0, \"La La Land (2016)\"=>8.0,\"Captain America: Civil War (2016)\"=>10.0,\"Finding Dory (2016)\"=>7.0,\"Zootopia (2016)\"=>9.0)\nRecommendations for Musk: Dict{String,Float64}()\nRecommendations for Sam: Dict(\"Hell or High Water (2016)\"=>10.0,\n\"La La Land (2016)\"=>9.0,\"Moonlight (2016)\"=>10.0,\"Zootopia (2016)\"=>7.0,\"Manchester by the Sea (2016)\"=>8.0)\n```", "```py\njulia> movies[:, [Symbol(\"Movie title\"), :Dean, :Kit]] \n```", "```py\ncommon_movies = ratings[(ratings[user] .> 0) .& (ratings[target_user] .> 0), :]\n```", "```py\ncommon_movies = ratings[Array(ratings[user] .> 7) .& Array(ratings[target_user] .> 0), :]\n```", "```py\nRecommendations for Acton: Dict(\"Moonlight (2016)\"=>9.0) \nRecommendations for Annie: Dict{String,Float64}() \nRecommendations for Comey: Dict( \n\"Moana (2016)\"=>9.0, \n\"Moonlight (2016)\"=>9.0) \nRecommendations for Dean: Dict( \n\"Moana (2016)\"=>8.0, \n\"Zootopia (2016)\"=>9.0) \nRecommendations for Kit: Dict{String,Float64}() \nRecommendations for Missie: Dict{String,Float64}() \nRecommendations for Musk: Dict{String,Float64}() \nRecommendations for Sam: Dict{String,Float64}() \n```", "```py\nusing CSV, DataFrames, DelimitedFiles, Statistics\n\nconst minimum_similarity = 0.8\n\nfunction setup_data()\n    movies = readdlm(\"top_10_movies_user_rankings.tsv\", '\\t')\n    movies = permutedims(movies, (2,1))\n    movies = convert(DataFrame, movies)\n\n    names = convert(Array, movies[1, :])[1,:]\n    names!(movies, [Symbol(name) for name in names])\n    deleterows!(movies, 1)\n    rename!(movies, [Symbol(\"Movie title\") => :User])\nend\n\nfunction movie_similarity(target_movie)\n    similarity = Dict{Symbol,Float64}()\n    for movie in names(movies[:, 2:end])\n        movie == target_movie && continue\n        ratings = movies[:, [movie, target_movie]]\n        common_users = ratings[(ratings[movie] .>= 0) .& (ratings[target_movie] .> 0), :]\n\n        correlation = try\n            cor(common_users[movie], common_users[target_movie])\n        catch\n            0.0\n        end\n\n        similarity[movie] = correlation\n    end\n\n    # println(\"The movie $target_movie is similar to $similarity\")\n    similarity\nend\n\nfunction recommendations(target_movie)\n    recommended = Dict{String,Vector{Tuple{String,Float64}}}()\n    # @show target_movie\n    # @show movie_similarity(target_movie)\n\n    for (movie, similarity) in movie_similarity(target_movie)\n        movie == target_movie && continue\n        similarity > minimum_similarity || continue\n        # println(\"Checking to which users we can recommend $movie\")\n        recommended[\"$movie\"] = Vector{Tuple{String,Float64}}()\n\n        for user_row in eachrow(movies)\n            if user_row[target_movie] >= 5\n                # println(\"$(user_row[:User]) has watched $target_movie so we can recommend similar movies\")\n                if user_row[movie] == 0\n                    # println(\"$(user_row[:User]) has not watched $movie so we can recommend it\")\n                    # println(\"Recommending $(user_row[:User]) the movie $movie\")\n                    push!(recommended[\"$movie\"], (user_row[:User], user_row[target_movie] * similarity))\n                end\n            end\n        end\n    end\n\n    recommended\nend\n\nconst movies = setup_data()\nprintln(\"Recommendations for users that watched Finding Dory (2016): $(recommendations(Symbol(\"Finding Dory (2016)\")))\")\n```", "```py\njulia> movies = readdlm(\"top_10_movies_user_rankings.tsv\", '\\t') \n```", "```py\njulia> movies = permutedims(movies, (2,1)) \n```", "```py\njulia> movies = convert(DataFrame, movies) \n```", "```py\njulia> movie_names = convert(Array, movies[1, :])[1,:] \n11-element Array{Any,1}: \n \"Movie title\" \n \"Moonlight (2016)\" \n \"Zootopia (2016)\" \n \"Arrival (2016)\" \n \"Hell or High Water (2016)\" \n \"La La Land (2016)\" \n \"The Jungle Book (2016)\" \n \"Manchester by the Sea (2016)\" \n \"Finding Dory (2016)\" \n \"Captain America: Civil War (2016)\" \n \"Moana (2016)\" \n```", "```py\njulia> names!(movies, [Symbol(name) for name in movie_names]) \n```", "```py\njulia> deleterows!(movies, 1) julia> rename!(movies, Symbol(\"Movie title\") => :User) \n```", "```py\nDict( \nSymbol(\"La La Land (2016)\")=>-0.927374, \nSymbol(\"Captain America: Civil War (2016)\")=>-0.584176, \nSymbol(\"The Jungle Book (2016)\")=>0.877386, \nSymbol(\"Manchester by the Sea (2016)\")=>-0.785933, \nSymbol(\"Arrival (2016)\")=>-0.927809, \nSymbol(\"Zootopia (2016)\")=>0.826331, \nSymbol(\"Moonlight (2016)\")=>-0.589269, \nSymbol(\"Hell or High Water (2016)\")=>-0.840462, \nSymbol(\"Moana (2016)\")=>0.933598\n) \n```", "```py\nRecommendations for users that watched Finding Dory (2016): \nDict( \n    \"The Jungle Book (2016)\"=> Tuple{String,Float64}[(\"Comey\", 4.38693)], \n    \"Moana (2016)\"=> Tuple{String,Float64}[(\"Comey\", 4.66799)], \n    \"Zootopia (2016)\"=> Tuple{String,Float64}[]\n)\n```"]