- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Federated Learning Server Implementation with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server-side implementation of a **federated learning** (**FL**) system is
    critical for realizing authentic FL-enabled applications. We have discussed the
    basic system architecture and flow in the previous chapter. In this chapter, more
    hands-on implementation will be discussed so that you can create a simple server
    and aggregator of the FL system that various **machine learning** (**ML**) applications
    can be connected to and tested on.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes an actual implementation aspect of FL server-side components
    discussed in [*Chapter 3*](B18369_03.xhtml#_idTextAnchor058), *Workings of the
    Federated Learning System*. Based on the understanding of how the entire process
    of the FL system works, you will be able to go one step further to make it happen
    with example code provided here and on GitHub. Once you understand the basic implementation
    principles using the example code, it is a fun aspect to be able enhance the FL
    server functionalities based on your own design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Main software components of the aggregator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing FL server-side functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining models for aggregation with the state manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregating local models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the FL server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and running the database server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential enhancements to the FL server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the code files introduced in this chapter can be found on GitHub here:
    [https://github.com/tie-set/simple-fl](https://github.com/tie-set/simple-fl).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can use the code files for personal or educational purposes. However, please
    note that we will not support deployments for commercial use and will not be responsible
    for any errors, issues, or damages caused by using the code.
  prefs: []
  type: TYPE_NORMAL
- en: "Main software components of the aggregator \Land database"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The architecture of an aggregator with the FL server was introduced in the
    previous chapter. Here, we will introduce the code that realizes the basic functionalities
    of an FL system. The aggregator and database-side Python-based software components
    are listed in the `aggregator` directory of `fl_main`, as well as `lib/util` and
    `pseudodb` folders, as in *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Python software components for the aggregator as well as internal
    libraries and pseudo database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18369_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Python software components for the aggregator as well as internal
    libraries and pseudo database
  prefs: []
  type: TYPE_NORMAL
- en: The following is a brief description of the Python code files in the aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregator-side codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will touch on the main Python files of the aggregator-side
    related to the FL server thread, FL state manager, and model aggregation itself.
    These aggregator-side code files are found in the `aggregator` folder. The code
    in the repo only captures the model aggregation perspective, not the entire engineering
    aspects of creating a thorough FL platform.
  prefs: []
  type: TYPE_NORMAL
- en: FL server code (server_th.py)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the main code that realizes the whole basic flow of the FL process from
    the communication processes between an aggregator itself, agents, and a database
    to coordinating agent participation and the aggregation of the ML models. It also
    initializes the global cluster model sent from the first connected agent. It manages
    receiving local models and the cluster model synthesis routine in which the cluster
    global model is formed after collecting enough local models.
  prefs: []
  type: TYPE_NORMAL
- en: FL state manager (state_manager.py)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The state manager buffers the local model and cluster model data that is needed
    for aggregation processes. The buffers will be filled out when the aggregator
    receives local models from the agents and cleared when proceeding to the next
    round of the FL process. The checking function of the aggregation criteria is
    also defined in this file.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation code (aggregation.py)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aggregation Python code will list the basic algorithms for aggregating the
    model. In the code example used here in this chapter, we will only introduce the
    averaging method called **federated averaging** (**FedAvg**), which averages the
    weights of the collected local models considering local dataset sizes to generate
    a cluster global model.
  prefs: []
  type: TYPE_NORMAL
- en: lib/util codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python files for the internal libraries (`communication_handler.py`, `data_struc.py`,
    `helpers.py`, `messengers.py`, and `states.py`) will be explained in the *Appendix*,
    *Exploring Internal Libraries*.
  prefs: []
  type: TYPE_NORMAL
- en: Database-side code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Database-side code consists of the pseudo database and the SQLite database Python
    code files that can be found in the `pseudodb` folder. The pseudo database code
    is hosting a server to receive messages from the aggregator and purse them to
    process as the ML model data that can be utilized for the FL process.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo database code (pseudo_db.py)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function of pseudo database Python code is to accept the messages related
    to the local and global cluster models from the aggregator and push the information
    to the database. It also saves the ML model binary files in the local file system.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite database code (sqlite_db.py)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite database Python code creates an actual SQLite database at the specified
    path. It also has the function to insert data entries related to the local and
    global cluster models into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the aggregator and database-side software components are defined, let's
    move on to the configuration of the aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the configuration of the aggregator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code is an example of the aggregator-side configuration parameters
    defined in the `config_aggregator.json` file, which can be found in the `setups`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The parameters include the aggregator’s IP (the FL server’s IP), the database
    server’s IP, and the various port numbers of the database and agents. The round
    interval is the time of the interval at which the criteria of aggregation are
    checked and the aggregation threshold defines the percentage of collected local
    ML models needed to start the aggregation process. The polling flag is related
    to whether to utilize the `polling` method for communications between the aggregator
    and agents or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the concept of the configuration file for the aggregator
    side, let’s move on to how the code is designed and implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FL server-side functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explain how you can implement the very first version
    of an aggregator with an FL server system using the actual code examples, which
    are in `server_th.py` in the `aggregator` directory. In this way, you will understand
    the core functionalities of the FL server system and how they are implemented
    so that you can further enhance a lot more functionalities on your own. Therefore,
    we will only cover the important and core functionalities that are critical to
    conducting a simple FL process. The potential enhancements will be listed in the
    later section of this chapter, *Potential enhancements to the FL server*.
  prefs: []
  type: TYPE_NORMAL
- en: '`server_th.py` handles all the aspects of basic functionalities related to
    the FL server side, so let’s look into that in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing libraries for the FL server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FL server-side code starts with importing the necessary libraries. In particular,
    `lib.util` handles the basic supporting functionalities to make the implementation
    of FL easy. The details of the code can be found in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: The server code imports `StateManager` and `Aggregator` for the FL processes.
    The code about the state manager and aggregation will be discussed in later sections
    in this chapter about *Maintaining models for aggregation with the state manager*
    and *Aggregating local models.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for importing the necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After we import the necessary libraries, let us move on to designing an FL `Server`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the FL Server class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In practice, it is wise to define the `Server` class, using which you can create
    an instance of the FL server that has the functionalities discussed in [*Chapter
    3*](B18369_03.xhtml#_idTextAnchor058), *Workings of the Federated Learning System*,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `server` class primarily provides the functionalities of agent registration
    and global model synthesis and handles the mechanisms of uploaded local models
    and polling messages sent from agents. It also serves as the interface between
    the aggregator and database and between the aggregator and agents.
  prefs: []
  type: TYPE_NORMAL
- en: The FL server class functionality is now clear – next is initializing and configuring
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the FL server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code inside the `__init__` constructor is an example of the initialization
    process of the `Server` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, `self.config` stores the information from the `config_aggregator.json`
    file discussed in the preceding code block.
  prefs: []
  type: TYPE_NORMAL
- en: '`self.sm` and `self.agg` have instances of the state manager class and aggregator
    class discussed as follows, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.aggr_ip` reads an IP address from the aggregator’s configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, `reg_socket` and `recv_socket` will be set up, where `reg_socket` is used
    for agents to register themselves together with an aggregator IP address stored
    as `self.aggr_ip`, and `recv_socket` is used for receiving local models from agents,
    together with an aggregator IP address stored as `self.aggr_ip`. Both `reg_socket`
    and `recv_socket` in this example code can be read from the aggregator’s configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `exch_socket` is the port number used to send the global model back to the
    agent together with the agent IP address, which is initialized with the configuration
    parameter in the initialization process.
  prefs: []
  type: TYPE_NORMAL
- en: The information to get connected to the database server will then be configured,
    where `dp_ip` and `db_socket` will be the IP address and the port number of the
    database server, respectively, all read from the `config_aggregator.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: '`round_interval` is an interval time to check whether the aggregation criteria
    for starting the model aggregation process are met or not.'
  prefs: []
  type: TYPE_NORMAL
- en: The `is_polling` flag is related to whether to use the `polling` method from
    the agents or not. The polling flag must be the same as the one used in the agent-side
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '`agg_threshold` is also the percentage over the number of collected local models
    that is used in the `ready_for_local_aggregation` function where if the percentage
    of the collected models is equal to or more than `agg_threshold`, the FL server
    starts the aggregation process of the local models.'
  prefs: []
  type: TYPE_NORMAL
- en: Both `self.round_interval` and `self.agg_threshold` are read from the configuration
    file in this example code too.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the configuration has been set up, we will talk about how to register
    agents that are trying to participate in the FL process.
  prefs: []
  type: TYPE_NORMAL
- en: Registration function of agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, the simplified and asynchronous `register` function is described
    to receive the participation message specifying the model structures and return
    socket information for future model exchanges. It also sends the welcome message
    back to the agent as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The registration process of agents is described in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example code, the received message from an agent, defined here as `msg`,
    is decoded by the `receive` function imported from the `communication_handler`
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the `self.sm.add_agent(agent_name, agent_id, addr, es)` function
    takes the agent name, agent ID, agent IP address, and the `exch_socket` number
    included in the `msg` message in order to accept the messages from this agent,
    even if the agent is temporarily disconnected and then connected again.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the registration function checks whether it should move on to the
    process of initial models or not, depending on the FL round that is tracked with
    `self.sm.round`. If the FL process is not happening yet, that is, if `self.sm.round`
    is `0`, it calls the `_initialize_fl(msg)` function in order to initialize the
    FL process.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the FL server sends the updated global model back to the agent by calling
    the `_send_updated_global_model(websocket, id, es)` function. The function takes
    the WebSocket, agent ID, and `exch_socket` as parameters and creates a reply message
    to the agent to notify it whether the participation message has been accepted
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: The registration process of agents with the FL server is simplified in this
    example code here. In a production environment, all the system information from
    the agent will be pushed to the database so that an agent that loses the connection
    to the FL server can be recovered anytime by reconnecting to the FL server.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, if the FL server is installed in the cloud and agents are connected
    to the FL server from their local environment, this push-back mechanism from the
    aggregator to agents will not work because of security settings such as firewalls.
    We do not discuss the topic of security issues in this book in detail, so you
    are encouraged to use the `polling` method implemented in the `simple-fl` code
    to communicate between the cloud-based aggregator and local agents.
  prefs: []
  type: TYPE_NORMAL
- en: Getting socket information to push the global model back to agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following function called `_get_exch_socket` takes a participation message
    from the agent and decides which port to use to reach out to the agent depending
    on the simulation flag in the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We support a simulation run in this implementation exercise by which you can
    run all the FL system components of a database, aggregator, and multiple agents
    in one machine.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the FL process if necessary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The asynchronous `_initialize_fl` function is for initializing an FL process
    that is only called when the round of FL is `0`. The following is the code to
    do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After extracting the agent ID (`agent_id`), the model ID (`model_id`), local
    models from an agent (`lmodels`), the generated time of the model (`gene_time`),
    the performance data (`perf_val`), and the value of `init_flag` from the received
    message, the `initialize_model_info` function of the state manager code is called,
    which is explained in a later section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This function then pushes the local model to the database by calling the `_push_local_models`
    function, which is also described in this section. You can refer to the *Functions
    to push the local and global models to the database* section.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the round is incremented to proceed to the first round in FL.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming agent participation with an updated global model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After initializing the (cluster) global model, the global models need to be
    sent to the agent connected to the aggregator through this registration process.
    The asynchronous `_send_updated_global_model` function as follows handles the
    process of sending the global models to the agent by taking the WebSocket information,
    agent ID, and the port to use to reach out to the agent as parameters. The following
    code block describes the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the FL process has already started, that is, the `self.sm.round` is more
    than 0 already, we get the cluster models from their buffer and convert them into
    a dictionary format with the `convert_LDict_to_Dict` library function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the reply message is packaged using the `generate_` `agent_participation_confirm_message`
    function and sent to the agent that just connected or reconnected to the aggregator
    by calling the `send_websocket(reply, websocket)` function. Please also refer
    to the *Functions to send the global models to the agents* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the agents’ registration process, let’s move on to the
    implementation of handling the local ML models and polling messages.
  prefs: []
  type: TYPE_NORMAL
- en: The server for handling messages from local agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The asynchronous `receive_msg_from_agent` process at the FL server is constantly
    running to receive local model updates and to push them to the database and the
    memory buffer temporally saving local models. It also responds to the polling
    messages from the local agents. The following code explains this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will then look into the two functions called by the `receive_msg_from_agent`
    function as shown in the preceding code blocks, which are the `_process_lmodel_upload`
    and `_process_polling` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Processing a model upload by local agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The asynchronous `_process_lmodel_upload` function deals with the `AgentMsgType.update`
    message. The following code block is about the function related to receiving the
    local ML models and putting them into the buffer in the state manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, it extracts the agent ID (`agent_id`), the model ID (`model_id`), local
    models from an agent (`lmodels`), the generated time of the model (`gene_time`),
    and the performance data (`perf_val`) from the received message, and then calls
    the `_push_local_models` function to push the local models to the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `buffer_local_models` function is then called to save the local models (`lmodels`)
    in the memory buffer. The `buffer_local_models` function is described in the *Maintaining
    models for aggregation with the state manager* section.
  prefs: []
  type: TYPE_NORMAL
- en: Processing polling by agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following asynchronous `_process_polling` function deals with the `AgentMsgType.polling`
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If the FL round (`self.sm.round`) is greater than the local FL round included
    in the received message that is maintained by the local agent itself, it means
    that the model aggregation is done during the period between the time when the
    agent polled to the aggregator last time and now.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `cluster_models` that are converted into a dictionary format are
    packaged into a response message by `generate_cluster_model_dist_message` and
    sent back to the agent via the `send_websocket` function.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the aggregator just returns the *ACK* message to the agent, generated
    by the `generate_ack_message` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to aggregate the local models received from the agents, so
    let us look into the model aggregation routine.
  prefs: []
  type: TYPE_NORMAL
- en: The global model synthesis routine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The global model synthesis routine process designed in `async def model_synthesis_routine(self)`
    in the FL server periodically checks the number of stored models and executes
    global model synthesis if there are enough local models collected to meet the
    aggregation threshold.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code describes the model synthesis routine process that periodically
    checks the aggregation criteria and executes model synthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This process is asynchronous, running with a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, once the criteria set by `ready_for_local_aggregation` (explained
    in the *Maintaining models for aggregation with the state manager* section) are
    met, the `aggregate_local_models` function imported from the `aggregator.py` file
    is called, where this function averages the weights of the collected local models
    based on `FedAvg`. Further explanation of the `aggregate_local_models` function
    can be found in the *Aggregating local models* section.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `await self._push_cluster_models()` is called to push the aggregated cluster
    global model to the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`await self._send_cluster_models_to_all()` is for sending the updated global
    model to all the agents connected to the aggregator if the `polling` method is
    not used.'
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the FL round is incremented by `self.sm.increment_round()`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the cluster global model is generated, the models need to be sent to the
    connected agents with the functions described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Functions to send the global models to the agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The functionality of sending global models to the connected agents is dealt
    with by the `_send_cluster_models_to_all` function. This is an asynchronous function
    to send out cluster global models to all agents under this aggregator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After getting the cluster models’ information, it creates the message including
    the cluster models, round, model ID, and aggregator ID information using the `generate_cluster_model_dist_message`
    function and calls the `send` function from the `communication_handler` libraries
    to send the global models to all the agents in the `agent_set` registered through
    the agent participation process.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the cluster global models to the connected agents has now been explained.
    Next, we explain how to push the local and cluster models to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Functions to push the local and global models to the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `_push_local_models` and `_push_cluster_models` functions are both called
    internally to push and send the local models and cluster global models to the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing local models to the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the `_push_local_models` function for pushing a given set of local
    models to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `_push_local_models` function takes parameters such as the agent ID, local
    models, the model ID, the generated time of the model, and the performance data,
    and returns a response message if there is one.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing cluster models to the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following `_push_cluster_models` function is for pushing the cluster global
    models to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`_push_cluster_models` in this code does not take any parameters, as those
    parameters can be obtained from the instance information and buffered memory data
    of the state manager. For example, `self.sm.cluster_model_ids[-1]` obtains the
    ID of the latest cluster model, and `self.sm.cluster_models` stores the latest
    cluster model itself, which is converted into `models` with a dictionary format
    to be sent to the database. It also creates `mata_dict` to store the number of
    samples.'
  prefs: []
  type: TYPE_NORMAL
- en: Pushing ML models to the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both the preceding functions call the `_push_models` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, the `_push_models` function takes parameters such as `component_id`
    (the ID of the aggregator or agent), `model_type`, such as local or cluster model,
    `models` themselves, `model_id`, `gene_time` (the time the model is created),
    and `performance_dict` as the performance metrics of the models. Then, the message
    to be sent to the database (using the `send` function) is created by the `generate_db_push_message`
    function, taking these parameters together with the FL round information. It returns
    a response message from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explained all the core functionalities related to the FL server,
    let us look into the role of the state manager, which maintains all the models
    needed for the aggregation process.
  prefs: []
  type: TYPE_NORMAL
- en: "Maintaining models for aggregation with the \Lstate manager"
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explain `state_manager.py,` which handles maintaining
    the models and necessary volatile information related to the aggregation of local
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the libraries of the state manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code imports the following. The internal libraries for `data_struc`, `helpers`,
    and `states` are introduced in the *Appendix*, *Exploring Internal Libraries*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After importing the necessary libraries, let’s define the state manager class.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the state manager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The state manager class (`Class StateManager`), as seen in `state_manager.py`,
    is defined in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This keeps track of the state information of an aggregator. The volatile state
    of an aggregator and agents should also be stored, such as local models, agents’
    info connected to the aggregator, cluster models generated by the aggregation
    process, and the current round number.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the state manager, let us move on to initializing the state manager.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the state manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `__init__` constructor, the information related to the FL process is
    configured. The following code is an example of how to construct the state manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The ID of the `self.id` aggregator can be generated randomly using the `generate_id()`
    function from the `util.helpers` library.
  prefs: []
  type: TYPE_NORMAL
- en: '`self.agent_set` is a set of agents connected to the aggregator where the format
    of the set is a collection of dictionary information, related to agents in this
    case.'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.mnames` stores the names of each layer of the ML models to be aggregated
    in a list format.'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.round` is initialized to be `0` so that the round of FL is initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: '`local_model_buffers` is a list of local models collected by agents stored
    in the memory space. `local_model_buffers` accepts the local models sent from
    the agents for each FL round, and once the round is completed by the aggregation
    process, this buffer is cleared and starts accepting the next round’s local models.'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.local_model_num_samples` is a list that stores the number of data samples
    for the models that are collected in the buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.cluster_models` is a collection of global cluster models in the `LimitedDict`
    format, and `self.cluster_model_ids` is a list of IDs of cluster models.'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.initialized` becomes `True` once the initial global model is set and
    is `False` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.agg_threshold` is initialized to be `1.0`, which is overwritten by the
    value specified in the `config_aggregator.json` file.'
  prefs: []
  type: TYPE_NORMAL
- en: After initializing the state manager, let us investigate initializing a global
    model next.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a global model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following `initialize_model_info` function sets up the initial global model
    to be used by the other agents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It fills up the model names (`self.mnames`) extracted from the local models
    (`lmodels`) sent from an initial agent. Together with the model names, `local_model_buffers`
    and `cluster_models` are re-initialized too. After clearing the local model buffers,
    it calls the `initialize_models` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `initialize_models` function initializes the structure of neural
    networks (`numpy.array`) based on the initial base models received as parameters
    of models with a dictionary format (`str` or `np.array`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For each layer of the model, defined here as model names, this function fills
    out the model parameters. Depending on the `weight_keep` flag, the model is initialized
    with zeros or parameters that are received. This way, the initial cluster global
    model is constructed together with the randomized model ID. If an agent sends
    a different ML model than the model architecture defined here, the aggregator
    rejects the acceptance of the model or gives an error message to the agent. Nothing
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have covered initializing the global model. In the following section,
    we will explain the core part of the FL process, which is checking aggregation
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the aggregation criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code, called `ready_for_local_aggregation`, is for checking the
    aggregation criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This `ready_for_local_aggregation` function returns a `bool` value to identify
    whether the aggregator can start the aggregation process. It returns `True` if
    it satisfies the aggregation criteria (such as collecting enough local models
    to aggregate) and `False` otherwise. The aggregation threshold, `agg_threshold`,
    is configured in the `config_aggregator.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: The following section is about buffering the local models that are used for
    the aggregation process.
  prefs: []
  type: TYPE_NORMAL
- en: Buffering the local models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code on `buffer_local_models` stores local models from an agent
    in the local model buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The parameters include the local `models` formatted as a dictionary as well
    as meta-information such as the number of samples.
  prefs: []
  type: TYPE_NORMAL
- en: First, this function checks whether the local model sent from an agent is either
    the initial model or not by checking the participation flag. If it is an initial
    model, it calls the `initialize_model` function, as shown in the preceding code
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, for each layer of the model defined with model names, it stores the
    `numpy` array in the `self.local_model_buffers`. The `key` is the model name and
    `model` mentioned in the preceding code are the actual parameters of the model.
    Optionally, it can accept the number of samples or data sources that the agent
    has used for the retraining process and push it to the `self.` `local_model_num_samples`
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: This function is called when the FL server receives the local models from an
    agent during the `receive_msg_from_agent` routine.
  prefs: []
  type: TYPE_NORMAL
- en: With that, the local model buffer has been explained. Next, we will explain
    how to clear the saved models so that aggregation can continue without having
    to store unnecessary models in the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the saved models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following `clear_saved_models` function clears all cluster models stored
    in this round:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function is called when initializing the FL process at the very beginning
    and the cluster global model is emptied to start a fresh FL round again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function, the `clear_lmodel_buffers` function, clears all the
    buffered local models to prepare for the next FL round:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Clearing the local models in `local_model_buffers` is critical when proceeding
    to the next FL round. Without this process, the models to be aggregated are mixed
    up with the non-relevant models from other rounds, and eventually, the performance
    of the FL is sometimes degraded.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explain the basic framework of adding agents during the FL process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `add_agent` function deals with brief agent registration using system
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This function just adds agent-related information to the `self.agent_set` list.
    The agent information includes the agent name, agent ID, agent IP address, and
    the `socket` number to reach out to the agent. The `socket` number can be used
    when sending the cluster global model to the agent connected to the aggregator
    and when the `push` method is used for communication between an aggregator and
    an agent. This function is only called during the agent registration process and
    returns the agent ID and the `socket` number.
  prefs: []
  type: TYPE_NORMAL
- en: If the agent is already registered, which means there is already an agent with
    the same name in `agent_set`, it returns the agent ID and the `socket` number
    of the existing agent.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this `push` communication method from an aggregator to agents does not
    work under certain security circumstances. It is recommended to use the `polling`
    method that the agents use to constantly check whether the aggregator has an updated
    global model or not.
  prefs: []
  type: TYPE_NORMAL
- en: The agent registration mechanism can be expanded using a database, which will
    give you better management of the distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will touch on incrementing the FL round.
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing the FL round
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `increment_round` function just increments the round number precisely managed
    by the state manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Incrementing rounds is a critical part of the FL process for supporting the
    continuous learning operation. This function is only called after registering
    the initial global model or after each model aggregation process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how the FL works with the state manager, in the following
    section, we will talk about the model aggregation framework.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating local models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `aggregation.py` code handles aggregating local models with a bunch of aggregation
    algorithms. In the code example, we only support **FedAvg**, as discussed in the
    following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the libraries for the aggregator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `aggregation.py` code imports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The imported state manager’s role and functionalities are discussed in the *Maintaining
    models for aggregation with the state manager* section, and the `helpers` and
    `states` libraries are introduced in the *Appendix*, *Exploring Internal Libraries.*
  prefs: []
  type: TYPE_NORMAL
- en: After importing the necessary libraries, let’s define the aggregator class.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and initializing the aggregator class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code for `class Aggregator` defines the core process of the aggregator,
    which provides a set of mathematical functions for computing the aggregated models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `__init__` function just sets up the state manager of the aggregator
    to access the model buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once the aggregator class is defined and initialized, let’s look at the actual
    FedAvg algorithm implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the aggregate_local_models function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following `aggregate_local_models` function is the code for aggregating
    the local models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function can be called after the aggregation criteria are satisfied, such
    as the aggregation threshold defined in the `config_aggregator.json` file. The
    aggregation process uses local ML models buffered in the memory of the state manager.
    Those local ML models are sent from the registered agents. For each layer of the
    models defined by `mname`, the weights of the model are averaged by the `_average_aggregate`
    function as follows to realize FedAvg. After averaging the model parameters of
    all the layers, `cluster_models` is updated, which is sent to all the agents.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the local model buffer is cleared to be ready for the next round of the
    FL process.
  prefs: []
  type: TYPE_NORMAL
- en: The FedAvg function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following function, `_average_aggregate`, called by the preceding `aggregate_local_models`
    function, is the code that realizes the `FedAvg` aggregation method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the `_average_aggregate` function, the computation is simple enough that,
    for each buffer of the given list of ML models, it takes averaged parameters for
    the models. The basics of model aggregation are discussed in [*Chapter 3*](B18369_03.xhtml#_idTextAnchor058),
    *Workings of the Federated Learning System*. It returns the weighted aggregated
    models with `np.array`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered all the essential functionalities of the FL server
    and aggregator, next, we will talk about how to run the FL server itself.
  prefs: []
  type: TYPE_NORMAL
- en: Running the FL server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of running the FL server. In order to run the FL server,
    you will just execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `register`, `receive_msg_from_agnet`, and `model_synthesis_routine` functions
    of the instance of the FL server are for starting the registration process of
    the agents, receiving messages from the agents, and starting the model synthesis
    process to create a global model, which are all started using the `init_fl_server`
    function from the `communication_handler` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered all the core modules of the aggregator with the FL server. They
    can work with the database server, which will be discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing and running the database server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The database server can be hosted either on the same machine as the aggregator
    server or separately from the aggregator server. Whether the database server is
    hosted on the same machine or not, the code introduced here is still applicable
    to both cases. The database-related code is found in the `fl_main/pseudodb` folder
    of the GitHub repository provided alongside this book.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the configuration of the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code is an example of the database-side configuration parameters
    saved as `config_db.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In particular, `db_data_path` is the location of the SQLite database and `db_model_path`
    is the location of the ML model binary files. The `config_db.json` file can be
    found in the `setup` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s define the database server and import the necessary libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the database server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main functionality of the `pseudo_db.py` code is accepting messages that
    contain local and cluster global models.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the libraries for the pseudo database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, the `pseudo_db.py` code imports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It imports the basic general libraries as well as `SQLiteDBHandler` (discussed
    later in the *Defining the database with SQLite* section) and the functions from
    the `lib/util` libraries that are discussed in the *Appendix*, *Exploring Internal
    Libraries*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the PseudoDB class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PseudoDB` class is then defined to create an instance that receives models
    and their data from an aggregator and pushes them to an actual database (SQLite,
    in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us move on to initializing the instance of `PseudoDB`.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing PseudoDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Then, the initialization process, `__init__`, is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The initialization process generates the ID of the instance and sets up various
    parameters such as the database socket (`db_socket`), the database IP address
    (`db_ip`), the path to the database (`data_path`), and the database file (`db_file`),
    all configured from `config_db.json`.
  prefs: []
  type: TYPE_NORMAL
- en: '`dbhandler` stores the instance of `SQLiteDBHandler` and calls the `initialize_DB`
    function to create an SQLite database.'
  prefs: []
  type: TYPE_NORMAL
- en: Folders for `data_path` and `db_model_path` are created if they do not already
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: After the initialization process of `PseudoDB`, we need to design the communication
    module that accepts the messages from the aggregators. We again use WebSocket
    for communicating with an aggregator and start this module as a server to accept
    and respond to messages from an aggregator. In this design, we do not push messages
    from the database server to an aggregator or agents in order to make the FL mechanism
    simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Handling messages from the aggregator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code for the `async def handler` function, which takes `websocket`
    as a parameter, receives messages from the aggregator and returns the requested
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the `handler` function, once it decodes the received message from an aggregator,
    the `handler` function checks whether the message type is `push` or not. If so,
    it tries to push the local or cluster models to the database by calling the _`push_all_data_to_db`
    function. Otherwise, it will show an error message. The confirmation message about
    pushing the models to the database can then be sent back to the aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we only defined the type of the `push` message, but you can define as
    many types as possible, together with the enhancement of the database schema and
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing all the data to the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code for `_push_all_data_to_db` pushes the models’ information
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The models’ information is extracted by the `_parse_message` function and passed
    to the `_insert_an_entry` function. Then, the actual models are saved in the local
    server filesystems, where the filename of the models and the path are defined
    by `db_model_path` and `fname` here.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing the message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `_parse_message` function just extracts the parameters from the received
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This function parses the received message into parameters related to agent ID
    or aggregator ID (`component_id`), round number (`r`), message type (`mt`), `model_id`,
    time of generation of the models (`gene_time`), and performance data as a dictionary
    format (`meta_data`). The local performance data, `local_prfmc`, is extracted
    when the model type is local. The amount of sample data used at the local device
    is also extracted from `meta_dect`. All these extracted parameters are returned
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explain the database implementation using
    the SQLite framework.
  prefs: []
  type: TYPE_NORMAL
- en: efining the database with SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sqlite_db.py` code creates the SQLite database and deals with storing and
    retrieving data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Importing libraries for the SQLite database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`sqlite_db.py` imports the basic general libraries and `ModelType` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ModelType` from `lib/util` defines the type of the models: local models
    and (global) cluster models.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining and initializing the SQLiteDBHandler class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Then, the following code related to the `SQLiteDBHandler` class creates and
    initializes the SQLite database and inserts models into the SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization is very simple – just setting the `db_file` parameter passed
    from the `PseudoDB` instance to `self.db_file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Initializing the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following `initialize_DB` function, the database tables are defined
    with local and cluster models using SQLite (`sqlite3`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The tables are simplified in this example so that you can easily follow the
    uploaded local models and their performance as well as the global models created
    by an aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: The `local_models` table has a model ID (`model_id`), the time the model is
    generated (`generation_time`), an agent ID uploaded of the local model (`agent_id`),
    round information (`round`), the performance data of the local model (`performance`),
    and the number of samples used for FedAvg aggregation (`num_samples`).
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster_models` has a model ID (`model_id`), the time the model is generated
    (`generation_time`), an aggregator ID (`aggregator_id`), round information (`round`),
    and the number of samples (`num_samples`).'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an entry into the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code for `insert_an_entry` inserts the data received as parameters
    using `sqlite3` libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the parameters of `component_id` (agent ID or aggregator
    ID), round number (`r`), message type (`mt`), model ID (`model_id`), the time
    the model is generated (`gtime`), the local model’s performance data (`local_prfmc`),
    and the number of samples (`num_samples`) to insert an entry with the `execute`
    function of the SQLite library.
  prefs: []
  type: TYPE_NORMAL
- en: If the model type is *local*, the information of the models is inserted into
    the `local_models` table. If the model type is *cluster*, the information of the
    models is inserted into the `cluster_models` table.
  prefs: []
  type: TYPE_NORMAL
- en: Other functions, such as updating and deleting data from the database, are not
    implemented in this example code and it’s up to you to write those additional
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will explain how to run the database server.
  prefs: []
  type: TYPE_NORMAL
- en: Running the database server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the code for running the database server with the SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The instance of `PseudoDB` class is created as `pdb`. The `pdb.handler`, the
    database’s IP address (`pdb.db_ip`), and the database socket (`pdb.db_socket`)
    are used to start the process of receiving local and cluster models from an aggregator
    enabled by `init_db_server` from the `communication_handler` library in the `util/lib`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we understand how to implement and run the database server. The database
    tables and schema discussed here are minimally designed so that we can understand
    the fundamentals of the FL server’s procedure. In the following section, we will
    discuss potential enhancements to the FL server.
  prefs: []
  type: TYPE_NORMAL
- en: Potential enhancements to the FL server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some of the key potential enhancements to the FL server discussed in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Redesigning the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The database was intentionally designed with minimal table information in this
    book and needs to be extended, such as by having tables of the aggregator itself,
    agents, the initial base model, and the project info, among other things, in the
    database. For example, the FL system described here in this chapter does not support
    the termination and restart of the server and agent processes. Thus, the FL server
    implementation is not complete, as it loses most of the information when any of
    the systems is stopped or failed.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the registry of an initial model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to simplify the explanation of the process of registering the initial
    model, we defined the layers of the ML models using model names. This registration
    of the model in the system can be automated so that just loading a certain ML
    model, such as PyTorch or Keras models, with file extensions such as `.pt/.pth`
    and `.h5`, will be enough for the users of the FL systems to start the process.
  prefs: []
  type: TYPE_NORMAL
- en: Performance metrics for local and global models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, to simplify the explanation of the FL server and the database-side functionalities,
    an accuracy value is just used as one of the performance criteria of the models.
    Usually, ML applications have many more metrics to keep track of as performance
    data and they needs to be enhanced together with the database and communications
    protocol design.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuned aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to simplify the process of aggregating the local models, we just used
    FedAvg, a weighted averaging method. The number of samples can dynamically change
    depending on the local environment, and that aspect is enhanced by you. There
    are also a variety of model aggregation methods, which will be explained in [*Chapter
    7*](B18369_07.xhtml#_idTextAnchor176), *Model Aggregation*, of this book so that
    you can accommodate the best aggregation method depending on the ML applications
    to be created and integrated into the FL system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the basics and principles of FL server-side implementation
    were explained with actual code examples. Having followed the contents of this
    chapter, you should now be able to construct the FL server-side functionalities
    with model aggregation mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The server-side components that were introduced here involve basic communications
    and the registration of the agents and initial models, managing state information
    used for the aggregation, and the aggregation mechanisms for creating the global
    cluster models. In addition, we discussed the implementation of the database to
    just store the information of the ML models. The code was simplified so that you
    were able to understand the principles of server-side functionalities. Further
    enhancements to many other aspects of constructing a more sustainable, resilient,
    and scalable FL system are up to you.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the principle of implementing the functionalities
    of the FL client and agent. The client side needs to provide some well-designed
    APIs for the ML applications for plugin use. Therefore, the chapter will discuss
    the FL client's core functionalities and libraries as well as the library integration
    into the very simple ML applications to enable the whole FL process.
  prefs: []
  type: TYPE_NORMAL
