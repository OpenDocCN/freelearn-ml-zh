["```py\nconda env create –f mlewp-chapter04.yml \n```", "```py\n    numerical_variable = 10\n    string_variable = 'string goes here' \n    ```", "```py\n    def calculate_statistics(df):\n        return df.describe() \n    ```", "```py\n    calculate_statistics(X_train) \n    ```", "```py\n    new_statistics_calculator = calculate_statistics\n    new_statistics_calculator(X_train) \n    ```", "```py\n    def make_func_result_json(func ,df):\n        return func(df).to_json\n    make_func_result_json(calculate_statistics, X_train) \n    ```", "```py\n    import module\n    module.calculate_statistics(df)\n    module.make_func_result_json(module.calcualate_statistics, df) \n    ```", "```py\n    feature/\n    |-- numerical/\n        |-- analyze.py\n        |-- aggregate.py\n        |-- transform.py\n    |-- categorical/\n       |-- analyze.py\n       |-- aggregate.py\n       |-- transform.py \n    ```", "```py\n    import feature.categorical.analyze\n    import feature.numerical.transform \n    ```", "```py\n    def filter_data(data, condition):\n        for x in data:\n            if condition(x):\n                yield x \n    ```", "```py\n    for x in filter_data(data_vals, lambda x: x > 50):\n        print(x) \n    ```", "```py\n    gen1 = (x**2 for x in range(10))\n    for i in gen1:\n        print(i) \n    ```", "```py\n    data_vals = [x for x in range(100)] \n    ```", "```py\n    class Address(object):\n        def __init__(self, *address):\n            if not address:\n                self.address = None\n                print('No address given')\n            else:\n              self.address = ' '.join(str(x) for x in address) \n    ```", "```py\n    address1 = Address('62', 'Lochview', 'Crescent')\n    address2 = Address('The Palm', '1283', 'Royston', 'Road') \n    ```", "```py\n    class ModelHyperparameters(object):\n        def __init__(self, **hyperparams):\n            if not hyperparams:\n                self.hyperparams = None\n            else:\n                self.hyperparams = hyperparams \n    ```", "```py\n    hyp1 = ModelHyperparameters(eps=3, distance='euclidean')\n    hyp2 = ModelHyperparameters(n_clusters=4, max_iter=100) \n    ```", "```py\n    def Makemydata():\n        # steps go here …\n        return result \n    ```", "```py\n    def transform_features()\n        # steps go here …\n        return result \n    ```", "```py\nfrom pyspark.ml.feature import StringIndexer\nstringIndexer = StringIndexer(inputCol=categoricalCol,\n                              outputCol=categoricalCol) \n```", "```py\nclass OutlierDetector(object):\n    def __init__(self, model=None):\n        if model is not None:\n            self.model = model\n        self.pipeline = make_pipeline(StandardScaler(), self.model)\n    def detect(self, data):\n        return self.pipeline.fit(data).predict(data) \n```", "```py\nmodel = IsolationForest(contamination=outliers_fraction,\n                        random_state=42)\ndetector = OutlierDetector(model=model)\nresult = detector.detect(data) \n```", "```py\n is defined with the class keyword and that the PEP-8 convention is to use upper CamelCase for the class name. It is also good practice to make your class names clear definitions of *things that do stuff*. For example, OutlierDetector, ModelWrapper, and DataTransformer are good class names, but Outliers and Calculation are not. You will also notice that we have something in brackets after the name of the class. This tells the class which objects to inherit functionality from. In the preceding example, we can see that this class inherits from something called object. This is actually the built-in base class in Python from which *all other objects inherit*. Therefore, since the class we defined does not inherit from anything more complex than object, you can think of this as essentially saying *the class we are about to build will have all of the functionality it needs defined within it; we do not need to use more complex functionality already defined in other objects for this class*. The syntax showing the inheritance from object is actually superfluous as you can just omit the brackets and write OutlierDetector, but it can be good practice to make the inheritance explicit.\n```", "```py\ndf['data_squared'] = df['data'].apply(lambda x: x**2) \n```", "```py\ndata = [\n    ['The', 'Business', 'Centre', '15', 'Stevenson', 'Lane'],\n    ['6', 'Mossvale', 'Road'],\n    ['Studio', '7', 'Tottenham', 'Court', 'Road']\n    ] \n```", "```py\ndef len_strings_in_list(data_list):\n    return list(map(lambda x: len(x), data_list)) \n```", "```py\ndef list_of_list_func_results(list_func, list_of_lists):\n    return list(map(lambda x: list_func(x), list_of_lists)) \n```", "```py\nlist_of_list_func_results(len_strings_in_list, data) \n```", "```py\n[[3, 8, 6, 2, 9, 4], [1, 8, 4], [6, 1, 9, 5, 4]] \n```", "```py\ndata = data.withColumn('label', f.when((f.col(\"y\") == \"yes\"),\n                        1).otherwise(0)) \n```", "```py\nscaler = StandardScaler(inputCol='numerical_cols_imputed',\n                        outputCol=\"numerical_cols_imputed_scaled\") \n```", "```py\n    outlier_package/\n    ├── outliers/ \n    ```", "```py\n    outlier_package/\n    ├── outliers/\n               ├── detectors \n    ```", "```py\n    outlier_package/\n    ├── outliers/\n               ├── detectors\n               ├── data \n    ```", "```py\n    outlier_package/\n    ├── outliers/\n               ├── detectors\n               ├── data\n               ├── configs\n               ├── utils \n    ```", "```py\n    from sklearn.preprocessing import StandardScaler\n    from sklearn.pipeline import make_pipeline\n\n    class OutlierDetector(object):\n        def __init__(self, model=None):\n            if model is not None:\n                self.model = model\n            self.pipeline = make_pipeline(StandardScaler(), self.model)\n        def detect(self, data):\n            return self.pipeline.fit(data).predict(data) \n    ```", "```py\n    import json\n    from sklearn.ensemble import IsolationForest\n\n    class DetectionModels(object):\n        def __init__(self, model_config_path=None):\n    ....\n        def create_model(self, model_name=None, params=None):\n    ....\n        def get_models(self):\n    .... \n    ```", "```py\n    class DetectionModels(object):\n        def __init__(self, model_config_path=None):\n            if model_config_path is not None:\n                with open(model_config_path) as w:\n                    self.model_def = json.load(w) \n    ```", "```py\n     def create_model(self, model_name=None, params=None):\n            if model_name is None and params is None:\n                return None\n            if model_name == 'IsolationForest' and params is not None:\n                return IsolationForest(**params) \n    ```", "```py\n     def get_models(self):\n            models = []\n            for model_definition in self.model_def:\n                defined_model = self.create_model(\n                    model_name=model_definition['model'],\n                    params=model_definition['params']\n                )\n                models.append(defined_model)\n            return models \n    ```", "```py\n    from utils.data import create_data\n    from detectors.detection_models import DetectionModels\n    import detectors.pipelines\n    from definitions import MODEL_CONFIG_PATH\n\n    if __name__ == \"__main__\":\n        data = create_data()\n        models = DetectionModels(MODEL_CONFIG_PATH).get_models()\n        for model in models:\n            detector = detectors.pipelines.OutlierDetector(model=model)\n            result = detector.detect(data)\n            print(result) \n    ```", "```py\n    [\n      {\n        \"model\": \"IsolationForest\",\n        \"params\": {\n          \"contamination\": 0.15,\n          \"random_state\": 42\n        }\n      }\n    ] \n    ```", "```py\n    import os\n\n    ROOT_DIR = os.path.dirname(__file__)\n    MODEL_CONFIG_PATH = os.path.join(ROOT_DIR, \"configs/model_config.\n                                     json\") \n    ```", "```py\n    python __main__.py \n    ```", "```py\n    python -m outliers \n    ```", "```py\nfrom setuptools import setup\n\nsetup(name='outliers',\n      version='0.1',\n      description='A simple package to wrap some outlier detection\n                   functionality',\n      author='Andrew McMahon',\n      license='MIT',\n      packages=['outliers'],\n      zip_safe=False) \n```", "```py\n    pip install . \n    ```", "```py\n    python setup.py sdist \n    ```", "```py\n    python setup.py bdist_wheel \n    ```", "```py\n    python setup.py sdist bdist_wheel\n    twine upload dist/* \n    ```", "```py\nMODULE := outliers\nrun:\n    @python -m $(MODULE)\ntest:\n    @pytest\n.PHONY: clean test\nclean:\n    rm -rf .pytest_cache .coverage .pytest_cache coverage.xml \n```", "```py\nmake test\nmake run \n```", "```py\nMODULE := outliers\nPROJECT_NAME := mlewp-ed2-ch4-outliers\nPYTHON_INTERPRETER := python3\nARCH := $(shell $(PYTHON_INTERPRETER) -c \"import platform;\nprint(platform.platform())\")\nVIRTUALENV := conda\nCONDA_EXE ?= ~/anaconda3/bin/conda\nEASYDATA_LOCKFILE := environment.$(ARCH).lock.yml \n```", "```py\n$(EASYDATA_LOCKFILE): environment.yml\nifeq (conda, $(VIRTUALENV))\n    $(CONDA_EXE) env update -n $(PROJECT_NAME) -f $<\n    $(CONDA_EXE) env export -n $(PROJECT_NAME) -f $@\n    # pip install -e .  # uncomment for conda <= 4.3\nelse\n    $(error Unsupported Environment `$(VIRTUALENV)`. Use conda)\nendif\n.PHONY: create_environment\n# Set up virtual (conda) environment for this project\ncreate_environment: $(EASYDATA_LOCKFILE)\nifeq (conda,$(VIRTUALENV))\n    @rm -f $(EASYDATA_LOCKFILE)\n    @echo\n    @echo \"New conda env created. Activate with:\"\n    @echo \">>> conda activate $(PROJECT_NAME)\"\n    @echo \">>> make update_environment\"\n        ifneq (\"X$(wildcard .post-create-environment.txt)\",\"X\")\n            @cat .post-create-environment.txt\n        endif\nelse\n    $(error Unsupported Environment `$(VIRTUALENV)`. Use conda)\nendif \n```", "```py\n.PHONY: update_environment\n## Install or update Python Dependencies in the virtual (conda) environment\nupdate_environment: environment_enabled $(EASYDATA_LOCKFILE)\n    ifneq (\"X$(wildcard .post-update-environment.txt)\",\"X\")\n        @cat .post-update-environment.txt\n    endif \n```", "```py\nmake update_environment \n```", "```py\n    name: mlewp-ed2-ch4-outliers\n    channels:\n      - conda-forge\n    dependencies:\n      - python=3.10.8\n      - scikit-learn\n      - pandas\n      - numpy\n      - pytest\n      - pytest-cov\n      - pip \n    ```", "```py\n    make create_environment \n    ```", "```py\n    make update_environment \n    ```", "```py\n    name: mlewp-ed2-ch4-outliers\n    channels:\n      - conda-forge\n    dependencies:\n      - python=3.10.8\n      - scikit-learn\n      - pandas\n      - numpy\n      - pytest\n      - pytest-cov\n      - bandit\n      - pip \n    ```", "```py\nmake delete_environment \n```", "```py\npip install poetry \n```", "```py\npoetry new my-ml-package \n```", "```py\n├── README.md\n├── my_ml_package\n│   └── __init__.py\n├── poetry.lock\n├── pyproject.toml\n└── tests\n    └── __init__.py \n```", "```py\npoetry add pytest \n```", "```py\nsource /path/to/venv/bin/activate \n```", "```py\npoetry shell \n```", "```py\ndeactivate \n```", "```py\nexit \n```", "```py\npoetry install \n```", "```py\npoetry run python main.py \n```", "```py\npoetry build \n```", "```py\npoetry publish –r private-repository-location \n```", "```py\n    import numpy\n    import pytest\n    import outliers.utils.data \n    ```", "```py\n    @pytest.fixture()\n    def dummy_data():\n        data = outliers.utils.data.create_data()\n        return data \n    ```", "```py\n    def test_data_is_numpy(dummy_data):\n        assert isinstance(dummy_data, numpy.ndarray)\n    def test_data_is_large(dummy_data):\n        assert len(dummy_data)>100 \n    ```", "```py\n    $ pytest \n    ```", "```py\n    import pytest\n    from outliers.detectors.detection_models import DetectionModels\n    from outliers.detectors.pipelines import OutlierDetector\n    from outliers.definitions import MODEL_CONFIG_PATH\n    import outliers.utils.data\n    import numpy as np \n    ```", "```py\n    @pytest.fixture()\n    def example_models():\n        models = DetectionModels(MODEL_CONFIG_PATH)\n        return models \n    ```", "```py\n    @pytest.fixture()\n    def example_detector(example_models):\n        model = example_models.get_models()[0]\n        detector = OutlierDetector(model=model)\n        return detector \n    ```", "```py\n    def test_model_creation(example_models):\n        assert example_models is not None \n    ```", "```py\n    def test_model_get_models(example_models):\n        example_models.get_models() is not None \n    ```", "```py\n    def test_model_evaluation(dummy_data, example_detector):\n        result = example_detector.detect(dummy_data)\n        assert len(result[result == -1]) == 39 #number of anomalies to detect\n        assert len(result) == len(dummy_data) #same numbers of results\n        assert np.unique(result)[0] == -1\n        assert np.unique(result)[1] == 1 \n    ```", "```py\n    pytest –-verbose \n    ```", "```py\nmake update_environment \n```", "```py\nbandit -r outliers \n```", "```py\nrepos:\n- repo: https://github.com/PyCQA/bandit\n  rev: '' # Update me!\n  hooks:\n  - id: bandit \n```", "```py\n    pip install safety \n    ```", "```py\n    safety check \n    ```", "```py\nsafety check \n```", "```py\nimport logging\nlogging.basicConfig(filename='outliers.log',\n                    level=logging.DEBUG,\n                    format='%(asctime)s | %(name)s | %(levelname)s |\n                            %(message)s') \n```", "```py\nlogging.debug('Message to help debug ...')\nlogging.info('General info about a process that is running ...')\nlogging.warning('Warn, but no need to error ...')\nWith the settings shown in the first logging snippet, this will result in the following logging messages being written to outliers.log:\n2021-08-02 19:58:53,501 | root | DEBUG | Message to help debug ...\n2021-08-02 19:58:53,501 | root | INFO | General info about a process that is running ...\n2021-08-02 19:58:53,501 | root | WARNING | Warn, but no need to error ... \n```", "```py\ndef feature_transform(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Transform a dataframe by not doing anything. Just for demo.\n    :param df: a dataframe.\n    :return: df.mean(), the same dataframe with the averages of eachcolumn.\n    \"\"\"\n    return df.mean() \n```", "```py\ntry:\n    df_transformed = feature_transform(df)\n    logging.info(\"df successfully transformed\")\nexcept Exception as err:\n    logging.error(\"Unexpected error\", exc_info=True) \n```", "```py\ndf = pd.DataFrame(data={'col1': [1,2,3,4], 'col2': [5,6,7,8]}) \n```", "```py\nlist_of_nums = [1,2,3,4,5,6,7,8]\ntry:\n    df_transformed = feature_transform(list_of_nums)\n    logging.info(\"df successfully transformed\")\nexcept Exception as err:\n    logging.error(\"Unexpected error\", exc_info=True) \n for the screenshot, shown in *Figure 4.18*.\n```", "```py\ny = 10*x \n```", "```py\nNamError: name 'x' is not defined \n```", "```py\ntry:\n    do_something()\nexcept:\n    do_something_else() \n```", "```py\nBaseException\n+-- SystemExit\n +-- KeyboardInterrupt\n +-- GeneratorExit\n +-- Exception\n      +-- StopIteration\n      +-- StopAsyncIteration\n      +-- ArithmeticError\n      |    +-- FloatingPointError\n      |    +-- OverflowError\n      |    +-- ZeroDivisionError\n      +-- AssertionError\n      +-- AttributeError\n      +-- BufferError\n      +-- EOFError\n…\n      +-- Warning\n           +-- DeprecationWarning\n           +-- PendingDeprecationWarning\n           +-- RuntimeWarning\n           +-- SyntaxWarning\n           +-- UserWarning\n… \n```", "```py\n +-- ArithmeticError\n      |    +-- FloatingPointError\n      |    +-- OverflowError\n      |    +-- ZeroDivisionError \n```", "```py\nn = 4.0\ntry:\n    result = n/0.0\nexcept ZeroDivisionError:\n    print(\"Division by zero not allowed!\")\nn = 4.0\ntry:\n    result = n/0.0\t\nexcept ArithmeticError:\n    print(\"Division by zero not allowed!\") \n```", "```py\n    import logging\n\n    def process_data(data):\n        try:\n            # Do some processing on the data\n            result = process(data)\n        except Exception as e:\n            # Log the exception\n            logging.exception(\"Exception occurred while processing\n                               data\")\n            # Re-raise the exception\n            raise\n        return result \n    ```", "```py\n    def process_data(data):\n        try:\n            # Do some processing on the data\n            result = process(data)\n        except Exception as e:\n            # Add additional context to the exception message\n            message = f\"Exception occurred while processing data:\n                        {data}\"\n            # Create a new exception with the modified message\n            raise Exception(message) from e\n        return result \n    ```", "```py\n    def process_data(data):\n        try:\n            # Do some processing on the data\n            result = process(data)\n        except Exception as e:\n            # Handle the exception\n            handle_exception(e)\n            # Re-raise the exception\n            raise\n        return result \n    ```", "```py\n    def handle_exception(e):\n        # Log the exception\n        logging.exception(\"Exception occurred\")\n        # Check if the exception should be handled at this level\n        if should_handle(e):\n            # Handle the exception\n            ...\n        else:\n            # Allow the exception to propagate up the call stack\n            raise \n    ```", "```py\n    def should_handle(e):\n        # Check the type of the exception\n        if isinstance(e, ArithmeticError):\n            # Handle the exception\n            return True\n        else:\n            # Allow the exception to propagate\n            return False \n    ```", "```py\n    def process_data(data):\n        try:\n            # Do some processing on the data\n            result = process(data)\n        except ValueError as e:\n            # Raise a different exception with the same message\n            raise MyCustomException(str(e))\n        except MyCustomException as e:\n            # Raise a different exception with a modified message\n            message = f\"Exception occurred while processing data:\n                        {data}\"\n            raise MyCustomException(message)\n        return result \n    ```", "```py\ndef process(data_to_be_processed):\n    '''Dummy example that returns original data plus 1'''\n    return data_to_be_processed + 1 \n```", "```py\ndef process_data(data): \n    try: \n        # Do some processing on the data \n        result = process(data) \n    except Exception as e: \n        # Log the exception \n        logging.exception(\"Exception occurred while processing data\") \n        # Raise a new exception from the overall exception\n        new_exception = ValueError(\"Error processing data\") \n        raise new_exception from e\n    return result \n```", "```py\nprocess_data('3') \n```", "```py\nERROR:root:Exception occurred while processing data\n  File \"exception_handling_examples.py\", line 5, in process\n    return data_to_be_processed + 1\nTypeError: can only concatenate str (not \"int\") to str \n```", "```py\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"exception_handling_examples.py\", line 18, in process_data\n    raise new_exception from e\nValueError: Error processing data \n```"]