- en: Chapter 4. Counting the Pixels with Histograms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用直方图计数像素
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Computing the image histogram
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算图像直方图
- en: Applying look-up tables to modify the image appearance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用查找表以修改图像外观
- en: Equalizing the image histogram
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: Backprojecting a histogram to detect the specific image content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将直方图反投影以检测特定图像内容
- en: Using the mean shift algorithm to find an object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用均值漂移算法寻找对象
- en: Retrieving similar images using the histogram comparison
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直方图比较检索相似图像
- en: Counting pixels with integral images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用积分图像计数像素
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: An image is composed of pixels of different values (colors). The distribution
    of pixel values across an image constitutes an important characteristic of that
    image. This chapter introduces the concept of image histograms. You will learn
    how to compute a histogram and how to use it to modify an image's appearance.
    Histograms can also be used to characterize an image's content and detect specific
    objects or textures in an image. Some of these techniques will be presented in
    this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由不同值的像素（颜色）组成。像素值在图像中的分布构成了该图像的一个重要特征。本章介绍了图像直方图的概念。你将学习如何计算直方图以及如何使用它来修改图像的外观。直方图还可以用来表征图像的内容，并在图像中检测特定的对象或纹理。本章将介绍一些这些技术。
- en: Computing the image histogram
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算图像直方图
- en: An image is made of pixels, and each of them have different values. For example,
    in a 1-channel gray-level image, each pixel has a value between 0 (black) and
    255 (white). Depending on the picture content, you will find different amounts
    of each gray shade laid out inside the image.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由像素组成，每个像素都有不同的值。例如，在单通道灰度图像中，每个像素的值介于0（黑色）和255（白色）之间。根据图片内容的不同，你会在图像内部找到不同数量的每种灰度色调。
- en: A **histogram** is a simple table that gives you the number of pixels that have
    a given value in an image (or sometimes, a set of images). The histogram of a
    gray-level image will, therefore, have 256 entries (or **bins**). Bin 0 gives
    you the number of pixels that have the value 0, bin 1 gives you the number of
    pixels that have the value 1, and so on. Obviously, if you sum all of the entries
    of a histogram, you should get the total number of pixels. Histograms can also
    be normalized such that the sum of the bins equals 1\. In this case, each bin
    gives you the percentage of pixels that have this specific value in the image.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**直方图**是一个简单的表格，它显示了图像（有时是图像集）中具有给定值的像素数量。因此，灰度图像的直方图将有256个条目（或称为**桶**）。桶0表示值为0的像素数量，桶1表示值为1的像素数量，以此类推。显然，如果你将直方图的全部条目相加，你应该得到像素的总数。直方图也可以进行归一化，使得桶的总和等于1。在这种情况下，每个桶都会给你图像中具有这个特定值的像素的百分比。'
- en: Getting started
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'The first three recipes of this chapter will use the following image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前三个食谱将使用以下图像：
- en: '![Getting started](img/00029.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![入门](img/00029.jpeg)'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Computing a histogram with OpenCV can be easily done by using the `cv::calcHist`
    function. This is a general function that can compute the histogram of multiple
    channel images of any pixel value type and range. Here, we will make this simpler
    to use by specializing a class for the case of 1-channel gray-level images. For
    other types of images, you can always directly use the `cv::calcHist` function,
    which offers you all the flexibility required. The next section will explain each
    of its parameters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV计算直方图可以通过`cv::calcHist`函数轻松完成。这是一个通用函数，可以计算任何像素值类型和范围的多个通道图像的直方图。在这里，我们将通过为单通道灰度图像的情况专门化一个类来简化其使用。对于其他类型的图像，你可以直接使用`cv::calcHist`函数，它为你提供了所需的所有灵活性。下一节将解释其每个参数。
- en: 'For now, our specialized class looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的专用类看起来如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the defined member variables, computing a gray-level histogram can then
    be accomplished using the following method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义的成员变量，可以通过以下方法计算灰度直方图：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, your program simply needs to open an image, create a `Histogram1D` instance,
    and call the `getHistogram` method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的程序只需要打开一个图像，创建一个`Histogram1D`实例，并调用`getHistogram`方法：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `histo` object here is a simple one-dimensional array with `256` entries.
    Therefore, you can read each bin by simply looping over this array:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`histo`对象是一个具有`256`个条目的简单一维数组。因此，你可以通过简单地遍历这个数组来读取每个桶：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the image shown at the start of this chapter, some of the displayed values
    would read as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章开头显示的图像，一些显示的值如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is obviously difficult to extract any intuitive meaning from this sequence
    of values. For this reason, it is often convenient to display a histogram as a
    function, for example, using bar graphs. The following methods create such a graph:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从这一系列值中提取任何直观意义都很困难。因此，通常方便将直方图显示为函数，例如，使用条形图。以下方法创建此类图表：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the `getImageOfHistogram` method, you can obtain an image of the histogram
    function in the form of a bar graph that is drawn using lines:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getImageOfHistogram`方法，你可以获得直方图函数的图像，以条形图的形式绘制，使用线条：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is the following image:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是以下图像：
- en: '![How to do it...](img/00030.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00030.jpeg)'
- en: 'From the preceding histogram, it can be seen that the image exhibits a large
    peak of mid-gray level values and a good quantity of darker pixels. Coincidentally,
    these two groups mostly correspond to, respectively, the background and foreground
    of the image. This can be verified by thresholding the image at the transition
    between these two groups. A convenient OpenCV function can be used for this, namely
    the `cv::threshold` function that was introduced in the previous chapter. Here,
    to create our binary image, we threshold the image at the minimum value just before
    it increases toward the high peak of the histogram (gray value `60`):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的直方图可以看出，图像显示出中灰度值的大峰值和大量较暗的像素。巧合的是，这两个组主要分别对应图像的背景和前景。可以通过在这两个组之间的过渡处对图像进行阈值处理来验证这一点。可以使用方便的OpenCV函数来完成此操作，即在前一章中介绍的`cv::threshold`函数。在这里，为了创建我们的二值图像，我们在直方图向高峰值增加之前的最小值处对图像进行阈值处理（灰度值`60`）：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The resulting binary image clearly shows you the background/foreground segmentation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的二值图像清楚地显示了背景/前景分割：
- en: '![How to do it...](img/00031.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00031.jpeg)'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `cv::calcHist` function has many parameters to permit its use in many contexts,
    which are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::calcHist`函数有许多参数，允许它在许多上下文中使用，如下所示：'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Most of the time, your histogram will be one of a single 1-channel or 3-channel
    image. However, the function allows you to specify a multiple-channel image distributed
    over several images. This is why an array of images is input into this function.
    The sixth parameter, `dims`, specifies the dimensionality of the histogram, for
    example, 1 for a 1D histogram. Even if you are analyzing a multichannel image,
    you do not have to use all its channels in the computation of the histogram. The
    channels to be considered are listed in the `channel` array that has the specified
    dimensionality. In our class implementation, this single channel is the channel
    0 by default. The histogram itself is described by the number of bins in each
    dimension (this is the `histSize` array of integers) and by the minimum (inclusive)
    and maximum (exclusive) values in each dimension (given by the `ranges` array
    of 2-element arrays). It is also possible to define a non-uniform histogram; in
    which case, you need to specify the limits of each bin.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你的直方图将是一张单通道或三通道图像之一。然而，该函数允许你指定一个分布在多个图像上的多通道图像。这就是为什么将图像数组输入到该函数中的原因。第六个参数`dims`指定直方图的维度，例如，对于一维直方图为1。即使你正在分析多通道图像，你也不必在直方图的计算中使用所有通道。要考虑的通道列在具有指定维度的`channel`数组中。在我们的类实现中，这个单通道默认是通道0。直方图本身由每个维度的bin数量（这是整数的`histSize`数组）以及每个维度的最小（包含）和最大（不包含）值（由2元素数组的`ranges`数组给出）描述。也可以定义一个非均匀直方图；在这种情况下，你需要指定每个bin的界限。
- en: As with many OpenCV functions, a mask can be specified, indicating which pixels
    you want to include in the count (all pixels for which the mask value is 0 are
    then ignored). Two additional optional parameters can be specified, both of which
    are Boolean values. The first one indicates whether the histogram is uniform or
    not (uniform is the default). The second allows you to accumulate the result of
    several histogram computations. If this last parameter is true, then the pixel
    count of the image will be added to the current values found in the input histogram.
    This is useful when you want to compute the histogram of a group of images.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多OpenCV函数一样，可以指定一个掩码，表示您想要包含在计数中的像素（掩码值为0的所有像素将被忽略）。还可以指定两个附加的可选参数，它们都是布尔值。第一个参数指示直方图是否均匀（均匀是默认值）。第二个参数允许您累积多个直方图计算的结果。如果最后一个参数为真，则图像的像素计数将添加到当前输入直方图中的值。这在您想要计算一组图像的直方图时非常有用。
- en: 'The resulting histogram is stored in a `cv::Mat` instance. Indeed, the `cv::Mat`
    class can be used to manipulate general N-dimensional matrices. Recall from [Chapter
    2](part0019_split_000.html#page "Chapter 2. Manipulating Pixels"), *Manipulating
    Pixels*, that this class has defined the `at` method for matrices of dimension
    1, 2, and 3\. This is why we were able to write the following code when accessing
    each bin of the 1D histogram in the `getHistogramImage` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果直方图存储在`cv::Mat`实例中。实际上，`cv::Mat`类可以用来操作通用的N维矩阵。回想一下[第2章](part0019_split_000.html#page
    "第2章. 操作像素")，*操作像素*，这个类为1维、2维和3维矩阵定义了`at`方法。这就是为什么我们能够在`getHistogramImage`方法中访问1D直方图的每个桶时编写以下代码：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the values in the histogram are stored as `float` values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直方图中的值存储为`float`类型。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Histogram1D` class presented in this recipe has simplified the `cv::calcHist`
    function by restricting it to a 1D histogram. This is useful for gray-level images,
    but what about color images?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中介绍的`Histogram1D`类通过将其限制为1D直方图简化了`cv::calcHist`函数。这对于灰度图像很有用，但对于彩色图像呢？
- en: Computing histograms of color images
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算彩色图像的直方图
- en: 'Using the same `cv::calcHist` function, we can compute histograms of multichannel
    images. For example, a class that computes histograms of color BGR images can
    be defined as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的`cv::calcHist`函数，我们可以计算多通道图像的直方图。例如，可以定义一个计算彩色BGR图像直方图的类如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, the histogram will be three-dimensional. Therefore, we need to
    specify a range for each of the three dimensions. In the case of our BGR image,
    the three channels have the same `[0,255]` range. With the arguments thus prepared,
    the color histogram is computed by the following method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，直方图将是三维的。因此，我们需要为三个维度中的每一个指定一个范围。在我们的BGR图像中，三个通道具有相同的`[0,255]`范围。准备好这些参数后，颜色直方图将通过以下方法计算：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A three-dimensional `cv::Mat` instance is returned. When a histogram of `256`
    bins is selected, this matrix has `(256)^3` elements, which represents more than
    16 million entries. In many applications, it would be better to reduce the number
    of bins in the computation of the histogram. It is also possible to use the `cv::SparseMat`
    data structure that is designed to represent large sparse matrices (that is, matrices
    with very few nonzero elements) without consuming too much memory. The `cv::calcHist`
    function has a version that returns one such matrix. It is, therefore, simple
    to modify the previous method in order to use `cv::SparseMatrix`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个三维`cv::Mat`实例。当选择`256`个桶的直方图时，这个矩阵有`(256)^3`个元素，这代表超过1600万个条目。在许多应用中，减少直方图计算中的桶数会更好。还可以使用设计用来表示大型稀疏矩阵（即零元素非常少的矩阵）而不消耗太多内存的`cv::SparseMat`数据结构。`cv::calcHist`函数有一个返回此类矩阵的版本。因此，修改前面的方法以使用`cv::SparseMatrix`非常简单：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Obviously, it is also possible to illustrate the color distribution in an image
    by showing the individual R, G, and B histograms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，也可以通过显示单个R、G和B直方图来展示图像中的颜色分布。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Backprojecting a histogram to detect specific image content* recipe later
    in this chapter makes use of color histograms in order to detect specific image
    content
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章后面提到的**将直方图反投影以检测特定图像内容**的配方使用颜色直方图来检测特定图像内容
- en: Applying look-up tables to modify the image appearance
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将查找表应用于修改图像外观
- en: Image histograms capture the way a scene is rendered using the available pixel
    intensity values. By analyzing the distribution of the pixel values over an image,
    it is possible to use this information to modify and possibly improve an image.
    This recipe explains how we can use a simple mapping function, represented by
    a look-up table, to modify the pixel values of an image. As we will see, look-up
    tables are often defined from histogram distributions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图像直方图捕捉了场景使用可用的像素强度值的方式。通过分析图像上像素值的分布，可以使用这些信息来修改和可能改进图像。这道菜谱解释了我们可以如何使用一个简单的映射函数，即查找表，来修改图像的像素值。正如我们将看到的，查找表通常是从直方图分布中定义的。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A **look-up table** is a simple one-to-one (or many-to-one) function that defines
    how pixel values are transformed into new values. It is a 1D array with, in the
    case of regular gray-level images, 256 entries. Entry `i` of the table gives you
    the new intensity value of the corresponding gray level, which is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找表**是一个简单的单对单（或一对多）函数，它定义了像素值如何转换成新值。它是一个1D数组，在常规灰度图像的情况下，有256个条目。表中的条目`i`给出了相应灰度的新的强度值，如下所示：'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `cv::LUT` function in OpenCV applies a look-up table to an image in order
    to produce a new image. We can add this function to our `Histogram1D` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中的`cv::LUT`函数将查找表应用于图像以生成新图像。我们可以将此函数添加到我们的`Histogram1D`类中：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When a look-up table is applied on an image, it results in a new image where
    the pixel intensity values have been modified as prescribed by the look-up table.
    A simple transformation could be the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当查找表应用于图像时，它会产生一个新的图像，其中像素强度值已根据查找表的规定进行了修改。一个简单的转换可能是以下这样：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This transformation simply inverts the pixel intensities, that is, intensity
    `0` becomes `255`, `1` becomes `254`, and so on. Applying such a look-up table
    on an image will produce the negative of the original image. On the image of the
    previous recipe, the result is seen here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换只是简单地反转像素强度，也就是说，强度`0`变为`255`，`1`变为`254`，依此类推。将此类查找表应用于图像将产生原始图像的负片。在上一道菜谱的图像中，结果如下所示：
- en: '![How it works...](img/00032.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00032.jpeg)'
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Look-up tables are useful for any application in which all pixel intensities
    are given a new intensity value. The transformation, however, has to be global,
    that is, all pixels of each intensity value must undergo the same transformation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 查找表对于任何所有像素强度都被赋予新强度值的应⽤程序都很有用。然而，这种转换必须是全局的，也就是说，每个强度值的所有像素都必须经历相同的转换。
- en: Stretching a histogram to improve the image contrast
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过拉伸直方图来提高图像对比度
- en: It is possible to improve an image's contrast by defining a look-up table that
    modifies the original image's histogram. For example, if you observe the histogram
    of the previous image shown in the first recipe, it is easy to notice that the
    full range of possible intensity values is not used (in particular, for this image,
    the brighter intensity values have not been used). We can, therefore, stretch
    the histogram in order to produce an image with an expanded contrast. To do so,
    the procedure uses a percentile threshold that defines the percentage of pixels
    that should be black and white in the stretched image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个修改原始图像直方图的查找表，可以改善图像的对比度。例如，如果你观察第一道菜谱中显示的上一张图像的直方图，很容易注意到没有使用所有可能的强度值范围（特别是，对于这张图像，较亮的强度值没有被使用）。因此，我们可以拉伸直方图以产生具有扩展对比度的图像。为此，该程序使用一个百分位数阈值来定义拉伸图像中应该为黑色和白色的像素百分比。
- en: 'We must, therefore, find the lowest (`imin`) and the highest (`imax`) intensity
    values such that we have the required minimum number of pixels below or above
    the specified percentile. The intensity values can then be remapped such that
    the `imin` value is repositioned at intensity `0` and the `imax` value is assigned
    the value of `255`. The in-between `i` intensities are simply linearly remapped
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须找到最低的（`imin`）和最高的（`imax`）强度值，这样我们就有所需的最低像素数在指定的百分位数以下或以上。然后可以将强度值重新映射，使`imin`值重新定位到强度`0`，而`imax`值被分配值为`255`。中间的`i`强度值简单地按以下方式进行线性重新映射：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Consequently, the complete image stretch method would look as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完整的图像拉伸方法如下所示：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note the call to our `applyLookUp` method once this method has been computed.
    Also, in practice, it could be advantageous to not only ignore bins with the `0`
    value, but also entries with negligible count, for example, less than a given
    value (defined here as `minValue`). The method is called as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在计算此方法后对`applyLookUp`方法的调用。实际上，在实践中，除了忽略具有`0`值的桶外，还可以忽略计数可忽略的条目，例如，小于给定值（在此定义为`minValue`）。方法的调用方式如下：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The resulting stretched image is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果拉伸的图像如下：
- en: '![Stretching a histogram to improve the image contrast](img/00033.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![拉伸直方图以改善图像对比度](img/00033.jpeg)'
- en: 'The expanded histogram then looks as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展后的直方图看起来如下：
- en: '![Stretching a histogram to improve the image contrast](img/00034.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![拉伸直方图以改善图像对比度](img/00034.jpeg)'
- en: Applying a look-up table on color images
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在彩色图像上应用查找表
- en: 'In [Chapter 2](part0019_split_000.html#page "Chapter 2. Manipulating Pixels"),
    *Manipulating Pixels*, we defined a color-reduction function that modifies the
    BGR values of an image in order to reduce the number of possible colors. We did
    this by looping through the image''s pixels and applying the color-reduction function
    on each of them. In fact, it would be much more efficient to precompute all color
    reductions and then modify each pixel by using a look-up table. This is indeed
    very easy to accomplish from what we learned in this recipe. The new color-reduction
    function would then be written as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#page "第2章. 操作像素")，*操作像素*中，我们定义了一个颜色减少函数，该函数通过修改图像的BGR值来减少可能的颜色数量。我们通过遍历图像的像素并对每个像素应用颜色减少函数来实现这一点。实际上，通过预计算所有颜色减少并使用查找表来修改每个像素将更加高效。这正是我们从本食谱中学到的东西。新的颜色减少函数将如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The color-reduction scheme is correctly applied here because when a one-dimensional
    look-up table is applied to a multichannel image, then the same table is individually
    applied to all channels. When a look-up table has more than one dimension, then
    it must be applied to an image with the same number of channels.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色减少方案在这里被正确应用，因为当一维查找表应用于多通道图像时，该表将单独应用于所有通道。当查找表具有多个维度时，它必须应用于具有相同通道数的图像。
- en: See also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The next recipe shows you another way to improve the image contrast
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个示例展示了另一种提高图像对比度的方法
- en: Equalizing the image histogram
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平衡图像直方图
- en: In the previous recipe, we showed you how the contrast of an image can be improved
    by stretching a histogram so that it occupies the full range of the available
    intensity values. This strategy indeed constitutes an easy fix that can effectively
    improve an image. However, in many cases, the visual deficiency of an image is
    not that it uses a too-narrow range of intensities. Rather, it is that some intensity
    values are used more frequently than others. The histogram shown in the first
    recipe of this chapter is a good example of this phenomenon. The middle-gray intensities
    are indeed heavily represented, while darker and brighter pixel values are rather
    rare. In fact, you would think that a good-quality image should make equal use
    of all available pixel intensities. This is the idea behind the concept of **histogram
    equalization**, that is, making the image histogram as flat as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们向您展示了如何通过拉伸直方图使它占据所有可用强度值的全范围来提高图像的对比度。这种策略确实是一个简单的解决方案，可以有效地改善图像。然而，在许多情况下，图像的视觉缺陷并不是它使用了太窄的强度范围。相反，它是一些强度值比其他强度值使用得更频繁。本章的第一个示例中显示的直方图就是这种现象的一个好例子。中间灰度强度确实被大量表示，而较暗和较亮的像素值则相对罕见。实际上，你会认为一个好的图像应该平等地使用所有可用的像素强度。这就是**直方图均衡化**概念背后的想法，即尽可能使图像直方图平坦。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'OpenCV offers an easy-to-use function that performs histogram equalization.
    It is called as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个易于使用的函数，用于执行直方图均衡化。它的调用方式如下：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After applying it on our image, the following screenshot is the result:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图像上应用它后，以下截图是结果：
- en: '![How to do it...](img/00035.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00035.jpeg)'
- en: 'This equalized image has the following histogram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此均衡化图像具有以下直方图：
- en: '![How to do it...](img/00036.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/00036.jpeg)'
- en: Of course, the histogram cannot be perfectly flat because the look-up table
    is a global many-to-one transformation. However, it can be seen that the general
    distribution of the histogram is now more uniform than the original one.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，直方图不能完全平坦，因为查找表是一个全局多对一转换。然而，可以看出，直方图的一般分布现在比原始的更均匀。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In a perfectly uniform histogram, all bins would have an equal number of pixels.
    This implies that 50 percent of the pixels should have an intensity lower than
    `128`, 25 percent should have an intensity lower than `64`, and so on. This observation
    can be expressed using the rule that in a uniform histogram, *p%* of the pixels
    must have an intensity value lower than or equal to *255*p%*. The rule used to
    equalize a histogram is that the mapping of intensity `i` should be at the intensity
    that corresponds to the percentage of pixels that have an intensity value below
    `i`. Therefore, the required look-up table can be built from the following equation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完全均匀的直方图中，所有桶都将具有相同数量的像素。这意味着50%的像素强度应低于`128`，25%应低于`64`，依此类推。这个观察结果可以用以下规则表示：在一个均匀的直方图中，*p%*的像素必须具有低于或等于*255*p%*的强度值。用于均衡直方图的规则是，强度`i`的映射应与具有低于`i`的强度值的像素百分比的强度相对应。因此，所需的查找表可以从以下方程式构建：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `p[i]` is the number of pixels that have an intensity lower than or equal
    to `i`. The `p[i]` function is often referred to as a **cumulative histogram**,
    that is, it is a histogram that contains the count of pixels lower than or equal
    to a given intensity instead of containing the count of pixels that have a specific
    intensity value. Recall that `image.total()` returns the number of pixels in an
    image, so `p[i]/image.total()` is a percentage of pixels.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`p[i]`是强度低于或等于`i`的像素数量。`p[i]`函数通常被称为**累积直方图**，即它是一个包含低于或等于给定强度的像素计数的直方图，而不是包含具有特定强度值的像素计数。回想一下，`image.total()`返回图像中的像素数量，所以`p[i]/image.total()`是像素的百分比。
- en: Generally, the histogram equalization greatly improves the image's appearance.
    However, depending on the visual content, the quality of the result can vary from
    image to image.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，直方图均衡化大大改善了图像的外观。然而，根据视觉内容的不同，结果的质量可能因图像而异。
- en: Backprojecting a histogram to detect specific image content
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将直方图反投影以检测特定图像内容
- en: A histogram is an important characteristic of an image's content. If you look
    at an image area that shows a particular texture or a particular object, then
    the histogram of this area can be seen as a function that gives the probability
    that a given pixel belongs to this specific texture or object. In this recipe,
    you will learn how the concept of **histogram backprojection** can be advantageously
    used to detect specific image content.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是图像内容的一个重要特征。如果你观察一个显示特定纹理或特定对象的图像区域，那么这个区域的直方图可以看作是一个函数，它给出了给定像素属于这个特定纹理或对象的概率。在本食谱中，你将学习如何有利地使用**直方图反投影**的概念来检测特定图像内容。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Suppose you have an image and you wish to detect specific content inside it
    (for example, in the following image, the clouds in the sky). The first thing
    to do is to select a region of interest that contains a sample of what you are
    looking for. This region is the one inside the rectangle drawn on the following
    test image:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个图像，并且你希望检测其中的特定内容（例如，在以下图像中，天空中的云）。首先要做的事情是选择一个感兴趣的区域，该区域包含你正在寻找的样本。这个区域就是以下测试图像中画出的矩形内部：
- en: '![How to do it...](img/00037.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00037.jpeg)'
- en: 'In our program, the region of interest is obtained as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，感兴趣的区域是通过以下方式获得的：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You then extract the histogram of this ROI. This is easily accomplished using
    the `Histogram1D` class defined in the first recipe of this chapter as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你提取这个ROI的直方图。这可以通过使用本章第一道食谱中定义的`Histogram1D`类轻松完成，如下所示：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By normalizing this histogram, we obtain a function that gives us the probability
    that a pixel of a given intensity value belongs to the defined area as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过归一化这个直方图，我们得到一个函数，它给出了给定强度值的像素属于定义区域的概率，如下所示：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Backprojecting a histogram consists of replacing each pixel value in an input
    image with its corresponding probability value read in the normalized histogram.
    An OpenCV function performs this task as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回投影直方图包括将输入图像中的每个像素值替换为其在归一化直方图中读取的对应概率值。OpenCV函数如下执行此任务：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result is the following probability map, with probabilities belonging to
    the reference area ranging from bright (low probability) to dark (high probability):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是以下概率图，参考区域的概率从亮（低概率）到暗（高概率）：
- en: '![How to do it...](img/00038.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00038.jpeg)'
- en: 'If we apply a threshold on this image, we obtain the most probable "cloud"
    pixels:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这张图像应用阈值，我们将获得最可能的“云”像素：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下截图所示：
- en: '![How to do it...](img/00039.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00039.jpeg)'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding result is disappointing because, in addition to the clouds, other
    areas have been wrongly detected as well. It is important to understand that the
    probability function has been extracted from a simple gray-level histogram. Many
    other pixels in the image share the same intensities as the cloud pixels, and
    pixels of the same intensity are replaced with the same probability value when
    backprojecting the histogram. One solution to improve the detection result would
    be to use the color information. However, in order to do this, we need to modify
    the call to `cv::calBackProject`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果令人失望，因为除了云层之外，其他区域也被错误地检测到了。重要的是要理解，概率函数是从简单的灰度直方图中提取出来的。图像中许多其他像素与云层像素具有相同的强度，并且在回投影直方图时，相同强度的像素被相同的概率值替换。为了提高检测结果，一个解决方案是使用颜色信息。然而，为了做到这一点，我们需要修改对`cv::calBackProject`的调用。
- en: The `cv::calBackProject` function is similar to the `cv::calcHist` function.
    The first parameter specifies the input image. You then need to list the channel
    numbers you wish to use. The histogram that is passed to the function is, this
    time, an input parameter; its dimension should match the one of the channel list
    array. As with `cv::calcHist`, the `ranges` parameter specifies the bin boundaries
    of the input histogram in the form of an array of float arrays, each specifying
    the range (minimum and maximum values) of each channel. The resulting output is
    an image, which is the computed probability map. Since each pixel is replaced
    by the value found in the histogram at the corresponding bin position, the resulting
    image has values between `0.0` and `1.0` (assuming a normalized histogram has
    been provided as input). A last parameter allows you to optionally rescale these
    values by multiplying them by a given factor.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::calBackProject`函数类似于`cv::calcHist`函数。第一个参数指定输入图像。然后你需要列出你希望使用的通道号。这次传递给函数的直方图是一个输入参数；其维度应与通道列表数组相匹配。与`cv::calcHist`一样，`ranges`参数指定输入直方图的bin边界，形式为一个float数组的数组，每个数组指定每个通道的范围（最小值和最大值）。生成的输出是一个图像，即计算出的概率图。由于每个像素都被替换为在对应bin位置上直方图中找到的值，因此生成的图像的值在`0.0`和`1.0`之间（假设已提供归一化直方图作为输入）。最后一个参数允许你选择性地通过乘以一个给定的因子来重新缩放这些值。'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's now see how we can use the color information in the histogram backprojection
    algorithm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何在直方图回投影算法中使用颜色信息。
- en: Backprojecting color histograms
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回投影颜色直方图
- en: 'Multidimensional histograms can also be backprojected onto an image. Let''s
    define a class that encapsulates the backprojection process. We first define the
    required attributes and initialize the data as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 多维直方图也可以回投影到图像上。让我们定义一个类来封装回投影过程。我们首先定义所需的属性并初始化数据如下：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we define a threshold parameter that will be used to create the binary
    map that shows the detection result. If this parameter is set to a negative value,
    the raw probability map will be returned. Refer to the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个阈值参数，该参数将用于创建显示检测结果的二值图。如果此参数设置为负值，则将返回原始概率图。请参考以下代码：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The input histogram is normalized (this is, however, not required) as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输入直方图已归一化（尽管这不是必需的），如下所示：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To backproject the histogram, you simply need to specify the image, the range
    (we assumed here that all channels have the same range), and the list of channels
    used. Refer to the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要回投影直方图，你只需指定图像、范围（我们假设所有通道具有相同的范围）以及使用的通道列表。请参考以下代码：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s now use a BGR histogram on the color version of the image we used previously
    (see the book''s website to see this image in color). This time, we will try to
    detect the blue sky area. We will first load the color image, define the region
    of interest, and compute the 3D histogram on a reduced color space as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在之前使用的图像的颜色版本上使用BGR直方图（查看书网站以查看此图像的颜色版本）。这次，我们将尝试检测蓝色天空区域。我们将首先加载彩色图像，定义感兴趣区域，并在减少的颜色空间上计算3D直方图，如下所示：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, you compute the histogram and use the `find` method to detect the sky
    portion of the image as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你计算直方图并使用 `find` 方法检测图像的天空部分，如下所示：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of the detection on the color version of the image in the previous
    section is seen here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个部分中图像颜色版本检测的结果如下：
- en: '![Backprojecting color histograms](img/00040.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![反向投影颜色直方图](img/00040.jpeg)'
- en: The BGR color space is generally not the best one to identify color objects
    in an image. Here, to make it more reliable, we reduced the number of colors before
    computing the histogram (remember that the original BGR space counts more than
    16 million colors). The histogram extracted represents the typical color distribution
    for a sky area. Try to backproject it on another image. It should also detect
    the sky portion. Note that using a histogram built from multiple sky images should
    increase the accuracy of this detection.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: BGR颜色空间通常不是在图像中识别颜色物体的最佳选择。在这里，为了使其更可靠，我们在计算直方图之前减少了颜色的数量（记住，原始的BGR空间包含超过1600万种颜色）。提取的直方图代表了天空区域的典型颜色分布。尝试将其反向投影到另一张图像上。它也应该检测到天空部分。请注意，使用由多个天空图像构建的直方图可以提高这种检测的准确性。
- en: Note that in this case, computing a sparse histogram would have been better
    in terms of memory usage. You should be able to redo this exercise using `cv::SparseMat`
    this time. Also, if you are looking for a bright-colored object, using the hue
    channel of the HSV color space would probably be more efficient. In other cases,
    the use of the chromaticity components of a perceptually uniform space (such as
    *L*a*b**) might constitute a better choice.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，从内存使用角度来看，计算稀疏直方图会更好。这次你应该能够使用 `cv::SparseMat` 重新做这个练习。此外，如果你正在寻找颜色鲜艳的物体，使用HSV颜色空间的色调通道可能会更有效率。在其他情况下，使用感知均匀空间（如
    *L*a*b**）的色度分量可能是一个更好的选择。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe uses the HSV color space to detect an object in an image. This
    is one of the many alternative solutions you can use in the detection of some
    image content.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个示例使用HSV颜色空间来检测图像中的物体。这是你可以在检测某些图像内容时使用的许多替代方案之一。
- en: Using the mean shift algorithm to find an object
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用均值漂移算法寻找物体
- en: The result of a histogram backprojection is a probability map that expresses
    the probability that a given piece of image content is found at a specific image
    location. Suppose we now know the approximate location of an object in an image;
    the probability map can be used to find the exact location of the object. The
    most probable location will be the one that maximizes this probability inside
    a given window. Therefore, if we start from an initial location and iteratively
    move around, it should be possible to find the exact object location. This is
    what is accomplished by the **mean shift algorithm**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图反向投影的结果是一个概率图，表示给定图像内容在特定图像位置被找到的概率。假设我们现在知道图像中物体的近似位置；概率图可以用来找到物体的确切位置。最可能的位置将是最大化给定窗口内该概率的位置。因此，如果我们从一个初始位置开始，迭代地移动，应该能够找到物体的确切位置。这就是**均值漂移算法**所实现的功能。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Suppose we have identified an object of interest—here, a baboon''s face—as
    shown in the following screenshot (refer to the book''s graphics PDF to view this
    image in color):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经识别出感兴趣的对象——这里是一个狒狒的脸，如下面的截图所示（参考书中图形PDF查看此图像的颜色版本）：
- en: '![How to do it...](img/00041.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00041.jpeg)'
- en: 'This time, we will describe this object by using the hue channel of the HSV
    color space. This means that we need to convert the image into an HSV one and
    then extract the hue channel and compute the 1D hue histogram of the defined ROI.
    Refer to the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用HSV颜色空间的色调通道来描述这个物体。这意味着我们需要将图像转换为HSV图像，然后提取色调通道并计算定义的ROI的1D色调直方图。参考以下代码：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As can be seen, the hue histogram is obtained using a convenient method that
    we have added to our `ColorHistogram` class as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，色调直方图是通过我们添加到`ColorHistogram`类的一个方便方法获得的，如下所示：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The resulting histogram is then passed to our `ContentFinder` class instance
    as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将生成的直方图传递给我们的`ContentFinder`类实例，如下所示：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s now open a second image where we want to locate the new baboon''s face
    position. This image needs to be converted to the HSV space first, and then we
    backproject the histogram of the first image. Refer to the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开第二张图片，这张图片是我们想要定位新狒狒面部位置的图片。这张图片首先需要转换到HSV空间，然后我们将第一张图片的直方图进行反向投影。参考以下代码：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, from an initial rectangular area (that is, the position of the baboon''s
    face in the initial image), the `cv::meanShift` algorithm of OpenCV will update
    the `rect` object at the new baboon''s face location. Refer to the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从一个初始矩形区域（即初始图像中狒狒面部的位置），OpenCV的`cv::meanShift`算法将更新`rect`对象到新狒狒面部的位置。参考以下代码：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The initial (red) and new (green) face locations are displayed in the following
    screenshot (refer to the book''s graphics PDF to view this image in color):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 初始（红色）和新（绿色）的面部位置在以下屏幕截图（参考书籍的图形PDF以查看此图像的颜色）中显示：
- en: '![How to do it...](img/00042.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/00042.jpeg)'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we used the hue component of the HSV color space in order to
    characterize the object we were looking for. We made this choice because the baboon's
    face has a very distinctive pink color; consequently, the pixels' hue should make
    the face easily identifiable. The first step, therefore, is to convert the image
    to the HSV color space. The hue component is the first channel of the resulting
    image when the `CV_BGR2HSV` flag is used. This is an 8-bit component that varies
    from `0` to `180` (with `cv::cvtColor`, the converted image is of the same type
    as the source image). In order to extract the hue image, the 3-channel HSV image
    is split into three 1-channel images using the `cv::split` function. The three
    images are put into a `std::vector` instance, and the hue image is the first entry
    of the vector (that is, at index `0`).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了HSV颜色空间的色调分量来描述我们正在寻找的对象。我们做出这个选择是因为狒狒的面部有一种非常独特的粉红色；因此，像素的色调应该使面部易于识别。因此，第一步是将图像转换为HSV颜色空间。当使用`CV_BGR2HSV`标志时，色调分量是结果图像的第一个通道。这是一个从`0`到`180`（使用`cv::cvtColor`转换的图像与源图像类型相同）的8位分量。为了提取色调图像，使用`cv::split`函数将3通道HSV图像分割成三个1通道图像。这三个图像被放入一个`std::vector`实例中，色调图像是向量的第一个条目（即索引`0`）。
- en: When using the hue component of a color, it is always important to take its
    saturation into account (which is the second entry of the vector). Indeed, when
    the saturation of a color is low, the hue information becomes unstable and unreliable.
    This is due to the fact that for low-saturated color, the B, G, and R components
    are almost equal. This makes it difficult to determine the exact color that is
    represented. Consequently, we decided to ignore the hue component of colors with
    low saturation. That is, they are not counted in the histogram (using the `minSat`
    parameter that masks out pixels with saturation below this threshold in the `getHueHistogram`
    method).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用颜色的色调分量时，始终需要考虑其饱和度（这是向量的第二个元素）。实际上，当颜色的饱和度低时，色调信息变得不稳定且不可靠。这是因为对于低饱和度的颜色，B、G和R分量几乎相等。这使得确定确切的颜色变得困难。因此，我们决定忽略低饱和度颜色的色调分量。也就是说，它们不会被计入直方图（使用`minSat`参数，在`getHueHistogram`方法中屏蔽掉饱和度低于此阈值的像素）。
- en: 'The mean shift algorithm is an iterative procedure that locates the local maxima
    of a probability function. It does this by finding the centroid, or weighted mean,
    of the data point inside a predefined window. The algorithm then moves the window
    center to the centroid location and repeats the procedure until the window center
    converges to a stable point. The OpenCV implementation defines two stopping criteria:
    a maximum number of iterations and a window center displacement value below which
    the position is considered to have converged to a stable point. These two criteria
    are stored in a `cv::TermCriteria` instance. The `cv::meanShift` function returns
    the number of iterations that have been performed. Obviously, the quality of the
    result depends on the quality of the probability map provided on the given initial
    position. Note that here, we used a histogram of colors to represent an image''s
    appearance; it is also possible to use histograms of other features to represent
    the object (for example, a histogram of edge orientation).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 均值漂移算法是一个迭代过程，它定位概率函数的局部最大值。它是通过找到预定义窗口内数据点的质心或加权平均值来做到这一点的。然后，算法将窗口中心移动到质心位置，并重复此过程，直到窗口中心收敛到一个稳定点。OpenCV实现定义了两个停止标准：最大迭代次数和窗口中心位移值，低于此值的位置被认为已收敛到一个稳定点。这两个标准存储在一个`cv::TermCriteria`实例中。`cv::meanShift`函数返回已执行的迭代次数。显然，结果的质量取决于在给定初始位置提供的概率图的质量。请注意，在这里，我们使用颜色直方图来表示图像的外观；也可以使用其他特征的直方图来表示对象（例如，边缘方向的直方图）。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The mean shift algorithm has been largely used for visual tracking. [Chapter
    11](part0072_split_000.html#page "Chapter 11. Processing Video Sequences"), *Processing
    Video Sequences*, will explore the problem of object tracking in more detail
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值漂移算法已被广泛用于视觉跟踪。[第11章](part0072_split_000.html#page "第11章. 处理视频序列")，*处理视频序列*，将更详细地探讨对象跟踪的问题
- en: 'The mean shift algorithm has been introduced in the article *Mean Shift: A
    robust approach toward feature space analysis* by *D. Comaniciu and P. Meer* in
    *IEEE transactions on Pattern Analysis and Machine Intelligence, volume 24, number
    5, May 2002*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '均值漂移算法在D. Comaniciu和P. Meer在*IEEE transactions on Pattern Analysis and Machine
    Intelligence, 第24卷，第5期，2002年5月*上发表的*Mean Shift: A robust approach toward feature
    space analysis*一文中被介绍。'
- en: OpenCV also offers an implementation of the CamShift algorithm, which is an
    improved version of the mean shift algorithm in which the size and the orientation
    of the window can change.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV还提供了一个CamShift算法的实现，这是均值漂移算法的一个改进版本，其中窗口的大小和方向可以改变。
- en: Retrieving similar images using the histogram comparison
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用直方图比较检索相似图像
- en: Content-based image retrieval is an important problem in computer vision. It
    consists of finding a set of images that present content that is similar to a
    given query image. Since we have learned that histograms constitute an effective
    way to characterize an image's content, it makes sense to think that they can
    be used to solve the content-based retrieval problem.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的图像检索是计算机视觉中的一个重要问题。它包括找到一组与给定查询图像内容相似的图像。由于我们已经了解到直方图是表征图像内容的一种有效方式，因此认为它们可以用来解决基于内容的检索问题是有意义的。
- en: The key here is to be able to measure the similarity between two images by simply
    comparing their histograms. A measurement function that will estimate how different,
    or how similar, two histograms are will need to be defined. Various such measures
    have been proposed in the past, and OpenCV proposes a few of them in its implementation
    of the `cv::compareHist` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于能够通过简单地比较两个图像的直方图来测量两个图像之间的相似性。需要定义一个测量函数，该函数将估计两个直方图之间的差异或相似程度。过去已经提出了各种此类度量，OpenCV在其`cv::compareHist`函数的实现中提出了一些。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to compare a reference image with a collection of images and find
    the ones that are the most similar to this query image, we created an `ImageComparator`
    class. This class contains a reference to a query image and an input image, together
    with their histograms. In addition, since we will perform the comparison using
    color histograms, the `ColorHistogram` class is used as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将参考图像与一组图像进行比较，并找到与查询图像最相似的图像，我们创建了一个`ImageComparator`类。这个类包含一个查询图像和一个输入图像的引用，以及它们的直方图。此外，由于我们将使用颜色直方图进行比较，因此使用`ColorHistogram`类如下：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To get a reliable similarity measure, the histogram should be computed over
    a reduced number of bins. Therefore, the class allows you to specify the number
    of bins to be used in each BGR channel. Refer to the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得可靠的相似性度量，直方图应该在较少的 bin 上计算。因此，该类允许你指定每个 BGR 通道中使用的 bin 数量。请参阅以下代码：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The query image is specified using an appropriate setter that also computes
    the reference histogram as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 查询图像通过一个适当的设置器指定，该设置器还会计算参考直方图，如下所示：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, a `compare` method compares the reference image with a given input
    image. The following method returns a score that indicates how similar the two
    images are:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个 `compare` 方法比较参考图像与给定输入图像。以下方法返回一个分数，表示两个图像的相似程度：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding class can be used to retrieve images that are similar to a given
    query image. The following code is initially provided to the class instance:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类可以用来检索与给定查询图像相似的图像。以下代码最初提供给类实例：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, the query image we used is the color version of the beach image shown
    in the *Backprojecting a histogram to detect specific image content* recipe earlier
    in the chapter. This image was compared to the following series of images. The
    images are shown in order from the most similar to the least similar, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用的查询图像是本章前面在 *将直方图反投影以检测特定图像内容* 菜谱中显示的海滩图像的颜色版本。此图像与以下一系列图像进行了比较。图像按从最相似到最不相似的顺序显示：
- en: '![How to do it...](img/00043.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00043.jpeg)'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most histogram comparison measures are based on bin-by-bin comparisons. This
    is why it is important to work with a reduced number of histogram bins when measuring
    the similarity of two color histograms. The call to `cv::compareHist` is straightforward.
    You just input the two histograms and the function returns the measured distance.
    The specific measurement method you want to use is specified using a flag. In
    the `ImageComparator` class, the intersection method is used (with the `CV_COMP_INTERSECT`
    flag). This method simply compares, for each bin, the two values in each histogram
    and keeps the minimum one. The similarity measure, then, is the sum of these minimum
    values. Consequently, two images that have histograms with no colors in common
    would get an intersection value of `0`, while two identical histograms would get
    a value that is equal to the total number of pixels.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数直方图比较度量都是基于每个直方图 bin 的比较。这就是为什么在测量两个颜色直方图的相似性时，与较少的直方图 bin 数量一起工作很重要。调用 `cv::compareHist`
    是直接的。你只需输入两个直方图，函数就会返回测量的距离。你想要使用的特定测量方法是通过一个标志指定的。在 `ImageComparator` 类中，使用的是交集方法（使用
    `CV_COMP_INTERSECT` 标志）。这种方法简单地比较每个 bin 中每个直方图的两个值，并保留最小的一个。因此，相似性度量是这些最小值的总和。因此，两个没有共同颜色的直方图的图像将得到一个交集值为
    `0`，而两个相同的直方图将得到一个等于像素总数的值。
- en: The other available methods are the Chi-Square measure (the `CV_COMP_CHISQR`
    flag) that sums the normalized square difference between the bins, the correlation
    method (the `CV_COMP_CORREL` flag) that is based on the normalized cross-correlation
    operator used in signal processing to measure the similarity between two signals,
    and the Bhattacharyya measure (the `CV_COMP_BHATTACHARYYA` flag) that is used
    in statistics to estimate the similarity between two probabilistic distributions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的方法包括卡方度量（`CV_COMP_CHISQR` 标志），它计算 bin 之间的归一化平方差之和，相关方法（`CV_COMP_CORREL`
    标志），它基于在信号处理中用于测量两个信号相似性的归一化互相关算子，以及 Bhattacharyya 度量（`CV_COMP_BHATTACHARYYA`
    标志），它在统计学中用于估计两个概率分布的相似性。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The OpenCV documentation provides a description of the exact formulas used in
    the different histogram comparison measures.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV 文档提供了不同直方图比较度量中使用的确切公式的描述。
- en: Earth Mover Distance is another popular histogram comparison method. It is implemented
    in OpenCV as the `cv::EMD` function. The main advantage of this method is that
    it takes into account the values found in adjacent bins to evaluate the similarity
    of two histograms. It is described in the article *The Earth Mover's Distance
    as a Metric for Image Retrieval* by *Y. Rubner, C. Tomasi, and L. J. Guibas in
    Int. Journal of Computer Vision, Volume 40, Number 2., 2000, pp. 99-121*.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地球迁移距离是另一种流行的直方图比较方法。它在OpenCV中作为`cv::EMD`函数实现。这种方法的主要优点是它考虑了相邻桶中找到的值来评估两个直方图的相似性。它被描述在Y.
    Rubner, C. Tomasi, 和 L. J. Guibas在《国际计算机视觉杂志》第40卷第2期，2000年，第99-121页的论文《The Earth
    Mover's Distance as a Metric for Image Retrieval》中。
- en: Counting pixels with integral images
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用积分图像计数像素
- en: 'In the previous recipes, we learned that a histogram is computed by going through
    all the pixels of an image and cumulating a count of how often each intensity
    value occurs in this image. We have also seen that sometimes, we are only interested
    in computing our histogram in a certain area of the image. In fact, having to
    cumulate a sum of pixels inside an image''s subregion is a common task in many
    computer vision algorithms. Now, suppose you have to compute several such histograms
    over multiple regions of interest inside your image. All these computations could
    rapidly become very costly. In such a situation, there is a tool that can drastically
    improve the efficiency of counting pixels over image subregions: the **integral
    image**.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们了解到直方图是通过遍历图像的所有像素并累计每个强度值在此图像中出现的频率来计算的。我们也看到，有时我们只对在图像的某个区域计算直方图感兴趣。实际上，在图像的子区域内累计像素总和是许多计算机视觉算法中的常见任务。现在，假设你必须在图像内多个感兴趣区域内计算多个这样的直方图。所有这些计算可能会迅速变得非常昂贵。在这种情况下，有一个工具可以极大地提高在图像子区域内计数像素的效率：**积分图像**。
- en: Integral images have been introduced as an efficient way of summing pixels in
    image regions of interest. They are widely used in applications that involve,
    for example, computations over sliding windows at multiple scales.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 积分图像被引入作为一种在图像感兴趣区域中累加像素的高效方法。它们在涉及例如在多个尺度上滑动窗口计算的应用中被广泛使用。
- en: This recipe will explain the principle behind integral images. Our objective
    here is to show how pixels can be summed over a rectangle region by using only
    three arithmetic operations. Once we have learned this concept, the *There's more...*
    section of this recipe will show you two examples where integral images can be
    advantageously used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将解释积分图像背后的原理。我们的目标是展示如何仅通过三个算术运算来在矩形区域内累加像素。一旦我们掌握了这个概念，本食谱的*更多内容...*部分将展示两个例子，说明积分图像如何被有利地使用。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This recipe will play with the following picture, in which a region of interest
    showing a girl on her bike is identified:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将处理以下图片，其中识别了一个显示骑自行车的女孩的兴趣区域：
- en: '![How to do it...](img/00044.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00044.jpeg)'
- en: 'Integral images are useful when you need to sum pixels over several image areas.
    Normally, if you wish to get the sum of all pixels over a region of interest,
    you would write the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要对多个图像区域中的像素进行求和时，积分图像非常有用。通常，如果你希望获取对感兴趣区域的像素总和，你会编写以下代码：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `cv::sum` function simply loops over all the pixels of the region and accumulates
    the sum. Using an integral image, this can be achieved using only three additive
    operations. However, first you need to compute the integral image as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::sum`函数简单地遍历该区域的像素并累计总和。使用积分图像，这可以通过仅使用三个加法运算来实现。然而，首先你需要按照以下方式计算积分图像：'
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As will be explained in the next section, the same result can be obtained using
    this simple arithmetic expression on the computed integral image as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如下一节所述，可以使用以下简单的算术表达式在计算出的积分图像上获得相同的结果：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Both approaches give you the same result. However, computing the integral image
    is costly, since you have to loop over all the image pixels. The key is that once
    this initial computation is done, you will need to add only four pixels to get
    a sum over a region of interest no matter what the size of this region is. Integral
    images then become advantageous to use when multiple such pixel sums have to be
    computed over multiple regions of different sizes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会给出相同的结果。然而，计算积分图像是昂贵的，因为你必须遍历图像中的所有像素。关键是，一旦完成这个初始计算，无论感兴趣的区域大小如何，你只需要添加四个像素来得到一个区域的和。因此，当需要计算多个不同大小的区域中的多个像素总和时，积分图像的使用就变得有利。
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'In the previous section, you were introduced to the concept of integral images
    through a brief demonstration of the *magic* behind them, that is, how they can
    be used to cheaply compute the sum of pixels inside rectangular regions. To understand
    how they work, let''s now define what an integral image is. An integral image
    is obtained by replacing each pixel with the value of the sum of all the pixels
    located inside the upper-left quadrant delimitated by this pixel. The integral
    image can be computed by scanning the image once, as the integral value of a current
    pixel is given by the integral value of the previously discussed pixel plus the
    value of the cumulative sum of the current line. The integral image is therefore
    a new image containing pixel sums. To avoid overflows, this image is usually an
    image of `int` values (`CV_32S`) or float values (`CV_32F`). For example, in the
    following figure, pixel **A** in this integral image would contain the sum of
    the pixels contained inside the upper-left corner area, which is identified with
    a double-hatched pattern. Refer to the following figure:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你通过一个简要的演示了解了积分图像背后的**魔法**，即它们如何被用来廉价地计算矩形区域内部像素的总和。为了理解它们是如何工作的，现在让我们定义一下什么是积分图像。积分图像是通过将每个像素替换为位于该像素定义的左上象限内所有像素值的总和来获得的。积分图像可以通过扫描图像一次来计算，因为当前像素的积分值由之前讨论的像素的积分值加上当前行的累积和的值给出。因此，积分图像是一个包含像素总和的新图像。为了避免溢出，这个图像通常是一个`int`值（`CV_32S`）或浮点值（`CV_32F`）的图像。例如，在下面的图中，这个积分图像中的像素**A**将包含位于左上角区域内的像素总和，该区域用双虚线图案标识。参见图：
- en: '![How it works...](img/00045.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00045.jpeg)'
- en: 'Once the integral image has been computed, any summation over a rectangular
    region can be easily obtained through four pixel accesses, and here is why. Considering
    the preceding figure again, we can see that the sum of the pixels inside the region
    delimitated by the pixels **A**, **B**, **C**, and **D** can be obtained by reading
    the integral value at pixel **D**, from which you subtract the values of the pixels
    over **B** and to the left-hand side of **C**. However, by doing so, you have
    subtracted twice the sum of pixels located in the upper-left corner of **A**;
    this is why you have to re-add the integral sum at **A**. Formally, then, the
    sum of pixels inside **A**, **B**, **C**, and **D** is given by *A-B-C+D*. If
    we use the `cv::Mat` method to access pixel values, this formula translates to
    the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算了积分图像，任何矩形区域的求和都可以通过四次像素访问轻松获得，原因如下。再次考虑前面的图，我们可以看到，位于像素**A**、**B**、**C**和**D**定义的区域内的像素总和可以通过读取像素**D**的积分值来获得，从该值中减去像素**B**和**C**左侧的像素值。然而，这样做会减去**A**左上角像素总和的两倍；这就是为什么你必须重新加上**A**的积分和。形式上，**A**、**B**、**C**和**D**内部像素的总和由*A-B-C+D*给出。如果我们使用`cv::Mat`方法来访问像素值，这个公式就转化为以下形式：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The complexity of this computation is, therefore, constant, no matter what the
    size of the region of interest is. Note that for simplicity, we used the `at`
    method of the `cv::Mat` class, which is not the most efficient way to access pixel
    values (see [Chapter 2](part0019_split_000.html#page "Chapter 2. Manipulating
    Pixels"), *Manipulating Pixels*). This aspect will be discussed in the *There's
    more...* section of this recipe, which presents two applications that benefit
    from the efficiency of the integral image concept.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个计算的复杂度是常数，无论感兴趣的区域大小如何。请注意，为了简单起见，我们使用了`cv::Mat`类的`at`方法，这不是访问像素值最有效的方法（参见[第2章](part0019_split_000.html#page
    "第2章. 操作像素")，*操作像素*）。这个方面将在本食谱的*还有更多...*部分中讨论，该部分介绍了两个受益于积分图像概念效率的应用。
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Integral images are used whenever multiple pixel summations must be performed.
    In this section, we will illustrate the use of integral images by introducing
    the concept of adaptive thresholding. Integral images are also useful for the
    efficient computation of histograms over multiple windows. This is also explained
    in this section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 整数图像在需要执行多个像素求和时被使用。在本节中，我们将通过介绍自适应阈值的概念来展示整数图像的使用。整数图像对于在多个窗口上高效计算直方图也是很有用的。这一点在本节中也有解释。
- en: Adaptive thresholding
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自适应阈值
- en: 'Applying a threshold on an image in order to create a binary image could be
    a good way to extract the meaningful elements of an image. Suppose that you have
    the following image of a book:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像上应用阈值以创建二值图像可能是提取图像有意义元素的好方法。假设你有一张书的图像：
- en: '![Adaptive thresholding](img/00046.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![自适应阈值](img/00046.jpeg)'
- en: 'Since you are interested in analyzing the text in this image, you apply a threshold
    to this image as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你对分析图像中的文本感兴趣，你将应用以下阈值到这张图像上：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You obtain the following result:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以得到以下结果：
- en: '![Adaptive thresholding](img/00047.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![自适应阈值](img/00047.jpeg)'
- en: In fact, no matter what value you choose for the threshold, in some parts of
    the image, you get missing text, whereas in other parts, the text disappears under
    the shadow. To overcome this problem, one possible solution consists of using
    a local threshold that is computed from each pixel's neighborhood. This strategy
    is called **adaptive thresholding**, and it consists of comparing each pixel with
    the mean value of the neighboring pixels. Pixels that clearly differ from their
    local mean will then be considered as outliers and will be cut off by the thresholding
    process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，无论你选择什么阈值值，在图像的某些部分，你会得到缺失的文本，而在其他部分，文本则被阴影所掩盖。为了克服这个问题，一个可能的解决方案是使用从每个像素的邻域计算出的局部阈值。这种策略被称为**自适应阈值**，它包括将每个像素与相邻像素的平均值进行比较。那些明显与其局部平均值不同的像素将被视为异常值，并通过阈值过程被裁剪掉。
- en: 'Adaptive thresholding, therefore, requires the computation of a local mean
    around every pixel. This requires multiple image window summations that can be
    computed efficiently through the integral image. Consequently, the first step
    is to compute the following integral image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自适应阈值需要计算每个像素周围的局部平均值。这需要通过整数图像进行多次图像窗口求和，这可以通过整数图像高效地计算。因此，第一步是计算以下整数图像：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can go through all the pixels and compute the mean over a square neighborhood.
    We could use our `IntegralImage` class to do so, but this one uses the inefficient
    `at` method for pixel access. This time, let''s get efficient by looping over
    the image using the pointers as we learned in [Chapter 2](part0019_split_000.html#page
    "Chapter 2. Manipulating Pixels"), *Manipulating Pixels*. This loop looks as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以遍历所有像素，并在一个正方形邻域内计算平均值。我们可以使用我们的`IntegralImage`类来做这件事，但这个类使用低效的`at`方法来访问像素。这次，让我们通过使用指针来遍历图像，就像我们在[第2章](part0019_split_000.html#page
    "第2章. 操作像素")“操作像素”中学到的那样，来提高效率。这个循环看起来如下所示：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this example, a neighborhood of size 21 x 21 is used. To compute each mean,
    we need to access the four integral pixels that delimitate the square neighborhood:
    two located on the line pointed by `idata1` and two on the line pointed by `idata2`.
    The current pixel is compared to the computed mean, from which we subtract a threshold
    value (here, set to `10`); this is to make sure that rejected pixels clearly differ
    from their local mean. The following binary image is then obtained:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用了大小为21 x 21的邻域。为了计算每个平均值，我们需要访问界定正方形邻域的四个整数像素：两个位于由`idata1`指向的行上，两个位于由`idata2`指向的行上。当前像素与计算出的平均值进行比较，然后从这个平均值中减去一个阈值值（这里设置为`10`）；这是为了确保被拒绝的像素明显不同于它们的局部平均值。然后得到以下二值图像：
- en: '![Adaptive thresholding](img/00048.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![自适应阈值](img/00048.jpeg)'
- en: 'Clearly, this is a much better result than the one we got using a fixed threshold.
    Adaptive thresholding is a common image-processing technique. As such, it is also
    implemented in OpenCV as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这比我们使用固定阈值得到的结果要好得多。自适应阈值是一种常见的图像处理技术。因此，它也被OpenCV实现，如下所示：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This function call produces exactly the same result as the one we obtained using
    our integral image. In addition, instead of using the local mean for thresholding,
    this function allows you to use a Gaussian weighted sum (the method flag would
    be `ADAPTIVE_THRESH_GAUSSIAN_C`) in this case. It is interesting to note that
    our implementation is slightly faster than the `cv::adaptiveThreshold` call.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用产生的结果与我们使用积分图像得到的结果完全相同。此外，与使用局部均值进行阈值处理不同，这个函数允许你在这种情况下使用高斯加权求和（方法标志为
    `ADAPTIVE_THRESH_GAUSSIAN_C`）。值得注意的是，我们的实现比 `cv::adaptiveThreshold` 调用稍微快一些。
- en: 'Finally, it is worth mentioning that we can also write an adaptive thresholding
    procedure by using the OpenCV image operators. This would be done as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，我们还可以使用OpenCV图像运算符编写自适应阈值处理程序。这将如下所示：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Image filtering will be covered in [Chapter 6](part0047_split_000.html#page
    "Chapter 6. Filtering the Images"), *Filtering the Images*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图像滤波将在 [第6章](part0047_split_000.html#page "第6章. 滤波图像")，*滤波图像* 中介绍。
- en: Visual tracking using histograms
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用直方图进行视觉跟踪
- en: As we learned in the previous recipes, a histogram constitutes a reliable global
    representation of an object's appearance. In this recipe, we will demonstrate
    the usefulness of integral images by showing you how we can locate an object in
    an image by searching for an image area that presents a histogram similar to a
    target object. We accomplished this in the *Using the mean shift algorithm to
    find an object* recipe by using the concepts of histogram backprojection and local
    search through mean shift. This time, we will find our object by performing an
    explicit search for regions of similar histograms over the full image.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的菜谱中学到的，直方图构成了一个可靠的全球表示，用于描述一个对象的外观。在这个菜谱中，我们将通过展示如何通过搜索与目标对象具有相似直方的图像区域来定位图像中的对象，来展示积分图像的有用性。我们在
    *使用均值漂移算法查找对象* 的菜谱中通过使用直方图反向投影和通过均值漂移进行局部搜索的概念实现了这一点。这次，我们将通过在整幅图像上执行对具有相似直方的区域的显式搜索来找到我们的对象。
- en: In the special case where an integral image is used on a binary image made of
    `0` and `1` values, the integral sum gives you the number of pixels that have
    a value of 1 inside the specified region. We will exploit this fact in this recipe
    to compute the histogram of a gray-level image.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在积分图像用于由 `0` 和 `1` 值组成的二值图像的特殊情况下，积分和给出了指定区域内值为1的像素数量。我们将利用这一事实在本菜谱中计算灰度图像的直方图。
- en: 'The `cv::integral` function also works for multichannel images. You can take
    advantage of this fact to compute histograms of image subregions using integral
    images. You simply need to convert your image into a multichannel image made of
    binary planes; each of these planes is associated to a bin of your histogram and
    shows you which pixels have a value that falls into this bin. The following function
    creates such multiplane images from a gray-level one:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::integral` 函数也适用于多通道图像。你可以利用这一事实，通过积分图像来计算图像子区域的直方图。你只需将你的图像转换为由二值平面组成的多个通道图像；每个平面都与你的直方图的一个bin相关联，并显示哪些像素的值落在这个bin中。以下函数将灰度图像转换为这样的多平面图像：'
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The integral image computations can also be encapsulated into one convenient
    template class as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 积分图像的计算也可以封装到一个方便的模板类中，如下所示：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We now want to find where the girl on the bicycle, whom we identified in the
    previous image, is in a subsequent image. Let''s first compute the histogram of
    the girl in the original image. We can accomplish this using the `Histogram1D`
    class we built in a previous recipe of this chapter. Here, we produce a 16-bin
    histogram as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想找到在上一幅图像中识别出的骑自行车的女孩在后续图像中的位置。首先，让我们计算原始图像中女孩的直方图。我们可以使用本章之前菜谱中构建的 `Histogram1D`
    类来完成此操作。在这里，我们生成一个16个bin的直方图，如下所示：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding histogram will be used as a referential representation to locate
    the target object (the girl on her bike) in a subsequent image.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述直方图将被用作参考表示，以在后续图像中定位目标对象（骑自行车的女孩）。
- en: 'Suppose that the only information we have is that the girl is moving more or
    less horizontally over the image. Since we will have many histograms to compute
    at various locations, we compute the integral image as a preliminary step. Refer
    to the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们唯一的信息是女孩在图像中大致水平移动。由于我们将在不同的位置计算许多直方图，我们将计算积分图像作为初步步骤。请参考以下代码：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To perform the search, we loop over a range of possible locations and compare
    the current histogram with the referential one. Our goal is to find the location
    with the most similar histogram. Refer to the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行搜索，我们遍历一系列可能的位置，并将当前直方图与参考直方图进行比较。我们的目标是找到具有最相似直方图的位置。参考以下代码：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The location with the most similar histogram is then identified as the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有最相似直方图的位置相对应的是以下：
- en: '![Visual tracking using histograms](img/00049.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![使用直方图进行视觉跟踪](img/00049.jpeg)'
- en: The white rectangle represents the search area. Histograms of all windows that
    fit inside this area have been computed. We kept the window size constant, but
    it could have been a good strategy to also search for slightly smaller or larger
    windows in order to take into account the eventual changes in scale. Note that
    in order to limit the complexity of this computation, the number of bins in the
    histograms to be computed should be kept low. In our example, we reduced this
    to `16` bins. Consequently, plane `0` of this multiplane image contains a binary
    image that shows you all pixels that have a value between `0` and `15`, while
    plane `1` shows you pixels with values between `16` and `31`, and so on.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 白色矩形表示搜索区域。已计算了所有适合该区域的窗口的直方图。我们保持了窗口大小不变，但寻找稍微小一些或大一些的窗口可能是一个很好的策略，以便考虑最终的比例变化。请注意，为了限制计算的复杂性，要计算的直方图中的箱数应保持较低。在我们的例子中，我们将这个数字减少到`16`个箱。因此，多平面图像的平面`0`包含一个二值图像，显示所有介于`0`和`15`之间的像素，而平面`1`显示介于`16`和`31`之间的像素，依此类推。
- en: The search for an object consisted of computing the histograms of all windows
    of the given size over a predetermined range of pixels. This represents the computation
    of `3200` different histograms that have been efficiently computed from our integral
    image. All the histograms returned by our `IntegralImage` class are contained
    in a `cv::Vec` object (because of the use of the `at` method). We then use the
    `cv::compareHist` function to identify the most similar histogram (remember that
    this function, like most OpenCV functions, can accept either the `cv::Mat` or
    `cv::Vec` object through the convenient `cv::InputArray` generic parameter type).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的搜索包括计算给定大小窗口在预定像素范围内的所有直方图。这代表了从我们的积分图像中高效计算出的`3200`个不同直方图的计算。我们 `IntegralImage`
    类返回的所有直方图都包含在一个 `cv::Vec` 对象中（由于使用了 `at` 方法）。然后我们使用 `cv::compareHist` 函数来识别最相似的直方图（请记住，这个函数，像大多数
    OpenCV 函数一样，可以通过方便的 `cv::InputArray` 泛型参数类型接受 `cv::Mat` 或 `cv::Vec` 对象）。
- en: See also
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 8](part0058_split_000.html#page "Chapter 8. Detecting Interest Points"),
    *Detecting Interest Points*, will present the `SURF` operator that also relies
    on the use of integral images'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 8 章](part0058_split_000.html#page "第 8 章. 检测兴趣点"), *检测兴趣点* 将介绍也依赖于积分图像使用的
    `SURF` 操作符。'
- en: The article *Robust Fragments-based Tracking using the Integral Histogram* by
    *A. Adam, E. Rivlin, and I. Shimshoni in the proceedings of the Int. Conference
    on Computer Vision and Pattern Recognition, 2006, pp. 798-805*, describes an interesting
    approach that uses integral images to track objects in an image sequence
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章《基于积分直方图的鲁棒片段跟踪》（*A. Adam, E. Rivlin, 和 I. Shimshoni 在 2006 年国际计算机视觉和模式识别会议论文集中的作品，第
    798-805 页*）描述了一种有趣的方法，该方法使用积分图像在图像序列中跟踪对象。
