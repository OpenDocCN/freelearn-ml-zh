- en: Designing ChefBot Hardware and Circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the design and workings of ChefBot hardware
    and look at a selection of its hardware components. In the previous chapter, we
    designed and simulated the basic robot framework in a hotel environment using
    Gazebo and ROS, and tested a few variables, such as the robot body mass, motor
    torque, wheel diameter, and more. We also tested the autonomous navigation capability
    of ChefBot in a hotel environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this using hardware, we need to select all the hardware components
    and figure out how to connect all these components. We know that the main functionality
    of this robot is navigation: this robot will have the ability to navigate from
    a start position to an end position without any collision with its surroundings.
    We will discuss the different sensors and hardware components required to achieve
    this goal. We will look at a block diagram representation of these components
    and its explanation, and also discuss the main functions and physical operations
    of the robot. Finally, we need to select the components required to build the
    robot. We will also familiarize ourselves with the online stores where we can
    purchase these components.'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a TurtleBot, you may skip this chapter because this chapter is only
    for those who need to create their robot's hardware. Let's look at the specifications
    that we have to meet in the design of the hardware. The robot hardware mainly
    includes the robot chassis, sensors, actuators, controller boards, and PC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Block diagram and description of the Chefbot robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robot component selection and description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workings of Chefbot's hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The components required to build the robot are described in this chapter. You
    have to purchase these components or similar components in order to build the
    ChefBot.
  prefs: []
  type: TYPE_NORMAL
- en: Specifications of the ChefBot's hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be discussing some of the important specifications
    that we mentioned in Chapter 3, *Modeling the Differential-Drive Robot*. The final
    robot prototype will meet the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple and cost-effective robot chassis design**: The robot chassis design
    should be simple and cost effective compared to existing robots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autonomous navigation functionality**: The robot should autonomously navigate
    and it should contain the necessary sensors for doing this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long battery life**: The robot should have a long battery life in order to
    work continuously. The length of time that it can work should be greater than
    one hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Obstacle avoidance**: The robot should be able to avoid static and dynamic
    objects in its surroundings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The robot hardware design should meet these specifications. Let's look at one
    of the possible ways of interconnecting the components in this robot. In the next
    section, we will look at a block diagram of the robot and use it to examine its
    workings.
  prefs: []
  type: TYPE_NORMAL
- en: Block diagram of the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The robot''s movement is controlled by two **direct current** (**DC**) gear
    motors using an encoder. The two motors are driven using a motor driver. The motor
    driver is interfaced with an embedded controller board, which will send commands
    to the motor driver to control the motor''s movements. The encoder of the motor
    is interfaced with the controller board in order to count the number of rotations
    of the motor shaft. This data is used to compute the odometry data of the robot.
    There are ultrasonic sensors that are interfaced with the controller board in
    order to sense the obstacles and measure the distance from the obstacles. There
    is an IMU sensor to improve odometry calculation. The embedded controller board
    is interfaced with a PC, which does all the high-end processing in the robot.
    Vision and sound sensors are interfaced with the PC and Wi-Fi is attached for
    remote operations. Each component of the robot is explained in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b7cf915-657b-47fd-af63-ca3e13160f73.png)'
  prefs: []
  type: TYPE_IMG
- en: Robot hardware block diagram
  prefs: []
  type: TYPE_NORMAL
- en: Motor and encoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The robot that we are going to design is a differential-drive robot with two
    wheels, so we will require two motors for its locomotion. Each motor consists
    of quadrature encoders ([http://www.creative-robotics.com/quadrature-intro](http://www.creative-robotics.com/quadrature-intro))
    so that we can get motor rotation feedback data.
  prefs: []
  type: TYPE_NORMAL
- en: The quadrature encoder will send data regarding of the rotation of the motor
    as square pulses; we can decode the pulses to get the number of the encoder's
    ticks, which can be used for feedback. If we know the wheel's diameter and the
    number of ticks of the motor, we can compute the displacement and the angle of
    the robot that moved. This computation is very useful for us in our attempts to
    navigate the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting motors, encoders, and wheels for the robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the simulation, we got an idea of the robot's parameters. While experimenting
    with the simulation's parameters, we mentioned that the motor torque needed to
    drive the robot is 18 N, but the calculated torque is slightly more than this;
    we are selecting a standard torque motor that is very close to the actual torque
    in order to make the motor selection easier. One of the standard motors that we
    might consider is from Pololu. According to our design specifications, we could
    select a high-torque DC gear motor with an encoder working at 12 V DC and with
    a speed of 80 RPM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the selected motor for this robot. The motor comes
    with an integrated quadrature encoder with a resolution of 64 counts per revolution
    of the motor shaft, which corresponds to 8,400 counts per revolution of the gearbox''s
    output shaft:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e3b0acd-1978-499f-90e8-3d35eb65a160.png)'
  prefs: []
  type: TYPE_IMG
- en: DC gear motor with encoder and wheel (see https://www.pololu.com/product/2827)
  prefs: []
  type: TYPE_NORMAL
- en: 'This motor has six differently colored pins . The descriptions of this motor''s
    pins are given in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Color** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| Red | Motor power (connects to one motor terminal) |'
  prefs: []
  type: TYPE_TB
- en: '| Black | Motor power (connects to the other motor terminal) |'
  prefs: []
  type: TYPE_TB
- en: '| Green | Encoder GND |'
  prefs: []
  type: TYPE_TB
- en: '| Blue | Encoder Vcc (3.5 V-20 V) |'
  prefs: []
  type: TYPE_TB
- en: '| Yellow | Encoder A output |'
  prefs: []
  type: TYPE_TB
- en: '| White | Encoder B output |'
  prefs: []
  type: TYPE_TB
- en: In accordance with our design specifications, we will choose a wheel diameter
    of 90 mm. Pololu provides a 90-mm wheel, which is available at [http://www.pololu.com/product/1439](http://www.pololu.com/product/1439).
    The preceding image showed the motor assembled with this wheel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other connectors needed to connect the motors and wheels together are available
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The mounting hub required to mount the wheel to the motor shaft is available
    at [http://www.pololu.com/product/1083](http://www.pololu.com/product/1083).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The L-bracket for the motor to mount onto the robot chassis is available at
    [http://www.pololu.com/product/1084](http://www.pololu.com/product/1084).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motor driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **motor driver**, or **motor controller**, is a circuit that can control the
    speed of the motor. By controlling the motors, we mean that we can control the
    voltage across the motors and can also control the direction and speed of the
    motors. Motors can rotate clockwise or counter clockwise if we change the polarity
    of the motor terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '**H-bridge** circuits are commonly used in motor controllers. An **H-bridge**
    is an electronic circuit that can apply voltage in either direction of the load.
    It has high current-handling properties and can change the direction of the current
    flow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a basic H-bridge circuit using switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/440ebeef-7d5b-4dfb-af85-00ef5275369a.png)'
  prefs: []
  type: TYPE_IMG
- en: H -bridge circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'The direction of the motor according to the state of the four switches is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **S1** | **S2** | **S3** | **S4** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | Motor moves right |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | Motor moves left |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | Motor free runs |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | Motor brakes |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | Motor brakes |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | Motor shoots through |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | Motor shoots through |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | Motor shoots through |'
  prefs: []
  type: TYPE_TB
- en: We have seen the basics of an H-bridge circuit in the preceding motor driver
    circuit diagram. Now, we will select one of the motor drivers for our application
    and discuss how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a motor driver/controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some motor drivers available in Pololu that are compatible with the
    selected motor. The following image shows one of the motor drivers that we will
    use in our robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4de5ba83-20c4-45f2-b3a8-e07cf339f187.png)'
  prefs: []
  type: TYPE_IMG
- en: Dual VNH2SP30 motor driver carrier MD03A
  prefs: []
  type: TYPE_NORMAL
- en: This motor driver is available at [http://www.pololu.com/product/708](http://www.pololu.com/product/708).
  prefs: []
  type: TYPE_NORMAL
- en: This driver can drive two motors with a maximum current rating of 30 A, and
    contains two integrated ICs for driving each of the motors. The pin description
    of this driver is given in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Input pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following pins are the input pins of the motor driver, through which we
    can control mainly the motor speed and direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pin name** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| 1DIAG/EN, 2DIAG/EN | These monitor the fault conditions of motor drivers
    1 and 2\. In a normal operation, they will remain disconnected. |'
  prefs: []
  type: TYPE_TB
- en: '| 1INa, 1INb, 2INa, 2INb | These pins will control the direction of motors
    1 and 2 in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: If INA = INB = 0, the motor will break
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If INA = 1, INB = 0, the motor will rotate clockwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If INA = 0, INB = 1, the motor will rotate counter clockwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* If INA = INB = 1, the motor will break'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1PWM, 2PWM | This will control the speed of motors 1 and 2 by turning them
    on and off at very high speed. |'
  prefs: []
  type: TYPE_TB
- en: '| 1CS, 2CS | This is the current sensing pin for each motor. |'
  prefs: []
  type: TYPE_TB
- en: Output pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The output pins of the motor driver will drive the two motors. The following
    are the output pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pin name** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| OUT 1A, OUT 1B | These pins can connect to motor 1''s power terminals. |'
  prefs: []
  type: TYPE_TB
- en: '| OUT 2A, OUT 2B | These pins can connect to motor 2''s power terminals. |'
  prefs: []
  type: TYPE_TB
- en: Power supply pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the power supply pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pin name** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| VIN (+), GND (-) | These are the supply pins of the two motors. The voltage
    ranges from 5.5 V to 16 V. |'
  prefs: []
  type: TYPE_TB
- en: '| +5 VIN, GND (-) | This is the power supply of the motor driver. The voltage
    should be 5 V. |'
  prefs: []
  type: TYPE_TB
- en: Embedded controller board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Controller boards** are typically I/O boards that can send control signals
    in the form of digital pulses to the H-bridge/motor-driver board and can receive
    inputs from sensors, such as ultrasonic and IR sensors. We can also interface
    motor encoders with the control board in order to send data from the motor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main uses of the controller board in this robot are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing the motor driver and encoder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing the ultrasonic sound sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving sensor values to and from the PC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will deal with I/O boards and interfacing with different components in the
    upcoming chapters. Some of the more popular I/O boards are Arduino (arduino.cc)
    and Tiva-C LaunchPad ([http://www.ti.com/tool/EK-TM4C123GXL](http://www.ti.com/tool/EK-TM4C123GXL))
    by Texas Instruments. We are selecting Tiva-C LaunchPad over Arduino because of
    the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Tiva-C LaunchPad has a microcontroller based on a 32-bit ARM Cortex-M4 with
    256 KB flash memory, 32 KB SRAM, and 80 MHz data transmission frequency; most
    Arduino boards run below these specifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outstanding processing performance combined with fast interrupt handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 timers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16 PWM outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 quadrature encoder inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 **universal asynchronous receiver/transmitters** (**UART**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 V-tolerant **general-purpose input/output** (**GPIO**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low cost and size compared to Arduino boards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily programmable interface IDE called Energia (http://energia.nu/). The code
    written in Energia is Arduino-board compatible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows Texas Instrument''s Tiva-C LaunchPad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02bd256a-b995-419e-88df-cab4ee6cf78c.png)'
  prefs: []
  type: TYPE_IMG
- en: Tiva-C LaunchPad 123 (http://www.ti.com/tool/EK-TM4C123GXL)
  prefs: []
  type: TYPE_NORMAL
- en: The pinout of Texas Instrument's LaunchPad series is given at [http://energia.nu/pin-maps/guide_stellarislaunchpad/](http://energia.nu/pin-maps/guide_stellarislaunchpad/).
    This pinout map is compatible with all LaunchPad series releases. This can also
    be used while programming in the Energia IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Ultrasonic sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ultrasonic sensors**, also called ping sensors and are mainly used to measure
    the distance from an object. The main application of ping sensors is to avoid
    obstacles. The ultrasonic sensor emits high-frequency sound waves and evaluates
    the echoes that it receives from the object. The sensor will calculate the delay
    between the sending and receiving of the echo and determine its distance to the
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: In our robot, collision-free navigation is an important part of the design specifications,
    otherwise there will be damage to the robot. You will see an image showing an
    ultrasonic sensor in the next section. This sensor can be installed on the sides
    of a robot to detect collisions at the sides and back of the robot. Kinect is
    also mainly used for obstacle detection and collision avoidance when used in robotics.
    Kinect can only be expected to be accurate at a range of 0.8 m, so the remaining
    distance from the 0.8 m-range limit can be detected using an ultrasonic sensor.
    In this case, the ultrasonic sensor is actually an add-on to our robot in order
    to increase its collision avoidance and detection abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an ultrasonic sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the more popular and cheap ultrasonic sensors available is **HC-SR04**.
    We are selecting this sensor for our robot because of the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Range of detection is from 2 cm to 4 m
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working voltage is 5 V
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working current is very low, typically 15 mA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use this sensor to accurately detect obstacles. It also works at 5 V.
    Here is an image of HC-SR04 and its pinout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37902c89-4ce4-4281-ad65-ad1795571060.png)'
  prefs: []
  type: TYPE_IMG
- en: Ultrasonic sound sensor (https://www.makerfabs.com/index.php?route=product/product&product_id=72)
  prefs: []
  type: TYPE_NORMAL
- en: 'The pins and their functions are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pins** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| Vcc, GND | These are the supply pins of the ultrasonic sensor. Usually, we
    need to apply 5 V for it to operate normally. |'
  prefs: []
  type: TYPE_TB
- en: '| Trig | This is the input pin of the sensor. We need to apply a pulse with
    a particular duration to this pin to send the ultrasonic sound waves. |'
  prefs: []
  type: TYPE_TB
- en: '| Echo | This is the output pin of the sensor. It will generate a pulse on
    this pin with a time duration according to the delay in receiving the triggered
    pulse. |'
  prefs: []
  type: TYPE_TB
- en: Inertial measurement unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use **the inertial measurement unit** (**IMU**) in this robot to get
    a good estimate of the odometry value and the robot''s pose. The odometry values
    computed from the encoder alone may not be sufficient for efficient navigation,
    as they can contain errors. To compensate for the error during the robot''s movement,
    especially rotation, we will use the IMU in this robot. We are selecting MPU 6050
    for the IMU because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: In MPU 6050, the accelerometer and gyroscope are integrated on a single chip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides high accuracy and sensitivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are able to interface with a magnetometer for better IMU performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The breakout board of MPU 6050 is very cheap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MPU 6050 can directly interface with LaunchPad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both MPU 6050 and LaunchPad are 3.3 V-compatible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software libraries are also available for easier interfacing between MPU 6050
    and LaunchPad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows the breakout board of MPU 6050:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ee5c70b-776c-4a0e-9c0e-d532812fd12f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The MPU 6050 device
  prefs: []
  type: TYPE_NORMAL
- en: 'The pins and their functions are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pins** | **Functions** |'
  prefs: []
  type: TYPE_TB
- en: '| VDD, GND | Supply voltage 2.3 V-3.4 V |'
  prefs: []
  type: TYPE_TB
- en: '| INT | This pin will generate an interrupt when data comes to the device buffer
    |'
  prefs: []
  type: TYPE_TB
- en: '| SCL, SDA | **Serial data line** (**SDA**) and **serial clock line** (SCL)
    are used for I2C communication |'
  prefs: []
  type: TYPE_TB
- en: '| ASCL, ASDA | Auxiliary I2C for communication with the magnetometer |'
  prefs: []
  type: TYPE_TB
- en: We can purchase the breakout board from Amazon at [http://a.co/9EBIquO](http://a.co/9EBIquO).
  prefs: []
  type: TYPE_NORMAL
- en: Kinect/Orbbec Astra
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kinect** is a 3D-vision sensor, mainly used in 3D-vision applications and
    motion-based gaming. We are using Kinect for 3D vision. Using Kinect, the robot
    will get a 3D image of the surrounding. The 3D images are converted to finer points
    that are gathered to form a point cloud. The point cloud data will have all the
    3D parameters that constitute the surrounding environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main use of Kinect on the robot is to mock the functionality of a laser
    scanner. The laser scanner data is essential for the SLAM algorithm to build a
    map of the environment. The laser scanner is a very costly device, so instead
    of buying an expensive laser scanner, we can convert a Kinect into a virtual laser
    scanner. Kinect has officially stopped production, but it''s still available from
    some vendors. One of the alternatives to Kinect is Orbbec Astra ([https://orbbec3d.com/product-astra/](https://orbbec3d.com/product-astra/)).
    It will support the same software that is written for Kinect. The point-cloud-to-laser-data
    conversion is done with this software, so we only need to change the device driver
    if you are using Astra; the resetting of the software is the same. After generating
    the map of the environment, the robot can navigate the surroundings. The following
    image shows the Kinect sensor (A) and Orbbec Astra (B):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c4edfe9-8daa-45c2-8dab-c74dd8d352fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Kinect and Orbbec Astra
  prefs: []
  type: TYPE_NORMAL
- en: Kinect mainly has an IR camera and projector, as well as an RGB camera. The
    IR camera and projector generates the 3D point cloud of the surrounding area.
    It also has a mic array and motorized tilt for moving the Kinect up and down.
    The Astra is very similar to Kinect.
  prefs: []
  type: TYPE_NORMAL
- en: We can purchase Kinect from [http://www.amazon.co.uk/Xbox-360-Kinect-Sensor-Adventures/dp/B0036DDW2G](http://www.amazon.co.uk/Xbox-360-Kinect-Sensor-Adventures/dp/B0036DDW2G).
  prefs: []
  type: TYPE_NORMAL
- en: We can purchase Astra from [https://orbbec3d.com/product-astra/](https://orbbec3d.com/product-astra/).
  prefs: []
  type: TYPE_NORMAL
- en: Central processing unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The robot is mainly controlled by the navigational algorithm that is running
    on its PC. We can choose a laptop, mini PC, or net book to use for the robot's
    processing functionalities. Recently, Intel launched a mini PC called Intel **Next
    Unit of Computing** (**NUC**). It has an ultra-small form factor (size), is lightweight,
    and has a good computing processor with either Intel Celeron, Core i3, or Core
    i5\. It can support up to 16 GB of RAM and has integrated Wi-Fi/Bluetooth. We
    are choosing Intel NUC because of its performance, ultra-small form factor, and
    its light weight. We are not going for a popular board, such as Raspberry Pi ([http://www.raspberrypi.org/](http://www.raspberrypi.org/))
    or Beagle Bone ([http://beagleboard.org/](http://beagleboard.org/)), because we
    require high-computing power, and this cannot be provided by these boards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The NUC we are using is **Intel DN2820FYKH**. Here is the specification of
    this computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Intel Celeron dual core processor with 2.39 GHz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 GB hard disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intel-integrated graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headphone/microphone jack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 V supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows the Intel NUC minicomputer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe1a2290-3758-44c9-86f0-63923de9a671.png)'
  prefs: []
  type: TYPE_IMG
- en: Intel NUC DN2820FYKH
  prefs: []
  type: TYPE_NORMAL
- en: We can purchase NUC from Amazon at [http://a.co/2F2flYl](http://a.co/2F2flYl).
  prefs: []
  type: TYPE_NORMAL
- en: 'This model of NUC is an old model; if it is not available, you can check for
    a low-cost NUC using the following links shown:'
  prefs: []
  type: TYPE_NORMAL
- en: Intel NUC BOXNUC6CAYH ([https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc6cayh.html](https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc6cayh.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intel NUC KIT NUC7CJYH (**[https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc7cjyh.html](https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc7cjyh.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intel NUC KIT NUC5CPYH (**[https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc5cpyh.html)](https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc5cpyh.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intel NUC KIT NUC7PJYH** ([https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc7pjyh.html](https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc7pjyh.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speakers/mic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main function of the robot is autonomous navigation. We will add an additional
    feature with which the robot can interact with users through speech. The robot
    can be given commands using voice input and can speak to the user using a **text-to-speech**
    (**TTS**) engine, which can convert text to speech format. A microphone and speakers
    are essential for this application. There is no particular selection that we will
    recommend for this hardware. If the speaker and mic are USB compatible, then that
    will be great. One of the other alternatives is a Bluetooth headset.
  prefs: []
  type: TYPE_NORMAL
- en: Power supply/battery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important hardware components is the power supply. We saw in
    the specification that the robot has to work for more than one hour. It will be
    good if the supply voltage of the battery is compatible with that required by
    the components. Also, if the size and weight of the battery is less than what
    we had in mind, it will not affect the robot's payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another concern is that the maximum current needed for the entire circuit will
    not exceed the battery''s maximum current, that it can source. The maximum voltage
    and current distribution of each part of the circuit is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Maximum current (in amperes)** |'
  prefs: []
  type: TYPE_TB
- en: '| Intel NUC PC | 12 V, 5 A |'
  prefs: []
  type: TYPE_TB
- en: '| Kinect | 12 V, 1 A |'
  prefs: []
  type: TYPE_TB
- en: '| Motors | 12 V, 0.7 A |'
  prefs: []
  type: TYPE_TB
- en: '| Motor driver, ultrasonic sensors, IMU, speakers | 5 V, < 0.5 A |'
  prefs: []
  type: TYPE_TB
- en: 'To meet these specifications, we are selecting a 12 V, 10 AH li-polymer or
    sealed lead acid (SLA) battery for our robot. Here is a typical low-cost SLA battery
    that we can use for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6be70a5e-ee95-4ed1-ac4e-79de7bd42e10.png)'
  prefs: []
  type: TYPE_IMG
- en: Sealed lead acid battery
  prefs: []
  type: TYPE_NORMAL
- en: We can buy this battery from [http://a.co/iOaMuZe](http://a.co/iOaMuZe). You
    can choose a battery based on how convenience it is for you, but it should satisfy
    the robot's power requirements.
  prefs: []
  type: TYPE_NORMAL
- en: How ChefBot’s hardware works’?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can explain how ChefBot''s hardware works using the following block diagram.
    This is an improved version of our first block diagram, as it mentions the voltage
    of each component and its interconnection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5ec768d-2df2-462d-aa9d-5e782054f8de.png)'
  prefs: []
  type: TYPE_IMG
- en: Detailed block diagram of Chefbot's hardware
  prefs: []
  type: TYPE_NORMAL
- en: The main aim of this chapter was to design the hardware for ChefBot, which included
    finding the appropriate hardware components and learning about the interconnection
    between each part. The main functionality of this robot is to perform autonomous
    navigation. The hardware design of the robot is optimized for autonomous navigation.
  prefs: []
  type: TYPE_NORMAL
- en: The robot drive is based on the differential-drive system, which consists of
    two motors and two wheels. There are caster wheels for supporting the main wheels.
    These two motors can move the robot to face in any direction on a 2D plane by
    adjusting their direction and speed of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: For controlling the velocity and direction of the wheels, we have to interface
    a motor controller, which can perform these functions. The motor driver we choose
    should able to control two motors at the same time, and it should also be able
    to change their direction and speed.
  prefs: []
  type: TYPE_NORMAL
- en: The motor driver pins are interfaced with a microcontroller board called Tiva-C
    LaunchPad, which can send the commands to change the direction and speed of the
    motor. The motor driver is interfaced with LaunchPad with the help of a level
    shifter. The **level shifter** is a circuit that can shift voltage levels from
    3.3 V to 5 V and vice versa. We are using a level shifter because the motor driver
    is operating at a level of 5 V, but the LaunchPad board is operating at 3.3 V.
  prefs: []
  type: TYPE_NORMAL
- en: Each motor has a rotation feedback sensor called an encoder, which can be used
    to estimate the robot's position. The encoders are interfaced with LaunchPad with
    the level shifter.
  prefs: []
  type: TYPE_NORMAL
- en: Other sensors that are interfaced with LaunchPad include an ultrasonic sound
    sensor and IMU. The ultrasonic sound sensor can detect objects that are close
    by, but that cannot be detected by the Kinect sensor. IMU is used along with encoders
    to get a good estimation of the robot's pose.
  prefs: []
  type: TYPE_NORMAL
- en: All sensor values are received on the LaunchPad and sent to the PC via USB.
    The LaunchPad board runs a firmware code that can receive all sensor values and
    send them to the PC.
  prefs: []
  type: TYPE_NORMAL
- en: The PC is interfaced with Kinect, the LaunchPad board, the speaker, and the
    mic. The PC has ROS running on it, and it will receive Kinect data and convert
    it to its equivalent laser scanner data. This data can be used to build a map
    of the environment using SLAM. The speaker and mic are used for communication
    between the user and robot. The speed commands generated in ROS nodes are sent
    to LaunchPad. LaunchPad will process the speed commands and send the appropriate
    PWM values to the motor driver circuit.
  prefs: []
  type: TYPE_NORMAL
- en: After designing and discussing the workings of the robot's hardware, we can
    discuss the detailed interfacing of each component and the firmware coding necessary
    for this interfacing in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the features of the robot that we are going
    to design. The main feature of this robot is its autonomous navigation. The robot
    can navigate its surroundings by analyzing sensor readings. We looked at the robot's
    block diagram and discussed the role of each block, selecting the appropriate
    components that satisfy our requirements. We also suggested some economical components
    with which to build this robot. In the next chapter, we will take a closer look
    at actuators and the interfacing that we will use for them in this robot.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is robot hardware design all about?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an H-bridge circuit and what are its functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the essential components for a robot's navigation algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the criteria that have to be kept in mind while selecting robotic components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main applications of Kinect as regards this robot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can learn more about the Tiva-C LaunchPad board from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://processors.wiki.ti.com/index.php/Getting_Started_with_the_TIVA%E2%84%A2_C_Series_TM4C123G_LaunchPad](http://processors.wiki.ti.com/index.php/Getting_Started_with_the_TIVA%E2%84%A2_C_Series_TM4C123G_LaunchPad)'
  prefs: []
  type: TYPE_NORMAL
