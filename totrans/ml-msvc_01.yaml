- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Importance of MSA and Machine Learning in Enterprise Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MSA和机器学习在企业系统中的重要性
- en: In today’s market, the competition has never been fiercer, and user requirements
    for IT systems are constantly increasing. To be able to keep up with customer
    requirements and market demands, the need for a shorter **time-to-market** (**TTM**)
    for IT systems has never been more important, all of which has pushed for agile
    deployment and the need to streamline the development process and leverage as
    much code reuse as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的市场中，竞争从未如此激烈，用户对IT系统的需求不断增长。为了能够跟上客户需求和市场需求，IT系统需要更短的**上市时间**（**TTM**）的需求从未如此重要，所有这些都推动了敏捷部署和简化开发流程的需求，以及尽可能多地利用代码重用的需求。
- en: '**Microservices architecture** (**MSA**) addresses these concerns and tries
    to deliver a more competitive, reliable, and rapid deployment and update delivery
    while maintaining an efficient, stable system operation.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**（**MSA**）解决了这些担忧，并试图在保持高效、稳定的系统运行的同时，提供更具竞争力、更可靠、更快速部署和更新的交付。'
- en: In this chapter, we will learn more details about how microservices help build
    a modern, flexible, scalable, and resilient enterprise system. The chapter will
    go over key concepts in MSA and discuss the common enterprise system architectures,
    how each architecture is different from MSA, why they are different, and what
    you gain or lose when you adopt one or more architectures over the others.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解微服务如何帮助构建现代、灵活、可扩展和具有弹性的企业系统。本章将介绍MSA中的关键概念，并讨论常见的企业系统架构，每种架构如何与MSA不同，为什么它们不同，以及当你选择一种或多种架构而不是其他架构时，你将获得或失去什么。
- en: 'We will cover the following areas as we go over the chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍本章时，我们将涵盖以下领域：
- en: What MSA is and why
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSA是什么以及为什么
- en: MSA versus monolithic enterprise systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSA与单体企业系统对比
- en: Service-driven architecture, **event-driven architecture** (**EDA**), and how
    to incorporate that in MSA
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务驱动架构、**事件驱动架构**（**EDA**），以及如何在MSA中融入这些架构
- en: Challenges of deploying and operating MSA enterprise systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和运营MSA企业系统面临的挑战
- en: Why it is important to embrace **DevOps** in building MSA
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在构建MSA时采用**DevOps**很重要
- en: Why microservices? Pros and cons
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么是微服务？优势和劣势
- en: Microservices is often likened to MSA. MSA refers to the way in which a complex
    system is built from a collection of smaller applications, where each application
    is designed for a specific limited-scope function. These small applications (or
    services, or microservices) are independently developed and can be independently
    deployed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常与MSA相提并论。MSA指的是从一组较小的应用程序中构建复杂系统的方式，其中每个应用程序都是为了特定的有限范围的功能而设计的。这些小型应用程序（或服务，或微服务）是独立开发的，并且可以独立部署。
- en: Each microservice has an API interface for communicating with other microservices
    in the system. The way all these individual microservices are organized together
    forms the larger system function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有一个API接口，用于与其他系统中的微服务通信。所有这些独立的微服务组织在一起，形成了更大的系统功能。
- en: In order to understand the value of microservices and the challenges one faces
    in designing an MSA, it is imperative to understand how microservices communicate
    and interact with each other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解微服务的价值以及设计MSA时面临的挑战，了解微服务之间如何通信和交互至关重要。
- en: 'Microservices can communicate together in a linear or non-linear fashion. In
    a linear microservices pipeline, each microservice communicates with another microservice,
    processing data across the system in a sequential manner. The input is always
    passed to the first microservice, and the output is always generated by the last
    microservice in the system:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以以线性或非线性的方式相互通信。在线性微服务管道中，每个微服务与其他微服务通信，以顺序方式在整个系统中处理数据。输入始终传递给第一个微服务，输出始终由系统中的最后一个微服务生成：
- en: '![Figure 1.1: Linear microservices pipeline](img/B18934_01_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：线性微服务管道](img/B18934_01_1.jpg)'
- en: 'Figure 1.1: Linear microservices pipeline'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：线性微服务管道
- en: 'Practically, however, most existing systems are formed using a non-linear microservices
    pipeline. In a non-linear microservices pipeline, data is distributed across different
    functions in the system. You can pass the input to any function in the system,
    and the output can be generated from any function in the system. You can therefore
    have multiple pipelines with multiple inputs, serving multiple functions and producing
    multiple outputs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，然而，大多数现有系统都是使用非线性微服务管道构建的。在非线性微服务管道中，数据分布在系统中的不同功能中。你可以将输入传递给系统中的任何功能，输出也可以由系统中的任何功能生成。因此，你可以有多个具有多个输入的管道，服务于多个功能并产生多个输出：
- en: '![Figure 1.2: Non-linear microservices pipeline](img/B18934_01_2.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：非线性微服务管道](img/B18934_01_2.jpg)'
- en: 'Figure 1.2: Non-linear microservices pipeline'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：非线性微服务管道
- en: 'Consider the following diagram of a simplified order fulfillment process in
    a typical e-commerce system. Each function within the **Placing an Order** process
    represents a microservice. Once an order is placed by a customer, an API call
    is triggered to the **Add/Update Customer Information** microservice to save that
    customer’s information or update it if needed. This microservice sole responsibility
    is just that: manage customer information based on the data input it receives
    from the API caller.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下典型电子商务系统中简化的订单履行流程图。**下单**过程中的每个功能都代表一个微服务。一旦客户下单，就会触发一个API调用到**添加/更新客户信息**微服务，以保存该客户的信息或在需要时更新它。这个微服务的唯一职责就是：根据从API调用者接收到的数据输入来管理客户信息。
- en: Another API call is issued at the same time to the **Verify Payment** part of
    the process. The call will be directed to either the **Process PayPal Payment**
    or the **Process Credit Card Payment** microservice depending on the payment type
    of the API call. Notice here how the payment verification process is broken down
    into two different microservices—each is specifically designed and developed for
    a specific payment function. This enables the flexibility and portability of these
    microservices to other parts of the system or to another system if needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同时还会向流程中的**验证付款**部分发出另一个API调用。调用将根据API调用的付款类型被引导到**处理PayPal付款**或**处理信用卡付款**微服务。注意这里如何将付款验证过程分解为两个不同的微服务——每个都是针对特定的付款功能专门设计和开发的。这使得这些微服务具有灵活性和可移植性，可以在系统或另一个系统中的其他部分使用，如果需要的话。
- en: 'After payment is processed, API calls are triggered simultaneously to other
    microservices in the system to fulfill the order:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完付款后，会同时触发系统中的其他微服务的API调用以履行订单：
- en: '![Figure 1.3: A non-linear microservices pipeline example – customer order](img/B18934_01_3.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3：非线性微服务管道示例——客户订单](img/B18934_01_3.jpg)'
- en: 'Figure 1.3: A non-linear microservices pipeline example – customer order'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：非线性微服务管道示例——客户订单
- en: The order placement example shows how modular and flexible designing an MSA
    enterprise system can be. We will often use this example to show some of the advantages
    and challenges one may face when designing, deploying, and operating an MSA enterprise
    system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 订单下单示例展示了如何模块化和灵活地设计MSA企业系统。我们经常使用这个例子来展示在设计、部署和运营MSA企业系统时可能面临的某些优势和挑战。
- en: It is essential that we go over some of the advantages and disadvantages of
    building enterprise systems using MSA to help decide whether MSA is a better option
    for your organization or not.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须探讨使用MSA构建企业系统的优缺点，以帮助决定MSA是否是您组织更好的选择。
- en: Note that some of the advantages listed next could also be considered disadvantages
    in other situations (and vice versa).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下列出的某些优势在其他情况下也可能被视为劣势（反之亦然）。
- en: Advantages of microservices
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的优势
- en: There is some significant value to implementing MSA. The following are some
    of the advantages we see applicable to today’s market.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实施MSA（微服务架构）具有一定的显著价值。以下是我们认为适用于当今市场的部分优势。
- en: Autonomy
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自主性
- en: One of the biggest advantages of microservices is their autonomy—it is the keystone
    for many of the other advantages of MSA. And because of their autonomy, microservices
    have their own technology stack, which means that each system service can be developed
    with completely different tools, libraries, frameworks, or programming languages
    than any other system service, yet they integrate with each other smoothly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务最大的优点之一是它们的自主性——这是MSA（Microservices Architecture，微服务架构）其他许多优点的基石。由于它们的自主性，微服务拥有自己的技术栈，这意味着每个系统服务都可以使用与任何其他系统服务完全不同的工具、库、框架或编程语言进行开发，但它们可以顺利地相互集成。
- en: Microservices can be developed and tested independently of any other application
    within the system, which enables each microservice to have its own life cycle,
    including **quality assurance** (**QA**), change management, upgrades, updates,
    and so on, which in return greatly minimizes application dependencies.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以在系统中的任何其他应用程序之外独立开发和测试，这使得每个微服务都可以拥有自己的生命周期，包括**质量保证**（**QA**）、变更管理、升级、更新等，这反过来又极大地减少了应用程序的依赖性。
- en: Portability
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可移植性
- en: Microservices’ autonomy enables them to be portable across platforms, operating
    systems, and different systems, all independent of the coding language in which
    these services were written.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的自主性使得它们可以在不同的平台、操作系统和系统中移植，所有这些都与这些服务编写的编程语言无关。
- en: Reuse
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重用
- en: When reusing microservices, you don’t need to reinvent the wheel. Because of
    their autonomy, microservices can be reused without the need to add additional
    coding, changes, or testing. Each service can be reused as needed, which largely
    increases system flexibility and scalability, significantly reduces the development
    time, cost, and deployment time, and reduces the system’s TTM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当重用微服务时，您不需要重新发明轮子。由于它们的自主性，微服务可以在不添加额外编码、更改或测试的情况下重用。每个服务可以根据需要重用，这极大地增加了系统的灵活性和可扩展性，显著减少了开发时间、成本和部署时间，并减少了系统的TTM。
- en: Loosely coupled, highly modular, flexible, and scalable
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 松散耦合、高度模块化、灵活和可扩展
- en: Microservices form the main building blocks of an MSA enterprise system. Each
    block is loosely coupled with the other blocks in the system. Just like Lego blocks,
    the manner in which these blocks are organized together can form a complex enterprise
    MSA system building a specific business solution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是MSA企业系统的主要构建块。每个块都与系统中的其他块松散耦合。就像乐高积木一样，这些块组织在一起的方式可以形成一个复杂的、针对特定业务解决方案的企业MSA系统。
- en: The following diagram shows an example of how we can build three different systems
    with multiple microservices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了我们可以如何使用多个微服务构建三个不同的系统示例。
- en: The diagram shows nine services, and seven out of these services are organized
    in such a manner to reuse and build three different systems—system **A**, system
    **B**, and system **C**. This shows how loose coupling enables flexibility in
    MSA in such a way that you can reuse each service to build a different system
    function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了九个服务，其中七个服务以这种方式组织，以便重用和构建三个不同的系统——系统**A**、系统**B**和系统**C**。这展示了松散耦合如何使MSA（Microservices
    Architecture，微服务架构）具有灵活性，以至于你可以重用每个服务来构建不同的系统功能。
- en: 'You can build a system with minimal development added to existing microservices
    either acquired by a third party or previously developed in house. This largely
    enables rapid system development, new feature releases, very short TTM, and reliable,
    flexible, and much more stable hot updates and upgrades. All of this increases
    **business continuity** (**BC**) and makes the enterprise system much more scalable:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在现有的微服务基础上，通过添加最少量的开发工作来构建系统，这些微服务可以是第三方购买的，也可以是之前内部开发的。这极大地促进了系统的快速开发、新功能的发布、极短的TTM（Time
    To Market，上市时间），以及可靠、灵活且更加稳定的即时更新和升级。所有这些都有助于**业务连续性**（**BC**）并使企业系统具有更高的可扩展性：
- en: '![Figure 1.4: Flexibility and modularity in microservices](img/B18934_01_4.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：微服务的灵活性和模块化](img/B18934_01_4.jpg)'
- en: 'Figure 1.4: Flexibility and modularity in microservices'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：微服务的灵活性和模块化
- en: Shorter release cycle and TTM
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短暂的发布周期和TTM
- en: Because of the individual and independent services features we previously mentioned,
    the deployment of microservices becomes much easier and faster to perform. Automation
    can play a great role in reducing time-of-service testing and deployment, as we
    will discuss later in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前提到的单个和独立的服务特性，微服务的部署变得更容易、更快。自动化可以在减少服务测试和部署时间方面发挥重要作用，正如我们将在本章后面讨论的那样。
- en: Fault tolerance and fault isolation
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障容错和故障隔离
- en: Each microservice has its own separate fault domain. Failures in one microservice
    will be contained within that microservice, hence it is easier to troubleshoot
    and faster to fix and bring back the system to full operations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有自己的独立故障域。一个微服务的故障将被限制在该微服务内部，因此更容易进行故障排除，修复速度更快，并能更快地将系统恢复到完全运行状态。
- en: Consider the order fulfillment example we mentioned earlier; the system can
    still be functional if the **Message/Email Customer** microservice—for example—experiences
    any failures. And because of the nature of the failure and the small fault domain,
    it will be easy to pinpoint where that failure is and how to fix it. **Mean Time
    to Resolution** (**MTTR**) is therefore significantly reduced, and BC is greatly
    enhanced.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前提到的订单履行示例；即使**消息/电子邮件客户**微服务（例如）出现任何故障，系统仍然可以正常工作。由于故障的性质和小的故障域，将很容易确定故障的位置以及如何修复它。因此，**平均修复时间**（**MTTR**）显著降低，BC得到极大提升。
- en: Architects are sometimes able to build the system with high embedded tolerance
    to prevent these failures to begin with or have other backup microservices on
    standby to take over once a failure is detected in the primary microservice. One
    of the primary objectives of this book, as we will see later, is to be able to
    design a system with high enough intelligence to provide the desired high resilience.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师有时能够构建具有高度内嵌容错能力的系统，以防止这些故障的发生，或者在主微服务检测到故障时，有其他备用微服务可以接管。正如我们稍后将会看到的，本书的一个主要目标就是能够设计出足够智能的系统，以提供所需的高弹性。
- en: What software architects have to bear in mind, however, is that, with too many
    system components in the MSA, too many things can go wrong. Architects and developers,
    therefore, have to have solid fallback and error handling to manage the system’s
    resilience.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，软件架构师必须牢记的是，在MSA中系统组件过多时，可能出现的问题也越多。因此，架构师和开发者必须具备坚实的回退和错误处理能力，以管理系统的弹性。
- en: The communication between the different microservices, for example, can simply
    time out for whatever reason; it could be a network issue, a server issue, or
    too many API calls at the receiving microservices or at the event-handling mechanism
    developed in the system, overwhelming this system component and causing failures
    or delayed response.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不同微服务之间的通信，例如，可能因为任何原因简单地超时；这可能是一个网络问题、服务器问题，或者在接收微服务或系统中开发的事件处理机制中API调用过多，从而压倒这个系统组件并导致故障或响应延迟。
- en: There are many data flow streams and data processing points in the system that
    all need to be synchronized. A single failure, if not taken care of properly by
    the system, can create system-cascading failures, and accordingly could cause
    a failure to the entire system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中有许多数据流和数据处理的点都需要同步。如果系统没有妥善处理单个故障，可能会导致系统级联故障，并相应地可能导致整个系统的故障。
- en: How fault tolerance is designed will be a big factor in how system performance
    and reliability are impacted.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 故障容错的设计方式将大大影响系统性能和可靠性。
- en: Reliability and the Single Responsibility Principle (SRP)
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可靠性和单一责任原则（SRP）
- en: 'If you come from the programming world, you are probably familiar with the
    SRP in **object-oriented programming** (**OOP**): *A class should have one, and
    only one, reason to change*. Every object, class, or function in the system should
    have a responsibility over only that functionality of the system, and hence that
    class, once developed, should only change for the reason it was originally created
    for. This principle is one of the main drivers of increased system reliability
    and BC in MSA.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自编程世界，你可能对**面向对象编程**（**OOP**）中的SRP很熟悉：*一个类应该只有一个，且只有一个，改变的理由*。系统中的每个对象、类或函数都应该只负责系统的那个功能，因此一旦该类开发完成，它应该只因为最初创建它的原因而改变。这个原则是提高MSA中系统可靠性和BC的主要驱动力之一。
- en: At the initial phases of developing an MSA enterprise system, and during the
    phase of developing new microservices from scratch, the MSA enterprise system
    may not be fully tested or fully matured yet, and reliability may still be building
    up. When the system matures, changes to individual microservices are minimal—if
    any— and microservices’ code reliability is, therefore, higher, the operation
    is more stable, fault domains are contained, fault tolerance is high, and the
    system’s reliability thus becomes much higher than similar systems with a monolithic
    architecture. Reliability is highly contingent on how well the system is designed,
    developed, and deployed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发MSA企业系统的初期阶段，以及从头开始开发新微服务的阶段，MSA企业系统可能尚未完全测试或成熟，可靠性仍在建立中。当系统成熟时，对单个微服务的更改最小——如果有的话——因此微服务的代码可靠性更高，操作更稳定，故障域被限制，容错性高，因此系统的可靠性比具有单体架构的类似系统要高得多。可靠性高度依赖于系统的设计、开发和部署效果。
- en: Reducing system development and operational cost
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 降低系统开发和运营成本
- en: Reusing microservices largely reduces the development efforts and time needed
    to bring the system to life. The more microservices you can reuse, the lower the
    development time and cost will become.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重新使用微服务在很大程度上减少了将系统投入运行所需的开发努力和时间。您可以重新使用的微服务越多，开发时间和成本就越低。
- en: Microservices do not have to be developed from scratch; you can purchase already
    developed microservices that you may need to plug into your MSA enterprise system,
    cutting the development time significantly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务不需要从头开始开发；您可以购买已经开发好的微服务，并将其集成到您的MSA企业系统中，从而显著缩短开发时间。
- en: When these microservices are stable and mature, reliability is higher, MTTR
    is much shorter, and hence system faults are lower and BC is higher. All these
    factors can play a major role in reducing the development cost, operational cost,
    and **total cost of** **ownership** (**TCO**).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些微服务稳定成熟时，可靠性更高，平均修复时间（MTTR）更短，因此系统故障更低，业务连续性（BC）更高。所有这些因素都可以在减少开发成本、运营成本和**总拥有成本**（**TCO**）方面发挥重要作用。
- en: Automation and operational orchestration are ideal for microservices; this enables
    agile development and can also decrease operational costs significantly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化和运营编排非常适合微服务；这有助于敏捷开发，也可以显著降低运营成本。
- en: Disadvantages of microservices
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的缺点
- en: Microservices come with a set of challenges that need to be taken into consideration
    before considering an MSA in your organization. The good news is that many of
    these challenges—if not all—can effectively be addressed to have in the end a
    robust MSA enterprise system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑在您的组织中采用MSA之前，需要考虑微服务带来的一系列挑战。好消息是，许多这些挑战——如果不是全部——都可以有效地解决，最终形成一个强大的MSA企业系统。
- en: Mentioned here are some of the challenges of microservices, and we will later
    in this chapter talk about some of the methodologies that help address these challenges.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到了微服务的一些挑战，我们将在本章后面讨论一些帮助解决这些挑战的方法。
- en: Complexity
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂性
- en: MSA systems contain many components that must work together and communicate
    together to form the overall solution. The system’s microservices in most cases
    are built with different frameworks, programming languages, and data structures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: MSA系统包含许多必须协同工作并相互通信以形成整体解决方案的组件。在大多数情况下，系统的微服务是用不同的框架、编程语言和数据结构构建的。
- en: Communication between microservices has to be in perfect synchronization for
    the system to properly function. Interface calls could at times overwhelm the
    microservice itself or the system as a whole, and therefore, system architects
    and developers have to continuously look for mechanisms to efficiently handle
    interface calls and try to eliminate dependencies as much as they can.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务之间的通信必须完美同步，系统才能正常运作。接口调用有时可能会压倒微服务本身或整个系统，因此，系统架构师和开发者必须持续寻找有效处理接口调用的机制，并尽可能消除依赖。
- en: Designing the system to handle call loads, data flows, and data synchronization,
    along with the operational aspects of it, could be a very daunting process and
    creates layers of complexity that are hard to overlook.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 设计系统以处理调用负载、数据流和数据同步，以及其运营方面，可能是一个非常艰巨的过程，并创造出难以忽视的复杂层次。
- en: Complexity is one of the main trade-off factors in implementing and running
    an MSA enterprise system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性是实现和运行MSA企业系统的主要权衡因素之一。
- en: Initial cost
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始成本
- en: MSA systems usually require a large number of resources to be able to handle
    the individual processing needs of each microservice, the high level of communication
    between microservices, and the different development and staging environments
    for developing these microservices.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: MSA系统通常需要大量的资源来处理每个微服务的个体处理需求、微服务之间的高度通信，以及开发这些微服务的不同开发和预演环境。
- en: If these microservices are being developed from scratch, the initial cost of
    building an MSA system would therefore be too high. You have to account for the
    cost of the many individual development environments, the many microservices to
    develop and test, and the different teams to do all these tasks and integrate
    all these components. All this adds to the cost of the initial system development.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些微服务是从零开始开发的，那么构建MSA系统的初始成本就会过高。你必须考虑到许多个体开发环境、许多需要开发和测试的微服务，以及执行所有这些任务并整合所有这些组件的不同团队的成本。所有这些都增加了初始系统开发成本。
- en: Tight API control
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 紧密API控制
- en: Each microservice has its own API calls to be able to integrate with other microservices
    in the system. Any change in the API command reference set—such as updates in
    any API call arguments, deprecated APIs, or changes in the return values—may require
    a change in how other microservices handle the data flow from and to that updated
    microservice. This can pose a real challenge.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都有自己的API调用，以便能够与系统中的其他微服务集成。API命令参考集的任何变化——例如任何API调用参数的更新、废弃的API或返回值的变化——可能需要更改其他微服务处理从和到更新微服务的数据流的方式。这可能会带来真正的挑战。
- en: Developers have to either maintain backward compatibility (which can be a big
    constraint at times) or change the API calls’ code of every other component in
    the system that interacts with the updated microservice.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者必须维护向后兼容性（有时这可能是一个很大的限制）或者更改系统中与更新后的微服务交互的每个其他组件的API调用代码。
- en: System architects and developers have therefore to maintain very tight control
    over API changes in order to maintain system stability.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系统架构师和开发者必须对API更改保持非常严格的控制，以维护系统稳定性。
- en: Data structure control and consistency
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据结构控制和一致性
- en: The drawback of having independent applications within the enterprise system
    is that each microservice will have to maintain its own data structure, which
    creates a challenge in maintaining data consistency across your system.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 企业系统中拥有独立应用程序的缺点是，每个微服务都必须维护自己的数据结构，这给在整个系统中维护数据一致性带来了挑战。
- en: If we take the earlier example of customer order fulfillment, the **Add/Update
    Customer Information** microservice should have its own database totally independent
    from any other database in the system. Similarly, the **Update Item Inventory**
    microservice should be the microservice responsible for the item information database,
    the **Update Orders Database** microservice should have the orders database, and
    so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以客户订单履行为例，**添加/更新客户信息**微服务应该有自己的数据库，完全独立于系统中的任何其他数据库。同样，**更新商品库存**微服务应该是负责商品信息数据库的微服务，**更新订单数据库**微服务应该拥有订单数据库，等等。
- en: The challenge now is that the shipping database will need to be in sync with
    the customer information database, and the orders database will have to contain
    some of the customer information. Also, the **Message/Email Customer** microservice
    has to have a way to access customer information (or receive customer information
    through API calls), and so on. In a larger system, the process of keeping data
    consistent across the different microservices becomes problematic. The more microservices
    we have, the more complex the data synchronization becomes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的挑战是，发货数据库需要与客户信息数据库保持同步，订单数据库必须包含一些客户信息。此外，**消息/电子邮件客户**微服务必须有一种方式来访问客户信息（或通过API调用接收客户信息），等等。在一个更大的系统中，保持不同微服务之间数据一致性的过程变得复杂。微服务越多，数据同步就越复杂。
- en: Once again, designing and developing a system with all that work in mind becomes
    another burden on the system architects and developers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在设计和发展一个系统时，考虑到所有这些工作，又给系统架构师和开发者带来了额外的负担。
- en: Performance
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能
- en: As we mentioned earlier, microservices have to communicate with each other to
    perform the entire system function. This communication, data flows, error handling,
    and fault-tolerance design—among many other factors—are susceptible to network
    latency, network congestions, network errors, application data processing time,
    database processing time, and data synchronization issues. All these factors greatly
    impact system performance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，微服务必须相互通信以执行整个系统功能。这种通信、数据流、错误处理和容错设计——以及其他许多因素——容易受到网络延迟、网络拥塞、网络错误、应用程序数据处理时间、数据库处理时间和数据同步问题的影响。所有这些因素都极大地影响了系统性能。
- en: Performance is another major trade-off factor in adopting and running an MSA
    enterprise system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是采用和运行MSA企业系统时的另一个主要权衡因素。
- en: Security
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性
- en: Because of microservices’ autonomy and their loose coupling, a high number of
    data exchanges between the different services is necessary for the MSA to function.
    This data flow, data storage within each microservice, data processing, the API
    call itself, and transaction logging all significantly increase the system attack
    surface and develop considerable security concerns.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务的自主性和它们松散的耦合，MSA要正常工作，不同服务之间必须进行大量的数据交换。这种数据流、每个微服务内的数据存储、数据处理、API调用本身以及事务日志都显著增加了系统的攻击面，并引发了相当大的安全担忧。
- en: Organizational culture
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组织文化
- en: 'Each microservice in the MSA has its own development cycle and therefore has
    its silo of architects, developers, testers, and the entire development and release
    cycle teams, all to maintain the main objective of microservices: their autonomy.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: MSA中的每个微服务都有自己的开发周期，因此有自己的架构师、开发者、测试员以及整个开发和发布周期团队，所有这些都是为了维护微服务的主要目标：它们的自主性。
- en: MSA enterprise systems are built from a large number of microservices and mechanisms
    to manage the interaction between the different system components. Developers
    have to therefore have system operational knowledge, and the operational teams
    need to have development knowledge.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: MSA企业系统是由大量微服务和用于管理不同系统组件之间交互的机制构建的。因此，开发者必须具备系统运营知识，而运营团队则需要具备开发知识。
- en: Testing such complex distributed environments that one will have in the MSA
    system becomes a very daunting process that needs a different set of expertise.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 测试MSA系统中将遇到的如此复杂的分布式环境，变成了一项非常艰巨的过程，需要一套不同的专业知识。
- en: The traditional organizational structure of one big development team solely
    focused on development, one QA team only doing basic testing, and so on is no
    longer sufficient for the way MSA is structured and operated.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的组织结构，如一个专注于开发的大团队，一个仅进行基本测试的QA团队等，对于MSA的结构和运营方式来说已经不再足够。
- en: Agile development and DevOps methodologies are very well suited for microservices
    development. You need agile processes to help maintain the fast development and
    release cycles MSA promises to deliver. You need DevOps teams who are very familiar
    with the end-to-end process of designing the application itself and how it fits
    in the big picture, testing the application, testing how it functions within the
    entire system, the release cycle, and how to monitor the application post release.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发和DevOps方法非常适合微服务开发。你需要敏捷流程来帮助维护MSA承诺的快速开发和发布周期。你需要DevOps团队，他们非常熟悉设计应用程序本身及其在大图景中的位置，测试应用程序，测试其在整个系统中的功能，发布周期以及发布后如何监控应用程序。
- en: All this requires a cultural shift and significant organizational transformation
    that can enable DevOps and agile development.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都要求文化转变和重大的组织转型，以实现DevOps和敏捷开发。
- en: Important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We rarely see a failure in MSA adoption because of technical limitations; rather,
    failure in adopting MSA is almost always due to a failure to shift the organization’s
    culture toward a true DevOps and agile culture.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少看到由于技术限制而导致MSA采用失败的情况；相反，MSA采用失败几乎总是由于未能将组织的文化转向真正的DevOps和敏捷文化。
- en: The benefits outweigh the detriments
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利益大于弊端
- en: 'The main questions you need to answer now are: Is building an MSA worth it?
    Can we make it happen given the current organizational culture? How long will
    it take the organization to transform and be ready for MSA? Do we have the luxury
    of waiting? Can we do both the organizational transformation and the building
    of the MSA enterprise system at the same time? Do we have the resources and the
    caliber necessary for the new organizational structure? Is cost an issue, and
    do I have the budget to cover that?'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在需要回答的主要问题是：构建MSA是否值得？在当前的组织文化下，我们能否实现它？组织需要多长时间才能转型并准备好采用MSA？我们是否有等待的奢侈？我们能否同时进行组织转型和MSA企业系统的构建？我们是否有必要的新组织结构所需资源和能力？成本是否是一个问题，我是否有足够的预算来覆盖这些费用？
- en: Well, first of all, if you are planning to build a large enterprise system,
    and you have the budget and necessary resources for starting this project, building
    the system as MSA is definitely worth it. All initial costs endured and time spent
    will eventually be offset by the long-term cost and time-saving benefits of having
    an MSA system.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你计划构建一个大型企业系统，并且你有启动这个项目的预算和必要的资源，那么以MSA的方式构建系统无疑是值得的。所有初始成本和时间投入最终都将由拥有MSA系统带来的长期成本和时间节省效益所抵消。
- en: Nevertheless, you are still the one to best address all these previous questions.
    There are overwhelming and compelling advantages to adopting MSA, but as we have
    seen, this is not a simple undertaking; so, whether an organization is willing
    to walk that path or not is something it—and only it—can answer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你仍然是最好回答所有这些先前问题的人。采用MSA（微服务架构）具有压倒性和令人信服的优势，但我们已经看到，这并不是一项简单的任务；因此，一个组织是否愿意走这条路，只有它自己才能回答。
- en: Now we know what the advantages of deploying an MSA are, and the challenges
    that come with MSA adoption, we will now go over different enterprise architecture
    styles, what they are, and the differences between each other.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了部署MSA的优势以及MSA采用带来的挑战，我们将现在讨论不同的企业架构风格，它们是什么，以及它们之间的区别。
- en: Loosely versus tightly coupled monolithic systems
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合与紧密耦合的单体系统
- en: Traditional applications back in the day were mostly built using a monolithic
    architecture, in which the entire application was one big code base. All system
    components and functions were tightly coupled together to deliver the business
    solution.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的传统应用程序大多使用单体架构构建，其中整个应用程序是一个庞大的代码库。所有系统组件和功能都紧密耦合在一起，以提供业务解决方案。
- en: As shown in the following diagram, system functions are all part of the same
    code, tightly coupled with centralized governance. Each system function has to
    be developed within the same framework of the application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，系统功能都是同一代码的一部分，与集中式治理紧密耦合。每个系统功能都必须在应用程序的同一框架内开发。
- en: 'In an MSA system, however, each function preserves its own anonymity—that is,
    loosely coupled with decentralized governance, giving each team the ability to
    work with its own preferred technology stack, with whichever tools, framework,
    and programming language it desires:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在MSA系统中，每个功能都保持了自己的匿名性——即与去中心化治理松散耦合，赋予每个团队使用其首选技术栈、工具、框架和编程语言的能力：
- en: '![Figure 1.5: Monolithic versus microservices systems](img/B18934_01_5.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5：单体架构与微服务系统对比](img/B18934_01_5.jpg)'
- en: 'Figure 1.5: Monolithic versus microservices systems'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：单体架构与微服务系统对比
- en: All functions in the monolithic architecture application are wrapped into the
    application itself. In the MSA, these functions are developed, packaged, and deployed
    separately. Therefore, we can run these services in multiple locations’ on-premises
    infrastructure, in the public cloud, or across both on-premises and the cloud
    in a hybrid-cloud fashion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构的应用程序中，所有功能都被封装在应用程序本身中。在MSA中，这些功能是分别开发、打包和部署的。因此，我们可以在多个地点的本地基础设施、公共云或混合云模式下在本地和云之间运行这些服务。
- en: In monolithic systems, and because of the tight coupling, synchronizing the
    different system function changes is a development and operational nightmare.
    If one application (for whatever reason) becomes unstable, it could cause a failure
    to the entire system, and bringing the system back to a stable point becomes a
    real pain.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体系统中，由于紧密耦合，同步不同的系统功能变化是开发和运营的噩梦。如果某个应用程序（无论什么原因）变得不稳定，它可能会使整个系统失败，而将系统恢复到稳定状态则变得非常痛苦。
- en: In the case of microservices, however, since each of these microservices is
    loosely coupled, changes and troubleshooting are limited to that particular microservice,
    as long as the microservice interface does not change.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在微服务的情况下，由于每个微服务都是松散耦合的，更改和故障排除仅限于特定的微服务，只要微服务接口没有改变。
- en: One large piece of code, in the case of monolithic architecture, is very hard
    to manage and maintain. It is also hard to understand, especially in large organizations
    where multiple developers are working together.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构的情况下，一大块代码很难管理和维护。它也难以理解，尤其是在大型组织中，多个开发者共同工作。
- en: In many cases such as employee turnover, for example, a developer may need to
    troubleshoot someone else’s code, and when the application is written in a single
    big piece of code, things tend to be complicated, hard to trace and understand,
    and hard to reverse engineer and fix. Code maintenance becomes a serious problem,
    while in the microservices case, this humongous line of code is broken into smaller
    chunks of code that are easier to read, understand, troubleshoot, and fix, totally
    independent of the other components of the system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，例如员工流动，例如，开发者可能需要调试他人的代码，当应用程序是用一大块代码编写时，事情往往变得复杂，难以追踪和理解，也难以逆向工程和修复。代码维护成为一个严重的问题，而在微服务的情况下，这庞大的代码行被分解成更小的代码块，更容易阅读、理解、调试和修复，完全独立于系统的其他组件。
- en: When code changes are needed in monolithic architecture, a single change to
    part of the code may need changes to many other parts of the application, and
    accordingly, change updates will likely require a rewrite and a recompile of the
    entire application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当单体架构需要代码更改时，对代码部分的单个更改可能需要更改应用程序的许多其他部分，因此，更改更新可能需要整个应用程序的重写和重新编译。
- en: We can also reuse and package different applications together in a workflow
    to form a specific service, as shown previously in *Figure 1**.4*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将不同的应用程序一起打包到工作流程中，形成一个特定的服务，如之前在*图1*中所示。4。
- en: It is just common sense to break down a complex application into multiple modules
    or microservices, each performing a specific function in the entire ecosystem
    for better scalability, higher portability, and more efficient development and
    operations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将复杂的应用程序分解成多个模块或微服务，每个在整个生态系统中执行特定功能，以实现更好的可扩展性、更高的可移植性和更高效的开发和运营，这是常识。
- en: For small, simple, and short-lived systems, monolithic applications may be a
    better fit for your organization, easier to design and deploy, cheaper to develop,
    and faster to release. As the business needs grow, MSA becomes a better long-term
    approach.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型、简单和短期存在的系统，单体应用程序可能更适合您的组织，更容易设计和部署，开发成本更低，发布速度更快。随着业务需求的增长，MSA成为一种更好的长期方法。
- en: Since monolithic systems are tightly coupled, there is no need for API communication
    between the different system functions; this significantly decreases the security
    surface of your system, lowering system security risks and increasing the system’s
    overall performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单体系统是紧密耦合的，不同系统功能之间不需要API通信；这显著降低了系统的安全面，降低了系统安全风险，并提高了系统的整体性能。
- en: Think of the deployment difference between both monolithic and MSA as the difference
    between an economy car and a Boeing 787\. The car is a better, cheaper, and faster
    tool for traveling between two cities 50 miles apart, with no need for the security
    checks you experience in airports before boarding your flight. As the distance
    increases, however, driving the car becomes more hassle. At 5,000 miles, the Boeing
    787 is likely to become a better, cheaper, and faster way to get to your destination,
    and you will likely be willing to put up with the hassle of security checks you
    have to undergo to be able to board your flight.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将单体和MSA之间的部署差异想象成经济型汽车和波音787之间的差异。汽车是更好的、更便宜、更快的工具，用于在相距50英里的两个城市之间旅行，无需在登机前在机场经历的安全检查。然而，随着距离的增加，开车变得更为麻烦。在5000英里时，波音787可能成为到达目的地的更好、更便宜、更快的途径，你可能会愿意忍受登机前必须经历的安全检查的麻烦。
- en: 'The following is a comparison summary between both monolithic and microservices
    applications:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对单体和微服务应用程序的比较总结：
- en: '|  | **Monolithic** | **MSA** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  | **单体** | **MSA** |'
- en: '| --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Architecture | Highly autonomous. System functions are split into independent
    loosely coupled chunks of smaller code. | No autonomy. System functions are all
    tightly coupled into one big piece of code. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 架构 | 高度自主。系统功能被分割成独立松散耦合的小代码块。 | 无自主性。系统功能全部紧密耦合成一个大的代码块。 |'
- en: '| Portability | Highly portable | Very limited portability |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 可移植性 | 高度可移植 | 可移植性非常有限 |'
- en: '| Reuse | Highly reusable | Very limited ability to reuse code |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 可复用性 | 高度可复用 | 复用代码的能力非常有限 |'
- en: '| Modularity and Scalability | Highly modular and scalable | Limited modularity
    and hard to scale |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 模块化和可扩展性 | 高度模块化和可扩展 | 模块化有限，难以扩展 |'
- en: '| Initial TTM | Highly dependent on the readiness of individual system services.
    The more code reuses, the shorter the TTM is.If the system microservices are being
    designed and developed from scratch, TTM is usually longer for monolithic architecture.
    | Long TTM, especially in large systems. Shorter TTM in small and simple systems.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 初始TTM | 高度依赖于单个系统服务的准备情况。代码复用越多，TTM越短。如果系统微服务是从零开始设计和开发的，那么对于单体架构，TTM通常会更长。
    | 长期TTM，尤其是在大型系统中。小型和简单系统中的TTM较短。 |'
- en: '| Release Cycle | Very short release cycle, super-fast to deploy changes and
    patch updates | Long and usually very time-consuming release cycles and patch
    updates |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 发布周期 | 非常短的发布周期，部署更改和补丁更新非常快 | 长期且通常非常耗时的发布周期和补丁更新 |'
- en: '| Initial Cost | Usually high. Depends on the system size.The initial cost
    is offset by operational cost savings. | Usually low. The initial size becomes
    higher in large enterprise systems. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 初始成本 | 通常较高。取决于系统大小。初始成本通过运营成本节省来抵消。 | 通常较低。在大型企业系统中，初始规模会更高。 |'
- en: '| Operational Cost | Low. Easier to maintain and operate. | High. Hard to maintain
    and operate. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 运营成本 | 低。易于维护和操作。 | 高。难以维护和操作。 |'
- en: '| Complexity | High | Low |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 复杂性 | 高 | 低 |'
- en: '| API Control | High | Low |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| API控制 | 高 | 低 |'
- en: '| Data Structure Consistency | Decentralized databases, hence data consistency
    is harder to maintain | A centralized database, hence easier to maintain data
    consistency across the system |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 数据结构一致性 | 去中心化数据库，因此数据一致性更难维护 | 集中式数据库，因此更容易在整个系统中维护数据一致性 |'
- en: '| Performance | Usually lower | Usually higher |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 通常较低 | 通常较高 |'
- en: '| Security | Many security concerns | Lower security concerns |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 存在许多安全担忧 | 安全担忧较低 |'
- en: '| Organizational Adoption | Hard to adopt depending on the organizational structure.
    Requires adoption of agile development and DevOps. Organizational transformation
    may be required and may take a long time to achieve. | Easy to adopt. Minimal
    organizational transformation needed—if any. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 组织采纳 | 采纳难度取决于组织结构。需要采纳敏捷开发和DevOps。可能需要进行组织转型，并且可能需要很长时间才能实现。 | 采纳容易。需要的组织转型最小——如果有的话。
    |'
- en: '| Fault Tolerance | Usually higher | Usually lower |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 容错性 | 通常较高 | 通常较低 |'
- en: 'Table 1.1: Summary of the differences between monolithic and MSA systems'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1：单体系统和MSA系统之间差异的总结
- en: We covered in this section the different aspects of a monolithic system; next,
    we go over service-driven architecture and EDA, and how to combine these architectural
    styles within MSA to address some of the MSA challenges discussed earlier.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了单体系统的不同方面；接下来，我们将介绍服务驱动架构和EDA，以及如何在MSA中结合这些架构风格来解决之前讨论的一些MSA挑战。
- en: Service-driven, EDA, and MSA hybrid model architecture
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务驱动、EDA和MSA混合模型架构
- en: People often get mixed up between MSA and **service-driven architecture** (aka
    **service-oriented architecture** or **SOA**). Both types of architecture try
    to break down the monolithic architecture system into smaller services. However,
    in MSA, the system services decomposition is extremely granular, breaking down
    the system into very fine specialized independent services. In the SOA, the system
    services decomposition is instead coarse-grained to the domain level.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常混淆微服务架构（MSA）和**服务驱动架构**（又称**面向服务架构**或**SOA**）。这两种架构类型都试图将单体架构系统分解成更小的服务。然而，在MSA中，系统服务的分解非常细粒度，将系统分解成非常精细的专业独立服务。在SOA中，系统服务的分解则是以领域级别为粗粒度。
- en: 'All domains, as shown in the following diagram, share the same centralized
    database and may actually share other resources in between, creating some level
    of coupling and system dependencies that are non-existent in MSA. Data storage
    is a key difference between both architectural styles:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有领域，如以下图所示，共享相同的集中式数据库，并且实际上可能共享其他资源，从而在MSA中不存在的某些层面上产生耦合和系统依赖。数据存储是这两种架构风格的关键区别：
- en: '![Figure 1.6: SOA architecture split into functional domains](img/B18934_01_6.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6：SOA架构拆分为功能域](img/B18934_01_6.jpg)'
- en: 'Figure 1.6: SOA architecture split into functional domains'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：SOA架构拆分为功能域
- en: In the case of the simplified MSA customer ordering example discussed earlier,
    there are eight different microservices. A similar implementation in SOA is likely
    to have all these microservices built together and tightly coupled in a single
    domain. Other domains within the system could be Cart Handling, Catalog Browsing
    and Suggestions, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面讨论的简化MSA客户订单示例中，有八个不同的微服务。在SOA中类似的实现可能会将这些微服务构建在一起，并在单个域中紧密耦合。系统中的其他域可能是购物车处理、目录浏览和推荐等。
- en: SOA has a holistic enterprise view, while in a microservice, development looks
    into the function itself in total isolation of the enterprise system in which
    the microservice is intended to be used.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: SOA具有整体的企业视角，而在微服务中，开发关注的是功能本身，完全独立于微服务打算使用的企业系统。
- en: EDA is another architectural style that is largely adopted. While MSA’s main
    focus is on function and SOA emphasizes the domain, EDA instead focuses on system
    events.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: EDA（事件驱动架构）是另一种广泛采用的架构风格。虽然MSA（微服务架构）主要关注功能，而SOA（面向服务架构）强调领域，EDA则专注于系统事件。
- en: EDA is usually complemented by another main system architecture, such as SOA
    or MSA. In EDA, services are decoupled at a granularity level determined by its
    main architecture (MSA or SOA) and then communicate with each other through event-based
    transactions. In our order placement example, these events could be **Order Created**,
    **Order Canceled**, **Order Shipped**, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: EDA通常与另一种主要系统架构（如SOA或MSA）相辅相成。在EDA中，服务在其主要架构（MSA或SOA）确定的粒度级别上解耦，然后通过基于事件的事务相互通信。在我们的订单处理示例中，这些事件可能是**订单创建**、**订单取消**、**订单发货**等等。
- en: In order to maintain event synchronization and data consistency across the enterprise
    system, these events must be handled by a message broker. The message broker’s
    sole responsibility is to guarantee the delivery of these events to different
    services across the system. Therefore, it has to be highly available, highly responsive,
    fault-tolerant, and scalable and must be able to function under heavy load.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在整个企业系统中维护事件同步和数据一致性，这些事件必须由消息代理处理。消息代理的唯一责任是确保将这些事件传递到系统中的不同服务。因此，它必须高度可用、高度响应、容错和可扩展，并且必须能够在高负载下运行。
- en: When EDA is adopted within the MSA enterprise system, the message broker in
    that case will be handling events, API calls, and API calls’ responses.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当在MSA企业系统中采用EDA时，该情况下的消息代理将处理事件、API调用以及API调用的响应。
- en: The message broker has to be able to queue messages when a specific service
    is down or under heavy load and deliver that message whenever that service becomes
    available.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当特定服务宕机或负载过重时，消息代理必须能够排队消息，并在该服务可用时传递该消息。
- en: ACID transactions
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACID事务
- en: 'Any system with some form of data storage always needs to ensure the integrity,
    reliability, and consistency of that data. In MSA, systems store and consume data
    across the workflow transactions, and for individual services to ensure integrity
    and reliability for the MSA system as a whole, data stored within the entire system
    have to comply with a certain set of principles called **Atomicity, Consistency,
    Isolation, and** **Durability** (**ACID**):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有某种形式数据存储的系统都必须确保数据的完整性、可靠性和一致性。在MSA中，系统在工作流事务中存储和消费数据，并且为了确保整个MSA系统的完整性和可靠性，系统内部存储的数据必须符合称为**原子性、一致性、隔离性和持久性**（**ACID**）的某些原则：
- en: '**Atomicity**: All-or-nothing transactions. Either all transactions in the
    workflow are successfully executed and committed or they all fail and are canceled.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：全部或无操作事务。要么工作流中的所有事务都成功执行并提交，要么它们全部失败并取消。'
- en: '**Consistency**: Any data change in one service has to maintain its integrity
    across the system or be canceled.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：任何服务中的数据更改都必须在整个系统中保持其完整性，或者被取消。'
- en: '**Isolation**: Each data transaction has its own sovereignty and should not
    impact or be impacted by other transactions in the system.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：每个数据事务都有其主权，不应影响或被系统中的其他事务影响。'
- en: '**Durability**: Committed transactions are forever permanent, even in the case
    of a system failure.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耐用性**：已提交的事务永久不变，即使在系统故障的情况下也是如此。'
- en: Saga patterns
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Saga模式
- en: One of the main challenges in MSA is distributed transactions, where data flow
    spans across multiple microservices in the system. This flow of data across the
    services creates a risk of violating the microservice autonomy. Data has to be
    managed within the microservice itself in total isolation from any other service
    in the system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'MSA中的一个主要挑战是分布式事务，其中数据流跨越了系统中的多个微服务。这种跨服务的数据流会带来违反微服务自治的风险。数据必须在微服务本身内进行管理，完全隔离于系统中的任何其他服务。 '
- en: If you look at our order placement example again, you find that customer data
    (or part of it) spans across the different microservices in the example, which
    could create undesired dependencies in the MSA, and should be avoided at all costs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看我们的订单放置示例，你会发现客户数据（或其一部分）跨越了示例中的不同微服务，这可能会在MSA中创建不希望的依赖关系，并且应该不惜一切代价避免。
- en: What if, for whatever reason, the **Update Item Inventory** service fails, or
    it just happens that the service reports back that the item is no longer available?
    The system in that case will need to roll back and update all individual services’
    databases to ensure ACID transactions for the workflow.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为任何原因，**更新项目库存**服务失败，或者服务恰好报告说该商品不再可用怎么办？在这种情况下，系统需要回滚并更新所有单个服务的数据库，以确保工作流程的ACID事务。
- en: The **saga pattern** manages the entire workflow of transactions. It sees all
    sets of transactions performed in a specific process as a workflow and ensures
    that all these transactions in that workflow are either successfully executed
    and committed or rolled back in case the workflow breaks for whatever reason,
    to maintain data consistency across the system.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**saga模式**管理事务的整个工作流程。它将特定过程中执行的所有事务集合视为工作流程，并确保在该工作流程中的所有这些事务要么成功执行并提交，要么在因任何原因导致工作流程中断的情况下回滚，以维护系统中的数据一致性。'
- en: A saga participant service would have a **local transaction** part of that workflow.
    A local transaction is a transaction performed within the service itself and produces
    an event upon execution to trigger the next local transaction in the workflow.
    These transactions must comply with ACID principles. If one of these local transactions
    fails, the saga service initiates a set of **compensating transactions** to roll
    back any changes caused by the already executed local transactions in the workflow.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: saga参与者服务将包含工作流程中的**本地事务**部分。本地事务是在服务内部执行的事务，并在执行时产生一个事件来触发工作流程中的下一个本地事务。这些事务必须遵守ACID原则。如果这些本地事务中的任何一个失败，saga服务将启动一系列**补偿事务**来回滚工作流程中已执行的本地事务引起的任何更改。
- en: 'Each local transaction should have corresponding compensating transactions
    to be executed to roll back actions caused by the local transaction, as shown
    in the following diagram:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个本地事务都应该有相应的补偿事务来执行，以回滚由本地事务引起的操作，如下面的图所示：
- en: '![Figure 1.7: Processing of local and compensating transactions](img/B18934_01_7.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7：本地和补偿事务的处理](img/B18934_01_7.jpg)'
- en: 'Figure 1.7: Processing of local and compensating transactions'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：本地和补偿事务的处理
- en: 'There are two ways to coordinate transactions’ workflow in a saga service:
    **choreography** and **orchestration**.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在saga服务中协调事务工作流程有两种方式：**编排**和**编排**。
- en: 'In choreography, saga participant services exchange events without the need
    for a centralized manager. As in EDA, a message broker is needed to handle event
    exchanges between services, as illustrated in the following diagram:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在编排中，saga参与者服务无需集中管理器即可交换事件。就像在EDA中一样，需要一个消息代理来处理服务之间的事件交换，如下面的图所示：
- en: '![Figure 1.8: Choreography in a saga service](img/B18934_01_8.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8：saga服务中的编排](img/B18934_01_8.jpg)'
- en: 'Figure 1.8: Choreography in a saga service'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：saga服务中的编排
- en: 'In orchestration, a saga pattern-centralized controller is introduced: an **orchestrator**.
    The workflow is configured in the orchestrator and the orchestrator sends requests
    to each saga participant service on which local transaction it needs to execute,
    receives events from saga participant services, checks the status of each request,
    and handles any local transaction failures by executing the necessary compensating
    transactions, as illustrated in the following diagram:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编排中，引入了一个叙事模式集中控制器：一个**编排器**。工作流程在编排器中配置，编排器向每个叙事参与者服务发送请求，确定需要在哪个服务上执行本地事务，接收来自叙事参与者服务的事件，检查每个请求的状态，并通过执行必要的补偿事务来处理任何本地事务失败，如图下所示：
- en: '![Figure 1.9: Orchestration in a saga service](img/B18934_01_9.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9：叙事服务中的编排](img/B18934_01_9.jpg)'
- en: 'Figure 1.9: Orchestration in a saga service'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：在叙事服务中的编排
- en: Orchestrators become the brain of the enterprise system and the single source
    for all steps that need to be taken to execute a specific system workflow. The
    orchestrator, therefore, must be implemented in a way to be highly resilient and
    highly available.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编排器成为企业系统的“大脑”，是执行特定系统工作流程所需采取的所有步骤的唯一来源。因此，编排器必须以高度弹性和高度可用性的方式实现。
- en: Command Query Responsibility Segregation (CQRS)
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）
- en: It is very common in traditional systems, and especially in monolithic applications,
    to have a common relational database deployed in the backend and accessed by a
    frontend application. That centralized database is accessed with **Create-Read-Update-Delete**
    (**CRUD**) operations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统系统中，尤其是在单体应用中，通常会在后端部署一个公共的关系型数据库，并由前端应用程序访问。这个集中式数据库通过**创建-读取-更新-删除**（**CRUD**）操作进行访问。
- en: In modern architecture, especially as the application scales, this traditional
    implementation poses a problem. With multiple CRUD requests being processed on
    the database, table joins are created with a high likelihood of database locking
    happening. Table locks introduce latency and resource competition, and greatly
    impact overall system performance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代架构中，尤其是在应用规模扩大的情况下，这种传统实现会带来问题。由于在数据库上处理多个CRUD请求，表连接创建的可能性很高，从而导致数据库锁定。表锁定引入了延迟和资源竞争，并极大地影响了整体系统性能。
- en: Complex queries have a large number of table joins and can lock the tables,
    preventing any write or update operations on them till the query is done and the
    database unlocks the tables. Database read operations are typically multiple times
    more than write operations, and in heavy transaction systems, the problem can
    multiply.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂查询有大量的表连接，可能会锁定表，直到查询完成并且数据库解锁表，阻止对它们的任何写入或更新操作。数据库读取操作通常比写入操作多出数倍，在重交易系统中，问题可能会成倍增加。
- en: 'You can see a comparison of CRUD and CQRS patterns here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到CRUD和CQRS模式的对比：
- en: '![](img/B18934_01_10.jpg)![](img/B18934_01_10b.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9：叙事服务中的编排](img/B18934_01_10.jpg)![](img/B18934_01_10b.jpg)'
- en: 'Figure 1.10: CRUD versus CQRS patterns'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10：CRUD与CQRS模式对比
- en: With CQRS, you simply separate one object into two objects. So, rather than
    doing both commands and queries on one object, we separate that object into two
    objects—one for the command, and one for the query. A command is an operation
    that changes the state of the object, while a query does not change the state
    of the system but instead returns a result.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CQRS，你只需简单地将一个对象分成两个对象。因此，而不是在一个对象上同时进行命令和查询，我们将该对象分成两个对象——一个用于命令，一个用于查询。命令是一种改变对象状态的操作，而查询不会改变系统的状态，而是返回一个结果。
- en: In our case, the object here is the system database, and that database separation
    could be either physical or logical. Although it is a best practice to have two
    physical databases for CQRS, you can still use the same physical database for
    both commands and queries. You can, for example, split the database into two logical
    views—one for commands and one for queries.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这里的对象是系统数据库，而这个数据库的分离可以是物理的也可以是逻辑的。尽管对于CQRS来说，拥有两个物理数据库是一种最佳实践，但你仍然可以使用相同的物理数据库来处理命令和查询。例如，你可以将数据库分成两个逻辑视图——一个用于命令，一个用于查询。
- en: A replica is created from the master database when two physical databases are
    used in CQRS. The replica will, of course, need to be synchronized with the master
    for data consistency. The synchronization can be accomplished by implementing
    EDA where a message broker is handling all system events. The replica subscribes
    to the message broker, and whenever the master database publishes an event to
    the message broker, the replica database will synchronize that specific change.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在CQRS中使用两个物理数据库时，会从主数据库创建一个副本。当然，副本需要与主数据库同步以保持数据一致性。同步可以通过实现EDA（事件驱动架构）来完成，其中消息代理处理所有系统事件。副本订阅消息代理，每当主数据库向消息代理发布事件时，副本数据库将同步该特定更改。
- en: There will be a delay between the exact time at which the master database was
    actually changed and when that change is reflected in the replica; the two databases
    are not 100% consistent during that period of time but will be eventually consistent.
    In CQRS, this synchronization is called eventual consistency synchronization.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 主数据库实际更改的确切时间和该更改反映在副本中的时间之间会有延迟；在这段时间内，两个数据库不是100%一致的，但最终会一致。在CQRS中，这种同步称为最终一致性同步。
- en: When applying CQRS design in MSA, database processing latency is greatly reduced,
    and hence communication between individual services’ performance is greatly enhanced,
    resulting in an overall system-enhanced performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSA中应用CQRS设计时，数据库处理延迟大大降低，因此各个服务之间的通信性能得到显著提升，从而提高了整体系统的性能。
- en: The database used can be of any type, depending on the business case of that
    particular service in the MSA. It may very well be a **relational database** (**RDB**),
    document database, graph database, and so on. A NoSQL database could also be an
    excellent choice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSA中使用的数据库可以是任何类型，具体取决于该特定服务在MSA中的业务案例。它可能非常可能是**关系数据库**（**RDB**）、文档数据库、图数据库等等。NoSQL数据库也是一个很好的选择。
- en: We discussed previously the MSA from a design and architecture perspective.
    Operating the MSA system is another aspect that the entire organization must consider
    for a successful business delivery process. In the next section, we discuss DevOps,
    how it fits into the MSA life cycle, and why it is important for a successful
    MSA adoption and operation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经从设计和架构的角度讨论了MSA。运营MSA系统是整个组织在成功交付业务流程时必须考虑的另一个方面。在下一节中，我们将讨论DevOps，它如何融入MSA生命周期，以及为什么它对于成功采用和运营MSA至关重要。
- en: DevOps in MSA
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MSA中的DevOps
- en: DevOps revolves around a set of operational guidelines in the software development
    and release cycles. The traditional development engineer is no longer living in
    their confined environment where all the focus is to convert functional specifications
    into code; rather, they should have an end-to-end awareness of the application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps围绕软件开发和发布周期中的一系列操作指南。传统的开发工程师不再生活在他们封闭的环境中，所有焦点都是将功能规格转换为代码；相反，他们应该对应用程序有端到端的认识。
- en: A DevOps engineer would oversee, understand, and be involved in the entire pipeline
    from the moment the entire application is planned out, converting business functions
    into code, building the application, testing it, releasing it, monitoring its
    operations, and coming back with the feedback necessary for enhancements and updates.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps工程师将负责监督、理解并参与整个管道，从整个应用程序计划开始，将业务功能转换为代码，构建应用程序，测试它，发布它，监控其操作，并返回必要的反馈以进行增强和更新。
- en: 'That does not necessarily mean that a DevOps engineer would be responsible
    for all development and operational task details. Individual responsibilities
    within the application team may vary in a way to guarantee a smooth **continuous
    integration and continuous deployment** (**CI/CD**) pipeline of the application:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定意味着DevOps工程师将负责所有开发和运营任务细节。应用程序团队中的个人责任可能会有所不同，以确保应用程序的**持续集成和持续部署**（**CI/CD**）管道的顺畅：
- en: '![Figure 1.11: DevOps CI/CD pipeline](img/B18934_01_11.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11：DevOps CI/CD管道](img/B18934_01_11.jpg)'
- en: 'Figure 1.11: DevOps CI/CD pipeline'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：DevOps CI/CD管道
- en: One of the main objectives of DevOps is to speed up the CI/CD pipeline; that’s
    why there is a lot of emphasis on automation in DevOps. Automation is essential
    to efficiently perform the pipeline.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps的主要目标之一是加快CI/CD管道的速度；这就是为什么在DevOps中非常重视自动化。自动化对于高效执行管道是必不可少的。
- en: Automation can help at every step of the way. In DevOps, many test cases that
    are part of your QA plan are automated, which significantly speeds up the QA process.
    The release management and monitoring of your application are also automated to
    provide high visibility, continuous learning, and quick fixes whenever needed.
    All of this will help organizations improve productivity, predictability, and
    scalability.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化可以在每个步骤中提供帮助。在DevOps中，许多作为您的质量保证计划一部分的测试用例都是自动化的，这显著加快了质量保证过程。您的应用程序的发布管理和监控也是自动化的，以提供高可见性、持续学习和在需要时快速修复。所有这些都将帮助组织提高生产力、可预测性和可扩展性。
- en: DevOps is a holistic view of how the application is developed and managed. It
    is not a function for only the development team or operational team to adopt;
    rather, the entire organization should adopt it. It is therefore imperative for
    the organizational structure and the organization’s vision and goal to all align
    with the set of procedural and functional changes necessary to shift from the
    traditional way of developing software.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps是对应用开发和管理的整体视角。它不仅仅是为开发团队或运维团队采用的功能；相反，整个组织都应该采用它。因此，组织结构以及组织的愿景和目标与从传统软件开发方式转变所需的程序和功能变化相一致是至关重要的。
- en: 'Just to give you a gist of how traditional and DevOps models differ in terms
    of application development and release cycles, take a look at the following comparison
    table:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了给您一个关于传统和DevOps模型在应用开发和发布周期方面差异的概览，请查看以下比较表格：
- en: '|  | **Traditional** | **DevOps** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  | **传统** | **DevOps** |'
- en: '| Planning | MonthsLong time to plan due to the large application size and
    tight coupling between different application components | Days to weeksVery short
    planning time since the application is broken down into small individual loosely
    coupled services |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 规划 | 数月由于应用程序规模大且不同应用程序组件之间紧密耦合，规划时间较长 | 天到几周由于应用程序被分解成小型独立松散耦合的服务，规划时间非常短
    |'
- en: '| Development | Months | Days to weeks, and even shorter in the case of patches
    and fixes |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 开发 | 数月 | 天到几周，在补丁和修复的情况下甚至更短 |'
- en: '| Testing | Weeks to monthsMostly manually intensive QA use case testing, which
    may sometimes jeopardize the reliability of the test’s outcome | DaysMostly automated
    QA use case execution that brings high reliability to the application |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 周到数月主要是手动密集型的质量保证用例测试，有时可能会危及测试结果的可信度 | 天主要是自动化的质量保证用例执行，为应用程序带来高可靠性
    |'
- en: '| Release, Deploy | DaysUsually long manual work and more susceptible to human
    errors | HoursMostly automated |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 发布、部署 | 天通常需要大量手动工作，更容易受到人为错误的影响 | 小时主要是自动化的 |'
- en: '| Operate, Monitor | Metrics reporting is mostly manually pulled and analyzed
    | Metrics are monitored and analyzed automatically and can even fix the problem
    in seconds. Moreover, **machine learning** (**ML**) tools can be used to enhance
    operations even further. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 运营、监控 | 指标报告主要是手动提取和分析 | 指标自动监控和分析，甚至可以在几秒钟内解决问题。此外，**机器学习**（**ML**）工具可以进一步优化操作。|'
- en: 'Table 1.2: Traditional operational style versus DevOps'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2：传统运维风格与DevOps对比
- en: 'In traditional development environments, you have a big piece of code to write,
    maintain, and change when needed. Because of the code size, it is only normal
    to have a long release cycle, and it can only be feasible to deploy patches or
    new releases when only major changes or high-severity fixes are needed, as illustrated
    in the following diagram:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的开发环境中，您需要编写、维护和更改一大块代码。由于代码量很大，发布周期长是正常的，只有在需要主要更改或高严重性修复时，才可行地部署补丁或新版本，如下面的图所示：
- en: '![Figure 1.12: Traditional development environment versus MSA DevOps](img/B18934_01_12.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图1.12：传统开发环境与MSA DevOps对比](img/B18934_01_12.jpg)'
- en: 'Figure 1.12: Traditional development environment versus MSA DevOps'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：传统开发环境与MSA DevOps对比
- en: In MSA, teams are separated based on applications that do not function. That
    big chunk of code is split into a collection of much smaller code (microservices),
    and since teams are split to work independently for each team to focus on a specialized
    microservice, the development and release cycles are much shorter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在MSA中，团队根据不功能的应用程序进行划分。那块大代码被拆分成一系列更小的代码（微服务），由于团队独立工作，每个团队专注于特定的微服务，因此开发和发布周期要短得多。
- en: Similarly, in DevOps, the application is broken down into smaller pieces to
    enable the CI/CD pipeline, which makes DevOps the perfect model that fits MSA.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Why ML?
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using ML tools and algorithms in your MSA enterprise system can further enhance
    and accelerate your DevOps CI/CD pipeline. With ML, you can find patterns in your
    tests, monitor phases of your pipeline, automatically analyze where the faults
    may be, and suggest a resolution or automatically fix operational issues whenever
    possible.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: ML can greatly shorten your MSA enterprise system’s TTM and make it more intelligent,
    self-healing, resilient, and supportable.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'We will in this book discuss two aspects of ML: first, we’ll explain in detail
    how to add CI/CD pipeline intelligence to your MSA enterprise system, and second,
    we’ll look at how to build an ML enterprise system with MSA in mind:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: Using ML in CI/CD pipeline](img/B18934_01_13.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Using ML in CI/CD pipeline'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the concepts of MSA and how MSA is different from
    traditional monolithic architecture. By now, you should also have a clear understanding
    of the advantages of MSA and the challenges organizations may experience when
    adopting MSA.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the key concept of methodologies to consider when designing
    MSA, such as ACID, the saga pattern, and CQRS. All these concepts are essential
    to help overcome synchronization challenges and to maintain microservices anonymity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We now understand the basics of DevOps and why it is important in MSA design,
    deployment, and operations, as well as how ML integration in MSA enterprise systems
    can help enhance system operations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go over common methodologies that organizations
    pursue to transition from running traditional monolithic systems to MSA systems.
    We will discuss how to break down the existing system into services that form
    the new MSA enterprise system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
