- en: Building the Wiki Game Web Crawler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wow, [Chapter 3](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml), *Setting Up the
    Wiki Game*, was quite a ride! Laying the foundation of our Wikipedia game took
    us on a real learning *tour-de-force*. After the quick refresher on how the web
    and web pages work, we dived deeper into the key parts of the language, studying
    the dictionary data structure and its corresponding data type, conditional expressions,
    functions, exception handling, and even the very handy piping operator (`|>`).
    In the process, we built a short script that uses a couple of powerful third-party
    packages, `HTTP` and `Gumbo`, to request a web page from Wikipedia, parse it as
    an HTML DOM, and extract all internal links from within the page. Our script is
    part of a proper Julia project, which employs `Pkg` to efficiently manage dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll continue the development of our game, implementing
    the complete workflow and the gameplay. Even if you are not a seasoned developer,
    it''s easy to imagine that even a simple game like this will end up with multiple
    logical parts. We could maybe have a module for the Wikipedia page crawler, one
    for the gameplay itself, and one for the UI (the web app that we''ll create in
    the next chapter). Breaking down a problem into smaller parts always makes for
    a simpler solution. And, that''s especially true when writing code—having small,
    specialized functions, grouped by responsibility, makes the software easier to
    reason about, develop, extend, and maintain. In this chapter, we''ll learn about
    Julia''s constructs for structuring the code, and we''ll discuss a few more key
    elements of the language: the type system, constructors, methods, and multiple
    dispatch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Six Degrees of Wikipedia*, the gameplay'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing our code using modules and loading code from multiple files (the
    so-called **mixin behavior**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types and the type system, which are key to Julia's flexibility and performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors, special functions which allow us to create new instances of our
    types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods and multiple dispatch, some of the most important aspects of the language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with relational databases (specifically, MySQL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you are ready to dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to install a specific version of a package you need to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively you can install all the used packages by downloading the Project.toml
    file provided with the chapter and using `pkg>` instantiate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Six Degrees of Wikipedia, the gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen in the previous chapter, the **Six Degrees of Wikipedia game**
    is a play on the concept of the *six degrees of separation* theory—the idea that
    all living things (and pretty much everything in the world) are six or fewer steps
    away from each other. For example, a chain of *a friend of a friend* can be made
    to connect any two people in a maximum of six steps.
  prefs: []
  type: TYPE_NORMAL
- en: For our own game, the goal of the player is to link any two given Wikipedia
    articles, passing through six or fewer other Wikipedia pages. In order to make
    sure that the problem has a solution (the *six degrees of separation* theory has
    not been demonstrated) and that indeed there is a path from our starting article
    to the end article, we'll pre-crawl the full path. That is, we'll begin with a
    random Wikipedia page, which will be our starting point, and we'll link through
    a number of pages toward our destination, the end article. The algorithm for picking
    the next linked page will be the simplest—we'll just pick any random internal
    link.
  prefs: []
  type: TYPE_NORMAL
- en: To make things more interesting, we will also offer a difficulty setting—easy,
    medium, or hard. This will affect how far apart the start page and the end page
    will be. For an easy game, they will be two pages away, for medium, four, and
    for hard, six. Of course, this logic in not super rigorous. Yes, intuitively,
    we can say that two articles that are further apart will be less related and harder
    to link. But, it's also possible that the player will find a shorter path. We
    won't worry about that, though.
  prefs: []
  type: TYPE_NORMAL
- en: The game will also allow the players to go back if they can't find the solution
    in the maximum number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the player gives up, we'll add an option to show the solution—the
    path we found from the start article to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds exciting—let's write some code!
  prefs: []
  type: TYPE_NORMAL
- en: Some additional requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow through this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working Julia installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we've been mostly coding at the REPL. Recently, in the previous
    chapter, we've started to rely more on the IDE to whip up short Julia files.
  prefs: []
  type: TYPE_NORMAL
- en: But, as our skillset grows and we develop more and more ambitious projects,
    so will grow the complexity of our programs. This, in turn, will lead to more
    lines of code, more logic, and more files—and more difficulties in maintaining
    and understanding all these down the line. As the famous coding axiom goes, the
    code is read many more times than it is written—so we need to plan accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Each language comes with its own philosophy and toolset when it comes to code
    organization. In Julia, we have files, modules, and packages. We'll learn about
    all of these next.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules to tame our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules group together related functions, variables, and other definitions.
    But, they are not just organizational units—they are language constructs that
    can be understood as variable workspaces. They allow us to define variables and
    functions without worrying about name conflicts. Julia's `Module` is one of the
    cornerstones of the language—a key structural and logical entity that helps make
    code easier to develop, understand, and maintain. We'll make good use of modules
    by architecting our game around them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A module is defined using the `module <<name>>...end` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's start a new REPL session and look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Say we want to write a function that retrieves a random Wikipedia page—it's
    one of our game's features. We could call this function `rand`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may suspect, creating random *things* is a pretty common task, so we''re
    not the first ones to think about it. You can see for yourself. Try this at the
    REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Turns out, 56 `rand` methods are already defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will make it difficult to add our own variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our attempt to define a new `rand` method raised an error because it was already
    defined and loaded.
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to see how this can lead to a nightmare scenario when choosing the
    names of our functions. If all the defined names would live in the same workspace,
    we'd get into endless name conflicts as we'd run out of relevant names for our
    functions and variables.
  prefs: []
  type: TYPE_NORMAL
- en: Julia's module allows us to define separate workspaces, providing a level of
    encapsulation that separates our variables and functions from everybody else's.
    By using modules, name conflicts are eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules are defined within `module...end` language constructs. Try this example
    (at the REPL), where we define our `rand` function within a module called `MyModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from its full name, `Main.MyModule`, our newly created module,
    is actually added within another existing module called `Main`. This module, `Main`,
    is the default module within which code executed at the REPL is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to access our newly defined function, we need to reference it within
    `MyModule`, by *dotting in*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Defining modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since modules are designed to be used with larger code bases, they're not REPL-friendly.
    Because once they are defined, we cannot extend them with extra definitions and
    we're forced to retype and redefine the whole module, and it's best to use a full-fledged
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new folder to host our code. Within it, we'll want to create
    a new folder called `modules/`. Then, within the `modules/` folder, add three
    files—`Letters.jl`, `Numbers.jl`, and `module_name.jl`.
  prefs: []
  type: TYPE_NORMAL
- en: Files containing Julia code use, by convention, the `.jl` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: Productive REPL sessions with Julia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why not use Julia's file-wrangling powers to set up this file structure? Let's
    take a look at how to do this, as it will come in handy in our day-to-day work.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you can type `;` into the REPL, at the beginning of the line, to trigger
    the shell mode. Your cursor will change from `julia>` to `shell>` to confirm the
    change of context. In IJulia/Jupyter, you have to prefix the code in the cell
    with `;` in order to be executed in shell mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget that Julia''s shell mode calls commands as if they run straight
    into the OS Terminal—so the invoked binaries must exist on that platform. Both
    `mkdir` and `cd` are supported on all major operating systems, so we''re safe
    here. But, when it comes to creating the files, we''re out of luck—the `touch`
    command is not available on Windows. No problem though—all we need to do in this
    case is to invoke the Julia function with the same name. This will create the
    files programmatically, in a platform-agnostic way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to make sure that the files were created, use `readdir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Please make sure that you name the files exactly as indicated, respecting the
    case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the default editor is not your favorite Julia IDE, you can change it by
    setting one of the `JULIA_EDITOR`, `VISUAL`, or `EDITOR` environment variables
    to point to the editor of your choice. For instance, on my Mac, I can ask for
    the path to the Atom editor with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, I can set `JULIA_EDITOR` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The three variables have slightly different purposes, but in this case, setting
    any of them will have the same effect—changing the default editor for the current
    Julia session. Keep in mind, though, that they have different *weights*, with
    `JULIA_EDITOR` taking precedence over `VISUAL`, which takes precedence over `EDITOR`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by editing `Letters.jl` to make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a module called `Letters`. In it, we added a `rand` function
    that uses Julia's `Random.rand` to return a random letter between `A` and `Z`
    in the form of a `Char`. Next, we added a function called `Letters.randstring`,
    which returns a `String` of `10` random characters. This string is generated using
    a `Char[]` array comprehension (the `_` variable name is perfectly legal in Julia
    and, by convention, it designates a variable whose value is not used) which is
    piped into the `join` function to return the string result.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this is an over complicated way to generate a random string
    as Julia provides the `Random.randstring` function. But, at this point, it's important
    to exploit every opportunity to practice writing code, and I just didn't want
    to waste the chance of using Julia's comprehension syntax and the pipe operator.
    Practice makes perfect!
  prefs: []
  type: TYPE_NORMAL
- en: Switching our focus towards the first lines of code, we declared that we'll
    be `using Random`—and we instructed the compiler to make `randstring` public via
    `export randstring`. Finally, we have also declared a constant called `MY_NAME`,
    which points to the `Letters` string (which is the name of the module itself).
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the module, `include("module_name.jl")`, loads the contents
    of `module_name.jl` into `Letters`. The `include` function is typically used to
    load source code interactively, or to combine files in packages that are split
    into multiple source files—and we'll see how this works soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s edit `Number.jl`. It will have a similar `rand` function that
    will return a random `Integer` between `1` and `1_000`. It exports `halfrand`,
    a function that gets a value from `rand` and divides it by `2`. We pass the result
    of the division to the `floor` function, which will convert it to the closest
    less than or equal value. And, just like `Letters`, it also includes `module_name.jl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, for both modules, we defined a `MY_NAME` constant. We''ll reference it
    by editing the `module_name.jl` file to make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code returns the corresponding value of the constant, depending on the actual
    module where we include the `module_name.jl` file. This illustrates Julia's mixin
    behavior, where included code acts as if it was written directly into the including
    file. We'll see how this works next.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the fact that we are only *now* formally discussing modules, we've been
    using them all along. The `using` statement which we employed so many times takes
    as its parameter a module name. It's a key language construct that tells the compiler
    to bring the module's definitions into the current scope. Referencing functions,
    variables, and types defined in other modules is a routine part of programming
    in Julia—accessing the functionality provided by a third-party package, for example,
    revolves around bringing its main module into scope via `using`. But, `using`
    is not the only tool in Julia's arsenal. We have a few more commands at our disposal,
    such as `import`, `include`, and `export`.
  prefs: []
  type: TYPE_NORMAL
- en: The `using` directive allows us to reference functions, variables, types, and
    so on exported by other modules. This tells Julia to make the module's exported
    definitions available in the current workspace. If the definitions were exported
    by the module's author, we can invoke them without having to prefix them with
    the module's name (prefixing the name of the function with the module name represents
    the fully qualified name). But, be careful though as this is a double-edged sword—if
    two used modules export functions with the same name, the functions will still
    have to be accessed using the fully qualified name—otherwise Julia will throw
    an exception as it won't know which of the functions we refer to.
  prefs: []
  type: TYPE_NORMAL
- en: As for `import`, it is somewhat similar, in that it also brings definitions
    from another module into scope. But, it differs in two important aspects. First,
    calling `import MyModule` would still require prefixing the definitions with the
    module's name, thereby avoiding potential name clashes. Second, if we want to
    extend functions defined in other modules with new methods, we *have* to use `import`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `include` is conceptually different. It is used to evaluate
    the contents of a file into the current context (that is, into the current module's
    *global* scope). It's a way to reuse code by providing mixin-like behavior, as
    we have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the included file is evaluated in the module''s global scope
    is a very important point. It means that, even if we include a file within a function''s
    body, the contents of the file will not be evaluated within the function''s scope,
    but within the module''s scope. To see this in action, let''s create a file called
    `testinclude.jl` in our `modules/` folder. Edit `testinclude.jl` and append this
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the following code in the REPL or in IJulia, you''ll see what
    I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Apparently, it all worked fine. The `testinclude.jl` file was included and
    the `somevar` variable was defined. However, `somevar` was not created within
    the `testinclude` function, but as a global variable in the `Main` module. We
    can see that easily, as we can access the `somevar` variable directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Keep this behavior in mind as it can lead to hard-to-understand bugs by exposing
    variables in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `export` is used by a module's author to expose definitions, much like
    a public interface. As we've seen, exported functions and variables are brought
    into scope by the module's users via `using`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the LOAD_PATH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at some examples that illustrate scoping rules when working with
    modules. Please open a new Julia REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen the `using` statement many times throughout the previous chapters,
    and now we understand its role—to bring another module and its definitions (variables,
    functions, types) into scope. Let''s try it with our newly created modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Ouch, an exception! Julia informs us that it doesn't know where to find the
    `Letters` module and advises us to use `Pkg.add("Letters")` to install it. But,
    since `Pkg.add` only works with registered packages and we haven't published our
    modules to Julia's registry, that won't help. Turns out we just need to tell Julia
    where to find our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When asked to bring a module into scope via `using`, Julia checks a series
    of paths to look up the corresponding files. These lookup paths are stored in
    a `Vector` called the `LOAD_PATH`—and we can append our `modules/` folder to this
    collection by using the `push!` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Your output might be different, but what matters is that after calling `push!`,
    the `LOAD_PATH` collection now has an extra element indicating the path to the
    `modules/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In order for Julia to match the name of a module with its corresponding file,
    *the file must have exactly the same name as the module*, plus the `.jl` extension.
    It's OK for a file to include more than one module, but Julia will not be able
    to automatically find the extra ones by filename.
  prefs: []
  type: TYPE_NORMAL
- en: In regard to naming the modules themselves, the convention is to use CamelCase.
    Thus, we'll end up with a module called `Letters` defined in a `Letters.jl` file,
    or with a `WebSockets` module in a file named `WebSockets.jl`.
  prefs: []
  type: TYPE_NORMAL
- en: Loading modules with using
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve added our folder to the `LOAD_PATH`, we''re ready to use our
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, two things have happened:'
  prefs: []
  type: TYPE_NORMAL
- en: All the exported definitions are now directly callable in the REPL, in our case,
    `randstring`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definitions that were not exported are accessible by *dotting into* `Letters`—for
    example, `Letters.rand()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see what a module exports with the `names` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to get all the definitions of a module, exported or not, `names`
    takes a second parameter, `all`, a `Boolean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can easily recognize the variables and functions we defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, for instance, `myname` was not brought directly into scope,
    since it wasn''t exported in `Letters`. But, it turns out that we can still get
    the exported-like behavior if we explicitly tell Julia to use the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to bring multiple definitions from the same module directly into
    scope, we can pass a comma-separated list of names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Loading modules with import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at the effects of the `import` function, using `Numbers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that, unlike `using`, the `import` function *does not bring
    into scope* the exported definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, explicitly importing a definition itself will bring it directly into
    scope, disregarding whether it was exported or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Loading modules with include
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manipulating the `LOAD_PATH` works great when developing standalone apps, like
    the one we're working on now. However, this approach is not available for a package
    developer. For such instances—and for all the cases when for one reason or another
    using the `LOAD_PATH` is not an option—a common way of loading modules is by including
    their files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can include our `Letters` module at the REPL, as follows (start
    a new REPL session):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will read and evaluate the contents of the `modules/Letters.jl` file in
    the current scope. And as a result, it will define the `Letters` module within
    our current module, `Main`. But, this is not enough—at this point, none of the
    definitions within `Letters` were exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to bring them into scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Not again! What just happened? This is an important distinction when using
    `include` with modules. The `Letters` module, like we just said, is included in
    the current module, `Main`, so we need to reference it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also reference this kind of nested module hierarchy by using relative
    *paths*. For example, a dot, `.`, stands for *current module*. So, the previous
    `Main.Letters` nesting can be expressed as `.Letters`— it''s exactly the same
    thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we could use two dots, `..`, to reference the parent module, three
    dots for the parent of the parent, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've just seen, sometimes, the logic of our program will dictate that a
    module has to be part of another module, effectively nesting them. This is used
    with predilection when developing our own packages. The best way to organize a
    package is to expose a top module and include all the other definitions (functions,
    variables, and other modules) within it (to encapsulate the functionality). An
    example should help clarify things.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a change—in the `Letters.jl` file, under the line saying `include("module_name.jl")`,
    go ahead and add another line—`include("Numbers.jl")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this change, the `Numbers` module will effectively be defined within the
    `Letters` module. In order to access the functions of the nested module, we *dot
    into* as deep as necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Setting up our game's architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a home for our game—make a new folder called `sixdegrees/`. We'll
    use it to organize our game's files. Each file will contain a module and each
    module will package related functionality. We'll make use of Julia's auto-loading
    features, which means that the filename of each module will be the same as the
    module's name, plus the `.jl` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do, though, once we go into the `sixdegrees/` folder,
    is to initialize our project through `Pkg`—so we can use Julia''s dependency management
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be using the `HTTP` and the `Gumbo` packages, so it''s a good idea to
    add them, now that we''re dealing with dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The next thing we need is a container for Wikipedia-related code—a module that
    encapsulates the functionality for requesting an article and extracting the internal
    URLs. We already have a first iteration of the code in the `webcrawler.jl` file
    we wrote in [Chapter 3](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml), *Setting
    Up the Wiki Game*. Now, all we need to do is create a `Wikipedia` module and fill
    it up with the contents of `webcrawler.jl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `sixdegrees` folder, create a new file called `Wikipedia.jl`. Set
    it up with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should look familiar as it shares much of its logic with
    `webcrawler.jl`. But, there are some important changes.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we wrapped everything into a `module` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note a very important convention: in Julia, we do not indent the code
    within modules as this would cause the whole file to be indented, which would
    affect readability.'
  prefs: []
  type: TYPE_NORMAL
- en: On the third line, where we used to have the link to Julia's Wikipedia entry,
    we now define a `String` constant, `RANDOM_PAGE_URL`, which points to a special
    Wikipedia URL that returns a random article. Also, we switched to the mobile version
    of the Wikipedia website, as indicated by the `en.m.` subdomains. Using the mobile
    pages will make our lives easier as they are simpler and have less markup.
  prefs: []
  type: TYPE_NORMAL
- en: In the `fetchpage` function, we're no longer looking for the `Content-Length`
    header and we're instead checking the `length` of the `response.body` property.
    We're doing this because requesting the special random Wikipedia page performs
    a redirect and, in the process, the `Content-Length` header is dropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also replaced some of the logic at the bottom of the file. Instead
    of automatically fetching Julia''s Wikipedia page and dumping the list of internal
    links onto the screen, we now define two more functions: `fetchrandom` and `articlelinks`.
    These functions will be the public interface of the `Wikipedia` module, and they
    are exposed using the `export` statement. The `fetchrandom` function does exactly
    what the name says—it calls the `fetchpage` function passing in the `RANDOM_PAGE_URL`
    const, effectively fetching a random Wikipedia page. `articlelinks` returns an
    array of strings representing the linked articles.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we removed the `LINKS` constant—global variables should be avoided.
    The `extractlinks` function has been refactored accordingly, now accepting a second
    parameter, `links`, a `Vector` of `String`, which is used to maintain state during
    recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Checking our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make sure that, after this refactoring, our code still works as expected.
    Julia comes out of the box with unit-testing capabilities, and we'll look at these
    in [Chapter 11](8391f749-e95c-4ff9-ba40-d71c91b1d7fd.xhtml), *Creating Julia Packages*.
    For now, we'll do it the old-fashioned way, by manually running the code and inspecting
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add a new file inside the `sixdegrees/` folder, called `six_degrees.jl`.
    Looking at its name, you can guess that it will be a plain Julia file and not
    a module. We''ll use it to orchestrate the loading of our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The code is straightforward and minimalistic—we use `Pkg` to activate the current
    project. Then, we include the `Wikipedia.jl` file in the current module, and then
    we ask the compiler to bring the `Wikipedia` module into scope. Finally, we use
    the previously discussed `fetchrandom` and `articlelinks` to retrieve the list
    of articles URLs from a random Wikipedia page and display it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to run our code! In the REPL, make sure that you `cd` into the `sixdegrees`
    folder and execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the run code or run file option in Visual Studio
    Code and Atom. Here''s Atom running the `six_degrees.jl` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/254968f3-69ff-4ecc-abec-45273a13f10c.png)'
  prefs: []
  type: TYPE_IMG
- en: Building our Wikipedia crawler - take two
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our code runs as expected, refactored and neatly packed into a module. However,
    there's one more thing I'd like us to refactor before moving on. I'm not especially
    fond of our `extractlinks` function.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it naively iterates over all the HTML elements. For example, say
    that we also want to extract the title of the page—every time we want to process
    something that's not a link, we'll have to iterate over the whole document again.
    That's going to be resource-hungry and slow to run.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we're reinventing the wheel. In [Chapter 3](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml),
    *Setting Up the Wiki Game*, we said that CSS selectors are the *lingua franca*
    of DOM parsing. We'd benefit massively from using the concise syntax of CSS selectors
    with the underlying optimizations provided by specialized libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we don't need to look too far for this kind of functionality. Julia's
    `Pkg` system provides access to `Cascadia`, a native CSS selector library. And,
    the great thing about it is that it works hand in hand with `Gumbo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use Cascadia, we need to add it to our project''s list of dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, tell Julia we''ll be using it—modify `Wikipedia.jl` so that the third
    line reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With the help of `Cascadia`, we can now refactor the `extractlinks` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a closer look at all that happens here. The first thing that stands
    out is the `Selector` function. This is provided by `Cascadia` and constructs
    a new CSS selector object. The string that is passed to it as its only parameter
    is a CSS selector that reads as—all `<a>` elements that have a `href` attribute
    whose value starts with `'/wiki/'` and does not contain a column (`:`).
  prefs: []
  type: TYPE_NORMAL
- en: '`Cascadia` also exports the `eachmatch` method. More accurately, it *extends*
    the existing `Base.eachmatch` method that we''ve seen previously with regular
    expressions. This provides a familiar interface—and we''ll see how to extend methods
    later in this chapter, in the *Methods* section. The `Cascadia.eachmatch` function
    returns a `Vector` of elements that match the selector.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we retrieve the collection of matched elements, we pass it to the `map`
    function. The `map` function is one of the most used tools in the functional programming
    toolbox. It takes as its arguments a function, `f`, and a collection, `c`—and
    it transforms the collection, `c`, by applying `f` to each element, returning
    the modified collection as the result. Its definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because, in Julia, functions are first-class language constructs, they can be
    referenced and manipulated like any other type of variable. They can be passed
    as arguments to other functions or can be returned as the result of other function
    calls. The functions that take another function as their argument or return another
    function as their result are called **higher-order functions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple example using `map`. We''ll take a `Vector` of `Int`,
    and we''ll apply to each element of its collection a function that doubles the
    value. You can follow along in a new REPL session (or in the accompanying IJulia
    notebook):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That's all good, but having to define a function just to use it as a one-off
    argument for another function is inconvenient and a bit wasteful. For this reason,
    the programming languages that support functional features, including Julia, usually
    support *anonymous functions*. An anonymous function, or a *lambda*, is a function
    definition that is not bound to an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the preceding `map` invocation to use an anonymous function,
    which is defined on the spot by using the arrow `->` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the definition, `x -> x*2`, the `x` at the left of the arrow represents the
    argument that is passed into the function, while `x*2` represents the body of
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! We have achieved the same end result without having to separately define
    `double`. But, what if we need to use a more complex function? For instance, note
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: That's pretty hard to follow! Because Julia allows us to indent our code, we
    can enhance the readability of this example to make it more palatable, but the
    result is still far from great.
  prefs: []
  type: TYPE_NORMAL
- en: Because these situations occur often, Julia provides the block syntax for defining
    anonymous functions. All the functions that take another function as their *first*
    argument can be used with the block syntax. Support for this kind of invocation
    is baked into the language, so you don't need to do anything—your functions will
    support it as well, out of the box, as long as the function is the first positional
    argument. In order to use it, we skip passing in the first argument when invoking
    the higher-order function—and instead, at the end of the arguments list, outside
    of the arguments tuple, we add a `do...end` block. Within this block, we define
    our lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can rewrite the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Much more readable!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Wikipedia parser is pretty robust now, and the addition of `Cascadia` greatly
    simplifies the code. It's time to think about the actual gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing, the core of the game, is to create the riddle—asking
    the player to find a path from the initial article to the end article. We previously
    decided that in order to be sure that a path between two articles really exists,
    we will pre-crawl all the pages, from the first to the last. In order to navigate
    from one page to the next, we'll simply randomly pick one of the internal URLs.
  prefs: []
  type: TYPE_NORMAL
- en: We also mentioned including difficulty settings. We will use the common-sense
    assumption that the more links there are between the start article and the end
    article, the less related their subjects will be; and thus, the more difficult
    to identify the path between them, resulting in a more challenging level.
  prefs: []
  type: TYPE_NORMAL
- en: 'All right, time to get coding! For starters, create a new file inside the `sixdegrees/`
    folder. Name it `Gameplay.jl` and copy and paste the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`Gamplay.jl` defines a new `module` and brings `Wikipedia` into scope. Here,
    you can see how we reference the `Wikipedia` module in the parent scope by using
    `..`. It then defines three constants that map the difficulty settings to degrees
    of separation (named `DIFFICULTY_EASY`, `DIFFICULTY_MEDIUM`, and `DIFFICULTY_HARD`).'
  prefs: []
  type: TYPE_NORMAL
- en: It then defines a function, `newgame`, which accepts a difficulty argument,
    by default set to hard. In the body of the function, we loop for a number of times
    equal to the difficulty value. On each iteration, we check the current degree
    of separation—if it's the first article, we call `fetchrandom` to start off the
    crawling process. If it's not the first article, we pick a random link from the
    list of links of the previously crawled article (`rand(articles[i-1][:links])`).
    We then pass this URL to `fetchpage`. When discussing conditionals, we learned
    that in Julia `if/else` statements return the value of the last-evaluated expression.
    We can see it put to good use here, with the result of the evaluation being stored
    in the `article` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've fetched the article, we store its content and its links within a
    `Dict` called `article_data`. And, `article_data` is in turn added to the `articles`
    array. On its last line, the `newgame` function returns the `articles` vector
    that now contains all the steps, from first to last. This function is also exported.
  prefs: []
  type: TYPE_NORMAL
- en: 'That wasn''t too hard! But, there''s a small glitch. If you try to run the
    code now, it will fail. The reason is that the article links are *relative*. This
    means that they are not fully qualified URLs; they look like `/wiki/Some_Article_Title`.
    When `HTTP.jl` makes a request, it needs the full link, protocol, and domain name
    included. But don''t worry, that''s easy to fix in `Wikipedia.jl`. Please switch
    your editor to the `Wikipedia` module and replace the `const RANDOM_PAGE_URL`
    line with the following three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We broke the random page URL into its components—the protocol, the domain name,
    and the rest of the relative path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use a similar approach to turn relative URLs into absolute URLs when
    fetching articles. For this, change the body of `fetchpage` and add this as its
    first line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check the `url` argument—if it starts with `"/"`, it means it's a relative
    URL so we need to turn it into its absolute counterpart. We used the ternary operator,
    as you can tell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code should work just fine now, but spreading this `PROTOCOL * DOMAIN_NAME
    * url` throughout our game is a bit of a code smell. Let''s abstract this away
    into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A *code smell* in programming parlance refers to a practice that violates fundamental
    design principles and negatively impacts quality. It is not a *bug* *per se*,
    but indicates weakness in design that may increase the risk of bugs or failures
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Wikipedia.jl` file should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our gameplay evolves nicely. Only a few pieces left. Thinking about our game's
    UI, we'll want to show the game's progression, indicating the articles the player
    has navigated through. For this, we'll need the titles of the articles. If we
    could also include an image, that would make our game much prettier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we are now using CSS selectors, so extracting the missing data
    should be a piece of cake. All we need to do is add the following to the `Wikipedia`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `extracttitle` and `extractimage` functions will retrieve the corresponding
    content from our article pages. In both cases, since we only want to select a
    single element, the main page heading and the first image respectively, we use
    `Cascadia.matchFirst`. The `matchFirst` function is not publicly exposed by `Cascadia`—but
    since it's quite useful, we `import` it.
  prefs: []
  type: TYPE_NORMAL
- en: The `#section_0` selector identifies the main page heading, a `<h1>` element.
    And, because we need to extract the text between its `<h1>...</h1>` tags, we invoke
    the `nodeText` method provided by `Cascadia`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in the following screenshot, which shows the main heading of a
    Wikipedia page in Safari''s inspector, how to identify the desired HTML elements
    and how to pick their CSS selectors by inspecting the source of the page and the
    corresponding DOM element. The HTML property, `id="section_0"`, corresponds to
    the `#section_0` CSS selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09501ef3-c816-45fb-9fdf-7210a0538eec.png)'
  prefs: []
  type: TYPE_IMG
- en: As for `extractimage`, we look for the main article image, represented by the
    `".content a.image img"` selector. Since not all the pages have it, we check if
    we do indeed get a valid element. If the page does not have an image, we'll get
    an instance of `Nothing,` called `nothing`. This is an important construct—`nothing`
    is the singleton instance of `Nothing`, indicating the absence of an object, corresponding
    to `NULL` in other languages. If we do get an `img` element, we extract the value
    of its `src` attribute, which is the URL of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another Wikipedia screenshot, in which I marked the image element that
    we''re targeting. The flag is the first image on Wikipedia''s **Australia** page—a
    perfect match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3db08f0a-dabc-4811-ab68-93785a2cea72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we could extend the `Gameplay.newgame` function, to handle the new functions
    and values. But by now, this doesn''t feel right—too much of the logic of `Wikipedia`
    would leak into the `Gameplay` module, coupling them; a dangerous anti-pattern.
    Instead, let''s make the extraction of the data and setting up of the article,
    `Dict`, the full responsibility of `Wikipedia`, completely encapsulating the logic.
    Make the `Gameplay.newgame` function looks as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update the `Wikipedia` module to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The file has a few important changes. We've removed the `articlelinks` function
    and instead added `articleinfo` and `articledom`. The new `articledom` function
    parses the HTML using `Gumbo` and generates the DOM, which, very importantly,
    is only parsed once. We don't want to parse the HTML into a DOM every time we
    extract a type of element, as would've been the case if we kept the previous `articlelinks`
    function. As for `articleinfo`, it is responsible for setting up an article, `Dict`,
    with all the relevant information—content, links, title, and image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do a test run of our code, by modifying the `six_degrees.jl` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We start a new game, which goes through two articles (`Gameplay.DIFFICULTY_EASY`)
    and for each article we display its title. We can see it in action by either running
    it in a REPL session via `julia> include("six_degrees.jl")`, or by simply running
    the file in Visual Studio Code or Atom. Here it is in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: One more thing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our test run shows that our difficulty settings have a small glitch. We should
    crawl a certain number of articles *after* the starting point. Our initial article
    should not count. This is super easy to fix. In `Gameplay.newgame`, we need to
    replace `for i in 1:difficulty` with `for i in 1:difficulty+1` (note the `+1`
    at the end). Now, if we try again, it works as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Learning about Julia's type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game works like a charm, but there is one thing we can improve—storing our
    article info as a `Dict`. Julia's dictionaries are very flexible and powerful,
    but they are not a good fit in every case. The `Dict` is a generic data structure
    that is optimized for search, delete, and insert operations. None of these are
    needed here—our articles have a fixed structure and contain data that doesn't
    change once created. It's a perfect use case for objects and **object-oriented
    programming** (**OOP**). Looks like it's time to learn about types.
  prefs: []
  type: TYPE_NORMAL
- en: Julia's type system is the bread and butter of the language—it is all-pervasive,
    defining the language's syntax and being the driving force behind Julia's performance
    and flexibility. Julia's type system is dynamic, meaning that nothing is known
    about types until runtime, when the actual values manipulated by the program are
    available. However, we can benefit from the advantages of static typing by using
    type annotations—indicating that certain values are of specific types. This can
    greatly improve the performance of the code and also enhance readability and simplify
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: It's impossible to talk about Julia and not talk about types. And sure enough,
    we've seen many primitive types so far—`Integer`, `Float64`, `Boolean`, `Char`,
    and so on. We've also been exposed to types while learning about the various data
    structures, such as `Array`, `Dict,` or tuple. These are all built into the language,
    but it turns out that Julia makes it very easy to create our own.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our own types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Julia supports two categories of type—primitive and composite. A primitive type
    is a concrete type whose data consists of plain old bits. A composite type is
    a collection of named fields, an instance of which can be treated as a single
    value. In many languages, composite types are the only kind of user-definable
    type, but Julia lets us declare our own primitive types as well, rather than providing
    only a fixed set of built-in ones.
  prefs: []
  type: TYPE_NORMAL
- en: We won't talk about defining primitive types here, but you can read more about
    them in the official documentation at [https://docs.julialang.org/en/v1/manual/types/](https://docs.julialang.org/en/v1/manual/types/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to represent our articles, we''re best served by an immutable composite
    type. Once our article object is created, its data won''t change. Immutable composite
    types are introduced by the `struct` keyword followed by a block of field names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we provide no type information for the fields—that is, we don''t tell
    Julia what type we want each field to be—they will default to any, allowing to
    hold any type of value. But, since we already know what data we want to store,
    we would greatly benefit from constraining the type of each field. The `::` operator
    can be used to attach type annotations to expressions and variables. It can be
    read as *is an instance of*. Thus, we define the `Article` type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: All the fields are of `String` type, with the exception of `links`, which is
    a one-dimensional `Array` of `String`, also called a `Vector{String}`.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations can provide important performance benefits—while also eliminating
    a whole class of type-related bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New objects of `Article` type are created by applying the `Article` type name
    like a function. The arguments are the values for its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields of the newly created object can be accessed using the standard *dot
    notation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we declared our type to be immutable, the values are read-only, so
    they can''t be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Article` type definition won''t allow us to change the `julia.title` property.
    But, immutability should not be dismissed as it does come with considerable advantages,
    per the official Julia documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be more efficient. Some structs can be packed efficiently into arrays,
    and in some cases, the compiler is able to avoid allocating immutable objects
    entirely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to violate the invariants provided by the type's constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code using immutable objects can be easier to reason about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But, that''s not the whole story. An immutable object can have fields that
    reference mutable objects, such as, for instance, `links`, which points to an
    `Array{String, 1}`. This array is still mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is no error when trying to alter the `links` property,
    by pushing one more URL to the underlying collection. If a property points to
    a mutable type, that type can be mutated, as long as its type stays the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We are not allowed to change the type of the `links` field—Julia tries to accommodate
    and attempts to convert the values we provided from `Int` to `String`, but fails.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable composite types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is also possible (and equally easy) to construct mutable composite types.
    The only thing we need to do is to use the `mutable struct` statement, instead
    of just `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Player` object should be mutable, as we''ll need to update the `score`
    property after each game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Type hierarchy and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like all programming languages that implement OOP features, Julia allows developers
    to define rich and expressive type hierarchies. However, unlike most OOP languages,
    there is a very important difference—*only the final (upper) type in the hierarchy
    can be instantiated in Julia*. All its parents are just nodes in the type graph,
    and we can''t create instances of them. They are *abstract types* and are defined
    using the `abstract` type keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `<:` operator to indicate that a type is a subtype of an existing
    *parent*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in another example, this is Julia''s numerical types hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that super-types can''t be instantiated can seem limiting, but they
    have a very powerful role. We can define functions that take a super-type as their
    argument, in effect accepting all its subtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how we defined a `getusername` function, which accepts an argument
    of (abstract) type, `Person`. As both `User` and `Player` are subtypes of `Person`,
    their instances are accepted as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Type unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we might want to allow a function to accept a set of types that are
    not necessarily part of the same type hierarchy. We could, of course, allow the
    function to accept any type, but depending on the use case, it could be desirable
    to strictly limit the arguments to a well-defined subset of types. For such cases,
    Julia provides *type unions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A type union is a special abstract type that includes as objects all instances
    of any of its argument types, constructed using the special `Union` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a new type union, `GameEntity`, which includes two types—`Person`
    and `Article`. Now, we can define functions that know how to handle `GameEntities`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Using article types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can refactor our code to eliminate the generic `Dict` data structure and
    represent our articles with specialized `Article` composite types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file in our `sixdegrees/` work folder, and name it `Articles.jl`.
    Edit the file by typing in the corresponding `module` declaration. Then, add the
    definition of our type and `export` it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We could've added the `Article` type definition to the `Wikipedia.jl` file,
    but chances are this will grow and it's better to keep them separated instead.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that both the `module` and the `type` are Julia entities
    that are loaded in the same scope. For this reason, we can't use the name `Article`
    for both the `module` and the `type`—we'd end up with a name clash. However, the
    pluralized name `Articles` is a good name for the module, since it will encapsulate
    the logic for dealing with *articles* in general, while the `Article` type represents
    an *article* entity—hence the singular form.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since conceptually an `Article` object references a Wikipedia page,
    it should be part of the `Wikipedia` namespace. That''s easy, we just need to
    include it into the `Wikipedia` module. Add this after the `import Cascadia: matchFirst`
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We're including the `Articles` module file and bringing it into scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the same `Wikipedia.jl` file, we need to modify the `articleinfo`
    function. Please make sure it reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Instead of creating a generic `Dict` object, we're now instantiating an instance
    of `Article`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to make a few changes to `Gameplay.jl` to use the `Article` types
    instead of `Dict`. It should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note that on the third line we bring `Wikipedia.Articles` into scope. Then,
    in the `newgame` function, we initiate the `articles` array to be of `Vector{Article}`
    type. And then, we update the code in the `for` loop to deal with `Article` objects—`rand(articles[i-1].links)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last change is in `six_degrees.jl`. Since `newgame` now returns a vector
    of `Article` objects instead of a `Dict`, we print the title by accessing the
    `title` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'A new test run should confirm that all works as expected (your output will
    be different since, remember, we''re pulling random articles):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Inner constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The external constructor (where we invoke the `type` as a function) is a default
    constructor where we provide the values for all the fields, in the right order—and
    get back an instance of the corresponding type. But, what if we want to provide
    additional constructors, that maybe impose certain constraints, perform validations,
    or are simply more user-friendly? For this purpose, Julia provides *internal constructors*.
    I've got a good use case for them.
  prefs: []
  type: TYPE_NORMAL
- en: I'm not especially fond of our `Article` constructor—it takes too many arguments
    that need to be passed in the exact right order. It's hard to remember how to
    instantiate it. We've learned earlier about keyword arguments—and it would be
    awesome to provide an alternative constructor that takes keyword arguments. Inner
    constructors are what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inner constructors are very much like the outer constructors, but with two
    major differences:'
  prefs: []
  type: TYPE_NORMAL
- en: They are declared inside the block of a type declaration, rather than outside
    of it like normal methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have access to a special locally existent function called `new` that creates
    objects of the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, external constructors have a clear limitation (by design)—we
    can create as many as we want, but they can only instantiate objects by invoking
    the existing internal constructors (they do not have access to the `new` function).
    This way, if we define internal constructors that implement some business logic
    constraints, *Julia guarantees that the external constructors cannot go around
    them*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our inner constructor with keyword arguments will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `;`, which separates the empty list of positional arguments
    from the list of keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This constructor allows us to instantiate `Article` objects using keyword arguments,
    which we can provide in any order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there''s a small problem. When we don''t provide any internal constructor,
    Julia provides the default one. But, if any inner constructor is defined, no default
    constructor method is provided anymore—it is presumed that we have supplied ourselves
    all the necessary inner constructors. In this case, if we want to get back the
    default constructor with the positional arguments, we''ll have to also define
    it ourselves as an internal one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The final version of the `Articles.jl` file should now be the following, with
    the two internal constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that, in this case, our keyword constructor could've
    been equally added as an external constructor and defined outside the `struct...end`
    body. What kind of constructor you use is an architectural decision that has to
    be taken on a case-by-case basis, taking into account the differences between
    the internal and the external constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you come from an OOP background, you may have noticed a very interesting
    aspect throughout our discussion of types. Unlike other languages, objects in
    Julia do not define behavior. That is, Julia's types only define fields (properties)
    but do not encapsulate functions.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is Julia's implementation of *multiple dispatch**, *a distinctive
    feature of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple dispatch is explained in the official documentation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The choice of which method to execute when a function is applied is called
    dispatch. Julia allows the dispatch process to choose which of a function''s methods
    to call based on the number of arguments given, and on the types of all of the
    function''s arguments. This is different than traditional object-oriented languages,
    where dispatch occurs based only on the first argument [`...`]. Using all of a
    function''s arguments to choose which method should be invoked, rather than just
    the first, is known as multiple dispatch. Multiple dispatch is particularly useful
    for mathematical code, where it makes little sense to artificially deem the operations
    to *belong *to one argument more than any of the others."'
  prefs: []
  type: TYPE_NORMAL
- en: Julia allows us to define functions that provide specific behavior for certain
    combinations of argument types. A definition of one possible behavior for a function
    is called a **method**. The signatures of method definitions can be annotated
    to indicate the types of arguments, in addition to their number, and more than
    a single method definition may be provided. An example will help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have our previously defined `Player` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, we see a corresponding `getscore` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. But, as our game grows incredibly successful, we could end
    up adding an app store to offer in-app purchases. This will lead us to also define
    a `Customer` type that could have a homonymous `credit_score` field, which stores
    their credit score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we''d need a corresponding `getscore` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, how would Julia know which function to use? It wouldn''t. As both functions
    are defined to accept any type of argument, the last-defined function overwrites
    the previous one. We need to specialize the two `getscore` declarations on the
    type of their arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If you look closely at the output for each function declaration, you'll see
    something interesting. After the definition of `getscore(p::Player)`, it says
    `getscore (generic function with 1 method)`. But, after defining `getscore(c::Customer)`,
    it shows `getscore (generic function with 2 methods)`. So now, we have defined
    two methods for the `getscore` function, each specializing on its argument type.
  prefs: []
  type: TYPE_NORMAL
- en: But, what if we add the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternatively, note the following that we might add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess which methods will be used when invoking `getscore` with a `Player`,
    a `Customer`, and an `Article` object? I''ll give you a hint: when a function
    is applied to a particular set of arguments, the most specific method applicable
    to those arguments is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to see which method is called for a given set of arguments, we can
    use `@which`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for `Customer` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We can see how the most specialized method is invoked— `getscore(t::Union{Player,Customer})`,
    which is more generic, is actually never used.
  prefs: []
  type: TYPE_NORMAL
- en: However, what about the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing an `Article` type will invoke the last definition of `getscore`, the
    one accepting `Any` type of argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Article` type does not have a `score` or a `credit_score` property,
    the `ErrorException` we defined is being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out what methods are defined for a function, use `methods()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Working with relational databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our web crawler is quite performant—using CSS selectors is very efficient. But,
    as it is right now, if we end up with the same Wikipedia article in different
    game sessions, we'll have to fetch it, parse it, and extract its contents multiple
    times. This is a time-consuming and resource-expensive operation—and, more importantly,
    one we can easily eliminate if we just store the article information once we fetch
    it the first time.
  prefs: []
  type: TYPE_NORMAL
- en: We could use Julia's serialization features, which we've already seen, but since
    we're building a fairly complex game, we would benefit from adding a database
    backend. Besides storing articles' data, we could also persist information about
    players, scores, preferences, and whatnot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen how to interact with MongoDB. In this case, though, a
    relational database is the better choice, as we''ll work with a series of related
    entities: articles, games (referencing articles), players (referencing games),
    and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia's package ecosystem provides a good range of options for interacting with
    relational databases, from generic ODBC and JDBC libraries to dedicated packages
    for the main backends—MySQL/MariaDB, SQLite, and Postgres, to name just a few.
    For our game, we'll use MySQL. If you don't already have MySQL installed on your
    system, please follow the instructions at [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/).
    Alternatively, if you're using Docker, you can get the official MySQL Docker image
    from [https://hub.docker.com/r/library/mysql/](https://hub.docker.com/r/library/mysql/).
  prefs: []
  type: TYPE_NORMAL
- en: 'On Julia''s side, `(sixdegrees) pkg>add MySQL` is all we need in order to add
    support for MySQL. Make sure you''re within the `sixdegrees/` project before adding
    MySQL. You can confirm this by looking at the prefix of the `pkg>` cursor; it
    should look like this: `(sixdegrees) pkg>`. If that is not the case, just execute
    `pkg> activate .` while making sure that you''re within the `sixdegrees/` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding MySQL support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with SQL databases, it's a good practice to abstract away the DB-related
    logic and to avoid littering all the codebase with SQL strings and database-specific
    commands. It will make our code more predictable and manageable and will provide
    a safe level of abstraction if we ever need to change or upgrade the database
    system. I'm a big fan of using ORM systems, but in this case, as a learning device,
    we'll be adding this functionality ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For starters, let''s instruct our application to connect to and disconnect
    from our MySQL database. Let''s extend our game by adding a new `Database` module
    within its corresponding file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `MySQL.connect` returns a connection object. We''ll need it in order
    to interact with the database, so we''ll reference it via the `CONN` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Since various parts of our code will access this connection object in order
    to perform queries against the database, we `export` it. Equally importantly,
    we need to set up some cleanup mechanism, to automatically disconnect from the
    database when we're done. We've defined a `disconnect` function that can be manually
    called. But, it's safer if we make sure that the cleanup function is automatically
    invoked. Julia provides an `atexit` function, which registers a zero-argument
    function `f` to be called at process exit. The `atexit` hooks are called in **last-in-first-out**
    (**LIFO**) order.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our Article module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to add a few more functions to the `Article` module to enable
    database persistence and retrieval functionality. Since it will need access to
    our DB connection object, let's give it access to the `Database` module. We'll
    also want to use `MySQL` functions. So, under the `export Article` line, add `using..Database,
    MySQL`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll add a `createtable` method. This will be a one-off function that
    will create the corresponding database table. We use this instead of just typing
    `CREATE TABLE` queries in the MySQL client, in order to have a consistent and
    reproducible way of (re)creating the table. In general, I prefer the use of a
    fully fledged database migration library, but for now, better to keep things simple
    (you can read about schema migrations at [https://en.wikipedia.org/wiki/Schema_migration](https://en.wikipedia.org/wiki/Schema_migration)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, here''s our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define an `sql` variable, which references the MySQL `CREATE TABLE`
    query, in the form of a `String`. The table will have four columns corresponding
    to the four fields of our `Article` type. Then, there's a fifth column, `url`,
    which will store the article's Wikipedia URL. We'll identify articles by URL—and
    for this reason, we add a unique index on the `url` column.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the function, we pass the query string to `MySQL.execute!` to
    be run against the DB connection. Please append the `createtable` definition to
    the end of the `Articles` module (within the module, above the closing `end`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see it in action. Open a new REPL session in the `sixdegrees/`
    folder and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: That's it, our table is ready!
  prefs: []
  type: TYPE_NORMAL
- en: The workflow should be pretty clear—we made sure we're loading our project's
    dependencies, we included the `Database.jl` and `Articles.jl` files, we brought
    `Articles` into scope, and then invoked its `createtable` method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the persistence and retrieval methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We said that when an article is fetched and parsed, we want to store its data
    in the database. Thus, before fetching an article, we'll first want to check our
    database. If the article was previously persisted, we'll retrieve it. If not,
    we'll perform the original fetch-and-parse workflow. We use the `url` property
    to uniquely identify articles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the `Articles.save(a::Article)` method for persisting
    an article object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `MySQL.Stmt` to create a MySQL prepared statement. The query itself
    is very simple, using MySQL's `INSERT IGNORE` statement, which makes sure that
    the `INSERT` operation is performed only if there is no article with the same
    `url`. If there is already an article with the same `url`, the query is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The prepared statement accepts a specially formatted query string, in which
    the actual values are replaced with placeholders, designated by question marks—`?`.
    We can then execute the prepared statement by passing it to `MySQL.execute!`,
    together with an array of corresponding values. The values are passed directly
    from the `article` object, with the exception of `links`. Since this represents
    a more complex data structure, a `Vector{String}`, we'll first serialize it using
    `JSON` and store it in MySQL as a string. To access functions from the `JSON`
    package, we'll have to add it to our project, so please execute `(sixdegrees)
    pkg> add JSON` in the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Prepared statements provide a safe way to execute queries because the values
    are automatically escaped, eliminating a common source of MySQL injection attacks.
    In our case, MySQL injections are less of a worry since we're not accepting user-generated
    input. But, the approach is still valuable, avoiding insert errors caused by improper
    escaping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a retrieval method. We''ll call it `find`. As its only attribute,
    it will take an article URL in the form of a `String`. It will return an `Array`
    of `Article` objects. By convention, if no corresponding article is found, the
    array will be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function''s declaration, we can see another Julia feature: return value
    types. After the regular function declaration, `function find(url)`, we appended
    `:: Vector{Article}`. This constrains the return value of `find` to an array of
    `Article`. If our function won''t return that, an error will be thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code, although very compact, has quite a lot of functionality.
    First, we create `articles`, a vector of `Article` objects, which will be the
    return value of our function. Then, we execute a `SELECT` query against the MySQL
    database through the `MySQL.query` method, attempting to find rows that match
    the `url`. The result of the query is stored in the `result` variable, which is
    a `NamedTuple` (each field in the `result` `NamedTuple` references an array of
    values corresponding to the database column of the same name). Next, we peek into
    our query `result` to see if we got anything—we chose to sample the `result.url`
    field—if it's empty, it means our query didn't find anything and we can just exit
    the function, returning an empty `articles` vector.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if `result.url` does contain entries, it means our query
    brought at least one row; so we iterate over the `result.url` array using `eachindex`,
    and for each iteration we construct an `Article` object with the corresponding
    values. Finally, we `push!` this new `Article` object into the `articles` vector
    which is returned, at the end of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we need to do is update the rest of the code to work with the
    changes we've made so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to update the `Article` type to add the extra `url` field.
    We need it in the list of fields and in the two constructors. Here is the final
    version of `Articles.jl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to make a few important changes to `Wikipedia.jl`. First, we''ll
    remove `Article` instantiation from `Wikipedia.articleinfo` since creating `Article`
    objects should now also take into account database persistence and retrieval.
    Instead, we''ll return a tuple representing the article data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add a new function, `persistedarticle`, which will accept as arguments
    the article content plus the article URL. It will instantiate a new `Article`
    object, save it to the database, and return it. In a way, `persistedarticle` can
    be considered a database-backed constructor, hence the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the *splat* operator `...` in action—it decomposes the `articleinfo`
    result `Tuple` into its corresponding elements so they can be passed into the
    `Article` constructor as individual arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have to deal with a minor complication. When we start a new game and
    call the `/wiki/Special:Random` URL, Wikipedia automatically performs a redirect
    to a random article. When we fetch the page, we get the redirected page content—but
    we don't have its URL.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to do two things. Firstly, we need to check if our request has been
    redirected and, if so, get the redirection URL. In order to do this, we can check
    the `request.parent` field of the `response` object. In the case of a redirect,
    the `response.request.parent` object will be set and will present a `headers`
    collection. The collection will include a `"Location"` item—and that's what we're
    after.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we also need to return the URL together with the HTML content of the
    page. This is easy—we'll return a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated `fetchpage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also use `eachmatch` to extract the part corresponding to the relative
    URL out of the absolute URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the whole `Wikipedia.jl` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s focus on `Gameplay.jl`. We need to update the `newgame` function
    to take advantage of the newly available methods from the `Wikipedia` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: If it's the first article, we fetch a random page and persist its data. Otherwise,
    we pick a random URL from the previously crawled page and check if a corresponding
    article already exists. If not, we fetch the page, making sure it's also persisted
    to the DB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, our point of entry into the app, the `six_degrees.jl` file, needs to
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'A final test run should confirm that all is good:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `six_degrees.jl` file with the `julia` binary in a terminal will
    output three Wikipedia article titles. And we can check the database to confirm
    that the data has been saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/468c724e-157a-4188-a63d-d722a5197c3e.png)'
  prefs: []
  type: TYPE_IMG
- en: The data for the three previously crawled pages has been safely persisted.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, this was quite a journey! We've learned about three key Julia
    concepts—modules, types and their constructors, and methods. We've applied all
    this knowledge to develop the backend of our *Six Degrees of Wikipedia* game,
    and in the process we've seen how to interact with MySQL databases, persisting
    and retrieving our `Article` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the next chapter, we''ll get the chance to enjoy the fruits of
    our hard work: after we add a web UI to our *Six degrees of Wikipedia* backend,
    we''ll relax by playing a few rounds. Let''s see if you can beat my best score!'
  prefs: []
  type: TYPE_NORMAL
