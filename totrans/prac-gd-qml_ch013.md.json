["```py\n\nfrom qiskit.opflow import Z \n\nfrom qiskit.algorithms import QAOA \n\nH1 = Z^Z # Define Z_0Z_1 \n\nqaoa = QAOA() \n\ncircuit = qaoa.construct_circuit([1,2],H1)[0] \n\ncircuit.draw(output=\"mpl\")\n\n```", "```py\n\ncircuit.decompose().decompose().draw(output=\"mpl\")\n\n```", "```py\n\nqaoa = QAOA(reps = 2) \n\ncircuit = qaoa.construct_circuit([1,2,3,4],H1)[0] \n\ncircuit.decompose().decompose().draw(output=\"mpl\")\n\n```", "```py\n\nfrom qiskit.utils import algorithm_globals, QuantumInstance \n\nfrom qiskit import Aer \n\nfrom qiskit.algorithms.optimizers import COBYLA \n\nseed = 1234 \n\nalgorithm_globals.random_seed = seed \n\nquantum_instance = QuantumInstance(Aer.get_backend(\"aer_simulator\"), \n\n                   seed_simulator=seed, seed_transpiler=seed, \n\n                   shots = 10) \n\nqaoa = QAOA(optimizer = COBYLA(), quantum_instance=quantum_instance) \n\nresult = qaoa.compute_minimum_eigenvalue(H1) \n\nprint(result)\n\n```", "```py\n\n{   ’aux_operator_eigenvalues’: None, \n\n    ’cost_function_evals’: 20, \n\n    ’eigenstate’: {’01’: 0.5477225575051661, ’10’: 0.8366600265340756}, \n\n    ’eigenvalue’: (-1+0j), \n\n    ’optimal_parameters’: { \n\n    ParameterVectorElement(@$\\gamma$@[0]): -0.847240391875931, \n\n    ParameterVectorElement(@$\\beta$@[0]): 6.7647519845416655}, \n\n    ’optimal_point’: array([ 6.76475198, -0.84724039]), \n\n    ’optimal_value’: -1.0, \n\n    ’optimizer_evals’: None, \n\n    ’optimizer_time’: 0.07764506340026855}\n\n```", "```py\n\nfrom qiskit import IBMQ \n\nprovider = IBMQ.load_account() \n\nprogram_id = \"qaoa\" \n\nH1 = Z^Z \n\nopt = COBYLA() \n\nreps = 1 \n\nshots = 1024 \n\nruntime_inputs = { \n\n    \"operator\": H1, \n\n    \"reps\": reps, \n\n    \"optimizer\": opt, \n\n    \"initial_point\": [0,0], \n\n    \"use_swap_strategies\": False \n\n} \n\noptions = {\"backend_name\": \"ibmq_belem\"} \n\njob = provider.runtime.run(program_id=program_id, \n\n      options=options, inputs=runtime_inputs)\n\n```", "```py\n\nresult = job.result() \n\nprint(\"Optimizer time\", result[’optimizer_time’]) \n\nprint(\"Optimal value\", result[’optimal_value’]) \n\nprint(\"Optimal point\", result[’optimal_point’]) \n\nprint(\"Optimal state\", result[’eigenstate’])\n\n```", "```py\n\nOptimizer time 88.11612486839294 \n\nOptimal value -0.84765625 \n\nOptimal point [0.42727683 2.39693691] \n\nOptimal state {’00’: 0.2576941016011038, ’01’: 0.691748238161833, \n\n               ’10’: 0.6584783595532961, ’11’: 0.14657549249448218}\n\n```", "```py\n\nfrom qiskit_optimization.problems import QuadraticProgram \n\nqp = QuadraticProgram() \n\nqp.binary_var(’x’) \n\nqp.binary_var(’y’) \n\nqp.binary_var(’z’) \n\nqp.minimize(linear = {’y’:-1}, quadratic = {(’x’,’y’):2, (’z’,’y’):-4}) \n\nqp.linear_constraint(linear = {’x’:1, ’y’:2, ’z’:3}, \n\n    sense =\"<=\", rhs = 5) \n\nprint(qp.export_as_lp_string())\n\n```", "```py\n\n\\ This file has been generated by DOcplex \n\n\\ ENCODING=ISO-8859-1 \n\n\\Problem name: CPLEX \n\nMinimize \n\n obj: - y + [ 4 x*y - 8 y*z ]/2 \n\nSubject To \n\n c0: x + 2 y + 3 z <= 5 \n\nBounds \n\n 0 <= x <= 1 \n\n 0 <= y <= 1 \n\n 0 <= z <= 1 \n\nBinaries \n\n x y z \n\nEnd\n\n```", "```py\n\nfrom qiskit_optimization.algorithms import MinimumEigenOptimizer \n\nfrom qiskit.algorithms import NumPyMinimumEigensolver \n\nnp_solver = NumPyMinimumEigensolver() \n\nnp_optimizer = MinimumEigenOptimizer(np_solver) \n\nresult = np_optimizer.solve(qp) \n\nprint(result)\n\n```", "```py\n\nfval=-5.0, x=0.0, y=1.0, z=1.0, status=SUCCESS\n\n```", "```py\n\nfrom qiskit import Aer \n\nfrom qiskit.algorithms import QAOA \n\nfrom qiskit.algorithms.optimizers import COBYLA \n\nfrom qiskit.utils import QuantumInstance \n\nquantum_instance = QuantumInstance(Aer.get_backend(\"aer_simulator\"), \n\n    shots = 1024) \n\nqaoa = QAOA(optimizer = COBYLA(), \n\n    quantum_instance=quantum_instance, reps = 1) \n\nqaoa_optimizer = MinimumEigenOptimizer(qaoa) \n\nresult = qaoa_optimizer.solve(qp) \n\nprint(result)\n\n```", "```py\n\nprint(’Variable order:’, [var.name for var in result.variables]) \n\nfor s in result.samples: \n\n    print(s)\n\n```", "```py\n\nVariable order: [’x’, ’y’, ’z’] \n\nSolutionSample(x=array([0., 1., 1.]), fval=-5.0, \n\nprobability=0.11621093749999999, status=<OptimizationResultStatus.SUCCESS: 0>) \n\nSolutionSample(x=array([0., 1., 0.]), fval=-1.0, \n\nprobability=0.107421875, status=<OptimizationResultStatus.SUCCESS: 0>) \n\nSolutionSample(x=array([1., 0., 1.]), fval=0.0, \n\nprobability=0.1494140625, status=<OptimizationResultStatus.SUCCESS: 0>) \n\nSolutionSample(x=array([0., 0., 1.]), fval=0.0, \n\nprobability=0.1103515625, status=<OptimizationResultStatus.SUCCESS: 0>) \n\nSolutionSample(x=array([1., 0., 0.]), fval=0.0, \n\nprobability=0.103515625, status=<OptimizationResultStatus.SUCCESS: 0>) \n\nSolutionSample(x=array([0., 0., 0.]), fval=0.0, \n\nprobability=0.1416015625, status=<OptimizationResultStatus.SUCCESS: 0>) \n\nSolutionSample(x=array([1., 1., 0.]), fval=1.0, \n\nprobability=0.13769531249999997, status=<OptimizationResultStatus.SUCCESS: 0>) \n\nSolutionSample(x=array([1., 1., 1.]), fval=-3.0, \n\nprobability=0.1337890625, status=<OptimizationResultStatus.INFEASIBLE: 2>)\n\n```", "```py\n\nprint(result.min_eigen_solver_result)\n\n```", "```py\n\n{   ’aux_operator_eigenvalues’: None, \n\n    ’cost_function_evals’: 32, \n\n    ’eigenstate’: {   ’000000’: 0.09375, \n\n                      ’000001’: 0.03125, \n\n                      ’000010’: 0.05412658773652741, \n\n                      [.....] \n\n                      ’111101’: 0.11692679333668567, \n\n                      ’111110’: 0.08838834764831845, \n\n                      ’111111’: 0.07654655446197431}, \n\n    ’eigenvalue’: (-14.7548828125+0j), \n\n    ’optimal_parameters’: { \n\n    ParameterVectorElement(@$\\gamma$@[0]): -5.087643335935586, \n\n    ParameterVectorElement(@$\\beta$@[0]): -0.24590437874189125}, \n\n    ’optimal_point’: array([-0.24590438, -5.08764334]), \n\n    ’optimal_value’: -14.7548828125, \n\n    ’optimizer_evals’: None, \n\n    ’optimizer_time’: 0.6570718288421631}\n\n```", "```py\n\nfrom qiskit_optimization.converters import QuadraticProgramToQubo \n\nqp_to_qubo = QuadraticProgramToQubo() \n\nqubo = qp_to_qubo.convert(qp) \n\nprint(qubo.export_as_lp_string())\n\n```", "```py\n\n\\ This file has been generated by DOcplex \n\n\\ ENCODING=ISO-8859-1 \n\n\\Problem name: CPLEX \n\nMinimize \n\n obj: - 80 x - 161 y - 240 z - 80 c0@int_slack@0 - 160 c0@int_slack@1 \n\n      - 160 c0@int_slack@2 + [ 16 x^2 + 68 x*y + 96 x*z + \n\n      32 x*c0@int_slack@0 + 64 x*c0@int_slack@1 + 64 x*c0@int_slack@2 \n\n      + 64 y^2 + 184 y*z + 64 y*c0@int_slack@0 + 128 y*c0@int_slack@1 \n\n      + 128 y*c0@int_slack@2 + 144 z^2 + 96 z*c0@int_slack@0 \n\n      + 192 z*c0@int_slack@1 + 192 z*c0@int_slack@2 \n\n      + 16 c0@int_slack@0^2 + 64 c0@int_slack@0*c0@int_slack@1 \n\n      + 64 c0@int_slack@0*c0@int_slack@2 + 64 c0@int_slack@1^2 \n\n      + 128 c0@int_slack@1*c0@int_slack@2 + 64 c0@int_slack@2^2 ]/2 \n\n      + 200 \n\nSubject To \n\nBounds \n\n 0 <= x <= 1 \n\n 0 <= y <= 1 \n\n 0 <= z <= 1 \n\n 0 <= c0@int_slack@0 <= 1 \n\n 0 <= c0@int_slack@1 <= 1 \n\n 0 <= c0@int_slack@2 <= 1 \n\nBinaries \n\n x y z c0@int_slack@0 c0@int_slack@1 c0@int_slack@2 \n\nEnd\n\n```", "```py\n\nH1, offset = qubo.to_ising() \n\nprint(\"The Hamiltonian is\", H1) \n\nprint(\"The constant term is\", offset)\n\n```", "```py\n\nfrom qiskit_optimization.runtime import QAOAClient \n\nfrom qiskit import IBMQ \n\nprovider = IBMQ.load_account() \n\nqaoa_client = QAOAClient(provider=provider, \n\n                      backend=provider.get_backend(\"ibm_oslo\"), reps=1) \n\nqaoa = MinimumEigenOptimizer(qaoa_client) \n\nresult = qaoa.solve(qp) \n\nprint(result)\n\n```", "```py\n\nfval=-5.0, x=0.0, y=1.0, z=1.0, status=SUCCESS\n\n```", "```py\n\nimport pennylane as qml \n\nfrom pennylane import PauliZ \n\ncoefficients = [2,-1,3.5] \n\npaulis = [PauliZ(0)@PauliZ(1),PauliZ(0)@PauliZ(2),PauliZ(1)] \n\nH = qml.Hamiltonian(coefficients,paulis) \n\nprint(H)\n\n```", "```py\n\n(3.5) [Z1] \n\n+ (-1) [Z0 Z2] \n\n+ (2) [Z0 Z1]\n\n```", "```py\n\n[[4.5+0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j] \n\n [0\\. +0.j  6.5+0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j] \n\n [0\\. +0.j  0\\. +0.j -6.5+0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j] \n\n [0\\. +0.j  0\\. +0.j  0\\. +0.j -4.5+0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j] \n\n [0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  2.5+0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j] \n\n [0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0.5+0.j  0\\. +0.j  0\\. +0.j] \n\n [0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j -0.5+0.j  0\\. +0.j] \n\n [0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j  0\\. +0.j -2.5+0.j]]\n\n```", "```py\n\nfrom pennylane.utils import sparse_hamiltonian \n\nprint(sparse_hamiltonian(H))\n\n```", "```py\n\n  (0, 0)    (4.5+0j) \n\n  (1, 1)    (6.5+0j) \n\n  (2, 2)    (-6.5+0j) \n\n  (3, 3)    (-4.5+0j) \n\n  (4, 4)    (2.5+0j) \n\n  (5, 5)    (0.5+0j) \n\n  (6, 6)    (-0.5+0j) \n\n  (7, 7)    (-2.5+0j)\n\n```", "```py\n\nH = 2*PauliZ(0)@PauliZ(1) - PauliZ(0)@PauliZ(2) +3.5*PauliZ(1)\n\n```", "```py\n\nfrom pennylane import qaoa \n\nH0 = qml.PauliX(0) + qml.PauliX(1) \n\nH1 = 1.0*qml.PauliZ(0) @ qml.PauliZ(1) \n\nwires = range(2) \n\ndev = qml.device(\"default.qubit\", wires=wires) \n\np = 2 \n\n@qml.qnode(dev) \n\ndef energy(angles): \n\n    for w in wires: \n\n        qml.Hadamard(wires=w) \n\n    for i in range(p): \n\n        qaoa.cost_layer(angles[2*i+1], H1) \n\n        qaoa.mixer_layer(angles[2*i], H0) \n\n    return qml.expval(H1)\n\n```", "```py\n\nfrom pennylane import numpy as np \n\noptimizer = qml.GradientDescentOptimizer() \n\nsteps = 20 \n\nangles = np.array([1,1,1,1], requires_grad=True) \n\nfor i in range(steps): \n\n    angles = optimizer.step(energy, angles) \n\nprint(\"Optimal angles\", angles)\n\n```", "```py\n\n@qml.qnode(dev) \n\ndef sample_solutions(angles): \n\n    for w in wires: \n\n        qml.Hadamard(wires=w) \n\n    for i in range(p): \n\n        qaoa.cost_layer(angles[2*i+1], H1) \n\n        qaoa.mixer_layer(angles[2*i], H0) \n\n    return qml.sample() \n\nprint(sample_solutions(angles, shots = 5))\n\n```", "```py\n\n[[0 1] \n\n [0 1] \n\n [0 1] \n\n [1 0] \n\n [0 1]]\n\n```"]