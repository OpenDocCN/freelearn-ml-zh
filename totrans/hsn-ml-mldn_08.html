<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Anomaly Detection Model</h1>
                </header>
            
            <article>
                
<p>With k-means clustering models behind us, it is now time to dive into anomaly detection models. Anomaly detection is one of the newer additions to ML.NET, and specifically, time-series transforms. In this chapter, we will dive into anomaly detection and the various applications best suited to utilizing anomaly detection. In addition, we will build two new example applications: one anomaly detection application that determines whether the login attempt is abnormally demonstrating the randomized PCA trainer, and one that demonstrates time series in a network traffic anomaly detection application. Finally, we will explore how to evaluate an anomaly detection model with the properties that ML.NET exposes.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Breaking down anomaly detection</li>
<li>Creating a time series application</li>
<li>Creating an anomaly detection application</li>
<li><span>Evaluating an anomaly detection</span><span> </span><span>model</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking down anomaly detection</h1>
                </header>
            
            <article>
                
<p>As<span> </span>mentioned in<span> </span><a href="b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml">Chapter 1</a>, <em>Getting Started with Machine Learning and ML.NET,</em><span> </span>anomaly detection, by definition, is an unsupervised learning algorithm. This means that the algorithm will train on data and look for data that does not fit the normal data. In this section, we will dive into use cases for anomaly detection and into the various trainers available for anomaly detection in ML.NET.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use cases for anomaly detection</h1>
                </header>
            
            <article>
                
<p>Anomaly detection, as you might have realized already, has numerous applications where data is available but it is unknown whether there is an anomaly in the data. Without needing to do manual spot-checking, anomaly detection algorithms train on this data and determine whether there are any anomalies. ML.NET provides various anomaly detection values to look at programmatically inside of your application. We will review these values later on in this chapter to better ensure that any detection is not a false positive.</p>
<p>Some of the potential applications best suited for anomaly detection include the following:</p>
<ul>
<li>Sales forecasting</li>
<li>Stock market</li>
<li><span>Fraud detection</span></li>
<li>Anticipating the failure of a device due to various factors</li>
<li>Cyber-security applications for remote connections and network traffic login history, such as the example application that we will dive into later</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the randomized PCA trainer</h1>
                </header>
            
            <article>
                
<p>The randomized PCA trainer is the only traditional trainer for anomaly detection found in ML.NET at the time of writing. The randomized PCA trainer requires normalization of the values; however, caching is not necessary and no additional NuGet packages are required to utilize the trainer.</p>
<p>Similar to other algorithms, the input is a known vector size of the <kbd>Float</kbd> type. The output comprises two properties: <kbd>Score</kbd> and <kbd>PredictedLabel</kbd>. The <kbd>Score</kbd> value is of the <kbd>Float</kbd> type, non-negative, and unbounded. In contrast, the <kbd>PredictedLabel</kbd> property indicates a valid anomaly based on the threshold set; a value of true indicates an anomaly, while a value of false indicates otherwise. ML.NET's default threshold is 0.5, which can be adjusted via the <kbd>ChangeModelThreshold</kbd> method. Effectively, values higher than the threshold return true, and false if they are lower.</p>
<p>Under the hood, the algorithm uses eigenvectors to estimate the subspace containing the normal class and then computes the normalized difference between the actual feature vector and the projected feature vector in that subspace. Put simply, the algorithm finds edge cases if the computed error is not close to 0. If it finds the error is close to 0, it is considered a normal data point (that is, a non-anomaly).</p>
<p>We will demonstrate this trainer in the second example application later on in this chapter, by detecting login anomalies.</p>
<div class="packt_tip">If you would like to deep dive further into randomized PCA, the following paper is a great resource: <a href="https://web.stanford.edu/group/mmds/slides2010/Martinsson.pdf">https://web.stanford.edu/group/mmds/slides2010/Martinsson.pdf</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into time series transforms</h1>
                </header>
            
            <article>
                
<p>Unlike other algorithms found in this book and ML.NET itself, time series support was added as a series of transforms to be applied to your training and test data. Time series, as mentioned previously, is also one of the newer additions to ML.NET, being added in 1.2.0.</p>
<p>In ML.NET, times series transforms are grouped into the <kbd>TimeSeriesCatalog</kbd> class. There are six different methods i<span>nside this class</span>:</p>
<ul>
<li><kbd>DetectAnomalyBySrCnn</kbd>: Detects anomalies with the SRCNN algorithm</li>
<li><kbd>DetectChangePointBySsa</kbd>: Detects anomalies with the <strong>Singular Spectrum Analysis</strong> (<strong>SSA</strong>) algorithm on change points</li>
<li><kbd>DetectIidChangePoint</kbd>: Detects changes to predict change points with an <strong>independent identically distributed</strong> (<strong>i.i.d</strong>) algorithm</li>
<li><kbd>DetectIidSpike</kbd><span>:</span> Detects changes with an i.i.d algorithm but predicts spikes instead of change points</li>
<li><kbd>DetectSpikeBySsa</kbd><span>:</span> Detects spikes using the SSA algorithm</li>
<li><kbd>ForecastBySsa</kbd><span>:</span> Uses the SSA algorithm for a singular variable- (commonly referred to as univariate-) based time series forecasting</li>
</ul>
<p>Depending on the application, you may want to look for spikes of data changes or points of change (on the upward or downward spiral). In this chapter's example on time series, we will be looking for spikes in network transfer over time utilizing <kbd>DetectSpikeBySsa</kbd>.</p>
<div class="packt_infobox">For more information on forecasting with SSA, a great resource can be found here: <a href="http://arxiv.org/pdf/1206.6910.pdf">http://arxiv.org/pdf/1206.6910.pdf</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a time series application</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the application we will be creating is a network traffic anomaly detector. Given a set of attributes relating to the network traffic amount (in bytes), the application will use that data to find anomalies in the amount of traffic for a given checkpoint. As with other applications, this is not meant to power the next ML network traffic anomaly detection product; however, it will show you how to use time series in ML.NET, specifically to detect spikes with SSA.</p>
<p>As with previous chapters, the completed project code, sample dataset, and project files can be downloaded here: <a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter06-time-series">https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter06-time-series</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the project architecture</h1>
                </header>
            
            <article>
                
<p>Building on the project architecture and code we created in previous chapters, the bulk of the changes are in the training of the model as time series requires a fairly significant paradigm shift from what we have reviewed in previous chapters. In addition to this, when using time series transforms, you will need to add the <kbd>Microsoft.ML.TimeSeries</kbd> NuGet package if you are creating a project from scratch. The example application available in the GitHub repository has this package already included.</p>
<p>In the following screenshot, you will find the Visual Studio Solution Explorer view of the project. The new additions to the solution are the <kbd>NetworkTrafficHistory</kbd><strong> </strong>and <kbd>NetworkTrafficPrediction</kbd><strong> </strong>files, which we will review later on in this section:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-625 image-border" src="assets/7800d9bf-46b4-4f78-bcb1-582760156732.png" style="width:21.17em;height:28.42em;"/></p>
<p>The<span> </span><kbd>sampledata.csv</kbd> file contains eight rows of network traffic data. Feel free to adjust the data to fit your own observations or to adjust the trained model. Here is a snippet of the data:</p>
<div>
<pre>laptop,2019-11-14T11:13:23,1500<br/>laptop,2019-11-15T11:13:23,1000<br/>laptop,2019-11-16T11:13:23,1100<br/>laptop,2019-11-17T11:13:23,1600<br/>laptop,2019-11-18T11:13:23,1000<br/>laptop,2019-11-19T11:13:23,1100<br/>laptop,2019-11-20T11:13:23,1000<br/>laptop,2019-11-21T11:13:23,1000</pre></div>
<p>Each of these rows contains the values for the properties in the newly created <kbd>NetworkTrafficHistory</kbd><strong> </strong>class, which we will review later on in this chapter.</p>
<p>In addition to this, we have added the <kbd>testdata.csv</kbd> file, which contains additional data points to test the newly trained model<span> </span>against and evaluate. Here is a snippet of the data inside of <kbd>testdata.csv</kbd>:</p>
<pre>laptop,2019-11-22T11:13:23,1000<br/>laptop,2019-11-23T11:13:23,1100<br/>laptop,2019-11-24T11:13:23,1200<br/>laptop,2019-11-25T11:13:23,1300<br/>laptop,2019-11-26T11:13:23,1400<br/>laptop,2019-11-27T11:13:23,3000<br/>laptop,2019-11-28T11:13:23,1500<br/>laptop,2019-11-29T11:13:23,1600</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the code</h1>
                </header>
            
            <article>
                
<p>For this application, as noted in the previous section, we are building on top of the work<span> </span>completed in <a href="4c32e261-cec6-4113-9734-1e29c7c18f9a.xhtml">Chapter 5</a><span>, </span><em><span>Clustering Model</span></em>. For this deep dive, we are going to focus solely on the code that was changed for this application.</p>
<p>Classes that were changed or added are as follows:</p>
<ul>
<li><kbd>NetworkTrafficHistory</kbd></li>
<li><kbd>NetworkTrafficPrediction</kbd></li>
<li><kbd>Predictor</kbd></li>
<li><kbd>Trainer</kbd></li>
<li><kbd>Program</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NetworkTrafficHistory class</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>NetworkTrafficHistory</kbd><strong> </strong>class is the container class that contains the data to both predict and train our model. As described in previous chapters, the number in the <kbd>LoadColumn</kbd><span> </span>decorator maps to the index in the CSV files. As noted earlier, anomaly detection in ML.NET requires the use of a single floating-point value; in this case, it is the <kbd>BytesTransferred</kbd> property:</p>
<pre>using System;<br/><br/>using Microsoft.ML.Data;<br/><br/>namespace chapter06.ML.Objects<br/>{<br/>    public class NetworkTrafficHistory<br/>    {<br/>        [LoadColumn(0)]<br/>        public string HostMachine { get; set; }<br/><br/>        [LoadColumn(1)]<br/>        public DateTime Timestamp { get; set; }<br/><br/>        [LoadColumn(2)] <br/>        public float BytesTransferred { get; set; }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NetworkTrafficPrediction class</h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>NetworkTrafficPrediction</kbd><strong> </strong>class contains the properties mapped to our prediction output. The <kbd>VectorType(3)</kbd> function holds the alert, score, and p-value. We will review these values later on in this section:</p>
<div>
<pre>using Microsoft.ML.Data;<br/><br/>namespace chapter06.ML.Objects<br/>{<br/>    public class NetworkTrafficPrediction<br/>    {<br/>        [VectorType(3)]<br/>        public double[] Prediction { get; set; }<br/>    }<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Predictor class</h1>
                </header>
            
            <article>
                
<p>There are a couple of changes to make to this class in order to handle the network traffic prediction scenario:</p>
<ol>
<li>First,<span> we create our prediction engine with the <kbd>NetworkTrafficHistory</kbd><strong> </strong>and <kbd>NetworkHistoryPrediction</kbd> types:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">var predictionEngine = MlContext.Model.CreatePredictionEngine&lt;NetworkTrafficHistory, NetworkTrafficPrediction&gt;(mlModel);</pre></div>
<ol start="2">
<li>Next, we read the input file into an <kbd>IDataView</kbd> variable (note the override to use a comma as <kbd>separatorChar</kbd>):</li>
</ol>
<div>
<pre style="padding-left: 60px">var inputData = MlContext.Data.LoadFromTextFile&lt;NetworkTrafficHistory&gt;(inputDataFile, separatorChar: ',');</pre></div>
<ol start="3">
<li>Next, we take the newly created <kbd>IDataView</kbd> variable and get an enumerable based off of that data view:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">var rows = MlContext.Data.CreateEnumerable&lt;NetworkTrafficHistory&gt;(inputData, false);</pre>
<ol start="3">
<li style="list-style-type: none">
<ol start="2"/>
</li>
<li>L<span>astly, we need to run the prediction and then output the results of the model run</span><span>:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">Console.WriteLine($"Based on input file ({inputDataFile}):");<br/><br/>foreach (var row in rows)<br/>{<br/>    var prediction = predictionEngine.Predict(row);<br/><br/>    Console.Write($"HOST: {row.HostMachine} TIMESTAMP: {row.Timestamp} TRANSFER: {row.BytesTransferred} ");<br/>    Console.Write($"ALERT: {prediction.Prediction[0]} SCORE: {prediction.Prediction[1]:f2} P-VALUE: {prediction.Prediction[2]:F2}{Environment.NewLine}");<br/>}</pre></div>
<p>With <kbd>Transform</kbd> only returning the three-element vector, the original row data is output to give context.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Trainer class</h1>
                </header>
            
            <article>
                
<p>Inside the <kbd>Trainer</kbd> class, several modifications need to be made to support the time series transform. In many ways, a simplification is required. The removal of the evaluation and testing data load is performed:</p>
<ol>
<li>The first addition is of the four variables to send to the transform:</li>
</ol>
<div>
<pre style="padding-left: 60px">private const int PvalueHistoryLength = 3;<br/>private const int SeasonalityWindowSize = 3;<br/>private const int TrainingWindowSize = 7;<br/>private const int Confidence = 98;</pre></div>
<div class="packt_tip">The training window size must be greater than twice the p-value history length due to a constraint in the ML.NET library at the time of writing.</div>
<ol start="2">
<li>We then build the <kbd>DataView</kbd> object from the CSV training file:</li>
</ol>
<div>
<pre style="padding-left: 60px">var trainingDataView = GetDataView(trainingFileName);</pre></div>
<ol start="3">
<li>We can then create SSA spike detection:</li>
</ol>
<div>
<pre style="padding-left: 60px">var trainingPipeLine = MlContext.Transforms.DetectSpikeBySsa(<br/>    nameof(NetworkTrafficPrediction.Prediction),<br/>    nameof(NetworkTrafficHistory.BytesTransferred),<br/>    confidence: Confidence,<br/>    pvalueHistoryLength: PvalueHistoryLength,<br/>    trainingWindowSize: TrainingWindowSize,<br/>    seasonalityWindowSize: SeasonalityWindowSize);</pre></div>
<ol start="4">
<li>Now, we fit the model on the training data and save the model:</li>
</ol>
<pre style="padding-left: 60px">ITransformer trainedModel = trainingPipeLine.Fit(trainingDataView);<br/><br/>MlContext.Model.Save(trainedModel, trainingDataView.Schema, ModelPath);<br/><br/>Console.WriteLine("Model trained");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Program class</h1>
                </header>
            
            <article>
                
<p><span>Given that the training only requires the training data, some modifications to the <kbd>Program</kbd> class have to be performed:</span></p>
<ol>
<li>The help text needs to be updated to reflect the new usage:</li>
</ol>
<div>
<pre style="padding-left: 60px">if (args.Length &lt; 2)<br/>{<br/>    Console.WriteLine($"Invalid arguments passed in, exiting.{Environment.NewLine}{Environment.NewLine}Usage:{Environment.NewLine}" +<br/>                      $"predict &lt;path to input file&gt;{Environment.NewLine}" +<br/>                      $"or {Environment.NewLine}" +<br/>                      $"train &lt;path to training data file&gt;{Environment.NewLine}");<br/><br/>    return;<br/>}</pre></div>
<ol start="2">
<li>In addition, the switch case statement needs to be updated to reflect the single argument passed for the prediction:</li>
</ol>
<div>
<pre style="padding-left: 60px">switch (args[0])<br/>{<br/>    case "predict":<br/>        new Predictor().Predict(args[1]);<br/>        break;<br/>    case "train":<br/>        new Trainer().Train(args[1]);<br/>        break;<br/>    default:<br/>        Console.WriteLine($"{args[0]} is an invalid option");<br/>        break;<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p><span>To run the application, the process we use is nearly identical to <a href="8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml">Chapter 3</a>, <em>Regression Model</em>'s example application:</span></p>
<ol>
<li>After preparing the data, we must train the model by passing in the newly created<span> </span><kbd>sampledata.csv</kbd> file:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS chapter06-time-series\bin\Debug\netcoreapp3.0&gt; .\chapter06-time-series.exe train ..\..\..\Data\sampledata.csv</strong><br/>Model trained</pre></div>
<ol start="2">
<li>To run the model with this file, simply pass in the <kbd>testdata.csv</kbd> file<strong> </strong>mentioned earlier into the newly built application, and the predicted output will show the following:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS bin\debug\netcoreapp3.0&gt; .\chapter06-time-series.exe predict ..\..\..\Data\testdata.csv</strong><br/>Based on input file (..\..\..\Data\testdata.csv):<br/>HOST: laptop TIMESTAMP: 11/22/2019 11:13:23 AM TRANSFER: 1000 ALERT: 0 SCORE: 46.07 P-VALUE: 0.50<br/>HOST: laptop TIMESTAMP: 11/23/2019 11:13:23 AM TRANSFER: 1100 ALERT: 0 SCORE: 131.36 P-VALUE: 0.00<br/>HOST: laptop TIMESTAMP: 11/24/2019 11:13:23 AM TRANSFER: 1200 ALERT: 0 SCORE: 180.44 P-VALUE: 0.06<br/>HOST: laptop TIMESTAMP: 11/25/2019 11:13:23 AM TRANSFER: 1300 ALERT: 0 SCORE: 195.42 P-VALUE: 0.17<br/>HOST: laptop TIMESTAMP: 11/26/2019 11:13:23 AM TRANSFER: 1400 ALERT: 0 SCORE: 201.15 P-VALUE: 0.22<br/>HOST: laptop TIMESTAMP: 11/27/2019 11:13:23 AM TRANSFER: 3000 ALERT: 1 SCORE: 1365.42 P-VALUE: 0.00<br/>HOST: laptop TIMESTAMP: 11/28/2019 11:13:23 AM TRANSFER: 1500 ALERT: 0 SCORE: -324.58 P-VALUE: 0.11<br/>HOST: laptop TIMESTAMP: 11/29/2019 11:13:23 AM TRANSFER: 1600 ALERT: 0 SCORE: -312.93 P-VALUE: 0.25</pre></div>
<p>The output includes the three data points: <kbd>HOST</kbd>, <kbd>TIMESTAMP</kbd>, and <kbd>TRANSFER</kbd>. The new additions are <kbd>ALERT</kbd>, <kbd>SCORE</kbd>, and <kbd>P-VALUE</kbd>. <kbd><span><span>ALERT</span></span></kbd> values of nonzero indicate an anomaly. <kbd>SCORE</kbd> is a numeric representation of the anomaly score; a higher value indicates a spike. <kbd>P-VALUE</kbd>, a value between 0 and 1, is the distance between the current point and the average point. A value closer or equal to 0 is another indication of a spike. When evaluating your model and efficacy, using these three data points together you can be guaranteed a true spike, effectively reducing the potential false positive count.</p>
<p>Feel free to modify the values and explore how the prediction changes based on the dataset that the model was trained on. A few areas of experimentation from this point might be as follows:</p>
<ul>
<li>Adding more specific data points such as an IP address</li>
<li>Adding diversification and more data points to the training and test data</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an anomaly detection application</h1>
                </header>
            
            <article>
                
<p>As mentioned earlier, the application we will be creating is a login anomaly detector. Given a set of attributes relating to the login, the application will use that data to find anomalies such as unusual login <span>times</span>. As with other applications, this is not meant to power the next ML login anomaly detection product; however, it will show you how to use anomaly detection in ML.NET.</p>
<p>As with previous chapters, the completed project code, sample dataset, and project files can be downloaded here: <a href="https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter06">https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter06</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the project architecture</h1>
                </header>
            
            <article>
                
<p>Building on the project architecture and code we created in previous chapters, the bulk of the changes in this example are in the training of the model.</p>
<p>In the following screenshot, you will find the Visual Studio Solution Explorer view of the project. The new additions to the solution are the<span> </span><kbd>LoginHistory </kbd>and<span> </span><kbd>LoginPrediction</kbd><span> </span>files, which we will review later on in this section:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-626 image-border" src="assets/2264ca20-b60c-44c8-9b34-ede53f39ca3d.png" style="width:16.42em;height:27.58em;"/></p>
<p>The<span> </span><kbd>sampledata.csv</kbd> file contains 10 rows of login data. Feel free to adjust the data to fit your own observations or to adjust the trained model. Here is a snippet of the data:</p>
<div>
<pre>0,1,0,1,1,0<br/>0,1,0,1,1,0<br/>0,0,1,0,1,0<br/>0,0,1,0,1,0<br/>0,0,1,1,0,1<br/>1,1,0,1,1,0<br/>1,1,0,1,1,0<br/>1,0,1,0,1,0<br/>1,0,1,0,1,1<br/>1,0,1,1,0,0</pre></div>
<p>Each of these rows contains the values for the properties in the newly created <kbd>LoginHistory</kbd> class, which we will review later on in this chapter.</p>
<p>In addition to this, we added the <kbd>testdata.csv</kbd> file, which contains additional data points to test the newly trained model<span> </span>against and evaluate. Here is a snippet of the data inside of <kbd>testdata.csv</kbd>:</p>
<pre>0,1,0,1,1,0<br/>0,1,0,1,1,0<br/>0,0,1,0,1,0<br/>0,0,1,0,1,0<br/>0,0,1,1,0,1<br/>1,1,0,1,1,0<br/>1,1,0,1,1,0<br/>1,0,1,0,1,0<br/>1,0,1,0,1,1<br/>1,0,1,1,0,0</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Diving into the code</h1>
                </header>
            
            <article>
                
<p>For this application, as noted in the previous section, we are building on top of the work<span> </span>completed in <a href="4c32e261-cec6-4113-9734-1e29c7c18f9a.xhtml">Chapter 5</a>, <em>Clustering Model</em>. For this deep dive, we are going to focus solely on the code that was changed for this application.</p>
<p>Classes that were changed or added are as follows:</p>
<ul>
<li><kbd>Constants</kbd></li>
<li><kbd>LoginHistory</kbd></li>
<li><kbd>LoginPrediction</kbd></li>
<li><kbd>Predictor</kbd></li>
<li><kbd>Trainer</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Constants class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Constants</kbd> class has been changed<span> </span>to save the model to<span> </span><kbd>chapter6.mdl</kbd>. The following code block reflects these changes:</p>
<pre>namespace chapter06.Common<br/>{<br/>    public class Constants<br/>    {<br/>        public const string MODEL_FILENAME = "chapter6.mdl";<br/><br/>        public const string SAMPLE_DATA = "sampledata.csv";<br/><br/>        public const string TEST_DATA = "testdata.csv";<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The LoginHistory class</h1>
                </header>
            
            <article>
                
<p>The <kbd>LoginHistory</kbd><strong> </strong>class is the container class that contains the data to both predict and train our model. As described in previous chapters, the number in the <kbd>LoadColumn</kbd> decorator maps to the index in the CSV files. Each property maps to a value that will be sent into the model for anomaly detection:</p>
<pre>using Microsoft.ML.Data;<br/><br/>namespace chapter06.ML.Objects<br/>{<br/>    public class LoginHistory<br/>    {<br/>        [LoadColumn(0)]<br/>        public float UserID { get; set; }<br/><br/>        [LoadColumn(1)]<br/>        public float CorporateNetwork { get; set; }<br/><br/>        [LoadColumn(2)] <br/>        public float HomeNetwork { get; set; }<br/><br/>        [LoadColumn(3)] <br/>        public float WithinWorkHours { get; set; }<br/><br/>        [LoadColumn(4)] <br/>        public float WorkDay { get; set; }<br/><br/>        [LoadColumn(5)] <br/>        public float Label { get; set; }<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The LoginPrediction class</h1>
                </header>
            
            <article>
                
<p>The <kbd>LoginPrediction</kbd><strong> </strong>class contains the properties mapped to our prediction output. The following <kbd>PredictedLabel</kbd> property will hold our prediction, while the <kbd>Label</kbd> and <kbd>Score</kbd> properties are used for evaluation:</p>
<div>
<pre>namespace chapter06.ML.Objects<br/>{<br/>    public class LoginPrediction<br/>    {<br/>        public float Label;<br/><br/>        public float Score;<br/><br/>        public bool PredictedLabel;<br/>    }<br/>}</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Predictor class</h1>
                </header>
            
            <article>
                
<p>There are a couple of changes to make to this class in order <span>to</span> <span>handle the</span> <kbd>Login</kbd> <span>anomaly detection scenario:</span></p>
<ol>
<li>First,<span> we create our prediction engine with the <kbd>LoginHistory</kbd><strong> </strong>and <kbd>LoginPrediction</kbd> types:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">var predictionEngine = MlContext.Model.CreatePredictionEngine&lt;LoginHistory, LoginPrediction&gt;(mlModel);     </pre></div>
<ol start="2">
<li>Next, we read the input file into a string variable:</li>
</ol>
<div>
<pre style="padding-left: 60px">var json = File.ReadAllText(inputDataFile);</pre></div>
<ol start="3">
<li>L<span>astly, we run the prediction and then output the results of the model run</span><span>:</span></li>
</ol>
<div>
<pre style="padding-left: 60px">var prediction = predictionEngine.Predict(JsonConvert.DeserializeObject&lt;LoginHistory&gt;(json));<br/><br/>Console.WriteLine(<br/>                    $"Based on input json:{System.Environment.NewLine}" +<br/>                    $"{json}{System.Environment.NewLine}" + <br/>                    $"The login history is {(prediction.PredictedLabel ? "abnormal" : "normal")}, with a {prediction.Score:F2} outlier score");</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Trainer class</h1>
                </header>
            
            <article>
                
<p>Inside the <kbd>Trainer</kbd> class, several modifications need to be made to support anomaly detection classification using the randomized PCA trainer:</p>
<ol>
<li>The first change is the addition of a <kbd>GetDataView</kbd> helper method, which builds the <kbd>IDataView</kbd> <span>data view </span>from the columns previously defined in the <kbd>LoginHistory</kbd> class:</li>
</ol>
<div>
<pre style="padding-left: 60px">private (IDataView DataView, IEstimator&lt;ITransformer&gt; Transformer) GetDataView(string fileName, bool training = true)<br/>{<br/>    var trainingDataView = MlContext.Data.LoadFromTextFile&lt;LoginHistory&gt;(fileName, ',');<br/><br/>    if (!training)<br/>    {<br/>        return (trainingDataView, null);<br/>    }<br/><br/>    IEstimator&lt;ITransformer&gt; dataProcessPipeline = MlContext.Transforms.Concatenate(<br/>        FEATURES, <br/>        typeof(LoginHistory).ToPropertyList&lt;LoginHistory&gt;(nameof(LoginHistory.Label)));<br/><br/>    return (trainingDataView, dataProcessPipeline);<br/>}</pre></div>
<ol start="2">
<li>We then build the training data view and the <kbd>RandomizedPcaTrainer.Options</kbd> object:</li>
</ol>
<div>
<pre style="padding-left: 60px">var trainingDataView = GetDataView(trainingFileName);<br/><br/>var options = new RandomizedPcaTrainer.Options<br/>{<br/>    FeatureColumnName = FEATURES,<br/>    ExampleWeightColumnName = null,<br/>    Rank = 5,<br/>    Oversampling = 20,<br/>    EnsureZeroMean = true,<br/>    Seed = 1<br/>};<br/><br/></pre></div>
<div class="packt_tip packt_infobox">Note that the <kbd>Rank</kbd> property must be equal to or less than the features.</div>
<ol start="3">
<li>We can then create the randomized PCA trainer, append it to the training data view, fit our model, and then save it:</li>
</ol>
<div>
<pre style="padding-left: 60px">IEstimator&lt;ITransformer&gt; trainer = MlContext.AnomalyDetection.Trainers.RandomizedPca(options: options);<br/><br/>EstimatorChain&lt;ITransformer&gt; trainingPipeline = trainingDataView.Transformer.Append(trainer);<br/><br/>TransformerChain&lt;ITransformer&gt; trainedModel = trainingPipeline.Fit(trainingDataView.DataView);<br/><br/>MlContext.Model.Save(trainedModel, trainingDataView.DataView.Schema, ModelPath);</pre></div>
<ol start="4">
<li>Now we evaluate the model we just trained using the testing dataset:</li>
</ol>
<pre style="padding-left: 60px">var testingDataView = GetDataView(testingFileName, true);<br/><br/>var testSetTransform = trainedModel.Transform(testingDataView.DataView);<br/><br/>var modelMetrics = MlContext.AnomalyDetection.Evaluate(testSetTransform);</pre>
<ol start="5">
<li>Finally, we output all of the classification metrics. Each of these will be detailed in the next section:</li>
</ol>
<pre style="padding-left: 60px">Console.WriteLine($"Area Under Curve: {modelMetrics.AreaUnderRocCurve:P2}{Environment.NewLine}" +<br/>                  $"Detection at FP Count: {modelMetrics.DetectionRateAtFalsePositiveCount}");</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p><span>To run the application, the process we use is nearly identical to <a href="8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml">Chapter 3</a>, <em>Regression Model</em>'s example application with the addition of passing in the test dataset when training:</span></p>
<ol>
<li>After extracting data, we must train the model by passing in the newly created<span> </span><kbd>sampledata.csv</kbd><span> </span>and <kbd>testdata.csv</kbd> files:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS chapter06\bin\Debug\netcoreapp3.0&gt; .\chapter06.exe train ..\..\..\Data\sampledata.csv </strong>..\..\..\Data\testdata.csv <br/>Area Under Curve: 78.12%<br/>Detection at FP Count: 1</pre></div>
<ol start="2">
<li>To run the model with this file, simply pass in a constructed JSON file (<kbd>input.json</kbd>, in this case) and the predicted output will show:</li>
</ol>
<div>
<pre style="padding-left: 60px"><strong>PS chapter06\bin\Debug\netcoreapp3.0&gt; .\chapter06.exe predict input.json</strong> <br/>Based on input json:<br/>{<br/> "UserID": 0, "CorporateNetwork": 1, "HomeNetwork": 0, "WithinWorkHours": 1, "WorkDay": 1<br/>}<br/>The login history is normal, with a 0% score</pre></div>
<p><span>Note the expanded output of the model training to include two metric data points. We will go through what each one of these means at the end of this chapter.</span></p>
<p>Feel free to modify the values and explore how the prediction changes based on the dataset that the model was trained on. A few areas of experimentation from this point might include the following:</p>
<ul>
<li>Adding some additional properties to increase the prediction accuracy in a production scenario such as the hour of the day the login occurred</li>
<li>Adding diversity to the training and test data</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating a randomized PCA model</h1>
                </header>
            
            <article>
                
<p>As discussed in previous chapters, evaluating a model is a critical part of the overall model-building process. A poorly trained model will only provide inaccurate predictions. Fortunately, ML.NET provides many popular attributes to calculate model accuracy based on a test set at the time of training to give you an idea of how well your model will perform in a production environment. </p>
<p>In ML.NET, as noted in the example application, there are two properties that comprise the <kbd>AnomalyDetectionMetrics</kbd><strong> </strong>class object. Let's dive into the properties exposed in the <kbd>AnomalyDetectionMetrics</kbd><strong> </strong>object:</p>
<ul>
<li><span>A</span>rea under the ROC curve</li>
<li>Detection rate at false positive count</li>
</ul>
<p>In the next sections, we will break down how these values are calculated and ideal values to look for.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Area under the ROC curve</h1>
                </header>
            
            <article>
                
<p>The area under the ROC curve, as mentioned in <a href="8bcfc000-9adc-4eda-a91a-e09f676eac85.xhtml">Chapter 3</a>, <em>Regression Model</em>, is, as the name implies, the area under the <strong>Receiver Operating Characteristic</strong> (<strong>ROC</strong>) curve. One question that might come to mind is this: how is this relevant to evaluating an anomaly detection model?</p>
<p>This computed area is equal to the chance that the algorithm, randomized PCA, in our case, scores a positive instance higher than a negative one, both chosen randomly to better evaluate the data. The number returned closer to 100% is the ideal value, while if it is closer to 0%, you will more than likely have significant false positives. You might remember our earlier example application getting 78%. This means that there was a 22% chance of a false positive; the following outlines some suggestions to improve the model and should reduce this number. </p>
<p>The following diagram visually <span>reflects </span>both a random guessing line and an arbitrary data curve. The area under the data curve in between the random guessing line is the area under the ROC curve data metric:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-674 image-border" src="assets/ca963c34-e882-4652-bdae-ba762ee7d9d5.png" style="width:19.75em;height:20.00em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Detection rate at false positive count</h1>
                </header>
            
            <article>
                
<p>The detection rate at false positive count property is the detection rate of <em>K</em> false positives. A false positive in an anomaly detection scenario would be to consider a data point an anomaly when, in fact, it was not. This rate is computed as follows:</p>
<p class="CDPAlignCenter CDPAlign"><em>Detection Rate of K False Positives = X / Y</em></p>
<p>Here, <em>X</em> is calculated to be the top test samples based on the scores previously described in the anomaly detection example (sorted in descending order). These are considered the top true positives (that is, more likely to be actual anomalies).</p>
<p><em>Y</em> is calculated to be the total number of anomalies in the test data regardless of the score value (not filtering to points that look suspicious or not). In theory, this number could be very high if the number of false positives is high in your training data. As you build production models with randomized PCA, ensure your data represents as close to production as possible to avoid overfitting or underfitting to anomalies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Over the course of this chapter, we discussed ML.NET's anomaly detection support via the randomized PCA algorithm. We also created and trained our first anomaly detection application using the randomized PCA algorithm to predict abnormal logins. In addition to this, we created a time series application, looking at network traffic and finding spikes in the amount of transferred data. Finally, we also looked at how to evaluate an anomaly detection model and the various properties that ML.NET exposes to achieve a proper evaluation of an anomaly detection model.</p>
<p>In the next chapter, we will deep dive into matrix factorization with ML.NET to create a music preference predictor.</p>


            </article>

            
        </section>
    </body></html>