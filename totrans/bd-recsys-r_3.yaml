- en: Chapter 3. Recommender Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shows some popular recommendation techniques. In addition, we will
    implement some of them in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will deal with the following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collaborative filtering**: This is the branch of techniques that we will
    explore in detail. The algorithms are based on information about similar users
    or similar items. The two sub-branches are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Item-based collaborative filtering**: This recommends to a user the items
    that are most similar to the user''s purchases'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-based collaborative filtering**: This recommends to a user the items
    that are the most preferred by similar users'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content-based filtering**: This is for each user; it defines a user profile
    and identify the items that match it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hybrid filtering**: This combines different techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Knowledge-based filtering**: This is uses explicit knowledge about users
    and items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R package for recommendation – recommenderlab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will build recommender systems using `recommenderlab`,
    which is an R package for collaborative filtering. This section will present a
    quick overview of this package. First, let''s install it, if we haven''t done
    so already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can load the package. Then, using the `help` function, we can take
    a look at its documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we run the preceding command in RStudio, a help file containing some links
    and a list of functions will open.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples that you will see in this chapter contain some random components.
    In order to be able to reproduce the code obtaining the same output, we need to
    run this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to start exploring `recommenderlab`.
  prefs: []
  type: TYPE_NORMAL
- en: Datasets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like many other R packages, `recommenderlab` contains some datasets that can
    be used to play around with the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Jester5k, MSWeb, and MovieLense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our examples, we will use the `MovieLense` dataset; the data is about movies.
    The table contains the ratings that the users give to movies. Let''s load the
    data and take a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each row of `MovieLense` corresponds to a user, and each column corresponds
    to a movie. There are more than *943 x 1664 = 1,500,000* combinations between
    a user and a movie. Therefore, storing the complete matrix would require more
    than 1,500,000 cells. However, not every user has watched every movie. Therefore,
    there are fewer than 100,000 ratings, and the matrix is sparse. The `recommenderlab`
    package allows us to store it in a compact way.
  prefs: []
  type: TYPE_NORMAL
- en: The class for rating matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will explore `MovieLense` in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `realRatingMatrix` class is defined by `recommenderlab`, and `ojectsojectsb`
    contains sparse rating matrices. Let''s take a look at the methods that we can
    apply on the objects of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| `[` | `dimnames<-` | `Recommender` |'
  prefs: []
  type: TYPE_TB
- en: '| `binarize` | `dissimilarity` | `removeKnownRatings` |'
  prefs: []
  type: TYPE_TB
- en: '| `calcPredictionAccuracy` | `evaluationScheme` | `rowCounts` |'
  prefs: []
  type: TYPE_TB
- en: '| `calcPredictionAccuracy` | `getData.frame` | `rowMeans` |'
  prefs: []
  type: TYPE_TB
- en: '| `colCounts` | `getList` | `rowSds` |'
  prefs: []
  type: TYPE_TB
- en: '| `colMeans` | `getNormalize` | `rowSums` |'
  prefs: []
  type: TYPE_TB
- en: '| `colSds` | `getRatings` | `sample` |'
  prefs: []
  type: TYPE_TB
- en: '| `colSums` | `getTopNLists` | `show` |'
  prefs: []
  type: TYPE_TB
- en: '| `denormalize` | `image` | `similarity` |'
  prefs: []
  type: TYPE_TB
- en: '| `dim` | `normalize` |   |'
  prefs: []
  type: TYPE_TB
- en: '| `dimnames` | `nratings` |   |'
  prefs: []
  type: TYPE_TB
- en: Some methods that are applicable to matrices have been redefined in a more optimized
    way. For instance, we can use `dim` to extract the number of rows and columns,
    and `colSums` to compute the sum of each column. In addition, there are new methods
    that are specific for recommendation systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, rating matrices are sparse matrices. For this reason, the `realRatingMatrix`
    class supports a compact storage of sparse matrices. Let''s compare the size of
    `MovieLense` with the corresponding R matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compute how many times the `recommenderlab` matrix is more compact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As expected, `MovieLense` occupies much less space than the equivalent standard
    R matrix. The rate is about *1:9*, and the reason is the sparsity of `MovieLense`.
    A standard R matrix object stores all the missing values as 0s, so it stores 15
    times more cells.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the similarity matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collaborative filtering algorithms are based on measuring the similarity between
    users or between items. For this purpose, `recommenderlab` contains the `similarity`
    function. The supported methods to compute similarities are `cosine`, `pearson`,
    and `jaccard`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we might want to determine how similar the first five users are
    with each other. Let''s compute this using the `cosine` distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `similarity_users` object contains all the dissimilarities. Let''s explore
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As expected, `similarity_users` is an object containing distances. Since `dist`
    is a base R class, we can use it in different ways. For instance, we could use
    `hclust` to build a hierarchic clustering model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also convert `similarity_users` into a matrix and visualize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| 1 | 2 | 3 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `0.1689` | `0.03827` | `0.06635` |'
  prefs: []
  type: TYPE_TB
- en: '| `0.1689` | `0` | `0.09707` | `0.1531` |'
  prefs: []
  type: TYPE_TB
- en: '| `0.03827` | `0.09707` | `0` | `0.3334` |'
  prefs: []
  type: TYPE_TB
- en: '| `0.06635` | `0.1531` | `0.3334` | `0` |'
  prefs: []
  type: TYPE_TB
- en: 'Using `image`, we can visualize the matrix. Each row and each column corresponds
    to a user, and each cell corresponds to the similarity between two users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The more red the cell is, the more similar two users are. Note that the diagonal
    is red, since it''s comparing each user with itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Computing the similarity matrix](img/B03888_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the same approach, we can compute and visualize the similarity between
    the first four items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Toy Story (1995) | GoldenEye (1995) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Toy Story (1995)** | `0` | `0.4024` |'
  prefs: []
  type: TYPE_TB
- en: '| **GoldenEye (1995)** | `0.4024` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| **Four Rooms (1995)** | `0.3302` | `0.2731` |'
  prefs: []
  type: TYPE_TB
- en: '| **Get Shorty (1995)** | `0.4549` | `0.5026` |'
  prefs: []
  type: TYPE_TB
- en: 'The table continues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | Four Rooms (1995) | Get Shorty (1995) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Toy Story (1995)** | `0.3302` | `0.4549` |'
  prefs: []
  type: TYPE_TB
- en: '| **GoldenEye (1995)** | `0.2731` | `0.5026` |'
  prefs: []
  type: TYPE_TB
- en: '| **Four Rooms (1995)** | `0` | `0.3249` |'
  prefs: []
  type: TYPE_TB
- en: '| **Get Shorty (1995)** | `0.3249` | `0` |'
  prefs: []
  type: TYPE_TB
- en: 'Similar to the preceding screenshot, we can visualize the matrix using this
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Computing the similarity matrix](img/B03888_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The similarity is the base of collaborative filtering models.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `recommenderlab` package contains some options for the recommendation algorithm.
    We can display the model applicable to the `realRatingMatrix` objects using `recommenderRegistry$get_entries`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `recommender_models` object contains some information about the models.
    First, let''s see which models we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| Models |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IBCF_realRatingMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `PCA_realRatingMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `POPULAR_realRatingMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `RANDOM_realRatingMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `SVD_realRatingMatrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `UBCF_realRatingMatrix` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s take a look at their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Out of them, we will use `IBCF` and `UBCF`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `recommender_models` object also contains some other information, such
    as its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| Parameter | Default |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `k` | `30` |'
  prefs: []
  type: TYPE_TB
- en: '| `method` | `Cosine` |'
  prefs: []
  type: TYPE_TB
- en: '| `normalize` | `center` |'
  prefs: []
  type: TYPE_TB
- en: '| `normalize_sim_matrix` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: '| `alpha` | `0.5` |'
  prefs: []
  type: TYPE_TB
- en: '| `na_as_zero` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: For a more detailed description of the package and some use cases, you can take
    a look at the package vignette. You can find all the material by typing `help(package
    = "recommenderlab")`.
  prefs: []
  type: TYPE_NORMAL
- en: The `recommenderlab` package is a good and flexible package to perform recommendation.
    If we combine its models with other R tools, we will have a powerful framework
    to explore the data and build recommendation models.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore a dataset of `recommenderlab` using some
    of its tools.
  prefs: []
  type: TYPE_NORMAL
- en: Data exploration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore the `MovieLense` dataset. For this purpose,
    we will use `recommenderlab` to build recommender systems and `ggplot2` to visualize
    their results. Let''s load the packages and the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`MovieLense` is a `realRatingMatrix` object containing a dataset about movie
    ratings. Each row corresponds to a user, each column to a movie, and each value
    to a rating.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the nature of the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at `MovieLense`. As explained in the previous section,
    there are some generic methods that can be applied to `realRatingMatrix` objects.
    We can extract their size using `dim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are `943` users and `1664` movies. Since `realRatingMatrix` is an S4
    class, the components of the objects are contained in `MovieLense` slots. We can
    see all the slots using `slotNames`, which displays all the data stored within
    an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`MovieLense@data` belongs to the `dgCMatrix` class that inherits from `Matrix`.
    In order to perform custom data exploration, we might need to access this slot.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the values of the rating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from the slot data, we can explore the matrix. Let''s take a look
    at the ratings. We can convert the matrix into a vector and explore its values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| Rating | Occurrences |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `1469760` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `6059` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `11307` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | `27002` |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `33947` |'
  prefs: []
  type: TYPE_TB
- en: '| `5` | `21077` |'
  prefs: []
  type: TYPE_TB
- en: 'According to the documentation, a rating equal to 0 represents a missing value,
    so we can remove them from `vector_ratings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can build a frequency plot of the ratings. In order to visualize a
    bar plot with frequencies, we can use `ggplot2`. Let''s convert them into categories
    using factor and build a quick chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s visualize their distribution using `qplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the distribution of the ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the values of the rating](img/B03888_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the ratings are above **2,** and the most common is **4**.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring which movies have been viewed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with `MovieLense`, we can easily extract quick results using methods
    such as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`colCounts`: This is the number of non-missing values for each column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colMeans`: This is the average value for each column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, which are the most viewed movies? We can use `colCounts` for
    this purpose. First, let''s count the views for each movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can sort the movies by number of views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can visualize the first six rows and build a histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the number of views of the top movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring which movies have been viewed](img/B03888_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding chart, you can notice that **Star Wars (1977)** is the most
    viewed movie, exceeding the others by about 100 views.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the average ratings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can identify the top-rated movies by computing the average rating of each
    of them. For this purpose, we can use `colMeans`; it automatically ignores the
    0s, since they represent missing values. Let''s take a look at the distribution
    of the average movie rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the chart using `qplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the distribution of the average movie rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the average ratings](img/B03888_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The highest value is around 3, and there are a few movies whose rating is either
    1 or 5\. Probably, the reason is that these movies received a rating from a few
    people only, so we shouldn''t take them into account. We can remove the movies
    whose number of views is below a defined threshold, for instance, below `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the distribution of the relevant average ratings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the average ratings](img/B03888_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All the rankings are between 2.3 and 4.5\. As expected, we removed the extremes.
    The highest value changes, and now, it is around 4.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can visualize the matrix by building a heat map whose colors represent the
    ratings. Each row of the matrix corresponds to a user, each column to a movie,
    and each cell to its rating. For this purpose, we can use the generic method:
    `image`. The `recommenderlab` package redefined the method image for `realRatingMatrix`
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the heatmap using `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays the heatmap of the rating matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing the matrix](img/B03888_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can notice a white area in the top-right region. The reason is that the row
    and columns are sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are too many users and items, this chart is hard to read. We can
    build another chart zooming in on the first rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the heat map using `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the heatmap of the first rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing the matrix](img/B03888_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some users saw more movies than the others. However, this chart is just displaying
    some random users and items. What if, instead, we select the most relevant users
    and items? This means visualizing only the users who have seen many movies and
    the movies that have been seen by many users. To identify and select the most
    relevant users and movies, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the minimum number of movies per user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the minimum number of users per movie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the users and movies matching these criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For instance, we can visualize the top percentile of users and movies. In order
    to do this, we use the `quantile` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can visualize the rows and columns matching the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the heat map using `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays the heatmap of the top users and movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing the matrix](img/B03888_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take account of the users having watched more movies. Most of them have
    seen all the top movies, and this is not surprising. We can notice some columns
    that are darker than the others. These columns represent the highest-rated movies.
    Conversely, darker rows represent users giving higher ratings. Because of this,
    we might need to normalize the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have explored the data. In the next section, we will process
    and transform it in order to have the inputs for the recommendation models.
  prefs: []
  type: TYPE_NORMAL
- en: Data preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will show you how to prepare the data to be used in recommender
    models. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the relevant data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normalize the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting the most relevant data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we explored the data, we noticed that the table contains:'
  prefs: []
  type: TYPE_NORMAL
- en: Movies that have been viewed only a few times. Their ratings might be biased
    because of lack of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users who rated only a few movies. Their ratings might be biased.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to determine the minimum number of users per movie and vice versa. The
    correct solution comes from an iteration of the entire process of preparing the
    data, building a recommendation model, and validating it. Since we are implementing
    the model for the first time, we can use a rule of thumb. After having built the
    models, we can come back and modify the data preparation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define `ratings_movies` containing the matrix that we will use. It
    takes account of:'
  prefs: []
  type: TYPE_NORMAL
- en: Users who have rated at least 50 movies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movies that have been watched at least 100 times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding points are defined in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `ratings_movies` object contains about half of the users and a fifth of
    the movies in comparison with `MovieLense`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the most relevant data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the same approach as we did in the previous section, let''s visualize
    the top 2 percent of users and movies in the new matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the heatmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays the heatmap of the top users and movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the most relevant data](img/B03888_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we already noticed, some rows are darker than the others. This might mean
    that some users give higher ratings to all the movies. However, we have visualized
    the top movies only. In order to have an overview of all the users, let''s take
    a look at the distribution of the average rating by user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s visualize the distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the distribution of the average rating per user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the most relevant data](img/B03888_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As suspected, the average rating varies a lot across different users.
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having users who give high (or low) ratings to all their movies might bias
    the results. We can remove this effect by normalizing the data in such a way that
    the average rating of each user is 0\. The prebuilt `normalize` function does
    it automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the average rating by users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the mean rating of each user is `0` (apart from the approximation
    error). We can visualize the new matrix using `image`. Let''s build the heat map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the heatmap of the top users and movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Normalizing the data](img/B03888_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first difference that we can notice is the colors, and this is because the
    data is continuous. Previously, the rating was an integer between 1 and 5\. After
    the normalization, the rating can be any number between -5 and 5.
  prefs: []
  type: TYPE_NORMAL
- en: There are still some lines that are more blue and some that are more red. The
    reason is that we are visualizing only the top movies. We already checked that
    the average rating is 0 for each user.
  prefs: []
  type: TYPE_NORMAL
- en: Binarizing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some recommendation models work on binary data, so we might want to binarize
    our data, that is, define a table containing only 0s and 1s. The 0s will be either
    treated as missing values or as bad ratings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we can either:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a matrix having 1 if the user rated the movie, and 0 otherwise. In this
    case, we are losing the information about the rating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a matrix having 1 if the rating is above or equal to a definite threshold
    (for example, 3), and 0 otherwise. In this case, giving a bad rating to a movie
    is equivalent to not having rated it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the context, one choice is more appropriate than the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function to binarize the data is `binarize`. Let''s apply it to our data.
    First, let''s define a matrix equal to 1 if the movie has been watched, that is
    if its rating is at least `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the results. In this case, we will have black-and-white
    charts so that we can visualize a larger portion of users and movies, for example,
    5 percent. Similarly, let''s select this 5 percent using `quantile`. The row and
    column counts are the same as the original matrix, so we can still apply `rowCounts`
    and `colCounts` on `ratings_movies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the heat map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the heat map of the top users and movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binarizing the data](img/B03888_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Only a few cells contain unwatched movies. This is just because we selected
    the top users and movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same approach to compute and visualize the other binary matrix
    The cells having a rating above the threshold will have their value equal to 1
    and the other cells will be 0s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the heat map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the heatmap of the top users and movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binarizing the data](img/B03888_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As expected, we have more white cells now. Depending on the model, we can leave
    the ratings matrix as it is or normalize/binarize it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we prepared the data to perform recommendations. In the upcoming
    sections, we will build collaborative filtering models.
  prefs: []
  type: TYPE_NORMAL
- en: Item-based collaborative filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collaborative filtering is a branch of recommendation that takes account of
    the information about different users. The word "collaborative" refers to the
    fact that users collaborate with each other to recommend items. In fact, the algorithms
    take account of user purchases and preferences. The starting point is a rating
    matrix in which rows correspond to users and columns correspond to items.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will show you an example of item-based collaborative filtering.
    Given a new user, the algorithm considers the user''s purchases and recommends
    similar items. The core algorithm is based on these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: For each two items, measure how similar they are in terms of having received
    similar ratings by similar users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each item, identify the *k*-most similar items
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each user, identify the items that are most similar to the user's purchases
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we will see the overall approach to building an IBCF model.
    In addition, the upcoming sections will show its details.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the training and test sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build the model using a part of the `MovieLense` dataset (the training
    set) and apply it on the other part (the test set). Since it's not a topic of
    this chapter, we will not evaluate the model, but will only recommend movies to
    the users in the test set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two sets are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Training set**: This set includes users from which the model learns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test set**: This set includes users to whom we recommend movies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algorithm automatically normalizes the data, so we can use `ratings_movies`
    that contains relevant users and movies of `MovieLense`. We defined `ratings_movies`
    in the previous section as the subset of `MovieLense` users who have rated at
    least 50 movies and movies that have been rated at least 100 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we randomly define the `which_train` vector that is `TRUE` for users
    in the training set and `FALSE` for the others. We will set the probability in
    the training set as 80 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the training and the test sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to recommend items to each user, we could just use the *k*-fold:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the users randomly into five groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a group as a test set and the other groups as training sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat it for each group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In order to show how this package works, we split the data into training and
    test sets manually. You can also do this automatically in `recommenderlab` using
    the `evaluationScheme` function. This function also contains some tools to evaluate
    models that we will use in the [Chapter 4](ch04.html "Chapter 4. Evaluating the
    Recommender Systems"), *Evaluating the Recommender Systems*, which is about model
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have the inputs to build and validate the model.
  prefs: []
  type: TYPE_NORMAL
- en: Building the recommendation model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function to build models is `recommender` and its inputs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data**: This is the training set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method**: This is the name of the technique'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: These are some optional parameters of the technique'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The model is called IBCF, which stands for item-based collaborative filtering.
    Let''s take a look at its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '| Parameters | Default |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `k` | `30` |'
  prefs: []
  type: TYPE_TB
- en: '| `method` | `Cosine` |'
  prefs: []
  type: TYPE_TB
- en: '| `normalize` | `center` |'
  prefs: []
  type: TYPE_TB
- en: '| `normalize_sim_matrix` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: '| `alpha` | `0.5` |'
  prefs: []
  type: TYPE_TB
- en: '| `na_as_zero` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: '| `minRating` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: 'Some relevant parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`k`: In the first step, the algorithm computes the similarities among each
    pair of items. Then, for each item, it identifies its *k* most similar items and
    stores it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This is the similarity function. By default, it is `Cosine`. Another
    popular option is `pearson`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the moment, we can just set them to their defaults. In order to show how
    to change parameters, we are setting `k = 30`, which is the default. We are now
    ready to build a recommender model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `recc_model` class is an object of the `Recommender` class containing the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the recommender model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `getModel`, we can extract some details about the model, such as its
    description and parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `model_details$sim` component contains the similarity matrix. Let''s check
    its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, `model_details$sim` is a square matrix whose size is equal to
    the number of items. We can explore a part of it using `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the heat map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays heatmap of the first rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the recommender model](img/B03888_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most of the values are equal to 0\. The reason is that each row contains only
    `k` elements. Let''s check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, each row has `30` elements greater than `0`. However, the matrix
    is not supposed to be symmetric. In fact, the number of non-null elements for
    each column depends on how many times the corresponding movie was included in
    the top *k* of another movie. Let''s check the distribution of the number of elements
    by column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the distribution chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays the distribution of the column count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the recommender model](img/B03888_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, there are a few movies that are similar to many others. Let''s
    see which are the movies with the most elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '| Movie | col_sum |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Sling Blade (1996)` | `62` |'
  prefs: []
  type: TYPE_TB
- en: '| `Usual Suspects, The (1995)` | `60` |'
  prefs: []
  type: TYPE_TB
- en: '| `Fargo (1996)` | `58` |'
  prefs: []
  type: TYPE_TB
- en: '| `Vertigo (1958)` | `58` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stargate (1994)` | `57` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Godfather (1972)` | `55` |'
  prefs: []
  type: TYPE_TB
- en: Applying the recommender model on the test set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are able to recommend movies to the users in the test set. We will
    define `n_recommended` that specifies the number of items to recommend to each
    user. This section will show you the most popular approach to computing a weighted
    sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'For each user, the algorithm extracts its rated movies. For each movie, it
    identifies all its similar items, starting from the similarity matrix. Then, the
    algorithm ranks each similar item in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the user rating of each purchase associated with this item. The rating
    is used as a weight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the similarity of the item with each purchase associated with this item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply each weight with the related similarity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum everything up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the algorithm identifies the top *n* recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `recc_predicted` object contains the recommendations. Let''s take a look
    at its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The slots are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`items`: This is the list with the indices of the recommended items for each
    user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`itemLabels`: This is the name of the items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n`: This is the number of recommendations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, these are the recommendations for the first user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extract the recommended movies from `recc_predicted@item` labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '| Index | Movie |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `201` | `Schindler''s List (1993)` |'
  prefs: []
  type: TYPE_TB
- en: '| `182` | `Secrets and Lies (1996)` |'
  prefs: []
  type: TYPE_TB
- en: '| `254` | `Trainspotting (1996)` |'
  prefs: []
  type: TYPE_TB
- en: '| `274` | `The Deer Hunter (1978)` |'
  prefs: []
  type: TYPE_TB
- en: '| `193` | `L.A. Confidential (1997)` |'
  prefs: []
  type: TYPE_TB
- en: '| `297` | `The Manchurian Candidate (1962)` |'
  prefs: []
  type: TYPE_TB
- en: 'We can define a matrix with the recommendations for each user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s visualize the recommendations for the first four users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '| `Schindler''s List (1993)` | `Babe (1995)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Secrets and Lies (1996)` | `The Usual Suspects (1995)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Trainspotting (1996)` | `Taxi Driver (1976)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Deer Hunter (1978)` | `Blade Runner (1982)` |'
  prefs: []
  type: TYPE_TB
- en: '| `L.A. Confidential (1997)` | `Welcome to the Dollhouse (1995)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Manchurian Candidate, The (1962)` | `The Silence of the Lambs (1991)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Batman Forever (1995)` | `Strictly Ballroom (1992)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Stargate (1994)` | `L.A. Confidential (1997)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Star Trek III: The Search for Spock (1984)` | `Cold Comfort Farm (1995)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Tin Cup (1996)` | `12 Angry Men (1957)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Courage Under Fire (1996)` | `Vertigo (1958)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Dumbo (1941)` | `A Room with a View (1986)` |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we can identify the most recommended movies. For this purpose, we will
    define a vector with all the recommendations, and we will build a frequency plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the distribution chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the distribution of the number of items for IBCF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the recommender model on the test set](img/B03888_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most of the movies have been recommended only a few times, and a few movies
    have been recommended many times. Let''s see which are the most popular movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '|   | names.number_of_items_top |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Mr. Smith Goes to Washington (1939)` | `Mr. Smith Goes to Washington (1939)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Babe (1995)` | `Babe (1995)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Maltese Falcon (1941)` | `The Maltese Falcon (1941)` |'
  prefs: []
  type: TYPE_TB
- en: '| `L.A. Confidential (1997)` | `L.A. Confidential (1997)` |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding table continues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | number_of_items_top |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Mr. Smith Goes to Washington (1939)` | `55` |'
  prefs: []
  type: TYPE_TB
- en: '| `Babe (1995)` | `38` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Maltese Falcon (1941)` | `35` |'
  prefs: []
  type: TYPE_TB
- en: '| `L.A. Confidential (1997)` | `34` |'
  prefs: []
  type: TYPE_TB
- en: IBCF recommends items on the basis of the similarity matrix. It's an eager-learning
    model, that is, once it's built, it doesn't need to access the initial data. For
    each item, the model stores the *k*-most similar, so the amount of information
    is small once the model is built. This is an advantage in the presence of lots
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this algorithm is efficient and scalable, so it works well with
    big rating matrices. Its accuracy is rather good, compared with other recommendation
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will explore another branch of techniques: user-based
    collaborative filtering.'
  prefs: []
  type: TYPE_NORMAL
- en: User-based collaborative filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, the algorithm was based on items and the steps to
    identify recommendations were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify which items are similar in terms of having been purchased by the same
    people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommend to a new user the items that are similar to its purchases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we will use the opposite approach. First, given a new user,
    we will identify its similar users. Then, we will recommend the top-rated items
    purchased by similar users. This approach is called user-based collaborative filtering.
    For each new user, these are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Measure how similar each user is to the new one. Like IBCF, popular similarity
    measures are correlation and cosine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Identify the most similar users. The options are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take account of the top *k* users (*k*-nearest_neighbors)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Take account of the users whose similarity is above a defined threshold
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rate the items purchased by the most similar users. The rating is the average
    rating among similar users and the approaches are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Average rating
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Weighted average rating, using the similarities as weights
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick the top-rated items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like we did in the previous chapter, we will build a training and a test set.
    Now, we can start building the model directly.
  prefs: []
  type: TYPE_NORMAL
- en: Building the recommendation model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The R command to build the model is the same as the previous chapter. Now,
    the technique is called UBCF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '| Parameter | Default |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `method` | `cosine` |'
  prefs: []
  type: TYPE_TB
- en: '| `nn` | `25` |'
  prefs: []
  type: TYPE_TB
- en: '| `sample` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: '| `normalize` | `center` |'
  prefs: []
  type: TYPE_TB
- en: '| `minRating` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: 'Some relevant parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method`: This shows how to compute the similarity between users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nn`: This shows the number of similar users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s build a recommender model leaving the parameters to their defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s extract some details about the model using `getModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the components of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '| Element |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| `description` |'
  prefs: []
  type: TYPE_TB
- en: '| `data` |'
  prefs: []
  type: TYPE_TB
- en: '| `method` |'
  prefs: []
  type: TYPE_TB
- en: '| `nn` |'
  prefs: []
  type: TYPE_TB
- en: '| `sample` |'
  prefs: []
  type: TYPE_TB
- en: '| `normalize` |'
  prefs: []
  type: TYPE_TB
- en: '| `minRating` |'
  prefs: []
  type: TYPE_TB
- en: 'Apart from the description and parameters of `model`, `model_details` contains
    a data slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `model_details$data` object contains the rating matrix. The reason is that
    UBCF is a lazy-learning technique, which means that it needs to access all the
    data to perform a prediction.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the recommender model on the test set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the same way as the IBCF, we can determine the top six recommendations for
    each new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define a matrix with the recommendations to the test set users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the first four users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '| `The Usual Suspects (1995)` | `Lone Star (1996)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Shawshank Redemption (1994)` | `This Is Spinal Tap (1984)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact (1997)` | `The Wrong Trousers (1993)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Godfather (1972)` | `Hoop Dreams (1994)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Nikita (La Femme Nikita) (1990)` | `Mighty Aphrodite (1995)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Twelve Monkeys (1995)` | `Big Night (1996)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Silence of the Lambs (1991)` | `The Usual Suspects (1995)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Shawshank Redemption (1994)` | `The Wrong Trousers (1993)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Jaws (1975)` | `Monty Python and the Holy Grail (1974)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Schindler''s List (1993)` | `GoodFellas (1990)` |'
  prefs: []
  type: TYPE_TB
- en: '|   | `The Godfather (1972)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Fargo (1996)` | `2001: A Space Odyssey (1968)` |'
  prefs: []
  type: TYPE_TB
- en: 'We can also compute how many times each movie got recommended and build the
    related frequency histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build the distribution chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image displays the distribution of the numbers of items for UBCF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the recommender model on the test set](img/B03888_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compared with the IBCF, the distribution has a longer tail. This means that
    there are some movies that are recommended much more often than the others. The
    maximum is 29, compared with 11 for IBCF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the top titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '|   | names.number_of_items_top |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Schindler''s List (1993)` | `Schindler''s List (1993)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Shawshank Redemption (1994)` | `The Shawshank Redemption (1994)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Silence of the Lambs (1991)` | `The Silence of the Lambs (1991)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Godfather (1972)` | `The Godfather (1972)` |'
  prefs: []
  type: TYPE_TB
- en: 'The preceding table is continued as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | number_of_items_top |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Schindler''s List (1993)` | `36` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Shawshank Redemption (1994)` | `34` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Silence of the Lambs (1991)` | `29` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Godfather (1972)` | `27` |'
  prefs: []
  type: TYPE_TB
- en: Comparing the results of UBCF with IBCF helps in understanding the algorithm
    better. UBCF needs to access the initial data, so it is a lazy-learning model.
    Since it needs to keep the entire database in memory, it doesn't work well in
    the presence of a big rating matrix. Also, building the similarity matrix requires
    a lot of computing power and time.
  prefs: []
  type: TYPE_NORMAL
- en: However, UBCF's accuracy is proven to be slightly more accurate than IBCF, so
    it's a good option if the dataset is not too big.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering on binary data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous two sections, we built recommendation models based on user
    preferences, since the data displayed the rating for each purchase. However, this
    information is not always available. The following two scenarios can take place:'
  prefs: []
  type: TYPE_NORMAL
- en: We know which items have been purchased, but not their ratings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each user, we don't know which items it purchased, but we know which items
    it likes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these contexts, we can build a user-item matrix whose values would be 1 if
    the user purchased (or liked) the item, and 0 otherwise. This case is different
    from the previous cases, so it should be treated separately. Similar to the other
    cases, the techniques are item-based and user-based.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, starting from `ratings_movies`, we can build a `ratings_movies_watched`
    matrix whose values will be 1 if the user viewed the movie, and 0 otherwise. We
    built it in one of the *Binarizing the data* sections.
  prefs: []
  type: TYPE_NORMAL
- en: Data preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can build `ratings_movies_watched` using the binarize method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a quick look at the data. How many movies (out of 332) did each
    user watch? Let''s build the distribution chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows a distribution of movies by user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data preparation](img/B03888_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the average, each user watched about 100 movies, and only a few watched more
    than 200 movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to build a recommendation model, let''s define a training set and
    a test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to build the IBCF and UBCF models.
  prefs: []
  type: TYPE_NORMAL
- en: Item-based collaborative filtering on binary data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step with IBCF is defining a similarity between items. In the case
    of binary data, distances such as the correlation and the cosine don't work properly.
    A good alternative is the Jaccard index. Given two items, the index is computed
    as the number of users purchasing both the items divided by the number of users
    purchasing at least one of them. Let's start from ![Item-based collaborative filtering
    on binary data](img/B03888_03_20.jpg) and ![Item-based collaborative filtering
    on binary data](img/B03888_03_21.jpg), which are the sets of users purchasing
    the first and second item, respectively. The "∩" symbol refers to the intersection
    of two sets, that is, the items contained in both. The "U" symbol refers to the
    union of two sets, that is, the items contained in at least one of them. The Jaccard
    index is the number of elements in the intersection between the two sets, divided
    by the number of elements in their union.
  prefs: []
  type: TYPE_NORMAL
- en: '![Item-based collaborative filtering on binary data](img/B03888_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can build the IBCF filtering model using the same commands as in the previous
    chapters. The only difference is the input parameter method equal to `Jaccard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Like in the previous sections, we can recommend six items to each of the users
    in the test set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Let's see the recommendations for the first four users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '| `L.A. Confidential (1997)` | `Hoop Dreams (1994)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Evita (1996)` | `Quiz Show (1994)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Being There (1979)` | `Strictly Ballroom (1992)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Chasing Amy (1997)` | `This Is Spinal Tap (1984)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb (1963)`
    | `What''s Eating Gilbert Grape (1993)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Full Monty (1997)` | `The Wrong Trousers (1993)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Gone with the Wind (1939)` | `Cop Land (1997)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Citizen Kane (1941)` | `Lost Highway (1997)` |'
  prefs: []
  type: TYPE_TB
- en: '| `On Golden Pond (1981)` | `Kolya (1996)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Emma (1996)` | `Secrets and Lies (1996)` |'
  prefs: []
  type: TYPE_TB
- en: '| `One Flew Over the Cuckoo''s Nest (1975)` | `Everyone Says I Love You (1996)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `The Philadelphia Story (1940)` | `Boogie Nights (1997)` |'
  prefs: []
  type: TYPE_TB
- en: The approach is similar to IBCF using a rating matrix. Since we are not taking
    account of the ratings, the result will be less accurate.
  prefs: []
  type: TYPE_NORMAL
- en: User-based collaborative filtering on binary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to IBCF, we need to use the Jaccard index for UBCF. Given two users,
    the index is computed as the number of items purchased by both the users divided
    by the number of items purchased by at least one of them. The mathematical symbols
    are the same as in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User-based collaborative filtering on binary data](img/B03888_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s build the recommender model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same commands as IBCF, let''s recommend six movies to each user,
    and let''s take a look at the first four users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '| `The Shawshank Redemption (1994)` | `Titanic (1997)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Casablanca (1942)` | `Cinema Paradiso (1988)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Braveheart (1995)` | `Lone Star (1996)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Terminator (1984)` | `L.A. Confidential (1997)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Usual Suspects (1995)` | `Singin'' in the Rain (1952)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Twelve Monkeys (1995)` | `Leaving Las Vegas (1995)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Titanic (1997)` | `Monty Python and the Holy Grail (1974)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Usual Suspects, The (1995)` | `The Shawshank Redemption (1994)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Groundhog Day (1993)` | `Schindler''s List (1993)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Shawshank Redemption (1994)` | `Young Frankenstein (1974)` |'
  prefs: []
  type: TYPE_TB
- en: '| `The Blues Brothers (1980)` | `The Usual Suspects (1995)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Monty Python and the Holy Grail (1974)` | `North by Northwest (1959)` |'
  prefs: []
  type: TYPE_TB
- en: The results are different from IBCF.
  prefs: []
  type: TYPE_NORMAL
- en: These techniques assumed that the 0s are missing values. However, there is also
    the option to treat them as bad ratings. There is a branch of technique that deals
    with binary matrices only.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the users don't give ratings to items, so there are several real-life
    cases of 0-1 matrices. That's why it's important to know how to build recommender
    systems in these contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions about collaborative filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book focuses on collaborative filtering as it's the most popular branch
    of recommendation. Also, it's the only one that is supported by `recommenderlab`.
  prefs: []
  type: TYPE_NORMAL
- en: However, collaborative filtering is not always the most suitable technique.
    This chapter provides an overview of its limitations and some alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of collaborative filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Collaborative filtering has some limitations. When dealing with new users and/or
    new items, the algorithm has these potential problems:'
  prefs: []
  type: TYPE_NORMAL
- en: If the new user hasn't seen any movie yet, neither the IBCF nor the UBCF is
    able to recommend any item. Unless the IBCF knows the items purchased by the new
    user, it can't work. The UBCF needs to know which users have similar preferences
    to the new one, but we don't know about its ratings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the new item hasn't been purchased by anyone, it will never be recommended.
    IBCF matches items that have been purchased by the same users, so it won't match
    the new item with any of the others. UBCF recommends to each user items purchased
    by similar users, and no one purchased the new item. So, the algorithm won't recommend
    it to anyone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we might not be able to include them, and this challenge is called a cold
    start problem. In order to include new users and/or items, we need to take account
    of other information such as user profiles and item descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of collaborative filtering is that it takes account of rating
    matrices only. In many contexts, we have some additional information that can
    improve the recommendations. In addition, user preferences are not always available,
    or they might be incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will look at some other approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Content-based filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular branch of techniques is content-based filtering. The algorithms
    start with a description of items, and they don't need to take account of different
    users at the same time. For each user, the algorithms recommend items that are
    similar to its past purchases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to perform a recommendation:'
  prefs: []
  type: TYPE_NORMAL
- en: Define item descriptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define user profiles based on purchases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recommend to each user the items matching its profile
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User profiles are based on their purchases, so the algorithms recommend items
    similar to past purchases.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many situations, we are able to build different collaborative and content-based
    filtering models. What if we take account of all of them at the same time? In
    machine learning, the approach of combining different models usually leads to
    better results.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example is collaborative filtering combined with information about
    users and/or items. In the case of IBCF, the distance between items can take account
    of user preferences and item descriptions at the same time. Even in UBCF, the
    distance between users can take account of their preferences and personal data.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of recommendation, these models are called hybrids. There are different
    ways to combine filtering models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallelized hybrid systems run the recommenders separately and combine their
    results. There are a few options such as the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a rule to pick one of the results for each user. The rule can be based
    on the user profile and/or on the recommendation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute an average of the rankings. The average can be weighted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipelined hybrid systems run the recommenders in sequence. The output of each
    model is an input for the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Monolithic hybrid systems integrate the approaches in the same algorithm. Some
    options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature combination**: This can be learned from different types of inputs.
    For example, an algorithm can take account of ratings, user profiles, and item
    descriptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature augmentation**: This builds the input of a recommender by combining
    different data sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge-based recommender systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations where collaborative and content-based filtering don't work.
  prefs: []
  type: TYPE_NORMAL
- en: In these contexts, we can use explicit knowledge about users and products, and
    recommendation criteria. This branch of techniques is called knowledge-based.
    There are a variety of techniques, and they depend on the data and on the business
    problem. For this reason, it's hard to define some techniques that are applicable
    in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the different techniques for recommendation, collaborative filtering is
    the easiest to implement. In addition, content-based filtering algorithms depend
    on the context, and it's still possible to build them in R.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter showed you different approaches to recommendation by focusing on
    collaborative filtering. The next chapter will show you how to test and evaluate
    the recommendation techniques.
  prefs: []
  type: TYPE_NORMAL
