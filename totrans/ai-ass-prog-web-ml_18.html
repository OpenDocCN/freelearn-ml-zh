<html><head></head><body>
  <div class="calibre1" id="_idContainer199">
    <h1 class="chapternumber">18</h1>
    <h1 class="chaptertitle" id="_idParaDest-410">Regression with Copilot Chat</h1>
    <h1 class="heading" id="_idParaDest-411">Introduction</h1>
    <p class="normal">The stock of a corporation signifies ownership in the corporation. A single share of the stock represents a claim on the fractional assets and the earnings of the corporation in proportion to the total number of shares. For example, if an investor owns 50 shares of stock in a company that has, in total, 1,000 shares, then that investor (or shareholder) would own and have a claim on 5% of the company’s assets and earnings.</p>
    <p class="normal1">The stocks of a company can be traded between shareholders and other parties via stock exchanges and organizations. Major stock exchanges include the New York Stock Exchange, NASDAQ, the London Stock Exchange Group, the Shanghai Stock Exchange, and the Hong Kong Stock Exchange. The prices that a stock is traded at fluctuate essentially due to the law of supply and demand. At any one moment, the supply is the number of shares that are in the hands of public investors, the demand is the number of shares investors want to buy, and the price of the stock moves up and down to attain and maintain equilibrium. </p>
    <p class="normal1">Investors generally want to buy low and sell high. This seems straightforward enough but putting it into practice is exceedingly tough because it is incredibly difficult to predict whether a stock price will increase or decrease. Fundamental analysis and technical analysis are the two main research areas that aim to comprehend the reasons and circumstances that influence price fluctuations or even forecast future stock prices: </p>
    <ul class="calibre15">
      <li class="bulletlist"><strong class="screentext">Fundamental analysis</strong>: This <a id="_idIndexMarker861" class="calibre3"/>stream focuses on the fundamental elements that affect a company’s value and operations, such as the macroeconomic environment, the state of the industry, and the company’s management and competitors. </li>
      <li class="bulletlist1"><strong class="screentext">Technical analysis</strong>: On the other hand, this uses statistical analysis of historical trading activity, such as price movement, volume, and time, to forecast future price movements. </li>
    </ul>
    <p class="normal1">In this chapter, we will explore the second technique using the Apple dataset to predict stock prices and help investors decide whether to buy or not. </p>
    <h1 class="heading" id="_idParaDest-412">Regression</h1>
    <p class="normal">Let’s start by <a id="_idIndexMarker862" class="calibre3"/>asking Copilot Chat for the definition of regression: </p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">What is regression? </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Regression is a statistical method used in data analysis which investigates the relationship between a dependent (target) and independent variable(s) (predictor). This method is mostly used for forecasting, time series modeling, and finding the causal effect relationship between the variables. For example, the relationship between rainfall and soil erosion or the relationship between salary and years of experience.</p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">You may notice in your chatbox that GitHub Copilot is suggesting the next context, highlighted in blue, asking, “<strong class="screentext">What are the different types of regression?</strong>”. You can click on this to get the answer. This demonstrates how Copilot is a powerful tool that assists users effectively. </p>
    <h1 class="heading" id="_idParaDest-413">Dataset overview </h1>
    <p class="normal">This <a id="_idIndexMarker863" class="calibre3"/>dataset contains Apple’s (AAPL) stock data spanning 10 years. Insights from this data can be used to build useful price forecasting algorithms to aid investment.</p>
    <p class="normal1">We can make the following notes about this dataset:</p>
    <ul class="calibre15">
      <li class="bulletlist">Data is collected and aggregated from 25 exchanges. </li>
      <li class="bulletlist1">Data is updated weekly.</li>
      <li class="bulletlist1">This dataset contains 1-minute, 5-minute, 30-minute, and 1-hour bars (open/high/low/close/volume) for AAPL. </li>
      <li class="bulletlist1">Out-of-hours<a id="_idIndexMarker864" class="calibre3"/> trades are included. Prices are adjusted for splits and dividends. Dataset available at <a href="https://www.kaggle.com/datasets/tarunpaparaju/apple-aapl-historical-stock-data" class="calibre3"><span class="calibre3">https://www.kaggle.com/datasets/tarunpaparaju/apple-aapl-historical-stock-data</span></a>.</li>
    </ul>
    <h2 class="heading1" id="_idParaDest-414">Explore the dataset </h2>
    <p class="normal">To better illustrate this<a id="_idIndexMarker865" class="calibre3"/> regression approach, it is necessary to have suitable predictors for our target. The dataset recorded more direct elements to the stock. Five values illustrating movements in the price over one unit of time (usually one day, but it can also be one week or one month) are key trading indicators. </p>
    <p class="normal1">They are as follows: </p>
    <ul class="calibre15">
      <li class="bulletlist"><strong class="screentext">Open</strong>: The starting price for a given trading day </li>
      <li class="bulletlist1"><strong class="screentext">Close</strong>: The final price on that day </li>
      <li class="bulletlist1"><strong class="screentext">High</strong>: The highest prices at which the stock traded on that day </li>
      <li class="bulletlist1"><strong class="screentext">Low</strong>: The lowest prices at which the stock traded on that day </li>
      <li class="bulletlist1"><strong class="screentext">Volume</strong>: The total number of shares traded before the market closed on that day </li>
    </ul>
    <h1 class="heading" id="_idParaDest-415">Prompt strategy</h1>
    <p class="normal">In this chapter, we will use the TAG (Task-Action-Guidance) prompt pattern. Here’s how we can help frame our project to help us author our initial prompt:</p>
    <ul class="calibre15">
      <li class="bulletlist"><strong class="screentext">Task</strong>: Regression analysis on Apple stock value through history</li>
      <li class="bulletlist1"><strong class="screentext">Action</strong>: We will need to instruct the AI assistant to tell us what steps to take</li>
      <li class="bulletlist1"><strong class="screentext">Guidance</strong>: The guidance should be us describing the dataset </li>
    </ul>
    <h2 class="heading1" id="_idParaDest-416">Your initial prompt </h2>
    <p class="normal">Just like with <a id="_idIndexMarker866" class="calibre3"/>other chapters in this book, we start with a prompt providing as much context as possible about what we want to do and the shape of the dataset. The idea is that we set a high-level context for our AI tool, which helps guide it throughout the rest of our prompts.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">I’m performing a regression project to forecast stock prices using the Apple Historical Stock dataset. This will aid investors in making informed decisions about buying or not buying stocks. The workflow includes loading the dataset, exploring its contents, splitting the dataset, building a regression model, and evaluating its performance. But remember I want to learn it step by step. Let’s start with loading the dataset. I am storing the dataset in <code class="inlinecode">&lt;file path&gt;</code>. Here’s the shape of the dataset:</p>
    <ul class="calibre15">
      <li class="bulletlist"><strong class="screentext">Open</strong>: The starting price for a given trading day </li>
      <li class="bulletlist1"><strong class="screentext">Close</strong>: The final price on that day </li>
      <li class="bulletlist1"><strong class="screentext">High</strong>: The highest prices at which the stock traded on that day </li>
      <li class="bulletlist1"><strong class="screentext">Low</strong>: The lowest prices at which the stock traded on that day </li>
      <li class="bulletlist1"><strong class="screentext">Volume</strong>: The total number of shares traded before the market closed on that day </li>
    </ul>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should <a id="_idIndexMarker867" class="calibre3"/>receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Sure, let’s start by loading the dataset. We’ll use the pandas library in Python to do this. Replace <code class="inlinecode">&lt;file-path&gt;</code> with the path where your file is located. </p>
    <p class="normal1">Here’s the Python code to load the dataset: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd 
 
<span class="hljs-comment"># Replace &lt;file-path&gt; with the path of your dataset </span>
file_path = <span class="hljs-string">"&lt;file-path&gt;"</span> 
 
<span class="hljs-comment"># Load the dataset </span>
df = pd.read_csv(file_path) 
 
<span class="hljs-comment"># Display the first few rows of the dataset </span>
<span class="hljs-built_in">print</span>(df.head()) 
</code></pre>
    <p class="normal1">After running this code, you should see the first few rows of your dataset printed out. This will give you a preliminary view of your data. </p>
    <p class="normal1">For the next steps, you might want to explore the dataset, clean the data if necessary, split the dataset into a training set and a test set, build a regression model using the training set, and then evaluate the model’s performance using the test set. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">Let’s try the output generated by Copilot and see if it works. Modify the <code class="inlinecode">file_path</code> variable to point to the location of your dataset and then execute the code below in a code cell in a notebook: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd 
 
<span class="hljs-comment"># Replace &lt;file-path&gt; with the path of your dataset </span>
file_path = <span class="hljs-string">"/your-path/.csv"</span> 
 
<span class="hljs-comment"># Load the dataset </span>
df = pd.read_csv(file_path) 
 
<span class="hljs-comment"># Display the first few rows of the dataset </span>
<span class="hljs-built_in">print</span>(df.head()) 
</code></pre>
    <p class="normal1">Here’s the <a id="_idIndexMarker868" class="calibre3"/>output you should see after running the code above:</p>
    <pre class="programlisting"><code class="hljs-code">         Date  Close/Last     Volume      Open      High       Low 
0  02/28/2020     $273.36  106721200   $257.26   $278.41   $256.37 
1  02/27/2020     $273.52   80151380    $281.1      $286   $272.96 
2  02/26/2020     $292.65   49678430   $286.53   $297.88    $286.5 
3  02/25/2020     $288.08   57668360   $300.95   $302.53   $286.13 
4  02/24/2020     $298.18   55548830   $297.26   $304.18   $289.23 
</code></pre>
    <p class="normal1">Next, we will focus on historical prices (the five recorded values) and performance to predict future prices. Let’s start by checking the data types. </p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Check the data types. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">To check the data types of the columns in your <code class="inlinecode">DataFrame</code>, you can use the <code class="inlinecode">dtypes</code> attribute. Here’s how you can do it: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Check the data types of each column </span>
<span class="hljs-built_in">print</span>(df.dtypes) 
</code></pre>
    <p class="normal1">This will print out the name of each column along with its data type. This is useful to know because certain operations can only be performed on certain types of data. For example, you can’t perform numerical operations on a string. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">Let’s try this and see if it works. Run the code <code class="inlinecode">print(df.types)</code>:</p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Check the data types of each column </span>
<span class="hljs-built_in">print</span>(df.dtypes) 
Date           object 
Close/Last    object 
Volume         int64 
Open          object 
High          object 
Low           object 
dtype: object 
</code></pre>
    <p class="normal1">Now, use the above output to query our AI tool.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Below is the <a id="_idIndexMarker869" class="calibre3"/>output, Date object Close/Last object Volume int64 Open object High object Low object dtype: object </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">It appears that the ‘Date’ column and the price columns (‘Close/Last’, ‘Open’, ‘High’, ‘Low’) are being read as ‘object’ type, which is essentially a string in pandas. However, for your analysis, you would want ‘Date’ to be in a datetime format and the price columns to be of a float type. </p>
    <p class="normal1">Here’s how you can convert the data types: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Convert 'Date' to datetime </span>
df[<span class="hljs-string">'Date'</span>] = pd.to_datetime(df[<span class="hljs-string">'Date'</span>]) 
 
<span class="hljs-comment"># Remove $ from price columns and convert to float </span>
price_columns = [<span class="hljs-string">' Close/Last'</span>, <span class="hljs-string">' Open'</span>, <span class="hljs-string">' High'</span>, <span class="hljs-string">' Low'</span>] 
<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> price_columns: 
    df[col] = df[col].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">'$'</span>, <span class="hljs-string">''</span>).astype(<span class="hljs-built_in">float</span>) 
 
<span class="hljs-comment"># Check the data types again </span>
<span class="hljs-built_in">print</span>(df.dtypes) 
</code></pre>
    <p class="normal1">This code first converts the ‘Date’ column to datetime format using <code class="inlinecode">pd.to_datetime()</code>. Then it loops over each price column, removes the dollar sign from each value, and converts the column to float type. Finally, it prints out the data types of the columns again to confirm the changes. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">Let’s try these suggestions above to convert our columns by running the below code: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Convert 'Date' to datetime </span>
df[<span class="hljs-string">'Date'</span>] = pd.to_datetime(df[<span class="hljs-string">'Date'</span>]) 
 
<span class="hljs-comment"># Remove $ from price columns and convert to float </span>
price_columns = [<span class="hljs-string">' Close/Last'</span>, <span class="hljs-string">' Open'</span>, <span class="hljs-string">' High'</span>, <span class="hljs-string">' Low'</span>] 
<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> price_columns: 
    df[col] = df[col].<span class="hljs-built_in">str</span>.replace(<span class="hljs-string">'$'</span>, <span class="hljs-string">''</span>).astype(<span class="hljs-built_in">float</span>) 
 
<span class="hljs-comment"># Check the data types again </span>
<span class="hljs-built_in">print</span>(df.dtypes) 
</code></pre>
    <p class="normal1">You should see the<a id="_idIndexMarker870" class="calibre3"/> following output, which is the columns correctly converted to suitable types instead of being strings:</p>
    <pre class="programlisting"><code class="hljs-code">Date           datetime64[ns] 
Close/Last           float64 
Volume                 int64 
Open                 float64 
High                 float64 
Low                  float64 
dtype: object 
</code></pre>
    <p class="normal1">Next, let’s tell Copilot about the result to ensure it tells us what to do next.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Below is the output, Date datetime64[ns] Close/Last float64 Volume int64 Open float64 High float64 Low float64 dtype: object </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Great! Now your ‘Date’ column is of type ‘datetime64[ns]’ and your price columns (‘Close/Last’, ‘Open’, ‘High’, ‘Low’) are of type ‘float64’. This means you can now perform numerical operations on your price columns and time series analysis on your ‘Date’ column. </p>
    <p class="normal1">The next steps could be to perform exploratory data analysis, such as checking for missing values, visualizing the distribution of your variables, or examining the correlation between <a id="_idIndexMarker871" class="calibre3"/>different variables. You might also want to split your data into a training set and a test set in preparation for building your regression model. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <h2 class="heading1" id="_idParaDest-417">Exploratory data analysis</h2>
    <p class="normal">Guided <a id="_idIndexMarker872" class="calibre3"/>by the output on what to do next, we decide to check the missing values in our dataset:</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Check missing values. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">To check for missing values in your <code class="inlinecode">DataFrame</code>, you can use the <code class="inlinecode">isnull()</code> function along with the <code class="inlinecode">sum()</code> function in pandas. Here’s how you can do it: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Check for missing values </span>
<span class="hljs-built_in">print</span>(df.isnull().<span class="hljs-built_in">sum</span>()) 
</code></pre>
    <p class="normal1">This will print out the number of missing values in each column of your <code class="inlinecode">DataFrame</code>. If a column has zero missing values, that means there are no missing values in that column. If a column has a number greater than zero, that’s the number of missing values in that column. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">The response from Copilot says to check for null values and provides code for how to do so. Let’s run the suggested code in a code cell in a Notebook:</p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Check for missing values </span>
<span class="hljs-built_in">print</span>(df.isnull().<span class="hljs-built_in">sum</span>()) 
</code></pre>
    <p class="normal1">Here’s the output:</p>
    <pre class="programlisting"><code class="hljs-code">Date           0 
Close/Last    0 
Volume        0 
Open          0 
High          0 
Low           0 
dtype: int64 
</code></pre>
    <p class="normal1">With <a id="_idIndexMarker873" class="calibre3"/>this output, provide it to Copilot to see what to do next:</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Below is the output, Date 0 Close/Last 0 Volume 0 Open 0 High 0 Low 0 dtype: int64 </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Great! The output indicates that there are no missing values in your dataset. Each column has 0 missing values. This is good news because it means you don’t have to handle missing data, which can be a complex process. </p>
    <p class="normal1">The next step in your analysis could be to perform some exploratory data analysis (EDA). This might include visualizing your data, checking for outliers, or examining the relationships between variables. After that, you can proceed to split your data into a training set and a test set, and then build your regression model. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">Great, we had no missing values and it seems like the next steps should be visual analysis and checking for outliers. With that knowledge, let’s craft an appropriate prompt.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Visualize data and check for outliers. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Visualizing the data can be done using various libraries in Python, such as Matplotlib or Seaborn. For checking outliers, boxplots can be very useful. Here’s how you can create boxplots for your<a id="_idIndexMarker874" class="calibre3"/> price columns: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt 
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns 
 
<span class="hljs-comment"># Set up the matplotlib figure </span>
f, axes = plt.subplots(<span class="hljs-attr">2</span>, <span class="hljs-attr">2</span>, figsize=(<span class="hljs-attr">15</span>, <span class="hljs-attr">10</span>)) 
 
<span class="hljs-comment"># Plot a simple histogram with binsize determined automatically </span>
sns.boxplot(data=df[<span class="hljs-string">' Close/Last'</span>], ax=axes[<span class="hljs-attr">0</span>, <span class="hljs-attr">0</span>]) 
axes[<span class="hljs-attr">0</span>, <span class="hljs-attr">0</span>].set_title(<span class="hljs-string">'Close/Last'</span>) 
 
sns.boxplot(data=df[<span class="hljs-string">' Open'</span>], ax=axes[<span class="hljs-attr">0</span>, <span class="hljs-attr">1</span>]) 
axes[<span class="hljs-attr">0</span>, <span class="hljs-attr">1</span>].set_title(<span class="hljs-string">'Open'</span>) 
 
sns.boxplot(data=df[<span class="hljs-string">' High'</span>], ax=axes[<span class="hljs-attr">1</span>, <span class="hljs-attr">0</span>]) 
axes[<span class="hljs-attr">1</span>, <span class="hljs-attr">0</span>].set_title(<span class="hljs-string">'High'</span>) 
 
sns.boxplot(data=df[<span class="hljs-string">' Low'</span>], ax=axes[<span class="hljs-attr">1</span>, <span class="hljs-attr">1</span>]) 
axes[<span class="hljs-attr">1</span>, <span class="hljs-attr">1</span>].set_title(<span class="hljs-string">'Low'</span>) 
 
plt.tight_layout() 
</code></pre>
    <p class="normal1">This code will create a 2x2 grid of plots, with each plot being a boxplot of one of your price columns. Boxplots are useful for visualizing the distribution of data and identifying potential outliers. In a boxplot, an outlier is typically represented as a point that is located outside the whiskers of the boxplot. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">The code above suggests using the matplotlib and seaborn libraries and also contains code to create a boxplot visualization; let’s run said code:</p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt 
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns 
 
<span class="hljs-comment"># Set up the matplotlib figure </span>
f, axes = plt.subplots(<span class="hljs-attr">2</span>, <span class="hljs-attr">2</span>, figsize=(<span class="hljs-attr">15</span>, <span class="hljs-attr">10</span>)) 
 
<span class="hljs-comment"># Plot a simple histogram with binsize determined automatically </span>
sns.boxplot(data=df[<span class="hljs-string">' Close/Last'</span>], ax=axes[<span class="hljs-attr">0</span>, <span class="hljs-attr">0</span>]) 
axes[<span class="hljs-attr">0</span>, <span class="hljs-attr">0</span>].set_title(<span class="hljs-string">'Close/Last'</span>) 
 
sns.boxplot(data=df[<span class="hljs-string">' Open'</span>], ax=axes[<span class="hljs-attr">0</span>, <span class="hljs-attr">1</span>]) 
axes[<span class="hljs-attr">0</span>, <span class="hljs-attr">1</span>].set_title(<span class="hljs-string">'Open'</span>) 
 
sns.boxplot(data=df[<span class="hljs-string">' High'</span>], ax=axes[<span class="hljs-attr">1</span>, <span class="hljs-attr">0</span>]) 
axes[<span class="hljs-attr">1</span>, <span class="hljs-attr">0</span>].set_title(<span class="hljs-string">'High'</span>) 
 
sns.boxplot(data=df[<span class="hljs-string">' Low'</span>], ax=axes[<span class="hljs-attr">1</span>, <span class="hljs-attr">1</span>]) 
axes[<span class="hljs-attr">1</span>, <span class="hljs-attr">1</span>].set_title(<span class="hljs-string">'Low'</span>) 
 
plt.tight_layout() 
</code></pre>
    <p class="normal1">You should<a id="_idIndexMarker875" class="calibre3"/> see results similar to the following boxplots:</p>
    <figure class="mediaobject"><img alt="A group of blue and black boxes  Description automatically generated" src="../Images/B21232_18_01.png" class="calibre19"/> </figure>
    <p class="packt_figref">Figure 18.1: Boxplots of our dataset</p>
    <p class="normal1">Next, we want to learn more about our variables and their relationship.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Examine the relationships between variables. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should<a id="_idIndexMarker876" class="calibre3"/> receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">To examine the relationships between variables, you can use a correlation matrix and a heatmap. The correlation matrix will give you numerical values that represent how closely related two variables are, while the heatmap will give you a visual representation of these relationships. </p>
    <p class="normal1">Here’s how you can do it: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Calculate the correlation matrix </span>
corr = df.corr() 
 
<span class="hljs-comment"># Plot the heatmap </span>
sns.heatmap(corr, annot=<span class="hljs-literal">True</span>, cmap=<span class="hljs-string">'coolwarm'</span>) 
 
plt.show() 
</code></pre>
    <p class="normal1">This code first calculates the correlation matrix using the <code class="inlinecode">corr()</code> function, which returns a <code class="inlinecode">DataFrame</code> where each cell represents the correlation coefficient between two variables. Then it plots a heatmap using this correlation matrix. The <code class="inlinecode">annot=True</code> argument allows the correlation coefficients to be plotted on the heatmap, and the <code class="inlinecode">cmap='coolwarm'</code> argument sets the color scheme of the heatmap. </p>
    <p class="normal1">The correlation coefficient ranges from -1 to 1. A value close to 1 implies a high positive correlation while a value close to -1 implies a high negative correlation. A value close to 0 implies no correlation. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">The response says we should create a correlation matrix and visualize it via a heatmap. Let’s try the suggested code above and see what we get:</p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Calculate the correlation matrix </span>
corr = df.corr() 
 
<span class="hljs-comment"># Plot the heatmap </span>
sns.heatmap(corr, annot=<span class="hljs-literal">True</span>, cmap=<span class="hljs-string">'coolwarm'</span>) 
 
plt.show() 
</code></pre>
    <p class="normal1">Here’s <a id="_idIndexMarker877" class="calibre3"/>the output from the code above:</p>
    <figure class="mediaobject"><img alt="A screenshot of a graph  Description automatically generated" src="../Images/B21232_18_02.png" class="calibre19"/> </figure>
    <p class="packt_figref">Figure 18.2: Heatmap</p>
    <p class="normal1">In the heatmap, we can see: </p>
    <ul class="calibre15">
      <li class="bulletlist">The diagonal is always 1 because it shows the correlation of each variable with itself. </li>
      <li class="bulletlist1">Close/Last, Open, High, and Low have a high positive correlation with each other (0.92), indicating that as one of these variables increases, the others tend to also increase. This is typical for stock data, as these prices move closely together throughout the trading day. </li>
      <li class="bulletlist1">Volume shows a negative correlation with Close/Last, Open, High, and Low (-0.61). This suggests that on days when the volume of shares traded is higher, the prices may tend to be lower, or vice versa. </li>
    </ul>
    <p class="normal1">As shown in <a id="_idIndexMarker878" class="calibre3"/>the screenshot below, Copilot recommends the next step following the analysis of variable relationships. We will choose this and see what it says. </p>
    <p class="normal1">Let’s ask Copilot what to do next.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">What is the next step after examining the relationships between variables? </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">The next step after examining the relationships between variables is typically to prepare your data for modeling. This can involve several sub-steps: </p>
    <ul class="calibre15">
      <li class="bulletlist"><strong class="screentext">Feature Selection</strong>: Based on your correlation analysis, you might decide to drop some features that are not correlated with your target variable, or to avoid multicollinearity, drop one of two features that are highly correlated with each other. </li>
      <li class="bulletlist1"><strong class="screentext">Data Splitting</strong>: You’ll need to split your data into a training set and a test set. A common split is 80% of the data for training and 20% for testing. </li>
      <li class="bulletlist1"><strong class="screentext">Data Scaling</strong>: Depending on the model you plan to use, you might need to scale your data so that all features have a similar range of values. </li>
    </ul>
    <p class="normal1">Once your data is prepared, you can proceed to build your regression model. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <h2 class="heading1" id="_idParaDest-418">Data splitting </h2>
    <p class="normal">At this point, let’s prepare <a id="_idIndexMarker879" class="calibre3"/>for the creation of the model. Before we can create the model, we need to split up our data into training data and test sets to verify the model later.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Let’s move on to the step of splitting the data. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Absolutely, splitting<a id="_idIndexMarker880" class="calibre3"/> the data into a training set and a test set is a crucial step in preparing your data for modeling. We’ll use the <code class="inlinecode">train_test_split</code> function from <code class="inlinecode">sklearn.model_selection</code> to do this. </p>
    <p class="normal1">Assuming that we are going to predict the ‘Close/Last’ price, here’s how you can split your data: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split 
 
<span class="hljs-comment"># Define the feature variables and the target variable </span>
X = df.drop(<span class="hljs-string">' Close/Last'</span>, axis=<span class="hljs-attr">1</span>) 
y = df[<span class="hljs-string">' Close/Last'</span>] 
 
<span class="hljs-comment"># Split the data into training set and test set </span>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-attr">0.2</span>, random_state=<span class="hljs-attr">42</span>) 
</code></pre>
    <p class="normal1">This code first defines the feature variables X and the target variable y. Then it splits these into a training set and a test set, with 80% of the data going to the training set and 20% going to the test set. The <code class="inlinecode">random_state</code> parameter is used for reproducibility - using the same <code class="inlinecode">random_state</code> will ensure that you get the same train/test split every time you run the code. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">In short, the code above shows us how to split up our dataset; let’s try this code next:</p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split 
 
<span class="hljs-comment"># Define the feature variables and the target variable </span>
X = df.drop(<span class="hljs-string">' Close/Last'</span>, axis=<span class="hljs-attr">1</span>) 
y = df[<span class="hljs-string">' Close/Last'</span>] 
 
<span class="hljs-comment"># Split the data into training set and test set </span>
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-attr">0.2</span>, random_state=<span class="hljs-attr">42</span>) 
</code></pre>
    <p class="normal1">At this point, we don’t have an output to show as we assigned the results to variables. Let’s, however, print that next.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Print the shape of samples. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">To print <a id="_idIndexMarker881" class="calibre3"/>the shape of your training and test samples, you can use the shape attribute. Here’s how you can do it: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Print the shape of the training set and the test set </span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Training set (X):"</span>, X_train.shape) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Training set (y):"</span>, y_train.shape) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Test set (X):"</span>, X_test.shape) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Test set (y):"</span>, y_test.shape) 
</code></pre>
    <p class="normal1">This will print out the number of rows and columns in your training set and test set. The number of rows should be the same between <code class="inlinecode">X_train</code> and <code class="inlinecode">y_train</code>, and between <code class="inlinecode">X_test</code> and <code class="inlinecode">y_test</code>. The number of columns in <code class="inlinecode">X_train</code> and <code class="inlinecode">X_test</code> should be the same, and <code class="inlinecode">y_train</code> and <code class="inlinecode">y_test</code> should each have just one column (since they represent the target variable). </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">The suggested code is straightforward, as it consists of a set of print statements. Let’s try said code by running it in a code cell:</p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Print the shape of the training set and the test set </span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Training set (X):"</span>, X_train.shape) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Training set (y):"</span>, y_train.shape) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Test set (X):"</span>, X_test.shape) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Test set (y):"</span>, y_test.shape) 
</code></pre>
    <p class="normal1">You should see output similar to the below:</p>
    <pre class="programlisting"><code class="hljs-code">Training set (X): (2014, 5) 
Training set (y): (2014,) 
Test set (X): (504, 5) 
Test set (y): (504,) 
</code></pre>
    <h2 class="heading1" id="_idParaDest-419">Build a regression model </h2>
    <p class="normal">Now<a id="_idIndexMarker882" class="calibre3"/> that we’ve split up the data, let’s train the model next, or at least that’s what we expect Copilot to say if we ask it for the next step. Let’s create a prompt asking just that:</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">What is the next step after splitting the data? </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">After splitting the data, the next step is to create and train your regression model using the training data. Depending on the nature of your data and the problem you’re trying to solve, you might choose a simple linear regression model, or a more complex model like polynomial regression or ridge regression.</p>
    <p class="normal1">Once the model is trained, you can use it to make predictions on the test data. Then, you evaluate the performance of the model by comparing these predictions to the actual values in the test data. Common metrics for evaluating regression models include Mean Absolute Error (MAE), Mean Squared Error (MSE), and R-squared. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">Okay, just as we thought, the next step is to train the model. Let’s create a prompt asking for more detailed information on how to train the model:</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Create and train a regression model. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Sure, let’s create and train a simple Linear Regression model using the training data. We’ll use the <code class="inlinecode">LinearRegression</code> class from <code class="inlinecode">sklearn.linear_model</code> to do this. </p>
    <p class="normal1">Here’s how you can create and train your model: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression 
 
<span class="hljs-comment"># Create a Linear Regression model </span>
model = LinearRegression() 
 
<span class="hljs-comment"># Train the model </span>
model.fit(X_train, y_train) 
</code></pre>
    <p class="normal1">This code <a id="_idIndexMarker883" class="calibre3"/>first creates a Linear Regression model. Then it trains the model using the fit method and the training data. After this step, your model is ready to make predictions on unseen data. </p>
    <p class="normal1">Please note that if your data has a non-linear relationship, you might need to use a more complex model like Polynomial Regression or a tree-based model. Also, if your features are not on the same scale, you might need to scale your data before training the model. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">We’ve received a response on using linear regression and the sklearn library. Note that you might need to install said library before proceeding. Once you’ve ensured sklearn is installed, proceed to run the suggested code below:</p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression 
 
<span class="hljs-comment"># Create a Linear Regression model </span>
model = LinearRegression() 
 
<span class="hljs-comment"># Train the model </span>
model.fit(X_train, y_train) 
</code></pre>
    <p class="normal1">Here’s the output from running the code:</p>
    <pre class="programlisting"><code class="hljs-code">--------------------------------------------------------------------------- 
DTypePromotionError                       Traceback (most recent call last) 
 
File ~/.conda/envs/myenv/lib/python3.12/site-packages/sklearn/base.py:1152, in _fit_context.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper(estimator, *args, **kwargs) 
   1145     estimator._validate_params() 
   1147 with config_context( 
   1148     skip_parameter_validation=( 
   1149         prefer_skip_nested_validation or global_skip_validation 
   1150     ) 
   1151 ): 
-&gt; 1152     return fit_method(estimator, *args, **kwargs) 
 
File ~/.conda/envs/myenv/lib/python3.12/site-packages/sklearn/linear_model/_base.py:678, in LinearRegression.fit(self, X, y, sample_weight) 
    674 n_jobs_ = self.n_jobs 
    676 accept_sparse = False if self.positive else ["csr", "csc", "coo"] 
--&gt; 678 X, y = self._validate_data( 
    679     X, y, accept_sparse=accept_sparse, y_numeric=True, multi_output=True 
    680 ) 
    682 has_sw = sample_weight is not None 
    683 if has_sw: 
 
File ~/.conda/envs/myenv/lib/python3.12/site-packages/sklearn/base.py:622, in BaseEstimator._validate_data(self, X, y, reset, validate_separately, cast_to_ndarray, **check_params) 
    620         y = check_array(y, input_name="y", **check_y_params) 
    621     else: 
--&gt; 622         X, y = check_X_y(X, y, **check_params) 
    623     out = X, y 
    625 if not no_val_X and check_params.get("ensure_2d", True): 
 
File ~/.conda/envs/myenv/lib/python3.12/site-packages/sklearn/utils/validation.py:1146, in check_X_y(X, y, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, multi_output, ensure_min_samples, ensure_min_features, y_numeric, estimator) 
   1141         estimator_name = _check_estimator_name(estimator) 
   1142     raise ValueError( 
   1143         f"{estimator_name} requires y to be passed, but the target y is None" 
   1144     ) 
-&gt; 1146 X = check_array( 
   1147     X, 
   1148     accept_sparse=accept_sparse, 
   1149     accept_large_sparse=accept_large_sparse, 
   1150     dtype=dtype, 
   1151     order=order, 
   1152     copy=copy, 
   1153     force_all_finite=force_all_finite, 
   1154     ensure_2d=ensure_2d, 
   1155     allow_nd=allow_nd, 
   1156     ensure_min_samples=ensure_min_samples, 
   1157     ensure_min_features=ensure_min_features, 
   1158     estimator=estimator, 
   1159     input_name="X", 
   1160 ) 
   1162 y = _check_y(y, multi_output=multi_output, y_numeric=y_numeric, estimator=estimator) 
   1164 check_consistent_length(X, y) 
 
File ~/.conda/envs/myenv/lib/python3.12/site-packages/sklearn/utils/validation.py:795, in check_array(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_all_finite, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name) 
    791 pandas_requires_conversion = any( 
    792     _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig 
    793 ) 
    794 if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig): 
--&gt; 795     dtype_orig = np.result_type(*dtypes_orig) 
    796 elif pandas_requires_conversion and any(d == object for d in dtypes_orig): 
    797     # Force object if any of the dtypes is an object 
    798     dtype_orig = object 
 
DTypePromotionError: The DType &lt;class 'numpy.dtypes.DateTime64DType'&gt; could not be promoted by &lt;class 'numpy.dtypes.Float64DType'&gt;. This means that no common DType exists for the given inputs. For example they cannot be stored in a single array unless the dtype is `object`. The full list of DTypes is: (&lt;class 
'numpy.dtypes.DateTime64DType'&gt;, &lt;class 'numpy.dtypes.Int64DType'&gt;, &lt;class 'numpy.dtypes.Float64DType'&gt;, &lt;class 'numpy.dtypes.Float64DType'&gt;, &lt;class 'numpy.dtypes.Float64DType'&gt;) 
</code></pre>
    <p class="normal1">We’re<a id="_idIndexMarker884" class="calibre3"/> clearly getting an error back, so let’s see if Copilot can help with this error. As usual, include context like the error text to get a good response.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">I am getting this error after running the code, </p>
    <pre class="programlisting"><code class="hljs-code">Cell 39 line 7 4 model = LinearRegression() 6 # Train the model ----&gt; 7 model.fit(X_train, y_train) 
File ~/.conda/envs/myenv/lib/python3.12/site-packages/sklearn/base.py:1152, in _fit_context..decorator..wrapper(estimator, *args, **kwargs) 1145 estimator._validate_params() 1147 with config_context( 1148 skip_parameter_validation=( 1149 prefer_skip_nested_validation or global_skip_validation 1150 ) 1151 ): -&gt; 1152 return fit_method(estimator, *args, **kwargs) 
File ~/.conda/envs/myenv/lib/python3.12/site-packages/sklearn/linear_model/base.py:678, in LinearRegression.fit(self, X, y, sample_weight) 674 n_jobs = self.n_jobs 676 accept_sparse = False if self.positive else ["csr", "csc", "coo"] --&gt; 678 X, y = self._validate_data( 679 X, y, accept_sparse=accept_sparse, y_numeric=True, multi_output=True 680 ) 682 has_sw = sample_weight is not None 683 if has_sw: ... 796 elif pandas_requires_conversion and any(d == object for d in dtypes_orig): 797 # Force object if any of the dtypes is an object 798 dtype_orig = object 
DTypePromotionError: The DType &lt;class 'numpy.dtypes.DateTime64DType'&gt; could not be promoted by &lt;class 'numpy.dtypes.Float64DType'&gt;. This means that no common DType exists for the given inputs. For example they cannot be stored in a single array unless the dtype is object. The full list of DTypes is: (&lt;class 'numpy.dtypes.DateTime64DType'&gt;, &lt;class 'numpy.dtypes.Int64DType'&gt;, &lt;class 'numpy.dtypes.Float64DType'&gt;, &lt;class 'numpy.dtypes.Float64DType'&gt;, &lt;class 'numpy.dtypes.Float64DType'&gt;) 
</code></pre>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should<a id="_idIndexMarker885" class="calibre3"/> receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response] </strong></p>
    <p class="normal1">The error message suggests that the model is having trouble handling the ‘Date’ column because it’s in datetime format, and the model expects numerical input. </p>
    <p class="normal1">One common approach to deal with datetime data is to extract features from it, such as the year, month, day, etc. Here’s how you can do it: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Extract features from 'Date' </span>
X_train[<span class="hljs-string">'Year'</span>] = X_train[<span class="hljs-string">'Date'</span>].dt.year 
X_train[<span class="hljs-string">'Month'</span>] = X_train[<span class="hljs-string">'Date'</span>].dt.month 
X_train[<span class="hljs-string">'Day'</span>] = X_train[<span class="hljs-string">'Date'</span>].dt.day 
 
<span class="hljs-comment"># Drop the original 'Date' column </span>
X_train = X_train.drop(<span class="hljs-string">'</span><span class="hljs-string">Date'</span>, axis=<span class="hljs-attr">1</span>) 
 
<span class="hljs-comment"># Do the same for the test set </span>
X_test[<span class="hljs-string">'Year'</span>] = X_test[<span class="hljs-string">'Date'</span>].dt.year 
X_test[<span class="hljs-string">'Month'</span>] = X_test[<span class="hljs-string">'Date'</span>].dt.month 
X_test[<span class="hljs-string">'Day'</span>] = X_test[<span class="hljs-string">'Date'</span>].dt.day 
X_test = X_test.drop(<span class="hljs-string">'Date'</span>, axis=<span class="hljs-attr">1</span>) 
 
<span class="hljs-comment"># Now try to fit the model again </span>
model.fit(X_train, y_train) 
</code></pre>
    <p class="normal1">This<a id="_idIndexMarker886" class="calibre3"/> code first extracts the year, month, and day from the ‘Date’ column and adds them as new columns in the DataFrame. Then it drops the original ‘Date’ column. Finally, it tries to fit the model again. </p>
    <p class="normal1">Please note that this is a simple approach and might not be the best way to handle datetime data for your specific problem. The best approach depends on the nature of your data and the problem you’re trying to solve. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">So, our <code class="inlinecode">Date</code> column was the problem. The model training can only handle numerical data. It seems the response suggested we should extract features from the <code class="inlinecode">Date</code> column though, like year, month, and day, to preserve the info, but in numerical form. Additionally, we should then drop the <code class="inlinecode">Date</code> column as we got what we wanted from it. </p>
    <p class="normal1">Let’s try running the suggested code:</p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-comment"># Extract features from 'Date' </span>
X_train[<span class="hljs-string">'Year'</span>] = X_train[<span class="hljs-string">'Date'</span>].dt.year 
X_train[<span class="hljs-string">'Month'</span>] = X_train[<span class="hljs-string">'Date'</span>].dt.month 
X_train[<span class="hljs-string">'Day'</span>] = X_train[<span class="hljs-string">'Date'</span>].dt.day 
 
<span class="hljs-comment"># Drop the original 'Date' column </span>
X_train = X_train.drop(<span class="hljs-string">'Date'</span>, axis=<span class="hljs-attr">1</span>) 
 
<span class="hljs-comment"># Do the same for the test set </span>
X_test[<span class="hljs-string">'Year'</span>] = X_test[<span class="hljs-string">'Date'</span>].dt.year 
X_test[<span class="hljs-string">'Month'</span>] = X_test[<span class="hljs-string">'Date'</span>].dt.month 
X_test[<span class="hljs-string">'Day'</span>] = X_test[<span class="hljs-string">'Date'</span>].dt.day 
X_test = X_test.drop(<span class="hljs-string">'Date'</span>, axis=<span class="hljs-attr">1</span>) 
 
<span class="hljs-comment"># Now try to fit the model again </span>
model.fit(X_train, y_train) 
LinearRegression() 
</code></pre>
    <p class="normal1">You<a id="_idIndexMarker887" class="calibre3"/> should now see your code running without any issues. Let’s tell Copilot about this fact and see if it suggests how we can proceed.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Thanks, that works. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">You’re welcome! I’m glad to hear that it worked. Now that your model is trained, the next step is usually to use the model to make predictions on your test data. After that, you can evaluate the performance of your model by comparing these predictions to the actual values in your test data. If you have any more questions or need further assistance, feel free to ask. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <h1 class="heading" id="_idParaDest-420">Evaluate the model </h1>
    <p class="normal">As suggested by the response, Copilot <a id="_idIndexMarker888" class="calibre3"/>recommends asking the following: What are some common metrics for evaluating regression models? Let’s select this and see what it says. </p>
    <h2 class="heading1" id="_idParaDest-421">Evaluation metrics </h2>
    <p class="normal">Let’s ask Copilot about<a id="_idIndexMarker889" class="calibre3"/> evaluation metrics.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">What are some common metrics for evaluating regression models? </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">There are several common metrics for evaluating the performance of regression models: </p>
    <ul class="calibre15">
      <li class="bulletlist"><strong class="screentext">Mean Absolute Error (MAE)</strong>: This <a id="_idIndexMarker890" class="calibre3"/>is the average of the absolute differences between the predicted and actual values. It gives an idea of how wrong the predictions were. </li>
      <li class="bulletlist1"><strong class="screentext">Mean Squared Error (MSE)</strong>: This<a id="_idIndexMarker891" class="calibre3"/> is the average of the squared differences between the predicted and actual values. Squaring the differences amplifies the impact of large errors. </li>
      <li class="bulletlist1"><strong class="screentext">Root Mean Squared Error (RMSE)</strong>: This is<a id="_idIndexMarker892" class="calibre3"/> the square root of the MSE. It has the same units as the output variable, making it easier to interpret than the MSE. </li>
      <li class="bulletlist1"><strong class="screentext">R-squared (R²)</strong>: This is the <a id="_idIndexMarker893" class="calibre3"/>proportion of the variance in the dependent variable that is predictable from the independent variables. It provides a measure of how well the model’s predictions fit the actual data. A value of 1 means the model perfectly predicts the actual values, while a value of 0 means the model does not predict the actual values at all. </li>
      <li class="bulletlist1"><strong class="screentext">Adjusted R-squared</strong>: This is a<a id="_idIndexMarker894" class="calibre3"/> modified version of R-squared that has been adjusted for the number of predictors in the model. It increases only if the new term improves the model more than would be expected by chance. </li>
    </ul>
    <p class="normal1">Each of these<a id="_idIndexMarker895" class="calibre3"/> metrics has its own strengths and weaknesses, and the choice of which to use depends on the specific problem and the goals of the analysis. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">Now that we know how to evaluate and with what metrics, let’s make predictions next given our testing data, and see what we get in response.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Make predictions and evaluate the model using different metrics. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Sure, let’s use the trained model to make predictions on the test data. Then, we’ll evaluate these predictions using Mean Absolute Error (MAE), Mean Squared Error (MSE), Root Mean Squared Error (RMSE), and R-squared (R<sup class="superscript">²</sup>). We’ll use the metrics module from<a id="_idIndexMarker896" class="calibre3"/> sklearn to calculate these metrics. </p>
    <p class="normal1">Here’s how you can do it: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics 
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
 
<span class="hljs-comment"># Make predictions on the test data </span>
y_pred = model.predict(X_test) 
 
<span class="hljs-comment"># Calculate MAE, MSE, RMSE, and R2 </span>
mae = metrics.mean_absolute_error(y_test, y_pred) 
mse = metrics.mean_squared_error(y_test, y_pred) 
rmse = np.sqrt(mse) <span class="hljs-comment"># or metrics.mean_squared_error(y_test, y_pred, squared=False) </span>
r2 = metrics.r2_score(y_test, y_pred) 
 
<span class="hljs-comment"># Print the metrics </span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Mean Absolute Error (MAE):"</span>, mae) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Mean Squared Error (MSE):"</span>, mse) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Root Mean Squared Error (RMSE):"</span>, rmse) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"R-squared (R2 ):"</span>, r2) 
</code></pre>
    <p class="normal1">This code first uses the model to make predictions on the test data. Then it calculates the MAE, MSE, RMSE, and R<sup class="superscript">²</sup> by comparing these predictions to the actual values in the test data. Finally, it prints out these metrics. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">The code contains both metrics and calls a <code class="inlinecode">predict()</code> function that produces a response from the model; let’s try this and see if it works. </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics 
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np 
 
<span class="hljs-comment"># Make predictions on the test data </span>
y_pred = model.predict(X_test) 
 
<span class="hljs-comment"># Calculate MAE, MSE, RMSE, and R2 </span>
mae = metrics.mean_absolute_error(y_test, y_pred) 
mse = metrics.mean_squared_error(y_test, y_pred) 
rmse = np.sqrt(mse) <span class="hljs-comment"># or metrics.mean_squared_error(y_test, y_pred, squared=False) </span>
r2 = metrics.r2_score(y_test, y_pred) 
 
<span class="hljs-comment"># Print the metrics </span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Mean Absolute Error (MAE):"</span>, mae) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Mean Squared Error (MSE):"</span>, mse) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Root Mean Squared Error (RMSE):"</span>, rmse) 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"R-squared (R2 ):"</span>, r2) 
</code></pre>
    <p class="normal1">You should <a id="_idIndexMarker897" class="calibre3"/>see a response similar to the one below:</p>
    <pre class="programlisting"><code class="hljs-code">Mean Absolute Error (MAE): 0.458844690389933 
Mean Squared Error (MSE): 0.4236006011305136 
Root Mean Squared Error (RMSE): 0.6508460656180642 
R-squared (R2 ): 0.999868004623502 
</code></pre>
    <p class="normal1">Let’s provide Copilot with the response below to learn what we should do next.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <pre class="programlisting"><code class="hljs-code">Below is the output, Mean Absolute Error (MAE): 0.458844690389933 Mean Squared Error (MSE): 0.4236006011305136 Root Mean Squared Error (RMSE): 0.6508460656180642 R-squared (R2 ): 0.999868004623502 
</code></pre>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Great! The output shows the calculated metrics for your regression model. </p>
    <ul class="calibre15">
      <li class="bulletlist"><strong class="screentext">Mean Absolute Error (MAE)</strong>: The average absolute difference between the predicted and actual values is approximately 0.46. This means that on average, your predictions are about 0.46 units away from the actual values. </li>
      <li class="bulletlist1"><strong class="screentext">Mean Squared Error (MSE)</strong>: The average squared difference between the predicted and actual values is approximately 0.42. This metric is more sensitive to large errors than MAE because it squares the differences. </li>
      <li class="bulletlist1"><strong class="screentext">Root Mean Squared Error (RMSE)</strong>: The square root of the MSE is approximately 0.65. This metric is in the same units as the output variable, making it easier to interpret than the MSE. </li>
      <li class="bulletlist1"><strong class="screentext">R-squared (R²)</strong>: The proportion of the variance in the dependent variable that is predictable from the independent variables is approximately 0.9999. This is very close to 1, which indicates that your model explains almost all of the variability of the response data around its mean. </li>
    </ul>
    <p class="normal1">Overall, these<a id="_idIndexMarker898" class="calibre3"/> metrics suggest that your model is performing very well on the test data. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">Next, we want to have a sense of how well the model is performing by comparing predicted values to actual values, so let’s create a prompt to reflect that request.</p>
    <p class="normal1"><strong class="screentext">[Prompt]</strong></p>
    <p class="normal1">Display a comparison of predicted values versus actual values. </p>
    <p class="normal1"><strong class="screentext">[End of prompt]</strong></p>
    <p class="normal1">You should receive a response similar to the response below: </p>
    <p class="normal1"><strong class="screentext">[Prompt response]</strong></p>
    <p class="normal1">Sure, you can compare the predicted values with the actual values by visualizing them in a plot. Here’s how you can do it using matplotlib: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt 
 
<span class="hljs-comment"># Plot the actual values </span>
plt.scatter(X_test.index, y_test, color=<span class="hljs-string">'blue'</span>, label=<span class="hljs-string">'Actual'</span>) 
 
<span class="hljs-comment"># Plot the predicted values </span>
plt.scatter(X_test.index, y_pred, color=<span class="hljs-string">'red'</span>, label=<span class="hljs-string">'Predicted'</span>) 
 
plt.title(<span class="hljs-string">'Actual vs Predicted'</span>) 
plt.xlabel(<span class="hljs-string">'Index'</span>) 
plt.ylabel(<span class="hljs-string">'Target'</span>) 
plt.legend() 
plt.show() 
</code></pre>
    <p class="normal1">This code creates a scatter plot where the x-axis represents the index of the test set and the y-axis represents the target variable. The actual values are plotted in blue and the predicted values are plotted in red. This allows you to visually compare the predictions made by the model to the actual values. </p>
    <p class="normal1"><strong class="screentext">[End of response]</strong></p>
    <p class="normal1">The suggested code seems to want to create a scatter plot to better compare our predicted values <a id="_idIndexMarker899" class="calibre3"/>compared to our test data: </p>
    <pre class="programlisting"><code class="hljs-code"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt 
 
<span class="hljs-comment"># Plot the actual values </span>
plt.scatter(X_test.index, y_test, color=<span class="hljs-string">'blue'</span>, label=<span class="hljs-string">'Actual'</span>) 
 
<span class="hljs-comment"># Plot the predicted values </span>
plt.scatter(X_test.index, y_pred, color=<span class="hljs-string">'red'</span>, label=<span class="hljs-string">'Predicted'</span>) 
 
plt.title(<span class="hljs-string">'Actual vs Predicted'</span>) 
plt.xlabel(<span class="hljs-string">'Index'</span>) 
plt.ylabel(<span class="hljs-string">'Target'</span>) 
plt.legend() 
plt.show() 
</code></pre>
    <p class="normal1">Here’s the output from running the above code:</p>
    <figure class="mediaobject"><img alt="A graph with red dots  Description automatically generated" src="../Images/B21232_18_03.png" class="calibre19"/> </figure>
    <p class="packt_figref">Figure 18.3: Actual versus predicted data</p>
    <p class="normal1">We can<a id="_idIndexMarker900" class="calibre3"/> see how the predicted data matches the actual data quite well. Let’s try to sum up our learning next.</p>
    <h1 class="heading" id="_idParaDest-422">Assignment</h1>
    <p class="normal">Instead of using regression to predict a value, let’s take the same data but treat it as a classification problem and predict whether the stock price will go up or down the next day.</p>
    <h1 class="heading" id="_idParaDest-423">Summary</h1>
    <p class="normal">Regression is a fundamental concept in machine learning used to predict a continuous outcome variable based on one or more predictor variables. It involves identifying the relationship between a dependent variable (often called the target) and one or more independent variables (features). We saw that, given our dataset, we were able to find correlations for certain variables. We also found that we could include columns like Date, but to include these, we needed to extract the important numerical parts from those columns, namely the year, month, and date. </p>
    <p class="normal1">Regression has many applications in other sectors, like healthcare and marketing. From a prompt perspective, it’s a good idea to set the context early on and show Copilot the shape of the data, which will then help you ask Copilot what to do next. </p>
    <p class="normal1">In the next chapter, we will use the same dataset while using GitHub Copilot to help us write some code.</p>
    <h1 class="heading" id="_idParaDest-424">Join our community on Discord </h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: </p>
    <p class="normal1"><a href="https://packt.link/aicode" class="calibre3"><span class="calibre3">https://packt.link/aicode</span></a></p>
    <p class="normal1"><span class="calibre3"><img alt="" src="../Images/QR_Code510410532445718281.png" class="calibre4"/></span></p>
  </div>
</body></html>