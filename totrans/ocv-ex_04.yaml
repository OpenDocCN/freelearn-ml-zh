- en: Chapter 4. Delving into Histograms and Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned the basics of user interfaces in OpenCV
    using QT or native libraries and how to use advanced OpenGL user interfaces. We
    learned basic color conversions and filters that helped us create our first application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Histogram and histogram equalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look up tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blur and median blur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Gaussian Canny filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image color equalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding conversion between image types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we learn the basics of OpenCV and user interfaces, we will create our
    first complete application and a basic photo tool with the following functionalities
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate and draw a histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Histogram equalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lomography camera effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cartoonize effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This application will help you understand how to create a whole project from
    scratch and understand the histogram concept. We will see how to equalize the
    histogram of a color image and create two effects using a combination of filters
    and the use of look up tables.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a CMake script file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start creating our source file, we will generate the `CMakeLists.txt`
    file that will allow us to compile our project, structure, and executable. The
    following `cmake` script is simple and basic but enough to compile and generate
    the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to understand the script file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line indicates the minimum `cmake` version required to generate our
    project, and the second line sets the `CMP0012` policy variable to allow you to
    identify numbers and Boolean constants and remove the CMake warning if it is not
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After these two lines, we define the project name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we need to include the OpenCV library. The first thing to do is
    find the library and show a message about the OpenCV library version with the
    `MESSAGE` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If the library with the minimum version 3.0 is found, then we include the headers
    and library files in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need to add the source files that are to be compiled; in order
    to link them to the OpenCV library, we use the project name variable as an executable
    name and use only a single source file called `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Graphical User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start with the image processing algorithms, we will create the main
    user interface for our application. We will use a QT-based user interface to allow
    us to create single buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application receives one input parameter to load the image to be processed,
    and we will create the following four buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Show histogram**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Equalize histogram**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lomography effect**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cartoonize effect**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see the four results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Graphical User Interface](img/B04283_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s develop our project. First of all, we will include the required OpenCV
    headers. We define an `img` matrix to store the input image, and create a constant
    string to use the new command-line parser, which is only available in OpenCV 3.0\.
    In this constant, we allow only two input parameters: common help and the required
    image input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function starts with the command-line parser variable. We then set
    the instructions and print the help message. The following lines will help you
    set up the help instructions for our final executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user doesn''t require help, then we need to get the file path image
    in an `imgFile` variable string and check whether all the required parameters
    are added to the `parser.check()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can read the image file with the `imread` function and then create
    the window in which the input image will be shown later using the `namedWindow`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the image loaded and window created, we only need to create the buttons
    for our interface and link them to the `callback` functions. Each `callback` function
    is defined in the source code, and we will explain them later in this chapter.
    We will create the buttons with the `createButton` function with the `QT_PUSH_BUTTON`
    constant in the button style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our `main` function, we show the input image and wait for a key
    press to finish our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we only need to define the `callback` functions in the following sections,
    and we will define and describe each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a histogram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A histogram is a statistical graphic representation of variable distribution.
    This allows us to understand the density estimation and probability distribution
    of data. The histogram is created by dividing the entire range of variable values
    into a fixed number of intervals and then counting how many values fall into each
    interval.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply this histogram concept to an image, it seems to be complex to understand,
    but it is really very simple. In a gray image, our variable values can take any
    possible gray value ranging from `0` to `255`, and the density is the number of
    pixels in the image that have this value. This means that we have to count the
    number of image pixels that have the value `0`, count the number of pixels of
    value `1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function that shows the histogram of the input image is called
    `showHistoCallback`. This function calculates the histogram of each channel image
    and shows the result of each histogram channel in a new image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to understand how to extract each channel histogram and how to draw
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create three matrices to process each input image channel.
    We use a `vector` type variable to store each one, and use the split `OpenCV`
    function to divide the input image into three channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will define the number of bins in our histogram; in our case, one bin
    per possible pixel value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to define our range of variables and create three matrices to
    store each histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can calculate the histogram using the OpenCV `calcHist` function. This
    function has several parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The input image; in our case, we use one image channel stored in the `bgr` vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of images required to calculate the histogram in the input; in our
    case, we only use one image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dimensions of the number channel used to compute the histogram; we use 0
    in our case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional mask matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable used to store the calculated histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The histogram dimensionality (the dimension of the space where the image (here,
    it's a gray plane) takes its values); in our case, it's 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of bins to be calculated; in our case, we use 256 bins, one per pixel
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range of the input variable; in our case, it's a range of possible pixel
    values from `0` to `255`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `calcHist` function for each channel looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have calculated the histogram for each channel. We need to draw each
    channel histogram and show it to the user. To do this, we will create a color
    image with a size of 512 x 300 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we draw the histogram values in our image, we will normalize the histogram
    matrices between the `min` value `0` and a `max` value; in our case, the same
    value as that of the height of our image, 300 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to draw a line from bin 0 to bin 1 and so on. We need to calculate
    the number of pixels between each bin, and then a `binStep` variable is calculated
    by dividing the width by the number of bins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each small line is drawn from the horizontal position, `i-1` to `i`, and the
    vertical position is the histogram value in the corresponding `i`. It is drawn
    with the color channel representation, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we show the histogram image with the `imshow` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result of the lena.png image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing a histogram](img/B04283_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image color equalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to equalize a color image. Image equalization
    and histogram equalization try to obtain a histogram with a uniform distribution
    of values. The result of equalization is an increase in the contrast of an image.
    The equalization allows lower local contrast areas to gain higher contrast, spreading
    out the most frequent intensities.
  prefs: []
  type: TYPE_NORMAL
- en: This method is very useful when the image is almost dark or completely bright
    and there are very small differences between the background and foreground. Using
    histogram equalization, we increase the contrast and the details that are over-
    or under-exposed. This technique is very useful in medical images, such as X-rays.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are two main disadvantages to this method: it increases the
    background noise and decreases useful signals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the effect of equalization in the following image and see how the
    histogram changes and spreads on increasing the image contrast:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image color equalization](img/B04283_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to implement our histogram equalization. We will implement it in
    the callback function defined in the user interface''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To equalize a color image, we only need to equalize the luminance channel.
    We can do this with each color channel, but the result is not usable. Then, we
    can use any other color image format, such as HSV or YCrCb, that separates the
    luminance component in an individual channel. We choose this last color format
    and use a Y channel (luminance) to equalize it. Then, we perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We convert our input BGR image into YCrCb using the `cvtColor` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After converting our image, we split the YCrCb image into different `channels`
    matrices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then equalize the histogram only in the `Y channel` using the `equalizeHist`
    function, which has only two parameters: input and output matrices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we only need to merge the resulted channels and convert the result to
    the BGR format to show the user the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The process applied to a low contrast `Lena` image will have the following
    result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Image color equalization](img/B04283_04_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Lomography effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create another image effect, a photographic effect
    that is commonly used in different mobile applications, such as Google Camera
    or Instagram.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discover how to use a **Look up Table** or **LUT**.
    We will discuss LUTs later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to add an over image; in this case, a dark halo to create
    our desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that implements this effect is the callback `lomoCallback` and
    has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lomography effect is divided into different steps, but in our example we
    applied a very simple lomography effect using the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A color manipulation with a look up table that applies a curve to the red channel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A vintage effect that applies a dark halo to the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step is to manipulate the red color with a curve transform that applies
    this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lomography effect](img/B04283_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This formula generates a curve that makes the dark values darker and light
    values lighter, where *x* is the possible pixel value (0 to 255) and *s* is a
    constant that we set to *0.1* in our tutorial. A lower constant value that generates
    pixels with values lower than 128 is very dark and over 128 is very bright. Values
    that are near to *1* convert the curve to a line and do not generate our desired
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lomography effect](img/B04283_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This function is very easy to implement by applying a **Look Up Table**, more
    commonly called a LUT. A LUT is a vector or table that returns a preprocess value
    for a given value to perform computation in the memory. A LUT is a common technique
    used to spare CPU cycles by avoiding performing costly computations repeatedly.
    Instead of calling the exponential/divide function for each pixel, we perform
    it only once for each possible pixel value (256 times) and store the result in
    a table. Thus, we save the CPU time at the cost of a bit of memory. While this
    may not make a great difference for the standard PC with small image sizes, this
    makes a huge difference for CPU-limited hardware, such as the Raspberry Pi. In
    our case, if we want to apply our function for each pixel, we need to make the
    width by calculating the height; in 100 x 100 pixels, there are 10,000 calculations,
    but there are only 256 possible values for a pixel. We can then precalculate the
    pixel values and save them in a LUT vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our sample code, we define the `E` variable and create a `lut` matrix of
    1 row and 256 columns. Then, we do a loop over all possible pixel values by applying
    our formula and saving them in the `lut` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, in this section we don''t apply the function to all channels.
    We need to split our input image by channels using the `split` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then apply our `lut` table variable to the red channel. OpenCV give us the
    `LUT` function that has the following three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: An input image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix of a look up table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, our call to the `LUT` function and red channels looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only have to merge our computed channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is done, and we only have to create the dark halo to finish
    our effect. Then, we create a gray image with a white circle inside with the same
    input image size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![Lomography effect](img/B04283_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we apply this image to our input image, it will change from dark
    to white, and we can then apply a big blur using the `blur` filter function to
    our circle halo image to get a smooth effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result after applying the blur filter is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lomography effect](img/B04283_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we need to apply this halo to our image from step 1\. An easy way to do
    this is to multiply both the images. But we need to convert our input image from
    an 8-bit image to a 32-bit float because we need to multiply our blurred image
    that has values ranging from 0 to 1 by our input image that has integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After we convert our image, we only need to multiply each matrix per element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we convert the float image matrix result to an 8-bit image and show
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![Lomography effect](img/B04283_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The cartoonize effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section of this chapter, we create another effect called **cartoonize**.
    The purpose of this effect is to create an image that looks like a cartoon. To
    do this, we divide the algorithm into two steps: edge detection and color filtering.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cartoonCallback` functions define this effect with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to detect the most important edges of the image. We need
    to remove noise from the input image before we detect the edges. There are several
    ways and methods to do this. We will use a median filter to remove any possible
    small noise, but we can use other methods such as Gaussian blur and so on. The
    OpenCV function is called `medianBlur` and accepts three parameters: an input
    image, an output image, and the kernel size (a kernel is a small matrix used to
    apply some mathematical operation such as convolutional to an image).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing any possible noise, we detect the strong edges with a `canny`
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `canny` filter accepts the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: An input image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sobel size aperture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Boolean value to check whether to use a more accurate image gradient magnitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smallest value between the first and second threshold is used for edge linking.
    The largest value is used to find initial segments of strong edges. The `solbel`
    size aperture is the kernel size of the `sobel` filter that will be used in the
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'After detecting the edges, we will apply a small dilation to join the broken
    edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we did in the Lomography effect, we need to multiply our edges''
    result image by the color image. Then, we require a pixel value between `0` and
    `1`, and so we divide the canny result by `256` and invert the edges to black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the Canny 8 unsigned bit format to a float matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To give a cool result, we can blur the edges to give a smooth result line,
    and then we apply a blur filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first step of the algorithm is complete, and now we will work with the color.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a cartoon look and feel, we will use the bilateral filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: A bilateral filter is a filter used to reduce the noise of an image while keeping
    edges, but we can get a cartoonish effect with appropriate parameters that we
    will explore later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bilateral filter parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An input image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An output image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diameter of a pixel neighborhood; if it's set to negative, it is computed
    from a sigma space value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sigma color value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sigma coordinate space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a diameter greater than 5, the bilateral filter becomes slow. With sigma
    values greater than 150, a cartoonish effect appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a stronger cartoonish effect, we truncate the possible color values
    to 10 by dividing and multiplying the pixel values. For other values, and to better
    understand the sigma parameters, read the OpenCV documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to merge the color and edges'' results. Then, we need to create
    a `3`-channel image from the first step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we convert our color result image to a 32 float image and then multiply
    both the images per element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we only need to convert our image to an 8-bit image and show the resulting
    image to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following image, we can see the input image (the left-hand side image)
    and the result after applying the cartoonize effect (the right-hand side image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The cartoonize effect](img/B04283_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a complete project that manipulates
    images after applying different effects. We also split a color image in multiple
    matrices in order to apply effects to only one channel. We learned how to create
    look up tables, merge multiple matrices in one, use a canny and bilateral filter,
    draw circles, and multiply images to perform halo effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to do object inspection and how to segment
    an image in different parts and detect it.
  prefs: []
  type: TYPE_NORMAL
