<html><head></head><body>
<div id="_idContainer106">
<h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-115"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.2.1">Measuring Movement with Encoders on Raspberry Pi Pico</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Robots don’t just run code blindly; they need sensors. </span><span class="koboSpan" id="kobo.3.2">What sensors do we add first? </span><span class="koboSpan" id="kobo.3.3">Our robot already has some sensors on board, and in this chapter, we’ll see how to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">use them.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We finished the previous chapter noticing that timing isn’t the most accurate way to determine robot movement. </span><span class="koboSpan" id="kobo.5.2">So, let’s see how our first sensor, encoders, can improve this. </span><span class="koboSpan" id="kobo.5.3">Encoders are the first step in getting accurate movement and location estimation in robots. </span><span class="koboSpan" id="kobo.5.4">We will also learn one of Raspberry Pi Pico’s excellent features – </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Programmable </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.7.1">IO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.8.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.9.1">PIO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">We’ll dig into movement fundamentals, odometry and encoding, look at Raspberry Pi Pico PIO in CircuitPython, and use this to get data from the encoders on </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">our robot.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">About encoders </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and odometry</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Wiring in encoders on a Raspberry Pi </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Pico robot</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Programming Raspberry Pi </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Pico PIO</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Measuring encoder count </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">for movement</span></span></li>
</ul>
<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">For this chapter, you will need </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">First is the built robot, as made in the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">previous chapters</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">6 x fresh </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">AA batteries</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">A PC or laptop with a USB </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">micro cable</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Mu software to write our code and </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">upload it</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Clear floor space with a meter or so in each direction to test </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">the robot</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">All code examples are on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">at </span></span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-06</span></span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.40.1">About encoders and odometry</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.41.1">Odometry</span></strong><span class="koboSpan" id="kobo.42.1"> is measuring how </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.43.1">a position has changed over time. </span><span class="koboSpan" id="kobo.43.2">We can combine measuring and estimation to determine where you are on a route. </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">An encoder</span></strong><span class="koboSpan" id="kobo.45.1"> is a sensor </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.46.1">designed to measure distance traveled via wheel turns. </span><span class="koboSpan" id="kobo.46.2">They </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.47.1">are like </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">tachometers</span></strong><span class="koboSpan" id="kobo.49.1">, but encoders measure position whereas tachometers measure only speed. </span><span class="koboSpan" id="kobo.49.2">Combined with time, they can make a speed </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">measurement too.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.51.1">Absolute and relative sensing</span></h2>
<p><span class="koboSpan" id="kobo.52.1">Sensors for a robot’s location come in two primary forms. </span><span class="koboSpan" id="kobo.52.2">They are </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.54.1">Absolute sensors</span></strong><span class="koboSpan" id="kobo.55.1"> encode a </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.56.1">position to a repeatable position. </span><span class="koboSpan" id="kobo.56.2">They have a limited range or resolution, such as encoding a position along a known line. </span><span class="koboSpan" id="kobo.56.3">For example, GPS sensors have exact positioning with low resolution, suitable for meters but </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">not millimeters.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.58.1">Relative sensors</span></strong><span class="koboSpan" id="kobo.59.1"> tend to </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.60.1">be cheaper. </span><span class="koboSpan" id="kobo.60.2">However, they produce a relative change in position, which needs to be combined with the previous state to get an absolute estimate – this means that errors can accumulate. </span><span class="koboSpan" id="kobo.60.3">Relative </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.61.1">encoders are one example of relative sensors, also known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">incremental encoders</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.64.1">If a sensor tells you where something is </span><em class="italic"><span class="koboSpan" id="kobo.65.1">at</span></em><span class="koboSpan" id="kobo.66.1">, it is absolute. </span><span class="koboSpan" id="kobo.66.2">It is relative if it tells you how much something has </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">moved </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.68.1">by</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.70.1">Types of encoders</span></h2>
<p><span class="koboSpan" id="kobo.71.1">Most encoder </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.72.1">designs work by passing markers or code over a sensor that counts or decodes </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">the pulses.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Encoders come in a few forms. </span><span class="koboSpan" id="kobo.74.2">Some example types are </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.76.1">A potentiometer or </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">variable resistor</span></strong><span class="koboSpan" id="kobo.78.1"> can sense </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.79.1">an absolute </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.80.1">encoder position by measuring resistance. </span><span class="koboSpan" id="kobo.80.2">Servo motors </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.81.1">use them. </span><span class="koboSpan" id="kobo.81.2">However, potentiometers are not suitable for continuous rotations such as wheels, as their track lengths limit them. </span><span class="koboSpan" id="kobo.81.3">In addition, regular movement wears them down, as they move contacts across </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">each other.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.83.1">Mechanical encoders</span></strong><span class="koboSpan" id="kobo.84.1"> pass </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.85.1">electrical contacts </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.86.1">over each other, producing on and off pulses. </span><span class="koboSpan" id="kobo.86.2">They are subject to heavy wear, so I do not </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">recommend them.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Optical encoders</span></strong><span class="koboSpan" id="kobo.89.1"> shine a </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.90.1">light through a </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.91.1">disk or strip with slots and detect the passing of slots in front of light sensors. </span><span class="koboSpan" id="kobo.91.2">They can come in absolute and relative flavors. </span><span class="koboSpan" id="kobo.91.3">They can be susceptible to interference from light sources or </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">just dirt.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.93.1">Magnetic encoders</span></strong><span class="koboSpan" id="kobo.94.1"> detect </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.95.1">the movements of </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.96.1">magnets in a disc using </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">hall-effect sensors</span></strong><span class="koboSpan" id="kobo.98.1">. </span><span class="koboSpan" id="kobo.98.2">Dirt, light </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.99.1">interference, and physical wear do not affect them so much. </span><span class="koboSpan" id="kobo.99.2">Hall-effect sensors produce a voltage depending on a magnetic field – encoder modules produce pulses </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">from this.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.101.1">The motors we chose came with rotary magnetic encoders in a convenient and small format as part of the package. </span><span class="koboSpan" id="kobo.101.2">They are </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">incremental encoders.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.103.1">Encoder pulse data</span></h2>
<p><span class="koboSpan" id="kobo.104.1">We can better </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.105.1">understand encoders by looking at the pulses they output. </span><span class="koboSpan" id="kobo.105.2">Relative encoders usually output digital pulse chains, 1s and 0s. </span><span class="koboSpan" id="kobo.105.3">The simplest form is just to count pulse edges by detecting marks passing a sensor, as the following </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">diagram shows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.107.1"><img alt="Figure 6.1 – Simple pulse encoding " src="image/Figure_6.01_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.108.1">Figure 6.1 – Simple pulse encoding</span></p>
<p><span class="koboSpan" id="kobo.109.1">On the left of </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.110.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.111.1">.1</span></em><span class="koboSpan" id="kobo.112.1"> is a disk with a rotation arrow. </span><span class="koboSpan" id="kobo.112.2">On the disk are four white marks – representing the markers passing a sensor. </span><span class="koboSpan" id="kobo.112.3">The black rectangular object is the sensor that </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.113.1">detects the markers. </span><span class="koboSpan" id="kobo.113.2">The sensor produces a value of 0 when it isn’t detecting a marker and 1 when it is – making a bunch of pulses or a stream of binary bits with values of 1 </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">or 0.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">We can count the pulses to get an idea of far the wheel has turned. </span><span class="koboSpan" id="kobo.115.2">We count a high pulse as 1 and a low pulse as 0. </span><span class="koboSpan" id="kobo.115.3">We can also count </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">edges</span></strong><span class="koboSpan" id="kobo.117.1">, the changes from 0 to 1 and 1 to 0. </span><span class="koboSpan" id="kobo.117.2">Counting edges gives us eight steps per wheel turn. </span><span class="koboSpan" id="kobo.117.3">The graph to the right of the following diagram shows </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">these pulses.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">We are likely to want to increase that sensitivity and detect which direction a wheel is going. </span><span class="koboSpan" id="kobo.119.2">To do that, we add a second sensor to the same wheel, as the following </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">diagram shows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.121.1"><img alt="Figure 6.2 – Quadrature pulse encoding " src="image/Figure_6.02_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.122.1">Figure 6.2 – Quadrature pulse encoding</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.123.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.124.1">.2</span></em><span class="koboSpan" id="kobo.125.1"> adds a second sensor to catch the markers at a slightly different time from the first, generating pulses out of phase; this means we have two streams </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">of pulses.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">At the top right is the pulse graph for the first sensor, with the digits we had read from times between the pulses added, showing a pulse train of 16 bits for the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">same period.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">The middle </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.130.1">graph shows the additional sensor, with the out-of-phase 16-digit pulse train. </span><span class="koboSpan" id="kobo.130.2">Below the graphs are the two states combined at each point in </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.131.1">time as </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Gray code</span></strong><span class="koboSpan" id="kobo.133.1">, with 2 bits of information on where we are relative to the last position. </span><span class="koboSpan" id="kobo.133.2">We have twice as many edges, increasing the sensor resolution and also encoding the wheel’s direction. </span><span class="koboSpan" id="kobo.133.3">If we reverse the wheel, this sequence will </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.134.1">reverse. </span><span class="koboSpan" id="kobo.134.2">This system is known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.135.1">quadrature encoding</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">Let’s look at the encoders on our robot in the </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">next section.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.139.1">Wiring in encoders on a Raspberry Pi Pico robot</span></h1>
<p><span class="koboSpan" id="kobo.140.1">Our </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.141.1">robot has already got encoders on board, and </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.142.1">we have already wired them in. </span><span class="koboSpan" id="kobo.142.2">We can take a closer look at the motors and how they are wired into Raspberry Pi Pico GPIO pins to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">robot better.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.144.1">Examining the motors</span></h2>
<p><span class="koboSpan" id="kobo.145.1">We use </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.146.1">N20 geared motors with encoders. </span><span class="koboSpan" id="kobo.146.2">The following diagram labels the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">motor parts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<span class="koboSpan" id="kobo.148.1"><img alt="Figure 6.3 – The N20 motor parts " src="image/Figure_6.03_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.149.1">Figure 6.3 – The N20 motor parts</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.150.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.151.1">.3</span></em><span class="koboSpan" id="kobo.152.1"> shows a drawing of the motors we have used. </span><span class="koboSpan" id="kobo.152.2">Marked on it are essential features that affect how we use the encoders. </span><span class="koboSpan" id="kobo.152.3">On the left is a magnetic disk with markers in it. </span><span class="koboSpan" id="kobo.152.4">This disk is attached to the motor’s driveshaft and sensed by the encoder sensor board. </span><span class="koboSpan" id="kobo.152.5">On the right are the gearbox and the motor </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">output shaft.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">The driveshaft goes through the gearbox, so the output shaft will not make the same number of rotations as the disk – the gear ratio will determine this relationship. </span><span class="koboSpan" id="kobo.154.2">So one revolution of the output wheel could count many pulses; this gives us high resolution. </span></p>
<p><span class="koboSpan" id="kobo.155.1">Consult the datasheet for the motors. </span><span class="koboSpan" id="kobo.155.2">Some Chinese characters are likely, but important numbers are usually in English. </span><span class="koboSpan" id="kobo.155.3">You may need translation services built into web search engines here. </span><span class="koboSpan" id="kobo.155.4">The datasheet and product page have two important numbers, the number of encoder counts per disk revolution and the gear ratio. </span><span class="koboSpan" id="kobo.155.5">The datasheet may note counts per disk revolution as </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">pole count.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">In my case, the gear ratio is 298:1, and the pole count is 14. </span><span class="koboSpan" id="kobo.157.2">Interpreting these facts means I get 298 turns of my encoder wheel per output wheel revolution. </span><span class="koboSpan" id="kobo.157.3">Each encoder turn </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.158.1">produces 14 poles on each sensor (two sensors), so we get 28 edges. </span><span class="koboSpan" id="kobo.158.2">Multiplying the number of sensor pulses by the gear ratio gives 8344 edges </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">per turn.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.160.1">Examining the wiring</span></h2>
<p><span class="koboSpan" id="kobo.161.1">We saw </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.162.1">the wiring for our robot in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.163.1">Figure 4</span></em></span><em class="italic"><span class="koboSpan" id="kobo.164.1">.20</span></em><span class="koboSpan" id="kobo.165.1"> of </span><a href="B18001_04.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.166.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.167.1">, </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Building a Robot around Pico</span></em><span class="koboSpan" id="kobo.169.1">. </span><span class="koboSpan" id="kobo.169.2">However, to better illustrate the encoder connections, here is a diagram focusing only on the wiring of encoders </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">to Pico:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<span class="koboSpan" id="kobo.171.1"><img alt="Figure 6.4 – Encoders wired to Raspberry Pi Pico " src="image/Figure_6.04_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">Figure 6.4 – Encoders wired to Raspberry Pi Pico</span></p>
<p><span class="koboSpan" id="kobo.173.1">The preceding figure takes a closer look at data connections for a robot encoder connection schematic. </span><span class="koboSpan" id="kobo.173.2">On the left is Raspberry Pi Pico; this has four connections from the encoders. </span><span class="koboSpan" id="kobo.173.3">These are on GPIO 20, 21, 26, and 27. </span><span class="koboSpan" id="kobo.173.4">Each of these can be set as input pins to read the state of the encoder pins. </span></p>
<p><span class="koboSpan" id="kobo.174.1">If we were just reading encoders alone, we could write code to check each pin in sequence. </span><span class="koboSpan" id="kobo.174.2">However, doing this may tie things up. </span><span class="koboSpan" id="kobo.174.3">What if we could get components of the Pico to monitor these pins and pulse chains for us so that we could just read a counter for them when we </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">need it?</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.176.1">Programming Raspberry Pi Pico PIO</span></h1>
<p><span class="koboSpan" id="kobo.177.1">We saw </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.178.1">the PIO system back in </span><a href="B18001_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.179.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">We could read encoders in Python on the Pico central cores; however, we can make monitoring the encoders the responsibility of PIO, letting those central cores do other things. </span><span class="koboSpan" id="kobo.180.3">The PIO system can read and decode the Gray code emitted by the encoders. </span><span class="koboSpan" id="kobo.180.4">This section will show how to program PIO in assembler and load the programs </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">with CircuitPython.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.182.1">Introduction to PIO programming</span></h2>
<p><span class="koboSpan" id="kobo.183.1">As we saw in </span><a href="B18001_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.184.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.185.1">, Pico has two PIO devices, each with </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.186.1">four state machines. </span><span class="koboSpan" id="kobo.186.2">We program PIO in </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">assembly language</span></strong><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">Instructions command PIO to perform operations such as manipulating IO pins, registers, and </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">first in first out</span></strong><span class="koboSpan" id="kobo.190.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.191.1">FIFO</span></strong><span class="koboSpan" id="kobo.192.1">) queues. </span><span class="koboSpan" id="kobo.192.2">The following diagram is a simplified representation of a </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">state machine:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<span class="koboSpan" id="kobo.194.1"><img alt="Figure 6.5 – The Raspberry Pi Pico PIO state machines " src="image/Figure_6.05_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.195.1">Figure 6.5 – The Raspberry Pi Pico PIO state machines</span></p>
<p><span class="koboSpan" id="kobo.196.1">The preceding </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.197.1">diagram shows Raspberry Pi Pico PIO state machines, highlighting registers and other features. </span><span class="koboSpan" id="kobo.197.2">It shows the two PIO devices and the state machines </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">in them.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">register</span></strong><span class="koboSpan" id="kobo.201.1"> is like a variable; they have fixed names, and there are only a few per core. </span><span class="koboSpan" id="kobo.201.2">PIO registers are 32-bit and specific to each state machine. </span><span class="koboSpan" id="kobo.201.3">We use an essential subset: </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">input shift register</span></strong><span class="koboSpan" id="kobo.203.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.204.1">ISR</span></strong><span class="koboSpan" id="kobo.205.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">output shift register</span></strong><span class="koboSpan" id="kobo.207.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.208.1">OSR</span></strong><span class="koboSpan" id="kobo.209.1">), and </span><em class="italic"><span class="koboSpan" id="kobo.210.1">X </span></em><span class="koboSpan" id="kobo.211.1">and </span><em class="italic"><span class="koboSpan" id="kobo.212.1">Y</span></em><span class="koboSpan" id="kobo.213.1"> (scratch registers). </span><span class="koboSpan" id="kobo.213.2">They </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.214.1">can store a number or a binary pattern. </span><span class="koboSpan" id="kobo.214.2">It is </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.215.1">common to refer to 32 bits </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.217.1">words</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Each state machine runs the program independently, so the same code runs four times, with independent registers. </span><span class="koboSpan" id="kobo.219.2">In addition, mappings (shown as dashed lines) connect state machines to IO pins – the tiny rectangles. </span><span class="koboSpan" id="kobo.219.3">Code can configure which state machines use which pins and a single state machine can read/write from </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">many pins.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">State machines also have FIFO queues. </span><span class="koboSpan" id="kobo.221.2">Data put into a FIFO queue comes out in the same order. </span><span class="koboSpan" id="kobo.221.3">Each can hold 4 x 32-bit words. </span><span class="koboSpan" id="kobo.221.4">These let PIO </span><strong class="bold"><span class="koboSpan" id="kobo.222.1">transmit</span></strong><span class="koboSpan" id="kobo.223.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.224.1">TX</span></strong><span class="koboSpan" id="kobo.225.1">) data from or </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">receive</span></strong><span class="koboSpan" id="kobo.227.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.228.1">RX</span></strong><span class="koboSpan" id="kobo.229.1">) data to other devices within the rest of Pico. </span><span class="koboSpan" id="kobo.229.2">We can configure FIFO queues in many ways. </span><span class="koboSpan" id="kobo.229.3">For this chapter, we will use the RX FIFO queue to receive data from PIO to </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">Each PIO block can run an independent program with 32 instructions – each roughly, but not quite, a line of code. </span><span class="koboSpan" id="kobo.231.2">But how do we write and use </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">these programs?</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.233.1">Introducing PIOASM</span></h2>
<p><span class="koboSpan" id="kobo.234.1">In CircuitPython, we assemble the PIO code using the Adafruit CircuitPython </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">PIOASM</span></strong><span class="koboSpan" id="kobo.236.1"> library. </span><span class="koboSpan" id="kobo.236.2">This runs </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.237.1">on Pico, taking the assembly code in a string and outputting a sequence of bytes with the code </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">in it.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">We need to put this </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">PIOASM</span></strong><span class="koboSpan" id="kobo.241.1"> library onto Raspberry </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">Pi Pico:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.243.1">First, find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">CIRCUITPY</span></strong><span class="koboSpan" id="kobo.245.1"> volume on </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">your computer.</span></span></li>
<li><span class="koboSpan" id="kobo.247.1">From the Adafruit CircuitPython library (as discussed in </span><a href="B18001_02.xhtml#_idTextAnchor041"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.249.1">), copy </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">lib/adafruit_pioasm.mpy</span></strong><span class="koboSpan" id="kobo.251.1"> into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">lib</span></strong><span class="koboSpan" id="kobo.253.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">CIRCUITPY</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.257.1">With that in place, we can write our first PIO-based program. </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">Here’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">pio_led_test.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
import time
import board
import rp2pio
import adafruit_pioasm</span></pre>
<p><span class="koboSpan" id="kobo.262.1">The first four lines are imports. </span><span class="koboSpan" id="kobo.262.2">You’ve seen </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">time</span></strong><span class="koboSpan" id="kobo.264.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">board</span></strong><span class="koboSpan" id="kobo.266.1"> before. </span><span class="koboSpan" id="kobo.266.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">rp2pio</span></strong><span class="koboSpan" id="kobo.268.1"> library lets us communicate with the PIO blocks and start code and interact with state machines. </span><span class="koboSpan" id="kobo.268.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">adafruit_pioasm</span></strong><span class="koboSpan" id="kobo.270.1"> library turns assembly code into bytes that PIO state machines can run. </span><span class="koboSpan" id="kobo.270.2">Now, let’s get into the </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">assembly code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
led_flash = """
    pull
    out pins, 1
"""</span></pre>
<p><span class="koboSpan" id="kobo.273.1">The preceding code puts some PIO assembly into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">led_flash</span></strong><span class="koboSpan" id="kobo.275.1"> string. </span><span class="koboSpan" id="kobo.275.2">Triple quotes in Python declare a long multi-line string. </span></p>
<p><span class="koboSpan" id="kobo.276.1">The assembly </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.277.1">code starts with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">pull</span></strong><span class="koboSpan" id="kobo.279.1"> instruction; this gets a word from the TX FIFO queue (removing it) and stores it in the OSR. </span><span class="koboSpan" id="kobo.279.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">out pins, 1</span></strong><span class="koboSpan" id="kobo.281.1"> instruction puts 1 bit of data from the OSR onto the configured pins – setting the state of a single pin. </span><span class="koboSpan" id="kobo.281.2">The code wraps around to run at the first instruction in a loop. </span><span class="koboSpan" id="kobo.281.3">We need to assemble </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
assembled = adafruit_pioasm.assemble(led_flash)</span></pre>
<p><span class="koboSpan" id="kobo.284.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">adafruit_pioasm.assemble</span></strong><span class="koboSpan" id="kobo.286.1"> function generates bytecode, which we store in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">assembled</span></strong><span class="koboSpan" id="kobo.288.1"> variable. </span><span class="koboSpan" id="kobo.288.2">We can </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">run this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
sm = rp2pio.StateMachine(
    assembled,
    frequency=2000,
    first_out_pin=board.LED,
)</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">rp2pio.StateMachine</span></strong><span class="koboSpan" id="kobo.292.1"> requests a state machine to run this code, telling it how fast to run and which output pin to map to – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">board.LED</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">Our code will be running on the PIO, but we have no data in the FIFO queue, so it will be waiting for us to write something </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">We can write data with a loop in </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">this program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
while True:
    sm.write(bytes([1]))
    time.sleep(0.5)
    sm.write(bytes([0]))
    time.sleep(0.5)</span></pre>
<p><span class="koboSpan" id="kobo.299.1">This loop </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.300.1">writes 1s and 0s to the state machine (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">sm</span></strong><span class="koboSpan" id="kobo.302.1"> variable). </span><span class="koboSpan" id="kobo.302.2">It must wrap the data as a list since a FIFO queue can store more than one data element as a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">bytes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1"> type.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Send this to Raspberry Pi Pico, and the LED will flash. </span><span class="koboSpan" id="kobo.305.2">Let's ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">this works.</span></span></p>
<h3><span class="koboSpan" id="kobo.307.1">Troubleshooting PIO code</span></h3>
<p><span class="koboSpan" id="kobo.308.1">Writing </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.309.1">assembler code is somewhat tricky the first time – these tips can help you </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">get moving:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.311.1">This code uses the Python triple quote, </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">"""</span></strong><span class="koboSpan" id="kobo.313.1">, for a multi-line string. </span><span class="koboSpan" id="kobo.313.2">Ensure you have three quotes at both ends of the assembly section, or you will </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">see errors.</span></span></li>
<li><span class="koboSpan" id="kobo.315.1">If Pico cannot load </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">adafruit_pioasm</span></strong><span class="koboSpan" id="kobo.317.1">, ensure you have followed the setup steps to copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">mpy</span></strong><span class="koboSpan" id="kobo.319.1"> file into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">lib</span></strong><span class="koboSpan" id="kobo.321.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">on Pico.</span></span></li>
<li><span class="koboSpan" id="kobo.323.1">Note that there must be two close brackets after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">sm.write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1"> statements.</span></span></li>
<li><span class="koboSpan" id="kobo.326.1">If Pico is not running your code, remember to import your code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">code.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1"> file.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.329.1">These tips should get you up </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">and running.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Now we have our first PIO code, we can try reading data back from an </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">I/O pin.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.333.1">Detecting input with PIO</span></h2>
<p><span class="koboSpan" id="kobo.334.1">Fetching input </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.335.1">from PIO is as simple as getting a pin state into a register and pushing that onto the RX FIFO queue for the Python code to pick up. </span><span class="koboSpan" id="kobo.335.2">Create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">pio_read_1_pin.py</span></strong><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">We will add one more import to read </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">PIO data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
import board
import time 
import rp2pio
import adafruit_pioasm
import array</span></pre>
<p><span class="koboSpan" id="kobo.340.1">The assembly section looks </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
pio_input = """
.program pio_input
    in pins, 1      ; read in pin (into ISR)
    push noblock    ; put this into input FIFO
"""
assembled = adafruit_pioasm.assemble(pio_input)
sm = rp2pio.StateMachine(
    assembled,
    frequency=2000,
    first_in_pin=board.GP20
)</span></pre>
<p><span class="koboSpan" id="kobo.343.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">in pins,</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.345.1">1</span></strong><span class="koboSpan" id="kobo.346.1"> instruction will read 1 bit of data from 1 input pin and store this in the ISR. </span><span class="koboSpan" id="kobo.346.2">Following this is a comment starting with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">;</span></strong><span class="koboSpan" id="kobo.348.1"> character that is for humans to read. </span><span class="koboSpan" id="kobo.348.2">The spaces </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.349.1">are optional and are there to aid readability by aligning the comments. </span><span class="koboSpan" id="kobo.349.2">You can also add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">.program</span></strong><span class="koboSpan" id="kobo.351.1"> line – effectively </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">another comment.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">The next instruction is </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">push noblock</span></strong><span class="koboSpan" id="kobo.355.1">, which will take the ISR register and push it as a word onto the RX FIFO queue. </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">noblock</span></strong><span class="koboSpan" id="kobo.357.1"> ensures it will not wait for the FIFO queue to be empty – note that data is not written to the FIFO queue if it </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">is full.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">We then assemble this code and load it into a state machine, passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">first_in_pin</span></strong><span class="koboSpan" id="kobo.361.1"> to map one of our encoder pins as input. </span><span class="koboSpan" id="kobo.361.2">Next, we need a buffer to read our FIFO queue data where the Python code can </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">use it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.363.1">
buffer = array.array('I', [0])</span></pre>
<p><span class="koboSpan" id="kobo.364.1">The array type makes fixed-size data structures in memory. </span><span class="koboSpan" id="kobo.364.2">It specifies an unsigned 32-bit integer with </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">'I'</span></strong><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">We size it as 1 element and initialize it </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">main</span></strong><span class="koboSpan" id="kobo.372.1"> loop reads data into the buffer and </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">prints it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
while True:
    sm.readinto(buffer)
    print(f"{buffer[0]:032b}")
    time.sleep(0.1)</span></pre>
<p><span class="koboSpan" id="kobo.375.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">sm.readinto</span></strong><span class="koboSpan" id="kobo.377.1"> Python function pulls data from a FIFO queue into a waiting buffer. </span><span class="koboSpan" id="kobo.377.2">It will wait if there is no new data to fetch. </span></p>
<p><span class="koboSpan" id="kobo.378.1">We then use </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.379.1">a fancy print to output our data. </span><span class="koboSpan" id="kobo.379.2">Python </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">f</span></strong><span class="koboSpan" id="kobo.381.1">-strings (prefixed with an f) let you use a variable in the string – in this case, extracting the only element of </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">buffer</span></strong><span class="koboSpan" id="kobo.383.1">. </span><span class="koboSpan" id="kobo.383.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">:032b</span></strong><span class="koboSpan" id="kobo.385.1"> format specifier tells Python to format the data as 32-digit binary, with the empty digits in front filled </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">with 0s.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">When you run this, you will see a repeating output with one of </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">two states:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">10000000000000000000000000000000</span></strong><span class="koboSpan" id="kobo.390.1">, showing the encoder pin </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">is high</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">00000000000000000000000000000000</span></strong><span class="koboSpan" id="kobo.393.1">, showing the encoder pin </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">is low</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.395.1">Turn the wheels on the robot slowly. </span><span class="koboSpan" id="kobo.395.2">One of them will make the pin change states. </span><span class="koboSpan" id="kobo.395.3">It may be surprising that the 1 bit is at the start of the data (and would be there in the ISR before we </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">sent it).</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">We can extend this code to work with two pins easily. </span><span class="koboSpan" id="kobo.397.2">Copy this to </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">pio_read_2_pins.py</span></strong><span class="koboSpan" id="kobo.399.1"> and make the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">following modification:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.401.1">
pio_input = """
.program pio_input
    in pins, </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">2</span></strong><span class="koboSpan" id="kobo.403.1">      ; read in two pins (into ISR)
    push noblock    ; put ISR into input FIFO
"""</span></pre>
<p><span class="koboSpan" id="kobo.404.1">The other code remains the same, except that when we run it to turn the wheel slowly, the output will now show 2 bits from the encoder, in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">four states:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.406.1">
11000000000000000000000000000000
01000000000000000000000000000000 
10000000000000000000000000000000 
00000000000000000000000000000000 </span></pre>
<p><span class="koboSpan" id="kobo.407.1">These are </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.408.1">the bits of the quadrature encoding discussed previously! </span></p>
<h3><span class="koboSpan" id="kobo.409.1">Troubleshooting</span></h3>
<p><span class="koboSpan" id="kobo.410.1">This section </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.411.1">is the first time we have tried to get information from the encoders, and issues may occur. </span><span class="koboSpan" id="kobo.411.2">Try </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">these steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.413.1">If the data values are not changing, check the </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">wiring carefully.</span></span></li>
<li><span class="koboSpan" id="kobo.415.1">If only 1 bit is changing, 1 encoder wire may </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">be incorrect.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.417.1">We have data, but the PIO can work harder to decode this and count it for us. </span><span class="koboSpan" id="kobo.417.2">Next, let's look at these PIO instructions and how they interact </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">with registers.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.419.1">PIO instructions and registers</span></h2>
<p><span class="koboSpan" id="kobo.420.1">Understanding how registers are changed and manipulated by PIO instructions is crucial to writing </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.421.1">and understanding PIO code. </span><span class="koboSpan" id="kobo.421.2">The PIO has nine instruction </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.422.1">types; however, they have several modes, making their use nuanced and complex. </span><a href="B18001_03.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.423.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.424.1"> of the </span><em class="italic"><span class="koboSpan" id="kobo.425.1">RP2040 datasheet</span></em><span class="koboSpan" id="kobo.426.1"> from Raspberry Pi serves as a comprehensive reference. </span><span class="koboSpan" id="kobo.426.2">We can get familiar with a few </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">more here.</span></span></p>
<h3><span class="koboSpan" id="kobo.428.1">Debugging a register</span></h3>
<p><span class="koboSpan" id="kobo.429.1">This next </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.430.1">example shows how to store a value in a register and surface it to code for printing. </span><span class="koboSpan" id="kobo.430.2">We keep the imports as before. </span><span class="koboSpan" id="kobo.430.3">Call this </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">file </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">pio_debugging_registers.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
program = """
    set y, 21 
    mov isr, y 
    push noblock 
"""
assembled = adafruit_pioasm.assemble(program)</span></pre>
<p><span class="koboSpan" id="kobo.435.1">This code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">set</span></strong><span class="koboSpan" id="kobo.437.1"> instruction, which can put any value less than 32 (5 bits) into a register. </span><span class="koboSpan" id="kobo.437.2">In the example, we store it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.439.1"> register.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">The following line is </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">mov isr, y</span></strong><span class="koboSpan" id="kobo.442.1">, which copies the right (</span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">y</span></strong><span class="koboSpan" id="kobo.444.1">) register data into the ISR. </span><span class="koboSpan" id="kobo.444.2">We must store a value in the </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">ISR</span></strong><span class="koboSpan" id="kobo.446.1"> to use it in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">push</span></strong><span class="koboSpan" id="kobo.448.1"> statement, putting it into a </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">FIFO queue.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">We assemble </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.451.1">this and send it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">state machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
sm = rp2pio.StateMachine(assembled, frequency=2000)</span></pre>
<p><span class="koboSpan" id="kobo.454.1">We can then pull this data from the FIFO queue and examine the content as decimal </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">and binary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
buffer = array.array('I', [0])
sm.readinto(buffer)
print("{0} 0b{0:032b}".format(buffer[0]))</span></pre>
<p><span class="koboSpan" id="kobo.457.1">This code will run and simply pass the number 21 through the system. </span><span class="koboSpan" id="kobo.457.2">Because I know the value is low, I have formatted it with 32 leading 0s. </span><span class="koboSpan" id="kobo.457.3">Therefore, the output should look </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
code.py output:
21 0b00000000000000000000000000010101
Code done running.</span></pre>
<p><span class="koboSpan" id="kobo.460.1">This feature is handy, and we can use this code with different assemblers as a template to test out PIO assembly techniques. </span><span class="koboSpan" id="kobo.460.2">We can start by looking at manipulating bits </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">in registers.</span></span></p>
<h3><span class="koboSpan" id="kobo.462.1">Bit manipulations</span></h3>
<p><span class="koboSpan" id="kobo.463.1">When dealing with registers, we may want to manipulate their content. </span><span class="koboSpan" id="kobo.463.2">For example, we may want </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.464.1">to move bits around, shift them, reverse their order, or flip them wholesale. </span><span class="koboSpan" id="kobo.464.2">The following diagram shows </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">these operations:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.466.1"><img alt="Figure 6.6 – PIO bit operations " src="image/Figure_6.06_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.467.1">Figure 6.6 – PIO bit operations</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.468.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.469.1">.6</span></em><span class="koboSpan" id="kobo.470.1"> shows these frequent operations pictorially. </span><span class="koboSpan" id="kobo.470.2">The tables show the state of registers as bits, with the register name on the left. </span><span class="koboSpan" id="kobo.470.3">The diagram shows assembler instructions with their effect on the </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">bits highlighted.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">We have already talked a lot about bit shifting into the ISR. </span><span class="koboSpan" id="kobo.472.2">When we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">in</span></strong><span class="koboSpan" id="kobo.474.1"> instruction, it makes space for the number of bits to shift in, discarding bits at the end. </span><span class="koboSpan" id="kobo.474.2">It then copies the new bits into the space. </span><span class="koboSpan" id="kobo.474.3">Code can alter this shift direction with </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">StateMachine</span></strong><span class="koboSpan" id="kobo.476.1"> parameters, but the operation is essentially the same. </span><span class="koboSpan" id="kobo.476.2">The example for shifting uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">in</span></strong><span class="koboSpan" id="kobo.478.1"> to read the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">C1</span></strong><span class="koboSpan" id="kobo.480.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">C2</span></strong><span class="koboSpan" id="kobo.482.1"> pins from our encoder. </span><span class="koboSpan" id="kobo.482.2">However, as well as pins, the source can be other registers or null to copy in zeros. </span><span class="koboSpan" id="kobo.482.3">This operation does not alter </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">the source.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">We can </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">reverse</span></strong><span class="koboSpan" id="kobo.486.1"> the content of a register using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">::</span></strong><span class="koboSpan" id="kobo.488.1"> operation in </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">mov</span></strong><span class="koboSpan" id="kobo.490.1">; this can be useful to get to bits at the other end. </span><span class="koboSpan" id="kobo.490.2">The following assembler </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">demonstrates this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.492.1">
    set y, 21
    mov isr, :: y
    push noblock</span></pre>
<p><span class="koboSpan" id="kobo.493.1">You can use this example in the same Python code shown in the preceding debug registers example. </span><span class="koboSpan" id="kobo.493.2">Note that we reverse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">y</span></strong><span class="koboSpan" id="kobo.495.1"> register right into the ISR. </span><span class="koboSpan" id="kobo.495.2">As the code gets more </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.496.1">complicated, combining operations like this will be critical, as with only 32 instructions, every instruction counts! </span><span class="koboSpan" id="kobo.496.2">The output of that code looks </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.498.1">
2818572288 0b10101000000000000000000000000000</span></pre>
<p><strong class="bold"><span class="koboSpan" id="kobo.499.1">Inverting</span></strong><span class="koboSpan" id="kobo.500.1"> a register is a bitwise </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">not</span></strong><span class="koboSpan" id="kobo.502.1"> operation. </span><span class="koboSpan" id="kobo.502.2">It replaces every bit with its logical opposite – 1s become 0s and 0s become 1s. </span><span class="koboSpan" id="kobo.502.3">If we represent signed numbers with our 32-bit words, this will make them negative. </span><span class="koboSpan" id="kobo.502.4">Try this assembler code: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
    set y, 21 
    mov isr, ~ y 
    push noblock</span></pre>
<p><span class="koboSpan" id="kobo.504.1">This code is exactly like the preceding example, producing the </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">inverted result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.506.1">
4294967274 0b11111111111111111111111111101010</span></pre>
<p><span class="koboSpan" id="kobo.507.1">We can modify our buffer to see how a value becomes negative too. </span><span class="koboSpan" id="kobo.507.2">Change the array format to a </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">lowercase </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">i</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
buffer = array.array('i', [0])</span></pre>
<p><span class="koboSpan" id="kobo.512.1">When running this, we can see what the output </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">is like:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.514.1">
-22 0b-0000000000000000000000000010110</span></pre>
<p><span class="koboSpan" id="kobo.515.1">The binary makes less sense, but we can see that the decimal number is the negative plus one. </span><span class="koboSpan" id="kobo.515.2">Inverting again gets back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">original number.</span></span></p>
<h3><span class="koboSpan" id="kobo.517.1">Extracting the value of a single bit</span></h3>
<p><span class="koboSpan" id="kobo.518.1">One more </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.519.1">thing to do is to combine operations so that we can extract a specific bit using a couple of bit shifts. </span><span class="koboSpan" id="kobo.519.2">The following diagram shows </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">the operation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.521.1"><img alt="Figure 6.7 – Extracting a bit " src="image/Figure_6.07_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.522.1">Figure 6.7 – Extracting a bit</span></p>
<p><span class="koboSpan" id="kobo.523.1">Let us imagine our value starts in </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">x</span></strong><span class="koboSpan" id="kobo.525.1">; I’ve shaded the bit we want darker than the rest. </span><span class="koboSpan" id="kobo.525.2">The assembly snippet for this is </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.527.1">
  in x, 30
  in null, 31</span></pre>
<p><span class="koboSpan" id="kobo.528.1">The first instruction shifts the bits up to the one we want into the ISR. </span><span class="koboSpan" id="kobo.528.2">The diagram shows that the bit we want is now leftmost in the ISR. </span><span class="koboSpan" id="kobo.528.3">However, as we do not want anything to the right of this bit, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">in</span></strong><span class="koboSpan" id="kobo.530.1"> instruction to shift in 31 zeros from </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">null</span></strong><span class="koboSpan" id="kobo.532.1">. </span><span class="koboSpan" id="kobo.532.2">This shift pushes all the other bits away – so we have only 0s and the bit we want. </span></p>
<p><span class="koboSpan" id="kobo.533.1">We’ll put this to real use with the OSR instead. </span><span class="koboSpan" id="kobo.533.2">Put the following code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">extract_a_bit.py</span></strong><span class="koboSpan" id="kobo.535.1">. </span><span class="koboSpan" id="kobo.535.2">We start with imports and a variable to tweak </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">the behavior:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
import rp2pio
import adafruit_pioasm
import array
bit_to_extract = 30</span></pre>
<p><span class="koboSpan" id="kobo.538.1">Remember that we store the assembler code in a Python string, so we can perform Python string formatting on it with </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">an f-string:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
program = f"""
    pull block
    in osr, {bit_to_extract}
    in null, 31
    push noblock
"""</span></pre>
<p><span class="koboSpan" id="kobo.541.1">Since we cannot use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">set</span></strong><span class="koboSpan" id="kobo.543.1"> instruction with values higher than 5 bits, we start by pulling data to read, which goes into the OSR. </span></p>
<p><span class="koboSpan" id="kobo.544.1">We then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">in</span></strong><span class="koboSpan" id="kobo.546.1"> to shift the bits up to the bit we want to extract, using the f-string to substitute </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.547.1">the variable here. </span><span class="koboSpan" id="kobo.547.2">The bit to extract must be 32 or less. </span><span class="koboSpan" id="kobo.547.3">The result is in the ISR. </span><span class="koboSpan" id="kobo.547.4">We perform a further </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">in</span></strong><span class="koboSpan" id="kobo.549.1"> operation from </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">null</span></strong><span class="koboSpan" id="kobo.551.1">, using 0s to drop all but the bit we wanted. </span><span class="koboSpan" id="kobo.551.2">Since this result is already on the ISR, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">push</span></strong><span class="koboSpan" id="kobo.553.1"> to send it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">FIFO queue.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">The remaining code handles assembling this, sending the data, and printing </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">the result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
assembled = adafruit_pioasm.assemble(program)
sm = rp2pio.StateMachine(assembled, frequency=2000)
sm.write(array.array('I',
  [0b01101000_00000000_00000000_00000000]))
buffer = array.array('I', [0])
sm.readinto(buffer)
print("{0} 0b{0:032b}".format(buffer[0]))</span></pre>
<p><span class="koboSpan" id="kobo.558.1">The result from running this should be </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.560.1">
1 0b00000000000000000000000000000001</span></pre>
<p><span class="koboSpan" id="kobo.561.1">If we want to use this data for conditional logic, we could use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">jmp</span></strong><span class="koboSpan" id="kobo.563.1"> instruction, requiring us to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">mov</span></strong><span class="koboSpan" id="kobo.565.1"> instruction to move the data into </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">x</span></strong><span class="koboSpan" id="kobo.567.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">y</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.569.1">scratch registers.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.570.1">Making a counter with PIO</span></h2>
<p><span class="koboSpan" id="kobo.571.1">Counting requires us to be able to add or subtract from a register. </span><span class="koboSpan" id="kobo.571.2">We’ll start with counting down, as that is easier. </span></p>
<p><span class="koboSpan" id="kobo.572.1">At first glance, the datasheet shows no arithmetic instructions in the PIO instruction set. </span><span class="koboSpan" id="kobo.572.2">So how </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.573.1">do we add or subtract? </span><span class="koboSpan" id="kobo.573.2">Although we have not used it yet, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">jmp</span></strong><span class="koboSpan" id="kobo.575.1"> instruction in PIO assembler usually jumps to a label somewhere else in our assembler instructions. </span><span class="koboSpan" id="kobo.575.2">However, it has a trick – it can subtract from a scratch register. </span><span class="koboSpan" id="kobo.575.3">We can exploit this side effect to perform simple arithmetic for us. </span><span class="koboSpan" id="kobo.575.4">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">pio_debugging_registers.py</span></strong><span class="koboSpan" id="kobo.577.1"> as a template, try switching out the assembler for the </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.579.1">
    set y, 21
    jmp y--, fake
fake:
    mov isr, y
    push noblock</span></pre>
<p><span class="koboSpan" id="kobo.580.1">I put this with the template in </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">pio_counting_down.py</span></strong><span class="koboSpan" id="kobo.582.1">. </span></p>
<p><span class="koboSpan" id="kobo.583.1">Sending it to Pico and running it gives the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.585.1">
20 0b00010100</span></pre>
<p><span class="koboSpan" id="kobo.586.1">Hurrah – we can subtract! </span><span class="koboSpan" id="kobo.586.2">We have used a </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">fake:</span></strong><span class="koboSpan" id="kobo.588.1"> label for the subtraction because we don’t want to jump anywhere, just perform </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">the arithmetic.</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">What about adding? </span><span class="koboSpan" id="kobo.590.2">This is trickier, but if you recall the bit invert, the number flipped from positive to negative. </span><span class="koboSpan" id="kobo.590.3">We can exploit this by subtracting 1 and flipping </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">it again.</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">Use this assembler (</span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">pio_counting_up.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
    set y, 21
    mov y, ~ y
    jmp y--, fake
fake:
    mov isr, ~ y
    push noblock</span></pre>
<p><span class="koboSpan" id="kobo.597.1">We still have our fake label, but we flip the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">y</span></strong><span class="koboSpan" id="kobo.599.1"> value into itself first and then flip it again when putting it into the ISR. </span><span class="koboSpan" id="kobo.599.2">The output of running this is </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.601.1">
22 0b00010110</span></pre>
<p><span class="koboSpan" id="kobo.602.1">You have </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.603.1">seen techniques for working with the PIO, how to read data from pins, extract information from it, and perform arithmetic. </span><span class="koboSpan" id="kobo.603.2">We have building blocks. </span><span class="koboSpan" id="kobo.603.3">The following section will see us use them to decode information from the encoder pins into </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">a counter.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.605.1">Measuring encoder count for movement</span></h1>
<p><span class="koboSpan" id="kobo.606.1">We know </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.607.1">what sequences to expect for our encoder, and we have a working knowledge of PIO assembler. </span><span class="koboSpan" id="kobo.607.2">So, we can bring these together to create the counter. </span><span class="koboSpan" id="kobo.607.3">We’ll start simple though; let’s see how to detect when a system </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">has changed.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.609.1">Making a simple PIO change detection loop</span></h2>
<p><span class="koboSpan" id="kobo.610.1">As we </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.611.1">saw in the read two pins example, when we output the system’s state in a tight loop, it floods off anything </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.612.1">interesting. </span><span class="koboSpan" id="kobo.612.2">We are interested in state changes, a step toward the full decoder. </span><span class="koboSpan" id="kobo.612.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">pio_one_encoder_when_changed.py</span></strong><span class="koboSpan" id="kobo.614.1"> file, we go straight from imports into </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">the assembler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
import board
import rp2pio
import adafruit_pioasm
import array</span></pre>
<p><span class="koboSpan" id="kobo.617.1">We start by clearing </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">y –</span></strong><span class="koboSpan" id="kobo.619.1">; we are going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">y</span></strong><span class="koboSpan" id="kobo.621.1"> to store a pin value </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">for comparison:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
program = """
    set y, 0</span></pre>
<p><span class="koboSpan" id="kobo.624.1">The following code creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">read</span></strong><span class="koboSpan" id="kobo.626.1"> label; we can loop to this point to get new pin readings. </span><span class="koboSpan" id="kobo.626.2">It stores the old </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">y</span></strong><span class="koboSpan" id="kobo.628.1"> in x so that we can get a new value. </span><span class="koboSpan" id="kobo.628.2">Shifting </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">in null, 32</span></strong><span class="koboSpan" id="kobo.630.1"> will fill the ISR with zeros, clearing it. </span><span class="koboSpan" id="kobo.630.2">We can then get two pins in </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">the ISR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
read:
    mov x, y 
    in null, 32 
    in pins, 2</span></pre>
<p><span class="koboSpan" id="kobo.633.1">We want to compare our new value in the ISR with our old value, now in </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">x</span></strong><span class="koboSpan" id="kobo.635.1">. </span><span class="koboSpan" id="kobo.635.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">jmp</span></strong><span class="koboSpan" id="kobo.637.1"> cannot use the ISR for comparisons, so we first copy the ISR </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">.</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.641.1">
    mov y, isr
    jmp x!=y different
    jmp read</span></pre>
<p><span class="koboSpan" id="kobo.642.1">As the </span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.643.1">code shows, we can </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.644.1">now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">jmp x!=y</span></strong><span class="koboSpan" id="kobo.646.1"> to jump somewhere else when the register values are different – to a label named </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">different</span></strong><span class="koboSpan" id="kobo.648.1">. </span><span class="koboSpan" id="kobo.648.2">If we do not find them different, we loop back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">read</span></strong><span class="koboSpan" id="kobo.650.1"> to try a fresh sample from the pins with the </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">unconditional </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">jmp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">Let's see the code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">different</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.656.1"> label:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
different:
    push noblock
    jmp read
"""</span></pre>
<p><span class="koboSpan" id="kobo.658.1">Although we copied the ISR to </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">y</span></strong><span class="koboSpan" id="kobo.660.1">, it is still in the ISR so that we can push this value, the new changed value, out to the Python code and then jump back around to read it again. </span><span class="koboSpan" id="kobo.660.2">So, the total effect is that it will spin reading values and, if they are different, push them to the Python code and then go back to spinning in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.662.1"> loop.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">Let us continue the </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">Python code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
assembled = adafruit_pioasm.assemble(program)
sm = rp2pio.StateMachine(
    assembled,
    frequency=20000,
    first_in_pin=board.GP20,
    in_pin_count=2
)
buffer = array.array('I', [0])
while True:
    sm.readinto(buffer)
    print("{:032b}".format(buffer[0]))</span></pre>
<p><span class="koboSpan" id="kobo.666.1">The last </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.667.1">half assembles our code and creates a state machine with it, using a higher frequency. </span><span class="koboSpan" id="kobo.667.2">It sets the state </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.668.1">machine to use GP20 as the first input pin. </span><span class="koboSpan" id="kobo.668.2">Then, it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">in_pin_count</span></strong><span class="koboSpan" id="kobo.670.1"> to set a range of two input pins, matching one of the encoders. </span><span class="koboSpan" id="kobo.670.2">It then reads data into a buffer and prints it in a loop. </span><span class="koboSpan" id="kobo.670.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">sm.readinto</span></strong><span class="koboSpan" id="kobo.672.1"> method waits until there is data, so the Python code only prints when there is a change. </span><span class="koboSpan" id="kobo.672.2">Try rotating the wheels slowly, and you should see the </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">output change:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.674.1">
00000000000000000000000000000000
01000000000000000000000000000000
11000000000000000000000000000000
10000000000000000000000000000000
00000000000000000000000000000000
01000000000000000000000000000000
11000000000000000000000000000000
10000000000000000000000000000000
00000000000000000000000000000000</span></pre>
<p><span class="koboSpan" id="kobo.675.1">We can see the encoder output, and only when it changes. </span><span class="koboSpan" id="kobo.675.2">We could just count the changes, but our system should count in different directions depending on the wheel movement. </span><span class="koboSpan" id="kobo.675.3">Let's write code to </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">check this.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.677.1">Making a bidirectional counter with PIO</span></h2>
<p><span class="koboSpan" id="kobo.678.1">We can </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.679.1">detect when our sensor is in a new </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.680.1">state and store </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.681.1">that in </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">y</span></strong><span class="koboSpan" id="kobo.683.1">, with an old state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">x</span></strong><span class="koboSpan" id="kobo.685.1"> for comparison. </span><span class="koboSpan" id="kobo.685.2">We also need to store a counter, and since we aren’t using it, the OSR will suffice. </span><span class="koboSpan" id="kobo.685.3">We’ll jump right into the assembler, since the imports </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">don’t change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.687.1">
program = """
    set y, 0            ; clear y
    mov osr, y          ; and clear osr
read:
    mov x, y
    in null, 32
    in pins, 2
    mov y, isr
    jmp x!=y, different
    jmp read</span></pre>
<p><span class="koboSpan" id="kobo.688.1">As you can see, beyond setting up the OSR, this starts the same as the previous example. </span><span class="koboSpan" id="kobo.688.2">However, where things are different, we need to be more innovative. </span><span class="koboSpan" id="kobo.688.3">Comparing the 2 bits with the previous 2 bits is tricky in assembler, and we have a 32-instruction limit. </span><span class="koboSpan" id="kobo.688.4">What we are trying to evaluate is the sequences in the </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.690.1"><img alt="Figure 6.8 – Quadrature encoding sequence " src="image/Figure_6.08_B18001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.691.1">Figure 6.8 – Quadrature encoding sequence</span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.692.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.693.1">.8</span></em><span class="koboSpan" id="kobo.694.1"> shows the sequence for encoder signals. </span><span class="koboSpan" id="kobo.694.2">Each pair of numbers shows the sensor </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.695.1">states. </span><span class="koboSpan" id="kobo.695.2">A jump from </span><strong class="bold"><span class="koboSpan" id="kobo.696.1">00</span></strong><span class="koboSpan" id="kobo.697.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.698.1">10</span></strong><span class="koboSpan" id="kobo.699.1"> suggests </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.700.1">the encoder </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.701.1">is going clockwise, and from </span><strong class="bold"><span class="koboSpan" id="kobo.702.1">00</span></strong><span class="koboSpan" id="kobo.703.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.704.1">01</span></strong><span class="koboSpan" id="kobo.705.1"> is anticlockwise; we can follow the sequence around in </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">either direction.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">We can evaluate an old reading and a new reading with the </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">following conditions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.709.1">If the first bit of the old reading </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">is 0</span></span><ul><li><span class="koboSpan" id="kobo.711.1">And the current second bit </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">is 1</span></span><ul><li><span class="koboSpan" id="kobo.713.1">Then it is </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">going anticlockwise</span></span></li></ul></li><li><span class="koboSpan" id="kobo.715.1">Else, the current second bit </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">is 0</span></span><ul><li><span class="koboSpan" id="kobo.717.1">It is </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">going clockwise</span></span></li></ul></li></ul></li>
<li><span class="koboSpan" id="kobo.719.1">If the first bit of the old reading </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">is 1</span></span><ul><li><span class="koboSpan" id="kobo.721.1">And the current second bit </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">is 1</span></span><ul><li><span class="koboSpan" id="kobo.723.1">It is </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">going clockwise</span></span></li></ul></li><li><span class="koboSpan" id="kobo.725.1">Else, the current second bit </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">is 0</span></span><ul><li><span class="koboSpan" id="kobo.727.1">It is </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">going anticlockwise</span></span></li></ul></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.729.1">This logic can boil down to a few instructions in the assembler. </span><span class="koboSpan" id="kobo.729.2">First, we can isolate the bit we want in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">x</span></strong><span class="koboSpan" id="kobo.731.1"> register (the old reading) and compare that to zero, jumping on </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">the result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.733.1">
different:
    in x, 31
    in null, 31
    mov x, isr
    jmp !x, c1_old_zero</span></pre>
<p><span class="koboSpan" id="kobo.734.1">Note that this uses the preceding bit extraction method; bit 31 would be the first pin (</span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">C1</span></strong><span class="koboSpan" id="kobo.736.1">) read in. </span><span class="koboSpan" id="kobo.736.2">We now have the old </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">C1</span></strong><span class="koboSpan" id="kobo.738.1"> value in </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">x</span></strong><span class="koboSpan" id="kobo.740.1">, padded with 0s. </span><span class="koboSpan" id="kobo.740.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">x</span></strong><span class="koboSpan" id="kobo.742.1"> register is zero, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">jmp !x</span></strong><span class="koboSpan" id="kobo.744.1"> instruction will jump to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">c1_old_zero</span></strong><span class="koboSpan" id="kobo.746.1"> label. </span><span class="koboSpan" id="kobo.746.2">Otherwise, it will </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">fall through.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">For clarity, we will start the fall-through section with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">c1_old_non_zero</span></strong><span class="koboSpan" id="kobo.750.1"> label; this is just a </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">comment, though:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.752.1">
c1_old_not_zero:
	jmp pin, count_up
	jmp count_down</span></pre>
<p><span class="koboSpan" id="kobo.753.1">At </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.754.1">this point, we test </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.755.1">a pin. </span><span class="koboSpan" id="kobo.755.2">We’ll </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.756.1">see later that we can set </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">jmp_pin</span></strong><span class="koboSpan" id="kobo.758.1"> when creating the state machine, and we’ll set it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">C2</span></strong><span class="koboSpan" id="kobo.760.1"> pin for an encoder, so this will have the current second pin in it. </span><span class="koboSpan" id="kobo.760.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">jmp pin, count_up</span></strong><span class="koboSpan" id="kobo.762.1"> instruction will jump to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">count_up</span></strong><span class="koboSpan" id="kobo.764.1"> label if the current state of the pin is 1. </span><span class="koboSpan" id="kobo.764.2">Otherwise, we unconditionally jump </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">count_down</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">The code for when </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">C1</span></strong><span class="koboSpan" id="kobo.770.1"> is zero is </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">the opposite:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.772.1">
c1_old_zero:
	jmp pin, count_down
	; fall through</span></pre>
<p><span class="koboSpan" id="kobo.773.1">However, I am being sneaky – instead of the unconditional jump, the next code section will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">count_up</span></strong><span class="koboSpan" id="kobo.775.1">, so we can skip it and save an instruction. </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">count_up</span></strong><span class="koboSpan" id="kobo.777.1"> is adding 1, as we’ve seen before, with the twist that the original value is on </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">the OSR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.779.1">
count_up:
    mov x, ~ osr 
    jmp x--, fake
fake:
    mov x, ~ x
    jmp send</span></pre>
<p><span class="koboSpan" id="kobo.780.1">We invert the OSR into </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">x</span></strong><span class="koboSpan" id="kobo.782.1">, use jmp to jump to a fake label, subtract 1 from </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">x</span></strong><span class="koboSpan" id="kobo.784.1">, and then invert </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">x</span></strong><span class="koboSpan" id="kobo.786.1"> back. </span><span class="koboSpan" id="kobo.786.2">Finally, this code jumps to send the data, with the new count now in </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">x</span></strong><span class="koboSpan" id="kobo.788.1">. </span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">count_down</span></strong><span class="koboSpan" id="kobo.790.1"> is a </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">little simpler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.792.1">
count_down:
    mov x, osr 
    jmp x--, send</span></pre>
<p><span class="koboSpan" id="kobo.793.1">This code </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.794.1">puts the OSR in </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">x</span></strong><span class="koboSpan" id="kobo.796.1"> and subtracts 1 from it, jumping directly to send. </span><span class="koboSpan" id="kobo.796.2">Regardless of the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">x</span></strong><span class="koboSpan" id="kobo.798.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">send</span></strong><span class="koboSpan" id="kobo.800.1"> part labels the </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.801.1">next </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">instruction anyway.</span></span></p>
<p><span class="koboSpan" id="kobo.803.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">send</span></strong><span class="koboSpan" id="kobo.805.1"> part is </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.806.1">just pushing this all back and storing the new value back in </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">the OSR:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.808.1">
send:
    mov isr, x 
    push noblock 
    mov osr, x 
    jmp read
"""</span></pre>
<p><span class="koboSpan" id="kobo.809.1">The final instruction loops back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">read</span></strong><span class="koboSpan" id="kobo.811.1"> to recheck the sensor. </span><span class="koboSpan" id="kobo.811.2">There is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">wrap</span></strong><span class="koboSpan" id="kobo.813.1"> directive in other PIO dialects that would save an instruction here; however, CircuitPython PIOASM does not implement this at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">of writing.</span></span></p>
<p><span class="koboSpan" id="kobo.815.1">That was a lot of assembler language. </span><span class="koboSpan" id="kobo.815.2">This example is in the chapter repo </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">pio_encoder_counting.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.819.1">We need a little more Python code to assemble the instructions, run it, and get </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">the data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.821.1">
assembled = adafruit_pioasm.assemble(program)
left_enc = rp2pio.StateMachine(
    assembled,
    frequency=0,
    first_in_pin=board.GP20,
    jmp_pin=board.GP21,
    in_pin_count=2
)
right_enc = rp2pio.StateMachine(
    assembled,
    frequency=0,
    first_in_pin=board.GP26,
    jmp_pin=board.GP27,
    in_pin_count=2
)</span></pre>
<p><span class="koboSpan" id="kobo.822.1">Here, we create two state machines from the same code! </span><span class="koboSpan" id="kobo.822.2">We pass C1 to the state machine </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.823.1">as the </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.824.1">first input pin, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">C2</span></strong><span class="koboSpan" id="kobo.826.1"> to </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.827.1">the state machine as </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">jmp_pin</span></strong><span class="koboSpan" id="kobo.829.1">, for each encoder based on </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.830.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.831.1">.4</span></em><span class="koboSpan" id="kobo.832.1">. </span><span class="koboSpan" id="kobo.832.2">We have also set </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">frequency=0</span></strong><span class="koboSpan" id="kobo.834.1">, which tells the state machine to go at </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">full speed.</span></span></p>
<p><span class="koboSpan" id="kobo.836.1">We can still use one buffer to read the two state machines alternately. </span><span class="koboSpan" id="kobo.836.2">However, this buffer needs to be type </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">i</span></strong><span class="koboSpan" id="kobo.838.1"> (lowercase) to use signed numbers and count negatively. </span><span class="koboSpan" id="kobo.838.2">We also will make two variables to hold the left and right </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">wheel states:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.840.1">
buffer = array.array('i', [0])
left_data = 0
right_data = 0</span></pre>
<p><span class="koboSpan" id="kobo.841.1">In our main loop, we can start with the left sensor, check whether there is data waiting in the RX FIFO queue with </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">.in_waiting</span></strong><span class="koboSpan" id="kobo.843.1">, and print both sides if </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">there is:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.845.1">
while True:
    if left_enc.in_waiting:
        left_enc.readinto(buffer)
        left_data = buffer[0]
        print(left_data, right_data)</span></pre>
<p><span class="koboSpan" id="kobo.846.1">Note that </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.847.1">there is no special format now; we are </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.848.1">just printing </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.849.1">the raw number of counts. </span><span class="koboSpan" id="kobo.849.2">The right side is </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">the same:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.851.1">
    if right_enc.in_waiting:
        right_enc.readinto(buffer)
        right_data = buffer[0]
        print(left_data, right_data)</span></pre>
<p><span class="koboSpan" id="kobo.852.1">If you run this, you should be able to turn either wheel and see output </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.854.1">
36   77
36   78
36   79
36   80
36   81
36   82</span></pre>
<p><span class="koboSpan" id="kobo.855.1">We can now count pulses for both wheels. </span><span class="koboSpan" id="kobo.855.2">So, if you make a complete wheel revolution, you should land close to plus or minus 8344 – proving our </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">previous calculation.</span></span></p>
<p><span class="koboSpan" id="kobo.857.1">You will see that one wheel makes the count go backward. </span><span class="koboSpan" id="kobo.857.2">Each motor effectively turns in an opposite direction from the encoder’s perspective. </span><span class="koboSpan" id="kobo.857.3">We will account for this later. </span></p>
<h3><span class="koboSpan" id="kobo.858.1">Troubleshooting</span></h3>
<p><span class="koboSpan" id="kobo.859.1">This example </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.860.1">is a lot of code and could go wrong in </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">various ways:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.862.1">If the code counts up/down randomly and not consistently, you may need to change </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">jmp_pin</span></strong><span class="koboSpan" id="kobo.864.1"> to the other </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">input pin.</span></span></li>
<li><span class="koboSpan" id="kobo.866.1">It could also mean you have missed putting </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">x</span></strong><span class="koboSpan" id="kobo.868.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">isr</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.870.1">before sending.</span></span></li>
<li><span class="koboSpan" id="kobo.871.1">Check against the source code </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">from git.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.873.1">You should now be up and running and </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">getting counts.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.875.1">Making reusable encoder code</span></h2>
<p><span class="koboSpan" id="kobo.876.1">Because we </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.877.1">will reuse this, we will put it into a module </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.878.1">and pick it up in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">robot.py</span></strong><span class="koboSpan" id="kobo.880.1">. </span><span class="koboSpan" id="kobo.880.2">We will then use this to make a </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">demonstration program.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">Let's take what we made previously and put it into a module named </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">pio_encoder.py</span></strong><span class="koboSpan" id="kobo.884.1">. </span><span class="koboSpan" id="kobo.884.2">The following code should all </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">be familiar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.886.1">
import rp2pio
import adafruit_pioasm
import array
program = """
    set y, 0
    mov osr, y
read:
    mov x, y
    in null, 32
    in pins, 2
    mov y, isr
    jmp x!=y, different
    jmp read
different:
    in x, 31
    in null, 31
    mov x, isr
    jmp !x, c1_old_zero
c1_old_not_zero:
    jmp pin, count_up
    jmp count_down
c1_old_zero:
    jmp pin, count_down
    ; fall through
count_up:
    mov x, ~ osr
    jmp x--, fake
fake:
    mov x, ~ x
    jmp send
count_down:
    mov x, osr
    jmp x--, send
send:
    mov isr, x
    push noblock
    mov osr, x
    jmp read
"""
assembled = adafruit_pioasm.assemble(program)</span></pre>
<p><span class="koboSpan" id="kobo.887.1">We need </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.888.1">a way to create the state machines with their </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.889.1">parameters and a wrapper for getting the data. </span><span class="koboSpan" id="kobo.889.2">A Python class is an excellent way to </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.891.1">
class QuadratureEncoder:
  def __init__(self, first_pin, second_pin, reversed=False):
    """Encoder with 2 pins. </span><span class="koboSpan" id="kobo.891.2">Must use sequential pins on the board"""
    self.sm = rp2pio.StateMachine(
        assembled,
        frequency=0,
        first_in_pin=first_pin,
        jmp_pin=second_pin,
        in_pin_count=2
    )
    self.reversed = reversed
    self._buffer = array.array('i', [0])</span></pre>
<p><span class="koboSpan" id="kobo.892.1">We will call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">QuadratureEncoder</span></strong><span class="koboSpan" id="kobo.894.1">, as it should work with those types regardless of the mechanism. </span><span class="koboSpan" id="kobo.894.2">Inside the class is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">__init__</span></strong><span class="koboSpan" id="kobo.896.1"> function, which tells Python how to make an encoder object – it takes two pins as its parameters and uses them to create the state machine. </span><span class="koboSpan" id="kobo.896.2">The object also makes a buffer to store the most recent return value. </span><span class="koboSpan" id="kobo.896.3">Note that the two pins must be in sequence. </span></p>
<p><span class="koboSpan" id="kobo.897.1">There’s also a reversed parameter; this is so we can account for one motor turning the opposite way. </span><span class="koboSpan" id="kobo.897.2">We cannot just swap pins in the code here, as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">in</span></strong><span class="koboSpan" id="kobo.899.1"> instruction requires pins </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">in sequence.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">Next, we need </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.902.1">a method </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.903.1">to read from the encoder or the old value if there’s </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">no change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.905.1">
  def read(self):
    while self.sm.in_waiting:
      self.sm.readinto(self._buffer)
    if self.reversed:
      return -self._buffer[0]
    else:
      return self._buffer[0]</span></pre>
<p><span class="koboSpan" id="kobo.906.1">By checking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">in_waiting</span></strong><span class="koboSpan" id="kobo.908.1"> state, this reading will not block and only update the buffer if there’s a new reading; this is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">while</span></strong><span class="koboSpan" id="kobo.910.1"> loop because we only want the most recent FIFO data. </span><span class="koboSpan" id="kobo.910.2">It returns the element in the buffer, returning the negative version if the motor is reversed. </span></p>
<p><span class="koboSpan" id="kobo.911.1">We can now add these encoders to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">robot.py</span></strong><span class="koboSpan" id="kobo.913.1"> library from the end of </span><a href="B18001_05.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.914.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.915.1">, </span><em class="italic"><span class="koboSpan" id="kobo.916.1">Driving Motors with Raspberry Pi Pico</span></em><span class="koboSpan" id="kobo.917.1">. </span><span class="koboSpan" id="kobo.917.2">Let's add encoders to </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">the imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.919.1">
import board
import pwmio
</span><strong class="bold"><span class="koboSpan" id="kobo.920.1">import pio_encoder</span></strong></pre>
<p><span class="koboSpan" id="kobo.921.1">The new code is highlighted. </span><span class="koboSpan" id="kobo.921.2">We can also set up the two encoders. </span><span class="koboSpan" id="kobo.921.3">Add the bold code after </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">the motors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.923.1">
right_motor = motor_A1, motor_A2
left_motor = motor_B1, motor_B2
</span><strong class="bold"><span class="koboSpan" id="kobo.924.1">right_encoder = pio_encoder.QuadratureEncoder(board.GP20, board.GP21, reversed=True)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.925.1">left_encoder = pio_encoder.QuadratureEncoder(board.GP26, board.GP27)</span></strong></pre>
<p><span class="koboSpan" id="kobo.926.1">When we </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.927.1">use our robot, we can now use </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">robot.left_encoder.read()</span></strong><span class="koboSpan" id="kobo.929.1"> and an equivalent command for the right encoder to get </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.930.1">an encoder reading, which we will now use in </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">a demonstration.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.932.1">Measure counts for a known time</span></h2>
<p><span class="koboSpan" id="kobo.933.1">We will </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.934.1">turn this into a demonstration to see what the count is when driving for a second. </span><span class="koboSpan" id="kobo.934.2">Because we have put work into preparing our </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">robot.py</span></strong><span class="koboSpan" id="kobo.936.1">, this code is simple. </span><span class="koboSpan" id="kobo.936.2">Put the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">measure_fixed_time.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.940.1">
import time 
import robot
robot.set_left(0.8)
robot.set_right(0.8)
time.sleep(1)
robot.stop()
print(robot.left_encoder.read(), robot.right_encoder.read())</span></pre>
<p><span class="koboSpan" id="kobo.941.1">This code loads the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">time</span></strong><span class="koboSpan" id="kobo.943.1"> library and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">robot</span></strong><span class="koboSpan" id="kobo.945.1"> helper. </span><span class="koboSpan" id="kobo.945.2">It drives forward at 0.8 speed for 1 second. </span><span class="koboSpan" id="kobo.945.3">It then stops and prints readings from each encoder. </span><span class="koboSpan" id="kobo.945.4">While this code sleeps, the encoder code is </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">still running.</span></span></p>
<p><span class="koboSpan" id="kobo.947.1">Making the encoders this simple to use means we can integrate them with more complex behaviors later; this is a good strategy for </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">most sensors.</span></span></p>
<p><span class="koboSpan" id="kobo.949.1">To run this code, be sure to send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">pio_encoders.py</span></strong><span class="koboSpan" id="kobo.951.1"> library, the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">robot.py</span></strong><span class="koboSpan" id="kobo.953.1">, and then </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">measure_fixed_time.py</span></strong><span class="koboSpan" id="kobo.955.1">. </span><span class="koboSpan" id="kobo.955.2">Remember to update </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">code.py</span></strong><span class="koboSpan" id="kobo.957.1"> to load it, and you should see </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.959.1">
code.py output:
4443 4522</span></pre>
<p><span class="koboSpan" id="kobo.960.1">You have </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.961.1">begun to take sensor readings from your robot, learning PIO on </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">the way!</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.963.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.964.1">In this chapter, you have learned about measuring distance traveled using encoders, including the different types of encoders. </span></p>
<p><span class="koboSpan" id="kobo.965.1">You saw the output that quadrature encoders create and how to interpret this as a </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">turning direction.</span></span></p>
<p><span class="koboSpan" id="kobo.967.1">You were introduced to the powerful PIO state machines present within Pico and saw how you can give tasks such as handling encoders </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">to them.</span></span></p>
<p><span class="koboSpan" id="kobo.969.1">You brought this together to create a reusable handler for the encoders, and we had a demonstration to see </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">them working.</span></span></p>
<p><span class="koboSpan" id="kobo.971.1">In the next chapter, we will plan and buy more devices for our robot, leading to more sensing, and remotely </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">drive it.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.973.1">Exercises</span></h1>
<p><span class="koboSpan" id="kobo.974.1">These exercises can improve your robot and let you practice </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">your skills:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.976.1">You have been able to get readings and a count for each wheel when driving for a fixed time. </span><span class="koboSpan" id="kobo.976.2">How could you make code that stops the motors after a fixed number of counts? </span><span class="koboSpan" id="kobo.976.3">You may need to check the encoder readings in a </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">loop regularly.</span></span></li>
<li><span class="koboSpan" id="kobo.978.1">You may have noticed imbalances in the counts – this is normal and due to motor and wheel differences. </span><span class="koboSpan" id="kobo.978.2">One way you could improve this would be to design and make a holder for the breadboard with the styrene rod so that it doesn’t slide around on </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">the platform.</span></span></li>
<li><span class="koboSpan" id="kobo.980.1">Could you write code to slow a motor if it’s overtaken another one in </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">its count?</span></span></li>
</ul>
<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.982.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.983.1">These further reading items will help you continue </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">your studies:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.985.1">Raspberry Pi has the definitive reference in </span><a href="B18001_03.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.986.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.987.1"> of their datasheet on using PIO and its architecture: </span><a href="https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf"><span class="koboSpan" id="kobo.988.1">https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf</span></a><span class="koboSpan" id="kobo.989.1">. </span><span class="koboSpan" id="kobo.989.2">They also have PIO code examples in </span><a href="B18001_03.xhtml#_idTextAnchor055"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.990.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.991.1"> of their C SDK document (including MicroPython but not CircuitPython </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">samples): </span></span><a href="https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf"><span class="No-Break"><span class="koboSpan" id="kobo.993.1">https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.994.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.995.1">Adafruit documentation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">rp2pio</span></strong><span class="koboSpan" id="kobo.997.1"> is at </span><a href="https://circuitpython.readthedocs.io/en/latest/shared-bindings/rp2pio/"><span class="koboSpan" id="kobo.998.1">https://circuitpython.readthedocs.io/en/latest/shared-bindings/rp2pio/</span></a><span class="koboSpan" id="kobo.999.1"> and is worth consulting for its use, along with their </span><em class="italic"><span class="koboSpan" id="kobo.1000.1">Introduction to CircuitPython RP2040 PIO</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.1001.1">at </span></span><a href="https://learn.adafruit.com/intro-to-rp2040-pio-with-circuitpython"><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">https://learn.adafruit.com/intro-to-rp2040-pio-with-circuitpython</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1004.1">A video by YouTuber StackSmasher has a great deep dive into PIO, its architecture, and programming </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">at </span></span><a href="https://youtu.be/yYnQYF_Xa8g"><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">https://youtu.be/yYnQYF_Xa8g</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">.</span></span></li>
</ul>
</div>
</body></html>