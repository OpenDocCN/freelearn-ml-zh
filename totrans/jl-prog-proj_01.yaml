- en: Getting Started with Julia Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Julia 编程
- en: Julia is a high-level, high-performance dynamic programming language, focusing
    on numerical computing and general programming. It is relatively new—the four
    creators, Jeff Bezanson, Stefan Karpinski, Viral Shah, and Alan Edelman, set out
    to create it in 2009, with the first public reference to the language in 2012,
    when they published a blog post explaining their vision and their goals. 2012
    is considered the official birth year of Julia, making it only six years old.
    Since its initial public release, Julia has received code contributions from hundreds
    of scientists, programmers, and engineers across the world. It is developed in
    the open, with the source code available on GitHub, and is one of the most popular
    repositories with almost 20,000 stars (at the time of writing, and counting).
    Julia v1.0, the much anticipated first stable release, came in August 2018 during
    the Julia conference in London, as the brilliant outcome of the collaboration
    between over 700 open source contributors and thousands of package creators and
    early users. By that time, the language had been downloaded over two million times
    already!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 是一种高级、高性能的动态编程语言，专注于数值计算和通用编程。它相对较新——四位创建者，Jeff Bezanson、Stefan Karpinski、Viral
    Shah 和 Alan Edelman，于 2009 年着手创建它，2012 年首次公开提及该语言，当时他们发布了一篇博客文章，解释了他们的愿景和目标。2012
    年被认为是 Julia 的官方诞生年份，使其仅有六岁。自其首次公开发布以来，Julia 已经收到了来自世界各地数百名科学家、程序员和工程师的代码贡献。它是开源的，源代码可在
    GitHub 上找到，并且是拥有近 20,000 个星标（截至写作时，仍在计数）的最受欢迎的仓库之一。备受期待的第一个稳定版本 Julia v1.0 在 2018
    年 8 月的伦敦 Julia 大会上发布，这是超过 700 名开源贡献者和数千名包创建者及早期用户的卓越合作的成果。到那时，该语言已经被下载超过两百万次了！
- en: Julia came out as a fresh alternative to traditional scientific computing languages,
    which were either productive *or* fast, but not both. This is known as the **two
    language problem**, where the initial prototyping code is written in a dynamic,
    highly productive language (such as R or Python), which allows exploratory coding
    and quick iterations, skipping taxing build and compile times. But later on, the
    developers would be forced to rewrite their programs (or at least the performance
    critical parts of their programs), using a compiled language that would satisfy
    the high-performance requirements of scientific computing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 作为一种全新的替代品出现，用于传统的科学计算语言，这些语言要么是高效的，要么是快速的，但两者都不是。这被称为**两种语言问题**，其中初始原型代码是用动态、高效的语言（如
    R 或 Python）编写的，这允许探索性编码和快速迭代，跳过了耗时的构建和编译时间。但后来，开发者被迫重写他们的程序（或者至少是程序中性能关键的部分），使用编译语言来满足科学计算的高性能要求。
- en: 'The creators of Julia thought that software development technology has evolved
    enough that it can support a language that combines both high productivity and
    high performance. This was their manifesto, underlying their goals for Julia:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的创建者认为，软件开发技术已经发展到足以支持一种结合高生产力和高性能的语言。这是他们的宣言，也是他们为 Julia 设定的目标：
- en: '"We want a language that''s open source, with a liberal license. We want the
    speed of C with the dynamism of Ruby. We want a language that''s homoiconic, with
    true macros like Lisp, but with obvious, familiar mathematical notation like MATLAB.
    We want something as usable for general programming as Python, as easy for statistics
    as R, as natural for string processing as Perl, as powerful for linear algebra
    as MATLAB, as good at gluing programs together as the shell. Something that is
    dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive
    and we want it compiled."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们希望有一种开源的语言，拥有宽松的许可证。我们希望拥有 C 的速度和 Ruby 的动态性。我们希望有一种同构语言，拥有像 Lisp 一样的真正宏，但又有像
    MATLAB 一样明显、熟悉的数学符号。我们希望它对通用编程的可用性像 Python 一样，对统计学的易用性像 R 一样，对字符串处理的自然性像 Perl
    一样，对线性代数的强大性像 MATLAB 一样，在粘合程序方面像 shell 一样出色。一种学习起来非常简单，但又能让最严肃的黑客满意的简单语言。我们希望它是交互式的，我们希望它是编译的。"'
- en: '"(Did we mention it should be as fast as C?)"'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '"(我们提到它应该和 C 一样快吗？)"'
- en: As incredible as it may seem, Julia has managed to satisfy all these demands,
    making for a unique language that is easy to learn, intuitive, friendly, productive,
    and fast. Let's take a closer look at all these features.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来可能难以置信，Julia 已经成功满足了所有这些要求，创造了一种易于学习、直观、友好、高效且快速的独特语言。让我们更深入地了解一下所有这些特性。
- en: 'The topics we will cover in this chapter are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: A quick look at Julia—what is it, the main features and strengths, and why it
    could be the best choice for your next project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速了解Julia——它是什么，主要功能和优势，以及为什么它可能是您下一个项目的最佳选择
- en: How to set up and interact with the Julia language on your local machine
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置和与本地机器上的Julia语言交互
- en: The best IDEs and editors for productive Julia development
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好的IDE和编辑器用于高效的Julia开发
- en: Getting starting with Julia by learning about its powerful REPL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过了解其强大的REPL开始使用Julia
- en: How to use the built-in package manager, `Pkg`, to extend the language with
    third-party libraries
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用内置的包管理器`Pkg`通过第三方库扩展语言
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的包生态系统正在持续发展中，并且每天都有新的包版本发布。大多数时候，这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍在测试版（版本0.x）中，任何新版本都可能引入破坏性更改。因此，书中展示的代码可能会停止工作。为了确保您的代码会产生与书中描述相同的结果，建议使用相同的包版本。以下是本章使用的外部包及其特定版本：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，您需要运行：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过下载章节中提供的`Project.toml`文件，并使用`pkg>`实例化来安装所有使用的包：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Why Julia?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Julia？
- en: In a nutshell, Julia truly is a new breed of programming language that successfully
    manages to combine the high performance of compiled languages with the agility
    of the dynamic ones, through a friendly syntax that feels natural and intuitive
    right from the start. Julia is *fast* (programs are compiled at runtime to efficient
    native code for multiple platforms), *general* (the standard library supports,
    out of the box, powerful programming tasks including asynchronous I/O, process
    control, parallel, and distributed computing, logging, profiling, package management,
    and more), *dynamic and optionally typed* (it is dynamically-typed with optional
    type declarations and comes with a powerful **read-eval-print loop** (**REPL**)
    for interactive and exploratory coding). It is also *technical* (excelling at
    numerical computing) and *composable* (thanks to its rich ecosystem of packages
    that are designed to work together seamlessly and with high performance).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Julia确实是一种新型的编程语言，它成功地结合了编译语言的高性能和动态语言的高灵活性，通过一种友好且直观的语法，从开始就让人感觉自然。Julia是*快速*的（程序在运行时编译成针对多个平台的高效原生代码），*通用*的（标准库支持开箱即用的强大编程任务，包括异步I/O、进程控制、并行和分布式计算、日志记录、性能分析、包管理等等），*动态和可选类型*的（它是动态类型的，具有可选的类型声明，并附带一个强大的**读取-评估-打印循环**（REPL）用于交互式和探索性编码）。它也是*技术*的（擅长数值计算）和*可组合*的（得益于其丰富的生态系统，这些包被设计成无缝且高性能地协同工作）。
- en: Although initially it focused on addressing the needs of high-performance numerical
    analysis and computational science, recent releases have positioned the language
    in the area of general computing, with many classes of specialized functions being
    moved out of the core into dedicated modules. As such, it is also a great fit
    for client and server-side programming, due to its powerful capabilities for concurrent,
    parallel, and distributed computing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最初它专注于解决高性能数值分析和计算科学的需求，但最近的版本已经将语言定位在通用计算领域，许多专门的函数被从核心移动到专用模块中。因此，它也非常适合客户端和服务器端编程，这得益于其在并发、并行和分布式计算方面的强大能力。
- en: Julia implements a type system based on parametric polymorphism and multiple
    dispatch, it is garbage-collected, uses eager evaluation, packs a powerful regular
    expression engine, and can call C and Fortran functions without glue code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Julia实现了一种基于参数多态和多重调用的类型系统，它采用垃圾回收机制，使用即时求值，内置强大的正则表达式引擎，并且可以调用C和Fortran函数而无需粘合代码。
- en: Let's take a look at the most important features of the language, the parts
    that make Julia stand out. If you're considering Julia for your next project,
    you can use this as a quick checklist against your requirements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看语言最重要的特性，那些使 Julia 突出的部分。如果您正在考虑将 Julia 用于您的下一个项目，您可以使用这个快速清单来对照您的需求。
- en: Good performance
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好的性能
- en: The key to Julia's performance is the combination between the LLVM-based **just-in-time**
    (**JIT**) compiler and a series of strategic design decisions that allow the compiler
    to generate code that approaches, and most of the times matches, the performance
    of C.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 性能的关键在于基于 LLVM 的即时编译器（**JIT**）和一系列战略性的设计决策，这些决策允许编译器生成接近甚至大多数情况下匹配 C 语言性能的代码。
- en: 'To give you an idea of where Julia stands in this regard, the official website
    provides a series of micro-benchmarks against other mainstream languages (including
    C, Python, R, Java, JavaScript, Fortran, Go, Rust, MATLAB, and Octave) implementing
    some algorithms for computing the Fibonacci sequence, the Mandelbrot set, a `quicksort`
    and a few others. They are designed to evaluate compiler performance against common
    code patterns such as function calls, string parsing, sorting, iterations, recursion,
    and more. There is a plot of the benchmarks, available at [https://julialang.org/benchmarks/](https://julialang.org/benchmarks/),
    which illustrates Julia''s consistent top performance across all of the tests.
    The following plot depicts this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解 Julia 在这个方面的位置，官方网站提供了一系列针对其他主流语言的微基准测试（包括 C、Python、R、Java、JavaScript、Fortran、Go、Rust、MATLAB
    和 Octave），这些语言实现了计算斐波那契数列、Mandelbrot 集合、快速排序以及其他一些算法。它们旨在评估编译器对常见代码模式（如函数调用、字符串解析、排序、迭代、递归等）的性能。基准测试的图表可在[https://julialang.org/benchmarks/](https://julialang.org/benchmarks/)找到，该图表展示了
    Julia 在所有测试中的一致性顶级性能。以下图表展示了这一点：
- en: '![](img/dceb5fac-7edb-49e8-8c46-8e7a47379953.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dceb5fac-7edb-49e8-8c46-8e7a47379953.png)'
- en: For more details about the testing methodology, you can visit [https://julialang.org/benchmarks/](https://julialang.org/benchmarks/).
    [](https://julialang.org/benchmarks/)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于测试方法的信息，您可以访问[https://julialang.org/benchmarks/](https://julialang.org/benchmarks/)。
    [](https://julialang.org/benchmarks/)
- en: Concise, readable, and intuitive syntax
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁、易读且直观的语法
- en: The creators of Julia have carefully picked the most successful elements of
    syntax from other languages, with the goal of producing expressive, concise, and
    readable code. Julia provides powerful and expressive language constructs for
    high-level numerical computing, in the same way as languages such as R, MATLAB,
    and Python do. It builds upon the experience brought by existing mathematical
    programming languages but also borrows much from popular dynamic ones, such as
    Lisp, Perl, Python, Lua, and Ruby.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的创造者从其他语言中精心挑选了最成功的语法元素，目的是生成表达性强、简洁且易于阅读的代码。与 R、MATLAB 和 Python 等语言一样，Julia
    提供了强大的表达式性语言结构，用于高级数值计算。它建立在现有数学编程语言的经验之上，同时也借鉴了流行的动态语言，如 Lisp、Perl、Python、Lua
    和 Ruby。
- en: 'To give you a quick taste of idiomatic Julia, here''s how to open a file, read
    it, output it, and then have the file automatically closed by Julia:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您快速了解 Julia 的惯用法，以下是如何打开一个文件、读取它、输出它，然后由 Julia 自动关闭文件的示例：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This so-called `do` syntax (named after the `do` part following the `open` function)
    is inspired by Ruby's blocks—and it is, in fact, syntactic sugar for passing anonymous
    functions as method arguments. It is efficiently used in the preceding example
    to succinctly express a powerful design pattern for safely handling files, guaranteeing
    that the resources are not accidentally left open.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种所谓的 `do` 语法（以 `open` 函数后的 `do` 部分为名）受到了 Ruby 的 blocks 的启发——实际上，它是将匿名函数作为方法参数传递的语法糖。在先前的例子中，它被有效地使用，以简洁地表达一个强大的设计模式，用于安全地处理文件，确保资源不会意外地被留下打开。
- en: This goes to show the amount of attention that was put by the designers of the
    language to make Julia safe, beginner-friendly, expressive, concise, readable,
    and intuitive.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了语言设计者对 Julia 的安全性、易用性、表达性、简洁性、易读性和直观性的关注程度。
- en: Powerful and productive dynamic type system
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大且高效的动态类型系统
- en: Julia's type system is a key feature of the language and one that has a major
    impact on both its performance and productivity. The type system is dynamic and
    optional, meaning that the developer can, but is not required to, provide type
    information to the compiler. If not provided, Julia will perform type inference,
    which is the process of deducing the types of later values from the types of input
    values. This is a very powerful technique, as it frees the programmers from having
    to worry about types, allowing them to focus on the application logic and making
    for a gentler learning curve. This is especially useful for prototyping and exploratory
    programming, when the complete set of constraints and requirements is not known
    beforehand.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的类型系统是语言的关键特性，它对性能和生产力都有重大影响。类型系统是动态和可选的，这意味着开发者可以选择但不必须向编译器提供类型信息。如果没有提供，Julia
    将执行类型推断，即从输入值的类型推断后续值的类型的过程。这是一种非常强大的技术，因为它使程序员从担心类型中解放出来，使他们能够专注于应用程序逻辑，并使学习曲线更加平缓。这对于原型设计和探索性编程特别有用，当事先不知道完整的约束和要求时。
- en: However, understanding and correctly using the type system offers important
    performance benefits. Julia allows optionally adding type information, making
    it possible to indicate that a certain value must be of a specific kind. This
    is one of the cornerstones of the language, allowing performant method dispatching
    and facilitating the automatic generation of efficient, specialized code for different
    argument types. The type system allows the definition of rich type hierarchies,
    with user-defined types as fast and compact as the built-in ones.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，理解和正确使用类型系统提供了重要的性能优势。Julia 允许可选地添加类型信息，这使得可以指明某个值必须是特定类型。这是语言的一个基石，允许高效的函数分发，并促进为不同参数类型自动生成高效、专门的代码。类型系统允许定义丰富的类型层次结构，用户定义的类型与内置类型一样快速且紧凑。
- en: Designed for parallelism and distributed computation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计用于并行性和分布式计算
- en: If the languages of the 70s and 80s were designed under the strict requirements
    imposed by the limited CPU and RAM resources, the ones in the 90s and the 2000s
    had the optimistic outlook that these resources are forever expanding. However,
    the last decade had seen something of a stagnation in this regard, with a shift
    toward multi-CPU, multi-core, and distributed computing. In this regard, Julia's
    inception only 6 years ago gave it an edge compared to older languages, putting
    parallel and distributed computing at its center as one of its most important
    features.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 70 年代和 80 年代的语言是在有限的 CPU 和 RAM 资源严格要求的约束下设计的，那么 90 年代和 2000 年代的语言则持有乐观的预期，认为这些资源将永远扩展。然而，在过去的十年中，在这方面出现了一些停滞，转向了多
    CPU、多核和分布式计算。在这方面，Julia 仅 6 年前才出现，与较老的语言相比，它具有优势，将并行和分布式计算作为其最重要的特性之一。
- en: Efficient intercommunication with other languages
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他语言的高效互操作
- en: One of the most serious barriers in the adoption of a new language is that it
    takes time for the ecosystem to catch up—and in the beginning, it cannot offer
    libraries of the quality and richness of the already established languages. This
    is less of an issue now, when Julia benefits from a large, enthusiastic and continuously
    growing developer community. But being able to seamlessly communicate with other
    languages is a very efficient way to enrich existing functionality and to effortlessly
    supplement any missing features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用新语言时，最严重的障碍之一是生态系统需要时间才能赶上——在最初，它无法提供与已经建立的语言质量相当和丰富的库。现在这个问题已经不那么严重了，因为
    Julia 受益于一个庞大、热情且持续增长的开发者社区。但能够与其他语言无缝通信是一种非常有效的方式来丰富现有功能，并轻松补充任何缺失的功能。
- en: Julia has the ability to directly call C and Fortran functions (that is, without
    glue code)—especially important for scientific computing, where these languages
    have a strong presence and a long history.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 具有直接调用 C 和 Fortran 函数的能力（即，无需粘合代码）——这对于科学计算尤为重要，在这些语言中，它们具有强大的存在感和悠久的历史。
- en: Optional packages extend this capability by adding support for calling functions
    written in other languages, most notably Python, via `PyCall`. And there are others,
    supporting interaction with Java, C++, MATLAB, Rust, and more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可选包通过添加对其他语言编写的函数的调用支持来扩展这一功能，最值得注意的是通过 `PyCall` 调用 Python，还有其他一些，支持与 Java、C++、MATLAB、Rust
    等语言交互。
- en: Powerful REPL and shell-like capabilities
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的 REPL 和类似 shell 的功能
- en: The REPL represents a language shell, an interactive computer programming environment
    at the command line. Julia has an excellent REPL, supporting sophisticated code
    inputting and evaluation. It includes powerful editing features such as searchable
    history, tab-completion, and syntax highlighting, to name just a few.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: REPL代表一个语言外壳，是一个命令行上的交互式计算机编程环境。Julia拥有出色的REPL，支持复杂的代码输入和评估。它包括一些强大的编辑功能，如可搜索的历史记录、自动补全和语法高亮，仅举几例。
- en: It also comes with three special modes—*shell**,* which allows executing commands
    as if at the OS Terminal; *help,* which provides access to documentation without
    leaving the REPL; and pkg, used for installing and managing application dependencies.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含三种特殊模式——*shell*，允许像在操作系统终端一样执行命令；*help*，提供在不离开REPL的情况下访问文档的功能；以及pkg，用于安装和管理应用程序依赖项。
- en: And more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Julia comes with its own powerful package manager that resolves dependencies
    and handles the adding and removal of extra packages. Like most modern languages,
    Julia has full support for Unicode. And finally, it is distributed under the liberal
    MIT license—it is free and open source.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Julia自带强大的包管理器，可以解决依赖关系，并处理额外包的添加和删除。像大多数现代语言一样，Julia完全支持Unicode。最后，它遵循宽松的MIT许可协议——它是免费和开源的。
- en: Installing Julia
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Julia
- en: If the previous section convinced you to use Julia for your next project, or
    at least made you curious to learn more, then it's time to set up your Julia development
    environment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的部分让您决定为您的下一个项目使用Julia，或者至少让您对了解更多感到好奇，那么是时候设置您的Julia开发环境了。
- en: Julia has superb cross-platform support, running on all major operating systems.
    The install process is straightforward—the language can be set up on your local
    machine, in a **virtual machine** (**VM**), in a Docker container, or on a server
    somewhere in the cloud.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Julia拥有出色的跨平台支持，可以在所有主要操作系统上运行。安装过程很简单——该语言可以在您的本地机器、虚拟机（VM）、Docker容器或云中的某个服务器上设置。
- en: Let's start by looking at local installation options for the *big three* operating
    systems (Windows, Linux, and macOS). Feel free to skip directly to the right one
    for you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看本地安装选项，针对三大操作系统（Windows、Linux和macOS）。您可以自由地直接跳转到适合您的选项。
- en: Windows
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: Windows has come a long way as a development platform and there are a few good
    alternatives for getting Julia up and running.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Windows作为一个开发平台已经取得了长足的进步，并且有一些很好的替代方案可以让Julia运行起来。
- en: Official Windows installer
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 官方Windows安装程序
- en: 'The simplest option is to download the Windows installer corresponding to your
    platform (32 or 64-bit), from [https://julialang.org/downloads/](https://julialang.org/downloads/).
    Get the `.exe` and run it. Follow the standard installation procedure and in the
    end, you will have Julia installed as a program. Double-clicking `julia.exe` opens
    a command prompt with the Julia REPL, just like the one illustrated here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是下载适用于您平台（32位或64位）的Windows安装程序，从[https://julialang.org/downloads/](https://julialang.org/downloads/)。获取`.exe`文件并运行它。按照标准安装程序进行操作，最后，您将拥有安装为程序的Julia。双击`julia.exe`将打开一个带有Julia
    REPL的命令提示符，就像这里所示：
- en: '![](img/d918e99d-a624-4fbe-932d-6d7d21effaf4.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d918e99d-a624-4fbe-932d-6d7d21effaf4.png)'
- en: Using Chocolatey
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chocolatey
- en: Chocolatey is a package manager for Windows, similar to `apt` or `yum` on Linux,
    or `brew` on Mac. If you don't have it, get it by following the instructions at
    [https://chocolatey.org](https://chocolatey.org).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Chocolatey是Windows的包管理器，类似于Linux上的`apt`或`yum`，或Mac上的`brew`。如果您还没有它，请按照[https://chocolatey.org](https://chocolatey.org)上的说明获取。
- en: 'Chocolatey has the latest version of Julia, as can be confirmed with a search,
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Chocolatey拥有最新的Julia版本，可以通过以下搜索进行确认：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Installing is as simple as this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程就像这样简单：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Windows Subsystem for Linux
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows子系统对于Linux
- en: One of the recent additions to Windows 10 is the Subsystem for Linux. This allows
    setting up a Linux development environment, including most command-line tools,
    utilities, and applications—directly on Windows, unmodified, and without the overhead
    of running a VM.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 10最近新增的功能之一是Linux子系统。这允许在Windows上直接设置Linux开发环境，包括大多数命令行工具、实用程序和应用程序——无需修改，无需运行虚拟机（VM）的开销。
- en: 'In order to be able to use the Linux Subsystem your PC must be running the
    64-bit version of Windows 10 Anniversary Update or later (build 1607+). It also
    needs to be enabled first—so open a PowerShell as an administrator and run the
    following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用 Linux 子系统，你的 PC 必须运行 Windows 10 周年更新或更高版本的 64 位版本（构建 1607+）。它还需要首先启用——因此以管理员身份打开
    PowerShell 并运行以下命令：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the subsystem is enabled (computer restart might be required) you can choose
    one of the Linux versions available, directly from the Windows Store. At the time
    of writing, five versions were available—Ubuntu, openSUSE , SLES, Debian, and
    Kali.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦子系统被启用（可能需要重启计算机），你可以直接从 Windows Store 选择可用的 Linux 版本。在撰写本文时，有五个版本可供选择——Ubuntu、openSUSE、SLES、Debian
    和 Kali。
- en: Ubuntu is the default option for Windows 10 and has the best user ratings in
    the Windows Store, so let's go with that. It can be installed from [https://www.microsoft.com/en-us/store/p/ubuntu/9nblggh4msv6](https://www.microsoft.com/en-us/store/p/ubuntu/9nblggh4msv6).
    Alternatively, you can just open a command prompt and type `$ bash`. This will
    trigger the installation of the Ubuntu Linux Subsystem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 是 Windows 10 的默认选项，在 Windows Store 中拥有最好的用户评分，所以让我们选择它。它可以从 [https://www.microsoft.com/en-us/store/p/ubuntu/9nblggh4msv6](https://www.microsoft.com/en-us/store/p/ubuntu/9nblggh4msv6)
    安装。或者，你只需打开一个命令提示符并输入 `$ bash`。这将触发 Ubuntu Linux 子系统的安装。
- en: 'Once you find yourself at the shell prompt of your Linux subsystem, you can
    proceed and issue the commands for installing Julia. For Ubuntu you need to run
    the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你发现自己处于 Linux 子系统的 shell 提示符，你就可以继续并输入安装 Julia 的命令。对于 Ubuntu，你需要运行以下命令：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure to confirm the required selections—then after a couple of minutes
    you should have Julia up and running.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 确保确认所需的选择——然后几分钟后，你应该就可以运行 Julia 了。
- en: macOS
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: Installing Julia on macOS is straightforward. There are two main options, depending
    on whether you prefer a visual installer or are more at home in front of the Terminal
    prompt.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 Julia 非常简单。主要有两种选择，取决于你是否更喜欢图形安装程序还是更习惯于在终端提示符前操作。
- en: Official image
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 官方镜像
- en: 'Visit [https://julialang.org/downloads/](https://julialang.org/downloads/)
    and look for the macOS package (`.dmg`). Once it''s downloaded, double-click the
    `.dmg` file and drag and drop the Julia app into the `/Applications` folder. Now
    you can simply open the Julia app—which in turn will launch a new Terminal session,
    loading the Julia environment, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://julialang.org/downloads/](https://julialang.org/downloads/) 并查找
    macOS 软件包（`.dmg`）。下载完成后，双击 `.dmg` 文件，将 Julia 应用程序拖放到 `/Applications` 文件夹。现在你可以简单地打开
    Julia 应用程序——它将启动一个新的终端会话，加载 Julia 环境，如下所示：
- en: '![](img/c530fc94-ba36-4b8d-b496-ab68eb42e966.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c530fc94-ba36-4b8d-b496-ab68eb42e966.png)'
- en: Homebrew
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Homebrew
- en: '`Homebrew` is a well-known package manager for macOS in the line of `apt` and
    `yum` on Linux. It''s not really necessary for installing Julia, but it''s worth
    setting it up as it can be very useful during development since it can seamlessly
    install database servers, libraries, and other components for your projects.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Homebrew` 是 macOS 上一个知名的包管理器，类似于 Linux 上的 `apt` 和 `yum`。虽然安装 Julia 并非必需，但值得设置它，因为它在开发过程中非常有用，因为它可以无缝地安装数据库服务器、库和其他项目组件。'
- en: 'As per the instructions at [https://brew.sh](https://brew.sh), it can be installed
    by running the following command in a Terminal window:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在 [https://brew.sh](https://brew.sh) 的说明，可以在终端窗口中运行以下命令来安装：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It might take a while but once `Homebrew` is installed, a new command-line utility,
    `brew`, will become available.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要一段时间，但一旦 `Homebrew` 安装完成，一个新的命令行工具 `brew` 将会可用。
- en: Finally, `$ brew cask install julia` will download and install the latest version
    of Julia. In the process, it will also link the `julia` binary to `/usr/local/bin/julia`
    so you can interact with the language from the command line by simply typing `$
    julia`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `$ brew cask install julia` 将下载并安装 Julia 的最新版本。在这个过程中，它还会将 `julia` 二进制文件链接到
    `/usr/local/bin/julia`，这样你就可以通过简单地输入 `$ julia` 来从命令行与语言交互。
- en: 'As soon as you get the confirmation that the installation was successful you
    can run `$ julia` to start a new REPL session:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你收到安装成功的确认，你可以运行 `$ julia` 来启动一个新的 REPL 会话：
- en: '![](img/c22c2c3d-210b-40e7-a2c0-4e589803e081.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c22c2c3d-210b-40e7-a2c0-4e589803e081.png)'
- en: Linux and FreeBSD
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 和 FreeBSD
- en: Julia is already available in the software repositories of the major Linux distributions,
    but unfortunately, these are not up to date. For example, at the time of writing,
    Ubuntu was providing v0.4.5 and Debian v0.4.7\. The best approach is to use the
    generic Linux binaries provided on Julia's download page, at [https://julialang.org/downloads/](https://julialang.org/downloads/).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Julia已经可用在主要Linux发行版的软件仓库中，但遗憾的是，这些并不都是最新的。例如，在撰写本文时，Ubuntu提供的是v0.4.5，Debian是v0.4.7。最佳方法是使用Julia下载页上提供的通用Linux二进制文件，在[https://julialang.org/downloads/](https://julialang.org/downloads/)。
- en: Please follow the instructions corresponding to your Linux distribution, as
    indicated at [https://julialang.org/downloads/platform.html#generic-binaries](https://julialang.org/downloads/platform.html#generic-binaries).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请遵循对应您Linux发行版的说明，如[https://julialang.org/downloads/platform.html#generic-binaries](https://julialang.org/downloads/platform.html#generic-binaries)所示。
- en: Docker
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Docker is a software technology that provides an additional layer of abstraction
    of operating-system-level virtualization. In plain English, Docker sets up *containers* that
    behave like VMs, but without the added overhead of starting and maintaining VMs.
    You can run Docker on all the major operating systems.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一种提供操作系统级别虚拟化抽象额外层的软件技术。简单来说，Docker设置了像VM一样的*容器*，但无需启动和维护VM的开销。您可以在所有主要操作系统上运行Docker。
- en: Docker is widely used as a development and deployment strategy, so many technologies
    are readily available in the form of Docker images, and Julia is no exception.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Docker被广泛用作开发和部署策略，因此许多技术都以Docker镜像的形式 readily 可用，Julia也不例外。
- en: Start by installing Docker for your platform. The official Julia container can
    be found in the Docker store at [https://store.docker.com/images/julia](https://store.docker.com/images/julia).
    Go get it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先为您的平台安装Docker。官方的Julia容器可以在Docker商店的[https://store.docker.com/images/julia](https://store.docker.com/images/julia)找到。去获取它。
- en: If you need help setting up Docker or installing containers, follow the instructions
    at [https://www.docker.com](https://www.docker.com).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要帮助设置Docker或安装容器，请参阅[https://www.docker.com](https://www.docker.com)上的说明。
- en: 'At the command prompt, type `$ docker pull julia`. Once the Julia image is
    configured by Docker, run it with `$ docker exec -it --rm julia`. This will start
    the container and load a new Julia REPL:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符下，输入`$ docker pull julia`。一旦Docker配置了Julia镜像，使用`$ docker exec -it --rm
    julia`运行它。这将启动容器并加载一个新的Julia REPL：
- en: '![](img/b2960334-eb4f-4ad9-9f55-1abb07275e33.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2960334-eb4f-4ad9-9f55-1abb07275e33.png)'
- en: JuliaPro
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JuliaPro
- en: Julia Computing, the company behind the Julia programming language, offers a
    *batteries included* distribution. It's called **JuliaPro** and it's arguably
    the easiest way to get started with Julia straight away. It includes the compiler,
    a profiler, the Juno IDE, and over 160 top quality curated packages for plotting,
    data visualization, machine learning, databases, and more.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Julia编程语言背后的公司Julia Computing提供了一种包含所有组件的发行版。它被称为**JuliaPro**，可以说是立即开始使用Julia的最简单方法。它包括编译器、分析器、Juno
    IDE以及超过160个高质量的精选包，用于绘图、数据可视化、机器学习、数据库等。
- en: JuliaPro can be downloaded for free at [https://shop.juliacomputing.com/Products/](https://shop.juliacomputing.com/Products/)
    (registration required). Once you get it, follow the install process specific
    to your platform. When done you'll have everything needed to begin using Julia
    productively.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://shop.juliacomputing.com/Products/](https://shop.juliacomputing.com/Products/)免费下载JuliaPro（需要注册）。一旦您获得它，请遵循您平台特定的安装过程。完成后，您将拥有开始高效使用Julia所需的一切。
- en: A paid enterprise version is also available, offering a few extra features,
    such as Excel integration and support with SLA.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 付费的企业版也提供了一些额外功能，例如Excel集成和支持SLA。
- en: JuliaBox
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JuliaBox
- en: Finally, there's also JuliaBox ([https://www.juliabox.com](https://www.juliabox.com)),
    another free offering from Julia Computing. JuliaBox allows running a Julia Docker
    container on the fly, in their cloud. It provides access to IJulia Jupyter notebooks
    ([https://github.com/JuliaLang/IJulia.jl](https://github.com/JuliaLang/IJulia.jl)),
    file sync with Google Drive, importing GitHub repositories, and many other features.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有JuliaBox ([https://www.juliabox.com](https://www.juliabox.com))，这是Julia
    Computing提供的另一项免费服务。JuliaBox允许在他们的云中即时运行Julia Docker容器。它提供了对IJulia Jupyter笔记本([https://github.com/JuliaLang/IJulia.jl](https://github.com/JuliaLang/IJulia.jl))的访问、与Google
    Drive的文件同步、导入GitHub仓库以及许多其他功能。
- en: If you are not familiar with Jupyter notebooks, you can learn more about them
    by visiting [http://jupyter.org](http://jupyter.org).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 Jupyter 笔记本，你可以通过访问 [http://jupyter.org](http://jupyter.org) 来了解更多信息。
- en: Choosing an IDE
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 IDE
- en: An IDE is very important when working with a programming language. A powerful
    source code editor, code completion, and a good linter and debugger can significantly
    influence the learning curve and the productivity of using a language. You will
    be happy to learn that there are some very good IDE and editor options for Julia—and
    chances are you'll find your favorite one among these.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用编程语言时，IDE 非常重要。一个强大的源代码编辑器、代码补全、以及良好的代码检查器和调试器可以显著影响学习曲线和使用该语言的效率。你会很高兴地了解到，对于
    Julia 来说，有一些非常好的 IDE 和编辑器选项——你可能会在这些选项中找到你最喜欢的一个。
- en: The IDE choices reflect the pragmatism of the language as a whole. From choosing
    LLVM as the compiler to providing efficient ways for calling functions from other
    languages, to using `git` and GitHub to power the package manager, the Julia core
    team takes a *don't reinvent the wheel* approach. Following the same line of thinking,
    the Julia community has built powerful IDEs upon existing industry established
    editors, such as Atom and Visual Studio Code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 的选择反映了整个语言的实用主义。从选择 LLVM 作为编译器，到提供从其他语言调用函数的高效方式，再到使用 `git` 和 GitHub 来驱动包管理器，Julia
    核心团队采取了“不重复造轮子”的方法。遵循同样的思路，Julia 社区在现有的行业建立编辑器的基础上构建了强大的 IDE，例如 Atom 和 Visual
    Studio Code。
- en: Juno (Atom)
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Juno (Atom)
- en: Juno ([http://junolab.org](http://junolab.org)) is the most advanced Julia IDE
    and the de facto editor of choice for Julia professionals. It is based on the
    Atom editor and it can be considered the official development tool, being also
    distributed with the previously mentioned JuliaPro distribution.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Juno ([http://junolab.org](http://junolab.org)) 是最先进的 Julia 集成开发环境（IDE），也是 Julia
    专业人士首选的默认编辑器。它基于 Atom 编辑器，可以被认为是官方的开发工具，因为它也随之前提到的 JuliaPro 发行版一起分发。
- en: To get it, either download and install JuliaPro from [https://juliacomputing.com/products/juliapro.html](https://juliacomputing.com/products/juliapro.html)
    or[ do a manual install of Atom and the required plugins.](https://juliacomputing.com/products/juliapro.html)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取它，你可以从 [https://juliacomputing.com/products/juliapro.html](https://juliacomputing.com/products/juliapro.html)
    下载并安装 JuliaPro，或者[手动安装 Atom 和所需的插件。](https://juliacomputing.com/products/juliapro.html)
- en: If you choose the manual install, first you need to download Atom from [https://atom.io](https://atom.io).
    Once it's up and running, go to the Settings pane (you can use the shortcut *Ctrl*/*cmd*
    and *,*) and then go to the Install panel. Type `uber-juno` into the search box
    and press *Enter*. Next, click the install button on the package with the same
    name. Atom will pick it up from here, installing all the required Atom and Julia
    packages.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择手动安装，首先需要从 [https://atom.io](https://atom.io) 下载 Atom。一旦启动并运行，转到设置面板（你可以使用快捷键
    *Ctrl*/*cmd* 和 *,*)，然后转到安装面板。在搜索框中输入 `uber-juno` 并按 *Enter*。接下来，点击具有相同名称的包的安装按钮。Atom
    将从这里开始，安装所有必需的 Atom 和 Julia 包。
- en: Once configured, the IDE options will be available in Atom's menu, under Packages
    > Julia. Various panes can also be enabled from here, to list variables, visualize
    plots, or search the documentation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，IDE 选项将在 Atom 的菜单中可用，在 Packages > Julia 下。也可以从这里启用各种面板，以列出变量、可视化图表或搜索文档。
- en: For further information, check out [http://junolab.org](http://junolab.org)
    and [https://github.com/JunoLab/uber-juno/blob/master/setup.md](https://githubcom/JunoLab/uber-juno/blob/master/setup.md).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请查看 [http://junolab.org](http://junolab.org) 和 [https://github.com/JunoLab/uber-juno/blob/master/setup.md](https://github.com/JunoLab/uber-juno/blob/master/setup.md)。
- en: Visual Studio Code
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Visual Studio Code is a cross-platform extendable editor from Microsoft. It
    is available for all the *big three* platforms at [https://code.visualstudio.com](https://code.visualstudio.com).
    Once installed, run it and from the menu click View > Extensions or use the shortcut
    *Shift* and *Ctrl*/*cmd* and *X*. Search for `julia` and install the Julia extension
    from *julialang*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 是微软的一个跨平台可扩展编辑器。它适用于所有三大平台，可在 [https://code.visualstudio.com](https://code.visualstudio.com)
    获取。安装后，运行它并从菜单中选择视图 > 扩展或使用快捷键 *Shift* 和 *Ctrl*/*cmd* 和 *X*。搜索 `julia` 并从 *julialang*
    安装 Julia 扩展。
- en: The Julia support in Visual Studio Code is not (yet) as powerful as Juno, but
    if you prefer it, it makes for a great coding experience, providing syntax highlighting,
    code completion, hover help, evaluation of Julia code, linting, code navigation,
    and more. Visual Studio Code is also snappier and uses fewer resources than Atom,
    which makes it an appealing option when running on a less powerful workstation
    (although Atom has greatly improved in this regard with recent versions).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code中的Julia支持（目前）不如Juno强大，但如果你更喜欢它，它也能提供极佳的编码体验，包括语法高亮、代码补全、悬停帮助、Julia代码评估、代码检查、代码导航等功能。Visual
    Studio Code比Atom更轻快，使用的资源也更少，这使得它在运行在性能较弱的工作站上时成为一个吸引人的选择（尽管Atom在最近版本中在这方面有了很大改进）。
- en: The extension might need a bit of help figuring out where it can find the Julia
    binary. If that is the case, you'll get an informative error message, asking you
    to set the `julia.executablePath` configuration option. This should point to the
    julia binary, and depends on your operating system and the way you installed Julia
    (see the previous section for details on the installation).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展可能需要一点帮助来确定它在哪里可以找到Julia的二进制文件。如果是这种情况，你会收到一个信息丰富的错误消息，要求你设置`julia.executablePath`配置选项。这应该指向julia的二进制文件，并且取决于你的操作系统和安装Julia的方式（有关安装的详细信息，请参阅上一节）。
- en: 'To set the configuration, go to Preferences > Settings (*Ctrl*/*cmd* and *,*)
    and in the right pane, the one used to overwrite the defaults, add the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置配置，请转到“首选项”>“设置”（*Ctrl*/*cmd*和*，*），然后在右侧面板中，用于覆盖默认设置的面板，添加以下内容：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: IJulia (JuliaBox)
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IJulia (JuliaBox)
- en: We already mentioned JuliaBox ([https://www.juliabox.com](https://www.juliabox.com))
    in the previous section—it allows creating, editing, and running IJulia Jupyter
    notebooks in the cloud. IJulia can also be installed on the local development
    machine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中已经提到了JuliaBox ([https://www.juliabox.com](https://www.juliabox.com))——它允许在云中创建、编辑和运行IJulia
    Jupyter笔记本。IJulia也可以安装在本地的开发机器上。
- en: IJulia is a Julia language backend for the Jupyter interactive environment (also
    used by IPython). It allows us to interact with the Julia language using Jupyter/IPython's
    powerful graphical notebook, which combines code, formatted text, math, and multimedia
    in a single document.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: IJulia是Jupyter交互式环境（也被IPython使用）的Julia语言后端。它允许我们通过Jupyter/IPython强大的图形笔记本与Julia语言进行交互，该笔记本将代码、格式化文本、数学和多媒体结合在一个文档中。
- en: Although IJulia/Jupyter is not really an IDE, nor a classical editor, it is
    a powerful environment for editing and executing Julia scripts, and it's especially
    popular for data science and scientific computing. Let's take a few moments to
    set it up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然IJulia/Jupyter并不是真正的IDE，也不是经典的编辑器，但它是一个强大的编辑和执行Julia脚本的编程环境，特别受数据科学和科学计算领域的欢迎。让我们花几分钟时间来设置它。
- en: 'Start a new Julia REPL and execute the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的Julia REPL并执行以下命令：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will install the `IJulia` package, while also adding a required minimal
    Python and Jupyter distribution called **Miniconda**. This Python distribution
    is private to Julia (not in your `PATH`). Once finished, continue by executing
    the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装`IJulia`包，同时还会添加一个名为**Miniconda**的必需的最小Python和Jupyter发行版。这个Python发行版是Julia专有的（不在你的`PATH`中）。完成后，继续执行以下命令：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will open the home page of your local Jupyter install in your default browser,
    at [http://localhost:8888/tree](http://localhost:8888/tree). From the toolbar
    choose `New > Julia 1.0.0` (or whatever version you are currently running) to
    create a new notebook. You can now create rich documents using embedded executable
    Julia code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的默认浏览器中打开本地Jupyter安装的主页，在[http://localhost:8888/tree](http://localhost:8888/tree)。从工具栏中选择`新建
    > Julia 1.0.0`（或你当前运行的版本）来创建一个新的笔记本。你现在可以使用嵌入的可执行Julia代码创建丰富的文档。
- en: There's another way of running IJulia as a desktop app, through `Interact`.
    You can download it and give it a try at [https://nteract.io/desktop](https://nteract.io/desktop).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种运行IJulia作为桌面应用程序的方式，通过`Interact`。你可以下载它并尝试使用[https://nteract.io/desktop](https://nteract.io/desktop)。
- en: If you're new to Jupyter, it's worth learning more about it. Go check it out
    at [http://jupyter.org](http://jupyter.org).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始使用Jupyter，了解它将很有帮助。可以去[http://jupyter.org](http://jupyter.org)查看。
- en: You can also find IJulia notebooks for each chapter in this book in the chapter's
    support file repository. The notebooks will allow you to go through the code we're
    writing, step by step. For instance, you can find the code for this chapter at
    [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb).
    You can download it on your computer and open it with the local IJulia installation,
    or upload it to JuliaBox through their Google Drive integration.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在本书每一章的支持文件仓库中找到每个章节的 IJulia 笔记本。这些笔记本将允许你逐步查看我们编写的代码。例如，你可以在这个章节中找到代码 [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb)。你可以在你的电脑上下载它，并用本地
    IJulia 安装打开，或者通过他们的 Google Drive 集成上传到 JuliaBox。
- en: Other options
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他选项
- en: The preceding choices are the most common IDE and editor options for Julia.
    But there are a few more out there.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述选择是 Julia 最常见的 IDE 和编辑器选项。但还有一些其他的选择。
- en: For the `vim` enthusiasts, there's also `julia-vim` ([https://github.com/JuliaEditorSupport/julia-vim](https://github.com/JuliaEditorSupport/julia-vim)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `vim` 爱好者，也有 `julia-vim` ([https://github.com/JuliaEditorSupport/julia-vim](https://github.com/JuliaEditorSupport/julia-vim))。
- en: If you prefer Emacs, you'll be pleased to know that Julia supports it as well [https://github.com/JuliaEditorSupport/julia-emacs](https://github.com/JuliaEditorSupport/julia-emacs).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用 Emacs，你会很高兴地知道 Julia 也支持它 [https://github.com/JuliaEditorSupport/julia-emacs](https://github.com/JuliaEditorSupport/julia-emacs)。
- en: If you'd rater go with one of the IDEs provided by JetBrains (like IntelliJ
    IDEA), you'll be happy to hear that a plugin is available, at [https://plugins.jetbrains.com/plugin/10413-julia](https://plugins.jetbrains.com/plugin/10413-julia)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意使用 JetBrains 提供的 IDE（如 IntelliJ IDEA），你会很高兴地听说有一个插件可用，在 [https://plugins.jetbrains.com/plugin/10413-julia](https://plugins.jetbrains.com/plugin/10413-julia)。
- en: Finally, there is also support for Sublime Text, available at [https://github.com/JuliaEditorSupport/Julia-sublime](https://github.com/JuliaEditorSupport/Julia-sublime).
    The plugin provides a good Julia editing experience, supporting syntax highlighting,
    code completion, and jumping to definition, among other things.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有对 Sublime Text 的支持，可在 [https://github.com/JuliaEditorSupport/Julia-sublime](https://github.com/JuliaEditorSupport/Julia-sublime)
    找到。该插件提供了良好的 Julia 编辑体验，支持语法高亮、代码补全和跳转到定义等功能。
- en: Getting started with Julia
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Julia
- en: If you followed through the first part of the chapter, by now you should have
    a fully functional local Julia installation, the knowledge to start a Julia REPL
    session, and have your preferred IDE ready for coding. If that is not the case,
    please refer to the previous sections. From this point on we're getting down to
    business—it's time to write some Julia code!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随着本章的第一部分，到现在你应该已经有一个功能齐全的本地 Julia 安装，了解如何启动 Julia REPL 会话，并且你的首选 IDE 已经准备好进行编码。如果不是这样，请参考前面的部分。从现在开始，我们将进入正题——是时候编写一些
    Julia 代码了！
- en: The Julia REPL
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia REPL
- en: The first thing we need to understand is how to use the powerful REPL. As a
    Julia developer, you'll spend a significant amount of time doing exploratory programming,
    interacting with the shell and the filesystem, and managing packages. The REPL
    will be your trusted sidekick. It's worth getting to know it well, it will save
    you a lot of time down the line.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要了解的是如何使用强大的 REPL。作为一名 Julia 开发者，你将花费大量时间进行探索性编程，与壳和文件系统交互，以及管理包。REPL 将是你的忠实伙伴。了解它将节省你很多时间。
- en: The acronym REPL stands for read-eval-print loop. Simply put, it's a language-specific
    shell, an interactive coding environment that allows inputting expressions, evaluates
    them, and outputs the result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写 REPL 代表读取-评估-打印循环。简单来说，它是一种特定语言的壳，一个交互式编码环境，允许输入表达式，评估它们，并输出结果。
- en: REPLs are very useful as they provide a simple way to interact with the language,
    to try out ideas and prototype, facilitating exploratory programming and debugging.
    It is especially powerful in the context of data analysis, where one can quickly
    connect to a data source, load a data sample and then slice and dice, rapidly
    testing different hypothesis.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 非常有用，因为它们提供了一种简单的方式来与语言交互，尝试想法和原型，促进探索性编程和调试。在数据分析的上下文中，它尤其强大，因为可以快速连接到数据源，加载数据样本，然后进行切片和切块，快速测试不同的假设。
- en: Julia provides an excellent REPL experience, with rich functionality that covers
    quick evaluation of Julia statements, searchable history, tab-completion, syntax
    highlighting, dedicated help and shell modes, to name just a few.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了一个出色的REPL体验，具有丰富的功能，涵盖了快速评估Julia语句、可搜索的历史记录、自动补全、语法高亮、专用帮助和shell模式等，仅举几例。
- en: If you do not have a working Julia installation, please see the *Installing
    Julia* section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装有效的Julia，请参阅*安装Julia*部分。
- en: Interacting with the REPL
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与REPL交互
- en: Depending on your OS and your preferences, the REPL can be started by simply
    invoking `$ julia` with no arguments, or by double-clicking the `julia` executable.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统和偏好，REPL可以通过简单地使用无参数的`$ julia`命令启动，或者通过双击`julia`可执行文件。
- en: 'You will be greeted with a screen like this one (the Julia version might be
    different than mine):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个类似这样的屏幕（Julia版本可能与我不同）：
- en: '![](img/3869e0f5-3197-4d08-9005-ab90794bce8e.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3869e0f5-3197-4d08-9005-ab90794bce8e.png)'
- en: Now Julia is waiting for us to input our code, evaluating it line by line. You
    can confirm that by checking the Terminal prompt, which says `julia>`. This is
    called the **julian** **mode**. Let's take it for a spin.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Julia正在等待我们输入代码，逐行评估。您可以通过检查终端提示符来确认，它说`julia>`。这被称为**julian** **模式**。让我们试试看。
- en: You can follow through the IJulia Jupyter notebook provided with this chapter's
    support files. If you are not familiar with Jupyter and don't know how to run
    it locally, you can use Juliabox ([juliabox.com](http://juliabox.com)). All you
    have to do is create an account, log in, and then load the notebook from [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照本章支持文件中提供的IJulia Jupyter笔记本进行操作。如果您不熟悉Jupyter且不知道如何在本地运行它，可以使用Juliabox
    ([juliabox.com](http://juliabox.com))。您只需创建一个账户，登录，然后从[https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter01/Chapter%201.ipynb)加载笔记本。
- en: 'Input the following lines, pressing *Enter* after each one:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下行，每行输入后按*Enter*键：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So we can use Julia like a simple calculator. Not very useful, but this is only
    the beginning and illustrates how powerful this rapid input and feedback cycle
    can be when we deal with complex computations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以像使用简单计算器一样使用Julia。虽然不是很实用，但这只是开始，展示了当我们处理复杂计算时，这种快速输入和反馈循环是多么强大。
- en: '`println` is a very useful function that prints whatever value it receives,
    appending a new line afterward. Type the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`println`是一个非常有用的函数，它会打印接收到的任何值，并在之后添加一个新行。输入以下代码：'
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Under each line, you should see the output generated by each expression. Your
    window should now look like this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行下面，您应该能看到每个表达式生成的输出。现在您的窗口应该看起来像这样。
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s try some more. The REPL interprets one line at a time, but everything
    is evaluated in a common scope. This means that we can define variables and refer
    to them later on, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一些。REPL一次解释一行，但所有内容都在一个共同的范围内评估。这意味着我们可以定义变量并在以后引用它们，如下所示：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This looks great! Let''s use the `greeting` variable with `println`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒！让我们使用`greeting`变量和`println`：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Oops! A little typo there, and the REPL promptly returned an error. It''s not
    `greting`, it''s `greeting`. This also tells us that Julia does not allow using
    variables without properly initializing them. It just looked for the `greting`
    variable, unsuccessfully—and it threw an undefined variable error. Let''s try
    that again, this time more carefully:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！这里有个小错误，REPL迅速返回了一个错误。不是`greting`，而是`greeting`。这也告诉我们，Julia不允许在不正确初始化的情况下使用变量。它只是查找了`greting`变量，但没有成功——并抛出了一个未定义变量的错误。让我们再次尝试，这次更加小心：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'OK, that''s much better! We can see the output: the `Hello` value we stored
    in the `greeting` variable.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！我们可以看到输出：存储在`greeting`变量中的`Hello`值。
- en: The ans variable
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ans`变量'
- en: The REPL provides a few helping features, specific to this interactive environment
    (they won't be available when executing a Julia script). One of these is the `ans`
    variable, automatically set up and updated by Julia.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: REPL提供了一些帮助功能，特定于这个交互式环境（在执行Julia脚本时不可用）。其中之一是`ans`变量，由Julia自动设置和更新。
- en: If you type `julia> 2^3`—unsurprisingly, you'll get `8`. Now input `julia> ans`—you'll
    get `8` again! What's up with that? `ans` is a special variable that exists only
    in the REPL and that automatically stores the last returned value. It can prove
    very useful when working with the REPL, but more importantly, you need to be aware
    of its existence so that you don't accidentally declare a variable with the same
    name. Otherwise, you'll run into some very hard to understand bugs with your variable's
    value constantly overwritten.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入 `julia> 2^3`——不出所料，你会得到 `8`。现在输入 `julia> ans`——你又会得到 `8`！这是怎么回事？`ans`
    是一个只在 REPL 中存在的特殊变量，它会自动存储最后一个返回的值。当与 REPL 一起工作时，这可以非常有用，但更重要的是，你需要意识到它的存在，以免不小心声明了一个同名变量。否则，你可能会遇到一些非常难以理解的错误，因为你的变量值会不断被覆盖。
- en: Prompt pasting
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示粘贴
- en: The REPL comes with a very powerful feature called **prompt pasting**. This
    allows us to copy-paste-execute Julia code and snippets that include both the
    `julia>` prompt and the output of the expression. It activates when pasting text
    that starts with `julia>`. In that case, only expressions starting with `julia>`
    are parsed, and all the others are ignored. This makes it possible to paste a
    chunk of code that has been copied from another REPL session or from the documentation,
    without having to scrub away prompts and outputs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 内置了一个非常强大的功能，称为 **提示粘贴**。这允许我们复制粘贴并执行包含 `julia>` 提示和表达式输出的 Julia 代码和代码片段。当粘贴以
    `julia>` 开头的文本时，它会激活。在这种情况下，只有以 `julia>` 开头的表达式会被解析，其他所有内容都会被忽略。这使得能够粘贴从另一个 REPL
    会话或文档中复制出来的代码块，而无需清除提示和输出。
- en: Prompt pasting does not work in IJulia Jupyter notebooks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 提示粘贴在 IJulia Jupyter 笔记本中不起作用。
- en: 'To see this in action, copy and paste the following snippet, as is:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此功能的效果，请复制并粘贴以下代码片段，无需修改：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If all goes well, both expressions should output your current time, and not
    the one from the snippet, effectively replacing the results in the snippet with
    the results in your Julia session.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，两个表达式都应该输出你当前的时间，而不是代码片段中的时间，从而有效地替换代码片段中的结果为 Julia 会话中的结果。
- en: This feature does not work with the default Windows command prompt due to its
    limitations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认 Windows 命令提示符的限制，此功能无法使用。
- en: Tab completion
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tab 完成功能
- en: 'In both the Julian, pkg, and help modes you can press the *Tab* key after entering
    the first few characters of a function to get a list of all the matches:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julian、pkg 和 help 模式下，你可以在输入函数的前几个字符后按 *Tab* 键，以获取所有匹配项的列表：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It can also be used to substitute LaTeX math symbols with their Unicode equivalents.
    To do this, type a backslash as the first character, then the first few characters
    of the symbol, then *Tab*. This will complete the name of the symbol or will display
    a list of options if there''s more than one matching name. Pressing *Tab* again
    on the complete name of the symbol will perform the replacement:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以用来将 LaTeX 数学符号替换为其 Unicode 等效符号。为此，输入一个反斜杠作为第一个字符，然后输入符号的前几个字符，然后按 *Tab*。这将完成符号的名称，或者如果存在多个匹配名称，将显示一个选项列表。再次按
    *Tab* 在符号的完整名称上将会执行替换：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Cleaning the REPL scope
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理 REPL 作用域
- en: Julia does not have the concept of null so you can't really deallocate a variable
    from memory. If, however, you need to free an expensive resource referenced by
    a variable, you can replace its value with something like `0` and the previous
    value will be automatically garbage collected. You can even invoke the garbage
    collector yourself straight away by calling `gc()`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 没有空值的概念，所以你实际上无法从内存中释放变量。然而，如果你需要释放一个由变量引用的昂贵资源，你可以将其值替换为类似 `0` 的东西，之前的值将会自动被垃圾回收。你甚至可以直接通过调用
    `gc()` 来立即调用垃圾回收器。
- en: Additional REPL modes
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加 REPL 模式
- en: The Julia REPL comes with four operational modes—and additional ones can be
    defined as needed. The currently active mode is indicated by its prompt. In the
    previous examples we've used the *julian* mode `julia>`, which evaluates the inputted
    expression. The other three available modes are *help,* `help?>`, *shell,* `shell>`,
    and package management, `pkg>`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Julia REPL 内置了四种操作模式——并且可以根据需要定义附加模式。当前活动模式由其提示表示。在之前的例子中，我们使用了 *julian* 模式
    `julia>`，它评估输入的表达式。其他三个可用模式是 *help*、`help?>`、*shell*、`shell>` 和包管理，`pkg>`。
- en: The active mode can be switched by typing a specific character right at the
    beginning of the line. The prompt will change in response, to indicate the current
    mode. The mode will stay active until the current line is evaluated, automatically
    switching back to julian (with the exception of the `pkg>` mode which is *sticky—*that
    is, it stays active until explicitly exited by typing backspace at the beginning
    of the line). The alternative modes can be exited without evaluating the expression
    by deleting everything on the line until the prompt changes back to `julia>`,
    or by pressing *Ctrl* + *C*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在行首输入特定的字符来切换活动模式。提示符将相应地更改，以指示当前模式。模式将保持活动状态，直到当前行被评估，自动切换回julian（`pkg>`模式除外，它是*粘性的*，即它将保持活动状态，直到通过在行首按退格键显式退出）。可以通过删除整行直到提示符变回`julia>`或按*Ctrl*
    + *C*来退出替代模式，而无需评估表达式。
- en: Accessing the documentation with the help mode
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用帮助模式访问文档
- en: 'The help mode provides access to documentation without having to get out of
    the REPL. To access it, simply type `?` at the beginning of the line. You should
    see the  `help?>` prompt. Now you can input text, and Julia will search the documentation
    for matching entries, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助模式提供访问文档的功能，无需离开REPL。要访问它，只需在行首输入`?`。你应该会看到`help?>`提示符。现在你可以输入文本，Julia将会搜索匹配的文档条目，如下所示：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In IJulia, the additional modes are activated by prefixing the input with the
    desired mode activator. For instance, to access the help for the previous `println`
    function, we need to input `?println.`
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在IJulia中，通过在输入前加上所需的模式激活器来激活额外的模式。例如，要访问之前`println`函数的帮助，我们需要输入`?println.`。
- en: 'The output supports rich formatting, via Markdown:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输出支持丰富的格式化，通过Markdown：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Resulting a rich output as in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如以下截图所示：
- en: '![](img/3e082fe5-e8ed-42d6-9c9c-c8c949384950.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e082fe5-e8ed-42d6-9c9c-c8c949384950.png)'
- en: More complex expressions can be queried, including macros, types, and variables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以查询更复杂的表达式，包括宏、类型和变量。
- en: 'For example, `help?> @time`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`help?> @time`：
- en: '![](img/f12eb3ed-e7c2-4395-a9c9-2b0df1657012.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f12eb3ed-e7c2-4395-a9c9-2b0df1657012.png)'
- en: 'Or `help?> IO`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者`help?> IO`：
- en: '![](img/09a9e60a-d1bd-40b5-9aa5-f265c9e44fa9.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09a9e60a-d1bd-40b5-9aa5-f265c9e44fa9.png)'
- en: Shell mode
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell模式
- en: 'The shell mode is used to switch to a command-line interface similar to the
    system shell, for directly executing OS commands. To enter it, input a semicolon
    `;` at the very beginning of the julian prompt:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用shell模式可以切换到类似于系统shell的命令行界面，以便直接执行操作系统命令。要进入该模式，请在julian提示符的非常开始处输入一个分号`;`：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Upon typing `;` the prompt changes (in place) to `shell>`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`;`后，提示符（就地）变为`shell>`：
- en: To enter shell mode in IJulia and execute a shell command, prefix the command
    with `;`, for example `;ls`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要在IJulia中进入shell模式并执行shell命令，请在命令前加上`;`，例如`;ls`。
- en: 'Now we can execute system-wide commands directly, without the need to wrap
    them in Julia code. This will list the last ten lines of your `repl_history.jl`
    file. This file is used by Julia to keep a history of the commands executed in
    the REPL, so your output will be different from mine:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直接执行系统范围内的命令，无需将它们包裹在Julia代码中。这将列出你的`repl_history.jl`文件的最后十行。此文件由Julia用于记录在REPL中执行的命令的历史，因此你的输出将与我不同：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While in REPL mode we can access Julia''s API, making this a very powerful
    combo. For example, in order to programmatically get the path to the REPL history
    file, we can use the `REPL.find_hist_file()` function, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于REPL模式时，我们可以访问Julia的API，这使得这是一个非常强大的组合。例如，为了以编程方式获取REPL历史文件的路径，我们可以使用`REPL.find_hist_file()`函数，如下所示：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The path to the file will be different for you.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的路径将因人而异。
- en: 'We can use this in the shell mode by wrapping the command in `$()`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在shell模式下使用它，通过将命令用`$()`括起来：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similarly to the help mode, the shell mode can be exited without executing any
    command by pressing backspace at the beginning of the line or typing *Ctrl* + *C*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与帮助模式类似，shell模式可以通过在行首按退格键或输入*Ctrl* + *C*来退出，而无需执行任何命令。
- en: 'In IJulia, the command can be executed by prefixing the input with `;`, like
    this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在IJulia中，可以通过在输入前加上`;`来执行命令，如下所示：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Search modes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索模式
- en: Besides the help and the shell modes, there are two search modes. These are
    not necessarily Julia specific, being common to many *nix style editing apps.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助和shell模式之外，还有两种搜索模式。这些模式不一定是Julia特有的，它们是许多*nix风格编辑应用程序的共同点。
- en: Press the *Ctrl* key and the *R* key at the same time in order to initiate a
    reverse incremental search. The prompt will change to `(reverse-i-search)`. Start
    typing your query and the most recent result will show. To find older results,
    type *Ctrl* + *R* again.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 同时按下*Ctrl*键和*R*键以启动反向增量搜索。提示符将变为`(reverse-i-search)`。开始输入你的查询，最近的搜索结果将显示出来。要找到更早的结果，再次按*Ctrl*
    + *R*。
- en: The counterpart of *Ctrl* + *R* is *Ctrl* + *S*, initiating an incremental search.
    The two may be used in conjunction to move through the previous or next matching
    results, respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *R*的对应操作是*Ctrl* + *S*，它启动增量搜索。这两个可以一起使用，分别用于移动到上一个或下一个匹配结果。'
- en: The startup.jl file
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`startup.jl`文件'
- en: If you want to automatically execute some code every time you run Julia, you
    can add it to a special file called `startup.jl`. This file is not automatically
    created, so you'll have to add it yourself to your Julia configuration directory.
    Any code you add to it will be run by Julia each time it starts up. Let's have
    some fun and do this using Julia—and practice a bit of what we've learned so far.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想每次运行Julia时自动执行一些代码，你可以将其添加到一个名为`startup.jl`的特殊文件中。这个文件不是自动创建的，所以你需要自己将它添加到你的Julia配置目录中。你添加到其中的任何代码都会在Julia启动时运行。让我们用Julia来做这个实验，并且练习一下我们学到的东西。
- en: 'First, go into shell mode and run these three commands:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进入shell模式并运行以下三个命令：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, in julian mode, execute the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在julian模式下，执行以下操作：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What did we just do? In shell mode, we created a new directory, called `config`,
    just one folder up from where our history file was. Then we `cd` into the newly
    created folder, where we created a new file called `startup.jl`. Finally, we asked
    Julia to add the line `"println(\"Welcome to Julia!\")"` to the `startup.jl` file.
    Next time we start the Julia REPL we''ll be greeted by this welcome message. Check
    this out:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才做了什么？在shell模式下，我们在历史文件所在目录的上一级创建了一个名为`config`的新目录。然后我们`cd`进入新创建的文件夹，在那里我们创建了一个名为`startup.jl`的新文件。最后，我们让Julia向`startup.jl`文件添加了这一行代码`"println(\"Welcome
    to Julia!\")"`。下次我们启动Julia REPL时，我们会看到这个欢迎信息。看看这个：
- en: '![](img/c5d8e674-f26c-4f07-8447-58183054c605.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5d8e674-f26c-4f07-8447-58183054c605.png)'
- en: REPL hooks
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL钩子
- en: It is also possible to define a function that will be automatically called before
    starting a REPL session. To achieve this, you need to use the `atreplinit(f)`
    function, which registers a one-argument function `f` to be called before the
    REPL interface is initialized in interactive sessions. This function should be
    called from within the `startup.jl` file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在启动REPL会话之前定义一个将被自动调用的函数。为了实现这一点，你需要使用`atreplinit(f)`函数，它将一个单参数函数`f`注册为在交互式会话中初始化REPL界面之前调用。这个函数应该从`startup.jl`文件内部调用。
- en: 'Let''s say that we edit our `startup.jl` file so that it now looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们编辑了`startup.jl`文件，使其现在看起来像这样：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our REPL will now greet us twice:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的REPL现在会两次问候我们：
- en: '![](img/3ce7247b-89de-4606-a154-3c88d1258c23.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ce7247b-89de-4606-a154-3c88d1258c23.png)'
- en: The `atreplinit` function can be used in tandem with `isinteractive`, which
    returns a `Boolean true` or `false` value that tells us whether or not Julia is
    running an interactive session.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`atreplinit`函数与`isinteractive`一起使用，`isinteractive`返回一个`Boolean true`或`false`值，告诉我们Julia是否正在运行一个交互式会话。
- en: Exiting the REPL
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出REPL
- en: In order to exit the REPL, you can type `^ D` (*Ctrl* + *D*). However, that
    will only work if you're at the beginning of the line (when the text buffer is
    empty). Otherwise just type `^C` (*Ctrl* + *C*) to first interrupt (or *c*ancel)
    and clear the line. You can also run `exit()`, which will stop the execution of
    the current Julia process.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出REPL，你可以输入`^ D`（*Ctrl* + *D*）。但是，这只有在行首（当文本缓冲区为空时）才会起作用。否则，只需输入`^C`（*Ctrl*
    + *C*）来首先中断（或取消）并清除行。你也可以运行`exit()`，这将停止当前Julia进程的执行。
- en: For the complete list of key bindings at the REPL and how to customise them,
    you can read the official documentation at [https://docs.julialang.org/en/v1.0/stdlib/REPL/#Key-bindings-1](https://docs.julialang.org/en/v1.0/stdlib/REPL/#Key-bindings-1).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看REPL中的完整键绑定列表以及如何自定义它们，你可以阅读官方文档[https://docs.julialang.org/en/v1.0/stdlib/REPL/#Key-bindings-1](https://docs.julialang.org/en/v1.0/stdlib/REPL/#Key-bindings-1)。
- en: The package system
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包系统
- en: Your Julia installation comes with a powerful package manager called `Pkg`.
    This handles all the expected operations, such as adding and removing packages,
    resolving dependencies and keeping installed packages up to date, running tests,
    and even assisting with publishing our own packages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Julia安装附带了一个名为`Pkg`的强大包管理器。它处理所有预期的操作，例如添加和删除包、解决依赖关系、保持已安装包的更新、运行测试，甚至帮助我们发布自己的包。
- en: Packages play a pivotal role by providing a wide range of functionality, seamlessly
    extending the core language. Let's take a look at the most important package management
    functions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 包通过提供广泛的功能，无缝地扩展了核心语言，发挥着至关重要的作用。让我们看看最重要的包管理功能。
- en: Adding a package
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个包
- en: In order to be known to `Pkg`, the packages must be added to a registry that
    is available to Julia. `Pkg` supports working with multiple registries simultaneously—including
    private ones hosted behind corporate firewalls. By default, `Pkg` is configured
    to use Julia's General registry, a repository of free and open sources packages
    maintained by the Julia community.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`Pkg`知道，包必须添加到一个Julia可用的注册表中。`Pkg`支持同时与多个注册表一起工作——包括位于企业防火墙后面的私有注册表。默认情况下，`Pkg`配置为使用Julia的通用注册表，这是一个由Julia社区维护的免费和开源包的存储库。
- en: '`Pkg` is quite a powerful beast and we''ll use it extensively throughout the
    book. Package management is a common task when developing with Julia so we''ll
    have multiple opportunities to progressively dive deeper. We''ll take our first
    steps now as we''ll learn how to add packages—and we''ll do this by stacking a
    few powerful new features to our Julia setup.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pkg`是一个非常强大的工具，我们将在整本书中广泛使用它。在使用Julia进行开发时，包管理是一个常见的任务，因此我们将有多次机会逐步深入了解。现在，我们将迈出第一步，学习如何添加包——我们将通过添加一些强大的新功能到我们的Julia设置中来实现这一点。'
- en: OhMyREPL
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OhMyREPL
- en: One of my favourite packages is called `OhMyREPL`. It implements a few super
    productive features for the Julia REPL, most notably syntax highlighting and brackets
    pairing. It's a great addition that makes the interactive coding experience even
    more pleasant and efficient.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的包之一叫做`OhMyREPL`。它为Julia的REPL实现了一些超级高效的功能，最显著的是语法高亮和括号配对。这是一个非常好的补充，使得交互式编码体验更加愉快和高效。
- en: Julia's `Pkg` is centered around GitHub. The creators distribute the packages
    as git repos, hosted on GitHub—and even the General registry is a GitHub repository
    itself. `OhMyREPL` is no exception. If you want to learn more about it before
    installing it—always a good idea when using code from third parties — you can
    check it out at [https://github.com/KristofferC/OhMyREPL.jl ](https://github.com/KristofferC/OhMyREPL.jl)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的`Pkg`以GitHub为中心。创建者将包作为git仓库分发，托管在GitHub上——甚至通用注册表本身也是一个GitHub仓库。`OhMyREPL`也不例外。在安装它之前，如果你想了解更多信息——使用第三方代码时，这总是一个好主意——你可以在[https://github.com/KristofferC/OhMyREPL.jl](https://github.com/KristofferC/OhMyREPL.jl)查看。
- en: Keep in mind that even if it's part of the General registry, the packages come
    with no guarantees and they're not necessarily checked, validated or endorsed
    by the Julia community. However, there are a few common sense indicators which
    provide insight into the quality of the package, most notably the number of stars,
    the status of the tests as well as the support for the most recent Julia versions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使它属于通用注册表，这些包也不提供任何保证，它们不一定经过Julia社区检查、验证或认可。然而，有一些常识性的指标可以提供关于包质量的洞察，最值得注意的是星标数量、测试状态以及最新Julia版本的兼容性。
- en: 'The first thing we need to do in order to add a package is to enter the `Pkg`
    REPL-mode. We do this by typing `]` at the beginning of the line:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加一个包，我们首先需要进入`Pkg`的REPL模式。我们通过在行首输入`]`来实现这一点：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The cursor will change to reflect that we''re now ready to manage packages:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 光标将改变以反映我们现在可以管理包了：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: IJulia does not (yet) support the `pkg>` mode, but we can execute `Pkg` commands
    by wrapping them in `pkg"..."` as in `pkg"add OhMyREPL"`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: IJulia目前不支持`pkg>`模式，但我们可以通过将它们包裹在`pkg"..."`中来执行`Pkg`命令，例如`pkg"add OhMyREPL"`。
- en: '`Pkg` uses the concept of *environments*, allowing us to define distinct and
    independent sets of packages on a per-project basis. This is a very powerful and
    useful feature, as it eliminates dependency conflicts caused by projects that
    rely on different versions of the same package (the so-called **dependency hell**).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pkg`使用*环境*的概念，允许我们根据项目定义不同的和独立的包集合。这是一个非常强大且有用的功能，因为它消除了由依赖于同一包的不同版本的项目（所谓的**依赖地狱**）引起的依赖冲突。'
- en: Given that we haven't created any project yet, `Pkg` will just use the default
    project, `v1.0`, indicated by the value between the parenthesis. This represents
    the Julia version that you're running on—and it's possible that you'll get a different
    default project depending on your very own version of Julia.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未创建任何项目，`Pkg`将仅使用默认项目`v1.0`，由括号中的值指示。这代表您正在运行的Julia版本——并且您可能会根据您自己的Julia版本得到不同的默认项目。
- en: 'Now we can just go ahead and `add OhMyREPL`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需继续添加`OhMyREPL`：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The IJulia equivalent of the previous command is `pkg"add OhMyREPL"`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令在IJulia中的等效命令是`pkg"add OhMyREPL"`。
- en: When running `pkg> add` on a fresh Julia installation, `Pkg` will clone Julia's
    General registry and use it to look up the names of the package we requested.
    Although we only explicitly asked for `OhMyREPL`, most Julia packages have external
    dependencies that also need to be installed. As we can see, our package has quite
    a few—but they were promptly installed by `Pkg`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当在新的Julia安装上运行`pkg> add`时，`Pkg`将克隆Julia的通用注册表，并使用它来查找我们请求的包名。尽管我们只明确请求了`OhMyREPL`，但大多数Julia包都有外部依赖项，也需要安装。正如我们所见，我们的包有很多——但它们被`Pkg`迅速安装了。
- en: Custom package installation
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义包安装
- en: 'Sometimes we might want to use packages that are not added to the general registry.
    This is usually the case with packages that are under (early) development—or private
    packages. For such situations, we can pass `pkg> add` the URL of the repository,
    instead of the package''s name:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能想使用未添加到通用注册表的包。这通常适用于处于（早期）开发中的包或私有包。对于这种情况，我们可以传递`pkg> add`存储库的URL，而不是包名：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another common scenario is when we want to install a certain branch of a package''s
    repository. This can be easily achieved by appending `#name_of_the_branch` at
    the end of the package''s name or URL:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见场景是我们想安装包存储库的某个分支。这可以通过在包名或URL的末尾附加`#name_of_the_branch`轻松实现：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or, for unregistered packages, use the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于未注册的包，使用以下命令：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we want to get back to using the published branch, we need to `free` the
    package:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想回到使用已发布的分支，我们需要`free`这个包：
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Revise
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Revise
- en: That was easy, but practice makes perfect. Let's add one more! This time we'll
    install `Revise`, another must-have package that enables a streamlined development
    workflow by monitoring and detecting changes in your Julia files and automatically
    reloading the code when needed. Before `Revise` it was notoriously difficult to
    load changes in the current Julia process, developers usually being forced to
    restart the REPL—a time-consuming and inefficient process. `Revise` can eliminate
    the overhead of restarting, loading packages, and waiting for code to compile.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但熟能生巧。让我们再添加一个！这次我们将安装`Revise`，这是另一个必不可少的包，它通过监控和检测您的Julia文件中的更改，并在需要时自动重新加载代码，从而实现流畅的开发工作流程。在`Revise`之前，加载当前Julia进程中的更改是出了名的困难，开发者通常被迫重启REPL——这是一个耗时且低效的过程。`Revise`可以消除重启、加载包和等待代码编译的开销。
- en: You can learn more about Revise by reading its docs at [https://timholy.github.io/Revise.jl/latest/](https://timholy.github.io/Revise.jl/latest/).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读其文档来了解更多关于Revise的信息，文档位于[https://timholy.github.io/Revise.jl/latest/](https://timholy.github.io/Revise.jl/latest/)。
- en: 'Unsurprisingly, we only have to invoke `add` one more time, this time passing
    in `Revise` for the package name:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 出乎意料的是，我们只需要再次调用`add`命令，这次传递`Revise`作为包名：
- en: '[PRE40]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `add` command also accepts multiple packages at once. We added them one
    by one now, for learning purposes, but otherwise, we could've just executed `(v1.0)
    pkg> add OhMyREPL Revise`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`命令也可以一次接受多个包。我们现在一个接一个地添加它们，为了学习目的，但否则，我们本可以执行`(v1.0) pkg> add OhMyREPL
    Revise`。'
- en: Checking the package status
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查包状态
- en: 'We can confirm that the operations were successful by checking our project''s
    status, using the aptly named `status` command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用恰如其分的`status`命令来检查我们项目的状态，以确认操作是否成功：
- en: '[PRE42]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `status` command displays all the installed packages, including, from left
    to right, the short version of the package's id (called the **UUID**), the name
    of the package and the version number. Where appropriate, it will also indicate
    the branch that we're tracking, as in the case of `Example`, where we're on the
    `master` branch.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`命令显示所有已安装的包，包括从左到右的包的ID简短版本（称为**UUID**）、包名和版本号。在适当的情况下，它还会指示我们正在跟踪的分支，例如在`Example`的情况下，我们处于`master`分支。'
- en: '`Pkg` also supports a series of shortcuts, if you want to save a few keystrokes.
    In this case, `st` can be used instead of `status`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pkg` 还支持一系列快捷方式，如果您想节省一些按键。在这种情况下，`st` 可以用来代替 `status`。'
- en: Using packages
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包
- en: 'Once a package has been added, in order to access its functionality we have
    to bring into scope. That''s how we tell Julia that we intend to use it, asking
    the compiler to make it available for us. For that, first, we need to exit pkg
    mode. Once we''re at the julian prompt, in order to use `OhMyREPL`, all we need
    to do is execute:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了包，为了访问其功能，我们必须将其引入作用域。这就是我们告诉 Julia 我们打算使用它的方法，请求编译器使其对我们可用。为此，首先，我们需要退出
    pkg 模式。一旦我们处于 julian 提示符，为了使用 `OhMyREPL`，我们只需要执行：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That''s all it takes—`OhMyREPL` is now automatically enhancing the current
    REPL session. To see it in action, here is what the *regular* REPL looks like:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部——`OhMyREPL` 现在会自动增强当前的 REPL 会话。要看到它的实际效果，这里是一个 *常规* REPL 的样子：
- en: '![](img/78f2947b-7269-43bd-97b4-3d03c4dfcebb.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78f2947b-7269-43bd-97b4-3d03c4dfcebb.png)'
- en: 'And here is the same code, enhanced by `OhMyREPL`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的代码，通过 `OhMyREPL` 增强后的样子：
- en: '![](img/8a1b2be7-71f1-4f3c-bcd4-90772ef61512.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a1b2be7-71f1-4f3c-bcd4-90772ef61512.png)'
- en: Syntax highlighting and bracket matching make the code more readable, reducing
    syntax errors. Looks pretty awesome, doesn't it?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 语法高亮和括号匹配使代码更易读，减少了语法错误。看起来很棒，不是吗？
- en: '`OhMyREPL` has a few more cool features up its sleeve—you can learn about them
    by checking the official documentation at [https://kristofferc.github.io/OhMyREPL.jl/latest/index.html](https://kristofferc.github.io/OhMyREPL.jl/latest/index.html).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`OhMyREPL` 还有更多酷炫的功能——您可以通过查看官方文档了解它们：[https://kristofferc.github.io/OhMyREPL.jl/latest/index.html](https://kristofferc.github.io/OhMyREPL.jl/latest/index.html)。'
- en: One more step
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再多一步
- en: '`OhMyREPL` and `Revise` are excellent development tools and it''s very useful
    to have them loaded automatically in all the Julia sessions. This is exactly why
    the `startup.jl` file exists—and now we have the opportunity to put it to good
    use (not that our heartfelt and welcoming greetings were not impressive enough!).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`OhMyREPL` 和 `Revise` 是出色的开发工具，在所有 Julia 会话中自动加载它们非常有用。这正是 `startup.jl` 文件存在的原因——现在我们有了一个将其用于实际的机会（尽管我们诚挚的欢迎问候已经足够令人印象深刻了！）。'
- en: 'Here''s a neat trick, to get us started—Julia provides an `edit` function that
    will open a file in the configured editor. Let''s use it to open the `startup.jl`
    file:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小技巧，让我们开始——Julia 提供了一个 `edit` 函数，它会在配置的编辑器中打开一个文件。让我们用它来打开 `startup.jl`
    文件：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will open the file in the default editor. If you haven''t yet deleted
    our previously added welcome messages, feel free to do it now (unless you really
    like them and in that case, by all means, you can keep them). Now, `Revise` needs
    to be used before any other module that we want to track—so we''ll want to have
    it at the top of the file. As for `OhMyREPL`, it can go next. Your `startup.jl`
    file should look like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用默认编辑器打开文件。如果您还没有删除我们之前添加的欢迎信息，现在可以自由地这样做（除非您真的很喜欢它们，在这种情况下，您当然可以保留它们）。现在，`Revise`
    需要在我们想要跟踪的任何其他模块之前使用——所以我们将希望它在文件顶部。至于 `OhMyREPL`，它可以放在下面。您的 `startup.jl` 文件应该看起来像这样：
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Save it and close the editor. Next time you start Julia, both `Revise` and `OhMyREPL`
    will be already loaded.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并关闭编辑器。下次您启动 Julia 时，`Revise` 和 `OhMyREPL` 将已经加载。
- en: Updating packages
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新包
- en: 'Julia boosts a thriving ecosystem and packages get updated at a rapid pace.
    It''s a good practice to regularly check for updates with `pkg> update`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了一个繁荣的生态系统，并且包的更新速度非常快。定期使用 `pkg> update` 检查更新是一个好习惯：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When this command is issued, Julia will first retrieve the latest version of
    the general repository, where it will check if any of the packages need to be
    updated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出此命令时，Julia 首先检索通用仓库的最新版本，然后检查是否有任何包需要更新。
- en: 'Beware that issuing the `update` command will update all the available packages.
    As we discussed earlier, when mentioning *dependency hell*, this might not be
    the best thing. In the upcoming chapters, we will see how to work with individual
    projects and manage dependencies per individual application. Until then though,
    it''s important to know that you can cherry pick the packages that you want to
    update by passing in their names:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，发出 `update` 命令将更新所有可用的包。正如我们之前讨论的，当提到 *依赖地狱* 时，这可能不是最好的做法。在接下来的章节中，我们将看到如何与单个项目一起工作，并按单个应用程序管理依赖项。不过，了解您可以通过传递它们的名称来选择您想要更新的包是很重要的：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`Pkg` also exposes a preview mode, which will show what will happen when running
    a certain command without actually making any of the changes:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pkg` 还提供了一个预览模式，它将显示运行特定命令时会发生什么，而实际上不会进行任何更改：'
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The shortcut for `pkg> update` is `pkg> up`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg> update` 的快捷键是 `pkg> up`。'
- en: Pinning packages
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定包
- en: 'Sometimes though we might want to ensure that certain packages will not be
    updated. That''s when we `pin` them:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能想要确保某些包不会被更新。这就是我们“固定”它们的时候：
- en: '[PRE49]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Pinned packages are marked with the `⚲` symbol—also present now when checking
    the status:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 固定包会标记为 `⚲` 符号——现在在检查状态时也会出现：
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we want to unpin a package, we can use `pkg> free`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想取消固定一个包，我们可以使用 `pkg> free`：
- en: '[PRE51]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Removing packages
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除包
- en: 'If you no longer plan on using some packages you can delete (or remove them),
    with the (you guessed it) `pkg> remove` command. For instance, let''s say that
    we have the following configuration:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不再打算使用某些包，你可以删除（或使用 `pkg> remove` 命令移除它们）。例如，假设我们有以下配置：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can remove the `Example` package with the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码移除 `Example` 包：
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Sure enough, it''s now gone:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它现在已经消失了：
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The shortcut for `pkg> remove` is `pkg> rm`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg> remove` 的快捷键是 `pkg> rm`。'
- en: 'Besides the explicit removal of undesired packages, `Pkg` also has a built-in
    auto-cleanup function. As package versions evolve and package dependencies change,
    some of the installed packages will become obsolete and will no longer be used
    in any existing project. `Pkg` keeps a log of all the projects used so it can
    go through the log and see exactly which projects are still needing which packages—and
    thus identify the ones that are no longer necessary. These can be deleted in one
    swoop with the `pkg> gc` command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显式删除不需要的包外，`Pkg` 还有一个内置的自动清理功能。随着包版本的发展和包依赖关系的变化，一些已安装的包可能会变得过时，并且不再在任何现有项目中使用。`Pkg`
    会记录所有使用过的项目，以便它可以遍历日志并确切地看到哪些项目仍然需要哪些包——从而识别出不再必要的包。这些可以使用 `pkg> gc` 命令一次性删除：
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Besides the dedicated `Pkg` REPL mode, Julia also provides a powerful API for
    programmatically managing packages. We won't cover it, but if you want to learn
    about it, you can check the official documentation at [https://docs.julialang.org/en/latest/stdlib/Pkg/#References-1](https://docs.julialang.org/en/latest/stdlib/Pkg/#References-1).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 除了专门的 `Pkg` REPL 模式外，Julia 还提供了一个强大的 API，用于以编程方式管理包。我们不会涉及它，但如果你想了解它，你可以查看官方文档，链接为
    [https://docs.julialang.org/en/latest/stdlib/Pkg/#References-1](https://docs.julialang.org/en/latest/stdlib/Pkg/#References-1)。
- en: Discovering packages
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现包
- en: Package discovery is not yet as simple as it could be, but there are a few good
    options. I recommend starting with this list of curated Julia packages: [https://github.com/svaksha/Julia.jl](https://github.com/svaksha/Julia.jl).
    It groups a large collection of packages by domain, covering topics such as AI,
    Biology, Chemistry, Databases, Graphics, Data Science, Physics, Statistics, Super-Computing
    and more.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 包发现还不是像它本可以那样简单，但有一些很好的选项。我建议从以下精心挑选的 Julia 包列表开始：[https://github.com/svaksha/Julia.jl](https://github.com/svaksha/Julia.jl)。它按领域分组了一个大量的包集合，包括人工智能、生物学、化学、数据库、图形、数据科学、物理学、统计学、超级计算等多个主题。
- en: If that is not enough, you can always go to [https://discourse.julialang.org](https://discourse.julialang.org/) where
    the Julia community discusses a multitude of topics related to the language. You
    can search and browse the existing threads, especially the package announcements
    section, hosted at [https://discourse.julialang.org/c/community/packages](https://discourse.julialang.org/c/community/packages).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，你总是可以访问 [https://discourse.julialang.org](https://discourse.julialang.org/)，在那里
    Julia 社区讨论与语言相关的多种主题。你可以搜索和浏览现有的线程，特别是位于 [https://discourse.julialang.org/c/community/packages](https://discourse.julialang.org/c/community/packages)
    的包公告部分。
- en: Of course you can always ask the community for help—Julians are very friendly
    and welcoming, and a lot of effort is put towards moderation, in order to keep
    the discussion civilized and constructive. A free Discourse account is required
    in order to create new topics and post replies.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你总是可以向社区寻求帮助——Julians 非常友好和欢迎，社区投入了大量精力进行管理，以保持讨论文明和建设性。创建新主题和回复需要免费 Discourse
    账户。
- en: Finally, [https://juliaobserver.com/packages](https://juliaobserver.com/packages) is
    a third party website that provides a more polished way to look for packages—and
    it also performs a GitHub search, thus including unregistered packages too.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[https://juliaobserver.com/packages](https://juliaobserver.com/packages)
    是一个第三方网站，提供了一种更精致的方式来查找包——它还执行 GitHub 搜索，因此也包括未注册的包。
- en: Registered versus unregistered
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册与非注册
- en: Although I already touched upon the topic in the previous paragraphs, I want
    to close the discussion about `Pkg` with a word of caution. The fact that a package
    is registered does not necessarily mean that it has been vetted in terms of functionality
    or security. It simply means that the package has been submitted by the creator
    and that it met certain technical requirements to be added to the general registry.
    The package sources are available on GitHub, and like with any open source software,
    make sure that you understand what it does, how it should be used, and that you
    accept the licensing terms.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我已在之前的段落中提到了这个话题，但我仍想以一个警告来结束对 `Pkg` 的讨论。一个包是否注册并不一定意味着它在功能或安全性方面经过了审查。它仅仅意味着该包已被创建者提交，并且它满足了一些技术要求，以便被添加到通用注册表中。包源代码可在
    GitHub 上找到，就像任何开源软件一样，请确保你了解它做什么，应该如何使用，以及你接受许可条款。
- en: This concludes our initial discussion about package management. But as this
    is one of the most common tasks, we'll come back to it again and again in future
    chapters, where we'll also see a few scenarios for more advanced usage.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对包管理的初步讨论。但鉴于这是最常见的任务之一，我们将在未来的章节中反复回到这个话题，我们还将看到一些更高级使用的场景。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Julia is a new programming language that takes advantage of recent innovations
    in compiler technology to offer the functionality, ease-of-use, and intuitive
    syntax of dynamic programming languages at the speed of C. One if its goals is
    to eliminate the so-called **two language problem**—when the users code in a high-level
    language, such as R and Python, but performance-critical parts have to be rewritten
    in C or C++. Julia feels like a dynamic language and offers all the productivity
    features associated with these. But at the same time, it eliminates the performance
    trade-offs, proving to be productive enough for prototyping and exploratory coding,
    and efficient enough for performance-critical applications.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 是一种新的编程语言，它利用了编译技术方面的最新创新，以提供动态编程语言的函数性、易用性和直观语法，同时以 C 的速度运行。其目标之一是消除所谓的**两种语言问题**——当用户用高级语言（如
    R 和 Python）编写代码时，但性能关键部分必须用 C 或 C++ 重新编写。Julia 感觉像是一种动态语言，并提供了与这些语言相关的所有生产力特性。但与此同时，它消除了性能权衡，证明对于原型设计和探索性编程来说足够高效，对于性能关键的应用来说也足够高效。
- en: Its built-in package manager provides access to over 2,000 third-party libraries
    that seamlessly extend the language with powerful new features—and we've learned
    how to take advantage of these. And if that is not enough, Julia has the ability
    to call functions written in other languages, such as C, Fortran, Python, or Java,
    to name just a few.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 它的内置包管理器提供了访问 2000 多个第三方库的权限，这些库无缝地扩展了语言，并提供了强大的新功能——我们已经学会了如何利用这些功能。而且如果还不够，Julia
    还具有调用其他语言（如 C、Fortran、Python 或 Java）编写的函数的能力，仅举几个例子。
- en: Julia is free and open source (MIT licensed) and can be deployed on all the
    major operating systems, including Windows, the main Linux distributions, and
    macOS. It also comes with some very good IDE and editor options.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 是免费且开源的（MIT 许可），可以在所有主要的操作系统上部署，包括 Windows、主要的 Linux 发行版和 macOS。它还提供了一些非常好的
    IDE 和编辑器选项。
- en: Now that we have successfully set up our development environment, it's time
    to dive deeper into Julia's syntax. In the next chapter, we'll take a look at
    some of the basic building blocks of the language—defining variables and constants,
    manipulating and using `Strings` and numeric types, and working with `Arrays`.
    As a testament to Julia's productivity, that's all we'll need (together with some
    extra packages that we'll add) in order to perform powerful exploratory data analysis
    on the Iris flowers dataset. Meet you in the next chapter!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功设置了我们的开发环境，是时候深入探讨 Julia 的语法了。在下一章中，我们将查看语言的一些基本构建块——定义变量和常量、操作和使用 `Strings`
    和数值类型，以及与 `Arrays` 一起工作。作为 Julia 生产力的一种证明，这就是我们（连同我们将添加的一些额外包）在 Iris 花卉数据集上进行强大的探索性数据分析所需的一切（together
    with some extra packages that we'll add）。下一章见！
