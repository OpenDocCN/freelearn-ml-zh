<html><head></head><body>
		<h1 id="_idParaDest-29" class="chapter-number"><a id="_idTextAnchor028"/>2</h1>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Refactoring Your Monolith</h1>
			<p>Now we have decided that MSA is the right architectural style for our organization, <span class="No-Break">what’s next?</span></p>
			<p>In a recent report, <em class="italic">2022 APIs &amp; Microservices Connectivity Report</em>, published by Kong Inc., 75% of organizations have a lack of innovation and <span class="No-Break">technology adoption.</span></p>
			<p>The need for an IT system that quickly responds to customer and market needs has never been higher. Monolithic applications can no longer respond to high-paced market updates and needs. That’s one main reason for organizations to look to update their IT system, to stay <span class="No-Break">in business.</span></p>
			<p>MSA is a primary enabler for a flexible and reliable enterprise system. Transitioning from a monolithic architecture into MSA is, therefore, becoming essential to modernizing an organization’s <span class="No-Break">IT systems.</span></p>
			<p>We will discuss, in this chapter, how to break up the business requirements of an existing running monolithic application in to microservices, and the steps necessary to transition toward <span class="No-Break">MSA applications.</span></p>
			<p>We will cover the following areas as we go over <span class="No-Break">the chapter:</span></p>
			<ul>
				<li>Identifying the <span class="No-Break">system’s microservices</span></li>
				<li>The <span class="No-Break">ABC monolith</span></li>
				<li><span class="No-Break">Function decomposition</span></li>
				<li><span class="No-Break">Data decomposition</span></li>
				<li><span class="No-Break">Request decomposition</span></li>
			</ul>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Identifying the system’s microservices</h1>
			<p>Whether it is a <a id="_idIndexMarker065"/>brownfield or greenfield enterprise system implementation, we still need to break up business requirements into basic functions as granularly as possible. This will later help us identify each microservice and successfully integrate it into our <span class="No-Break">enterprise system.</span></p>
			<p>In a brownfield system, business and system requirements have already been identified and implemented. They may, however, need to be revisited and updated according to new business criteria, changes, <span class="No-Break">and requirements.</span></p>
			<p>The objective of refactoring your application into simple services is to form highly granular functions that will eventually be built (or acquired) as microservices. You are very likely to add new functions to your new MSA in addition to some of the functions you will already extract from the <span class="No-Break">monolithic system.</span></p>
			<p>We, therefore, split the migration process into the following <span class="No-Break">high-level steps:</span></p>
			<ol>
				<li>Define the to-be MSA system and the functions needed to build <span class="No-Break">that MSA.</span></li>
				<li>Identify what existing functions in the current monolithic system are to be reused in the new MSA and implemented <span class="No-Break">as microservices.</span></li>
				<li>Identify the delta between the existing functions to be reused and the functions needed to get to the to-be MSA system. These are the new functions to be implemented in the new <span class="No-Break">MSA system.</span></li>
				<li>From the functions list identified in <em class="italic">step 3</em>, identify which functions will be developed as a microservice in-house, and the ones that can be acquired through <span class="No-Break">third parties.</span></li>
			</ol>
			<p>Decomposing the monolith using a function-driven approach is a good starting point; nevertheless, using that approach alone is not enough. Since data stores are centralized in the monolith, data dependencies will still be a big concern in maintaining the <span class="No-Break">microservices’ autonomy.</span></p>
			<p>The interaction between the different functions in the monolith is another concern. We will need to look into how the function calls are being processed and handled, what data is being shared between these functions, and what data is <span class="No-Break">being returned.</span></p>
			<p>Examining monolithic system functions, data, and function calls (requests) during the refactoring process is essential for maintaining the autonomy of microservices and achieving the desired level <span class="No-Break">of granularity.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Bear in mind that we must maintain the microservices autonomy principle during the entire monolith decomposition process. Too many microservices would cause a <strong class="bold">Nano-service anti-pattern</strong> effect, while <a id="_idIndexMarker066"/>too few would still leave your system with the same issues as a <span class="No-Break">monolithic system.</span></p>
			<p>The Nano-service anti-pattern creates too many expectations for most systems’ operations, which can in turn further complicate your MSA system and create a lack of stability, decreased reliability, and other system <span class="No-Break">performance issues.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">As a general rule, apply <a id="_idIndexMarker067"/>the <strong class="bold">Common Closure Principle</strong>, where microservices that change for the same exact reason are better off packaged together in a <span class="No-Break">single microservice.</span></p>
			<p>To better explain the monolith transformation process to an MSA, in the following sections, we will design a simple <a id="_idIndexMarker068"/>hypothetical monolithic system, break up the system using the already mentioned three stages of system decomposition, build the different microservices, and then organize them together to build <span class="No-Break">the MSA.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>The ABC monolith</h1>
			<p>ABC is a simplified <a id="_idIndexMarker069"/>hypothetical product-ordering monolithic system built specifically to demonstrate the process and the steps needed in refactoring a monolithic application into an MSA. We will be using this ABC system throughout this book to demonstrate some examples of how to apply the concepts <span class="No-Break">and methodologies.</span></p>
			<p>Please note that we put the ABC-Monolith system together for demo purposes only and our aim here is not to discuss how the ABC-Monolith can be designed or structured better. We are more focused on the ABC-Monolith system refactoring <span class="No-Break">process itself.</span></p>
			<p>In the ABC-Monolith, the user can place an order from an existing product catalog and track the order’s shipping status. For simplicity, all sales are final, and products cannot <span class="No-Break">be returned.</span></p>
			<p>The system will be able to clear the order payment, assign a shipping courier to the order, and track all order and <span class="No-Break">shipping updates.</span></p>
			<p>The following diagram shows the high-level ABC-Monolith architecture. A user portal is used to add items to<a id="_idIndexMarker070"/> the cart, then send the order details to the ABC-Monolith. The ABC-Monolith has different tightly coupled functions with a centralized database, all to process the order from payment to delivery. The user is notified of all order and shipping updates throughout the order <span class="No-Break">fulfillment process.</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B18934_02_1.jpg" alt="Figure 2.1: The ABC-Monolith architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: The ABC-Monolith architecture</p>
			<p>To further understand <a id="_idIndexMarker071"/>the monolith, we will next go over the system As-Is state by discussing the existing monolith’s functions, the monolith database structure, and the workflow of the order placement process. We will close this section by comparing the As-Is to the <span class="No-Break">To-Be state.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>The ABC-Monolith’s current functions</h2>
			<p>It is imperative to<a id="_idIndexMarker072"/> start by understanding what current functions are implemented in the monolith and what their role is in the overall system. The following table lists the system functions we need to consider later in our <span class="No-Break">system refactoring:</span></p>
			<table id="table001-2" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Function</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Description</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">place_order()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A function to create a record with all order information, and mark the order as “pending” awaiting the rest of the order <span class="No-Break">placement process.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">check_inventory()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>To check the availability of an item in the <span class="No-Break">placed order.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">process_payment()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Verify the payment of the total order amount. Will return an error code if the payment is <span class="No-Break">not cleared.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">update_inventory()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Once an order is verified and the payment is successfully processed, the item inventory should be <span class="No-Break">updated accordingly.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">create_order()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The order is now successfully processed; time to change the order status, and kick off the order preparation process (<span class="No-Break">packing, etc.).</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">create_shipping_request()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Starts the order shipping request and notifies the courier with an available order <span class="No-Break">for shipping.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">order_status_update()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A function to update the order status with any changes such as preparing, shipping, exception, received, and <span class="No-Break">so on.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">shipment_status_update()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A function to update the shipping status with any changes such as, pending pickup, picked up, en route, exception, received, and <span class="No-Break">so on.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">notify_user()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>To notify the user of any changes or updates to the <span class="No-Break">placed order.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">register_customer()</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A function that creates customer record information with a full name, address, phone, and <span class="No-Break">other details.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1: The ABC-Monolith functions list</p>
			<p>In the preceding table, we focused our description on the role of the function itself regardless of what the<a id="_idIndexMarker073"/> parameter passing is, or what the return <span class="No-Break">values are.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>The ABC-Monolith’s database</h2>
			<p>All the functions<a id="_idIndexMarker074"/> identified in the monolith share a centralized database. The following are the database tables being accessed by <span class="No-Break">the functions:</span></p>
			<table id="table002-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Database Table</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Description</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">CUSTOMER</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A table holding all customer information such as name, email, <span class="No-Break">and phone.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ITEM</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The product information is in the catalog. Product information includes product name, price, and <span class="No-Break">stock quantity.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ORDER</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Information on <span class="No-Break">orders placed.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ORDER_ITEM</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A many-to-many relationship normalization table between the <strong class="source-inline">ORDER</strong> and <span class="No-Break"><strong class="source-inline">ITEM</strong></span><span class="No-Break"> tables.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ORDER_STATUS</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The status of each placed order, with a reference <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">status_code</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">STATUS_CODE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Lookup table for order and shipment <span class="No-Break">status codes.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">COURIER</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Shipping courier information, including courier name, contact, and <span class="No-Break">so on.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">SHIPMENT_REQUEST</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A list of all shipping requests for <span class="No-Break">orders placed.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">SHIPMENT_REQUEST_STATUS</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The status of each shipment request, with a reference <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">status_code</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2: The ABC-Monolith database tables list</p>
			<p>The following is <a id="_idIndexMarker075"/>ABC’s <strong class="bold">Entity Relationship Diagram</strong> (<strong class="bold">ERD</strong>). Note that we needed to create the <strong class="bold">ORDER_ITEM</strong> normalization table to break up the many-to-many relationship between both the <strong class="bold">ORDER</strong> and <span class="No-Break"><strong class="bold">ITEM</strong></span><span class="No-Break"> tables:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B18934_02_2.jpg" alt="Figure 2.2: The ABC-Monolith ERD"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: The ABC-Monolith ERD</p>
			<p>Keep in mind that some of the monolith’s functions require full read/write access to specific tables with access to all fields in the table, while some other functions need only access to specific fields in<a id="_idIndexMarker076"/> the table. This information is important in <span class="No-Break">system refactoring.</span></p>
			<p>In the following section, we will go over the workflow to identify the ABC-Monolith As-Is state and determine how we can transition into the To-Be state. Along with the workflow information, the function database access requirements will help us refactor the monolith database into individual MSA databases for <span class="No-Break">each microservice.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>The ABC workflow and current function calls</h2>
			<p>We know so far<a id="_idIndexMarker077"/> what functions are used in the monolith and how the monolith’s database is structured. The next step is to examine the order <span class="No-Break">placement workflow:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B18934_02_3.jpg" alt="Figure 2.3: The ABC-Monolith function requests/workflow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: The ABC-Monolith function requests/workflow</p>
			<p>As shown in the preceding workflow diagram, the individual functions are all executed sequentially. Since it is all one tightly coupled system, there are no synchronization issues expected, and hence no orchestration <span class="No-Break">is needed.</span></p>
			<p>As we move toward the ABC-MSA, however, the decoupling of services creates the need to have a centralized point for managing the execution of these services in a <span class="No-Break">specific sequence.</span></p>
			<p>Shown in the following diagram are ABC’s As-Is and To-Be states. No centralized management in the As-Is state is needed; however, an orchestrator component is introduced in the To-Be state to manage the process flows between <span class="No-Break">the services.</span></p>
			<p>Each of the individual services in the To-Be states has a dedicated database, as shown in the diagram. In the As-Is state, on the other hand, the database <span class="No-Break">is centralized.</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B18934_02_4.jpg" alt="Figure 2.4: The ABC As-Is and To-Be states"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: The ABC As-Is and To-Be states</p>
			<p>Now that we know how our current ABC-Monolith is structured, and what both the as-is and to-be states are, it is time to start the ABC-Monolith refactoring process to transform into <span class="No-Break">the ABC-MSA.</span></p>
			<p>We will refactor the monolith in three stages. First, we will decompose the monolith functions and map these functions to microservices. Then, we will decompose the data to see how<a id="_idIndexMarker078"/> the individual databases will be designed. Finally, out of the monolith’s workflow, we will analyze the function requests, and build our MSA sagas <span class="No-Break">from there.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Function decomposition</h1>
			<p>The first step in<a id="_idIndexMarker079"/> refactoring the ABC-monolith is to create the microservices based on the system functions we previously identified. This is a straightforward mapping between the existing functions and <span class="No-Break">the microservices.</span></p>
			<p>The key point here is that, by looking only at each function by itself without considering any function calls or data connections, you need to be as granular as possible in your <span class="No-Break">function decomposition.</span></p>
			<p>At first glance, the <strong class="source-inline">notify_user()</strong> function is doing too many things for a microservice, displaying a web user message status/update, notifying the user by email, and/or notifying the user by SMS. Each of these functions can have its own rules, design, issues, and concerns. Splitting the <strong class="source-inline">notify_user()</strong> function into three functions is a better approach from an MSA perspective to achieve the separation <span class="No-Break">of concerns.</span></p>
			<p>Accordingly, we<a id="_idIndexMarker080"/> split the <strong class="source-inline">notify_user()</strong> function into one function for handling web messages and notifications, one for handling email notifications, and one for SMS <span class="No-Break">message notifications:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">web_msg_notification()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">email_notification()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">sms_notification()</strong></span></li>
			</ul>
			<p>Similarly, the <strong class="source-inline">process_payment()</strong> function can also be split into two different, more granular functions, one for handling direct credit card payments and one for handling <span class="No-Break">PayPal payments:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">verify_cc_payment()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">verify_paypal_payment()</strong></span></li>
			</ul>
			<p>The following diagram shows how the ABC-Monolith is broken up so far. We haven’t yet looked into how the system’s functions are interacting with each other. The function interactions and the order fulfillment’s overall workflow will be handled at a <span class="No-Break">later stage.</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B18934_02_5.jpg" alt="Figure 2.5: The ABC-Monolith function decomposition"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: The ABC-Monolith function decomposition</p>
			<p>At this point, we are satisfied with the current level of granularity so far and we are ready to examine<a id="_idIndexMarker081"/> how the database tables are being accessed to see whether further decomposition <span class="No-Break">is needed.</span></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Data decomposition</h1>
			<p>During this stage, we <a id="_idIndexMarker082"/>need to look at how each function is accessing the database and what tables and even which parts of the database tables <span class="No-Break">are accessed.</span></p>
			<p>The following diagram shows what parts of the database the ABC-Monolith functions access. It is essential to know exactly which tables are accessed by which function and why. This will help us identify database dependencies, in order to later eliminate these dependencies and split the centralized ABC-Monolith database into separate data stores, each data store dedicated to <span class="No-Break">each microservice.</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B18934_02_6.jpg" alt="Figure 2.6: ABC-Monolith database access"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: ABC-Monolith database access</p>
			<p>We are still bound by<a id="_idIndexMarker083"/> the microservice autonomy rule. The challenging part in the diagram and this refactoring phase is the shared tables. Sharing a table between two microservices creates coupling that would clearly violate the autonomy rule. On the other hand, creating multiple copies of the table across different microservices will create serious data consistency issues. So, how do we solve <span class="No-Break">this conundrum?</span></p>
			<p>Remember <a id="_idIndexMarker084"/>the <strong class="bold">saga patterns</strong> that we previously discussed in <a href="B18934_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>? <strong class="bold">Saga patterns</strong> should be able to solve data consistency issues that arise from having a transaction that spans multiple services. In our example here, we can have duplicates of the <strong class="source-inline">ORDER</strong> table, for example, across the <strong class="source-inline">place_order()</strong>, <strong class="source-inline">create_order()</strong>, and <strong class="source-inline">process_payment()</strong> services of the ABC-MSA system. A similar approach is taken for <strong class="source-inline">check_inventory()</strong>, <strong class="source-inline">update_inventory()</strong>, and <span class="No-Break">so on.</span></p>
			<p>So, with saga patterns in mind, let’s reexamine the ABC-Monolith database access shown in the preceding diagram, to build a new database access diagram for services in the <span class="No-Break">ABC-MSA system.</span></p>
			<p>There are two ways to coordinate the data transactions, choreography and orchestration. In choreography, the ABC-MSA saga participant services will have to coordinate data transactions among themselves. In orchestration, a centralized orchestrator performs the coordination process and handles all <span class="No-Break">workflow transactions.</span></p>
			<p>Certainly, we can choose either coordination methodology, but in our example, we would argue that orchestration creates a better decoupling model over choreography. For that reason, and to keep our example simple, we will be using orchestration for our ABC-MSA <span class="No-Break">saga patterns.</span></p>
			<p>The following diagram<a id="_idIndexMarker085"/> shows the ABC-MSA service database access. As you can see in the diagram, there are a few database tables that have been copied across the system. We will, in the next section, use saga patterns to maintain data consistency across the <span class="No-Break">copied tables.</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B18934_02_7.jpg" alt="Figure 2.7: ABC-MSA database access"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: ABC-MSA database access</p>
			<p>We notice in other<a id="_idIndexMarker086"/> services, such as <strong class="bold">web_msg_notification</strong>, <strong class="bold">email_notification</strong>, and <strong class="bold">sms_notification</strong>, that the database is identical for all three services. This is an indication that<a id="_idIndexMarker087"/> creating these three services off the original <strong class="source-inline">notify_user()</strong> function may not be a good idea anyway. You should only see small database access similarities between these different services, not a completely identical database. In a real scenario, we are better off combining these three services into only one service as it <span class="No-Break">originally was.</span></p>
			<p>Similarly, in a real-life scenario, the <strong class="source-inline">process_payment()</strong> function is likely to be mapped to a single service that includes clearing the payment overall, regardless of whether it is a credit card, PayPal, or any other form of payment. For demo purposes, we will split <strong class="source-inline">notify_user()</strong> and <strong class="source-inline">process_payment()</strong> into three and two different <span class="No-Break">services respectively.</span></p>
			<p>So far, we have been able to build the ABC-MSA’s microservices from the ABC-Monolith functions, identify data access in the monolith, and decompose the monolith into separate microservices, each with its own database. In the next section, we will focus more on how to <a id="_idIndexMarker088"/>ensure isolation and separation of concerns for the microservices by looking into how the service requests are orchestrated in the new <span class="No-Break">ABC-MSA system.</span></p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Request decomposition</h1>
			<p>The ABC-Monolith<a id="_idIndexMarker089"/> function request flow has already been identified and shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.3</em>. We will now see how this flow is going to work in <span class="No-Break">the ABC-MSA.</span></p>
			<p>In the ABC-MSA, the sagas are programmed and configured in the centralized orchestrator. The orchestrator will initiate separate API calls to each service in the saga, in either a synchronous or asynchronous fashion, depending on the defined workflow, and wait for a response from each API call to determine what other API call(s) to initiate next <span class="No-Break">and how.</span></p>
			<p>The following diagram shows how the workflow would be in the ABC-MSA. Please note that all API calls in our scenario are being initiated from the orchestrator. As you can see from the sequence number, there are some API calls initiated in parallel, and in some other cases, the orchestrator decides the next course of action based on the response it receives from a previously <span class="No-Break">executed service.</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B18934_02_8.jpg" alt="Figure 2.8: The ABC-MSA workflow"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: The ABC-MSA workflow</p>
			<p>The user in the<a id="_idIndexMarker090"/> ABC-MSA <a id="_idIndexMarker091"/>workflow diagram initiates the order fulfillment process from a web interface, which will kick off the workflow from the orchestrator. Both the <strong class="bold">place_order</strong> and <strong class="bold">check_inventory</strong> services are launched at the same time by the orchestrator. <strong class="bold">place_order</strong> creates the order with all its information and marks its state as <strong class="bold">pending</strong>, waiting for the rest of the workflow to <span class="No-Break">be processed.</span></p>
			<p>The <strong class="bold">check_inventory</strong> service checks the inventory of items ordered and sends back a <strong class="bold">true</strong> or <strong class="bold">false</strong> response depending on whether the item is available or not. If any of the items ordered are not available, the <strong class="bold">web_msg_notification</strong>, <strong class="bold">email_notification</strong>, and <strong class="bold">sms_notification</strong> services <span class="No-Break">are triggered.</span></p>
			<p>Now, here is the first challenge: all three notification services will require access to the <strong class="source-inline">CUSTOMER</strong> database in order to get the customer’s name, email address, phone number, and so on. But having one database for all three services creates undesired coupling that would violate the microservices autonomy principle. As we discussed earlier, we should instead create copies of that <strong class="source-inline">CUSTOMER</strong> database across all services to avoid service coupling. But how do we <span class="No-Break">do that?</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B18934_02_9.jpg" alt="Figure 2.9: Maintaining database consistency across MSA"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: Maintaining database consistency across MSA</p>
			<p>The <strong class="source-inline">CUSTOMER</strong> database is mainly managed by the <strong class="bold">register_customer</strong> service, which is triggered by the<a id="_idIndexMarker092"/> orchestrator through the user interface. To be able to maintain data consistency, and as shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.9</em>, the orchestrator will need to simultaneously issue the same transaction on all copies of the <strong class="source-inline">CUSTOMER</strong> database whenever a record is edited, created, <span class="No-Break">or deleted.</span></p>
			<p>The orchestrator will need to wait for a success confirmation from all four services, <strong class="bold">register_customer</strong>, <strong class="bold">email_notification</strong>, <strong class="bold">sms_ notification</strong>, and <strong class="bold">web_ msg_notification</strong>, before the workflow is finalized. Now, what if, let’s say, updating the <strong class="bold">sms_ notification</strong> <strong class="source-inline">CUSTOMER</strong> database fails? You will end up with data inconsistency, which can be a serious issue <span class="No-Break">later on.</span></p>
			<p>That’s why all saga participants’ local transactions will need to have a set of compensating transactions to ensure a rollback in case of any failures in executing the transaction. In our example, the orchestrator will need to undo updates to the <strong class="source-inline">CUSTOMER</strong> database for all the <span class="No-Break">other services.</span></p>
			<p>The following diagram shows how a failure to update the <strong class="source-inline">CUSTOMER</strong> database should be rolled back <a id="_idIndexMarker093"/>using <span class="No-Break">saga patterns.</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B18934_02_10.jpg" alt="Figure 2.10: Compensating transactions for registering new customer information and placing an order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: Compensating transactions for registering new customer information and placing an order</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Summary</h1>
			<p>In this chapter, we were able to go over the main steps of refactoring a monolith into an MSA, the steps necessary, the main things to consider, and the methodology of doing so. The simplified ABC-Monolith system was a good example; however, as systems get more complicated and the workflow gets more involved, data and process synchronization challenges start <span class="No-Break">to arise.</span></p>
			<p>In <a href="B18934_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, we briefly discussed the challenges and the methodologies to be applied to overcome these challenges. In the next chapter, we will start applying the methodology to the ABC system we are trying <span class="No-Break">to refactor.</span></p>
			<p>In the next chapter, we will discuss how we can further maintain microservices’ autonomy and MSA stability and overcome some other operational challenges, and the role of API gateways, orchestrators, and <span class="No-Break">microservice aggregators.</span></p>
</body></html>