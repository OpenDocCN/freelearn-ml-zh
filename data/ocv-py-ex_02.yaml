- en: Chapter 2. Detecting Edges and Applying Image Filters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.检测边缘和应用图像滤波器
- en: In this chapter, we are going to see how to apply cool visual effects to images.
    We will learn how to use fundamental image processing operators. We are going
    to discuss edge detection and how we can use image filters to apply various effects
    on photos.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何将酷炫的视觉效果应用于图像。我们将学习如何使用基本的图像处理算子。我们将讨论边缘检测以及我们如何可以使用图像滤波器在照片上应用各种效果。
- en: 'By the end of this chapter, you will know:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解：
- en: What is 2D convolution and how to use it
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是2D卷积以及如何使用它
- en: How to blur an image
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何模糊图像
- en: How to detect edges in an image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在图像中检测边缘
- en: How to apply motion blur to an image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何给图像应用运动模糊
- en: How to sharpen and emboss an image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何锐化和浮雕图像
- en: How to erode and dilate an image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何腐蚀和膨胀图像
- en: How to create a vignette filter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建晕影滤镜
- en: How to enhance image contrast
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何增强图像对比度
- en: Tip
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 2D convolution
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D卷积
- en: Convolution is a fundamental operation in image processing. We basically apply
    a mathematical operator to each pixel and change its value in some way. To apply
    this mathematical operator, we use another matrix called a **kernel**. The kernel
    is usually much smaller in size than the input image. For each pixel in the image,
    we take the kernel and place it on top such that the center of the kernel coincides
    with the pixel under consideration. We then multiply each value in the kernel
    matrix with the corresponding values in the image, and then sum it up. This is
    the new value that will be substituted in this position in the output image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积是图像处理中的一个基本操作。我们基本上将一个数学算子应用于每个像素，并以某种方式改变其值。要应用这个数学算子，我们使用另一个称为**内核**的矩阵。内核通常比输入图像小得多。对于图像中的每个像素，我们取内核并将其放置在上面，使得内核的中心与正在考虑的像素重合。然后我们将内核矩阵中的每个值与图像中相应的值相乘，然后求和。这就是将在输出图像的这个位置替换的新值。
- en: 'Here, the kernel is called the "image filter" and the process of applying this
    kernel to the given image is called "image filtering". The output obtained after
    applying the kernel to the image is called the filtered image. Depending on the
    values in the kernel, it performs different functions like blurring, detecting
    edges, and so on. The following figure should help you visualize the image filtering
    operation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内核被称为“图像滤波器”，将此内核应用于给定图像的过程称为“图像滤波”。将内核应用于图像后获得的结果称为滤波图像。根据内核中的值，它执行不同的功能，如模糊、检测边缘等。以下图应有助于您可视化图像滤波操作：
- en: '![2D convolution](img/B04554_02_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![2D卷积](img/B04554_02_01.jpg)'
- en: 'Let''s start with the simplest case which is identity kernel. This kernel doesn''t
    really change the input image. If we consider a 3x3 identity kernel, it looks
    something like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的情况开始，即单位内核。这个内核实际上并不会改变输入图像。如果我们考虑一个3x3的单位内核，它看起来就像以下这样：
- en: '![2D convolution](img/B04554_02_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![2D卷积](img/B04554_02_02.jpg)'
- en: Blurring
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊
- en: Blurring refers to averaging the pixel values within a neighborhood. This is
    also called a **low pass filter**. A low pass filter is a filter that allows low
    frequencies and blocks higher frequencies. Now, the next question that comes to
    our mind is—What does "frequency" mean in an image? Well, in this context, frequency
    refers to the rate of change of pixel values. So we can say that the sharp edges
    would be high frequency content because the pixel values change rapidly in that
    region. Going by that logic, plain areas would be low frequency content. Going
    by this definition, a low pass filter would try to smoothen the edges.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊是指在一个邻域内平均像素值。这也称为**低通滤波器**。低通滤波器是一种允许低频并阻止高频的滤波器。现在，接下来我们可能会想到的问题是——在图像中“频率”是什么意思？嗯，在这个上下文中，频率指的是像素值变化的速率。因此，我们可以说，锐利的边缘会是高频内容，因为在这个区域的像素值变化很快。按照这个逻辑，平面区域会是低频内容。按照这个定义，低通滤波器会尝试平滑边缘。
- en: 'A simple way to build a low pass filter is by uniformly averaging the values
    in the neighborhood of a pixel. We can choose the size of the kernel depending
    on how much we want to smoothen the image, and it will correspondingly have different
    effects. If you choose a bigger size, then you will be averaging over a larger
    area. This tends to increase the smoothening effect. Let''s see what a 3x3 low
    pass filter kernel looks like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 构建低通滤波器的一个简单方法是均匀平均像素邻域内的值。我们可以根据我们想要平滑图像的程度来选择核的大小，它将相应地产生不同的效果。如果你选择更大的尺寸，那么你将在更大的区域内进行平均。这通常会增强平滑效果。让我们看看3x3低通滤波器核的样子：
- en: '![Blurring](img/B04554_02_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![模糊](img/B04554_02_03.jpg)'
- en: We are dividing the matrix by 9 because we want the values to sum up to `1`.
    This is called **normalization**, and it's important because we don't want to
    artificially increase the intensity value at that pixel's location. So you should
    normalize the kernel before applying it to an image. Normalization is a really
    important concept, and it is used in a variety of scenarios, so you should read
    a couple of tutorials online to get a good grasp on it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将矩阵除以9，因为我们希望值加起来等于`1`。这被称为**归一化**，它很重要，因为我们不希望人为地增加该像素位置的强度值。所以你应该在将核应用到图像之前进行归一化。归一化是一个非常重要的概念，它在各种场景中使用，所以你应该在网上阅读一些教程，以获得对它的良好理解。
- en: 'Here is the code to apply this low pass filter to an image:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是应用低通滤波器到图像的代码：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run the preceding code, you will see something like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会看到类似这样的结果：
- en: '![Blurring](img/B04554_02_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![模糊](img/B04554_02_04.jpg)'
- en: The size of the kernel versus the blurriness
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核大小与模糊程度的关系
- en: In the preceding code, we are generating different kernels in the code which
    are `kernel_identity`, `kernel_3x3`, and `kernel_5x5`. We use the function, `filter2D`,
    to apply these kernels to the input image. If you look at the images carefully,
    you can see that they keep getting blurrier as we increase the kernel size. The
    reason for this is because when we increase the kernel size, we are averaging
    over a larger area. This tends to have a larger blurring effect.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们生成了不同的核，分别是`kernel_identity`、`kernel_3x3`和`kernel_5x5`。我们使用`filter2D`函数将这些核应用到输入图像上。如果你仔细观察图像，你会发现随着核大小的增加，图像变得越来越模糊。这是因为当我们增加核大小时，我们是在更大的区域内进行平均。这通常会带来更大的模糊效果。
- en: 'An alternative way of doing this would be by using the OpenCV function, `blur`.
    If you don''t want to generate the kernels yourself, you can just use this function
    directly. We can call it using the following line of code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式是使用OpenCV的`blur`函数。如果你不想自己生成核，可以直接使用这个函数。我们可以用以下代码行来调用它：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will apply the 3x3 kernel to the input and give you the output directly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接应用3x3核并给出输出。
- en: Edge detection
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘检测
- en: The process of edge detection involves detecting sharp edges in the image and
    producing a binary image as the output. Typically, we draw white lines on a black
    background to indicate those edges. We can think of edge detection as a high pass
    filtering operation. A high pass filter allows high frequency content to pass
    through and blocks the low frequency content. As we discussed earlier, edges are
    high frequency content. In edge detection, we want to retain these edges and discard
    everything else. Hence, we should build a kernel that is the equivalent of a high
    pass filter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘检测的过程涉及检测图像中的尖锐边缘，并生成一个二值图像作为输出。通常，我们在黑色背景上画白色线条来指示这些边缘。我们可以将边缘检测视为高通滤波操作。高通滤波器允许高频内容通过并阻止低频内容。正如我们之前讨论的，边缘是高频内容。在边缘检测中，我们希望保留这些边缘并丢弃其他所有内容。因此，我们应该构建一个相当于高通滤波器的核。
- en: 'Let''s start with a simple edge detection filter known as the `Sobel` filter.
    Since edges can occur in both horizontal and vertical directions, the `Sobel`
    filter is composed of the following two kernels:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一种简单的边缘检测滤波器开始，称为`Sobel`滤波器。由于边缘可以出现在水平和垂直方向，`Sobel`滤波器由以下两个核组成：
- en: '![Edge detection](img/B04554_02_05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![边缘检测](img/B04554_02_05.jpg)'
- en: 'The kernel on the left detects horizontal edges and the kernel on the right
    detects vertical edges. OpenCV provides a function to directly apply the `Sobel`
    filter to a given image. Here is the code to use Sobel filters to detect edges:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的核检测水平边缘，右侧的核检测垂直边缘。OpenCV提供了一个函数可以直接将`Sobel`滤波器应用到给定的图像上。以下是使用Sobel滤波器检测边缘的代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output will look something like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像以下这样：
- en: '![Edge detection](img/B04554_02_06.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![边缘检测](img/B04554_02_06.jpg)'
- en: 'In the preceding figure, the image in the middle is the output of horizontal
    edge detector, and the image on the right is the vertical edge detector. As we
    can see here, the `Sobel` filter detects edges in either a horizontal or vertical
    direction and it doesn''t give us a holistic view of all the edges. To overcome
    this, we can use the `Laplacian` filter. The advantage of using this filter is
    that it uses double derivative in both directions. You can call the function using
    the following line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，中间的图像是水平边缘检测器的输出，右边的图像是垂直边缘检测器的输出。如上图所示，`Sobel`滤波器可以在水平和垂直方向检测边缘，但它不会给我们一个所有边缘的整体视图。为了克服这个问题，我们可以使用`Laplacian`滤波器。使用这个滤波器的优点是它在两个方向上都使用双重导数。你可以使用以下行来调用该函数：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output will look something like the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像以下截图：
- en: '![Edge detection](img/B04554_02_07.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![边缘检测](img/B04554_02_07.jpg)'
- en: 'Even though the `Laplacian` kernel worked great in this case, it doesn''t always
    work well. It gives rise to a lot of noise in the output, as shown in the screenshot
    that follows. This is where the `Canny edge` detector comes in handy:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个情况下`Laplacian`核工作得很好，但它并不总是有效。它会在输出中产生很多噪声，如下面的截图所示。这就是`Canny边缘检测器`派上用场的地方：
- en: '![Edge detection](img/B04554_02_08.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![边缘检测](img/B04554_02_08.jpg)'
- en: 'As we can see in the above images, the `Laplacian` kernel gives rise to a noisy
    output and this is not exactly useful. To overcome this problem, we use the `Canny
    edge` detector. To use the `Canny edge` detector, we can use the following function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，`Laplacian`核会产生噪声输出，这并不完全有用。为了克服这个问题，我们使用`Canny边缘检测器`。要使用`Canny边缘检测器`，我们可以使用以下函数：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, the quality of the Canny edge detector is much better. It takes
    two numbers as arguments to indicate the thresholds. The second argument is called
    the low threshold value, and the third argument is called the high threshold value.
    If the gradient value is above the high threshold value, it is marked as a strong
    edge. The Canny Edge Detector starts tracking the edge from this point and continues
    the process until the gradient value falls below the low threshold value. As you
    increase these thresholds, the weaker edges will be ignored. The output image
    will be cleaner and sparser. You can play around with the thresholds and see what
    happens as you increase or decrease their values. The overall formulation is quite
    deep. You can learn more about it at [http://www.intelligence.tuc.gr/~petrakis/courses/computervision/canny.pdf](http://www.intelligence.tuc.gr/~petrakis/courses/computervision/canny.pdf)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，Canny边缘检测器的质量要好得多。它接受两个数字作为参数来指示阈值。第二个参数被称为低阈值，第三个参数被称为高阈值。如果梯度值高于高阈值，它会被标记为强边缘。Canny边缘检测器从这个点开始跟踪边缘，并继续这个过程，直到梯度值低于低阈值。当你增加这些阈值时，较弱的边缘将被忽略。输出图像将更干净、更稀疏。你可以调整阈值并观察当增加或减少它们的值时会发生什么。整体公式相当复杂。你可以在[http://www.intelligence.tuc.gr/~petrakis/courses/computervision/canny.pdf](http://www.intelligence.tuc.gr/~petrakis/courses/computervision/canny.pdf)了解更多信息。
- en: Motion blur
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运动模糊
- en: When we apply the motion blurring effect, it will look like you captured the
    picture while moving in a particular direction. For example, you can make an image
    look like it was captured from a moving car.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用运动模糊效果时，它看起来就像你在特定方向上移动时捕捉到了图片。例如，你可以让图片看起来像是从一个移动的汽车上捕捉到的。
- en: 'The input and output images will look like the following ones:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出图像将看起来像以下这些：
- en: '![Motion blur](img/B04554_02_09.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![运动模糊](img/B04554_02_09.jpg)'
- en: 'Following is the code to achieve this motion blurring effect:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现这种运动模糊效果的代码：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Under the hood
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部结构
- en: 'We are reading the image as usual. We are then constructing a motion `blur`
    kernel. A motion blur kernel averages the pixel values in a particular direction.
    It''s like a directional low pass filter. A 3x3 horizontal motion-blurring kernel
    would look this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样读取图像。然后我们构建一个运动`模糊`核。一个运动模糊核会在特定方向上平均像素值。它就像一个方向性低通滤波器。一个3x3水平运动模糊核看起来是这样的：
- en: '![Under the hood](img/B04554_02_10.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![内部结构](img/B04554_02_10.jpg)'
- en: This will blur the image in a horizontal direction. You can pick any direction
    and it will work accordingly. The amount of blurring will depend on the size of
    the kernel. So, if you want to make the image blurrier, just pick a bigger size
    for the kernel. To see the full effect, we have taken a 15x15 kernel in the preceding
    code. We then use `filter2D` to apply this kernel to the input image, to obtain
    the motion-blurred output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在水平方向上模糊图像。您可以选择任何方向，它都会相应地工作。模糊的程度将取决于核的大小。因此，如果您想使图像更模糊，只需为核选择更大的尺寸。为了看到完整的效果，我们在前面的代码中使用了15x15的核。然后我们使用`filter2D`将这个核应用到输入图像上，以获得运动模糊的输出。
- en: Sharpening
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锐化
- en: 'Applying the `sharpening` filter will sharpen the edges in the image. This
    filter is very useful when we want to enhance the edges in an image that''s not
    crisp. Here are some images to give you an idea of what the image `sharpening`
    process looks like:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应用`锐化`滤镜将增强图像中的边缘。当我们需要增强不清晰的图像边缘时，这个滤镜非常有用。以下是一些图像，以供您了解图像`锐化`过程的外观：
- en: '![Sharpening](img/B04554_02_11.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![锐化](img/B04554_02_11.jpg)'
- en: 'As you can see in the preceding figure, the level of sharpening depends on
    the type of kernel we use. We have a lot of freedom to customize the kernel here,
    and each kernel will give you a different kind of sharpening. To just sharpen
    an image, like we are doing in the top right image in the preceding picture, we
    would use a kernel like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，锐化的程度取决于我们使用的核的类型。在这里，我们有很大的自由度来自定义核，每个核都会给您带来不同类型的锐化。如果我们只想锐化图像，就像我们在前一张图片的右上角所做的那样，我们会使用这样的核：
- en: '![Sharpening](img/B04554_02_12.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![锐化](img/B04554_02_12.jpg)'
- en: 'If we want to do excessive sharpening, like in the bottom left image, we would
    use the following kernel:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要进行过度的锐化，就像左下角的图像那样，我们会使用以下核：
- en: '![Sharpening](img/B04554_02_13.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![锐化](img/B04554_02_13.jpg)'
- en: But the problem with these two kernels is that the output image looks artificially
    enhanced. If we want our images to look more natural, we would use an `Edge Enhancement`
    filter. The underlying concept remains the same, but we use an approximate Gaussian
    kernel to build this filter. It will help us smoothen the image when we enhance
    the edges, thus making the image look more natural.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但这两个核的问题在于输出图像看起来经过了人工增强。如果我们想让我们的图像看起来更自然，我们会使用`边缘增强`滤镜。基本概念保持不变，但我们使用一个近似高斯核来构建这个滤镜。当我们增强边缘时，这将帮助我们平滑图像，从而使图像看起来更自然。
- en: 'Here is the code to achieve the effects applied in the preceding screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现前面截图中应用效果的代码：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you noticed, in the preceding code, we didn't divide the first two kernels
    by a normalizing factor. The reason is because the values inside the kernel already
    sum up to 1, so we are implicitly dividing the matrices by 1.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到了，在前面的代码中，我们没有将前两个核除以归一化因子。原因是核内的值已经总和为1，所以我们隐式地将矩阵除以1。
- en: Understanding the pattern
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模式
- en: You must have noticed a common pattern in image filtering code examples. We
    build a kernel and then use `filter2D` to get the desired output. That's exactly
    what's happening in this code example as well! You can play around with the values
    inside the kernel and see if you can get different visual effects. Make sure that
    you normalize the kernel before applying it, or else the image will look too bright
    because you are artificially increasing the pixel values in the image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定注意到了图像滤波代码示例中的常见模式。我们构建一个核，然后使用`filter2D`来获取所需的输出。这正是这个代码示例中发生的事情！您可以尝试调整核内的值，看看是否能得到不同的视觉效果。确保在应用核之前对其进行归一化，否则图像会看起来太亮，因为您正在人为地增加图像中的像素值。
- en: Embossing
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮雕
- en: An embossing filter will take an image and convert it into an embossed image.
    We basically take each pixel and replace it with a shadow or a highlight. Let's
    say we are dealing with a relatively plain region in the image. Here, we need
    to replace it with plain gray color because there's not much information there.
    If there is a lot of contrast in a particular region, we will replace it with
    a white pixel (highlight), or a dark pixel (shadow), depending on the direction
    in which we are embossing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 浮雕滤镜会将图像转换为浮雕图像。我们基本上是将每个像素替换为阴影或高光。比如说我们处理图像中的一个相对平坦的区域。在这里，我们需要用纯灰色替换它，因为那里没有太多信息。如果某个区域有很高的对比度，我们将用白色像素（高光）或黑色像素（阴影）替换它，具体取决于我们浮雕的方向。
- en: 'This is what it will look like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子：
- en: '![Embossing](img/B04554_02_14.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![浮雕](img/B04554_02_14.jpg)'
- en: 'Let''s take a look at the code and see how to do this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，看看如何做到这一点：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you run the preceding code, you will see that the output images are embossed.
    As we can see from the kernels above, we are just replacing the current pixel
    value with the difference of the neighboring pixel values in a particular direction.
    The embossing effect is achieved by offsetting all the pixel values in the image
    by `128`. This operation adds the highlight/shadow effect to the picture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会看到输出图像是浮雕的。正如我们可以从上面的核中看到的那样，我们只是在特定方向上用相邻像素值的差值替换当前像素值。浮雕效果是通过将图像中所有像素值偏移
    `128` 来实现的。这个操作为图片添加了高光/阴影效果。
- en: Erosion and dilation
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 腐蚀和膨胀
- en: '**Erosion** and **dilation** are morphological image processing operations.
    Morphological image processing basically deals with modifying geometric structures
    in the image. These operations are primarily defined for binary images, but we
    can also use them on grayscale images. Erosion basically strips out the outermost
    layer of pixels in a structure, where as dilation adds an extra layer of pixels
    on a structure.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**腐蚀** 和 **膨胀** 是形态学图像处理操作。形态学图像处理基本上处理图像中的几何结构修改。这些操作主要定义用于二值图像，但我们也可以在灰度图像上使用它们。腐蚀基本上移除了结构的最外层像素，而膨胀则在结构上添加了一层额外的像素。'
- en: 'Let''s see what these operations look like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些操作看起来像什么：
- en: '![Erosion and dilation](img/B04554_02_15.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![腐蚀和膨胀](img/B04554_02_15.jpg)'
- en: 'Following is the code to achieve this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现这个效果的代码：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Afterthought
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反思
- en: OpenCV provides functions to directly erode and dilate an image. They are called
    erode and dilate, respectively. The interesting thing to note is the third argument
    in these two functions. The number of iterations will determine how much you want
    to erode/dilate a given image. It basically applies the operation successively
    to the resultant image. You can take a sample image and play around with this
    parameter to see what the results look like.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 提供了直接腐蚀和膨胀图像的函数。它们分别称为 `erode` 和 `dilate`。值得注意的是这两个函数的第三个参数。迭代次数将决定你想要腐蚀/膨胀给定图像的程度。它基本上将操作连续应用于结果图像。你可以取一个样本图像并调整这个参数，看看结果如何。
- en: Creating a vignette filter
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 vignette 滤镜
- en: 'Using all the information we have, let''s see if we can create a nice `vignette`
    filter. The output will look something like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们所拥有的所有信息，让我们看看是否可以创建一个漂亮的 `vignette` 滤镜。输出将看起来像以下这样：
- en: '![Creating a vignette filter](img/B04554_02_16.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![创建 vignette 滤镜](img/B04554_02_16.jpg)'
- en: 'Here is the code to achieve this effect:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现这个效果的代码：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What's happening underneath?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下面到底发生了什么？
- en: The `Vignette` filter basically focuses the brightness on a particular part
    of the image and the other parts look faded. In order to achieve this, we need
    to filter out each channel in the image using a Gaussian kernel. OpenCV provides
    a function to do this, which is called `getGaussianKernel`. We need to build a
    2D kernel whose size matches the size of the image. The second parameter of the
    function, `getGaussianKernel`, is interesting. It is the standard deviation of
    the Gaussian and it controls the radius of the bright central region. You can
    play around with this parameter and see how it affects the output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vignette` 滤镜基本上将亮度集中在图像的特定部分，而其他部分看起来则变得模糊。为了实现这一点，我们需要使用高斯核对图像中的每个通道进行过滤。OpenCV
    提供了一个执行此操作的函数，称为 `getGaussianKernel`。我们需要构建一个与图像大小匹配的 2D 核。函数 `getGaussianKernel`
    的第二个参数很有趣。它是高斯的标准差，它控制着明亮中心区域的半径。你可以调整这个参数，看看它如何影响输出。'
- en: 'Once we build the 2D kernel, we need to build a mask by normalizing this kernel
    and scaling it up, as shown in the following line:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了 2D 核，我们需要通过归一化这个核并放大它来构建一个掩码，如下面的行所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is an important step because if you don't scale it up, the image will look
    black. This happens because all the pixel values will be close to `0` after you
    superimpose the mask on the input image. After this, we iterate through all the
    color channels and apply the mask to each channel.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的步骤，因为如果你不放大它，图像将看起来是黑色的。这是因为在你将掩码叠加到输入图像上之后，所有像素值都会接近 `0`。之后，我们遍历所有颜色通道，并将掩码应用于每个通道。
- en: How do we move the focus around?
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何移动焦点？
- en: 'We now know how to create a `vignette` filter that focuses on the center of
    the image. Let''s say we want to achieve the same `vignette` effect, but we want
    to focus on a different region in the image, as shown in the following figure:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何创建一个聚焦于图像中心的`vignette`滤镜。假设我们想要达到相同的`vignette`效果，但我们想聚焦于图像中的不同区域，如图所示：
- en: '![How do we move the focus around?](img/B04554_02_17.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![我们如何移动焦点？](img/B04554_02_17.jpg)'
- en: 'All we need to do is build a bigger Gaussian kernel and make sure that the
    peak coincides with the region of interest. Following is the code to achieve this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是构建一个更大的高斯核，并确保峰值与感兴趣的区域相吻合。以下是实现这一目标的代码：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Enhancing the contrast in an image
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强图像的对比度
- en: Whenever we capture images in low-light conditions, the images turn out to be
    dark. This typically happens when you capture images in the evening or in a dimly
    lit room. You must have seen this happen many times! The reason this happens is
    because the pixel values tend to concentrate near 0 when we capture the images
    under such conditions. When this happens, a lot of details in the image are not
    clearly visible to the human eye. The human eye likes contrast, and so we need
    to adjust the contrast to make the image look nice and pleasant. A lot of cameras
    and photo applications implicitly do this already. We use a process called **Histogram
    Equalization** to achieve this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们在低光条件下捕捉图像，图像都会变得很暗。这通常发生在你在傍晚或昏暗的房间里捕捉图像时。你肯定见过这种情况发生很多次！这种情况发生的原因是因为在这种情况下捕捉图像时，像素值往往会集中在0附近。当这种情况发生时，图像中的许多细节对肉眼来说并不清晰可见。人眼喜欢对比度，因此我们需要调整对比度，使图像看起来更美观、更愉快。许多相机和照片应用程序已经隐式地做了这件事。我们使用一个称为**直方图均衡化**的过程来实现这一点。
- en: 'To give an example, this is what it looks like before and after contrast enhancement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，这是对比度增强前后的图像外观：
- en: '![Enhancing the contrast in an image](img/B04554_02_18.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![增强图像的对比度](img/B04554_02_18.jpg)'
- en: As we can see here, the input image on the left is really dark. To rectify this,
    we need to adjust the pixel values so that they are spread across the entire spectrum
    of values, that is, between 0 and `255`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如此可见，左侧的输入图像非常暗。为了纠正这一点，我们需要调整像素值，使它们分布在整个值谱上，即0到`255`之间。
- en: 'Following is the code for adjusting the pixel values:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为调整像素值而编写的代码：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Histogram equalization is applicable to grayscale images. OpenCV provides a
    function, `equalizeHist`, to achieve this effect. As we can see here, the code
    is pretty straightforward, where we read the image and equalize its histogram
    to adjust the contrast of the image.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图均衡化适用于灰度图像。OpenCV提供了一个名为`equalizeHist`的函数来实现这一效果。正如我们所见，代码相当简单，其中我们读取图像并均衡其直方图以调整图像的对比度。
- en: How do we handle color images?
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何处理彩色图像？
- en: Now that we know how to equalize the histogram of a grayscale image, you might
    be wondering how to handle color images. The thing about histogram equalization
    is that it's a nonlinear process. So, we cannot just separate out the three channels
    in an RGB image, equalize the histogram separately, and combine them later to
    form the output image. The concept of histogram equalization is only applicable
    to the intensity values in the image. So, we have to make sure not to modify the
    color information when we do this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何均衡灰度图像的直方图，你可能想知道如何处理彩色图像。关于直方图均衡化，它是一个非线性过程。因此，我们不能只是将RGB图像中的三个通道分开，分别均衡直方图，然后再将它们组合起来形成输出图像。直方图均衡化的概念仅适用于图像中的强度值。因此，我们必须确保在执行此操作时不要修改颜色信息。
- en: In order to handle the histogram equalization of color images, we need to convert
    it to a color space where intensity is separated from the color information. YUV
    is a good example of such a color space. Once we convert it to YUV, we just need
    to equalize the Y-channel and combine it with the other two channels to get the
    output image.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理彩色图像的直方图均衡化，我们需要将其转换为一种强度与颜色信息分离的颜色空间。YUV就是这样一种颜色空间。一旦我们将其转换为YUV，我们只需要均衡Y通道，并将其与其他两个通道组合起来以获得输出图像。
- en: 'Following is an example of what it looks like:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示其外观：
- en: '![How do we handle color images?](img/B04554_02_19.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![我们如何处理彩色图像？](img/B04554_02_19.jpg)'
- en: 'Here is the code to achieve histogram equalization for color images:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现彩色图像直方图均衡化的代码：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use image filters to apply cool visual effects
    to images. We discussed the fundamental image processing operators and how we
    can use them to build various things. We learnt how to detect edges using various
    methods. We understood the importance of 2D convolution and how we can use it
    in different scenarios. We discussed how to smoothen, motion-blur, sharpen, emboss,
    erode, and dilate an image. We learned how to create a vignette filter, and how
    we can change the region of focus as well. We discussed contrast enhancement and
    how we can use histogram equalization to achieve it. In the next chapter, we will
    discuss how to cartoonize a given image.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用图像过滤器将酷炫的视觉效果应用到图像上。我们讨论了基本的图像处理算子以及如何使用它们构建各种事物。我们学习了如何使用各种方法检测边缘。我们理解了二维卷积的重要性以及在不同场景中如何使用它。我们讨论了如何平滑、运动模糊、锐化、浮雕、腐蚀和膨胀图像。我们学习了如何创建晕影过滤器，以及如何改变焦点区域。我们讨论了对比度增强以及如何使用直方图均衡化来实现它。在下一章中，我们将讨论如何卡通化给定的图像。
