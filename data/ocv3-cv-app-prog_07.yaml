- en: Chapter 7. Extracting Lines, Contours, and Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 提取线条、轮廓和组件
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Detecting image contours with the Canny operator
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canny算子检测图像轮廓
- en: Detecting lines in images with the Hough transform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用霍夫变换检测图像中的线条
- en: Fitting a line to a set of points
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将直线拟合到一组点
- en: Extracting connected components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取连通组件
- en: Computing components' shape descriptors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算组件的形状描述符
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In order to perform content-based analysis of an image, it is necessary to extract
    meaningful features from the collection of pixels that constitute the image. Contours,
    lines, blobs, and so on, are fundamental image primitives that can be used to
    describe the elements contained in an image. This chapter will teach you how to
    extract some of these image primitives.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对图像进行基于内容的分析，有必要从构成图像的像素集合中提取有意义的特征。轮廓、线条、块等是基本图像原语，可以用来描述图像中包含的元素。本章将教会你如何提取这些图像原语中的一些。
- en: Detecting image contours with the Canny operator
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canny算子检测图像轮廓
- en: In the previous chapter, we learned how it is possible to detect the edges of
    an image. In particular, we showed you that by applying a threshold to the gradient
    magnitude, a binary map of the main edges of an image can be obtained. Edges carry
    important visual information since they delineate the image elements. For this
    reason, they can be used, for example, in object recognition. However, simple
    binary edge maps suffer from two main drawbacks. First, the edges that are detected
    are unnecessarily thick; this makes the object's limits more difficult to identify.
    Second, and more importantly, it is often impossible to find a threshold that
    is sufficiently low in order to detect all important edges of an image and is,
    at the same time, sufficiently high in order to not include too many insignificant
    edges. This is a trade-off problem that the **Canny** algorithm tries to solve.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何检测图像的边缘。特别是，我们向您展示了通过将梯度幅度应用于阈值，可以得到图像主要边缘的二值图。边缘携带重要的视觉信息，因为它们界定了图像元素。因此，它们可以用在物体识别中。然而，简单的二值边缘图有两个主要缺点。首先，检测到的边缘过于粗厚；这使得识别对象的边界更加困难。其次，更重要的是，通常很难找到一个足够低的阈值来检测图像的所有重要边缘，同时这个阈值又足够高，以避免包含太多不重要的边缘。这是一个权衡问题，Canny算法试图解决这个问题。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The Canny algorithm is implemented in OpenCV by the `cv::Canny` function. As
    will be explained, this algorithm requires the specification of two thresholds.
    The call to the function is, therefore, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Canny算法在OpenCV中通过`cv::Canny`函数实现。正如将解释的那样，此算法需要指定两个阈值。因此，函数调用如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s consider the following image:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图像：
- en: '![How to do it...](img/image_07_001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_07_001.jpg)'
- en: 'When the algorithm is applied on the preceding image, the result is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法应用于前述图像时，结果如下：
- en: '![How to do it...](img/image_07_002.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_07_002.jpg)'
- en: Note that here we have inverted the contour representation since the normal
    result represents contours by non-zero pixels. The displayed image is simply `255-contours`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们反转了轮廓表示，因为正常的结果是通过非零像素来表示轮廓的。显示的图像仅仅是`255-轮廓`。
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Canny operator is generally based on the Sobel operator that was presented
    in [Chapter 6](ch06.html "Chapter 6. Filtering the Images") , *Filtering the Images*,
    although other gradient operators can also be used. The key idea here is to use
    two different thresholds in order to determine which point should belong to a
    contour: a low and a high threshold.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Canny算子通常基于在第6章中介绍的Sobel算子，即*过滤图像*，尽管也可以使用其他梯度算子。这里的关键思想是使用两个不同的阈值来确定哪个点应属于轮廓：一个低阈值和一个高阈值。
- en: 'The low threshold should be chosen in a way that it includes all edge pixels
    that are considered to belong to a significant image contour. For example, using
    the low-threshold value specified in the example of the preceding section and
    applying it on the result of a Sobel operator, the following edge map is obtained:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 低阈值应选择得包括所有被认为是属于重要图像轮廓的边缘像素。例如，使用前一小节中指定的低阈值值，并将其应用于Sobel算子的结果，可以得到以下边缘图：
- en: '![How it works...](img/image_07_003.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/image_07_003.jpg)'
- en: 'As can be seen, the edges that delineate the road are very well defined. However,
    because a permissive threshold was used, more edges than what is ideally needed
    are also detected. The role of the second threshold, then, is to define the edges
    that belong to all important contours. It should exclude all edges considered
    as outliers. For example, the Sobel edge map that corresponds to the high threshold
    used in our example is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，界定道路的边缘非常清晰。然而，由于使用了宽容的阈值，也检测到了比理想情况下更多的边缘。因此，第二个阈值的作用是定义属于所有重要轮廓的边缘。它应该排除所有被认为是异常值的边缘。例如，对应于我们示例中使用的较高阈值的Sobel边缘图如下：
- en: '![How it works...](img/image_07_004.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/image_07_004.jpg)'
- en: We now have an image that contains broken edges, but the ones that are visible
    certainly belong to the significant contours of the scene. The Canny algorithm
    combines these two edge maps in order to produce an optimal map of contours. It
    operates by keeping only the edge points of the low-threshold edge map for which
    a continuous path of edges exists, linking those edge points to an edge that belongs
    to the high-threshold edge map. Consequently, all edge points of the high-threshold
    map are kept, while all isolated chains of edge points in the low-threshold map
    are removed. The solution that is obtained constitutes a good compromise, allowing
    good quality contours to be obtained as long as appropriate threshold values are
    specified. This strategy, based on the use of two thresholds to obtain a binary
    map, is called **hysteresis thresholding**, and can be used in any context where
    a binary map needs to be obtained from a thresholding operation. However, this
    is done at the cost of higher computational complexity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个包含断裂边缘的图像，但可见的边缘肯定属于场景的重要轮廓。Canny算法通过仅保留低阈值边缘图中存在连续边缘路径的边缘点，将这些边缘点连接到属于高阈值边缘图的边缘，将这两个边缘图结合起来以产生轮廓的最佳图。它通过仅保留高阈值图中的所有边缘点，同时移除低阈值图中的所有孤立边缘点链来实现。获得的解决方案是一个良好的折衷方案，只要指定了适当的阈值值，就可以获得高质量的轮廓。这种基于使用两个阈值来获得二值图的策略称为**滞后阈值化**，可以在任何需要从阈值化操作中获得二值图的环境中使用。然而，这是以更高的计算复杂度为代价的。
- en: In addition, the Canny algorithm uses an extra strategy to improve the quality
    of the edge map. Prior to the application of the hysteresis thresholding, all
    edge points for which the gradient magnitude is not a maximum in the gradient
    direction are removed (recall that the gradient orientation is always perpendicular
    to the edge). Therefore, the local maximum of the gradient in this direction corresponds
    to the point of maximum strength of the contour. This is a contour thinning operation
    that creates edges having a width of 1 pixel. This explains why thin edges are
    obtained in the Canny contour maps.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Canny算法采用额外策略来提高边缘图的质量。在应用阈值化之前，所有梯度方向上梯度幅度不是最大的边缘点都被移除（记住梯度方向始终垂直于边缘）。因此，这个方向上的梯度局部最大值对应于轮廓的最大强度点。这是一个轮廓细化操作，创建宽度为1像素的边缘。这也解释了为什么Canny轮廓图中会得到细边缘。
- en: See also
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The classic article by *J. Canny*, *A computational approach to edge detection,
    IEEE Transactions on Pattern Analysis and Image Understanding, vol. 18, issue
    6, 1986*
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*J. Canny*的经典文章，《一种边缘检测的计算方法》，IEEE Transactions on Pattern Analysis and Image
    Understanding，第18卷，第6期，1986年'
- en: Detecting lines in images with the Hough transform
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用霍夫变换检测图像中的直线
- en: In our human-made world, planar and linear structures abound. As a result, straight
    lines are frequently visible in images. These are meaningful features that play
    an important role in object recognition and image understanding. The **Hough transform**
    is a classic algorithm that is often used to detect these particular features
    in images. It was initially developed to detect lines in images and, as we will
    see, it can also be extended to detect other simple image structures.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们人造的世界中，平面和线性结构比比皆是。因此，直线在图像中经常可见。这些是有意义的特征，在物体识别和图像理解中起着重要作用。**霍夫变换**是一种经典算法，常用于检测图像中的这些特定特征。它最初是为了检测图像中的直线而开发的，正如我们将看到的，它还可以扩展到检测其他简单的图像结构。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'With the Hough transform, lines are represented using the following equation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用霍夫变换，直线用以下方程表示：
- en: '![Getting ready](img/image_07_005-2-300x54.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/image_07_005-2-300x54.jpg)'
- en: 'The `ρ` parameter is the distance between the line and the image origin (the
    upper-left corner), and `θ` is the angle of the perpendicular to the line. In
    this representation, the lines visible in an image have a `θ` angle between `0`
    and `π` radians, while the `ρ` radius can have a maximum value that equals the
    length of the image diagonal. Consider, for example, the following set of lines:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ρ`参数是线与图像原点（左上角）之间的距离，而`θ`是垂直于线的角度。在这种表示中，图像中可见的线的`θ`角度在`0`到`π`弧度之间，而`ρ`半径可以有一个最大值，等于图像对角线的长度。例如，考虑以下线条集：'
- en: '![Getting ready](img/image_07_006.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/image_07_006.jpg)'
- en: A vertical line such as line **1** has a `θ` angle value equal to zero, while
    a horizontal line (for example, line **5**) has its `θ` value equal to `π/2`.
    Therefore, line **3** has an angle `θ` equal to `π/4`, and line **4** is at `0.7π`
    approximately. In order to be able to represent all possible lines with `θ` in
    the `[0, π]` interval, the radius value can be made negative. This is the case
    with line **2**, which has a `θ` value equal to `0.8π` with a negative value for
    `ρ`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直线（例如，线**1**）的`θ`角度值等于零，而水平线（例如，线**5**）的`θ`值等于`π/2`。因此，线**3**的`θ`角度等于`π/4`，线**4**大约在`0.7π`。为了能够用`θ`在`[0,
    π]`区间内表示所有可能的线，可以将半径值设为负。这就是线**2**的情况，其`θ`值等于`0.8π`，而`ρ`的值为负。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'OpenCV offers two implementations of the Hough transform for line detection.
    The basic version is `cv::HoughLines`. Its input is a binary map that contains
    a set of points (represented by non-zero pixels), some of which are aligned to
    form lines. Usually, this is an edge map obtained, for example, from the Canny
    operator. The output of the `cv::HoughLines` function is a vector of `cv::Vec2f`
    elements, each of them being a pair of floating point values, representing the
    parameters of a detected line, `(ρ,θ)`. The following is an example of using this
    function where we first apply the Canny operator to obtain the image contours
    and then detect the lines using the Hough transform:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV为线检测提供了两种Hough变换的实现。基本版本是`cv::HoughLines`。它的输入是一个包含一组点（由非零像素表示）的二值图，其中一些点排列成线。通常，这是从Canny算子获得的边缘图。`cv::HoughLines`函数的输出是一个`cv::Vec2f`元素的向量，每个元素都是一对浮点值，表示检测到的线的参数，`(ρ,θ)`。以下是一个使用此函数的示例，我们首先应用Canny算子以获得图像轮廓，然后使用Hough变换检测线：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Parameters 3 and 4 correspond to the step size for the line search. In our
    example, the function will search for lines of all possible radii by steps of
    `1` and all possible angles by steps of `π/180`. The role of the last parameter
    will be explained in the next section. With this particular choice of parameter
    values, several lines are detected on the road image of the preceding recipe.
    In order to visualize the result of the detection, it is interesting to draw these
    lines on the original image. However, it is important to note that this algorithm
    detects lines in an image and not line segments, since the endpoints of each line
    are not given. Consequently, we will draw lines that traverse the entire image.
    To do this, for a vertically oriented line, we calculate its intersection with
    the horizontal limits of the image (that is, the first and last rows) and draw
    a line between these two points. We proceed similarly with horizontally-oriented
    lines but using the first and last columns. Lines are drawn using the `cv::line`
    function. Note that this function works well even with point coordinates outside
    the image limits. Therefore, there is no need to check whether the computed intersection
    points fall within the image. Lines are then drawn by iterating over the line
    vector as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参数3和4对应于线搜索的步长。在我们的例子中，函数将通过步长`1`搜索所有可能的半径的线，并通过步长`π/180`搜索所有可能的角。最后一个参数的作用将在下一节中解释。使用这种特定的参数值选择，在先前的食谱中的道路图像上检测到几条线。为了可视化检测的结果，有趣的是将这些线绘制在原始图像上。然而，重要的是要注意，此算法检测图像中的线而不是线段，因为每条线的端点没有给出。因此，我们将绘制穿过整个图像的线。为此，对于垂直方向的线，我们计算它与图像水平极限（即第一行和最后一行）的交点，并在这两个点之间绘制一条线。我们以类似的方式处理水平方向的线，但使用第一列和最后一列。使用`cv::line`函数绘制线。请注意，即使点坐标在图像极限之外，此函数也能很好地工作。因此，没有必要检查计算出的交点是否在图像内。然后通过以下方式迭代线向量来绘制线：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following result is obtained:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果得到：
- en: '![How to do it...](img/image_07_007.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_07_007.jpg)'
- en: As can be seen, the Hough transform simply looks for an alignment of edge pixels
    across the image. This can potentially create some false detections due to incidental
    pixel alignments or multiple detections when several lines with slightly different
    parameter values pass through the same alignment of pixels.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，霍夫变换只是简单地寻找图像中边缘像素的对齐。这可能会由于偶然的像素对齐或当几条参数值略有不同的线通过相同的像素对齐时，可能会产生一些误检。
- en: 'To overcome some of these problems, and to allow line segments to be detected
    (that is, with endpoints), a variant of the transform has been proposed. This
    is the Probabilistic Hough transform, and it is implemented in OpenCV as the `cv::HoughLinesP`
    function. We use it here to create our `LineFinder` class, which encapsulates
    the function parameters:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，并允许检测到线段（即带有端点），已经提出了一种变换的变体。这就是概率霍夫变换，它在 OpenCV 中作为 `cv::HoughLinesP`
    函数实现。我们在这里使用它来创建我们的 `LineFinder` 类，该类封装了函数参数：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Take a look at the corresponding setter methods:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下相应的设置方法：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the preceding method, the method that performs Hough line segment detection
    is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的方法，执行霍夫线段检测的方法如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This method returns a vector of `cv::Vec4i`, which contains the start and endpoint
    coordinates of each detected segment. The detected lines can then be drawn on
    an image with the following method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个 `cv::Vec4i` 向量，其中包含每个检测到的线段的起点和终点坐标。然后可以使用以下方法在图像上绘制检测到的线：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, using the same input image, lines can be detected with the following sequence:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用相同的输入图像，可以使用以下序列检测线：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code gives the following result:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给出了以下结果：
- en: '![How to do it...](img/image_07_008.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_07_008.jpg)'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The objective of the Hough transform is to find all lines in a binary image
    that pass through a sufficient number of points. It proceeds by considering each
    individual pixel point in the input binary map and identifying all possible lines
    that pass through it. When the same line passes through many points, it means
    that this line is significant enough to be considered.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 霍夫变换的目标是在二值图像中找到所有通过足够多点的线。它通过考虑输入二值映射中的每个单独的像素点并识别所有通过它的可能线来进行。当相同的线通过许多点时，这意味着这条线足够重要，值得考虑。
- en: 'The Hough transform uses a two-dimensional accumulator in order to count how
    many times a given line is identified. The size of this accumulator is defined
    by the specified step sizes (as mentioned in the preceding section) of the `(ρ,θ)`
    parameters of the adopted line representation. To illustrate the functioning of
    the transform, let''s create a `180` by `200` matrix (corresponding to a step
    size of `π/180` for `θ` and `1` for `ρ`):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 霍夫变换使用一个二维累加器来计数给定线被识别的次数。这个累加器的大小由指定的步长（如前所述）定义的 `(ρ,θ)` 参数的线表示法。为了说明变换的工作原理，让我们创建一个
    `180` 行 `200` 列的矩阵（对应于 `θ` 的步长为 `π/180`，`ρ` 的步长为 `1`）：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This accumulator is a mapping of different `(ρ,θ)` values. Therefore, each
    entry of this matrix corresponds to one particular line. Now, if we consider one
    point, let''s say one at `(50,30)`, then it is possible to identify all lines
    that pass through this point by looping over all possible `θ` angles (with a step
    size of `π/180`) and computing the corresponding (rounded) `ρ` value:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个累加器是不同 `(ρ,θ)` 值的映射。因此，这个矩阵的每个条目对应一条特定的线。现在，如果我们考虑一个点，比如说 `(50,30)`，那么通过遍历所有可能的
    `θ` 角度（步长为 `π/180`）并计算相应的（四舍五入的）`ρ` 值，就可以识别通过这个点的所有线：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The entries of the accumulator corresponding to the computed `(ρ,θ)` pairs
    are then incremented, signifying that all of these lines pass through one point
    of the image (or, to say it another way, each point votes for a set of possible
    candidate lines). If we display the accumulator as an image (inverted and multiplied
    by `100` to make the count of `1` visible), we obtain the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器中对应于计算出的 `(ρ,θ)` 对的条目随后被增加，这表示所有这些线都通过图像的一个点（或者说，换一种说法，每个点为一系列可能的候选线投票）。如果我们以图像的形式显示累加器（反转并乘以
    `100` 以使 `1` 的计数可见），我们得到以下结果：
- en: '![How it works...](img/image_07_009.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/image_07_009.jpg)'
- en: 'The preceding curve represents the set of all lines that pass through the specified
    point. Now, if we repeat the same exercise with, let''s say, point `(30,10)`,
    we now have the following accumulator:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的曲线表示通过指定点的所有直线的集合。现在，如果我们用，比如说，点 `(30,10)` 重复相同的练习，我们现在有以下累加器：
- en: '![How it works...](img/image_07_010.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/image_07_010.jpg)'
- en: 'As can be seen, the two resulting curves intersect at one point: the point
    that corresponds to the line that passes through these two points. The corresponding
    entry of the accumulator receives two votes, indicating that two points pass through
    this line.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，两个结果曲线在一点相交：对应于通过这两个点的直线的点。累加器的相应条目接收两个投票，表示有两个点通过这条线。
- en: If the same process is repeated for all points of a binary map, then points
    aligned along a given line will increase a common entry of the accumulator many
    times. At the end, you just need to identify the local maxima in this accumulator
    that receives a significant number of votes in order to detect the lines (that
    is, point alignments) in the image. The last parameter specified in the `cv::HoughLines`
    function corresponds to the minimum number of votes that a line must receive to
    be considered as detected. This means that the lower this minimum number of votes
    is, then the higher the number of detected lines will be.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对二进制地图的所有点重复相同的过程，那么沿着给定直线对齐的点将多次增加累加器的公共条目。最后，你只需要识别这个累加器中接收了大量投票的局部极大值，以检测图像中的线条（即点对齐）。`cv::HoughLines`
    函数中指定的最后一个参数对应于线条必须接收的最小投票数才能被认为是检测到的。这意味着这个最小投票数越低，检测到的线条数量就越多。
- en: 'For example, if we lower this value to `50` in the case of our road example,
    then the following lines are now detected:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将这个值降低到 `50`，在我们的道路示例中，那么现在检测到的以下线条：
- en: '![How it works...](img/image_07_011.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/image_07_011.jpg)'
- en: The Probabilistic Hough transform adds a few modifications to the basic algorithm.
    First, instead of systematically scanning the image row-by-row, points are chosen
    in random order in the binary map. Whenever an entry of the accumulator reaches
    the specified minimum value, the image is scanned along the corresponding line
    and all points that pass through it are removed (even if they have not voted yet).
    This scanning also determines the length of the segments that will be accepted.
    For this, the algorithm defines two additional parameters. One is the minimum
    length for a segment to be accepted, and the other is the maximum pixel gap that
    is permitted to form a continuous segment. This additional step increases the
    complexity of the algorithm, but this is partly compensated by the fact that fewer
    points will be involved in the voting process, as some of them are eliminated
    by the line-scanning process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 概率霍夫变换对基本算法进行了一些修改。首先，不是系统地按行扫描图像，而是在二进制地图中以随机顺序选择点。每当累加器的某个条目达到指定的最小值时，就会沿着相应的线条扫描图像，并移除所有通过它的点（即使它们还没有投票）。这种扫描还确定了将接受的段长度。为此，算法定义了两个额外的参数。一个是段被接受的最小长度，另一个是形成连续段所允许的最大像素间隙。这一额外步骤增加了算法的复杂性，但部分地通过减少参与投票过程中的点数来补偿，因为其中一些点被线扫描过程消除。
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Hough transform can also be used to detect other geometrical entities. In
    fact, any entity that can be represented by a parametric equation is a good candidate
    for the Hough transform. There is also a Generalized Hough transform that can
    detect objects of any shape.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 霍夫变换也可以用来检测其他几何实体。实际上，任何可以用参数方程表示的实体都是霍夫变换的良好候选者。还有一个广义霍夫变换可以检测任何形状的物体。
- en: Detecting circles
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测圆圈
- en: 'In the case of circles, the corresponding parametric equation is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在圆的情况下，相应的参数方程如下：
- en: '![Detecting circles](img/B05388_07_22.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![检测圆圈](img/B05388_07_22.jpg)'
- en: This equation includes three parameters (the circle radius and center coordinates),
    which means that a three-dimensional accumulator would be required. However, it
    is generally found that the Hough transform becomes more complex and less reliable
    as the dimensionality of its accumulator increases. Indeed, in this case, a large
    number of entries of the accumulator will be incremented for each point and, as
    a consequence, the accurate localization of local peaks becomes more difficult.
    Different strategies have been proposed in order to overcome this problem. The
    strategy used in the OpenCV implementation of the Hough circle detection uses
    two passes. During the first pass, a two-dimensional accumulator is used to find
    candidate circle locations. Since the gradient of points on the circumference
    of a circle should point in the direction of the radius, for each point, only
    the entries in the accumulator along the gradient direction are incremented (based
    on predefined minimum and maximum radius values). Once a possible circle center
    is detected (that is, has received a predefined number of votes), a 1D histogram
    of a possible radius is built during the second pass. The peak value in this histogram
    corresponds to the radius of the detected circles.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程包含三个参数（圆的半径和中心坐标），这意味着需要一个三维累加器。然而，通常发现，随着其累加器维度的增加，霍夫变换变得更加复杂且不可靠。确实，在这种情况下，累加器的每个点都会增加大量条目，因此局部峰值的确切定位变得更加困难。已经提出了不同的策略来克服这个问题。OpenCV
    实现的霍夫圆检测策略使用两遍。在第一次遍历中，使用二维累加器来找到候选圆的位置。由于圆周上点的梯度应该指向半径方向，因此对于每个点，仅沿梯度方向增加累加器的条目（基于预定义的最小和最大半径值）。一旦检测到一个可能的圆心（即，已收到预定义数量的投票），在第二次遍历中构建一个可能的半径的一维直方图。该直方图中的峰值值对应于检测到的圆的半径。
- en: 'The `cv::HoughCircles` function that implements the preceding strategy integrates
    both the Canny detection and the Hough transform. It is called as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实现上述策略的 `cv::HoughCircles` 函数集成了 Canny 检测和霍夫变换。其调用方式如下：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that it is always recommended that you smooth the image before calling
    the `cv::HoughCircles` function in order to reduce the image noise that could
    cause several false circle detections. The result of the detection is given in
    a vector of `cv::Vec3f` instances. The first two values are the circle center
    coordinates and the third is the radius.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用 `cv::HoughCircles` 函数之前始终建议您平滑图像，以减少可能导致多个错误圆检测的图像噪声。检测结果以 `cv::Vec3f`
    实例的向量给出。前两个值是圆心坐标，第三个是半径。
- en: The `cv::HOUGH_GRADIENT` argument was the only option available at the time
    of writing. It corresponds to the two-pass circle detection method. The fourth
    parameter defines the accumulator resolution. It is a divider factor; specifying
    a value of `2`, for example, makes the accumulator half the size of the image.
    The next parameter is the minimum distance in pixels between two detected circles.
    The other parameter corresponds to the high threshold of the Canny edge detector.
    The low-threshold value is always set at half this value. The seventh parameter
    is the minimum number of votes that a center location must receive during the
    first pass to be considered as a candidate circle for the second pass. Finally,
    the last two parameters are the minimum and maximum radius values for the circles
    to be detected. As can be seen, the function includes many parameters that make
    it difficult to tune.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写时，`cv::HOUGH_GRADIENT` 参数是唯一可用的选项。它对应于两遍圆检测方法。第四个参数定义了累加器的分辨率。它是一个除数因子；例如，指定值为
    `2` 将使累加器的大小为图像的一半。下一个参数是两个检测到的圆之间的最小像素距离。另一个参数对应于 Canny 边缘检测器的高阈值。低阈值值始终设置为这个值的一半。第七个参数是在第一次遍历期间，一个中心位置必须收到的最小投票数，才能被认为是第二次遍历的候选圆。最后，最后两个参数是待检测圆的最小和最大半径值。可以看出，该函数包含许多参数，使得调整变得困难。
- en: 'Once the vector of detected circles is obtained, these circles can be drawn
    on the image by iterating over the vector and calling the `cv::circle` drawing
    function with the obtained parameters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得检测到的圆的向量，可以通过遍历该向量并使用获取到的参数调用 `cv::circle` 绘图函数，在图像上绘制这些圆：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the result obtained on a test image with the chosen arguments:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是使用所选参数在测试图像上获得的结果：
- en: '![Detecting circles](img/image_07_013.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![检测圆](img/image_07_013.jpg)'
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The following article, *Gradient-based Progressive Probabilistic Hough Transform*
    by *C. Galambos*, *J. Kittler*, and *J. Matas, IEE Vision Image and Signal Processing*,
    *vol. 148 no 3, pp. 158-165, 2002*, is one of the numerous references on the Hough
    transform and describes the probabilistic algorithm implemented in OpenCV.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文章，*《基于梯度的渐进概率Hough变换》，*由*C. Galambos*，*J. Kittler*和*J. Matas*撰写，发表在*《IEEE视觉图像与信号处理》，第148卷第3期，第158-165页，2002年*，是关于Hough变换的众多参考文献之一，描述了OpenCV中实现的概率算法。
- en: The following article, *Comparative Study of Hough Transform Methods for Circle
    Finding, Image and Vision Computing*, *vol. 8 no 1, pp. 71-77, 1990*, by *H.K.
    Yuen*, *J. Princen*, *J. Illingworth*, and *J Kittler*, describes different strategies
    for circle detection using the Hough transform.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文章，*《基于Hough变换的圆检测方法比较研究》，*《图像与视觉计算》，第8卷第1期，第71-77页，1990年*，由*H.K. Yuen*，*J.
    Princen*，*J. Illingworth*和*J. Kittler*撰写，描述了使用Hough变换进行圆检测的不同策略。
- en: Fitting a line to a set of points
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一条线拟合到一组点
- en: In some applications, it could be important to not only detect lines in an image,
    but also to obtain an accurate estimate of the line's position and orientation.
    This recipe will show you how to estimate the exact line that best fits a given
    set of points.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用中，可能不仅需要检测图像中的线，还需要获得线位置和方向的准确估计。这个菜谱将向您展示如何估计最适合给定点集的确切线。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The first thing to do is to identify points in an image that seem to be aligned
    along a straight line. Let''s use one of the lines we detected in the preceding
    recipe. The lines detected using `cv::HoughLinesP` are contained in `std::vector<cv::Vec4i>`
    called `lines`. To extract the set of points that seem to belong to, let''s say,
    the first of these lines, we can proceed as follows. We draw a white line on a
    black image and intersect it with the Canny image of `contours` used to detect
    our lines. This is simply achieved by the following statements:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是识别图像中似乎沿直线排列的点。让我们使用前一个菜谱中检测到的其中一条线。使用`cv::HoughLinesP`检测到的线包含在名为`lines`的`std::vector<cv::Vec4i>`中。为了提取似乎属于这些线的点集，例如，第一个这样的线，我们可以按以下步骤进行。我们在黑色图像上绘制一条白色线，并将其与用于检测线的`contours`的Canny图像相交。这可以通过以下语句简单地实现：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result is an image that contains points that could be associated with the
    specified line. In order to introduce some tolerance, we draw a line of a certain
    thickness (here, `3`). All points inside the defined neighborhood are, therefore,
    accepted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含可能关联到指定线的点的图像。为了引入一些容差，我们绘制了一条具有一定厚度（此处为`3`）的线。因此，定义的邻域内的所有点都被接受。
- en: 'The following is the image that is obtained (inverted for better viewing):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是获得的图像（为了更好的查看已反转）：
- en: '![How to do it...](img/image_07_014.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/image_07_014.jpg)'
- en: 'The coordinates of the points in this set can then be inserted in a `std::vector`
    of `cv::Point` objects (floating point coordinates, that is, `cv::Point2f`, can
    also be used) with the following double loop:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集合中点的坐标可以插入到`std::vector`中，其中包含`cv::Point`对象（浮点坐标，即`cv::Point2f`也可以使用）的以下双循环中：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now have a list of points and we want to fit a line passing through these
    points. This best fitting line is easily found by calling the `cv::fitLine` OpenCV
    function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一组点，我们想要拟合一条通过这些点的线。通过调用`cv::fitLine` OpenCV函数，可以轻松找到最佳拟合线：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code gives us the parameters of the line equation in the form
    of a unit-directional vector (the first two values of `cv::Vec4f`) and the coordinates
    of one point on the line (the last two values of `cv::Vec4f`). The last two parameters
    specify the requested accuracy for the line parameters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码以单位方向向量的形式（`cv::Vec4f`的前两个值）和线上的一个点的坐标（`cv::Vec4f`的最后两个值）的形式给出了线方程的参数。最后两个参数指定了线参数的请求精度。
- en: 'In general, the line equation will be used in the calculation of some properties
    (calibration is a good example where precise parametric representation is required).
    As an illustration, and to make sure we calculated the right line, let''s draw
    the estimated line on the image. Here, we simply draw an arbitrary black segment
    that has a length of `100` pixels and a thickness of `2` pixels (to make it visible):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，线方程将用于计算某些属性（校准是一个需要精确参数表示的好例子）。为了说明，并确保我们计算了正确的线，让我们在图像上绘制估计的线。在这里，我们简单地绘制了一个长度为`100`像素、厚度为`2`像素的任意黑色线段（使其可见）：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following image shows this line well aligned with one of the road''s sides:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了这条线与道路一侧的良好对齐：
- en: '![How to do it...](img/image_07_015.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_07_015.jpg)'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Fitting lines to a set of points is a classic problem in mathematics. The OpenCV
    implementation proceeds by minimizing the sum of the distances from each point
    to the line. Several distance functions are proposed, and the fastest option is
    to use the Euclidean distance, which is specified by `cv::DIST_L2`. This choice
    corresponds to the standard least-squares line fitting. When outliers (that is,
    points that don't belong on the line) are included in the point set, other distance
    functions that give less influence to far points can be selected. The minimization
    is based on the M-estimator technique, which iteratively solves a weighted least-squares
    problem with weights that are inversely proportional to the distance from the
    line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将直线拟合到一组点集是数学中的一个经典问题。OpenCV的实现是通过最小化每个点到直线的距离之和来进行的。提出了几种距离函数，其中最快的选择是使用欧几里得距离，它由`cv::DIST_L2`指定。这个选择对应于标准的最小二乘线拟合。当点集中包含异常值（即不属于直线的点）时，可以选择其他对远点影响较小的距离函数。最小化是基于M估计器技术，它通过迭代求解具有与到直线的距离成反比的权重的加权最小二乘问题。
- en: Using this function, it is also possible to fit a line to a 3D point set. The
    input is, in this case, a set of `cv::Point3i` or `cv::Point3f` objects, and the
    output is a `std::Vec6f` instance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，还可以将直线拟合到3D点集。在这种情况下，输入是一个`cv::Point3i`或`cv::Point3f`对象的集合，输出是一个`std::Vec6f`实例。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `cv::fitEllipse` function fits an ellipse to a set of 2D points. This returns
    a rotated rectangle (a `cv::RotatedRect` instance), inside which the ellipse is
    inscribed. In this case, you would write the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::fitEllipse`函数将椭圆拟合到一组2D点。这返回一个旋转矩形（一个`cv::RotatedRect`实例），其中椭圆被内嵌。在这种情况下，你会写以下内容：'
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `cv::ellipse` function is the one you would use to draw the computed ellipse.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::ellipse`函数是您用来绘制计算出的椭圆的函数。'
- en: Extracting connected components
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取连通分量
- en: Images generally contain representations of objects. One of the goals of image
    analysis is to identify and extract these objects. In object detection/recognition
    applications, the first step is often to produce a binary image that shows you
    where certain objects of interest could be located. No matter how this binary
    map is obtained (for example, from the histogram back projection we performed
    in [Chapter 4](ch04.html "Chapter 4. Counting the Pixels with Histograms") , *Counting
    the Pixels with Histograms*, or from motion analysis as we will learn in [Chapter
    12](ch12.html "Chapter 12. Processing Video Sequences") , *Processing Video Sequences*),
    the next step is to extract the objects that are contained in this collection
    of 1s and 0s.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图像通常包含对象的表示。图像分析的一个目标就是识别和提取这些对象。在目标检测/识别应用中，第一步通常是生成一个二值图像，显示感兴趣对象可能的位置。无论这个二值图是如何获得的（例如，从我们在[第4章](ch04.html
    "第4章. 使用直方图计数像素")中执行的直方图反向投影，*使用直方图计数像素*，或者从我们在[第12章](ch12.html "第12章. 处理视频序列")中将要学习的运动分析，*处理视频序列*），下一步就是从这组1和0中提取对象。
- en: 'Consider, for example, the image of buffaloes in a binary form that we manipulated
    in [Chapter 5](ch05.html "Chapter 5. Transforming Images with Morphological Operations")
    , *Transforming Images with Morphological Operations*, as shown in the following
    figure:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们在[第5章](ch05.html "第5章. 使用形态学操作变换图像")，*使用形态学操作变换图像*中操作的二值化水牛图像，如图所示：
- en: '![Extracting connected components](img/image_07_016.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![提取连通分量](img/image_07_016.jpg)'
- en: We obtained this image from a simple thresholding operation followed by the
    application of morphological filters. This recipe will show you how to extract
    the objects of such images. More specifically, we will extract the connected components,
    that is, shapes made of a set of connected pixels in a binary image.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的阈值操作和随后应用形态学滤波器获得此图像。这个配方将向您展示如何提取此类图像的对象。更具体地说，我们将提取连通分量，即在二值图像中由一组连接像素组成的形状。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'OpenCV offers a simple function that extracts the contours of the connected
    components of an image. This is the `cv::findContours` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个简单的函数，用于提取图像中连通分量的轮廓。这个函数是`cv::findContours`：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The input is obviously the binary image. The output is a vector of contours,
    each contour being represented by a vector of `cv::Point` objects. This explains
    why the output parameter is defined as a `std::vector` instance of the `std::vector`
    instances. In addition, two flags are specified. The first one indicates that
    only the external contours are required, that is, holes in an object will be ignored
    (the *There's more...* section will discuss the other options).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，输入是二值图像。输出是一个轮廓向量，每个轮廓由一个`cv::Point`对象的向量表示。这解释了为什么输出参数被定义为`std::vector`实例的`std::vector`实例。此外，还指定了两个标志。第一个标志表示只需要外部轮廓，即对象中的孔将被忽略（*还有更多...*部分将讨论其他选项）。
- en: The second flag is there to specify the format of the contour. With the current
    option, the vector will list all of the points in the contour. With the `cv::CHAIN_APPROX_SIMPLE`
    flag, only the endpoints for horizontal, vertical, or diagonal contours will be
    included. Other flags would give a more sophisticated chain approximation of the
    contours in order to obtain a more compact representation. With the preceding
    image, nine connected components are obtained as given by `contours.size()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个标志用于指定轮廓的格式。在当前选项下，向量将列出轮廓中的所有点。使用`cv::CHAIN_APPROX_SIMPLE`标志，仅包括水平、垂直或对角轮廓的端点。其他标志将给出更复杂的轮廓链近似，以获得更紧凑的表示。根据前面的图像，通过`contours.size()`获得了九个连通组件。
- en: 'Fortunately, there is a very convenient function that can draw the contours
    of those components on an image (here, a white image):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个非常方便的函数可以在图像上绘制这些组件的轮廓（这里是一个白色图像）：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the third parameter of this function is a negative value, then all contours
    are drawn. Otherwise, it is possible to specify the index of the contour to be
    drawn. The result is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数的第三个参数是一个负值，那么将绘制所有轮廓。否则，可以指定要绘制的轮廓的索引。结果如下：
- en: '![How to do it...](img/image_07_017.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_07_017.jpg)'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The contours are extracted by a simple algorithm that consists of systematically
    scanning the image until a component is hit. From this starting point on the component,
    its contour is followed, marking the pixels on its border. When the contour is
    completed, the scanning resumes at the last position until a new component is
    found.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 轮廓是通过一个简单的算法提取的，该算法系统地扫描图像，直到遇到一个组件。从这个组件的起始点开始，跟随其轮廓，标记其边界的像素。当轮廓完成时，扫描从最后的位置重新开始，直到找到新的组件。
- en: 'The identified connected components can then be individually analyzed. For
    example, if some prior knowledge is available about the expected size of the objects
    of interest, it becomes possible to eliminate some of the components. Let''s then
    use a minimum and a maximum value for the perimeter of the components. This is
    done by iterating over the vector of contours and eliminating the invalid components:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 确定的连通组件可以随后分别进行分析。例如，如果对感兴趣对象的大小有先验知识，就可以消除一些组件。然后，我们可以为组件的周长设置一个最小值和一个最大值。这是通过迭代轮廓向量并消除无效组件来完成的：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that this loop could have been made more efficient since each erasing operation
    in a `std::vector` instance is O(N). However, considering the small size of this
    vector, the overall cost is not too high.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个循环可以更高效，因为`std::vector`实例中的每次删除操作都是O(N)。然而，考虑到这个向量的尺寸很小，总体成本并不高。
- en: 'This time, we draw the remaining contours on the original image and obtain
    the following result:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在原始图像上绘制剩余的轮廓，得到以下结果：
- en: '![How it works...](img/image_07_018.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/image_07_018.jpg)'
- en: We were lucky enough to find a simple criterion that allowed us to identify
    all objects of interest in this image. In more complex situations, a more refined
    analysis of the components' properties is required. This is the object of the
    next recipe, *Computing components' shape descriptors*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常幸运地找到了一个简单的标准，使我们能够识别出图像中所有感兴趣的对象。在更复杂的情况下，需要对组件属性进行更精细的分析。这就是下一个菜谱的主题，*计算组件的形状描述符*。
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With the `cv::findContours` function, it is also possible to include all closed
    contours in the binary map, including the ones formed by holes in the components.
    This is done by specifying another flag in the function call:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cv::findContours`函数，还可以在二值图中包括所有闭合轮廓，包括由组件形成的孔。这是通过在函数调用中指定另一个标志来完成的：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this call, the following contours are obtained:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个调用，得到以下轮廓：
- en: '![There''s more...](img/image_07_019.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/image_07_019.jpg)'
- en: 'Notice the extra contours that were added in the background forest. It is also
    possible to have these contours organized into a hierarchy. The main component
    is the parent, holes in it are its children, and if there are components inside
    these holes, they become the children of the previous children, and so on. This
    hierarchy is obtained by using the `cv::RETR_TREE` flag, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在背景森林中添加的额外轮廓。这些轮廓也可以组织成层次结构。主要组件是父元素，其中的孔是它的子元素，如果这些孔中有组件，它们成为先前子元素的子元素，依此类推。这个层次结构是通过使用
    `cv::RETR_TREE` 标志获得的，如下所示：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, each contour has a corresponding hierarchy element at the same
    index, made of four integers. The first two integers give you the index of the
    next and the previous contours of the same level, and the next two integers give
    you the index of the first child and the parent of this contour. A negative index
    indicates the end of a contour list. The `cv::RETR_CCOMP` flag is similar but
    limits the hierarchy at two levels.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个轮廓都有一个对应的同一索引的层次元素，由四个整数组成。前两个整数给出了同一级别的下一个和前一个轮廓的索引，后两个整数给出了此轮廓的第一个子元素和父元素的索引。负索引表示轮廓列表的结束。`cv::RETR_CCOMP`
    标志类似，但限制了层次结构在两个级别。
- en: Computing components' shape descriptors
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算组件的形状描述符
- en: A connected component often corresponds to the image of an object in a pictured
    scene. To identify this object, or to compare it with other image elements, it
    can be useful to perform some measurements on the component in order to extract
    some of its characteristics. In this recipe, we will look at some of the shape
    descriptors available in OpenCV that can be used to describe the shape of a connected
    component.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 连通组件通常对应于图片场景中物体的图像。为了识别这个物体，或者将其与其他图像元素进行比较，对组件进行一些测量以提取其某些特征可能是有用的。在这个菜谱中，我们将查看OpenCV中可用的某些形状描述符，这些描述符可以用来描述连通组件的形状。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Many OpenCV functions are available when it comes to shape description. We will
    apply some of them on the components that we have extracted in the preceding recipe.
    In particular, we will use our vector of four contours corresponding to the four
    buffaloes we previously identified. In the following code snippets, we compute
    a shape descriptor on the contours (`contours[0]` to `contours[3]`) and draw the
    result (with a thickness of `2`) over the image of the contours (with a thickness
    of `1`). This image is shown at the end of this section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到形状描述时，OpenCV提供了许多函数。我们将应用其中的一些函数到前面菜谱中提取的组件上。特别是，我们将使用我们之前识别出的四个水牛对应的四个轮廓的向量。在下面的代码片段中，我们在轮廓上计算形状描述符（`contours[0]`
    到 `contours[3]`），并在轮廓图像上绘制结果（厚度为 `2`），轮廓图像的厚度为 `1`。此图像在本节末尾显示。
- en: 'The first one is the bounding box, which is applied to the bottom-right component:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个边界框，它应用于右下角的组件：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The minimum enclosing circle is similar. It is applied to the upper-right component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最小包围圆类似。它应用于右上角的组件：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The polygonal approximation of a component''s contour is computed as follows
    (on the left-hand component):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 组件轮廓的多边形近似计算如下（在左侧组件）：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice the polygon drawing function, `cv::polylines`. This operates similarly
    to the other drawing functions. The third Boolean parameter is used to indicate
    whether the contour is closed or not (if yes, the last point is linked to the
    first one).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到多边形绘制函数 `cv::polylines`。它与其他绘图函数类似操作。第三个布尔参数用于指示轮廓是否闭合（如果是，则最后一个点与第一个点相连）。
- en: 'The convex hull is another form of polygonal approximation (on the second component
    from the left):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 凸包是另一种多边形近似形式（在左侧第二个组件）：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, the computation of the moments is another powerful descriptor (the
    center of mass is drawn inside all components):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，计算矩是另一个强大的描述符（质心被绘制在所有组件内部）：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The resulting image is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像如下：
- en: '![How to do it...](img/image_07_020.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_07_020.jpg)'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The bounding box of a component is probably the most compact way to represent
    and localize a component in an image. It is defined as the upright rectangle of
    minimum size that completely contains the shape. Comparing the height and width
    of the box gives you an indication about the vertical or horizontal dimensions
    of the object (for example, one could use a height-to-width ratio in order to
    distinguish an image of a car from one of a pedestrian). The minimum enclosing
    circle is generally used when only the approximate component size and location
    is required.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的边界框可能是表示和定位图像中组件的最紧凑方式。它被定义为完全包含形状的最小直立矩形。比较框的高度和宽度可以给出关于物体垂直或水平尺寸的指示（例如，可以通过高度与宽度的比例来区分汽车图像和行人图像）。当只需要近似组件大小和位置时，通常使用最小外接圆。
- en: The polygonal approximation of a component is useful when one wants to manipulate
    a more compact representation that resembles the component's shape. It is created
    by specifying an accuracy parameter, giving you the maximal acceptable distance
    between a shape and its simplified polygon. It is the fourth parameter in the
    `cv::approxPolyDP` function. The result is a vector of `cv::Point`, which corresponds
    to the vertices of the polygon. To draw this polygon, we need to iterate over
    the vector and link each point with the next one by drawing a line between them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要操作一个更紧凑且类似于组件形状的表示时，组件的多边形近似很有用。它通过指定一个精度参数来创建，该参数给出了形状与其简化多边形之间的最大可接受距离。它是`cv::approxPolyDP`函数中的第四个参数。结果是`cv::Point`的向量，对应于多边形的顶点。为了绘制这个多边形，我们需要遍历这个向量，并通过在它们之间画线将每个点与下一个点连接起来。
- en: The convex hull, or convex envelope, of a shape is the minimal convex polygon
    that encompasses a shape. It can be visualized as the shape that an elastic band
    would take if placed around the component. As can be seen, the convex hull contour
    will deviate from the original one at the concave locations of the shape contour.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 形状的凸包，或称为凸包，是包含该形状的最小凸多边形。它可以想象成如果将一个弹性带围绕该形状放置时它所形成的形状。正如所见，凸包轮廓将在形状轮廓的凹处偏离原始轮廓。
- en: 'These locations are often designated as convexity defects, and a special OpenCV
    function is available to identify them: the `cv::convexityDefects` function. It
    is called as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些位置通常被称为凸性缺陷，OpenCV提供了一个特殊函数来识别它们：`cv::convexityDefects`函数。它的调用方式如下：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `contour` and `hull` arguments are, respectively, the original and the convex
    hull contours (both represented with `std::vector<cv::Point>` instances). The
    output is a vector of four integer elements. The first two integers are the indices
    of the points on the contour, delimiting the defect; the third integer corresponds
    to the farthest point inside the concavity, and finally, the last integer corresponds
    to the distance between this farthest point and the convex hull.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`contour`和`hull`参数分别是原始轮廓和凸包轮廓（均以`std::vector<cv::Point>`实例表示）。输出是一个包含四个整数元素的向量。前两个整数是轮廓上点的索引，界定缺陷；第三个整数对应于凹处的最远点，最后，最后一个整数对应于这个最远点与凸包之间的距离。'
- en: Moments are commonly used mathematical entities in the structural analysis of
    shapes. OpenCV has defined a data structure that encapsulates all computed moments
    of a shape. It is the object returned by the `cv::moments` function. Together,
    the moments represent a compact description of the shape of an object. They are
    commonly used, for example, in character recognition. We simply use this structure
    to obtain the mass center of each component that is computed from the first three
    spatial moments here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬时矩是形状结构分析中常用的数学实体。OpenCV定义了一个数据结构，用于封装形状的所有计算出的矩。它是`cv::moments`函数返回的对象。这些矩共同代表了一个物体形状的紧凑描述。它们在字符识别等应用中常用。我们简单地使用这个结构来获取由前三个空间矩计算出的每个组件的质量中心。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Other structural properties can be computed using the available OpenCV functions.
    The `cv::minAreaRect` function computes the minimum enclosed rotated rectangle
    (this was used in [Chapter 5](ch05.html "Chapter 5. Transforming Images with Morphological
    Operations") , *Transforming Images with Morphological Operations*, in the *Extracting
    distinctive regions using MSER* recipe). The `cv::contourArea` function estimates
    the area of (the number of pixels inside) a contour. The `cv::pointPolygonTest`
    function determines whether a point is inside or outside a contour, and `cv::matchShapes`
    measures the resemblance between two contours. All these property measures can
    be advantageously combined in order to perform more advanced structural analysis.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用可用的OpenCV函数计算其他结构特性。`cv::minAreaRect`函数计算最小包含旋转矩形（这在[第5章](ch05.html "第5章.
    使用形态学操作变换图像")，*使用形态学操作变换图像*，在*使用MSER提取特征区域*的配方中使用过）。`cv::contourArea`函数估计轮廓的面积（轮廓内的像素数量）。`cv::pointPolygonTest`函数确定一个点是否在轮廓内部或外部，而`cv::matchShapes`测量两个轮廓之间的相似度。所有这些属性度量可以有效地结合起来，以执行更高级的结构分析。
- en: Quadrilateral detection
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四边形检测
- en: 'The MSER features presented in [Chapter 5](ch05.html "Chapter 5. Transforming
    Images with Morphological Operations") , *Transforming Images with Morphological
    Operations*, constitutes an efficient tool to extract shapes in an image. Considering
    the MSER result obtained in the preceding chapter, we will now build an algorithm
    to detect quadrilateral components in an image. In the case of the current image,
    this detection will allow us to identify the building''s windows. A binary version
    of the MSER image is easily obtained, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章. 使用形态学操作变换图像")中介绍的MSER特征，*使用形态学操作变换图像*，构成了一种有效的工具，可以用来从图像中提取形状。考虑到前一章中获得的MSER结果，我们现在将构建一个算法来检测图像中的四边形组件。对于当前图像，这种检测将使我们能够识别建筑物的窗户。MSER图像的二值版本很容易获得，如下所示：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In addition, we cleaned the image with a morphological filter. The image is
    then as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用形态学滤波器清理了图像。图像随后如下所示：
- en: '![Quadrilateral detection](img/image_07_021.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![四边形检测](img/image_07_021.jpg)'
- en: 'The next step is to obtain the contours:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取轮廓：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we go over all the contours and roughly approximate them with a polygon:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遍历所有轮廓，并大致用多边形来近似它们：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The quadrilaterals are those polygons that have four edges. The detected ones
    are the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 四边形是指具有四条边的多边形。检测到的如下：
- en: '![Quadrilateral detection](img/image_07_022.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![四边形检测](img/image_07_022.jpg)'
- en: To detect rectangles, you can simply measure the angles between adjacent edges
    and reject the quadrilaterals that have angles that deviate too much from 90 degrees.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测矩形，你可以简单地测量相邻边之间的角度，并拒绝那些角度与90度偏差太大的四边形。
