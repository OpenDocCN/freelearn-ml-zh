- en: Anti-Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反模式
- en: Over the last five chapters, we have looked in great detail at reusability,
    performance, maintainability, safety, and some miscellaneous design patterns.
    These patterns are extremely useful and can be applied to various situations for
    different types of applications. While it is important to know what the best practices
    are, it is also beneficial to understand what pitfalls to avoid. To do this, we
    are going to cover several **anti-patterns** in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的五章中，我们详细探讨了可重用性、性能、可维护性、安全性和一些杂项设计模式。这些模式非常有用，可以应用于各种不同类型的应用程序的不同场景。虽然了解最佳实践很重要，但了解要避免的陷阱也同样有益。为此，我们将在本章中介绍几个**反模式**。
- en: 'Anti-patterns are bad practices that programmers may do unintentionally. Sometimes,
    these problems are not severe enough to cause trouble; however, it is possible
    that an application may become unstable or have degraded performance due to improper
    design. In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式是程序员可能无意中采取的坏做法。有时，这些问题可能不够严重，不足以造成麻烦；然而，由于设计不当，应用程序可能会变得不稳定或性能下降。在本章中，我们将涵盖以下主题：
- en: Piracy anti-pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盗版反模式
- en: Narrow argument types anti-pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窄参数类型反模式
- en: Nonconcrete field types anti-pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非具体字段类型反模式
- en: By the end of this chapter, you will have learned how to avoid developing pirate
    functions. You will also be more conscious and smart about the level of abstraction
    when specifying the type of function arguments. Finally, you will be able to leverage
    more parametric types in your design for your own composite types for high-performance
    applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何避免开发盗版函数。您还将对指定函数参数类型时的抽象级别更加警觉和明智。最后，您将能够在设计自己的复合类型时利用更多的参数化类型，以实现高性能应用。
- en: Let's start with the most interesting topic—piracy!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最有趣的话题——盗版！开始吧。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10)[.](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源代码位于[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10)[.](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter10)
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在Julia 1.3.0环境中进行了测试。
- en: Piracy anti-pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盗版反模式
- en: In [Chapter 2](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml), *Modules, Packages
    and Data Type Concepts*, we learned how to create new namespaces using modules.
    As you may recall, modules are used to define functions so that they are logically
    separated. It is possible, then, that we can define two different functions—one
    in module X and another in module Y, with both having exactly the same name. In
    fact, these functions do not even need to mean the same thing. For example, in
    a mathematics package, we can define a `trace` function for matrices. In a computer
    graphics package, we can define a `trace` function for doing ray tracing work.
    These two `trace` functions perform different things, and they do not interfere
    with each other.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](48061f6f-db77-4db6-9c92-d7550f4317fe.xhtml)“模块、包和数据类型概念”中，我们学习了如何使用模块创建新的命名空间。如您所回忆的那样，模块用于定义函数，以便它们在逻辑上分离。因此，我们可以定义两个不同的函数——一个在模块X中，另一个在模块Y中，这两个函数具有完全相同的名称。实际上，这些函数甚至不需要具有相同的意义。例如，在一个数学包中，我们可以为矩阵定义一个`trace`函数。在计算机图形学包中，我们可以定义一个用于进行光线追踪工作的`trace`函数。这两个`trace`函数执行不同的操作，并且它们不会相互干扰。
- en: 'On the other hand, a function can also be designed to be extended from another
    package. For example, in the `Base` package, the `AbstractArray` interface is
    designed to be extended. Here''s an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个函数也可以设计成可以从另一个包扩展。例如，在`Base`包中，`AbstractArray`接口被设计成可以扩展。以下是一个例子：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have extended the `size` and `getindex` functions from the `Base`
    package so that they can work with our own data types. This is a perfectly good
    usage of the Julia language; however, it can be problematic when we do not extend
    functions from other packages correctly. In particular,* piracy* refers to the
    situation in which a third-party function is replaced or extended in a bad way.
    This is an anti-pattern because it may cause system behavior to become nondeterministic.
    For convenience, we can define three different kinds of piracy:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们扩展了来自 `Base` 包的 `size` 和 `getindex` 函数，以便它们可以与我们的自定义数据类型一起工作。这是 Julia
    语言的一个非常好的用法；然而，当我们没有正确扩展其他包的函数时，可能会出现问题。特别是，“盗版”指的是第三方函数被错误地替换或扩展的情况。这是一个反模式，因为它可能导致系统行为变得非确定性。为了方便起见，我们可以定义三种不同类型的盗版：
- en: '**Type I piracy**: Function is redefined'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型 I 盗版行为**：功能被重新定义'
- en: '**Type II piracy**: Function is extended without using your own types in any
    of the arguments'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型 II 盗版行为**：在没有任何参数中使用自己的类型扩展函数'
- en: '**Type III piracy**: Function is extended but used for a different purpose'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型 III 盗版行为**：函数被扩展但用于不同的目的'
- en: We will now drill down into each one in more detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更详细地探讨每一个。
- en: Type I – Redefining a function
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型 I – 重新定义函数
- en: Type I piracy refers to the situation where a programmer redefines a third-party
    function from their own module. Perhaps you did not like the original implementation
    in the third-party module and replaced the function with your own implementation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 I 盗版行为指的是程序员在自己的模块中重新定义第三方函数的情况。也许你不喜欢第三方模块中的原始实现，并用你自己的实现替换了该函数。
- en: 'The worst form of Type I piracy is when you replace the function without conforming
    to the original function''s interface. Let''s do an experiment and see what could
    happen. We will use the `+` function from `Base` as an example. As you know, when
    the `+` function is passed with two `Int` arguments, it should return an `Int`
    value as a result. What would happen if we replace the function so that it returns
    a string? Let''s open up a REPL and give it a try:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 I 盗版行为最糟糕的形式是，在不遵守原始函数接口的情况下替换函数。让我们做一个实验看看会发生什么。我们将使用 `Base` 中的 `+` 函数作为例子。正如你所知，当
    `+` 函数传递两个 `Int` 参数时，它应该返回一个 `Int` 类型的结果。如果我们替换函数使其返回一个字符串会发生什么？让我们打开一个 REPL 并试一试：
- en: '![](img/f79f8cb7-b6c1-403c-a428-9b1d907a190c.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f79f8cb7-b6c1-403c-a428-9b1d907a190c.png)'
- en: '*Boom! *The Julia REPL crashed immediately as soon as the function was defined. That
    is because the return value of this `+` function is expected to be an integer.
    When we return a string, it violates the contract of this function and all functionalities
    that rely on the `+` function are negatively impacted. Given that `+` is a commonly
    used function, it crashes the system immediately.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*砰！* Julia REPL 在定义函数的瞬间立即崩溃。这是因为这个 `+` 函数的返回值预期是一个整数。当我们返回一个字符串时，它违反了这个函数的契约，并且所有依赖于
    `+` 函数的功能都会受到负面影响。鉴于 `+` 是一个常用的函数，它立即导致系统崩溃。'
- en: Why does Julia even allow us to do that? For some situations, the ability to
    do this can be useful. Say that you found a bug for a specific function in a third-party
    package—you can inject a fix immediately without having to wait for the bug fix
    upstream. Likewise, you can replace a slow function with a more performant version.
    Ideally, these changes should be sent upstream, but you have the flexibility to
    implement the change immediately.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 Julia 甚至允许我们这样做？在某些情况下，这种能力可能是有用的。比如说，你发现了一个第三方包中特定函数的 bug—you 可以立即注入修复，而不必等待上游的
    bug 修复。同样，你可以用更高效的版本替换一个慢函数。理想情况下，这些更改应该发送到上游，但你也有立即实施更改的灵活性。
- en: The only requirement is that the function being replaced should adhere to the
    same contract that was originally intended. Therefore, it requires an intimate
    understanding about how the third-party package is designed. In reality, it is
    even better if you can contact the original author and discuss the change before
    applying piracy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的要求是，被替换的函数应该遵守最初打算的相同契约。因此，需要对第三方包的设计有深入的了解。实际上，如果你在应用盗版之前能联系到原始作者并讨论更改，那就更好了。
- en: '*With great power comes great responsibility. *Great care must be taken if
    we ever want to make use of Type I piracy.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*权力越大，责任越大。*如果我们想利用类型 I 盗版行为，就必须非常小心。'
- en: Next, we will look into Type II piracy, which is more common across packages
    in the Julia ecosystem.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨类型 II 盗版行为，这在 Julia 生态系统中的包中更为常见。
- en: Type II piracy – Extending without your own types
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型 II 盗版 – 没有使用自己的类型进行扩展
- en: Type II piracy is commonly known as *type piracy* by the Julia developer community.
    It refers to the situation where a third-party function is extended without using
    the programmer's own types in any of the function arguments. It usually happens
    when you want to extend the third-party package by injecting your own code. Let's
    go through a hypothetical example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 II 盗版在 Julia 开发者社区中通常被称为 *类型盗版*。它指的是在没有使用程序员自己的类型作为任何函数参数的情况下扩展第三方函数的情况。这通常发生在您想通过注入自己的代码来扩展第三方包时。让我们通过一个假设的例子来探讨。
- en: 'Suppose that you want to mimic the same behavior in JavaScript of adding a
    string and a number together, where the values concatenate as if they are both
    strings:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在 JavaScript 中模拟将字符串和数字相加的行为，其中值像字符串一样连接：
- en: '![](img/181d749d-f102-4928-ba25-6006356a6a51.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/181d749d-f102-4928-ba25-6006356a6a51.png)'
- en: 'To make it happen in Julia, we would be tempted to do the following in `MyModule`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Julia 中实现这一点，我们可能会在 `MyModule` 中做以下操作：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can paste the preceding code in the REPL and do a quick test:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 REPL 中粘贴前面的代码并进行快速测试：
- en: '![](img/a13e987f-88e4-4c69-8b2b-38b551f95014.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a13e987f-88e4-4c69-8b2b-38b551f95014.png)'
- en: This seems to be working great! But there are some hidden issues with this approach.
    Let's look at why it is still a bad idea.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来工作得很好！但是，这种方法还有一些隐藏的问题。让我们看看为什么这仍然是一个坏主意。
- en: Conflicting with another pirate
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与另一个海盗冲突
- en: Now that we are using the enhanced version of the `+` function, can we rely
    on the fact that the function will always do exactly what we have made it do?
    Perhaps surprisingly, the answer is no.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用 `+` 函数的增强版本，我们能依赖这个函数始终如我们所期望的那样工作吗？也许令人惊讶的是，答案是否定的。
- en: 'Let''s say we have found an open source package called `AnotherModule`, and
    we want to use it in our `MyModule` module. The `AnotherModule` module happens
    to do the same kind of type II piracy; however, the author decided to do the *right* thing—instead
    of concatenating the arguments as if they are strings, the string argument is
    parsed into a number and then the two numbers are added together. The code is
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们找到一个名为 `AnotherModule` 的开源包，我们想在我们的 `MyModule` 模块中使用它。`AnotherModule` 模块恰好也做了同样的类型
    II 盗版；然而，作者决定做正确的事情——不是像字符串一样连接参数，而是将字符串参数解析为数字，然后将两个数字相加。代码如下：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we go back to the REPL and define this module, then we get the new definition:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到 REPL 并定义这个模块，那么我们会得到新的定义：
- en: '![](img/5dbbd88c-0b23-4057-9025-d16729e75e80.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dbbd88c-0b23-4057-9025-d16729e75e80.png)'
- en: We now have two implementations of the same function with exactly the same signature,
    and they return different results. Who is going to win? Is it the one defined
    in `MyModule` or the one in `AnotherModule`? Only one of them can be in effect.
    That means that either `AnotherModule` or `MyModule` is going to break. This problem
    can lead to a disastrous situation and hard-to-find bugs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个具有完全相同签名的相同函数实现，但它们返回的结果不同。谁将获胜？是定义在 `MyModule` 中的那个还是定义在 `AnotherModule`
    中的那个？只有一个可以生效。这意味着 `AnotherModule` 或 `MyModule` 中将有一个会出问题。这个问题可能导致灾难性的情况，并且难以发现的错误。
- en: Another reason to avoid type II piracy is the future-proofing problem. We will
    discuss this next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 避免类型 II 盗版的另一个原因是未来兼容性问题。我们将在下一节讨论这个问题。
- en: Future-proofing your code
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码的未来兼容性
- en: 'Say that we have extended the `+` function in `Base` as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经将 `Base` 中的 `+` 函数扩展如下：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It may seem to be a great addition today; however, there is no guarantee that
    the same function will not be implemented in a future version of Julia. It is
    conceivable (which is not to say that it's likely or unlikely) that the `+` function
    will be enhanced to work with strings in the future.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 今天这看起来可能是一个很好的补充；然而，并不能保证在未来的 Julia 版本中相同的函数不会被实现。可以想象（这并不意味着它可能或不可能）`+` 函数将来会被增强以支持字符串。
- en: In addition, these kinds of changes would be considered nonbreaking, meaning
    that the Julia dev team can add this feature with just a minor release. Unfortunately,
    your application now breaks for a nonbreaking Julia upgrade. That's not something
    that we normally expect.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这类更改将被视为非破坏性更改，这意味着 Julia 开发团队只需通过小版本发布即可添加此功能。不幸的是，现在您的应用程序因为非破坏性的 Julia
    升级而崩溃。这不是我们通常期望的事情。
- en: '*If you want to future-proof your code, then do not be a pirate!*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您想使代码具有未来兼容性，那么请不要成为海盗！*'
- en: Avoiding type piracy
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免类型盗版
- en: 'Type II piracy can be mitigated by creating your own types and using them in
    the function argument. In this case, perhaps we should consider creating a wrapper
    type to hold the string and using this new type for dispatch:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建自己的类型并使用它们作为函数参数，可以减轻Ⅱ级海盗行为。在这种情况下，也许我们应该考虑创建一个包装类型来保存字符串，并使用这个新类型进行分发：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we have redefined the module with a new `MyString` type that holds a
    string. Then, we can still extend the `+` function to concatenate `MyString` with
    any number. For completeness, we have defined three variations of the `+` function
    for accepting `MyString` and `Number` arguments in any order and another one that
    accepts two `MyString` arguments. We have also defined a `str_str` macro for convenience.
    The new module works properly as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重新定义了模块，使用新的 `MyString` 类型来保存字符串。然后，我们仍然可以扩展 `+` 函数以将 `MyString` 与任何数量的字符串连接起来。为了完整性，我们已定义了三个
    `+` 函数变体，用于接受任意顺序的 `MyString` 和 `Number` 参数，以及另一个接受两个 `MyString` 参数的变体。我们还定义了一个
    `str_str` 宏以方便使用。新的模块按如下方式正常工作：
- en: '![](img/55f649ff-8e46-490a-b929-0f53af5fbd9e.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55f649ff-8e46-490a-b929-0f53af5fbd9e.png)'
- en: By using your own type in the function argument, we can avoid any conflict with
    other dependent packages, as well as future-proofing our code for Julia upgrades.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数参数中使用自己的类型，我们可以避免与其他依赖包发生冲突，并为 Julia 升级提供未来保障。
- en: The last kind of piracy is somewhat less severe but still worth a look. Let's
    take a look at that next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种海盗行为稍微轻微一些，但仍值得一看。让我们看看下一个。
- en: Type III piracy – Extending with your own type, but for a different purpose
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ⅲ级海盗行为 – 使用你自己的类型，但用于不同的目的
- en: Type III piracy refers to the situation where a function is extended, but is
    used for a different purpose. It is the right procedure of extending code, but
    done in a bad way. This kind of piracy is also called a *pun *by the Julia developers.
    To understand what it is, let's consider a fun example here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ⅲ级海盗行为指的是扩展了函数，但用于不同的目的的情况。这是扩展代码的正确程序，但以错误的方式执行。这种海盗行为也被 Julia 开发者称为 *pun*。为了理解它是什么，让我们在这里考虑一个有趣的例子。
- en: 'Suppose that we are developing a simple party registration application. The
    type definition and constructor are shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个简单的派对注册应用程序。类型定义和构造函数如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Party` type contains just a title and an array of guest names. The constructor
    just takes the title and initializes the guest array as an empty array. Now, just
    to be cute, we can define a function for joining a party as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Party` 类型仅包含一个标题和一组嘉宾名称。构造函数仅接受标题并将嘉宾数组初始化为空数组。现在，为了显得可爱，我们可以定义一个如下所示的参加派对的函数：'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is an extension to the `join` method from `Base`. Why would we want to
    do that? Well, if we create the `join` function in our own namespace, then we
    can get into a naming conflict with the standard `join` function. To avoid handling
    that conflict, maybe it is easier to just extend the function from `Base`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Base` 中 `join` 方法的扩展。我们为什么要这样做呢？好吧，如果我们在我们自己的命名空间中创建 `join` 函数，那么我们可能会与标准
    `join` 函数发生命名冲突。为了避免处理这种冲突，也许直接从 `Base` 扩展函数更容易。
- en: 'At first glance, it would work as expected:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，它应该按预期工作：
- en: '![](img/fe6cd83a-ab76-44ad-9b78-a29c23dcc77b.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe6cd83a-ab76-44ad-9b78-a29c23dcc77b.png)'
- en: 'However, there is a hidden trap. If we were to let multiple people join the
    party at the same time, then we could get into trouble easily:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个隐藏的陷阱。如果我们让多个人同时参加派对，那么我们很容易陷入麻烦：
- en: '![](img/880ac20d-0858-48d9-abad-23375c8ded03.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/880ac20d-0858-48d9-abad-23375c8ded03.png)'
- en: 'What happened? Let''s take a look at the original meaning of the `join` function,
    as shown in the `help` screen:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？让我们看看 `join` 函数的原始含义，如 `help` 屏幕所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The purpose of the `join` function is to take multiple strings and put them
    together separated by some kind of delimiter. So the call to the `join` function
    in the preceding code ended up using the `Party` object as a delimiter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`join` 函数的目的是将多个字符串组合在一起，并用某种分隔符分隔。因此，前面代码中对 `join` 函数的调用最终使用了 `Party` 对象作为分隔符。'
- en: Let's think a little bit about how we got into trouble. When we defined the
    function using our own type (`Party`), we did not expect our function to be used
    by any other code except our own. However, that is not true here. Our function
    was clearly utilized by the string concatenation logic from the `Base` package.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微思考一下我们是如何陷入麻烦的。当我们使用自己的类型（`Party`）定义函数时，我们没有预料到我们的函数会被除我们自己的代码之外的任何代码使用。然而，这里并非如此。我们的函数显然被
    `Base` 包中的字符串连接逻辑所使用。
- en: It turns out that we are an unfortunate victim of *duck typing*. If you look
    into the source code of Julia, you will find that some `join` functions are defined
    without specifying any type in the arguments. So, when we pass a `Party` object
    to the `join` function, it leaks into the original `join` logic. Worse yet, no
    error was thrown because everything just *worked*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们是不幸的*鸭子类型*的受害者。如果你查看Julia的源代码，你会发现一些`join`函数在参数中未指定任何类型。因此，当我们向`join`函数传递`Party`对象时，它就会泄露到原始的`join`逻辑中。更糟糕的是，没有抛出错误，因为一切只是*正常工作*。
- en: It is best to avoid type III piracy altogether. In the preceding example, we
    could have defined the `join` function in our own module rather than extending
    the one from `Base`. If we are bothered by the name conflict issue, we can also
    choose a different function name—for example, `register`. We have to realize that
    the meaning of joining a party is not the same as joining strings together.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最好完全避免类型III盗用。在前面的例子中，我们可以在自己的模块中定义`join`函数，而不是扩展`Base`中的函数。如果我们被名称冲突问题所困扰，我们也可以选择不同的函数名——例如，`register`。我们必须意识到，加入一个派对的意义并不等同于将字符串连接起来。
- en: All three types of piracy are bad, and they can cause bugs that are surprisingly
    difficult to find or debug. We should avoid them as much as possible.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种盗用类型都是不好的，它们可能导致难以找到或调试的bug。我们应该尽可能地避免它们。
- en: Next, we will go over another anti-pattern related to specifying argument types
    in function definitions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论与函数定义中指定参数类型相关的另一种反模式。
- en: Narrow argument types anti-pattern
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 狭义参数类型反模式
- en: When designing functions in Julia, we have many options about whether and how
    to provide the type of arguments. The narrow argument types anti-pattern refers
    to the situation in which the types of the arguments are too narrowly specified,
    causing the function to be less useful unnecessarily.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中设计函数时，我们有很多关于是否以及如何提供参数类型的选择。狭义参数类型反模式指的是参数类型被过于狭窄地指定，导致函数不必要的无用。
- en: 'Let''s consider a simple example function that is used for computing the sum
    of the products of two vectors:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的示例函数，该函数用于计算两个向量的乘积之和：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is nothing wrong with this design, except that the function can only be
    used when the arguments are vectors of `Float64` values. What are the other possible
    options? Let's take a look at that next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计没有问题，只是功能只能在参数是`Float64`值向量时使用。其他可能的选择有哪些？让我们接下来看看。
- en: Considering various options for argument types
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑参数类型的各种选项
- en: Julia's dispatch mechanism can select the right function to call as long as
    the type of the arguments being passed matches the signature of the function.
    Based upon the type hierarchy, we can possibly specify abstract types and the
    function still gets selected properly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的调度机制可以在传递的参数类型与函数签名匹配的情况下选择正确的函数来调用。基于类型层次结构，我们可以指定抽象类型，并且函数仍然会被正确选择。
- en: 'Such flexibility gives us many options. We can consider any of the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性给我们提供了很多选择。我们可以考虑以下任何一种：
- en: '`sumprod(A::Vector{Float64}, B::Vector{Float64})`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sumprod(A::Vector{Float64}, B::Vector{Float64})`'
- en: '`sumprod(A::Vector{Number}, B::Vector{Number})`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sumprod(A::Vector{Number}, B::Vector{Number})`'
- en: '`sumprod(A::Vector{T}, B::Vector{T}) where T <: Number`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sumprod(A::Vector{T}, B::Vector{T}) where T <: Number`'
- en: '`sumprod(A::Vector{S}, B::Vector{T}) where {S <: Number, T <: Number}`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sumprod(A::Vector{S}, B::Vector{T}) where {S <: Number, T <: Number}`'
- en: '`sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number}`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number}`'
- en: '`sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N, S <: Number,
    T <: Number}`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N, S <: Number,
    T <: Number}`'
- en: '`sumprod(A, B)`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sumprod(A, B)`'
- en: Which one is the most appropriate option for our function? We're not sure yet,
    but we can always revisit our requirements and perform some testing before drawing
    a conclusion.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能最合适的选项是哪一个？我们还没有确定，但我们可以始终回顾我们的需求，在得出结论之前进行一些测试。
- en: 'Let''s first define what scenarios we plan to support. As we expect, this is
    just a numeric calculation: we would like to support any numeric container that
    supports broadcasting. Broadcasting is required because we use dot notation when
    calculating the product of A and B in the preceding code.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义我们计划支持的场景。正如我们所期望的，这只是一个数值计算：我们希望支持任何支持广播的数值容器。广播是必需的，因为我们使用点符号来计算前面代码中A和B的乘积。
- en: 'Our test scenarios involve the following combinations of arguments:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试场景涉及以下参数组合：
- en: '| **Scenario** | **Argument 1** | **Argument 2** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **场景** | **参数 1** | **参数 2** |'
- en: '| 1 | `Array{Float64, 1}` | `Array{Float64, 1}` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `Array{Float64, 1}` | `Array{Float64, 1}` |'
- en: '| 2 | `Array{Int64, 1}` | `Array{Int64, 1}` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `Array{Int64, 1}` | `Array{Int64, 1}` |'
- en: '| 3 | `Array{Int, 1}` | `Array{Float64, 1}` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `Array{Int, 1}` | `Array{Float64, 1}` |'
- en: '| 4 | `Array{Float64, 2}` | `Array{Float64, 2}` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `Array{Float64, 2}` | `Array{Float64, 2}` |'
- en: '| 5 | `Array{Number,1}` | `Array{Number,1}` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `Array{Number,1}` | `Array{Number,1}` |'
- en: 'To test these scenarios for various function signature options, we can build
    a test harness function, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试各种函数签名选项的这些场景，我们可以构建一个测试框架函数，如下所示：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The test harness applies function `f` with the provided arguments `args` for
    a specific `scenario`. If the function is dispatched, it displays a success message
    in the console; otherwise, it displays a failure message. As we want to test the
    preceding listed scenarios, we can define just one more function so that we can
    execute our tests easily:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架将函数 `f` 与提供的参数 `args` 对特定 `scenario` 进行应用。如果函数被调度，它将在控制台显示成功消息；否则，它将显示失败消息。由于我们想要测试前面列出的场景，我们可以定义一个额外的函数，这样我们就可以轻松地执行我们的测试：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `test_sumprod` function takes a function and executes the five preceding
    test cases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_sumprod` 函数接受一个函数并执行前五个测试用例。'
- en: Now we are all set. Let's dissect each option and see how well they work for
    us.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了。让我们分析每个选项，看看它们对我们有多有效。
- en: Option 1 – Vectors of Float64 values
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项 1 – `Float64` 值的向量
- en: The first option is what we started with at the beginning of this section. It
    has the most specific types of arguments. The drawback is that it can only work
    with a vector of `Float64` values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是我们在这个部分开始时使用的。它具有最具体的参数类型。缺点是它只能与 `Float64` 值的向量一起工作。
- en: 'Let''s define our function as follows so that we can pass it to the testing
    function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式定义我们的函数，以便我们可以将其传递给测试函数：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can try our test harness now:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试我们的测试框架了：
- en: '![](img/722c66c6-4c47-4dd5-bfb4-69630ca827e8.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/722c66c6-4c47-4dd5-bfb4-69630ca827e8.png)'
- en: As expected, this function can work with the first scenario when both arguments
    are vectors of `Float64` values. So it does not satisfy all of our requirements.
    Let's try the next option.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这个函数可以在两个参数都是 `Float64` 值的向量时与第一个场景一起工作。因此，它并不满足我们的所有要求。让我们尝试下一个选项。
- en: Option 2 – Vectors of instances of Number
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项 2 – `Number` 实例的向量
- en: 'The second option is a little more interesting. We have switched the type parameter
    from `Float64` to `Number`, which is the topmost abstract type in the numeric
    type hierarchy:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项稍微有趣一些。我们将类型参数从 `Float64` 更改为 `Number`，这是数值类型层次结构中最顶层的抽象类型：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s test it now:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试一下：
- en: '![](img/be78eef1-fd52-43b2-98e9-7f799d0439f2.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be78eef1-fd52-43b2-98e9-7f799d0439f2.png)'
- en: 'At first glance, it may appear that using `Number` as a type parameter would
    make it more generic. It turns that out that it can only accept an array of `Number`
    types, which means that it has to be a heterogenous array where each element can
    be a different type as long as all element types are subtypes of `Number`. For
    that reason, a vector of `Float64` values is not a subtype of a vector of `Number`
    values. Check the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，使用 `Number` 作为类型参数似乎会使它更通用。但实际上，它只能接受 `Number` 类型的数组，这意味着它必须是一个异构数组，其中每个元素可以是不同类型，只要所有元素类型都是
    `Number` 的子类型。因此，`Float64` 值的向量不是 `Number` 值向量的子类型。请检查以下代码片段：
- en: '![](img/d2da93bb-6858-4bd4-9ad8-b4db15d9ff03.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2da93bb-6858-4bd4-9ad8-b4db15d9ff03.png)'
- en: For that reason, none of the scenarios was successful except the last one, which
    takes vectors of `Number` exactly as arguments. So this option is not a great
    one either. Let's move on!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了最后一个选项之外，没有任何场景成功，最后一个选项接受 `Number` 类型的向量作为参数。所以这个选项也不是一个好的选择。让我们继续前进！
- en: Option 3 – Vectors of type T where T is a subtype of Number
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项 3 – 类型为 T 的向量，其中 T 是 `Number` 的子类型
- en: The third option is to take vectors of type `T`, where `T` is just a subtype
    of `Number`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项是取类型为 `T` 的向量，其中 `T` 只是 `Number` 的子类型。
- en: 'The function can be defined as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以定义如下：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s try it first:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先试一下：
- en: '![](img/da1489bb-1a10-4dbb-85c2-bc4258a76abb.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da1489bb-1a10-4dbb-85c2-bc4258a76abb.png)'
- en: As the type parameter `T` can be any subtype of `Number`, this function comfortably
    handles vectors of `Float64`, `Int64`, and even `Number` types. Unfortunately,
    it cannot handle arguments of different types, but we should be able to improve
    it further. Let's try the next option.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型参数 `T` 可以是 `Number` 的任何子类型，这个函数可以舒适地处理 `Float64`、`Int64` 以及甚至 `Number` 类型的向量。不幸的是，它不能处理不同类型的参数，但我们应该能够进一步改进它。让我们尝试下一个选项。
- en: Option 4 – Vectors of type S and T where S and T are subtypes of Number
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项 4 – 类型为 S 和 T 的向量，其中 S 和 T 是 Number 的子类型
- en: 'This option differs from option 3 only in the way that the types of arguments
    are separately specified. Thus, the function can accept different types for the
    first and second arguments. The function is defined as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项与选项 3 的区别仅在于参数类型是分别指定的。因此，函数可以接受第一和第二个参数的不同类型。函数定义如下：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can try it now:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试一下：
- en: '![](img/54817012-bf9b-4a6e-9382-4435067dc8aa.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54817012-bf9b-4a6e-9382-4435067dc8aa.png)'
- en: We have definitely addressed the issue with mixed argument types by now. We're
    getting close to the final destination. Scenario 4 is the case where the arguments
    are matrices rather than vectors. For sure we know how to fix this, so let's do
    that next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经解决了混合参数类型的问题。我们越来越接近最终目标。场景 4 是参数是矩阵而不是向量的情况。我们当然知道如何解决这个问题，所以让我们接下来做。
- en: Option 5 – Arrays of type S and type T where S and T are subtypes of Number
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项 5 – 类型为 S 和 T 的数组，其中 S 和 T 是 Number 的子类型
- en: 'Since Julia arrays support broadcasting, we can generalize the function arguments
    from a `Vector{T}` to an `Array{T,N}` signature in order to support multidimensional
    arrays. Let''s now define the function as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Julia 数组支持广播，我们可以将函数参数从 `Vector{T}` 通用化到 `Array{T,N}` 签名，以支持多维数组。现在让我们定义函数如下：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have pretty good confidence that this would work. Let''s test it now:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相当有信心这会起作用。现在让我们测试它：
- en: '![](img/2c8503b9-bb20-493c-9990-442b3e64bb31.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c8503b9-bb20-493c-9990-442b3e64bb31.png)'
- en: '*Fabulous!* We have finally satisfied all the requirements as listed in the
    test scenarios. Are we done? Maybe not. For the sake of argument, we may want
    to support other types of containers that are not necessarily a dense array. What
    if the input is sparse matrices? Let''s improve the function once again.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*太棒了!* 我们终于满足了测试场景中列出的所有要求。我们完成了吗？也许还没有。为了辩论，我们可能希望支持其他类型的容器，这些容器不一定是密集数组。如果输入是稀疏矩阵怎么办？让我们再次改进这个函数。'
- en: Option 6 – Abstract arrays
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项 6 – 抽象数组
- en: 'The `AbstractArray` is the abstract type for all Julia array containers. Many
    Julia packages implement the array interface and are made to be subtypes of `AbstractArray`.
    It would be a shame if we go so far to make the `sumprod` function versatile enough,
    and yet we cannot support sparse matrices or other types of array-type containers.
    To make it more general, let''s turn our function definition from `Array` to `AbstractArray`
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractArray` 是所有 Julia 数组容器的抽象类型。许多 Julia 包实现了数组接口，并成为 `AbstractArray` 的子类型。如果我们把
    `sumprod` 函数做得足够通用，却不能支持稀疏矩阵或其他类型的数组容器，那就太遗憾了。为了使其更通用，让我们将函数定义从 `Array` 转换为 `AbstractArray`，如下所示：'
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The signature is the same as the previous option, except that the function
    can be dispatched with any `AbstractArray` container types. Let''s make sure that
    the function works as expected:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 签名与上一个选项相同，只是函数可以使用任何 `AbstractArray` 容器类型进行分发。让我们确保函数按预期工作：
- en: '![](img/5635c61d-1a34-464e-a158-c11fd39e2365.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5635c61d-1a34-464e-a158-c11fd39e2365.png)'
- en: 'The function is working properly for our existing cases. Let''s just try it
    once again using the sparse matrix type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在我们的现有案例中运行正常。让我们再次尝试使用稀疏矩阵类型来测试它：
- en: '![](img/159e5aa8-4b96-44ac-8563-39a8cfb6f1b1.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/159e5aa8-4b96-44ac-8563-39a8cfb6f1b1.png)'
- en: '*Bravo!* It is working great now, even with a non-dense array type. We are
    almost done. Let''s look at our last option—duck typing.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*太棒了!* 现在它运行得很好，甚至是非密集数组类型。我们几乎完成了。让我们看看我们的最后一个选项——鸭式类型。'
- en: Option 7 – Duck typing
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项 7 – 鸭式类型
- en: 'Our last option basically skips the types in the function arguments. This is
    also called duck typing, as the function will be dispatched as long as two arguments
    are provided. Julia will specialize and compile a new version for different variations
    of the argument types. The function is simply defined as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个选项基本上跳过了函数参数中的类型。这也被称为鸭式类型，因为只要提供了两个参数，函数就会被分发。Julia 将针对不同参数类型的变体进行特化和编译新版本。函数简单地定义为如下：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For completeness, we will run the test again:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，我们将再次运行测试：
- en: '![](img/102bb95c-6403-4519-9065-5a400edd9561.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/102bb95c-6403-4519-9065-5a400edd9561.png)'
- en: The benefit of this option is that the function is free of type information
    in the signature, so it looks very clean. However, the drawback is that the function
    can be dispatched for any type—not even an array or for numeric values. When garbage
    is passed into the function, garbage comes out, or the function just throws an
    error when the objects being passed do not have the `*` operator function defined.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项的好处是函数在签名中没有类型信息，看起来非常干净。然而，缺点是函数可以针对任何类型进行分发——甚至不是数组或数值。当垃圾数据传递给函数时，输出也是垃圾，或者当传递的对象没有定义`*`运算符函数时，函数会抛出错误。
- en: Now that we have considered all the options and performed the respective tests,
    let's summarize what we have done so far and what we would want to do next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经考虑了所有选项并执行了相应的测试，让我们总结一下到目前为止我们已经做了什么，以及我们接下来想做什么。
- en: Summarizing all options
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结所有选项
- en: 'Let''s now summarize all the options that we have considered so far:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在总结一下到目前为止我们已经考虑的所有选项：
- en: '| **Option** | **Signature** | **Passed all tests?** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **签名** | **所有测试都通过吗？** |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | `sumprod(A::Vector{Float64}, B::Vector{Float64})` | No |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `sumprod(A::Vector{Float64}, B::Vector{Float64})` | 否 |'
- en: '| 2 | `sumprod(A::Vector{Number}, B::Vector{Number})` | No |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `sumprod(A::Vector{Number}, B::Vector{Number})` | 否 |'
- en: '| 3 | `sumprod(A::Vector{T}, B::Vector{T}) where T <: Number` | No |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `sumprod(A::Vector{T}, B::Vector{T}) where T <: Number` | 否 |'
- en: '| 4 | `sumprod(A::Vector{S}, B::Vector{T}) where {S <: Number, T <: Number}`
    | No |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `sumprod(A::Vector{S}, B::Vector{T}) where {S <: Number, T <: Number}`
    | 否 |'
- en: '| 5 | `sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number}`
    | Yes |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `sumprod(A::Array{S,N}, B::Array{T,N}) where {N, S <: Number, T <: Number}`
    | 是 |'
- en: '| 6 | `sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N, S <:
    Number, T <: Number}` | Yes |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 6 | `sumprod(A::AbstractArray{S,N}, B::AbstractArray{T,N}) where {N, S <:
    Number, T <: Number}` | 是 |'
- en: '| 7 | `sumprod(A, B)` | Yes |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `sumprod(A, B)` | 是 |'
- en: Technically speaking, options 5, 6, or 7 could work for all array types. Options
    6 and 7 support other array containers, such as sparse matrix. Option 7 works
    with non-`AbstractArray` types, as long as the type is broadcasting multiplication
    as well as summation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，选项5、6或7可以适用于所有数组类型。选项6和7支持其他数组容器，例如稀疏矩阵。选项7与非`AbstractArray`类型一起工作，只要类型支持广播乘法和加法。
- en: Before we draw our conclusion, let's do one last test from a performance perspective.
    Do you wonder whether making the function accept more general types would sacrifice
    performance? The only way to know this is to prove it with real experiments. Let's
    do that next.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们得出结论之前，让我们从性能的角度进行最后一次测试。你是否想知道让函数接受更通用的类型是否会牺牲性能？了解这一点唯一的方法是通过实际实验来证明。让我们接下来这么做。
- en: Evaluating performance
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估性能
- en: Do we sacrifice performance when we make the functions accept more general types
    in their arguments? Let's do some benchmarking tests and see how they perform.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在函数参数中接受更通用的类型时，我们会牺牲性能吗？让我们进行一些基准测试，看看它们的性能如何。
- en: 'Here, we will benchmark the functions for options 1, 5, 6, and 7 using exactly
    the same input: two `Float64` vectors with 10,000 elements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用完全相同的输入：两个包含10,000个元素的`Float64`向量，对选项1、5、6和7中的函数进行基准测试：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here are the test results:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是测试结果：
- en: '![](img/a1901151-46ea-4338-810e-3f66c7fb9b88.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1901151-46ea-4338-810e-3f66c7fb9b88.png)'
- en: As you can see, there is no material difference between these options. How the
    argument types are specified does not affect the runtime performance of the function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些选项之间没有实质性的差异。如何指定参数类型不会影响函数的运行时性能。
- en: In summary, what we have learned about this anti-pattern is that the function
    argument should not be made too narrow unnecessarily. A function can be much more
    useful when the *net* is cast wide. A function that can accept and support more
    input types is automatically more reusable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们关于这种反模式学到的经验是，函数参数不应该无必要地设置得太窄。当范围广泛时，一个函数可以更加有用。一个可以接受和支持更多输入类型的函数自动具有更高的可重用性。
- en: Our next anti-pattern relates to how field types should be chosen when designing
    data types. This is an extremely important topic as it can dramatically affect
    system performance.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个反模式与设计数据类型时如何选择字段类型有关。这是一个极其重要的话题，因为它可以显著影响系统性能。
- en: Nonconcrete field types anti-pattern
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非具体字段类型反模式
- en: The nonconcrete field types anti-pattern is an anti-pattern in which a struct
    field is not concrete. The main problem with nonconcrete types for fields is that
    they can cause major performance problems. To understand why, let's take a look
    at the memory layout for composite types that have nonconcrete versus concrete
    types, then design and compare the two.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 非具体字段类型的反模式是一种结构字段不是具体类型的反模式。对于字段的非具体类型的主要问题是它们可能会引起重大的性能问题。为了理解为什么，让我们看看具有非具体类型与具体类型组合类型的内存布局，然后设计和比较这两个。
- en: Understanding the memory layout of composite data types
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解复合数据类型的内存布局
- en: 'Let''s first take a look at a simple example for a composite type for tracking
    the coordinates of a point:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看一个用于跟踪点坐标的复合类型的简单例子：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the field type is not specified, it is implicitly interpreted as `Any`,
    the super type of all types, hence the preceding code is syntactically equivalent
    to the following (except that we have renamed the type name as `Point2` to avoid
    confusion):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当字段类型未指定时，它隐式地解释为所有类型的超类型 `Any`，因此前面的代码在语法上等同于以下代码（除了我们将类型名称重命名为 `Point2` 以避免混淆）：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The fields `x` and `y` have the `Any` type, meaning that they can be anything:
    `Int64`, `Float64`, or any other data type. To compare the memory layout and utilization,
    it is worth creating a new point type that uses a small concrete type, such as
    `UInt8`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 字段 `x` 和 `y` 有 `Any` 类型，这意味着它们可以是任何东西：`Int64`、`Float64` 或任何其他数据类型。为了比较内存布局和利用率，值得创建一个新的点类型，它使用小的具体类型，如
    `UInt8`：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we know, `UInt8` should occupy a single byte of storage. Having both `x`
    and `y` fields should consume only two bytes of storage. Perhaps we should just
    prove it to ourselves. Check the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，`UInt8` 应该占用单个字节的存储空间。`x` 和 `y` 字段同时存在应该只消耗两个字节的存储空间。也许我们应该亲自证明这一点。检查以下代码：
- en: '![](img/d8c30dcb-bb09-4f8f-946b-a82ad0479b39.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8c30dcb-bb09-4f8f-946b-a82ad0479b39.png)'
- en: 'Clearly, a single `Point3` object only occupies two bytes. Let''s do the same
    with the original `Point` object:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 明显地，一个单独的 `Point3` 对象只占用两个字节。让我们用原始的 `Point` 对象做同样的操作：
- en: '![](img/1fdf8554-09ac-4a38-be2a-a858b3e6dea0.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fdf8554-09ac-4a38-be2a-a858b3e6dea0.png)'
- en: 'The `Point` object takes 16 bytes, even though we want to store just two bytes.
    As we know, the `Point` object can take any data type in the `x` and `y` fields.
    Now, let''s do the same exercise with a larger data type, such as `Int128`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point` 对象占用 16 字节，尽管我们只想存储两个字节。正如我们所知，`Point` 对象可以在 `x` 和 `y` 字段中存储任何数据类型。现在，让我们用更大的数据类型，如
    `Int128`，来做同样的练习：'
- en: '![](img/5f3561d8-0ee6-42d1-a404-e3cf5fdda73a.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f3561d8-0ee6-42d1-a404-e3cf5fdda73a.png)'
- en: An `Int128` is a 128-bit integer, which occupies 16 bytes in memory. Interestingly,
    even though we are carrying two `Int128` fields in `Point`, the size of the object
    remains as 16 bytes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int128` 是一个 128 位整数，在内存中占用 16 字节。有趣的是，尽管我们在 `Point` 中携带了两个 `Int128` 字段，但对象的大小仍然保持在
    16 字节。'
- en: 'Why? It is because `Point` actually stores two 64-bit pointers, each occupying
    eight bytes of storage. We can visualize the memory of a `Point` object as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？这是因为 `Point` 实际上存储了两个 64 位指针，每个指针占用八字节的存储空间。我们可以这样可视化 `Point` 对象的内存：
- en: '![](img/2c98b9c7-d7ba-4406-90fd-90b099bfa974.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c98b9c7-d7ba-4406-90fd-90b099bfa974.png)'
- en: 'When the field types are concrete, the Julia compiler knows exactly what the
    memory layout looks like. With two `UInt8` fields, it is compactly represented
    with two bytes. With two `Int128` fields, it will occupy 32 bytes. Let''s try
    that in REPL:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当字段类型是具体的时，Julia 编译器确切地知道内存布局看起来像什么。对于两个 `UInt8` 字段，它以紧凑的方式用两个字节表示。对于两个 `Int128`
    字段，它将占用 32 字节。让我们在 REPL 中尝试一下：
- en: '![](img/9a3be4a1-1026-4805-bdc6-3a5e034f7b5d.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a3be4a1-1026-4805-bdc6-3a5e034f7b5d.png)'
- en: 'The memory layout of `Point4` is compact, as shown in the following diagram:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point4` 的内存布局紧凑，如下面的图所示：'
- en: '![](img/91ca4f89-99a9-4356-90da-2bb55bc4967f.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91ca4f89-99a9-4356-90da-2bb55bc4967f.png)'
- en: Now that we know the difference in memory layout, we can immediately see the
    benefits of using concrete types. Every time we need to access the `x` or `y`
    field, if it is a concrete type, then the data is right there. If the fields are
    just pointers, then we have to dereference the pointer to find the data. Furthermore,
    the physical memory locations of `x` and `y` may not even be adjacent to each
    other, which may cause hardware cache misses, further hurting performance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了内存布局的差异，我们可以立即看到使用具体类型的优势。每次我们需要访问`x`或`y`字段时，如果它是具体类型，那么数据就在那里。如果字段只是指针，那么我们必须取消引用指针以找到数据。此外，`x`和`y`的物理内存位置可能甚至不相邻，这可能导致硬件缓存未命中，从而进一步影响性能。
- en: So, do we just follow the rule of using concrete types directly in the field
    definitions? Not necessarily. There are other options that we can consider, which
    we will do in the following sections.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们是否只是遵循在字段定义中直接使用具体类型的规则？不一定。我们还有其他可以考虑的选项，我们将在接下来的章节中讨论。
- en: Designing composite types with concrete types in mind
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑具体类型设计复合类型
- en: Perhaps the reason why we use abstract types in the fields in the first place
    is to support different types of data in the field. Taking the `Point` type in
    the previous section, we can see that the type can be useful in the context of
    computer games, where the coordinates are identified by integer pixel positions
    on the screen. On the other hand, we also think that the same type may be useful
    for storing coordinates of shapes in architectural diagrams, in which case, we
    would want floating-point values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们最初在字段中使用抽象类型的原因是为了支持字段中的不同类型数据。以上一节中的`Point`类型为例，我们可以看到这种类型在计算机游戏环境中非常有用，因为在游戏中坐标是通过屏幕上的整数像素位置来识别的。另一方面，我们也认为同样的类型可能对存储建筑图纸中形状的坐标也很有用，在这种情况下，我们可能需要使用浮点值。
- en: 'If we want to be flexible, we would want to support `Point` fields with any
    subtype of the `Real` type. Conceptually, we want something like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更灵活，我们希望支持任何`Real`类型的子类型的`Point`字段。从概念上讲，我们希望得到如下所示的东西：
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, since `Real` is an abstract type, we would expect poor performance,
    just like we would with `Any`. In order to utilize concrete types without sacrificing
    the flexibility of supporting other numeric types, we can turn `Point` into a
    parametric type. Let''s restart the REPL and define the new `Point` type, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`Real`是一个抽象类型，我们预计性能会较差，就像使用`Any`一样。为了在不牺牲支持其他数值类型灵活性的情况下利用具体类型，我们可以将`Point`转换为参数化类型。让我们重新启动REPL并定义新的`Point`类型，如下所示：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Making it a parametric type has the benefit of being concrete. We can check
    this out easily from the REPL. The following is a basic syntax implementation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将其设计为参数化类型的好处是它是具体的。我们可以很容易地从REPL中检查这一点。以下是一个基本的语法实现：
- en: '![](img/a3d52d8d-c736-41ba-a950-3be3e02c793c.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3d52d8d-c736-41ba-a950-3be3e02c793c.png)'
- en: 'The following code shows another example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了另一个示例：
- en: '![](img/26adba53-dedf-4318-88fb-81544d3e20f0.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26adba53-dedf-4318-88fb-81544d3e20f0.png)'
- en: So far, we have been assuming that concrete types would outperform nonconcrete
    types in `struct` fields. It would be nice to get an idea of how much difference
    it makes. Let's try that now.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直假设在`struct`字段中，具体类型会比非具体类型表现更好。了解这种差异有多大会有所帮助。现在让我们试试看。
- en: Comparing performance between concrete versus nonconcrete field types
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较混凝土与非混凝土字段类型之间的性能
- en: 'We can run a performance test with these two different types, depicted here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这两种不同的类型进行性能测试，如下所示：
- en: 'Our benchmark test function will compute the center of all points from an array,
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基准测试函数将计算数组中所有点的中心，如下所示：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In addition, we will also define a function that can be used to make an array
    of points for whatever type we want:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将定义一个函数，可以用于为任何我们想要的类型创建点的数组：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's start with a `PointAny` type.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`PointAny`类型开始。
- en: 'We will generate 100,000 points and use `BenchmarkTools` to measure the time:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成100,000个点，并使用`BenchmarkTools`来测量时间：
- en: '![](img/ae24af37-f0f9-436e-844b-32fb0928c388.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae24af37-f0f9-436e-844b-32fb0928c388.png)'
- en: 'Next, we will run the performance test for the `Point` type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对`Point`类型进行性能测试：
- en: '![](img/3ad4d592-b2c5-4588-8518-b2b09f27476e.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ad4d592-b2c5-4588-8518-b2b09f27476e.png)'
- en: As we can see, there is a huge difference between the two. Using the parametric
    `Point` type is approximately 25 times faster than the one that uses `Any` as
    a field type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两者之间存在着巨大的差异。使用参数化`Point`类型比使用`Any`作为字段类型的速度快约25倍。
- en: What we have learned from this anti-pattern is that we should use concrete types
    for fields defined in composite types. It is quite easy to *factor out* the abstract
    type we want into a type parameter. Doing this allows us to gain performance benefits
    from concrete types without sacrificing the ability to support other data types.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个反模式中我们学到的经验是，我们应该为在复合类型中定义的字段使用具体类型。将我们想要的抽象类型**提取出来**作为一个类型参数是非常容易的。这样做可以让我们在不牺牲支持其他数据类型能力的情况下，从具体类型中获得性能上的好处。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about several anti-patterns in Julia programming.
    When we went over details for each anti-pattern, we also figured out how to apply
    alternative design solutions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Julia编程中的一些反模式。当我们详细研究每个反模式时，我们也找到了应用替代设计解决方案的方法。
- en: We began with the piracy anti-pattern, which refers to bad practices as related
    to extending functions from a third-party module. For convenience, we classified
    piracy anti-patterns into three different types—type I, II, and III. Each type
    poses a different problem in causing the system to become unstable or potentially
    invite problems in the future.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从盗版反模式开始，它指的是与从第三方模块扩展函数相关的坏习惯。为了方便起见，我们将盗版反模式分为三种不同类型——I型、II型和III型。每种类型都会在导致系统不稳定或未来可能引起问题的过程中带来不同的问题。
- en: Next, we looked into the narrow argument types anti-pattern. When function arguments
    are too narrowly specified, they become less reusable. Because Julia can specialize
    the function for various argument types, it is more beneficial to make argument
    types as general as possible, utilizing abstract types. We went through several
    design options in great detail, and concluded that the most general types can
    be used without sacrificing performance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了狭隘的参数类型反模式。当函数参数过于狭窄时，它们的可重用性会降低。因为Julia可以为各种参数类型对函数进行特殊化，所以尽可能使参数类型通用化，利用抽象类型，这样做更有益。我们详细探讨了几个设计选项，并得出结论：最通用的类型可以在不牺牲性能的情况下使用。
- en: Finally, we reviewed the nonconcrete field types anti-pattern. We proved that
    having nonconcrete types poses a performance problem because of the resulting
    inefficient memory layout structure. We figured that the problem can be solved easily by
    using parametric types, specifying concrete types as part of the type parameters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了非具体字段类型反模式。我们证明了由于产生的低效内存布局结构，拥有非具体类型会带来性能问题。我们推测，这个问题可以通过使用参数类型，将具体类型指定为类型参数的一部分来轻松解决。
- en: 'In the next chapter, we will turn our attention to traditional object-oriented
    design patterns and see how they can be applied in Julia programming. *Fasten
    your seat belt: if you used to be an OOP programmer, your ride may be a little
    bumpy! *'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注传统的面向对象设计模式，并探讨它们如何在Julia编程中应用。*系好安全带：如果你曾经是面向对象程序员，你的旅程可能会有些颠簸！*
- en: Questions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the risks and potential benefits of type I piracy?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型I盗版的风险和潜在好处是什么？
- en: What kind of problems can arise from type II piracy?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型II盗版可能引发什么问题？
- en: How does type III piracy cause trouble?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型III盗版是如何引起麻烦的？
- en: What should we watch out for when specifying function arguments?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定函数参数时我们应该注意什么？
- en: How is system performance affected by using abstract function arguments?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用抽象函数参数会如何影响系统性能？
- en: How is system performance affected by using abstract field types for composite
    types?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用抽象字段类型为复合类型时，系统性能会受到怎样的影响？
