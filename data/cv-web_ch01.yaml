- en: Chapter 1. Math Never Was So Simple!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章  数学从未如此简单！
- en: Computer Vision is all about math. When you need to create your own algorithm
    or implement something, you address a math topic. You should know how it works
    on the inside because without digging into the basics, it is hard to do anything.
    But you are not alone! Many smart people have created several useful libraries
    to simplify your job. One of those libraries is JSFeat ([http://inspirit.github.io/jsfeat/](http://inspirit.github.io/jsfeat/)),
    which has a realization of different math methods. Here, we will discuss fundamental
    elements of the library such as data structures, especially matrices, and simple
    math algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉全靠数学。当你需要创建自己的算法或实现某些功能时，你将面对一个数学问题。你应该了解其内部是如何工作的，因为没有深入到基础知识，很难做任何事情。但你不孤单！许多聪明的人已经创建了几个有用的库来简化你的工作。其中之一就是JSFeat（[http://inspirit.github.io/jsfeat/](http://inspirit.github.io/jsfeat/)），它实现了不同的数学方法。在这里，我们将讨论库的基本元素，如数据结构，特别是矩阵，以及简单的数学算法。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Installation and core structure representation of JSFeat
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSFeat的安装和核心结构表示
- en: What is inside an image? All about matrices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像内部是什么？所有关于矩阵
- en: Useful functions and where to use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的函数及其使用位置
- en: Installation and core structure representation of JSFeat
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSFeat的安装和核心结构表示
- en: JSFeat is a powerful tool to implement something new. To start using it, we
    need to initialize the project. It is relatively simple; if you have any experience
    with JavaScript, then it will not cause any trouble for you. The library itself
    contains various Computer Vision algorithms and it will be a good starting point
    for anyone who wants a flexible Computer Vision framework. First, you will learn
    how to install it and see a basic example of what you can do with the library.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JSFeat是一个强大的工具，可以用来实现新的功能。要开始使用它，我们需要初始化项目。这相对简单；如果你有JavaScript的经验，那么这不会给你带来任何麻烦。这个库本身包含各种计算机视觉算法，对于想要一个灵活的计算机视觉框架的人来说，它将是一个很好的起点。首先，你将学习如何安装它，并看到使用这个库可以做什么的基本示例。
- en: Initializing the project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'First of all, you need to download the JSFeat library and add it to your webpage.
    It is simple and it looks similar to this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要下载JSFeat库并将其添加到你的网页中。这很简单，看起来就像这样：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we just added a JavaScript library here without any additional
    actions. We do not need any particular software, since JavaScript is fast enough
    for many Computer Vision tasks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只是在这里添加了一个JavaScript库，没有进行任何额外的操作。我们不需要任何特定的软件，因为JavaScript对于许多计算机视觉任务来说已经足够快了。
- en: The core data structure for the JSFeat library is a matrix. We will cover more
    topics about matrices in the next section, but to check whether everything works
    correctly, let's try to create an example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JSFeat库的核心数据结构是矩阵。我们将在下一节中详细介绍矩阵的更多内容，但为了检查一切是否正常工作，让我们尝试创建一个示例。
- en: 'Add the following code to a `<script/>` tag:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`<script/>`标签中：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see the following in your console:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在你的控制台中看到以下内容：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we create a new matrix with the dimensions of 3 x 3 and
    an unsigned byte type with one channel. Next, we set a few elements into it and
    log the content of the matrix into the console row by row. The matrix data is
    presented as a one-dimensional array. Remember this, we will clarify it in the
    next section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个3 x 3维度的矩阵，数据类型为无符号字节，单通道。接下来，我们将一些元素放入其中，并按行将矩阵的内容记录到控制台。矩阵数据以一维数组的形式呈现。记住这一点，我们将在下一节中详细说明。
- en: Finally, you did it! You have successfully added the JSFeat Computer Vision
    library to your first project. Now, we will discuss what a matrix actually is.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你做到了！你已经成功地将JSFeat计算机视觉库添加到了你的第一个项目中。现在，我们将讨论矩阵实际上是什么。
- en: Understanding a digital image
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数字图像
- en: It is likely that you already know that an image consists of pixels, which is
    a big step in understanding image processing. You already saw in the previous
    topics that a matrix is just a one-dimensional array. However, it represents two-dimensional
    array and its elements are presented in a row-major order layout. It is more efficient
    in terms of speed and memory to create a matrix in such a way. Our images are
    two dimensional too! Each pixel reflects the value of an array element. Consequently,
    it is obvious that a matrix is the best structure for image representation. Here,
    we will see how to work with a matrix and how to apply matrix conversion operations
    on an image.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道，图像由像素组成，这是理解图像处理的一大步。在先前的主题中，你已经看到矩阵只是一个一维数组。然而，它代表的是二维数组，其元素以行主序布局呈现。以这种方式创建矩阵在速度和内存效率方面更为优越。我们的图像也是二维的！每个像素反映了数组元素的价值。因此，很明显，矩阵是图像表示的最佳结构。在这里，我们将看到如何处理矩阵以及如何在图像上应用矩阵转换操作。
- en: Loading an image into a matrix
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图像加载到矩阵中
- en: 'The JSFeat library uses its own data structure for matrices. First, we load
    an image using regular HTML and JavaScript operations. We then place a canvas
    on our webpage:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JSFeat库使用其自己的矩阵数据结构。首先，我们使用常规的HTML和JavaScript操作加载一个图像。然后我们在网页上放置一个画布：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then we need to place an image here. We do this with just a few lines of code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要在这里放置一个图像。我们只需几行代码就能做到：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is just a common way of displaying an image on a canvas. We define the
    image source path, and when the image is loaded, we set the canvas dimensions
    to those of an image and draw the image itself. Let''s move on. Loading a canvas''
    content into a matrix is a bit tricky. Why is that? We need to use a `jsfeat.data_t`
    method, which is a data structure that holds a binary representation of an array.
    Anyway, since it is just a wrapper for the JavaScript ArrayBuffer, it should not
    be a problem:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将图像显示在画布上的常见方法。我们定义图像源路径，当图像加载完成后，我们将画布的尺寸设置为图像的尺寸，并绘制图像本身。让我们继续前进。将画布的内容加载到矩阵中有点棘手。为什么？我们需要使用`jsfeat.data_t`方法，这是一个包含数组二进制表示的数据结构。无论如何，由于它只是JavaScript
    ArrayBuffer的包装器，所以应该不会有问题：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we create a matrix as we did earlier, but in addition to that we add a
    new parameter, matrix buffer, which holds all the necessary data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个矩阵，就像我们之前做的那样，但除此之外，我们还添加了一个新的参数，即矩阵缓冲区，它包含所有必要的数据。
- en: 'Probably, you already noticed that the third parameter for the matrix construction
    looks strange. It sets the type of matrix. Matrices have two properties:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你已经注意到矩阵构造的第三个参数看起来很奇怪。它设置了矩阵的类型。矩阵有两个属性：
- en: The first part represents the type of data in the matrix. In our example, it
    is `U8_t`; it states that we use unsigned byte array. Usually, an image uses 0-255
    range for a color representation, that is why we need bytes here.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分表示矩阵中的数据类型。在我们的例子中，它是`U8_t`；它表示我们使用无符号字节数组。通常，图像使用0-255的范围来表示颜色，这就是为什么我们需要字节。
- en: Remember that an image consists of 3 main channels (red, green, and blue) and
    an alpha channel. The second part of the parameter shows the number of channels
    we use for the matrix. If there is only one channel, then it is a grayscale image.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，一个图像由3个主要通道（红色、绿色和蓝色）和一个透明度通道组成。参数的第二部分显示了矩阵中使用的通道数。如果只有一个通道，那么它就是一个灰度图像。
- en: How do we convert a colored image into a grayscale image? For the answer, we
    must move to the next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将彩色图像转换为灰度图像？要找到答案，我们必须转到下一节。
- en: Basic matrix operations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本矩阵操作
- en: Working with matrices is not easy. Who are we to fear the difficulties? With
    the help of this section, you will learn how to combine different matrices to
    produce interesting results.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 处理矩阵并不容易。我们为什么要害怕困难呢？通过本节的内容，你将学习如何组合不同的矩阵以产生有趣的结果。
- en: 'Basic operations are really useful when you need to implement something new.
    Usually, Computer Vision uses grayscale images to work with them, since most Computer
    Vision algorithms do not need color information to track the object. As you may
    already know, Computer Vision mostly relies on the shape and intensity information
    to produce the results. In the following code, we will see how to convert a color
    matrix into a grayscale (one channel) matrix:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要实现新功能时，基本操作非常有用。通常，计算机视觉使用灰度图像来处理，因为大多数计算机视觉算法不需要颜色信息来跟踪对象。正如你可能已经知道的，计算机视觉主要依赖于形状和强度信息来产生结果。在下面的代码中，我们将看到如何将彩色矩阵转换为灰度（单通道）矩阵：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Just a few lines of code! First, we create an object, which will hold our grayscale
    image. Next, we apply the `JSFeat` function to that image. You may also define
    matrix boundaries for conversion, if you want. Here is the result of the conversion:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几行代码！首先，我们创建一个对象，该对象将保存我们的灰度图像。接下来，我们将 `JSFeat` 函数应用于该图像。如果您想定义转换的矩阵边界，也可以。以下是转换的结果：
- en: '![Basic matrix operations](img/image00096.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![基本矩阵操作](img/image00096.jpeg)'
- en: For this type of operation, you do not actually need to load a color image into
    the matrix; instead of `mat.data`, you can use `imageData.data` from the context—it's
    up to you.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类操作，您实际上不需要将彩色图像加载到矩阵中；您可以使用 `imageData.data` 而不是 `mat.data`，这取决于您。
- en: To see how to display a matrix, refer to the *Matrix displaying* section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何显示矩阵，请参阅 *矩阵显示* 部分。
- en: 'One of the useful operations in Computer Vision is a matrix transpose, which
    basically just rotates a matrix by 90 degrees counter-clockwise. You need to keep
    in mind that the rows and columns of the original matrix are reflected during
    this operation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉中的一种有用操作是矩阵转置，这基本上只是将矩阵逆时针旋转 90 度。您需要记住，在这次操作中，原始矩阵的行和列会被反转：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: 'You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you. Download link for the
    book: [https://github.com/foat/computer-vision-for-the-web](https://github.com/foat/computer-vision-for-the-web).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以直接将文件通过电子邮件发送给您。本书的下载链接：[https://github.com/foat/computer-vision-for-the-web](https://github.com/foat/computer-vision-for-the-web)。
- en: 'Again, we need to predefine the resulting matrix, and only then we can apply
    the transpose operation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要预先定义结果矩阵，然后才能应用转置操作：
- en: '![Basic matrix operations](img/image00097.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![基本矩阵操作](img/image00097.jpeg)'
- en: 'Another operation that can be helpful is a matrix multiplication. Since it
    is hard to see the result on an image, we will fill matrices manually. The following
    code works by the formula *C = A * B*, the number of rows of the first matrix
    must be equal to the number of columns of the second matrix, e.g. *MxN* and *NxK*,
    those are dimensions for the first and the second matrices accordingly:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能有所帮助的操作是矩阵乘法。由于在图像上难以看到结果，我们将手动填写矩阵。以下代码通过公式 *C = A * B* 运作，第一个矩阵的行数必须等于第二个矩阵的列数，例如
    *MxN* 和 *NxK*，这些分别是第一个和第二个矩阵的维度：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, the *M = K = 3* and *N = 2*. Keep in mind that during the matrix creation,
    we place columns as a first parameter, and only as the second do we place rows.
    We populate matrices with dummy values and call the multiply function. After displaying
    the result in the console, you will see this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*M = K = 3* 和 *N = 2*。请注意，在创建矩阵的过程中，我们将列作为第一个参数放置，而将行仅作为第二个参数放置。我们用虚拟值填充矩阵并调用乘法函数。在控制台显示结果后，您将看到如下：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here the first column is matrix A, the second – matrix B and the third column
    is the result matrix of C.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一列是矩阵 A，第二列是矩阵 B，第三列是结果矩阵 C。
- en: JSFeat also provides such functions for matrix multiplication as `multiply_ABt`,
    `multiply_AAt`, and so on, where *t* means transposed. Use these functions when
    you do not want to write additional lines of code for the transpose method. In
    addition to this, there are matrix operations for 3 x 3 matrices, which are faster
    and optimized for this dimension. Besides, they are useful when, for example,
    you need to work with coordinates.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: JSFeat 还提供了矩阵乘法的函数，如 `multiply_ABt`、`multiply_AAt` 等，其中 *t* 表示转置。当您不想为转置方法编写额外的代码行时，请使用这些函数。此外，还有针对
    3 x 3 矩阵的矩阵操作，这些操作更快且针对此维度进行了优化。此外，当您需要处理坐标时，它们也非常有用。
- en: In the two-dimensional world, we use only *x* and *y* for coordinates. However,
    for more complex algorithms, when we need to define a point of intersection between
    two parallel lines, we need to add *z* (third) coordinate to a point, this system
    of coordinates is called homogeneous coordinates. They are especially helpful
    when you need to project a three-dimensional object onto a two-dimensional space.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维世界中，我们只使用*x*和*y*作为坐标。然而，对于更复杂的算法，当我们需要定义两条平行线之间的交点时，我们需要给一个点添加*z*（第三个）坐标，这个坐标系统被称为齐次坐标。它们在你需要将三维物体投影到二维空间时特别有用。
- en: Going deeper
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入探索
- en: Consider find features on an image, these features are usually used for object
    detection. There are many algorithms for this but you need a robust approach,
    which has to work with different object sizes. Moreover, you may need to reduce
    the redundancy of an image or search something the size of which you are unsure
    of. In that case, you need a set of images. The solution to this is a pyramid
    of an image. An **image pyramid** is a collection of several images, which are
    downsampled from the original.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在图像上找到特征，这些特征通常用于目标检测。为此有很多算法，但你需要一个鲁棒的解决方案，它必须能够处理不同大小的对象。此外，你可能需要减少图像的冗余或搜索你不确定大小的东西。在这种情况下，你需要一组图像。这个问题的解决方案是一个图像金字塔。**图像金字塔**是一组从原始图像下采样得到的多个图像。
- en: 'The code for creating an image pyramid will look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像金字塔的代码看起来是这样的：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'First, we define the number of levels for the pyramid; here, we set it to 4\.
    In JSFeat, the first level is skipped by default, since it is the original image.
    Next, we define the starting dimensions and output types. Then, we allocate space
    for the pyramid levels and build the pyramid itself. A pyramid is generally downsampled
    by a factor of 2:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义金字塔的层数；在这里，我们将其设置为4。在JSFeat中，默认情况下跳过第一层，因为它就是原始图像。接下来，我们定义起始尺寸和输出类型。然后，我们为金字塔层分配空间并构建金字塔本身。金字塔通常以2的倍数下采样：
- en: '![Going deeper](img/image00098.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![深入探索](img/image00098.jpeg)'
- en: JSFeat pyramid is just an array of matrices, it shows different pyramid layers
    starting from the original image and ending with the smallest image in the pyramid.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: JSFeat金字塔只是一个矩阵数组，它显示了从原始图像开始到金字塔中最小图像的不同金字塔层。
- en: Matrix displaying
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵显示
- en: 'What we did not discuss in the previous section is how to display output matrices.
    It is done in different ways for grayscale and colored images. Here is the code
    for displaying matrices for a colored image:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们没有讨论的是如何显示输出矩阵。对于灰度和彩色图像，有不同的显示方式。以下是显示彩色图像矩阵的代码：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We just need to cast the matrix data to the appropriate format and put the
    resulting `ImageData` function into the context. It is harder to do so for a grayscale
    image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将矩阵数据转换为适当的格式，并将结果`ImageData`函数放入上下文中。对于灰度图像来说，这样做更困难：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a binary data representation. We populate the `ImageData` function with
    the alpha channel, which is constant for all pixels as well as for red, green,
    and blue channels. For a gray image, they have the same value, which is set as
    the `pix` variable. Finally, we need to put the `ImageData` function into the
    context as we did in the previous example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个二进制数据表示。我们将alpha通道填充到`ImageData`函数中，对于所有像素以及红色、绿色和蓝色通道都是常数。对于灰度图像，它们的值相同，设置为`pix`变量。最后，我们需要像上一个例子中那样将`ImageData`函数放入上下文中。
- en: Useful functions and where to use them
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的函数及其使用方法
- en: There are many functions that are needed in Computer Vision. Some of them are
    simple, such as sorting, while others are more complex. Here, we will discuss
    how to use them with the JSFeat library and see several Computer Vision applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉中需要很多函数。其中一些很简单，比如排序，而另一些则更复杂。在这里，我们将讨论如何使用JSFeat库来使用它们，并查看几个计算机视觉应用。
- en: Sorting using JSFeat
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSFeat进行排序
- en: 'Sort algorithms are always helpful in any application. JSFeat provides an excellent
    way to sort a matrix. In addition to just sorting an array, it can even sort just
    part of the data. Let''s see how we can do that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法在任何应用中都是非常有帮助的。JSFeat提供了一个出色的排序矩阵的方法。除了排序数组之外，它甚至可以排序数据的一部分。让我们看看我们如何做到这一点：
- en: 'First, we need to define a compare function, which is as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个比较函数，如下所示：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we do the sorting:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们进行排序：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first parameter defines an array for sorting, the second and third are
    the starting index and the ending index, respectively. The final parameter defines
    the comparison function. You will see the following image:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数定义了一个用于排序的数组，第二个和第三个参数分别是起始索引和结束索引。最后一个参数定义了比较函数。你将看到以下图像：
- en: '![Sorting using JSFeat](img/image00099.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用 JSFeat 排序](img/image00099.jpeg)'
- en: As we can see, the lower portion part of the image was sorted, looks good!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，图像的下半部分被排序了，看起来不错！
- en: 'You will probably need a `median` function, which returns the number that separates
    the higher part of the data from the lower part. To understand this better, we
    need to see some examples:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要一个 `median` 函数，它返回将数据的高部分与低部分分开的数字。为了更好地理解这一点，我们需要看看一些示例：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the first array, the result is `3`. It is simple. For the sorted array,
    number `3` just separates `1`, `2` from `5`, `8`. What we do see for the second
    array, is the result of `4`. Actually, different median algorithms may return
    different results; for the presented algorithm, JSFeat picks one of the array
    elements to return the result. In contrast, many approaches will return `5` in
    that case, since `5` represents the mean of two middle values `(4, 6)`. Taking
    that into account, be careful and see how the algorithm is implemented.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个数组，结果是 `3`。很简单。对于排序后的数组，数字 `3` 只是将 `1`、`2` 与 `5`、`8` 分开的分隔符。对于第二个数组，我们看到的结果是
    `4`。实际上，不同的中值算法可能会返回不同的结果；对于所展示的算法，JSFeat 会从数组元素中选择一个来返回结果。相比之下，许多方法在这种情况下会返回
    `5`，因为 `5` 代表两个中间值 `(4, 6)` 的平均值。考虑到这一点，请务必小心，并看看算法是如何实现的。
- en: Linear algebra
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性代数
- en: Who wants to solve a system of linear equations? No one? Don't worry, it can
    be done very easily.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 谁想解一个线性方程组？没有人？别担心，这可以很容易地完成。
- en: 'First, let''s define a simple linear system. To start with, we define the linear
    system as *Ax = B*, where we know *A* and *B* matrices and need to find *x*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个简单的线性系统。首先，我们将线性系统定义为 *Ax = B*，其中我们知道 *A* 和 *B* 矩阵，并需要找到 *x*：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'JSFeat places the result into the *B* matrix, so be careful if you want to
    use *B* somewhere else or you will loose your data. The result will look like
    this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: JSFeat 将结果放入 *B* 矩阵中，所以如果你想在其他地方使用 *B*，请务必小心，否则你会丢失你的数据。结果看起来会是这样：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the algorithm works with floats, we cannot get the exact values but after
    applying a round operation, everything will look fine:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于算法使用浮点数，我们无法得到精确的值，但经过四舍五入操作后，一切看起来都会很正常：
- en: '*[2, -4, -4]*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*[2, -4, -4]*'
- en: 'In addition to this, you can use the `svd_solve` function. In that case, you
    will need to define an *X* matrix as well:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以使用 `svd_solve` 函数。在这种情况下，你还需要定义一个 *X* 矩阵：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A perspective example
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个透视示例
- en: 'Let us show you a more catchy illustration. Suppose you have an image that
    is distorted by perspective or you want to rectify an object plane, for example,
    a building wall. Here''s an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给你一个更吸引人的插图。假设你有一个被透视扭曲的图像，或者你想要校正一个物体平面，例如，一堵建筑墙。这里有一个例子：
- en: '![A perspective example](img/image00100.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![一个透视示例](img/image00100.jpeg)'
- en: 'Looks good, doesn''t it? How do we do that? Let''s look at the code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，不是吗？我们是如何做到这一点的？让我们看看代码：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Primarily, as we did earlier, we define a result matrix object. Next, we assign
    a matrix for image perspective transformation. We calculate it based on four pairs
    of corresponding points. For example, the last, that is the fourth point of the
    original image, which is `[0, 480]`, should be projected to the point of `[180,
    480]` on the rectified image. Here, the first coordinate refers to *X* and the
    second to *Y*. Then, we invert the transform matrix to be able to apply it to
    the original image—`mat` variable. We pick the background color as white (255
    for an unsigned byte). As a result, we get a nice image without any perspective
    distortion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的，就像我们之前做的那样，我们定义一个结果矩阵对象。接下来，我们分配一个用于图像透视变换的矩阵。我们根据四对对应点来计算它。例如，最后一个是原始图像的第四个点，即
    `[0, 480]`，应该投影到校正图像上的 `[180, 480]` 点。在这里，第一个坐标指的是 *X*，第二个指的是 *Y*。然后，我们反转变换矩阵，以便能够将其应用于原始图像——`mat`
    变量。我们选择背景颜色为白色（无符号字节中的 255）。结果，我们得到了一个没有任何透视扭曲的漂亮图像。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw many useful Computer Vision applications. Every time
    you want to implement something new, you need to start from the beginning. Fortunately,
    there are many libraries that can help you with your investigation. Here, we mainly
    covered the JSFeat library, since it provides basic methods for Computer Vision
    applications. We discussed how and when to apply the core of this library. Nevertheless,
    this is just a starting point, and if you want to see more exciting math topics
    and dig into the Computer Vision logic, we strongly encourage you to go through
    the next chapters of this book. See you there!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了许多有用的计算机视觉应用。每次你想实现新的功能时，你都需要从头开始。幸运的是，有许多库可以帮助你进行调研。在这里，我们主要介绍了JSFeat库，因为它为计算机视觉应用提供了基本方法。我们讨论了如何以及何时应用这个库的核心。然而，这只是一个起点，如果你想看到更多令人兴奋的数学主题并深入理解计算机视觉的逻辑，我们强烈建议你阅读这本书的下一章节。那里见！
