- en: Exploring the Potential of JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 JavaScript 的潜力
- en: 'We will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Why JavaScript?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 JavaScript？
- en: Why machine learning, why now?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择机器学习，为什么现在？
- en: Advantages and challenges of JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的优缺点
- en: The CommonJS initiative
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CommonJS 创新计划
- en: Node.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js
- en: TypeScript language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 语言
- en: Improvements in ES6
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6 的改进
- en: Preparing the development environment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: Why JavaScript?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 JavaScript？
- en: I started writing about **machine learning** (**ML**) in JavaScript in 2010\.
    At the time, Node.js was brand new and JavaScript was just beginning to come into
    its own as a language. For much of the history of the internet, JavaScript had
    been seen as a toy language, used to create simple dynamic interactions on web
    pages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 2010 年开始用 JavaScript 写有关 **机器学习**（**ML**）的文章。当时，Node.js 还很新，JavaScript 正开始作为一种语言崭露头角。在互联网的大部分历史中，JavaScript
    被视为一种玩具语言，用于在网页上创建简单的动态交互。
- en: 'The perception of JavaScript began to change in 2005 with the release of the
    **Prototype JavaScript Framework**, which aimed to simplify AJAX requests and
    help developers deal with cross-browser `XMLHttpRequest`. The Prototype Framework
    also introduced the familiar dollar function as an alias for `` `document.getElementById`:
    `$(“myId”)` ``, for instance.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 2005 年 **Prototype JavaScript 框架** 的发布，人们对 JavaScript 的看法开始改变，该框架旨在简化 AJAX
    请求并帮助开发者处理跨浏览器的 `XMLHttpRequest`。Prototype 框架还引入了熟悉的美元函数作为 `document.getElementById`
    的别名，例如 `$(“myId”)`。
- en: One year later, John Resig released the wildly popular jQuery library. At the
    time of writing, [w3techs.com](https://w3techs.com/) reports that jQuery is used
    on 96% of websites whose JavaScript libraries are known to them (which accounts
    for 73% of all websites). jQuery worked to make common JavaScript operations cross-browser
    compatible and easy to achieve, bringing important tools such as AJAX requests,
    **Document Object Model** (**DOM**) traversal and manipulation, and animations
    to web developers everywhere.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一年后，John Resig 发布了广受欢迎的 jQuery 库。在撰写本文时，[w3techs.com](https://w3techs.com/)
    报告称，jQuery 被用于 96% 的已知 JavaScript 库的网站（这占所有网站的 73%）。jQuery 致力于使常见的 JavaScript
    操作跨浏览器兼容且易于实现，为全球的网页开发者带来了重要的工具，如 AJAX 请求、**文档对象模型**（**DOM**）遍历和操作，以及动画。
- en: 'Then, in 2008, the Chrome web browser and the Chrome V8 JavaScript engine were
    released. Chrome and V8 introduced a marked performance improvement over older
    browsers: JavaScript was now fast, owing in large part to the V8 engine''s innovative
    just-in-time compiler that builds machine code directly from JavaScript.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 2008 年，Chrome 浏览器和 Chrome V8 JavaScript 引擎被发布。Chrome 和 V8 引入了相对于旧浏览器的显著性能提升：JavaScript
    现在变得更快，这主要归功于 V8 引擎的创新即时编译器，它可以直接从 JavaScript 构建机器代码。
- en: JavaScript became more popular as jQuery and Chrome took over the web. Developers
    historically have never loved JavaScript as a programming language, but with jQuery
    in the picture, running on a fast and modern browser, it became clear that JavaScript
    was an underutilized tool and capable of much more than it had been used for previously.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 jQuery 和 Chrome 浏览器的兴起，JavaScript 的受欢迎程度逐渐增加。开发者们历史上从未真正喜欢 JavaScript 这种编程语言，但有了
    jQuery 的加入，在快速且现代的浏览器上运行，很明显 JavaScript 是一个未被充分利用的工具，并且能够完成比之前更多的事情。
- en: In 2009, the JavaScript developer community decided to break JavaScript free
    from the web browser environment. The CommonJS initiative was launched early that
    year, and Node.js followed after a few months. CommonJS modules' goal was to develop
    a standard library and improve the ecosystem for JavaScript so that it could be
    used outside of the browser environment. As part of this effort, CommonJS standardized
    a module-loading interface that allowed developers to build libraries that they
    could share with others.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2009 年，JavaScript 开发者社区决定将 JavaScript 从浏览器环境解放出来。CommonJS 创新计划在当年早期启动，几个月后 Node.js
    随之诞生。CommonJS 模块的目标是开发一个标准库，并改善 JavaScript 的生态系统，使其能够在浏览器环境之外使用。作为这项努力的一部分，CommonJS
    标准化了模块加载接口，允许开发者构建可以与他人共享的库。
- en: 'The release of Node.js in mid-2009 rocked the JavaScript world by giving JavaScript
    developers a new paradigm to consider: JavaScript as a server-side language. Packing
    the Chrome V8 engine under the hood made Node.js surprisingly fast, though the
    V8 engine doesn''t deserve all of the credit for the software''s performance.
    The Node.js instance uses an event loop to process requests, so it can handle
    a large number of concurrent connections despite being single-threaded.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年中旬Node.js的发布，通过为JavaScript开发者提供了一个新的思考范式——将JavaScript作为服务器端语言，震撼了JavaScript世界。将Chrome
    V8引擎打包在内，使得Node.js出奇地快，尽管V8引擎并不应该独占软件性能的功劳。Node.js实例使用事件循环来处理请求，因此尽管它是单线程的，但它可以处理大量的并发连接。
- en: The novelty of JavaScript on the server, its surprising performance, and the
    early introduction of the npm registry which let developers publish and discover
    modules, attracted thousands of developers. The standard library published with
    Node.js was primarily low-level I/O APIs, and developers raced to see who could
    publish the first good HTTP request wrapper, the first easy-to-use HTTP server,
    the first high-level image processing library, and so on. The rapid early growth
    of the JavaScript ecosystem generated confidence in developers who were reluctant
    to adopt the new technology. JavaScript, for the first time, was being seen as
    a real programming language, rather than just something we tolerated because of
    web browsers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在服务器端的创新之处，其令人惊讶的性能，以及npm注册表的早期引入，让开发者能够发布和发现模块，这些都吸引了成千上万的开发者。与Node.js一起发布的标准库主要是低级I/O
    API，开发者们竞相发布第一个优秀的HTTP请求包装器，第一个易于使用的HTTP服务器，第一个高级图像处理库，等等。JavaScript生态系统的快速早期增长，让那些不愿采用新技术的开发者们产生了信心。JavaScript第一次被视为一种真正的编程语言，而不仅仅是由于网络浏览器而容忍的东西。
- en: While JavaScript as a programming platform was maturing, the Python community
    was busy working on ML, in part inspired by Google's success in the market. The
    foundational and very popular number processing library, NumPy, was released in
    2006, though it had existed in one form or another for a decade prior. A ML library
    called **scikit-learn** was released in 2010, and that was the moment I decided
    to start teaching ML to JavaScript developers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript作为编程平台逐渐成熟时，Python社区正忙于研究机器学习，这在一定程度上受到了谷歌在市场上的成功启发。基础且非常流行的数值处理库NumPy于2006年发布，尽管它以某种形式存在了十年。一个名为**scikit-learn**的机器学习库于2010年发布，那是我决定开始向JavaScript开发者教授机器学习的时刻。
- en: The popularity of ML in Python and the ease of building and training models
    with tools, such as scikit-learn, astounded me and many others. In my eyes, the
    surge in popularity caused an ML bubble; because models were so easy to build
    and run, I found that many developers didn't actually understand the mechanics
    of the algorithms and techniques they were using. Many developers lamented their
    underperforming models, not understanding that they themselves were the weak link
    in the chain.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python中机器学习的流行以及使用工具（如scikit-learn）构建和训练模型的便捷性，让我和许多人感到惊讶。在我看来，这种流行度的激增引发了一个机器学习泡沫；因为模型构建和运行变得如此容易，我发现许多开发者实际上并不了解他们所使用的算法和技术的工作原理。许多开发者哀叹他们的模型表现不佳，却不知道他们自己才是链条中的薄弱环节。
- en: Machine learning at the time had been seen as mystical, magical, academic, accessible
    only to a select few geniuses, and only accessible to Python developers. I felt
    differently. Machine learning is just a category of algorithms with no magic involved.
    Most of the algorithms are actually easy to understand and reason about!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在当时，机器学习被视为神秘、神奇、学术性的，只有少数天才才能接触，而且只有Python开发者才能接触。我的看法不同。机器学习只是没有魔法涉及的一类算法。大多数算法实际上很容易理解和推理！
- en: Rather than showing developers how to import Bayes in Python, I wanted to show
    developers how to build the algorithms from scratch, an important step in building
    intuition. I also wanted my students to largely ignore the popular Python libraries
    that existed at the time, because I wanted to reinforce the notion that ML algorithms
    can be written in any language and Python is not required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想向开发者展示如何在Python中导入贝叶斯，而是想展示如何从头开始构建算法，这是建立直觉的重要一步。我还想让我学生很大程度上忽略当时流行的Python库，因为我想要强化这样一个观念：机器学习算法可以用任何语言编写，Python不是必需的。
- en: I chose JavaScript as my teaching platform. To be perfectly honest, I chose
    JavaScript in part because it was considered a *bad* language by many at that
    time. My message was *machine learning is easy, you can even do it in JavaScript!* Fortunately
    for me, Node.js and JavaScript were both becoming incredibly popular, and my early
    articles on ML in JavaScript were read by over a million curious developers in
    the following years.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了JavaScript作为我的教学平台。坦白说，我选择JavaScript部分原因是因为当时很多人认为它是一种*糟糕*的语言。我的信息是*机器学习很简单，你甚至可以用JavaScript来做！*
    幸运的是，对于我来说，Node.js和JavaScript都变得极其流行，我的早期关于JavaScript中机器学习的文章在接下来的几年里被超过一百万名好奇的开发者阅读。
- en: I also chose JavaScript in part because I didn't want ML to be seen as a tool
    only accessible to academics, or computer scientists, or even college graduates.
    I believed, and still believe, that these algorithms can be thoroughly understood
    by any competent developer, given enough practice and repetition. I chose JavaScript
    because it allowed me to reach a new audience of frontend and full-stack web developers,
    many of whom were self-taught or had never studied computer science formally.
    If the goal was to demystify and democratize the field of ML, I felt it was much
    better to reach the web developer community rather than the backend Python programmer
    community, which as a whole was already more comfortable with ML at the time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我还选择JavaScript部分原因是因为我不想让机器学习被视为只有学者、计算机科学家或甚至大学毕业生才能使用的工具。我相信，并且仍然相信，只要足够练习和重复，任何有能力的开发者都可以彻底理解这些算法。我选择JavaScript是因为它让我能够接触到新的前端和全栈Web开发者群体，其中许多人自学成才或从未正式学习过计算机科学。如果目标是使机器学习领域去神秘化和民主化，我觉得接触Web开发者社区比接触当时整体更熟悉机器学习的后端Python程序员社区要好得多。
- en: Python has always been and remains the language of choice for ML, in part due
    to the maturity of the language, in part due to the maturity of the ecosystem,
    and in part due to the positive feedback loop of early ML efforts in Python. Recent
    developments in the JavaScript world, however, are making JavaScript more attractive
    to ML projects. I think we will see a major ML renaissance in JavaScript within
    a few years, especially as laptops and mobile devices become ever more powerful
    and JavaScript itself surges in popularity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python一直是，并且仍然是机器学习的首选语言，部分原因是语言的成熟度，部分原因是生态系统的成熟度，部分原因是Python早期机器学习努力的积极反馈循环。然而，JavaScript世界的最新发展使得JavaScript对机器学习项目更具吸引力。我认为在几年内，我们将看到JavaScript在机器学习领域迎来一场重大的复兴，特别是在笔记本电脑和移动设备变得越来越强大，JavaScript本身也日益流行的情况下。
- en: Why machine learning, why now?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么是机器学习，为什么是现在？
- en: Several ML techniques have been around since before computers themselves, but
    many of the modern ML algorithms we use today were discovered all the way back
    in the 1970s and 1980s. They were interesting but not practical then, and were
    confined largely to academia.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些机器学习技术早在计算机本身出现之前就已经存在，但许多我们现在使用的现代机器学习算法都是在20世纪70年代和80年代发现的。当时它们很有趣但不实用，主要局限于学术界。
- en: 'What changed to give ML its massive rise in popularity? First, computers finally
    got fast enough to run non-trivial neural networks and large ML models. And then
    two things happened: Google and **Amazon Web Services** (**AWS**). Google proved
    the value of ML to the market in a very visible manner, and then AWS made scalable
    computing and storage resources readily available (AWS democratized it and created
    new competition).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 什么变化使得机器学习在流行度上有了巨大的提升？首先，计算机终于足够快，可以运行非平凡的神经网络和大型机器学习模型。然后发生了两件事：谷歌和**亚马逊网络服务**（**AWS**）。谷歌以一种非常明显的方式证明了机器学习对市场的价值，然后AWS使可扩展的计算和存储资源变得容易获得（AWS使其民主化并创造了新的竞争）。
- en: 'Google PageRank, the ML algorithm powering Google Search, taught us all about
    business applications of ML. Sergei and Larry, the founders of Google, told the
    world that the massive success of their search engine and resultant advertising
    business was the PageRank algorithm: a relatively straightforward linear algebra
    equation, with a massive matrix.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的PageRank算法，这个为谷歌搜索提供动力的机器学习算法，让我们了解了机器学习的商业应用。谷歌的创始人谢尔盖和拉里向世界宣布，他们搜索引擎和随之而来的广告业务的巨大成功归功于PageRank算法：一个相对简单的线性代数方程，包含一个巨大的矩阵。
- en: Note that neural networks are also relatively straightforward linear algebra
    equations with a massive matrix.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，神经网络也是相对简单的线性代数方程，包含一个巨大的矩阵。
- en: That was ML in all its glory; big data giving big insight which translates into
    a major market success. This got the world economically interested in ML.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是所有荣耀中的机器学习（ML）；大数据带来了深刻的洞察力，这转化为巨大的市场成功。这使得全世界对机器学习产生了经济上的兴趣。
- en: AWS, with the launch of EC2 and hourly billing, democratized compute resources.
    Researchers and early-stage start ups were now able to launch large computing
    clusters quickly, train their models, and scale the cluster back down, avoiding
    the need for large capital expenditures on beefy servers. This created new competition
    and an inaugural generation of ML-focused start ups, products, and initiatives.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: AWS通过推出EC2和按小时计费，民主化了计算资源。研究人员和早期阶段的初创公司现在可以快速启动大型计算集群，训练他们的模型，并将集群规模缩小，避免了对强大服务器的巨额资本支出。这创造了新的竞争，并产生了一代专注于机器学习的初创公司、产品和倡议。
- en: ML has recently had another surge in popularity, both in the developer and business
    communities. The first generation of ML-focused start ups and products have now
    come to maturity and are proving the value of ML in the market, and in many cases
    these companies are closing in on or have overtaken their competitors. The desire
    of companies to remain competitive in their market drove up the demand for ML
    solutions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 近期，机器学习在开发者和商业社区中又掀起了一股热潮。第一代专注于机器学习的初创公司和产品现在已经成熟，并在市场上证明了机器学习的价值，在许多情况下，这些公司正在接近或超越其竞争对手。公司保持市场竞争力的愿望推动了机器学习解决方案的需求。
- en: The late 2015 introduction of Google's neural network library, **TensorFlow**,
    energized developers by democratizing neural networks much in the same way that
    EC2 democratized computing power. Additionally, those first-generation start ups
    that focused on developers have also come to maturity, and now we can make a simple
    API request to AWS or **Google Cloud Platform** (**GCP**) that runs an entire
    pretrained **Convolutional Neural Network** (**CNN**) on an image, and tells me
    if I'm looking at a cat, a woman, a handbag, a car, or all four at once.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年末，谷歌推出了神经网络的库**TensorFlow**，通过民主化神经网络的方式激发了开发者们的热情，这与EC2民主化计算能力的方式非常相似。此外，那些专注于开发者的第一代初创公司也已经成熟，现在我们可以通过简单的API请求AWS或**Google
    Cloud Platform**（**GCP**），在图像上运行整个预训练的**卷积神经网络**（**CNN**），并告诉我我是否在看着一只猫、一个女人、一个手提包、一辆车，或者同时看着这四者。
- en: As ML is democratized it will slowly lose its competitive value, that is, companies
    will no longer be able to use ML to jump leaps and bounds ahead of the competition,
    because their competition will also be using ML. Everyone in the field is now
    using the same algorithms, and competition becomes a data war. If we want to keep
    competing on technology, if we want to find the next 10x improvement, then we'll
    either need to wait for, or preferably cause, the next big technological breakthrough.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着机器学习的民主化，它将逐渐失去其竞争优势，也就是说，公司将不再能够使用机器学习来超越竞争，因为他们的竞争对手也将使用机器学习。现在，该领域的每个人都使用相同的算法，竞争变成了数据战。如果我们想在技术上保持竞争，如果我们想找到下一个10倍改进，那么我们可能需要等待，或者最好是促成下一个重大的技术突破。
- en: If ML had not been such a success in the market, that would have been the end
    of the story. All the important algorithms would be known to all, and the fight
    would move to who can gather the best data, put walls around their garden, or
    exploit their ecosystem the best.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器学习在市场上的成功不是如此之大，那么这个故事就结束了。所有重要的算法都将为所有人所知，战斗将转移到谁能够收集到最好的数据，在自己的园地里筑起围墙，或者最好地利用自己的生态系统。
- en: But introducing a tool such as TensorFlow into the market changed all of that.
    Now, neural networks have been democratized. It's surprisingly easy to build a
    model, train and run it on a GPU, and generate real results. The academic fog
    surrounding neural networks has been lifted, and now tens of thousands of developers
    are playing around with techniques, experimenting, and refining. This will launch
    a second major wave of ML popularity, particularly focused on neural networks.
    The next generation of ML and neural network-focused start ups and products is
    being born right now, and when they come to maturity in a few years, we should
    see a number of significant breakthroughs, as well as breakaway companies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，将TensorFlow这样的工具引入市场改变了这一切。现在，神经网络已经实现了民主化。构建模型、在GPU上训练和运行它以及生成真实结果出奇地简单。围绕神经网络的学术迷雾已经消散，现在成千上万的开发者正在尝试各种技术、进行实验和改进。这将引发机器学习（ML）的第二次重大浪潮，尤其是专注于神经网络。新一代以机器学习和神经网络为重点的初创公司和产品正在诞生，几年后当它们成熟时，我们应该会看到许多重大突破，以及一些突破性的公司。
- en: Each new market success we see will create demand for ML developers. The increase
    of the talent pool and democratization of technology causes technology breakthroughs.
    Each new technology breakthrough hits the market and creates new market successes,
    and the cycle will continue while the field itself advances at an accelerating
    pace. I think, for purely economic reasons, that we really are headed for an **artificial
    intelligence** (**AI**) boom.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的每一个新的市场成功都将创造对机器学习（ML）开发者的需求。人才库的增加和技术的民主化导致技术突破。每一次新的技术突破进入市场都会创造新的市场成功，并且随着该领域的加速发展，这个循环将持续下去。我认为，纯粹从经济角度来看，我们真的正走向一个**人工智能**（**AI**）的繁荣。
- en: Advantages and challenges of JavaScript
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的优势和挑战
- en: Despite my optimism towards the future of ML in JavaScript, most developers
    today would still choose Python for their new projects, and nearly all large-scale
    production systems are developed in Python or other languages more typical to
    ML.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我对JavaScript在机器学习（ML）未来的乐观态度，但今天的大多数开发者仍然会选择Python来开发他们的新项目，几乎所有的大型生产系统都是用Python或其他更典型的机器学习语言开发的。
- en: 'JavaScript, like any other tool, has its advantages and disadvantages. Much
    of the historic criticism of JavaScript has focused on a few common themes: strange
    behavior in type coercion, the prototypical object-oriented model, difficulty
    organizing large codebases, and managing deeply nested asynchronous function calls
    with what many developers call *callback hell*. Fortunately, most of these historic
    gripes have been resolved by the introduction of **ES6**, that is, **ECMAScript
    2015**, a recent update to the JavaScript syntax.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript，就像任何其他工具一样，有其优点和缺点。历史上对JavaScript的许多批评都集中在几个常见的主题上：类型强制转换中的奇怪行为、原型面向对象模型、组织大型代码库的困难，以及使用许多开发者称之为*回调地狱*的深度嵌套异步函数调用。幸运的是，大多数这些历史上的抱怨都通过引入**ES6**（即**ECMAScript
    2015**），这个JavaScript语法的最新更新而得到了解决。
- en: 'Despite the recent language improvements, most developers would still advise
    against using JavaScript for ML for one reason: the ecosystem. The Python ecosystem
    for ML is so mature and rich that it''s difficult to justify choosing any other
    ecosystem. But this logic is self-fulfilling and self-defeating; we need brave
    individuals to take the leap and work on real ML problems if we want JavaScript''s
    ecosystem to mature. Fortunately, JavaScript has been the most popular programming
    language on GitHub for a few years running, and is growing in popularity by almost
    every metric.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最近语言有所改进，但大多数开发者仍然会建议不要使用JavaScript进行机器学习，原因之一是生态系统。Python的机器学习生态系统如此成熟和丰富，以至于很难为选择其他生态系统找到理由。但这种逻辑是自我实现的也是自我挫败的；如果我们想让JavaScript的生态系统成熟，我们需要勇敢的人去跨越障碍，解决真实的机器学习问题。幸运的是，JavaScript已经连续几年成为GitHub上最受欢迎的编程语言，并且几乎在所有指标上都在增长。
- en: There are some advantages to using JavaScript for ML. Its popularity is one;
    while ML in JavaScript is not very popular at the moment, the language itself
    is. As demand for ML applications rises, and as hardware becomes faster and cheaper,
    it's only natural for ML to become more prevalent in the JavaScript world. There
    are tons of resources available for learning JavaScript in general, maintaining
    Node.js servers, and deploying JavaScript applications. The **Node Package Manager**
    (**npm**) ecosystem is also large and still growing, and while there aren't many
    very mature ML packages available, there are a number of well built, useful tools
    out there that will come to maturity soon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript进行机器学习有一些优势。其普及度是一个；虽然目前JavaScript中的机器学习并不非常流行，但JavaScript语言本身是流行的。随着机器学习应用需求的增加，以及硬件变得更快更便宜，机器学习在JavaScript世界中的普及是自然而然的事情。学习JavaScript的通用资源很多，维护Node.js服务器和部署JavaScript应用也是如此。**Node包管理器（npm**）生态系统也很大，仍在增长，尽管成熟的机器学习包并不多，但有许多构建良好、有用的工具即将成熟。
- en: Another advantage to using JavaScript is the universality of the language. The
    modern web browser is essentially a portable application platform which allows
    you to run your code, basically without modification, on nearly any device. Tools
    like **electron** (while considered by many to be bloated) allow developers to
    quickly develop and deploy downloadable desktop applications to any operating
    system. Node.js lets you run your code in a server environment. React Native brings
    your JavaScript code to the native mobile application environment, and may eventually
    allow you to develop desktop applications as well. JavaScript is no longer confined
    to just dynamic web interactions, it's now a general-purpose, cross-platform programming
    language.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript的另一个优势是语言的通用性。现代网络浏览器本质上是一个可携带的应用程序平台，它允许你在几乎任何设备上运行你的代码，基本上无需修改。像**electron**（虽然许多人认为它很臃肿）这样的工具允许开发者快速开发并部署可下载的桌面应用程序到任何操作系统。Node.js让你可以在服务器环境中运行你的代码。React
    Native将你的JavaScript代码带到原生移动应用程序环境中，并可能最终允许你开发桌面应用程序。JavaScript不再局限于动态网络交互，现在它是一种通用、跨平台的编程语言。
- en: Finally, using JavaScript makes ML accessible to web and frontend developers,
    a group that historically has been left out of the ML discussion. Server-side
    applications are typically preferred for ML tools, since the servers are where
    the computing power is. That fact has historically made it difficult for web developers
    to get into the ML game, but as hardware improves, even complex ML models can
    be run on the client, whether it's the desktop or the mobile browser.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用JavaScript使得机器学习（ML）对网页和前端开发者变得可访问，这个群体在历史上一直被排除在机器学习讨论之外。由于服务器是计算能力所在的地方，因此服务器端应用通常是机器学习工具的首选。这一事实在历史上使得网页开发者难以进入机器学习领域，但随着硬件的改进，即使是复杂的机器学习模型也可以在客户端运行，无论是桌面还是移动浏览器。
- en: If web developers, frontend developers, and JavaScript developers all start
    learning about ML today, that same community will be in a position to improve
    the ML tools available to us all tomorrow. If we take these technologies and democratize
    them, expose as many people as possible to the concepts behind ML, we will ultimately
    elevate the community and seed the next generation of ML researchers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网页开发者、前端开发者和JavaScript开发者今天开始学习机器学习，那么这个社区将能够改善我们所有人明天可用的机器学习工具。如果我们采用这些技术并使其民主化，让尽可能多的人接触到机器学习背后的概念，我们最终将提升社区并培养下一代机器学习研究人员。
- en: The CommonJS initiative
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJS倡议
- en: In 2009, a Mozilla engineer named Kevin Dangoor realized that server-side JavaScript
    needed a lot of help in order to be useful. The concept of server-side JavaScript
    had already existed, but wasn't very popular due to a number of limitations, particularly
    in terms of the JavaScript ecosystem.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，一位名叫Kevin Dangoor的Mozilla工程师意识到，服务器端JavaScript需要大量的帮助才能变得有用。服务器端JavaScript的概念已经存在，但由于许多限制，尤其是JavaScript生态系统方面的限制，它并不受欢迎。
- en: In a blog post written in January of 2009, Dangoor cited a few examples of where
    JavaScript needed some help. He wrote that the JavaScript ecosystem would need
    a standard library and standard interfaces for things such as file and database
    access. Additionally, the JavaScript environment needed a way to package, publish,
    and install libraries and dependencies for others to use, and also needed a package
    repository to host all of the aforementioned.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在2009年1月的一篇博客文章中，Dangoor列举了一些JavaScript需要帮助的例子。他写道，JavaScript生态系统需要一个标准库和标准接口，用于文件和数据库访问等。此外，JavaScript环境需要一个方法来打包、发布和安装库和依赖项，以便其他人可以使用，还需要一个包仓库来托管所有上述内容。
- en: 'Out of all of this came the **CommonJS** initiative, whose most notable contribution
    to the JavaScript ecosystem is the CommonJS module format. If you''ve done any
    work with Node.js, you''re probably already familiar with CommonJS: your `package.json` file
    is written in the CommonJS modules package specification format, and writing code
    like `var app = require(‘./app.js’)` in one file with `module.exports = App` in
    `app.js` is using the CommonJS module specification.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些最终导致了**CommonJS**倡议的诞生，它对JavaScript生态系统最显著的贡献是CommonJS模块格式。如果你有任何Node.js的工作经验，你可能已经熟悉CommonJS：你的`package.json`文件是用CommonJS模块包规范格式编写的，而在一个文件中编写`var
    app = require(‘./app.js’)`并在`app.js`中写入`module.exports = App`，就是在使用CommonJS模块规范。
- en: The standardization of modules and packages paved the way for a significant
    boost in JavaScript popularity. Developers were now able to use modules to write
    complex applications spanning many files, without polluting the global namespace.
    Package and library developers were able to build and publish new libraries of
    higher levels of abstraction than JavaScript's standard library. Node.js and npm
    would shortly grab onto these concepts and build a major ecosystem around package
    sharing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和包的标准化为JavaScript的普及率显著提升铺平了道路。开发者现在可以使用模块来编写跨越多个文件的复杂应用程序，而不会污染全局命名空间。包和库的开发者能够构建和发布比JavaScript标准库更高层次的抽象库。Node.js和npm很快就会抓住这些概念，围绕包共享构建一个主要生态系统。
- en: Node.js
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js
- en: The release of Node.js in 2009 is possibly the single most important moment
    in JavaScript's history, though it would not have been possible without the release
    of the Chrome browser and Chrome's V8 JavaScript engine in the previous year.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年Node.js的发布可能是JavaScript历史上最重要的时刻之一，尽管没有前一年Chrome浏览器和Chrome的V8 JavaScript引擎的发布，这一时刻是不可能实现的。
- en: 'Those readers who remember the launch of Chrome also recognize why Chrome dominated
    the browser wars: Chrome was fast, it was minimalist, it was modern, it was easy
    to develop for, and JavaScript itself ran much faster on Chrome than on other
    browsers.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那些还记得Chrome浏览器发布的人也会认识到为什么Chrome能在浏览器大战中占据主导地位：Chrome速度快，设计简约，风格现代，易于开发，而且JavaScript在Chrome上的运行速度比在其他浏览器上要快得多。
- en: 'Behind Chrome is the open source Chromium project, which in turn developed
    the **V8** JavaScript engine. The innovation that V8 brought to the JavaScript
    world was its new execution model: instead of interpreting JavaScript in real
    time, V8 contains a JIT compiler that turns JavaScript directly into native machine
    code. This gambit paid off, and the combined effect of its stellar performance
    and its open source status led others to co-opt V8 for their own purposes.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome背后是开源的Chromium项目，该项目反过来又开发了**V8** JavaScript引擎。V8为JavaScript世界带来的创新是其新的执行模型：V8包含一个即时编译器，它将JavaScript直接转换为原生机器代码，而不是实时解释JavaScript。这一策略取得了成功，其卓越的性能和开源状态使得其他人也开始将其用于自己的目的。
- en: Node.js took the V8 JavaScript engine, added an event-driven architecture around
    it, and added a low-level I/O API for disk and file access. The event-driven architecture
    turned out to be a critical decision. Other server-side languages and technologies,
    such as PHP, typically used a thread pool to manage concurrent requests, with
    each thread itself blocking while processing the request. Node.js is a single-threaded
    process, but using an event loop avoids blocking operations and instead favors
    asynchronous, callback-driven logic. While the single-threaded nature of Node.js
    is considered by many to be a drawback, Node.js was still able to handle many
    concurrent requests with good performance, and that was enough to bring developers
    to the platform.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 采用了 V8 JavaScript 引擎，在其周围添加了一个事件驱动架构，并添加了用于磁盘和文件访问的低级 I/O API。事件驱动架构最终证明是一个关键决策。其他服务器端语言和技术，如
    PHP，通常使用线程池来管理并发请求，每个线程在处理请求时本身会阻塞。Node.js 是一个单线程进程，但使用事件循环避免了阻塞操作，并更倾向于异步、回调驱动的逻辑。尽管许多人认为
    Node.js 的单线程特性是一个缺点，但 Node.js 仍然能够以良好的性能处理许多并发请求，这对吸引开发者到这个平台来说已经足够了。
- en: A few months later, the npm project was released. Building on top of the foundational
    work that CommonJS achieved, npm allowed package developers to publish their modules
    to a centralized registry (called the **npm registry**), and allowed package consumers
    to install and maintain dependencies with the npm command-line tool.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月后，npm 项目发布了。在 CommonJS 所取得的基石工作上，npm 允许包开发者将他们的模块发布到一个集中的注册表（称为 **npm 注册表**），并允许包消费者使用
    npm 命令行工具安装和维护依赖项。
- en: Node.js likely would not have broken into the mainstream if not for npm. The
    Node.js server itself provided the JavaScript engine, the event loop, and a few
    low-level APIs, but as developers work on bigger projects they tend to want higher-level
    abstractions. When making HTTP requests or reading files from disk, developers
    don't always want to have to worry about binary data, writing headers, and other
    low-level issues. The npm and the npm registry let the developer community write
    and share their own high-level abstractions in the form of modules other developers
    could simply install and `require()`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 npm，Node.js 很可能无法进入主流。Node.js 服务器本身提供了 JavaScript 引擎、事件循环和一些低级 API，但随着开发者处理更大的项目，他们往往希望有更高层次的抽象。在发起
    HTTP 请求或从磁盘读取文件时，开发者并不总是需要担心二进制数据、编写头信息和其他低级问题。npm 和 npm 注册表让开发者社区能够以模块的形式编写和分享他们自己的高级抽象，其他开发者可以简单地安装并
    `require()` 这些模块。
- en: Unlike other programming languages which typically have high-level abstractions
    built in, Node.js was allowed to focus on providing the low-level building blocks
    and the community took care of the rest. The community stepped up by building
    excellent abstractions such as the `Express.js` web application framework, the
    `Sequelize ORM`, and hundreds of thousands of other libraries ready to be used
    after just a simple `npm install` command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他通常内置高级抽象的编程语言不同，Node.js 允许专注于提供低级构建块，而社区则负责其他部分。社区通过构建出色的抽象，如 `Express.js`
    网络应用程序框架、`Sequelize ORM` 以及数以万计的其他库，这些库只需简单的 `npm install` 命令即可使用。
- en: With the advent of Node.js, JavaScript developers with no prior server-side
    language knowledge were now able to build entire full-stack applications. The
    frontend code and backend code could now be written in the same language, by the
    same developers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Node.js 的出现，那些没有先前服务器端语言知识的 JavaScript 开发者现在能够构建完整的全栈应用程序。前端代码和后端代码现在可以由相同的开发者使用同一种语言编写。
- en: Ambitious developers were now building entire applications in JavaScript, though
    they ran into a few issues and solutions along the way. Single-page applications
    fully written in JavaScript became popular, but also became difficult to template
    and organize. The community responded by building frameworks such as **Backbone.js**
    (the spiritual predecessor to frameworks such as Angular and React), **RequireJS**
    (a CommonJS and AMD module loader), and templating languages such as **Mustache**
    (a spiritual predecessor to JSX).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有雄心的开发者现在用 JavaScript 构建整个应用程序，尽管他们在路上遇到了一些问题和解决方案。完全用 JavaScript 编写的单页应用程序变得流行，但也变得难以模板化和组织。社区通过构建框架来回应，例如
    **Backbone.js**（Angular 和 React 等框架的精神前辈）、**RequireJS**（CommonJS 和 AMD 模块加载器）以及模板语言如
    **Mustache**（JSX 的精神前辈）。
- en: When developers ran into issues with SEO on their single-page applications,
    they invented the concept of **isomorphic applications**, or codes that could
    be rendered both server side (so that web spiders could index the content) and
    client side (to keep the application fast and JavaScript-powered). This led to
    the invention of more JavaScript frameworks such as **MeteorJS**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者遇到单页应用程序的 SEO 问题，他们发明了**同构应用程序**的概念，或者能够在服务器端（以便网络爬虫可以索引内容）和客户端（以保持应用程序快速和
    JavaScript 驱动）渲染的代码。这导致了更多 JavaScript 框架如**MeteorJS**的发明。
- en: Eventually, JavaScript developers building single-page applications realized
    that often, their server-side and database requirements were lightweight, requiring
    just authentication, and data storage, and retrieval. This led to the development
    of *serverless* technologies or **database-as-a-service** (**DBaaS**) platforms
    such as **Firebase**, which in turn laid out a path for mobile JavaScript applications
    to become popular. The Cordova/PhoneGap project appeared around the same time,
    allowing developers to wrap their JavaScript code in a native iOS or Android WebView
    component and deploy their JavaScript applications to the mobile app stores.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，构建单页应用的 JavaScript 开发者意识到，通常他们的服务器端和数据库需求很轻量，只需要认证、数据存储和检索。这导致了无服务器技术或**数据库即服务**（DBaaS）平台如**Firebase**的发展，这反过来又为移动
    JavaScript 应用程序的普及铺平了道路。Cordova/PhoneGap 项目大约在同一时间出现，允许开发者将他们的 JavaScript 代码包裹在原生的
    iOS 或 Android WebView 组件中，并将他们的 JavaScript 应用程序部署到移动应用商店。
- en: For our purposes throughout this book, we'll be relying on Node.js and npm very
    heavily. Most of the examples in this book will use ML packages available on npm.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将非常依赖 Node.js 和 npm。本书中的大多数示例将使用 npm 上可用的 ML 包。
- en: TypeScript language
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 语言
- en: The development and sharing of new packages on npm was not the only result of
    JavaScript's popularity. JavaScript's increasing usage as a primary programming
    language caused many developers to lament the lack of IDE and language tooling
    support. Historically, IDEs were more popular with developers of compiled and
    statically-typed languages such as C and Java, as it’s easier to parse and statically
    analyze those types of languages. It wasn't until recently that great IDEs started
    appearing for languages such as JavaScript and PHP, while Java has had IDEs geared
    towards it for many years.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 npm 上开发和共享新包并不是 JavaScript 流行带来的唯一结果。JavaScript 作为主要编程语言的日益普及导致许多开发者哀叹缺乏 IDE
    和语言工具支持。历史上，IDE 在 C 和 Java 等编译和静态类型语言的开发者中更受欢迎，因为这些类型的语言更容易解析和静态分析。直到最近，才出现了针对
    JavaScript 和 PHP 等语言的优秀 IDE，而 Java 已经有多年针对它的 IDE。
- en: Microsoft wanted better tooling and support for their large-scale JavaScript
    projects, but there were a few issues with the JavaScript language itself that
    got in the way. In particular, JavaScript's dynamic typing (the fact that `var
    number` could start its life as the integer **5**, but then be assigned to an
    object later) precludes using static analysis tools to ensure type safety, and
    also makes it difficult for an IDE to find the correct variable or object to autocomplete
    with. Additionally, Microsoft wanted a class-based object-oriented paradigm with
    interfaces and contracts, but JavaScript's object-oriented programming paradigm
    was based on **prototypes**, not classes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 微软希望为他们的大规模 JavaScript 项目提供更好的工具和支持，但 JavaScript 语言本身存在一些问题，阻碍了这一进程。特别是，JavaScript
    的动态类型（例如，`var number` 可能一开始是整数 **5**，但后来被分配给一个对象）排除了使用静态分析工具来确保类型安全，并且也使得 IDE
    难以找到正确的变量或对象来自动完成。此外，微软希望有一个基于类和接口的面向对象范式，但 JavaScript 的面向对象编程范式是基于**原型**的，而不是类。
- en: Microsoft therefore invented the TypeScript language in order to support large-scale
    JavaScript development efforts. TypeScript introduced classes, interfaces, and
    static typing to the language. Unlike Google's Dart, Microsoft made sure TypeScript
    would always be a strict superset of JavaScript, meaning that all valid JavaScript
    is also valid TypeScript. The TypeScript compiler does static type checking at
    compile time, helping developers catch errors early. Support for static typing
    also helps IDEs interpret code more accurately, making for a nicer developer experience.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，微软发明了 TypeScript 语言，以支持大规模的 JavaScript 开发工作。TypeScript 将类、接口和静态类型引入了语言。与
    Google 的 Dart 不同，微软确保 TypeScript 总是 JavaScript 的严格超集，这意味着所有有效的 JavaScript 也是有效的
    TypeScript。TypeScript 编译器在编译时进行静态类型检查，帮助开发者尽早捕获错误。对静态类型的支持还有助于 IDE 更准确地解释代码，从而为开发者提供更好的体验。
- en: Several of TypeScript's early improvements to the JavaScript language have been
    made irrelevant by ECMAScript 2015, or what we call ES6\. For instance, TypeScript's
    module loader, class syntax, and arrow function syntax have been subsumed by ES6,
    and TypeScript now simply uses the ES6 versions of those constructs; however,
    TypeScript still brings static typing to JavaScript, which ES6 wasn't able to
    accomplish.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 对 JavaScript 语言的早期改进中，有一些已经被 ECMAScript 2015（或我们称之为 ES6）所取代。例如，TypeScript
    的模块加载器、类语法和箭头函数语法已被 ES6 所吸收，现在 TypeScript 只使用这些结构的 ES6 版本；然而，TypeScript 仍然为 JavaScript
    带来了静态类型，这是 ES6 无法实现的。
- en: I bring up TypeScript here because, while we won't be using TypeScript in the
    examples in this book, some of the examples of ML libraries we examine here are
    written in TypeScript.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里提到 TypeScript，因为虽然我们不会在本书的示例中使用 TypeScript，但我们考察的一些机器学习库的示例是用 TypeScript
    编写的。
- en: 'For instance, one example found on the `deeplearn.js` tutorials page shows
    code that looks like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `deeplearn.js` 教程页面上的一个示例显示了如下代码：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The syntax looks like ES6 JavaScript except for the new colon notation seen
    in `const x: Tensor = … :` this code is telling the TypeScript compiler that the
    `const x` must be an instance of the `Tensor` class. When TypeScript compiles
    this code, it first checks that everywhere `x` is used expects a `Tensor` (it
    will throw an error if not), and then it simply discards the type information
    when compiling to JavaScript. Converting the preceding TypeScript code to JavaScript
    is as simple as removing the colon and the `Tensor` keyword from the variable
    definition.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '语法看起来像 ES6 JavaScript，除了在 `const x: Tensor = …:` 中看到的新的冒号表示法，这段代码是在告诉 TypeScript
    编译器 `const x` 必须是 `Tensor` 类的实例。当 TypeScript 编译此代码时，它首先检查 `x` 在所有使用的地方是否期望是 `Tensor`（如果不是，将抛出错误），然后简单地丢弃编译到
    JavaScript 时的类型信息。将前面的 TypeScript 代码转换为 JavaScript 只需从变量定义中移除冒号和 `Tensor` 关键字即可。'
- en: You are welcome to use TypeScript in your own examples as you follow along with
    this book, however, you will have to update the build process that we set up later
    to support TypeScript.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在跟随本书的过程中在自己的示例中使用 TypeScript，但是您必须更新我们稍后设置的构建过程以支持 TypeScript。
- en: Improvements in ES6
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES6 的改进
- en: The ECMAScript committee, which defines the specification for the JavaScript
    language itself, released a new specification called ECMAScript 6/ECMAScript 2015
    in June 2015\. The new standard, called **ES6** for short, was a major revision
    of the JavaScript programming language and added a number of new paradigms intended
    to make development of JavaScript programs easier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 JavaScript 语言本身的规范的 ECMAScript 委员会在 2015 年 6 月发布了一个新的规范，称为 ECMAScript 6/ECMAScript
    2015。这个新标准简称为 **ES6**，是对 JavaScript 编程语言的重大修订，并增加了一些旨在使 JavaScript 程序开发更容易的新范式。
- en: While ECMAScript defines the specification for the JavaScript language, the
    actual implementation of the language is dependent on the browser vendors and
    the maintainers of the various JavaScript engines. ES6 by itself is only a guideline,
    and because the browser vendors each have their own timeline for implementing
    new language features, the JavaScript language and the JavaScript implementations
    diverged slightly. Features defined by ES6, such as classes, were not available
    in the major browsers, but developers wanted to use them anyway.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ECMAScript 定义了 JavaScript 语言的规范，但语言的实际实现依赖于浏览器供应商和各种 JavaScript 引擎的维护者。ES6
    本身只是一个指南，由于浏览器供应商各自有自己的时间表来实现新的语言特性，JavaScript 语言及其实现略有分歧。ES6 定义的特性，如类，在主要浏览器中不可用，但开发者仍然想使用它们。
- en: Enter **Babel**, the JavaScript transpiler. Babel can read and parse different
    JavaScript flavors (such as ES6, ES7, ES8, and React JSX) and convert it or compile
    it into browser-standard ES5\. Even today, the entirety of ES6 has not yet been
    implemented by the browser vendors, so Babel remains an essential tool for developers
    wishing to write ES6 code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 来到 **Babel**，JavaScript 转译器。Babel 可以读取和解析不同的 JavaScript 版本（如 ES6、ES7、ES8 和 React
    JSX），并将其转换为或编译为浏览器标准的 ES5。即使今天，浏览器厂商还没有完全实现 ES6，所以 Babel 对于希望编写 ES6 代码的开发者来说仍然是一个必不可少的工具。
- en: The examples in this book will use ES6\. If you're not yet familiar with the
    newer syntax, here are a few of the major features you'll see used throughout
    this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例将使用 ES6。如果你还不熟悉新的语法，以下是本书中将使用的一些主要特性。
- en: Let and const
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Let 和 const
- en: 'In ES5 JavaScript, we use the `var` keyword to define variables. In most cases,
    `var` can simply be replaced with `let`, with the major difference between the
    two constructs being the scoping of the variable with respect to blocks. The following
    example from **MDN web docs**, or previously **Mozilla Developer Network** ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)),
    demonstrates the subtle difference between the two:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 JavaScript 中，我们使用 `var` 关键字来定义变量。在大多数情况下，`var` 可以简单地替换为 `let`，这两个构造之间的主要区别是变量相对于代码块的可见性。以下来自
    **MDN 网络文档**（或之前称为 **Mozilla 开发者网络**）的例子（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)）展示了这两个之间的微妙差异：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, while you must use additional caution in cases like the preceding one, in
    most cases you can simply replace `var` with `let`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然你必须在像前面那样的情况下更加小心，但在大多数情况下，你只需将 `var` 替换为 `let`。
- en: 'The `const` keyword, unlike `let`, defines a variable as a constant; that is,
    you cannot reassign a variable initialized with `const` at a later date. For example,
    the following code causes an error with a message similar to `invalid assignment
    to const a`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `let` 不同，`const` 关键字定义了一个常量变量；也就是说，你无法在以后重新分配用 `const` 初始化的变量。例如，以下代码会导致一个类似于
    `invalid assignment to const a` 的错误信息：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the other hand the same code, using `var` or `let` to define `a`, would run
    successfully.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用 `var` 或 `let` 来定义 `a` 的相同代码将成功运行。
- en: Note that if `a` is an object, you are allowed to modify object properties of
    `a`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 `a` 是一个对象，你可以修改 `a` 的对象属性。
- en: 'The following code will run successfully:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将成功运行：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, attempting to redefine objects such as in `obj = {name: “other object”}`
    would cause an error.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，尝试重新定义对象，如 `obj = {name: “other object”}`，会导致错误。'
- en: I find that in most programming contexts, `const` is typically more appropriate
    than `let`, as most variables you use never need to be redefined. My recommendation
    is to use `const` as much as you can, and use `let` only when you have a reason
    to redefine the variable later.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，在大多数编程环境中，`const` 通常比 `let` 更合适，因为大多数你使用的变量永远不会需要重新定义。我的建议是尽可能多地使用 `const`，只有在有理由在以后重新定义变量时才使用
    `let`。
- en: Classes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'One very welcome change in ES6 is the addition of classes and class inheritance.
    Previously, object-oriented programming in JavaScript required prototypical inheritance,
    which many developers found unintuitive, like the following ES5 example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，一个非常受欢迎的变化是类和类的继承的添加。之前，JavaScript 中的面向对象编程需要原型继承，这让许多开发者觉得不直观，就像以下
    ES5 的例子：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, extending an object requires calling the parent class
    in the child's `constructor` function, creating a clone of the parent's prototype
    object, and overriding the parent's prototype constructor with the child's prototype
    constructor. These steps were seen as unintuitive and burdensome by most developers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，扩展一个对象需要在子类的 `constructor` 函数中调用父类，创建父类原型对象的克隆，并用子类的原型构造函数覆盖父类的原型构造函数。这些步骤被大多数开发者视为不直观且繁重。
- en: 'Using ES6 classes, however, the code will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 ES6 类，代码将看起来像这样：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding syntax is more in line with what we'd expect from object-oriented
    programming, and also makes inheritance much simpler.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法更符合我们对面向对象编程的预期，并且使继承变得更加简单。
- en: It's important to note that under the hood, ES6 classes still use JavaScript's
    prototypical inheritance paradigm. Classes are just syntactic sugar on top of
    the existing system, so there is no significant difference between these two approaches
    other than clean code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在底层，ES6 类仍然使用 JavaScript 的原型继承范式。类只是现有系统之上的语法糖，因此这两种方法之间除了代码整洁性外，没有显著的区别。
- en: Module imports
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块导入
- en: 'ES6 also defines a module import and export interface. With the older CommonJS
    approach, modules are exported using the `modules.export` construct, and modules
    are imported with the `require(filename)` function. The ES6 approach looks a little
    different. In one file, define and export a class, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 还定义了一个模块导入和导出接口。使用较旧的 CommonJS 方法，模块通过 `module.exports` 构造导出，模块通过 `require(filename)`
    函数导入。ES6 方法看起来略有不同。在一个文件中，定义并导出一个类，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And in another file, import the class, as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个文件中，导入类，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At present, Babel compiles ES6 modules to the same format as CommonJS modules,
    so you can use either the ES6 modules syntax or the CommonJS modules syntax if
    you’re using Babel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Babel 将 ES6 模块编译成与 CommonJS 模块相同的格式，所以如果你使用 Babel，你可以使用 ES6 模块语法或 CommonJS
    模块语法。
- en: Arrow functions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'One quirky, useful, but somewhat annoying aspect of ES5 JavaScript is its heavy
    use of callbacks that run asynchronously. You are probably intimately familiar
    with jQuery code that looks something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ES5 JavaScript 中的一个奇特、有用但有些令人烦恼的方面是其对异步回调的广泛使用。你可能非常熟悉类似以下这样的 jQuery 代码：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're forced to create a variable called `$self` because the original `this`
    context is lost in our inner anonymous function. We also have a lot of boilerplate
    and difficult-to-read code due to needing to create three separate anonymous functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被迫创建一个名为 `$self` 的变量，因为原始的 `this` 上下文在我们的内部匿名函数中丢失了。我们还因为需要创建三个单独的匿名函数而有大量的样板代码和难以阅读的代码。
- en: Arrow function syntax is both syntactic sugar that helps us write anonymous
    functions with a shorter syntax, and also a functional update that preserves the
    context of `this` inside an arrow function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数语法既是帮助我们用更短的语法编写匿名函数的语法糖，也是对函数式编程的更新，它保留了箭头函数内部 `this` 的上下文。
- en: 'For instance, the preceding code may be written in ES6 as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述代码可以用 ES6 写成如下所示：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see in the preceding code that we no longer need a `$self` variable
    to preserve `this`, and our call to `.map` is much simpler, no longer requiring
    the `function` keyword, parentheses, curly braces, or a `return` statement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在上述代码中看到，我们不再需要 `$self` 变量来保留 `this`，并且我们的 `.map` 调用要简单得多，不再需要 `function`
    关键字、括号、大括号或 `return` 语句。
- en: 'Now let''s look at some equivalent functions. Let''s look at the following
    code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些等效函数。让我们看看以下代码：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code would be similar to:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码类似于：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the aforementioned examples, we can omit the parentheses around the `number`
    parameter because the function only requires one parameter. If the function required
    two parameters, we would be required to add parentheses as in the next example.
    Additionally, if the body of our function only requires one line, we can omit
    the function body curly braces and omit the `return` statement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们可以省略 `number` 参数周围的括号，因为该函数只需要一个参数。如果函数需要两个参数，我们就会像下一个示例中那样需要添加括号。此外，如果我们的函数体只需要一行，我们可以省略函数体的大括号和
    `return` 语句。
- en: 'Let''s look at another equivalence, with multiple parameters, as shown in the
    following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个等效示例，具有多个参数，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code would be similar to:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码类似于：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I find that arrow functions make themselves most useful in situations like the
    preceding one, when you're doing data transformations, especially where using
    `Array.map`, `Array.filter`, `Array.reduce`, and `Array.sort` calls with straightforward
    function bodies. Arrow functions are less useful in jQuery because of jQuery's
    tendency to give you data using the `this` context, which you don't receive with
    anonymous arrow functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现箭头函数在像上述这样的情况下最有用，当你正在做数据转换，尤其是在使用 `Array.map`、`Array.filter`、`Array.reduce`
    和 `Array.sort` 调用具有简单函数体时。由于 jQuery 倾向于使用 `this` 上下文提供数据，而匿名箭头函数不会提供 `this`，因此箭头函数在
    jQuery 中不太有用。
- en: Object literals
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象字面量
- en: 'ES6 makes some improvements to object literals. There are several improvements,
    but the one you''ll see most is the implicit naming of object properties. In ES5
    it would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ES6对对象字面量进行了一些改进。有几个改进，但你最常看到的是对象属性的隐式命名。在ES5中，它将是这样的：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In ES6, if the property name and the variable name are the same as the preceding
    one, you can simplify it to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，如果属性名和变量名与前面相同，你可以简化为以下形式：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Additionally, ES6 introduces the object spread operator, which simplifies shallow
    object merges. For instance, take a look at the following code in ES5:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ES6引入了对象扩展运算符，它简化了浅层对象合并。例如，看看以下ES5中的代码：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will create a new object from `defaultPreferences`, and merge
    in properties from `userPreferences`. Passing an empty object to the `Object.assign` instance
    first parameter ensures that we create a new object rather than overwriting `defaultPreferences`
    (which isn't an issue in the preceding example, but is an issue in real-life use
    cases).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将从`defaultPreferences`创建一个新的对象，并合并`userPreferences`中的属性。将空对象传递给`Object.assign`实例的第一个参数确保我们创建一个新的对象，而不是覆盖`defaultPreferences`（在前面示例中这不是问题，但在实际使用场景中是问题）。
- en: 'And now, let''s take a look at the same in ES6:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看ES6中的相同代码：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This approach does the same as the ES5 example, but is quicker and easier to
    read in my opinion than the `Object.assign` method. Developers familiar with React
    and Redux, for instance, often use the object spread operator when managing reducer
    state operations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与ES5示例做的是同样的事情，但在我看来，它比`Object.assign`方法更快、更容易阅读。例如，熟悉React和Redux的开发者经常在管理reducer状态操作时使用对象扩展运算符。
- en: The for...of function
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for...of函数
- en: 'The `for` loops over arrays in ES5 are often achieved using the `for (index
    in array)` syntax, which looks something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，通过数组中的`for`循环通常使用`for (index in array)`语法，它看起来像这样：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And ES6 adds the `for...of` syntax, which saves you a step, as you can see
    from the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ES6添加了`for...of`语法，这可以节省你一步，正如你从下面的代码中可以看到的那样：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Promises
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: Promises, in one form or another, have been available in JavaScript for a while.
    All jQuery users are familiar with the idea. A **promise** is a reference to a
    variable that is generated asynchronously and may become available in the future.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种形式或另一种形式，承诺在JavaScript中已经存在了一段时间。所有jQuery用户都熟悉这个概念。**承诺**是对一个异步生成并在未来可能可用的变量的引用。
- en: 'The ES5 way of doing things, if you weren''t already using some sort of third-party
    promise library or jQuery''s deferred''s, was to accept a callback function to
    an asynchronous method and run the callback upon successful completion, as shown
    in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用某种第三方承诺库或jQuery的deferred，那么在ES5中处理事情的方式是接受一个异步方法的回调函数，并在成功完成后运行该回调，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In ES6, you may return a `Promise` which encapsulates the asynchronous request
    and either gets resolved or rejected, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，你可以返回一个封装异步请求的`Promise`，它要么被解决，要么被拒绝，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The real power of promises is that they can be passed around as objects, and
    promise handlers can be chained.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的真正力量在于它们可以被当作对象传递，并且承诺处理器可以被链式调用。
- en: The async/await functions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async/await函数
- en: The `async` and `await` keywords are not an ES6 feature but rather an ES8 feature.
    While promises bring huge improvements to the way we deal with asynchronous calls,
    promises also are susceptible to lots of method chaining, and in some cases force
    us to use asynchronous paradigms when we really just want to write a function
    that acts asynchronously but reads as if it were a synchronous function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`和`await`关键字不是ES6特性，而是ES8特性。虽然承诺极大地改进了我们处理异步调用的方式，但承诺也容易受到大量方法链的影响，在某些情况下，迫使我们使用异步范式，而实际上我们只想编写一个异步但看起来像同步函数的函数。'
- en: 'Now let''s take a look at the following example from MDN''s asynchronous function
    reference page ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看MDN异步函数参考页面上的以下示例（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)）：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `resolveAfter2Seconds` function is a normal JavaScript function that returns
    an ES6 promise. The magic is in the `asyncCall` function, which is marked by the
    `async` keyword. Inside `asyncCall`, we invoke `resolveAfter2Seconds` with the
    `await` keyword, rather than using the more familiar promise `.then(result =>
    console.log(result))` construct we'd normally use in ES6\. The `await` keyword
    makes our `async` function wait for the promise to resolve before continuing,
    and returns the result of the `Promise` directly. In this manner, `async`/`await`
    can convert asynchronous functions that use promises to read like synchronous
    functions, which should help keep deeply nested promise calls and asynchronous
    function stats neat and easy to read.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolveAfter2Seconds` 函数是一个普通的 JavaScript 函数，它返回一个 ES6 promise。魔法在于 `asyncCall`
    函数，它被 `async` 关键字标记。在 `asyncCall` 内部，我们使用 `await` 关键字调用 `resolveAfter2Seconds`，而不是使用在
    ES6 中更熟悉的 promise `.then(result => console.log(result))` 构造。`await` 关键字使我们的 `async`
    函数在继续之前等待 promise 解析，并直接返回 `Promise` 的结果。以这种方式，`async`/`await` 可以将使用 promises
    的异步函数转换为类似同步函数，这应该有助于保持深层嵌套的 promise 调用和异步函数调用整洁且易于阅读。'
- en: The `async` and `await` features are part of ES8, not ES6, so when we set up
    Babel in a few minutes we'll need to be sure to include all new versions of EMCAScript
    in our configuration, not just ES6.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 功能是 ES8 的部分，而不是 ES6，所以当我们几分钟内设置 Babel 时，我们需要确保在我们的配置中包含所有新的
    ECMAScript 版本，而不仅仅是 ES6。'
- en: Preparing the development environment
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: The examples in this book will use both the web browser environment and the
    Node.js environment. While Node.js Version 8 and higher has support for ES6+,
    not all browser vendors have complete support yet for ES6+ features, and we will
    therefore be using Babel to transpile all of our code regardless.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例将使用网络浏览器环境和 Node.js 环境。虽然 Node.js 版本 8 和更高版本支持 ES6+，但并非所有浏览器供应商都完全支持 ES6+
    功能，因此我们将使用 Babel 将所有代码进行转译。
- en: This book will try its best to use the same project structure for all examples,
    whether they're executed on the command line in Node.js or run in the browser.
    Because we're attempting to standardize this project structure, not every project
    will use all of the features we set up in this section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将尽可能为所有示例使用相同的工程项目结构，无论它们是在 Node.js 命令行中执行还是在浏览器中运行。因为我们正在尝试标准化这个项目结构，所以并非每个项目都会使用我们在本节中设置的所有功能。
- en: 'The tools you will need are:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要的工具是：
- en: Your favorite code editor, such as Vim, Emacs, Sublime Text, or WebStorm
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您喜欢的代码编辑器，例如 Vim、Emacs、Sublime Text 或 WebStorm
- en: An up-to-date web browser such as Chrome or Firefox
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个最新的网络浏览器，如 Chrome 或 Firefox
- en: Node.js Version 8 LTS or higher; this book will use version 9.4.0 for all examples
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 版本 8 LTS 或更高；本书将使用 9.4.0 版本进行所有示例
- en: The Yarn package manager (optional; you may use npm instead)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yarn 软件包管理器（可选；您也可以使用 npm）
- en: Various build tools such as Babel and Browserify
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种构建工具，如 Babel 和 Browserify
- en: Installing Node.js
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Node.js
- en: If you're a macOS user, the easiest way to install Node.js is through a package
    manager such as **Homebrew** or **MacPorts**. For best compatibility with the
    examples in this book, install Node.js version 9.4.0 or greater.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 macOS 用户，通过软件包管理器如 **Homebrew** 或 **MacPorts** 安装 Node.js 是最简单的方法。为了与本书中的示例获得最佳兼容性，请安装
    9.4.0 或更高版本的 Node.js。
- en: 'Windows users can also use the **Chocolatey** package manager to install Node.js,
    otherwise you may follow the instructions on the Node.js current download page:
    [https://nodejs.org/en/](https://nodejs.org/en/).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户也可以使用 **Chocolatey** 软件包管理器来安装 Node.js，否则您可以遵循 Node.js 当前下载页面上的说明：[https://nodejs.org/en/](https://nodejs.org/en/).
- en: Linux users should be careful if installing Node.js through their distribution's
    package manager, as the shipped version of Node.js may be a much older version.
    If your package manager uses a version older than V8, you may either add a repository
    to your package manager, build from source, or install from binary, as appropriate
    for your system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 用户如果通过其发行版的软件包管理器安装 Node.js，应小心谨慎，因为提供的 Node.js 版本可能非常旧。如果您的软件包管理器使用低于
    V8 的版本，您可以选择为软件包管理器添加仓库、从源代码构建或根据您的系统安装二进制文件。
- en: 'Once you''ve installed Node.js, ensure that it runs and is the correct version
    by running `node --version` from the command line. The output will look like the
    following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Node.js 后，通过在命令行中运行 `node --version` 确保它运行并且是正确的版本。输出将如下所示：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is also a good time to test that `npm` also works:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是测试 `npm` 是否正常工作的好时机：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Optionally installing Yarn
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选安装 Yarn
- en: Yarn is a package management tool similar to and compatible with npm, though
    I find it is faster and easier to work with. If using Homebrew on macOS, you may
    simply install it using `brew install yarn`; otherwise follow the instructions
    found on Yarn's installation guide page ([https://yarnpkg.com/en/docs/install#windows-stable](https://yarnpkg.com/en/docs/install#windows-stable)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Yarn是一个类似于npm且与npm兼容的包管理工具，尽管我发现它运行更快，更容易使用。如果您在macOS上使用Homebrew，您可以使用`brew
    install yarn`简单地安装它；否则，请按照Yarn安装指南页面上的说明操作（[https://yarnpkg.com/en/docs/install#windows-stable](https://yarnpkg.com/en/docs/install#windows-stable)）。
- en: If you want to use npm instead of Yarn, you may; both respect the same format
    for `package.json`, though they have slightly different syntaxes for commands
    such as `add`, `require`, and `install`. If you're using npm instead of Yarn,
    simply replace the commands with the correct function; the package names used
    will all be the same.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用npm而不是Yarn，您也可以；它们都尊重相同的`package.json`格式，尽管它们在`add`、`require`和`install`等命令的语法上略有不同。如果您使用npm而不是Yarn，只需将命令替换为正确的函数；使用的包名都将相同。
- en: Creating and initializing an example project
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和初始化示例项目
- en: Use the command line, your favorite IDE, or your file browser to create a directory
    somewhere on your machine called `MLinJSBook`, with a subdirectory called `Ch1-Ex1`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行、您喜欢的IDE或文件浏览器，在您的机器上创建一个名为`MLinJSBook`的目录，并创建一个名为`Ch1-Ex1`的子目录。
- en: Navigate your command line to the `Ch1-Ex1` folder, and run the command `yarn
    init`, which like `npm init` will create a `package.json` file and prompt you
    for basic information. Respond to the prompts, answering appropriately. You will
    not be publishing this package so the answers aren't too important, however, when
    prompted for the application's entry point, type in `dist/index.js`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将命令行导航到`Ch1-Ex1`文件夹，并运行命令`yarn init`，它类似于`npm init`，将创建一个`package.json`文件，并提示您输入基本信息。根据提示进行回答，答案并不重要，但是当被提示输入应用程序的入口点时，请输入`dist/index.js`。
- en: 'Next, we need to install a few build tools that we''ll use for the majority
    of our example projects:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装一些我们将用于大多数示例项目的构建工具：
- en: '`babel-core`: The Babel transpiler core'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel-core`：Babel转译器核心'
- en: '`babel-preset-env`: The Babel parser preset that parses ES6, ES7, and ES8 code'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel-preset-env`：解析ES6、ES7和ES8代码的Babel解析器预设'
- en: '`browserify`: A JavaScript bundler which can compile multiple files into a
    single file'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browserify`：一个可以将多个文件编译成一个文件的JavaScript打包器'
- en: '`babelify`: The Babel plugin for Browserify'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babelify`：Browserify的Babel插件'
- en: 'Install these as development environment requirements by issuing the following
    command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令安装这些作为开发环境需求：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a Hello World project
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Hello World项目
- en: To test that everything is building and running, we'll create a very simple
    two-file Hello World project and add our build script.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一切是否正在构建和运行，我们将创建一个非常简单的包含两个文件的Hello World项目，并添加我们的构建脚本。
- en: 'First, create two subdirectories under your `Ch1-Ex1` folder: `src` and `dist`.
    We''ll use this convention for all projects: `src` will contain JavaScript source
    code, `dist` will contain built source code and any additional assets (images,
    CSS, HTML files, and so on) required by the project.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的`Ch1-Ex1`文件夹下创建两个子文件夹：`src`和`dist`。我们将为所有项目使用此约定：`src`将包含JavaScript源代码，`dist`将包含构建源代码以及项目所需的任何附加资源（图像、CSS、HTML文件等）。
- en: 'In the `src` folder, create a file called `greeting.js` with the following
    code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，创建一个名为`greeting.js`的文件，并包含以下代码：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then create another file called `index.js` with the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建另一个名为`index.js`的文件，并包含以下内容：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This small application tests whether we can use basic ES6 syntax and module
    loading, as well as access command-line arguments given to Node.js.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小型应用程序测试我们是否可以使用基本的ES6语法和模块加载，以及访问传递给Node.js的命令行参数。
- en: 'Next, open up the `package.json` file in `Ch1-Ex1`, and add the following section
    to the file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`Ch1-Ex1`中的`package.json`文件，并将以下部分添加到文件中：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This defines three simple command-line scripts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了三个简单的命令行脚本：
- en: '`Build-web` uses Browserify and Babel to compile everything that `src/index.js`
    touches into a single file called `dist/index.js`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Build-web`使用Browserify和Babel将`src/index.js`接触到的所有内容编译成一个名为`dist/index.js`的单个文件'
- en: '`Build-cli` is similar to `build-web`, except it also uses Browserify''s node
    option flag; without this option we would not be able to access command-line arguments
    given to Node.js'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Build-cli`与`build-web`类似，但它还使用了Browserify的node选项标志；如果没有这个选项，我们就无法访问传递给Node.js的命令行参数'
- en: '`Start` is intended only for CLI/Node.js examples, and both builds and runs
    the source code'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start`仅适用于CLI/Node.js示例，并且构建和运行源代码'
- en: 'Your `package.json` file should now look something like the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`package.json`文件现在应该看起来像以下这样：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s put this simple application through a few tests. First, make sure that
    `yarn build-cli` works. You should see something like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对这个简单应用进行一些测试。首先，确保`yarn build-cli`命令可以正常工作。你应该会看到以下类似的内容：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this point, confirm that the `dist/index.js` file has been built, and try
    running it directly, using the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，确认`dist/index.js`文件已经被构建，并尝试直接运行它，使用以下代码：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also try passing in your name as an argument to the command, using the following
    code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 也尝试将你的名字作为参数传递给命令，使用以下代码：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s try the `build-web` command, as shown in the following code. Because
    this command omits the `node` option, we expect that our argument will not work:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试`build-web`命令，如下所示代码。因为这个命令省略了`node`选项，我们预计我们的参数将不会起作用：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Without the `node` option, our arguments are not forwarded to the script, and
    it defaults to saying `Hello, world!`, which is the expected result here.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`node`选项，我们的参数不会被传递到脚本中，并且默认显示`Hello, world!`，这是预期的结果。
- en: 'Finally, let''s test our `yarn start` command, using the following code, to
    make sure it builds the CLI version of the application and also forwards our command-line
    arguments, using the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下代码测试我们的`yarn start`命令，以确保它构建了应用程序的CLI版本，并且也传递了我们的命令行参数，使用以下代码：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `yarn start` command successfully built the CLI version of the application
    and forwarded our command-line arguments to the program.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`yarn start`命令成功构建了应用程序的CLI版本，并将我们的命令行参数传递给了程序。'
- en: We will try our best to use the same structure for each of the examples in this
    book, however, pay attention to the beginning of each chapter as each example
    may require some additional setup work.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尽力为本书中的每个示例使用相同的结构，然而，请注意每个章节的开头，因为每个示例可能需要一些额外的设置工作。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've discussed the important moments of JavaScript's history
    as applied to ML, starting from the launch of Google ([https://www.google.com/](https://www.google.com/))
    and finishing up at the end of 2017 with the release of Google's `deeplearn.js`
    library.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了JavaScript在机器学习中的应用中的重要时刻，从Google的推出([https://www.google.com/](https://www.google.com/))开始，到2017年底Google的`deeplearn.js`库发布结束。
- en: We’ve discussed some advantages to using JavaScript for machine learning, and
    also some of the challenges we’re facing, particularly in terms of the machine
    learning ecosystem.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用JavaScript进行机器学习的优势，以及我们面临的挑战，特别是在机器学习生态系统方面。
- en: We then took a tour of the most important recent developments in the JavaScript
    language, and had a brief introduction to ES6, the newest stable JavaScript language
    specification.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们游览了JavaScript语言最近最重要的进展，并对最新的JavaScript语言规范ES6进行了简要介绍。
- en: Finally, we set up an example development environment using Node.js, the Yarn
    package manager, Babel, and Browserify—tools that we will use throughout the rest
    of the book in our examples.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Node.js、Yarn包管理器、Babel和Browserify——这些工具将在本书的其余部分示例中使用——设置了一个示例开发环境。
- en: In the next chapter, we'll begin exploring and processing the data itself.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探索和处理数据本身。
