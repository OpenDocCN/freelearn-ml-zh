- en: '*Chapter 8*: TPOT Model Deployment'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*: TPOT模型部署'
- en: In this chapter, you'll learn how to deploy any automated machine learning model,
    both to localhost and the cloud. You'll learn why the deployment step is necessary
    if you aim to make machine learning-powered software. It's assumed you know how
    to train basic regression and classification models with TPOT. Knowledge of the
    topics of the last couple of chapters (Dask and neural networks) isn't required,
    as we won't deal with those here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何将任何自动化机器学习模型部署到本地主机和云端。您将了解到如果您旨在创建机器学习驱动的软件，部署步骤是必要的。假设您知道如何使用TPOT训练基本的回归和分类模型。不需要了解前几章（Dask和神经网络）的主题，因为我们在这里不会涉及这些内容。
- en: Throughout the chapter, you'll learn how easy it is to wrap your models in an
    API and expose their predictive capabilities to other users that aren't necessarily
    data scientists. You'll also learn which cloud providers are the best to get you
    started entirely for free.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解到将模型封装在API中并向非数据科学家用户暴露其预测能力是多么容易。您还将了解到哪些云服务提供商最适合您免费开始。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why do we need model deployment?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要模型部署？
- en: Introducing `Flask` and `Flask-RESTful`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`Flask`和`Flask-RESTful`
- en: Best practices for deploying automated models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化模型部署的最佳实践
- en: Deploying machine learning models to localhost
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将机器学习模型部署到本地主机
- en: Deploying machine learning models to the cloud
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将机器学习模型部署到云端
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As briefly said earlier, you need to know how to build basic machine learning
    models with TPOT. Don't worry if you don't feel too comfortable with the library
    yet, as we'll develop the model from scratch. If you're entirely new to TPOT,
    please refer to [*Chapter 2*](B16954_02_Final_SK_ePub.xhtml#_idTextAnchor036),
    *Deep Dive into TPOT*, [*Chapter 3*](B16954_03_Final_SK_ePub.xhtml#_idTextAnchor051),
    *Exploring Regression with TPOT*, and [*Chapter 4*](B16954_04_Final_SK_ePub.xhtml#_idTextAnchor058),
    *Exploring Classification with TPOT*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您需要知道如何使用TPOT构建基本的机器学习模型。如果您对库还不够熟悉，请不要担心，我们将从头开始开发模型。如果您是TPOT的完全新手，请参阅[*第2章*](B16954_02_Final_SK_ePub.xhtml#_idTextAnchor036)，*深入TPOT*，[*第3章*](B16954_03_Final_SK_ePub.xhtml#_idTextAnchor051)，*使用TPOT探索回归*，和[*第4章*](B16954_04_Final_SK_ePub.xhtml#_idTextAnchor058)，*使用TPOT探索分类*。
- en: 'This chapter will be quite code-heavy, so you can refer to the official GitHub
    repository if you get stuck: [https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter08](https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter08).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包含大量的代码，因此如果您遇到困难，可以参考官方GitHub仓库：[https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter08](https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter08)。
- en: Why do we need model deployment?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要模型部署？
- en: If you're already going through the hassle of training and optimizing machine
    learning models, why don't you take it a step further and deploy it so everyone
    can use it?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在费劲周折地训练和优化机器学习模型，为什么不更进一步，将其部署出来供每个人使用呢？
- en: Maybe you want to have the model's predictive capabilities available in a web
    application. Perhaps you're a mobile app developer who wants to bring machine
    learning to Android and iOS. The options are endless and different, but all of
    them share one similarity – the need to be deployed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您希望将模型的预测能力集成到Web应用程序中。也许您是一位希望将机器学习带到Android和iOS的移动应用开发者。选项无穷无尽，但它们都有一个共同点——需要部署。
- en: Now, machine learning model deployment has nothing to do with machine learning.
    The aim is to write a simple REST API (preferably in Python, since that's the
    language used throughout the book) and expose any form of endpoint that calls
    a `predict()` function to the world. You want parameters sent to your application
    in JSON format, and then to use them as inputs to your model. Once the prediction
    is made, you can simply return it to the user.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，机器学习模型部署与机器学习本身无关。目标是编写一个简单的REST API（最好使用Python，因为本书中使用的语言是Python）并将调用`predict()`函数的任何形式的端点暴露给世界。您希望以JSON格式发送参数到您的应用程序，并将它们用作模型的输入。一旦做出预测，您只需将其返回给用户即可。
- en: Yes, that's all there is to machine learning model deployment. Of course, things
    could get more technical, but keeping things simple will get us 95% of the way,
    and you can always explore further to squeeze that extra 5%.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是机器学习模型部署的全部内容。当然，事情可能会变得更加技术化，但保持简单将让我们达到 95% 的效果，而你总是可以进一步探索以获得额外的 5%。
- en: When it comes to the technical side of model deployment, Python provides you
    with a bunch of options. You can use either `Flask` and `Flask-RESTful`, `FastAPI`,
    `Django`, or `Pyramid`. There are other options, sure, but their "market share"
    is more or less negligible. You'll use the first option in this chapter, starting
    from the next section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到模型部署的技术方面时，Python 为你提供了一系列选项。你可以使用 `Flask` 和 `Flask-RESTful`、`FastAPI`、`Django`
    或 `Pyramid`。当然，还有其他选项，但它们的“市场份额”或多或少可以忽略不计。你将在本章的下一节开始使用第一个选项。
- en: The section that follows aims to introduce you to the libraries with a couple
    of basic hands-on examples. We'll dive into machine learning afterward.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分旨在通过几个基本的动手示例介绍这些库。之后，我们将深入了解机器学习。
- en: Introducing Flask and Flask-RESTful
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Flask 和 Flask-RESTful
- en: '`Flask` is a lightweight framework for building web applications. It enables
    you to start simple and scale when needed. `Flask-RESTful` is an extension for
    `Flask` that allows you to build REST APIs in no time.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask` 是一个用于构建 Web 应用的轻量级框架。它使你能够简单开始，并在需要时进行扩展。`Flask-RESTful` 是 `Flask`
    的一个扩展，它允许你快速构建 RESTful API。'
- en: 'To get started with these two, you''ll need to install them. You can execute
    the following line from the terminal:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用这两个库，你需要安装它们。你可以在终端中执行以下行：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And that''s all you need to get started. Let''s explore the basics of `Flask`
    first:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要开始的地方。让我们首先探索 `Flask` 的基础知识：
- en: Believe it or not, you'll need only seven lines of code to create your first
    web application with `Flask`. It won't do anything useful, but it's still a step
    in the right direction.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信不信由你，你只需要七行代码就可以使用 `Flask` 创建你的第一个 Web 应用程序。它可能不会做任何有用的事情，但这仍然是一个正确的方向。
- en: To start, you'll need to import the library and create an application instance.
    You'll then have to make a function that returns what you want to be displayed
    on the website and decorate the function with an `@app.route(route_url)` decorator.
    Keep in mind that you should replace `route_url` with the URL string at which
    the function should display the result. If you pass in a forward slash (`/`),
    the results will be displayed on the root page – but more about that in a bit.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，你需要导入库并创建一个应用程序实例。然后，你需要创建一个函数，该函数返回你想要在网站上显示的内容，并用 `@app.route(route_url)`
    装饰器装饰该函数。请记住，你应该用函数应该显示结果的 URL 字符串替换 `route_url`。如果你传递一个正斜杠（`/`），结果将在根页面上显示——但关于这一点，我们稍后再说。
- en: Finally, you'll have to make the Python file runnable with an `if __name__ ==
    '__main__'` check. The application will run on localhost on port `8000`.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，你必须使用 `if __name__ == '__main__'` 检查使 Python 文件可执行。应用程序将在本地的 `8000` 端口上运行。
- en: 'Refer to the following code snippet for your first `Flask` application:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参考以下代码片段以了解你的第一个 `Flask` 应用程序：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run the application, you''ll have to execute the Python file from the terminal.
    The file is named `flask_basics.py` on my machine, so to run it, please execute
    the following:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要运行应用程序，你必须在终端中执行 Python 文件。在我的机器上，该文件被命名为 `flask_basics.py`，因此要运行它，请执行以下操作：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By now, you know how to build the simplest application with `Flask` – but that's
    not why you're here. We want to make APIs instead of apps, and that's a bit of
    a different story. The difference between them is quite obvious – APIs don't come
    with a user interface (except for the documentation page), whereas web apps do.
    APIs are just a service. As it turns out, you can build APIs with `Flask` out
    of the box. We'll explore how to do so and explain why it isn't the best option.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道如何使用 `Flask` 构建最简单的应用程序——但这不是你来的原因。我们想要构建 API 而不是应用程序，这是一个不同的故事。它们之间的区别相当明显——API
    不带用户界面（除了文档页面），而 Web 应用程序则带。API 只是一个服务。实际上，你可以使用 `Flask` 直接构建 API。我们将探讨如何做到这一点，并解释为什么这不是最佳选择。
- en: 'To start, create a new Python file. This file will be referenced as `flask_basics2.py`.
    Inside it, we''ll have a single route for two possible API call types. Both have
    the task of adding two numbers and returning the results, but they do so differently.
    Let''s list the differences:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 Python 文件。这个文件将被引用为 `flask_basics2.py`。在里面，我们将有一个用于两种可能的 API 调用类型的单个路由。它们都有添加两个数字并返回结果的任务，但它们以不同的方式完成。让我们列出这些差异：
- en: a) `/adding` (GET) relies on the logic implemented earlier. To be more precise,
    a GET request is made when the endpoint is called. The only difference is that
    this time, the parameters are passed in the URL. For example, calling `/adding?num1=3&num2=5`
    should display `8` onscreen. The parameter values are extracted directly from
    the URL. You'll see this in action, so everything will be clear immediately.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `/adding`（GET）依赖于之前实现的逻辑。更准确地说，当调用端点时，会发起一个GET请求。唯一的区别是这次，参数是通过URL传递的。例如，调用`/adding?num1=3&num2=5`应在屏幕上显示`8`。参数值直接从URL中提取。您将看到这一动作，所以一切都会立即变得清晰。
- en: b) `/adding` (POST) is quite similar to the first endpoint but makes a POST
    request instead. This is a more secure communication method, as parameter values
    aren't passed in the URL directly but in the request body instead. This endpoint
    returns the summation as JSON, so you'll need to wrap the results inside the `flask.jsonify()`
    function.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `/adding`（POST）与第一个端点非常相似，但发起的是POST请求。这是一种更安全的通信方法，因为参数值不是直接通过URL传递，而是在请求体中传递。此端点以JSON格式返回求和结果，因此您需要将结果包装在`flask.jsonify()`函数中。
- en: 'Both functions aim to complete an identical task – sum two numbers and return
    the result. Here''s one example of how you might implement this logic:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个函数旨在完成一个相同的目标 – 求两个数的和并返回结果。以下是如何实现这种逻辑的一个示例：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the `add_get()` function returns a string formatted as HTML.
    You can return entire HTML documents if you want, but that's not something that
    interests us now, so we won't look further into it.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，`add_get()`函数返回一个格式为HTML的字符串。如果您想返回整个HTML文档，也可以，但这不是我们现在感兴趣的事情，所以我们不会进一步探讨。
- en: 'To run the application, you''ll have to execute the Python file from the terminal.
    The file is named `flask_basics2.py` on my machine, so to run it, please execute
    the following:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要运行应用程序，您需要在终端中执行Python文件。在我的机器上，该文件名为`flask_basics2.py`，因此要运行它，请执行以下命令：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: import requests
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import requests
- en: req = requests.post(
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: req = requests.post(
- en: url='http://localhost:8000/adding',
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: url='http://localhost:8000/adding',
- en: 'json={''num1'': 3, ''num2'': 5}'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'json={''num1'': 3, ''num2'': 5}'
- en: )
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: res = req.content
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: res = req.content
- en: print(res)
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(res)
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You already have `Flask-RESTful` installed. The syntax when using it is a bit
    different. It uses the `get()`, `post()`, and `put()`, which represent what happens
    when a request of a particular type is made.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经安装了`Flask-RESTful`。使用它的语法略有不同。它使用`get()`、`post()`和`put()`，这些代表当发起特定类型的请求时会发生什么。
- en: All API classes inherit from the `Flask-RESTful.Resource` class and each endpoint
    must be manually bound to a specific URL string via the `add_resource()` method.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有API类都继承自`Flask-RESTful.Resource`类，并且每个端点必须通过`add_resource()`方法手动绑定到特定的URL字符串。
- en: 'To summarize, we''ll have the `Add` class, which has two methods: `get()` and
    `post()`. All of the logic inside these methods is identical to what we had earlier,
    with a single exception – we won''t return HTML anywhere.'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结一下，我们将有一个`Add`类，它有两个方法：`get()`和`post()`。这些方法内部的逻辑与之前相同，唯一的例外是我们不会在任何地方返回HTML。
- en: 'Here''s the entire code snippet:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是整个代码片段：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Everything inside the `Adding` class is available on the `/adding` endpoint.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Adding`类内部的所有内容都在`/adding`端点上可用。'
- en: As you can see, the API will run on a different port, just to easily distinguish
    between this API and the previous one.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，该API将在不同的端口上运行，以便于区分这个API和之前的那个。
- en: 'If you were to open `http://localhost:8000/adding` now, you''d see the following
    message:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您现在打开`http://localhost:8000/adding`，您会看到以下消息：
- en: '![Figure 8.7 – Flask-RESTful GET without parameters'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – Flask-RESTful无参数GET'
- en: '](img/B16954_08_7.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_08_7.jpg)'
- en: Figure 8.7 – Flask-RESTful GET without parameters
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – Flask-RESTful无参数GET
- en: 'We now have the same error as with the default `Flask` API, and the reason
    is that no parameter values were given in the URL. If you were to change it and
    call `http://localhost:8000/adding?num1=5&num2=10`, you''d see the following in
    your browser window:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在遇到了与默认`Flask`API相同的错误，原因是URL中没有给出参数值。如果您要更改它并调用`http://localhost:8000/adding?num1=5&num2=10`，您会在浏览器窗口中看到以下内容：
- en: '![Figure 8.8 – Flask-RESTful GET with parameters'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – Flask-RESTful带参数GET'
- en: '](img/B16954_08_8.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_08_8.jpg)'
- en: Figure 8.8 – Flask-RESTful GET with parameters
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – Flask-RESTful带参数GET
- en: As mentioned earlier, communicating with an API straight from the browser is
    not considered to be a good practice, but you can still do it with GET request
    types. You're better off using a tool such as Postman, and you already know how
    to do so.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，直接从浏览器与API通信不被认为是最佳实践，但你可以使用GET请求类型来做这件事。你最好使用像Postman这样的工具，而你已经知道如何使用它。
- en: 'As for the POST method, you can call the same URL as previously, `http://localhost:8000/adding`,
    and pass the parameters as JSON in the request body. Here''s how you can do so
    with Postman:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于POST方法，你可以调用之前相同的URL，即`http://localhost:8000/adding`，并在请求体中以JSON格式传递参数。以下是使用Postman进行操作的步骤：
- en: '![Figure 8.9 – Flask-RESTful POST with Postman'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 使用Postman的Flask-RESTful POST'
- en: '](img/B16954_08_9.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_08_9.jpg)'
- en: Figure 8.9 – Flask-RESTful POST with Postman
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 使用Postman的Flask-RESTful POST
- en: You can do the same through Python, but you should already know how to do so
    by now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过Python来做同样的事情，但你现在应该已经知道如何做了。
- en: You now know the basics of REST API development with Python, `Flask`, and `Flask-RESTful`.
    This was a relatively quick, hands-on section that served as a primer for what's
    about to follow. In the next section, we'll go over a couple of best practices
    for deploying machine learning models, and in the last two sections, we'll explore
    how you can train and deploy models to localhost and the cloud, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了使用Python、`Flask`和`Flask-RESTful`进行REST API开发的基础知识。这是一个相对快速、实用的部分，作为即将到来的内容的入门。在下一节中，我们将讨论部署机器学习模型的几个最佳实践，在最后两节中，我们将探讨如何分别在本地和云中训练和部署模型。
- en: Best practices for deploying automated models
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化模型部署的最佳实践
- en: The deployment of automated models is more or less identical to the deployment
    of your normal machine learning models. It boils down to training the model first
    and then saving the model in some format. In the case of normal machine learning
    models, you could easily save the model to a `.model` or `.h5` file. There's no
    reason not to do the same with TPOT models.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化模型的部署与你的常规机器学习模型的部署大致相同。这归结为首先训练模型，然后以某种格式保存模型。在常规机器学习模型的情况下，你可以轻松地将模型保存为`.model`或`.h5`文件。没有理由不将TPOT模型也这样做。
- en: If you remember from previous chapters, TPOT can export the best pipeline to
    a Python file so this pipeline can be used to train the model if it isn't trained
    already, and the model can be saved afterward. If the model is already trained,
    only the prediction is obtained.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得前面的章节，TPOT可以将最佳管道导出为Python文件，这样就可以在模型未训练的情况下使用该管道进行训练，并在之后保存模型。如果模型已经训练，则只获取预测。
- en: The check for whether a model has been trained or not can be made by checking
    whether a file exists or not. If a model file exists, we can assume the model
    was trained, so we can load it and make a prediction. Otherwise, the model should
    be trained and saved first, and only then can the prediction be made.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查文件是否存在，可以确定模型是否已被训练。如果模型文件存在，我们可以假设模型已被训练，因此可以加载它并做出预测。否则，模型应该首先进行训练和保存，然后才能进行预测。
- en: It's also a good idea to use a POST request type when connecting to a machine
    learning API. It's a better option than GET because parameter values aren't passed
    directly in the URL. As you might know, parameter values can be sensitive, so
    it's a good idea to hide them whenever possible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到机器学习API时使用POST请求类型也是一个好主意。它比GET更好，因为参数值不会直接传递到URL中。正如你可能知道的，参数值可能是敏感的，所以尽可能隐藏它们是个好主意。
- en: For example, maybe you need to authenticate with the API before making predictions.
    It's easy to understand why sending your username and password credentials directly
    in a URL isn't a good idea. POST has you covered, and the rest of the chapter
    will make good use of it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能需要在做出预测之前通过API进行身份验证。很容易理解为什么直接在URL中发送用户名和密码凭证不是一个好主意。POST方法可以解决这个问题，本章的其余部分将很好地利用这一点。
- en: In a nutshell, you should always check whether the model is trained before making
    predictions and train it if required. The other take-home point is that POST is
    better than GET in our case. You now know a couple of basic best practices for
    deploying machine learning models. In the next section, we will train and deploy
    the model to localhost.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在做出预测之前，你应该始终检查模型是否已训练，并在需要时进行训练。另一个要点是，在我们的情况下，POST比GET更好。你现在已经了解了部署机器学习模型的一些基本最佳实践。在下一节中，我们将训练并部署模型到本地主机。
- en: Deploying machine learning models to localhost
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将机器学习模型部署到本地主机
- en: 'We''ll have to train a model before we can deploy it. You already know everything
    about training with TPOT, so we won''t spend too much time here. The goal is to
    train a simple Iris classifier and export the predictive functionality somehow.
    Let''s go through the process step by step:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以部署模型之前，我们需要先训练它。你已经知道如何使用TPOT进行训练的所有内容，所以我们不会在这里花费太多时间。目标是训练一个简单的Iris分类器，并以某种方式导出预测功能。让我们一步一步地完成这个过程：
- en: 'As always, the first step is to load in the libraries and the dataset. You
    can use the following piece of code to do so:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，第一步是加载库和数据集。你可以使用以下代码片段来完成此操作：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what the first few rows look like:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是前几行看起来像什么：
- en: '![Figure 8.10 – The first few rows of the Iris dataset'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.10 – Iris数据集的前几行](img/B16954_08_10.jpg)'
- en: '](img/B16954_08_10.jpg)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16954_08_10.jpg](img/B16954_08_10.jpg)'
- en: Figure 8.10 – The first few rows of the Iris dataset
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.10 – Iris数据集的前几行
- en: 'The next step is to separate the features from the target variable. This time,
    we won''t split the dataset into training and testing subsets, as we don''t intend
    to evaluate the model''s performance. In other words, we know the model performs
    well, and now we want to retrain it on the entire dataset. Also, string values
    in the target variables will be remapped to their integer representation as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将特征与目标变量分开。这次，我们不会将数据集分为训练集和测试集，因为我们不打算评估模型的性能。换句话说，我们知道模型表现良好，现在我们想在整个数据集上重新训练它。此外，目标变量中的字符串值将按照以下方式重映射为其整数表示：
- en: a) Setosa – 0
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) Setosa – 0
- en: b) Virginica – 1
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) Virginica – 1
- en: c) Versicolor – 2
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) Versicolor – 2
- en: 'The following lines of code do everything that was described:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码行执行了之前描述的所有操作：
- en: '[PRE8]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s what the target variable looks like now:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在的目标变量看起来是这样的：
- en: '![Figure 8.11 – The target variable after value remapping'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.11 – 值重映射后的目标变量](img/B16954_08_11.jpg)'
- en: '](img/B16954_08_11.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16954_08_11.jpg](img/B16954_08_11.jpg)'
- en: Figure 8.11 – The target variable after value remapping
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.11 – 值重映射后的目标变量
- en: Next stop – model training. We'll train the model with TPOT for 15 minutes.
    This part should be familiar to you, as we're not using any parameters that weren't
    used or described in previous chapters.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个步骤是模型训练。我们将使用TPOT进行15分钟的模型训练。这部分你应该很熟悉，因为我们没有使用之前章节中没有使用或描述过的任何参数。
- en: 'The following piece of code will train the model on the entire dataset:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段将在整个数据集上训练模型：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You''ll see many outputs during the training process, but it shouldn''t take
    too long to achieve 100% accuracy, as shown in the following figure:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在训练过程中，你会看到许多输出，但达到100%的准确率不应该花费太多时间，如下图所示：
- en: '![Figure 8.12 – TPOT training process'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.12 – TPOT训练过程](img/B16954_08_12.jpg)'
- en: '](img/B16954_08_12.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16954_08_12.jpg](img/B16954_08_12.jpg)'
- en: Figure 8.12 – TPOT training process
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.12 – TPOT训练过程
- en: 'How many generations will pass in the 15-minute time frame depends on your
    hardware, but once finished, you should see something similar to this:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在15分钟的时间框架内，将经过多少代取决于你的硬件，但一旦完成，你应该看到类似以下的内容：
- en: '![Figure 8.13 – TPOT output after training'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.13 – 训练后的TPOT输出](img/B16954_08_13.jpg)'
- en: '](img/B16954_08_13.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16954_08_13.jpg](img/B16954_08_13.jpg)'
- en: Figure 8.13 – TPOT output after training
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.13 – 训练后的TPOT输出
- en: 'Once the training process is complete, you''ll have access to the `fitted_pipeline_`
    property:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦训练过程完成，你将能够访问`fitted_pipeline_`属性：
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It''s a pipeline object that can be exported for later use. Here''s what it
    should look like (keep in mind that you could see something different on your
    machine):'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个可以导出以供以后使用的管道对象。以下是它应该看起来像什么（请注意，你可能在你的机器上看到不同的结果）：
- en: '![Figure 8.14 – TPOT fitted pipeline'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.14 – TPOT拟合管道](img/B16954_08_14.jpg)'
- en: '](img/B16954_08_14.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16954_08_14.jpg](img/B16954_08_14.jpg)'
- en: Figure 8.14 – TPOT fitted pipeline
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.14 – TPOT拟合管道
- en: 'To demonstrate how this pipeline works, please take a look at the following
    code snippet. It calls the `predict()` function of the `fitted_pipeline_` property
    with a 2D array of input data, representing a single flower species:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示这个管道的工作原理，请查看以下代码片段。它使用一个表示单个花种的二维输入数据数组调用`fitted_pipeline_`属性的`predict()`函数：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The results are displayed in the following figure:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果显示在以下图中：
- en: '![Figure 8.15 – TPOT prediction'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.15 – TPOT预测](img/B16954_08_15.jpg)'
- en: '](img/B16954_08_15.jpg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16954_08_15.jpg](img/B16954_08_15.jpg)'
- en: Figure 8.15 – TPOT prediction
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.15 – TPOT预测
- en: Remember our remapping strategy from a couple of pages ago? `0` indicates that
    this species was classified as `setosa`.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得我们几页前的重映射策略吗？`0`表示这种物种被分类为`setosa`。
- en: The final step we have to do is save the predictive capabilities of this model
    to a file. The `joblib` library makes this step easy to do, as you just have to
    call the `dump()` function to save the model and the `load()` function to load
    the model.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须完成的最后一步是将此模型的预测能力保存到文件中。`joblib` 库使得这一步变得简单，因为你只需要调用 `dump()` 函数来保存模型，并调用
    `load()` 函数来加载模型。
- en: 'Here''s a quick demonstration. The goal is to save the `fitted_pipeline_` property
    to a file called `iris.model`. You can use the following code to do so:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一个快速演示。目标是把 `fitted_pipeline_` 属性保存到名为 `iris.model` 的文件中。你可以使用以下代码来完成：
- en: '[PRE12]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And that''s all there is to it! You''ll see the following output once the model
    is saved to a file:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这么简单！一旦模型保存到文件中，你将看到以下输出：
- en: '![Figure 8.16 – Saving TPOT models'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.16 – 保存 TPOT 模型'
- en: '](img/B16954_08_16.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_16.jpg]'
- en: Figure 8.16 – Saving TPOT models
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 保存 TPOT 模型
- en: 'Just to verify that the model will still work, you can use the `load()` function
    to load the model in a new variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证模型仍然可以正常工作，你可以使用 `load()` 函数在新的变量中加载模型：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the preceding code is shown in the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出显示在下图中：
- en: '![Figure 8.17 – Prediction of a saved model'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.17 – 保存模型的预测'
- en: '](img/B16954_08_17.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_17.jpg]'
- en: Figure 8.17 – Prediction of a saved model
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 保存模型的预测
- en: And that's how easy it is to save machine learning models for later use. We
    now have everything needed to deploy this model, so let's do that next.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，保存机器学习模型以供以后使用变得非常简单。我们现在拥有了部署此模型所需的一切，所以让我们继续下一步。
- en: 'The model deployment process will be quite similar to what we''ve done previously
    with `Flask` and `Flask-RESTful`. Before proceeding to the step-by-step guide,
    you should create a directory for your API with the following directory/file structure:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 模型部署过程将与之前使用 `Flask` 和 `Flask-RESTful` 所做的非常相似。在继续逐步指南之前，你应该为你的 API 创建一个目录，并具有以下目录/文件结构：
- en: '![Figure 8.18 – API directory structure'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.18 – API 目录结构'
- en: '](img/B16954_08_18.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_18.jpg]'
- en: Figure 8.18 – API directory structure
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – API 目录结构
- en: As you can see, the root folder is called `api` and it has two Python files
    inside – `app.py` and `helpers.py`. The folder also has another folder for storing
    the model trained previously.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，根目录被命名为 `api`，其中包含两个 Python 文件 —— `app.py` 和 `helpers.py`。该文件夹还有一个用于存储之前训练的模型的文件夹。
- en: 'Let''s build the API one step at a time next:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地构建 API：
- en: Let's start with the `helpers.py` file. The goal of this Python file is to remove
    all calculations and data operations from `app.py`. The ladder is used only to
    declare and manage the API itself, and everything else is performed elsewhere.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 `helpers.py` 文件开始。这个 Python 文件的目标是从 `app.py` 中移除所有计算和数据操作。后者仅用于声明和管理 API
    本身，其他所有操作都在其他地方执行。
- en: The `helpers.py` file will have two functions – `int_to_species(in_species)`
    and `predict_single(model, X)`.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`helpers.py` 文件将包含两个函数 —— `int_to_species(in_species)` 和 `predict_single(model,
    X)`。'
- en: 'The goal of the first function is to reverse our previously declared mappings
    and to return the actual flower species name given the integer representation.
    Here''s a concrete list of strings returned when given the integer input:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个函数的目标是反转我们之前声明的映射，并给出整数表示的实际花卉种类名称。以下是给出整数输入时返回的字符串的具体列表：
- en: a) 0 – `setosa`
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 0 – `setosa`
- en: b) 1 – `virginica`
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 1 – `virginica`
- en: c) 2 – `versicolor`
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 2 – `versicolor`
- en: 'If some other number is passed, an empty string is returned. You can find the
    code for this function as follows:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果传递了其他数字，则返回一个空字符串。你可以按照以下方式找到此函数的代码：
- en: '[PRE14]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On to the `predict_single(model, X)` function now. It aims to return a prediction
    and its probability given the model and a list of input values. The function also
    makes the following checks:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来是 `predict_single(model, X)` 函数。该函数旨在根据模型和输入值的列表返回预测及其概率。该函数还执行以下检查：
- en: a) Is `X` a list? If not, raise an exception.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `X` 是一个列表吗？如果不是，则抛出异常。
- en: b) Does `X` have four items (sepal length, sepal width, petal length, and petal
    width)? If not, raise an exception.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `X` 是否有四个项目（花瓣长度、花瓣宽度、花萼长度和花萼宽度）？如果不是，则抛出异常。
- en: These checks are required because we don't want bad or misformatted data going
    in our model and crashing the API.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些检查是必需的，因为我们不希望不良或格式错误的数据进入我们的模型并使 API 崩溃。
- en: 'If all of the checks pass, the prediction and probability are returned to the
    user as a dictionary, alongside the entered data for each parameter. Here''s how
    to implement this function:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果所有检查都通过，预测和概率将作为字典返回给用户，并列出每个参数的输入数据。以下是实现此函数的方法：
- en: '[PRE15]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s one example of calling the `predict_single()` function:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是调用 `predict_single()` 函数的一个示例：
- en: '[PRE16]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The results are shown in the following figure:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Figure 8.19 – Results of calling the predict_single() function'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.19 – 调用 predict_single() 函数的结果'
- en: '](img/B16954_08_19.jpg)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_19.jpg)'
- en: Figure 8.19 – Results of calling the predict_single() function
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.19 – 调用 predict_single() 函数的结果
- en: On to `app.py` now. If you have been following along from the beginning of this
    chapter, coding out this file will be a piece of cake. The goal is to have the
    model loaded at all times and to trigger the `post()` method of the `PredictSpecies`
    class when a `/predict` endpoint is called. You'll have to implement both the
    class and the method yourself.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转向 `app.py`。如果您从本章的开头就一直在跟进，编写这个文件将易如反掌。目标是始终加载模型，并在调用 `/predict` 端点时触发
    `PredictSpecies` 类的 `post()` 方法。您将不得不自己实现这个类和方法。
- en: The user has to pass input data as JSON. To be more precise, every flower measurement
    value is passed separately, so the user will have to specify values for four parameters
    in total.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户必须以 JSON 格式传递输入数据。更准确地说，每个花卉测量值都是单独传递的，因此用户总共需要指定四个参数的值。
- en: If everything goes well, the `predict_single()` function from `helpers.py` is
    called, and the results are returned to the user.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，`helpers.py` 中的 `predict_single()` 函数将被调用，并将结果返回给用户。
- en: 'Let''s take a look at the implementation of `app.py`:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看 `app.py` 的实现：
- en: '[PRE17]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You now have everything needed to run the API. You can do so the same way that
    you did with the previous APIs, and that is by executing the following line in
    the terminal:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在拥有了运行 API 所需的一切。您可以像之前使用其他 API 一样运行它，即在终端中执行以下行：
- en: '[PRE18]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If everything went well, you''ll get the following message:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将看到以下消息：
- en: '![Figure 8.20 – Running the API'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.20 – 运行 API'
- en: '](img/B16954_08_20.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_20.jpg)'
- en: Figure 8.20 – Running the API
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.20 – 运行 API
- en: The API is now running on `http://localhost:8000`. We'll use the Postman application
    to test the API.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 现在正在 `http://localhost:8000` 上运行。我们将使用 Postman 应用程序来测试 API。
- en: 'Here''s the first example:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是第一个示例：
- en: '![Figure 8.21 – API testing example 1'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.21 – API 测试示例 1'
- en: '](img/B16954_08_21.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_08_21.jpg)'
- en: Figure 8.21 – API testing example 1
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – API 测试示例 1
- en: 'As you can see, the model is 100% confident that this species belongs to the
    `setosa` class. Let''s try another one:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模型 100% 确信这种物种属于 `setosa` 类。让我们再试一个：
- en: '![Figure 8.22 – API testing example 2'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.22 – API 测试示例 2'
- en: '](img/B16954_08_22.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_08_22.jpg)'
- en: Figure 8.22 – API testing example 2
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.22 – API 测试示例 2
- en: 'This has an identical confidence level but a different prediction class. Let''s
    mix things up a beat and pass values a bit different than anything in the training
    set:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有相同的置信水平，但预测类别不同。让我们来点不一样的，传递一些与训练集不同的值：
- en: '![Figure 8.23 – API testing example 3'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.23 – API 测试示例 3'
- en: '](img/B16954_08_23.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_08_23.jpg)'
- en: Figure 8.23 – API testing example 3
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23 – API 测试示例 3
- en: As you can see, the model isn't 100% confident this time, as the input data
    is a lot different from the data seen at training.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次模型并不完全自信，因为输入数据与训练时看到的数据有很大不同。
- en: And there you have it – TPOT model deployment to localhost! The only thing left
    to do in this chapter is to bring the model to the cloud and make it accessible
    from anywhere. Let's do that next.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，TPOT 模型部署到本地主机！本章剩下的唯一事情是将模型带到云端，使其在任何地方都可以访问。让我们接下来这么做。
- en: Deploying machine learning models to the cloud
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将机器学习模型部署到云
- en: 'Cloud deployment of machine learning models means creating a cloud virtual
    machine, transferring our API to it, and running it. It''s a tedious process that
    gets easier with repetition since a lot of steps are involved. If you follow every
    step precisely from this section, everything will work fine. Just make sure not
    to miss any minor details:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 云部署机器学习模型意味着创建一个云虚拟机，将我们的 API 转移到它上面，并运行它。这是一个繁琐的过程，但由于涉及许多步骤，随着重复执行会变得更容易。如果您从这个部分精确地遵循每个步骤，一切都会顺利。只需确保不要遗漏任何细节：
- en: To start, head over to [https://portal.aws.amazon.com/billing/signup#/start](https://portal.aws.amazon.com/billing/signup#/start)
    and create an account (assuming you don't already have one). Here's what the website
    currently looks like (as of February 2021):![Figure 8.24 – AWS registration website
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，请访问 [https://portal.aws.amazon.com/billing/signup#/start](https://portal.aws.amazon.com/billing/signup#/start)
    并创建一个账户（假设您还没有一个）。以下是网站目前的模样（截至 2021 年 2 月）：![图 8.24 – AWS 注册网站
- en: '](img/B16954_08_24.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_24.jpg]'
- en: Figure 8.24 – AWS registration website
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.24 – AWS 注册网站
- en: The registration process will take some time, and you will have to enter your
    credit card information. Don't worry; we'll create entirely free virtual machine
    instances so you won't be charged a dime.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注册过程将花费一些时间，您将需要输入您的信用卡信息。请放心；我们将创建完全免费的虚拟机实例，所以您不会收取任何费用。
- en: Once the registration process is complete, click on the `ubuntu` in the search
    bar:![Figure 8.26 – Ubuntu Server 20.04
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦注册过程完成，点击搜索栏中的 `ubuntu`：![图 8.26 – Ubuntu Server 20.04
- en: '](img/B16954_08_26.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_26.jpg]'
- en: Figure 8.26 – Ubuntu Server 20.04
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.26 – Ubuntu Server 20.04
- en: 'Once you click on **Select**, you''ll have to specify the type. Make sure to
    select the free version if you don''t want to get charged:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦点击 **选择**，您将需要指定类型。如果您不想被收费，请确保选择免费版本：
- en: '![Figure 2.27 – Ubuntu instance type'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.27 – Ubuntu 实例类型'
- en: '](img/B16954_08_27.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_27.jpg]'
- en: Figure 2.27 – Ubuntu instance type
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.27 – Ubuntu 实例类型
- en: 'Next, click on the **Review and Launch** button. You''ll be taken to the following
    screen:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，点击 **审查和启动** 按钮。您将被带到以下屏幕：
- en: '![Figure 2.28 – Ubuntu instance confirmation'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 2.28 – Ubuntu 实例确认'
- en: '](img/B16954_08_28.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_28.jpg]'
- en: Figure 2.28 – Ubuntu instance confirmation
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.28 – Ubuntu 实例确认
- en: 'Once you click on **Launch**, the following window will appear. Make sure to
    select the identical options, but the key pair name is up to you:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦点击 **启动**，将出现以下窗口。请确保选择相同的选项，但密钥对名称由您决定：
- en: '![Figure 8.29 – Ubuntu key pair'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.29 – Ubuntu 密钥对'
- en: '](img/B16954_08_29.jpg)'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_29.jpg]'
- en: Figure 8.29 – Ubuntu key pair
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.29 – Ubuntu 密钥对
- en: 'Click on the **Download Key Pair** button after you enter the details. After
    the download is complete, you''ll be able to click on the **Launch Instances**
    button:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输入详细信息后，点击 **下载密钥对** 按钮。下载完成后，您将能够点击 **启动实例** 按钮：
- en: '![Figure 8.30 – Launching the Ubuntu instance'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.30 – 启动 Ubuntu 实例'
- en: '](img/B16954_08_30.jpg)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_30.jpg]'
- en: Figure 8.30 – Launching the Ubuntu instance
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.30 – 启动 Ubuntu 实例
- en: 'Finally, after everything is done, you can click on the **View Instances**
    button:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，完成所有操作后，您可以点击 **查看实例** 按钮：
- en: '![Figure 8.31 – View Instances'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.31 – 查看实例'
- en: '](img/B16954_08_31.jpg)'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_31.jpg]'
- en: Figure 8.31 – View Instances
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.31 – 查看实例
- en: 'You will be presented with your created instance immediately. It might take
    some time before you see that the instance is running, so please be patient:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将立即看到您创建的实例。在看到实例正在运行之前可能需要一些时间，所以请耐心等待：
- en: '![Figure 8.32 – Running instance'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.32 – 运行实例'
- en: '](img/B16954_08_32.jpg)'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_32.jpg]'
- en: Figure 8.32 – Running instance
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.32 – 运行实例
- en: To obtain the connection parameter, click on the instance row and select the
    `.ppk` file in the **Key file** option. After the **Connect** button is pressed,
    you'll see the following:![Figure 8.36 – FileZilla host key
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取连接参数，请点击实例行，并在 **密钥文件** 选项中选择 `.ppk` 文件。按下 **连接** 按钮后，您将看到以下内容：![图 8.36 –
    FileZilla 主机密钥
- en: '](img/B16954_08_36.jpg)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_36.jpg]'
- en: Figure 8.36 – FileZilla host key
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.36 – FileZilla 主机密钥
- en: 'Just press **OK** and you''re good to go. The connection was successful, as
    visible from the following figure:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只需按 **确定**，您就可以开始了。连接成功，如下图所示：
- en: '![Figure 8.37 – FileZilla successful connection'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.37 – FileZilla 成功连接'
- en: '](img/B16954_08_37.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_37.jpg]'
- en: Figure 8.37 – FileZilla successful connection
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.37 – FileZilla 成功连接
- en: 'You can now drag the **api** folder to the **ubuntu** folder on the remote
    virtual machine, as shown here:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您现在可以将 **api** 文件夹拖动到远程虚拟机上的 **ubuntu** 文件夹中，如图所示：
- en: '![Figure 8.38 – Transferring API data to a remote virtual machine'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.38 – 将 API 数据传输到远程虚拟机'
- en: '](img/B16954_08_38.jpg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_08_38.jpg]'
- en: Figure 8.38 – Transferring API data to a remote virtual machine
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.38 – 将 API 数据传输到远程虚拟机
- en: Before further configuring and starting the API, let's explore how you can obtain
    the connection through the terminal.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在进一步配置和启动 API 之前，让我们看看您如何通过终端获取连接。
- en: 'Open up a new terminal window right where your `.pem` file is stored. Once
    there, execute the following command to change the permission:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储 `.pem` 文件的新终端窗口中打开。一旦进入，执行以下命令以更改权限：
- en: '[PRE19]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: sudo apt-get update && sudo apt-get install python3-pip
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sudo apt-get update && sudo apt-get install python3-pip
- en: '[PRE20]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: pip3 install virtualenv
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pip3 install virtualenv
- en: virtualenv tpotapi_env
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: virtualenv tpotapi_env
- en: source tpotapi_env/bin/activate
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: source tpotapi_env/bin/activate
- en: pip3 install joblib flask flask-restful sklearn tpot
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pip3 install joblib flask flask-restful sklearn tpot
- en: '[PRE21]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you were to run the API now, no errors would be raised, but you wouldn't
    be able to access the API in any way. That's because we need to "fix" a couple
    of permissions first. Put simply, our API needs to be accessible from anywhere,
    and it isn't by default.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在运行 API，不会引发错误，但您将无法以任何方式访问 API。这是因为我们首先需要“修复”一些权限。简单来说，我们的 API 需要从任何地方可访问，但默认情况下并不是。
- en: 'To start, navigate to **Network & Security** | **Security Groups** on the sidebar:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，导航到 **网络与安全** | **安全组** 侧边栏：
- en: '![Figure 8.40 – Security Groups'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.40 – 安全组'
- en: '](img/B16954_08_40.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_40.jpg)'
- en: Figure 8.40 – Security Groups
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.40 – 安全组
- en: 'You should see the **Create security group** button in the top-right corner
    of the browser window:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该在浏览器窗口的右上角看到 **创建安全组** 按钮：
- en: '![Figure 8.41 – The Create security group button'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.41 – 创建安全组按钮'
- en: '](img/B16954_08_41.jpg)'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_41.jpg)'
- en: Figure 8.41 – The Create security group button
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.41 – 创建安全组按钮
- en: 'Once the new window pops up, you''ll have to specify a couple of things. The
    **Security group name** and **Description** fields are entirely arbitrary. On
    the other hand, the **Inbound rules** group isn''t arbitrary. You''ll have to
    add a new rule with the following options:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当新窗口弹出时，您必须指定一些内容。**安全组名称** 和 **描述** 字段完全是任意的。另一方面，**入站规则** 组不是任意的。您必须添加一个具有以下选项的新规则：
- en: 'a) **Type**: **All traffic**'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'a) **类型**: **所有流量**'
- en: 'b) **Source**: **Anywhere**'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'b) **源**: **任何地方**'
- en: 'Refer to the following figure for more information:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下图示获取更多信息：
- en: '![Figure 8.42 – Creating a security group'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.42 – 创建安全组'
- en: '](img/B16954_08_42.jpg)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_42.jpg)'
- en: Figure 8.42 – Creating a security group
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.42 – 创建安全组
- en: 'After specifying the correct values, you have to scroll down to the end of
    the screen and click on the **Create security group** option:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在指定正确的值后，您必须滚动到屏幕底部并点击 **创建安全组** 选项：
- en: '![Figure 8.43 – Verifying a security group'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.43 – 验证安全组'
- en: '](img/B16954_08_43.jpg)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_43.jpg)'
- en: Figure 8.43 – Verifying a security group
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.43 – 验证安全组
- en: 'We''re not done yet. The next step is to go to the **Network & Security** |
    **Network Interfaces** option on the sidebar:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还没有完成。下一步是转到侧边栏上的 **网络与安全** | **网络接口** 选项：
- en: '![Figure 8.44 – The Network Interfaces option'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.44 – 网络接口选项'
- en: '](img/B16954_08_44.jpg)'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_44.jpg)'
- en: Figure 8.44 – The Network Interfaces option
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.44 – 网络接口选项
- en: 'Once there, right-click the only available network interface (assuming this
    is your first time in the AWS console) and select the **Change security groups**
    option:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦进入，右键单击唯一可用的网络接口（假设这是您第一次进入 AWS 控制台）并选择 **更改安全组** 选项：
- en: '![Figure 8.45 – Changing security groups'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.45 – 更改安全组'
- en: '](img/B16954_08_45.jpg)'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_45.jpg)'
- en: Figure 8.45 – Changing security groups
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.45 – 更改安全组
- en: 'The whole point of this is to assign the "access from anywhere" rule to our
    virtual machine. Once a window pops up, select the previously declared security
    group from the dropdown of options:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个目的就是将“从任何地方访问”的规则分配给我们的虚拟机。一旦弹出窗口，从选项下拉列表中选择之前声明的安全组：
- en: '![Figure 8.46 – Selecting the security group'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.46 – 选择安全组'
- en: '](img/B16954_08_46.jpg)'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_46.jpg)'
- en: Figure 8.46 – Selecting the security group
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.46 – 选择安全组
- en: 'Once added, click on the **Save** button to save this association:'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加完成后，点击 **保存** 按钮保存此关联：
- en: '![Figure 8.47 – Saving security associations'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.47 – 保存安全关联'
- en: '](img/B16954_08_47.jpg)'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_47.jpg)'
- en: Figure 8.47 – Saving security associations
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.47 – 保存安全关联
- en: 'Configuring our virtual machine was quite a lengthy process, but you can now
    finally start the `Flask` application (REST API). To do so, navigate to the `/api`
    folder and execute the following:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置我们的虚拟机是一个相当漫长的过程，但现在您终于可以启动 `Flask` 应用程序（REST API）了。为此，导航到 `/api` 文件夹并执行以下操作：
- en: '[PRE22]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see the following, by now a familiar message:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到现在为止，你应该看到一个熟悉的消息：
- en: '![Figure 8.48 – Starting the REST API through the terminal'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.48 – 通过终端启动REST API'
- en: '](img/B16954_08_48.jpg)'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_08_48.jpg)'
- en: Figure 8.48 – Starting the REST API through the terminal
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.48 – 通过终端启动REST API
- en: And that's it! The API is now running, and we can test whether it works properly.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！API现在正在运行，我们可以测试它是否正常工作。
- en: 'Before making a request through Postman, we first need to find the complete
    URL for our remote virtual machine. You can find yours by right-clicking the instance
    under **Instances** and clicking on the **Connect** option. There, you''ll see
    the **SSH client** tab:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过Postman发送请求之前，我们首先需要找到远程虚拟机的完整URL。你可以通过在**实例**下右键单击实例并点击**连接**选项来找到它。在那里，你会看到**SSH客户端**标签页：
- en: '![Figure 8.49 – Virtual machine URL'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.49 – 虚拟机URL'
- en: '](img/B16954_08_49.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_08_49.jpg)'
- en: Figure 8.49 – Virtual machine URL
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.49 – 虚拟机URL
- en: 'Now we know the complete URL: `http://ec2-18-220-113-224.us-east-2.compute.amazonaws.com:8000/predict`.
    The procedure from now is identical to as it was on localhost, as visible in the
    following figure:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了完整的URL：`http://ec2-18-220-113-224.us-east-2.compute.amazonaws.com:8000/predict`。从现在开始，流程与在本地主机上相同，如下图所示：
- en: '![Figure 8.50 – Testing our deployed API'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.50 – 测试我们部署的API'
- en: '](img/B16954_08_50.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_08_50.jpg)'
- en: Figure 8.50 – Testing our deployed API
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.50 – 测试我们部署的API
- en: As you can see, the connection went through, and the API returned a response
    just as it did with the locally deployed version.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，连接已经建立，API返回了与本地部署版本相同的响应。
- en: And there you have it – the complete procedure for deploying machine learning
    models to an AWS virtual machine. The process can be quite tedious to do and even
    tricky if this is your first time. It will get easier as you deploy more and more
    machine learning models, as the procedure is identical.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你就有了一个将机器学习模型部署到AWS虚拟机的完整流程。这个过程可能相当繁琐，如果是第一次尝试，甚至可能有些棘手。随着你部署越来越多的机器学习模型，这个过程会变得越来越容易，因为流程是相同的。
- en: You could play around with the permissions if you don't want your API to be
    accessible from anywhere by anyone, but that's beyond the scope of this book.
    This chapter is more or less over – great work! What follows is a summary of everything
    learned and then yet another interesting, hands-on chapter.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想让任何人从任何地方访问你的API，你可以玩一下权限，但这超出了本书的范围。这一章大致结束了——做得很好！接下来是所学内容的总结，然后是另一个有趣且实用的章节。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was the longest one so far and quite intensive with the hands-on
    tasks. You've hopefully managed to follow along and learned how machine learning
    models built with TPOT can be deployed – both locally and to the cloud.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是目前最长的，而且非常注重实践任务。你希望已经能够跟上并学习了如何部署使用TPOT构建的机器学习模型——无论是在本地还是在云端。
- en: You are now capable of deploying any sort of machine learning model built with
    Python. Besides, you also know how to deploy basic Python web applications, provided
    that you have the necessary knowledge of frontend technologies, such as HTML,
    CSS, and JavaScript. We didn't dive into this area, as it's beyond the scope of
    this book.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经能够部署任何使用Python构建的机器学习模型。此外，你还知道如何部署基本的Python网络应用程序，前提是你具备前端技术（如HTML、CSS和JavaScript）的相关知识。我们没有深入这个领域，因为这不属于本书的范围。
- en: In the following chapter, [*Chapter 9*](B16954_09_Final_SK_ePub.xhtml#_idTextAnchor102),
    *Using the Deployed TPOT Model in Production*, you'll learn how to build a basic
    application around this REST API. To be more precise, you'll learn how to make
    a simple and decent-looking web interface that predicts flower species based on
    the input data. But before that, you'll practice making a request to our API with
    Python.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中[*第9章*](B16954_09_Final_SK_ePub.xhtml#_idTextAnchor102)，*在生产中使用部署的TPOT模型*，你将学习如何围绕这个REST
    API构建一个基本的应用程序。更准确地说，你将学习如何制作一个简单且外观不错的网页界面，该界面可以根据输入数据预测花卉种类。但在那之前，你将练习使用Python向我们的API发送请求。
- en: As always, feel free to study model deployment in more detail, as AWS isn't
    the only option. There are many cloud providers that offer some sort of a free
    tier, and AWS is just a single fish in the pond.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以自由地更详细地研究模型部署，因为AWS不是唯一的选择。有许多云服务提供商提供某种免费层，AWS只是池塘中的一条鱼。
- en: Question
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we need (and want) model deployment?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么需要（并希望）模型部署？
- en: What's the role of REST APIs in model deployment?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REST API在模型部署中扮演什么角色？
- en: Name a couple of Python libraries that can be used to deploy machine learning
    models.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些可以用来部署机器学习模型的Python库。
- en: What's the difference between the GET and POST request types?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GET 和 POST 请求类型之间有什么区别？
- en: What's the general idea behind the `joblib` library in Python?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 中 `joblib` 库背后的基本思想是什么？
- en: Explain in your own words what a virtual machine is.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你自己的话解释什么是虚拟机。
- en: Which free tool can be used to test REST APIs?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个免费工具可以用来测试 REST API？
