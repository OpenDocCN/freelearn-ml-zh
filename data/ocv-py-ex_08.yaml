- en: Chapter 8. Detecting Shapes and Segmenting an Image
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 检测形状和分割图像
- en: In this chapter, we are going to learn about shape analysis and image segmentation.
    We will learn how to recognize shapes and estimate the exact boundaries. We will
    discuss how to segment an image into its constituent parts using various methods.
    We will learn how to separate the foreground from the background as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习形状分析和图像分割。我们将学习如何识别形状并估计确切的边界。我们将讨论如何使用各种方法将图像分割成其组成部分。我们还将学习如何将前景与背景分离。
- en: 'By the end of this chapter, you will know:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道：
- en: What is contour analysis and shape matching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是轮廓分析和形状匹配
- en: How to match shapes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何匹配形状
- en: What is image segmentation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是图像分割
- en: How to segment an image into its constituent parts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将图像分割成其组成部分
- en: How to separate the foreground from the background
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将前景与背景分离
- en: How to use various techniques to segment an image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用各种技术来分割图像
- en: Contour analysis and shape matching
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮廓分析和形状匹配
- en: Contour analysis is a very useful tool in the field of computer vision. We deal
    with a lot of shapes in the real world and contour analysis helps in analyzing
    those shapes using various algorithms. When we convert an image to grayscale and
    threshold it, we are left with a bunch of lines and contours. Once we understand
    the properties of different shapes, we will be able to extract detailed information
    from an image.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 轮廓分析是计算机视觉领域的一个非常有用的工具。我们在现实世界中处理很多形状，轮廓分析有助于使用各种算法分析这些形状。当我们把图像转换为灰度并对其进行阈值处理时，我们剩下的是一堆线和轮廓。一旦我们了解了不同形状的特性，我们就能从图像中提取详细的信息。
- en: 'Let''s say we want to identify the boomerang shape in the following image:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在以下图像中识别回力镖形状：
- en: '![Contour analysis and shape matching](img/B04554_08_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![轮廓分析和形状匹配](img/B04554_08_01.jpg)'
- en: 'In order to do that, we first need to know what a regular boomerang looks like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先需要知道一个标准的回力镖是什么样子：
- en: '![Contour analysis and shape matching](img/B04554_08_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![轮廓分析和形状匹配](img/B04554_08_02.jpg)'
- en: 'Now using the above image as a reference, can we identify what shape in our
    original image corresponds to a boomerang? If you notice, we cannot use a simple
    correlation based approach because the shapes are all distorted. This means that
    an approach where we look for an exact match won''t work! We need to understand
    the properties of this shape and match the corresponding properties to identify
    the boomerang shape. OpenCV provides a nice shape matcher function that we can
    use to achieve this. The matching is based on the concept of Hu moment, which
    in turn is related to image moments. You can refer to the following paper to learn
    more about moments: [http://zoi.utia.cas.cz/files/chapter_moments_color1.pdf](http://zoi.utia.cas.cz/files/chapter_moments_color1.pdf).
    The concept of "image moments" basically refers to the weighted and power-raised
    summation of the pixels within a shape.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以上述图像为参考，我们能否识别出原始图像中与回力镖相对应的形状？如果你注意到，我们不能使用基于简单相关性的方法，因为所有形状都发生了扭曲。这意味着我们寻找精确匹配的方法将不会起作用！我们需要了解这个形状的特性，并将相应的特性匹配以识别回力镖形状。OpenCV提供了一个很好的形状匹配函数，我们可以使用它来实现这一点。匹配基于Hu矩的概念，而Hu矩又与图像矩相关。你可以参考以下论文了解更多关于矩的信息：[http://zoi.utia.cas.cz/files/chapter_moments_color1.pdf](http://zoi.utia.cas.cz/files/chapter_moments_color1.pdf)。图像矩的概念基本上是指形状内像素的加权幂次求和。
- en: '![Contour analysis and shape matching](img/B04554_08_20.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![轮廓分析和形状匹配](img/B04554_08_20.jpg)'
- en: In the above equation, **p** refers to the pixels inside the contour, **w**
    refers to the weights, **N** refers to the number of points inside the contour,
    **k** refers to the power, and **I** refers to the moment. Depending on the values
    we choose for w and k, we can extract different characteristics from that contour.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方程中，**p** 指的是轮廓内的像素，**w** 指的是权重，**N** 指的是轮廓内的点数，**k** 指的是幂，**I** 指的是矩。根据我们为w和k选择的值，我们可以从该轮廓中提取不同的特征。
- en: Perhaps the simplest example is to compute the area of the contour. To do this,
    we need to count the number of pixels within that region. So mathematically speaking,
    in the weighted and power raised summation form, we just need to set w to 1 and
    k to 0\. This will give us the area of the contour. Depending on how we compute
    these moments, they will help us in understanding these different shapes. This
    also gives rise to some interesting properties that help us in determining the
    shape similarity metric.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单的例子是计算轮廓的面积。为此，我们需要计算该区域内像素的数量。所以从数学的角度讲，在加权求和和幂次求和的形式中，我们只需要将w设为1，将k设为0。这将给出轮廓的面积。根据我们如何计算这些矩，它们将帮助我们理解这些不同的形状。这也引发了一些有趣的属性，有助于我们确定形状相似度指标。
- en: 'If we match the shapes, you will see something like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们匹配形状，你会看到类似这样的结果：
- en: '![Contour analysis and shape matching](img/B04554_08_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![轮廓分析和形状匹配](img/B04554_08_03.jpg)'
- en: 'Let''s take a look at the code to do this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行此操作的代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Approximating a contour
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 近似轮廓
- en: A lot of contours that we encounter in real life are noisy. This means that
    the contours don't look smooth, and hence our analysis takes a hit. So how do
    we deal with this? One way to go about this would be to get all the points on
    the contour and then approximate it with a smooth polygon.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在现实生活中遇到的大多数轮廓都很嘈杂。这意味着轮廓看起来不光滑，因此我们的分析受到了影响。那么我们如何处理这个问题呢？一种方法就是获取轮廓上的所有点，然后用平滑的多边形来近似它。
- en: 'Let''s consider the boomerang image again. If you approximate the contours
    using various thresholds, you will see the contours changing their shapes. Let''s
    start with a factor of 0.05:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑回飞镖图像。如果你使用不同的阈值近似轮廓，你会看到轮廓改变形状。让我们从一个因子0.05开始：
- en: '![Approximating a contour](img/B04554_08_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![近似轮廓](img/B04554_08_04.jpg)'
- en: 'If you reduce this factor, the contours will get smoother. Let''s make it 0.01:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你减少这个因子，轮廓将变得更加平滑。让我们将其设置为0.01：
- en: '![Approximating a contour](img/B04554_08_05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![近似轮廓](img/B04554_08_05.jpg)'
- en: 'If you make it really small, say 0.00001, then it will look like the original
    image:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把它做得非常小，比如说0.00001，那么它看起来就像原始图像：
- en: '![Approximating a contour](img/B04554_08_06.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![近似轮廓](img/B04554_08_06.jpg)'
- en: Identifying the pizza with the slice taken out
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别被切掉一片的披萨
- en: The title might be slightly misleading, because we will not be talking about
    pizza slices. But let's say you are in a situation where you have an image containing
    different types of pizzas with different shapes. Now, somebody has taken a slice
    out of one of those pizzas. How would we automatically identify this?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标题可能有些误导，因为我们不会谈论披萨片。但假设你处于一个情况，你有一个包含不同形状披萨的图像。现在，有人从那些披萨中切掉了一片。我们如何自动识别这个？
- en: 'We cannot take the approach we took earlier because we don''t know what the
    shape looks like. So we don''t have any template. We are not even sure what shape
    we are looking for, so we cannot build a template based on any prior information.
    All we know is the fact that a slice has been taken from one of the pizzas. Let''s
    consider the following image:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能采取之前的方法，因为我们不知道形状看起来像什么。所以我们没有任何模板。我们甚至不确定我们正在寻找什么形状，因此我们不能根据任何先前的信息构建一个模板。我们只知道的事实是从其中一个披萨中切下了一片。让我们考虑以下图像：
- en: '![Identifying the pizza with the slice taken out](img/B04554_08_07.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![识别被切掉一片的披萨](img/B04554_08_07.jpg)'
- en: It's not exactly a real image, but you get the idea. You know what shape we
    are talking about. Since we don't know what we are looking for, we need to use
    some of the properties of these shapes to identify the sliced pizza. If you notice,
    all the other shapes are nicely closed. As in, you can take any two points within
    those shapes and draw a line between them, and that line will always lie within
    that shape. These kinds of shapes are called **convex shapes**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一张真实的图像，但你能理解我们的意思。你知道我们在谈论什么形状。由于我们不知道我们在寻找什么，我们需要使用这些形状的一些属性来识别切下的披萨。如果你注意的话，其他所有形状都很好地封闭。也就是说，你可以在那些形状内取任意两点，并在它们之间画一条线，那条线始终位于那个形状内。这类形状被称为**凸形状**。
- en: 'If you look at the sliced pizza shape, we can choose two points such that the
    line between them goes outside the shape as shown in the figure that follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察被切掉的披萨形状，我们可以选择两个点，使得它们之间的线如图所示超出形状：
- en: '![Identifying the pizza with the slice taken out](img/B04554_08_08.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![识别被切掉一片的披萨](img/B04554_08_08.jpg)'
- en: 'So, all we need to do is detect the non-convex shape in the image and we''ll
    be done. Let''s go ahead and do that:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们只需要检测图像中的非凸形状，然后我们就完成了。让我们继续做：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you run the above code, you will see something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上面的代码，你将看到类似以下的内容：
- en: '![Identifying the pizza with the slice taken out](img/B04554_08_09.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![识别被切掉一片的披萨](img/B04554_08_09.jpg)'
- en: 'Wait a minute, what happened here? It looks so cluttered. Did we do something
    wrong? As it turns out, the curves are not really smooth. If you observe closely,
    there are tiny ridges everywhere along the curves. So, if you just run your convexity
    detector, it''s not going to work. This is where contour approximation comes in
    really handy. Once we''ve detected the contours, we need to smoothen them so that
    the ridges do not affect them. Let''s go ahead and do that:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，这里发生了什么？看起来太杂乱了。我们是不是做错了什么？实际上，曲线并不平滑。如果你仔细观察，曲线的每处都有微小的脊。所以，如果你只是运行你的凸性检测器，它将不起作用。这就是轮廓近似真正派上用场的地方。一旦我们检测到轮廓，我们需要平滑它们，以便脊不会影响它们。让我们继续做：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run the preceding code, the output will look like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，输出将类似于以下内容：
- en: '![Identifying the pizza with the slice taken out](img/B04554_08_10.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![识别被切掉一片的披萨](img/B04554_08_10.jpg)'
- en: How to censor a shape?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何屏蔽形状？
- en: 'Let''s say you are dealing with images and you want to block out a particular
    shape. Now, you might say that you will use shape matching to identify the shape
    and then just block it out, right? But the problem here is that we don''t have
    any template available. So, how do we go about doing this? Shape analysis comes
    in various forms, and we need to build our algorithm depending on the situation.
    Let''s consider the following figure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理图像，并且想要屏蔽掉特定的形状。现在，你可能想说你会使用形状匹配来识别形状，然后直接屏蔽它，对吧？但问题在于我们没有可用的模板。那么我们该如何进行呢？形状分析有多种形式，我们需要根据具体情况构建我们的算法。让我们考虑以下图示：
- en: '![How to censor a shape?](img/B04554_08_11.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![如何屏蔽形状？](img/B04554_08_11.jpg)'
- en: 'Let''s say we want to identify all the boomerang shapes and then block them
    out without using any template images. As you can see, there are various other
    weird shapes in that image and the boomerang shapes are not really smooth. We
    need to identify the property that''s going to differentiate the boomerang shape
    from the other shapes present. Let''s consider the convex hull. If you take the
    ratio of the area of each shape to the area of the convex hull, we can see that
    this can be a distinguishing metric. This metric is called **solidity factor**
    in shape analysis. This metric will have a lower value for the boomerang shapes
    because of the empty area that will be left out, as shown in the following figure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要识别所有飞镖形状，然后在不使用任何模板图像的情况下屏蔽它们。正如你所见，图像中还有各种其他奇怪的形状，而飞镖形状并不平滑。我们需要识别将飞镖形状与其他形状区分开来的属性。让我们考虑凸包。如果你将每个形状的面积与凸包的面积之比，我们可以看到这可以是一个区分的指标。这个指标在形状分析中被称为**坚实因子**。由于会留下空隙，这个指标对于飞镖形状将会有一个较低的值，如下面的图示所示：
- en: '![How to censor a shape?](img/B04554_08_12.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![如何屏蔽形状？](img/B04554_08_12.jpg)'
- en: The black boundaries represent the convex hulls. Once we compute these values
    for all the shapes, how do separate them out? Can we just use a fixed threshold
    to detect the boomerang shapes? Not really! We cannot have a fixed threshold value
    because you never know what kind of shape you might encounter later. So, a better
    approach would be to use **K-Means clustering**. K-Means is an unsupervised learning
    technique that can be used to separate out the input data into K classes. You
    can quickly brush up on K-Means before proceeding further at [http://docs.opencv.org/master/de/d4d/tutorial_py_kmeans_understanding.html](http://docs.opencv.org/master/de/d4d/tutorial_py_kmeans_understanding.html).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色边界代表凸包。一旦我们为所有形状计算了这些值，我们该如何将它们分开？我们能否仅仅使用一个固定的阈值来检测飞镖形状？实际上不行！我们不能有一个固定的阈值值，因为你永远不知道你可能会遇到什么形状。所以，更好的方法是用**K-Means聚类**。K-Means是一种无监督学习技术，可以用来将输入数据分离成K个类别。在继续之前，你可以快速复习一下K-Means，请参考[http://docs.opencv.org/master/de/d4d/tutorial_py_kmeans_understanding.html](http://docs.opencv.org/master/de/d4d/tutorial_py_kmeans_understanding.html)。
- en: 'We know that we want to separate the shapes into two groups, that is, boomerang
    shapes and other shapes. So, we know what our *K* will be in K-Means. Once we
    use that and cluster the values, we pick the cluster with the lowest solidity
    factor and that will give us our boomerang shapes. Bear in mind that this approach
    works only in this particular case. If you are dealing with other kinds of shapes,
    then you will have to use some other metrics to make sure that the shape detection
    works. As we discussed earlier, it depends heavily on the situation. If you detect
    the shapes and block them out, it will look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们想要将形状分为两组，即回旋镖形状和其他形状。因此，我们知道在K-Means中我们的*K*是什么。一旦我们使用它并对值进行聚类，我们选择具有最低固结因子的聚类，这将给我们回旋镖形状。请注意，这种方法只适用于这个特定情况。如果你处理的是其他类型的形状，那么你将不得不使用其他指标来确保形状检测能够工作。正如我们之前讨论的，这很大程度上取决于具体情况。如果你检测到形状并将它们屏蔽掉，它看起来会是这样：
- en: '![How to censor a shape?](img/B04554_08_13.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![如何屏蔽形状？](img/B04554_08_13.jpg)'
- en: 'Following is the code to do it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现它的代码：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What is image segmentation?
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是图像分割？
- en: Image segmentation is the process of separating an image into its constituent
    parts. It is an important step in many computer vision applications in the real
    world. There are many different ways of segmenting an image. When we segment an
    image, we separate the regions based on various metrics such as color, texture,
    location, and so on. All the pixels within each region have something in common,
    depending on the metric we are using. Let's take a look at some of the popular
    approaches here.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图像分割是将图像分割成其组成部分的过程。它是现实世界中许多计算机视觉应用的重要步骤。有许许多多的图像分割方法。当我们分割图像时，我们根据颜色、纹理、位置等各种指标来分离区域。每个区域内的所有像素都有一些共同点，这取决于我们使用的指标。让我们看看这里的一些流行方法。
- en: 'To start with, we will be looking at a technique called **GrabCut**. It is
    an image segmentation method based on a more generic approach called **graph-cuts**.
    In the graph-cuts method, we consider the entire image to be a graph, and then
    we segment the graph based on the strength of the edges in that graph. We construct
    the graph by considering each pixel to be a node and edges are constructed between
    the nodes, where edge weight is a function of the pixel values of those two nodes.
    Whenever there is a boundary, the pixel values are higher. Hence, the edge weights
    will also be higher. This graph is then segmented by minimizing the Gibss energy
    of the graph. This is analogous to finding the maximum entropy segmentation. You
    can refer to the original paper to learn more about it at [http://cvg.ethz.ch/teaching/cvl/2012/grabcut-siggraph04.pdf](http://cvg.ethz.ch/teaching/cvl/2012/grabcut-siggraph04.pdf).
    Let''s consider the following image:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨一种称为**GrabCut**的技术。它是一种基于更通用方法**图割**的图像分割方法。在图割方法中，我们将整个图像视为一个图，然后根据图中边的强度来分割图。我们通过考虑每个像素为一个节点来构建图，节点之间构建边，其中边的权重是这两个节点像素值的函数。每当存在边界时，像素值会更高。因此，边的权重也会更高。然后通过最小化图的吉布斯能量来分割这个图。这类似于寻找最大熵分割。你可以参考原始论文了解更多信息，请参阅[http://cvg.ethz.ch/teaching/cvl/2012/grabcut-siggraph04.pdf](http://cvg.ethz.ch/teaching/cvl/2012/grabcut-siggraph04.pdf)。让我们考虑以下图像：
- en: '![What is image segmentation?](img/B04554_08_14.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![什么是图像分割？](img/B04554_08_14.jpg)'
- en: 'Let''s select the region of interest:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择感兴趣的区域：
- en: '![What is image segmentation?](img/B04554_08_15.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![什么是图像分割？](img/B04554_08_15.jpg)'
- en: 'Once the image has been segmented, it will look something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦图像被分割，它看起来可能就像这样：
- en: '![What is image segmentation?](img/B04554_08_16.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![什么是图像分割？](img/B04554_08_16.jpg)'
- en: 'Following is the code to do this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现这一功能的代码：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How does it work?
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: We start with the seed points specified by the user. This is the bounding box
    within which we have the object of interest. Underneath the surface, the algorithm
    estimates the color distribution of the object and the background. The algorithm
    represents the color distribution of the image as a **Gaussian Mixture Markov
    Random Field** (**GMMRF**). You can refer to the detailed paper to learn more
    about GMMRF at [http://research.microsoft.com/pubs/67898/eccv04-GMMRF.pdf](http://research.microsoft.com/pubs/67898/eccv04-GMMRF.pdf).
    We need the color distribution of both, the object and the background, because
    we will be using this knowledge to separate the object. This information is used
    to find the maximum entropy segmentation by applying the min-cut algorithm to
    the Markov Random Field. Once we have this, we use the graph cuts optimization
    method to infer the labels.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从用户指定的种子点开始。这是包含我们感兴趣物体的边界框。在表面之下，算法估计物体和背景的颜色分布。算法将图像的颜色分布表示为**高斯混合马尔可夫随机场**（**GMMRF**）。你可以参考详细论文了解GMMRF的更多信息，请参阅[http://research.microsoft.com/pubs/67898/eccv04-GMMRF.pdf](http://research.microsoft.com/pubs/67898/eccv04-GMMRF.pdf)。我们需要物体和背景两者的颜色分布，因为我们将会使用这些知识来分离物体。这些信息被用来通过在马尔可夫随机场上应用最小割算法来找到最大熵分割。一旦我们有了这个，我们就使用图割优化方法来推断标签。
- en: Watershed algorithm
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分水岭算法
- en: OpenCV comes with a default implementation of the watershed algorithm. It's
    pretty famous and there are a lot of implementations available out there. You
    can read more about it at [http://docs.opencv.org/master/d3/db4/tutorial_py_watershed.html](http://docs.opencv.org/master/d3/db4/tutorial_py_watershed.html).
    Since you already have access to the OpenCV source code, we will not be looking
    at the code here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV自带了分水岭算法的默认实现。它相当著名，并且有很多实现可供选择。你可以在[http://docs.opencv.org/master/d3/db4/tutorial_py_watershed.html](http://docs.opencv.org/master/d3/db4/tutorial_py_watershed.html)了解更多相关信息。由于你已经可以访问OpenCV的源代码，我们这里将不会查看代码。
- en: 'We will just see what the output looks like. Consider the following image:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只看看输出是什么样子。考虑以下图像：
- en: '![Watershed algorithm](img/B04554_08_17.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![分水岭算法](img/B04554_08_17.jpg)'
- en: 'Let''s select the regions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择区域：
- en: '![Watershed algorithm](img/B04554_08_18.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![分水岭算法](img/B04554_08_18.jpg)'
- en: 'If you run the watershed algorithm on this, the output will look something
    like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个物体上运行分水岭算法，输出将类似于以下内容：
- en: '![Watershed algorithm](img/B04554_08_19.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![分水岭算法](img/B04554_08_19.jpg)'
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about contour analysis and image segmentation. We
    learned how to match shapes based on a template. We learned about the various
    different properties of shapes and how we can use them to identify different kinds
    of shapes. We discussed image segmentation and how we can use graph-based methods
    to segment regions in an image. We briefly discussed watershed transformation
    as well.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了轮廓分析和图像分割。我们学习了如何根据模板匹配形状。我们学习了形状的各种不同属性以及我们如何使用它们来识别不同类型的形状。我们讨论了图像分割以及我们如何使用基于图的方法来分割图像中的区域。我们还简要讨论了分水岭变换。
- en: In the next chapter, we are going to discuss how to track an object in a live
    video.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何在实时视频中跟踪一个物体。
