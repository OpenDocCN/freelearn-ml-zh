- en: '*Chapter 10*: XGBoost Model Deployment'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*: XGBoost模型部署'
- en: In this final chapter on XGBoost, you will put everything together and develop
    new techniques to build a robust machine learning model that is industry ready.
    Deploying models for industry is a little different than building models for research
    and competitions. In industry, automation is important since new data arrives
    frequently. More emphasis is placed on procedure, and less emphasis is placed
    on gaining minute percentage points by tweaking machine learning models.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章关于 XGBoost 的最后一部分，您将把所有内容结合起来，并开发新的技术，构建一个适应行业需求的强大机器学习模型。将模型部署到行业环境中与为研究和竞赛构建模型有所不同。在行业中，自动化非常重要，因为新数据会频繁到达。更多的重视放在流程上，而不是通过微调机器学习模型来获得微小的百分比提升。
- en: Specifically, in this chapter, you will gain significant experience with **one-hot
    encoding** and **sparse matrices**. In addition, you will implement and customize
    scikit-learn transformers to automate a machine learning pipeline to make predictions
    on data that is mixed with **categorical** and **numerical** columns. At the end
    of this chapter, your machine learning pipeline will be ready for any incoming
    data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您将获得与**独热编码**和**稀疏矩阵**相关的丰富经验。此外，您还将实现并自定义 scikit-learn 转换器，以自动化机器学习管道，对包含**分类**和**数值**列的混合数据进行预测。到本章结束时，您的机器学习管道将准备好处理任何新来的数据。
- en: 'In this chapter, we cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Encoding mixed data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码混合数据
- en: Customizing scikit-learn transformers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 scikit-learn 转换器
- en: Finalizing an XGBoost model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成 XGBoost 模型
- en: Building a machine learning pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建机器学习管道
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter may be found at [https://github.com/PacktPublishing/Hands-On-Gradient-Boosting-with-XGBoost-and-Scikit-learn/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Gradient-Boosting-with-XGBoost-and-Scikit-learn/tree/master/Chapter10).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Hands-On-Gradient-Boosting-with-XGBoost-and-Scikit-learn/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Gradient-Boosting-with-XGBoost-and-Scikit-learn/tree/master/Chapter10)找到。
- en: Encoding mixed data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码混合数据
- en: Imagine that you are working for an EdTech company and your job is to predict
    student grades to target services aimed at bridging the tech skills gap. Your
    first step is to load data that contains student grades into `pandas`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在为一家教育科技公司工作，您的工作是预测学生成绩，以便为弥补技术技能差距的服务提供目标。您的第一步是将包含学生成绩的数据加载到`pandas`中。
- en: Loading data
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载数据
- en: The Student Performance dataset, provided by your company, may be accessed by
    loading the `student-por.csv` file that has been imported for you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由公司提供的学生表现数据集，可以通过加载已为您导入的`student-por.csv`文件来访问。
- en: 'Start by importing `pandas` and silencing warnings. Then, download the dataset
    and view the first five rows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`pandas`并关闭警告。然后，下载数据集并查看前五行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the expected output:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是预期的输出：
- en: '![Figure 10.1 – The Student Performance dataset as is](img/B15551_10_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 学生表现数据集原始样子](img/B15551_10_01.jpg)'
- en: Figure 10.1 – The Student Performance dataset as is
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 学生表现数据集的原始样子
- en: Welcome to the world of industry, where data does not always appear as expected.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到行业世界，在这里数据并不总是如预期那样呈现。
- en: A recommended option is to view the CSV file. This can be done in Jupyter Notebooks
    by locating the folder for this chapter and clicking on the `student-por.csv`
    file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的选项是查看 CSV 文件。可以在 Jupyter Notebook 中通过定位到本章节的文件夹并点击`student-por.csv`文件来实现。
- en: 'You should see the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到如下内容：
- en: '![Figure 10.2 – The Student Performance CSV file](img/B15551_10_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 学生表现 CSV 文件](img/B15551_10_02.jpg)'
- en: Figure 10.2 – The Student Performance CSV file
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 学生表现 CSV 文件
- en: 'As you can see in the preceding figure, the data is separated by semi-colons.
    CSV stands for `pandas` comes with a `sep` parameter, which stands for **separator**,
    that may be set to the semi-colon, (*;*), as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，数据是通过分号分隔的。CSV 代表`pandas`，它带有一个`sep`参数，表示**分隔符**，可以将其设置为分号（*;*），如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the expected output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是预期的输出：
- en: '![Figure 10.3 – The Student Performance dataset ](img/B15551_10_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 学生表现数据集](img/B15551_10_03.jpg)'
- en: Figure 10.3 – The Student Performance dataset
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 学生表现数据集
- en: Now that the DataFrame looks as expected, with a mix of categorical and numerical
    values, we must clean up the **null values**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，DataFrame 看起来符合预期，包含了分类值和数值的混合数据，我们必须清理**空值**。
- en: Clearing null values
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理空值
- en: 'You can view all columns of null values by calling the `.sum()` method on `df.insull()`.
    Here is an excerpt of the results:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`df.insull()`上调用`.sum()`方法来查看所有包含空值的列。以下是结果的摘录：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can view the rows of these columns using conditional notation by placing
    `df.isna().any(axis=1)` inside of brackets with `df`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将`df.isna().any(axis=1)`放入括号中与`df`一起使用，来查看这些列的行：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the expected output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期的输出：
- en: '![Figure 10.4 – The Student Performance null data](img/B15551_10_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 学生成绩数据集的空数据](img/B15551_10_04.jpg)'
- en: Figure 10.4 – The Student Performance null data
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 学生成绩数据集的空数据
- en: 'It''s preferable to see the null columns in the middle, which Jupyter removes
    by default on account of the number of columns. This is easily corrected by setting
    `max columns` to `None` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将空列显示在中间，Jupyter 默认会删除它们，因为列数较多。可以通过将`max columns`设置为`None`来轻松修正，如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, running the code again shows all the columns:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行代码会显示所有的列：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is an excerpt of the expected output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期的输出摘录：
- en: '![Figure 10.5 – Null data from all rows of the Student Performance dataset](img/B15551_10_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 学生成绩数据集中所有行的空数据](img/B15551_10_05.jpg)'
- en: Figure 10.5 – Null data from all rows of the Student Performance dataset
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 学生成绩数据集中所有行的空数据
- en: As you can see, all columns including the hidden null values under `'guardian'`
    are now displayed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有列，包括`'guardian'`下隐藏的空值，现已显示。
- en: Numerical null values may be set to -999.0, or some other value, and XGBoost
    will find the best replacement for you using the `missing` hyperparameter as introduced
    in [*Chapter 5*](B15551_05_Final_NM_ePUB.xhtml#_idTextAnchor117), *XGBoost Unveiled*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 数值型空值可以设置为`-999.0`，或其他值，XGBoost 将使用`missing`超参数为你找到最佳替代值，正如在[*第 5 章*](B15551_05_Final_NM_ePUB.xhtml#_idTextAnchor117)中介绍的那样，*XGBoost
    揭示*。
- en: 'Here is the code to fill the `''age''` column with `-999.0`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是用`-999.0`填充`'age'`列的代码：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, categorical columns may be filled by the mode. The mode is the most common
    occurrence in a column. Filling categorical columns with the mode may distort
    the resulting distribution, however, only if the number of null values is large.
    There are only two null values present, so our distribution will not be affected.
    Another option includes replacing categorical null values with the '`unknown`'
    string, which may become its own column after one-hot encoding. Note that XGBoost
    requires numerical input, so the `missing` hyperparameter cannot be directly applied
    to categorical columns as of 2020.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，类别列可以通过众数进行填充。众数是列中最常见的值。用众数填充类别列可能会扭曲结果分布，但只有在空值数量很大时才会发生。然而，我们只有两个空值，所以我们的分布不会受到影响。另一种选择是将类别空值替换为`'unknown'`字符串，经过独热编码后，这个字符串可能会变成一个单独的列。需要注意的是，XGBoost
    需要数值型输入，因此从 2020 年起，`missing`超参数不能直接应用于类别列。
- en: 'The following code converts the `''sex''` and `''guardian''` categorical columns
    to `mode`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`'sex'`和`'guardian'`这两列类别数据转换为众数：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since our null values were in the first two rows, we can reveal that they have
    been changed using `df.head()`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的空值出现在前两行，我们可以通过使用`df.head()`来显示它们已经被更改：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the expected output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期的输出：
- en: '![Figure 10.6 – The Student Performance dataset with the null values removed
    (first five rows only)](img/B15551_10_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 删除空值后的学生成绩数据集（仅显示前五行）](img/B15551_10_06.jpg)'
- en: Figure 10.6 – The Student Performance dataset with the null values removed (first
    five rows only)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 删除空值后的学生成绩数据集（仅显示前五行）
- en: The null values have all been cleared as expected.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 空值已经按预期被清除。
- en: Next, we will convert all categorical columns to numerical columns using one-hot
    encoding.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用独热编码将所有类别列转换为数值列。
- en: One-hot encoding
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独热编码
- en: Previously, we used `pd.get_dummies` to transform all categorical variables
    to numerical values of `0` and `1`, with `0` indicating absence and `1` indicating
    presence. While acceptable, this approach has some shortcomings.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用`pd.get_dummies`将所有类别变量转换为`0`和`1`的数值，其中`0`表示缺失，`1`表示存在。虽然这种方法是可以接受的，但它也存在一些不足之处。
- en: The first shortcoming is that `pd.get_dummies` can be computationally expensive,
    as you may have found when waiting for code to run in previous chapters. The second
    shortcoming is that `pd.get_dummies` does not translate particularly well to scikit-learn's
    pipelines, a concept that we will explore in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个缺点是`pd.get_dummies`在计算上可能非常昂贵，就像你在前几章等待代码运行时所发现的那样。第二个缺点是`pd.get_dummies`在转换到scikit-learn的管道时效果不太好，这是我们将在下一节中探讨的概念。
- en: A nice alternative to `pd.get_dummies` is scikit-learn's `OneHotEncoder`. Like
    `pd.get_dummies`, one-hot encoding transforms all categorical values to `0` and
    `1`, with `0` indicating absence and `1` indicating presence, but unlike `pd.get_dummies`,
    it is not computationally expensive. `OneHotEncoder` uses a sparse matrix instead
    of a dense matrix to save space and time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不错的`pd.get_dummies`替代方案是scikit-learn的`OneHotEncoder`。与`pd.get_dummies`类似，独热编码将所有类别值转换为`0`和`1`，其中`0`表示缺失，`1`表示存在，但与`pd.get_dummies`不同的是，它并不在计算上昂贵。`OneHotEncoder`使用稀疏矩阵而不是密集矩阵，从而节省空间和时间。
- en: Sparse matrices save space by only storing data with values that do not include
    0\. The same amount of information is conserved by using fewer bits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵通过只存储不包含零的值来节省空间。通过使用更少的位数，保存了相同的信息量。
- en: In addition, `OneHotEncoder` is a scikit-learn transformer, which means that
    it's specifically designed to work in machine learning pipelines.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`OneHotEncoder`是一个scikit-learn的转换器，意味着它是专门设计用来在机器学习管道中使用的。
- en: In past versions of scikit-learn, `OneHotEncoder` only accepted numerical input.
    When that was the case, an intermediate step was taken with `LabelEncoder` to
    first convert all categorical columns into numerical columns.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的scikit-learn版本中，`OneHotEncoder`只接受数值输入。在那时，需要使用`LabelEncoder`先将所有类别列转换为数值列，作为中间步骤。
- en: 'To use `OneHotEncoder` on specific columns, you may use the following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定列上使用`OneHotEncoder`，可以按照以下步骤进行：
- en: 'Convert all categorical columns of the `dtype` object into a list:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有`dtype`为对象的类别列转换为列表：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Import and initialize `OneHotEncoder`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入并初始化`OneHotEncoder`：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the `fit_transform` method on the columns:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列上使用`fit_transform`方法：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`0` or `1`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0`或`1`。'
- en: 'If you want to see what the `hot` sparse matrix actually looks like, you can
    print it out as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想查看`hot`稀疏矩阵的实际样子，可以按如下方式打印出来：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is an excerpt of the results:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是结果的一个摘录：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you want more information about the sparse matrix, just enter the following
    variable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获得更多关于稀疏矩阵的信息，只需输入以下变量：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This tells us that the matrix is `649` by `43`, but only `11033` values have
    been stored, saving a significant amount of space. Note that for text data, which
    has many zeros, sparse matrices are very common.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，矩阵是`649`行`43`列，但只有`11033`个值被存储，从而节省了大量空间。请注意，对于包含许多零的文本数据，稀疏矩阵是非常常见的。
- en: Combining a one-hot encoded matrix and numerical columns
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并独热编码矩阵和数值列
- en: Now that we have a one-hot encoded sparse matrix, we must combine it with the
    numerical columns of the original DataFrame.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有一个独热编码的稀疏矩阵，接下来我们需要将它与原始DataFrame的数值列合并。
- en: 'First, let''s isolate the numerical columns. This may be done with the `exclude=["object"]`
    parameter as input for `df.select_dtypes`, which selects columns of certain types
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分离数值列。可以使用`df.select_dtypes`的`exclude=["object"]`参数来选择特定类型的列，方法如下：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the expected output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的输出：
- en: '![Figure 10.8 – The Student Performance dataset''s numerical columns](img/B15551_10_08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 学生表现数据集的数值列](img/B15551_10_08.jpg)'
- en: Figure 10.8 – The Student Performance dataset's numerical columns
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 学生表现数据集的数值列
- en: These are the columns we are looking for.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们要查找的列。
- en: 'For data of this size, we have a choice of converting the sparse matrix to
    a regular DataFame, as seen in the preceding screenshot, or converting this DataFrame
    into a sparse matrix. Let''s pursue the latter, considering that DataFrames in
    industry can become enormous and saving space can be advantageous:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种规模的数据，我们可以选择将稀疏矩阵转换为常规的DataFrame，如前面的截图所示，或者将这个DataFrame转换为稀疏矩阵。我们将选择后者，因为行业中的DataFrame可能非常庞大，节省空间是有利的：
- en: 'To convert the `cold_df` DataFrame to a compressed sparse matrix, import `csr_matrix`
    from `scipy.sparse` and place the DataFrame inside, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将`cold_df` DataFrame转换为压缩稀疏矩阵，请从`scipy.sparse`导入`csr_matrix`并将DataFrame放入其中，如下所示：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, stack both matrices, hot and cold, by importing and using `hstack`,
    which combines sparse matrices horizontally:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过导入并使用`hstack`，将热矩阵和冷矩阵堆叠起来，`hstack`将稀疏矩阵水平组合：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Verify that `final_sparse_matrix` works as expected by converting the sparse
    matrix into a dense matrix and by displaying the DataFrame as usual:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将稀疏矩阵转换为密集矩阵并像往常一样显示数据框，验证`final_sparse_matrix`是否按预期工作：
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the expected output:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是预期的输出：
- en: '![Figure 10.9 – The DataFrame of the final sparse matrix](img/B15551_10_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 最终稀疏矩阵的数据框](img/B15551_10_09.jpg)'
- en: Figure 10.9 – The DataFrame of the final sparse matrix
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 最终稀疏矩阵的数据框
- en: The output is shifted to the right to show the one-hot encoded and numerical
    columns together.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出被向右移动，以显示一热编码和数值列一起呈现。
- en: Now that the data is ready for machine learning, let's automate the process
    using transformers and pipelines.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已准备好进行机器学习，让我们使用变换器和流水线自动化这个过程。
- en: Customizing scikit-learn transformers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制Scikit-learn变换器
- en: Now that we have a process for transforming the DataFrame into a machine learning-ready
    sparse matrix, it would be advantageous to generalize the process with transformers
    so that it can easily be repeated for new data coming in.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个将数据框转换为适合机器学习的稀疏矩阵的过程，将其用变换器进行泛化，以便可以轻松地为新的数据重复这个过程，将会是一个有利的选择。
- en: Scikit-learn transformers work with machine learning algorithms by using a `fit`
    method, which finds model parameters, and a `transform` method, which applies
    these parameters to data. These methods may be combined into a single `fit_transform`
    method that fits and transforms data in one line of code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Scikit-learn的变换器通过使用`fit`方法与机器学习算法一起工作，`fit`方法用于找到模型参数，`transform`方法则将这些参数应用于数据。这些方法可以合并为一个`fit_transform`方法，在一行代码中同时完成拟合和变换数据。
- en: When used together, various transformers, including machine learning algorithms,
    may work together in the same pipeline for ease of use. Data is then placed in
    the pipeline that is fit and transformed to achieve the desired output.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当一起使用时，各种变换器，包括机器学习算法，可以在同一流水线中协同工作，便于使用。然后，数据被放入流水线中，进行拟合和变换，以实现期望的输出。
- en: Scikit-learn comes with many great transformers, such as `StandardScaler` and
    `Normalizer` to standardize and normalize data, respectively, and `SimpleImputer`
    to convert null values. You have to be careful, however, when data contains a
    mix of categorical and numerical columns, as is the case here. In some cases,
    the scikit-learn options may not be the best options for automation. In this case,
    it's worth creating your own transformers to do exactly what you want.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Scikit-learn提供了许多优秀的变换器，例如`StandardScaler`和`Normalizer`分别用于标准化和归一化数据，`SimpleImputer`用于转换空值。然而，当数据包含混合类别和数值列时（如本例所示），你需要小心。在某些情况下，Scikit-learn提供的选项可能不是自动化的最佳选择。在这种情况下，值得创建你自己的变换器来精确地完成你想要的操作。
- en: Customizing transformers
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制变换器
- en: The key to creating your own transformers is to use scikit-learn's `TransformerMixin`
    as your superclass.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你自己的变换器的关键是使用Scikit-learn的`TransformerMixin`作为父类。
- en: 'Here is a general code outline to create a customized transformer in scikit-learn:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Scikit-learn中创建定制变换器的一般代码框架：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, you don't have to initialize anything, and `fit` can always
    return `self`. Simply put, you may place all your code for transforming the data
    under the `transform` method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你无需初始化任何内容，`fit`方法可以始终返回`self`。简而言之，你可以将所有用于变换数据的代码放在`transform`方法下。
- en: Now that you see how customization works generally, let's create a customized
    transformer to handle different kinds of null values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了定制化的一般操作方式，让我们创建一个定制的变换器，用来处理不同类型的空值。
- en: Customizing a mixed null value imputer
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制混合空值填充器
- en: Let's see how this works by creating a customized mixed null value imputer.
    Here, the reason for the customization is to handle different types of columns
    with different approaches to correcting null values.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个定制的混合空值填充器来看看这个如何工作。这里，定制化的原因是为了处理不同类型的列，并采用不同的方式修正空值。
- en: 'Here are the steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是步骤：
- en: 'Import `TransformerMixin` and define a new class with `TransformerMixin` as
    the superclass:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`TransformerMixin`并定义一个新类，以`TransformerMixin`作为父类：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Initialize the class with `self` as input. It''s okay if this does nothing:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`self`作为输入初始化类。如果这个操作没有实际作用也没关系：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `fit` method that takes `self` and `X` as input, with `y=None`, and
    returns `self`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fit`方法，接受`self`和`X`作为输入，`y=None`，并返回`self`：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a `transform` method that takes `self` and `X` as input, with `y=None`,
    and transforms the data by returning a new `X`, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`transform`方法，该方法接受`self`和`X`作为输入，`y=None`，并通过返回一个新的`X`来转换数据，如下所示：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We need to handle null values separately depending on the columns.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要根据列的不同单独处理空值。
- en: 'Here are the steps to convert null values to the mode or `-999.0`, depending
    upon the column type:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是将空值转换为众数或`-999.0`的步骤，具体取决于列的类型：
- en: 'a) Loop through the columns by converting them to a list:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 通过将列转换为列表来循环遍历列：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'b) Within the loop, access the columns that are strings by checking which columns
    are of the `object` dtype:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 在循环中，通过检查哪些列是`object`类型来访问字符串列：
- en: '[PRE26]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'c) Convert the null values of the string (`object`) columns to the mode:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 将字符串（`object`）列的空值转换为众数：
- en: '[PRE27]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'd) Otherwise, fill the columns with `-999.0`:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 否则，将列填充为`-999.0`：
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, you may have wondered why `y=None` is used. The reason
    is that `y` will be needed as an input when including a machine learning algorithm
    in the pipeline. By setting `y` to `None`, changes will only be made to the predictor
    columns as expected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可能会想知道为什么使用了`y=None`。原因是，当将机器学习算法纳入管道时，`y`将作为输入使用。通过将`y`设置为`None`，只会对预测列进行预期的更改。
- en: Now that the customized imputer has been defined, it may be used by calling
    the `fit_transform` method on the data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定制的插补器已经定义完成，可以通过在数据上调用`fit_transform`方法来使用它。
- en: 'Let''s reset the data by establishing a new DataFrame from the CSV file and
    transform the null values in one line of code using the customized `NullValueImputer`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从CSV文件创建一个新的DataFrame并使用定制的`NullValueImputer`在一行代码中转换空值，来重置数据：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is the expected output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是期望的输出：
- en: '![Figure 10.10 – The Student Performance DataFrame after NullValueImputer()](img/B15551_10_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 使用NullValueImputer()后的学生表现DataFrame](img/B15551_10_10.jpg)'
- en: Figure 10.10 – The Student Performance DataFrame after NullValueImputer()
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 使用NullValueImputer()后的学生表现DataFrame
- en: As you can see, all null values have been cleared.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有空值都已清除。
- en: Next, let's transform the data into a one-hot encoded sparse matrix as before.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们像之前一样将数据转换为独热编码的稀疏矩阵。
- en: One-hot encoding mixed data
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独热编码混合数据
- en: 'We will apply similar steps here to those from the previous section by creating
    a customized transformer to one-hot encode the categorical columns before joining
    them with the numerical columns as a sparse matrix (a dense matrix is also okay
    for a dataset of this size):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取与上一节类似的步骤，通过创建一个定制的转换器对分类列进行独热编码，然后将它们与数值列合并为一个稀疏矩阵（对于这个大小的数据集，密集矩阵也可以）：
- en: 'Define a new class with `TransformerMixin` as the superclass:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的类，继承`TransformerMixin`作为父类：
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Initialize the class with `self` as input. It''s okay if this does nothing:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`self`作为输入初始化类。如果这没有任何作用也没关系：
- en: '[PRE31]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a `fit` method that takes `self` and `X` as input and returns `self`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`fit`方法，该方法接受`self`和`X`作为输入并返回`self`：
- en: '[PRE32]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a `transform` method that takes `self` and `X` as input, transforms
    the data, and returns a new `X`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`transform`方法，该方法接受`self`和`X`作为输入，转换数据并返回新的`X`：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here are the steps to complete the transformation; start by accessing only
    the categorical columns, which are of the `object` type, as follows:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是完成转换的步骤；首先访问仅包含`object`类型的分类列，如下所示：
- en: 'a) Put the categorical columns in a list:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 将分类列放入一个列表中：
- en: '[PRE34]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'b) Initialize `OneHotEncoder`:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 初始化`OneHotEncoder`：
- en: '[PRE35]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'c) Transform the categorical columns with `OneHotEncoder`:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) 使用`OneHotEncoder`转换分类列：
- en: '[PRE36]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'd) Create a DataFrame of numerical columns only by excluding strings:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) 通过排除字符串，创建一个仅包含数值列的DataFrame：
- en: '[PRE37]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'e) Convert the numerical DataFrame into a sparse matrix:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e) 将数值型DataFrame转换为稀疏矩阵：
- en: '[PRE38]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'f) Combine both sparse matrices into one:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: f) 将两个稀疏矩阵合并为一个：
- en: '[PRE39]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'g) Convert this into a **Compressed Sparse Row** (**CSR**) matrix to limit
    errors. Note that XGBoost requires CSR matrices, and this conversion may happen
    automatically depending on your version of XGBoost:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: g) 将其转换为**压缩稀疏行**（**CSR**）矩阵，以限制错误。请注意，XGBoost要求使用CSR矩阵，并且根据你的XGBoost版本，转换可能会自动发生：
- en: '[PRE40]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can transform the `nvi` data with no null values by using the powerful
    `fit_transform` method on `SparseMatrix`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用强大的`fit_transform`方法对没有空值的`nvi`数据进行转换：
- en: '[PRE41]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The expected output, given here, is truncated to save space:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里给出的期望输出已被截断以节省空间：
- en: '[PRE42]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can verify that the data looks as expected by converting the sparse matrix
    back into a dense matrix as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过将稀疏矩阵转换回密集矩阵来验证数据是否符合预期，方法如下：
- en: '[PRE43]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is the expected dense output:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是预期的密集输出：
- en: '![Figure 10.11 – The sparse matrix converted into a dense matrix](img/B15551_10_11.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 稀疏矩阵转换为密集矩阵](img/B15551_10_11.jpg)'
- en: Figure 10.11 – The sparse matrix converted into a dense matrix
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 稀疏矩阵转换为密集矩阵
- en: This appears correct. The figure shows a value of `0.0` for the 27th column
    and a value of `1.0` for the 28th column. The preceding one-hot encoded output
    excludes (`0`,`27`) and shows a value of `1.0` for (`0`,`28`), matching the dense
    output.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是正确的。图中显示第27列的值为`0.0`，第28列的值为`1.0`。前面的独热编码输出排除了（`0`，`27`），并显示（`0`，`28`）的值为`1.0`，与密集输出匹配。
- en: Now that the data has been transformed, let's combine both preprocessing steps
    into a single pipeline.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经转换，让我们将两个预处理步骤合并到一个单一的管道中。
- en: Preprocessing pipeline
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理管道
- en: When building machine learning models, it's standard to start by separating
    the data into `X` and `y`. When thinking about a pipeline, it makes sense to transform
    `X`, the predictor columns, and not `y`, the target column. Furthermore, it's
    important to hold out a test set for later.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建机器学习模型时，通常会先将数据分为`X`和`y`。在考虑管道时，合理的做法是转换`X`（预测列），而不是`y`（目标列）。此外，重要的是保留一个测试集以供后用。
- en: 'Before placing data into the machine learning pipeline, let''s split the data
    into training and test sets and leave the test set behind. We start from the top
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据放入机器学习管道之前，让我们将数据拆分为训练集和测试集，并保留测试集。我们按以下方式从头开始：
- en: 'First, read the CSV file as a DataFrame:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将CSV文件读取为一个DataFrame：
- en: '[PRE44]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When choosing `X` and `y` for the Student Performance dataset, it''s important
    to note that the last three columns all include student grades. Two potential
    studies are of value here:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在为学生表现数据集选择`X`和`y`时，需要注意的是，最后三列都包含学生成绩。这里有两个潜在的研究方向值得关注：
- en: a) Including previous grades as predictor columns
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) 包括之前的成绩作为预测列
- en: b) Not including previous grades as predictor columns
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) 不包括之前的成绩作为预测列
- en: Assume that your EdTech company wants to make predictions based on socioeconomic
    variables, not on previous grades earned, so ignore the first two grade columns
    indexed as -`2` and -`3`.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设你的EdTech公司希望基于社会经济变量进行预测，而不是基于以前获得的成绩，因此忽略前两列成绩，索引为`-2`和`-3`。
- en: 'Select the last column as `y`, and all columns except for the last three as
    `X`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最后一列作为`y`，并将最后三列以外的所有列作为`X`：
- en: '[PRE45]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now import `train_test_split` and split `X` and `y` into a training and a test
    set:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导入`train_test_split`，并将`X`和`y`拆分为训练集和测试集：
- en: '[PRE46]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now let''s build the pipeline using the following steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤构建管道：
- en: 'First import `Pipeline` from `sklearn.pipeline`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先从`sklearn.pipeline`导入`Pipeline`：
- en: '[PRE47]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, assign tuples using the syntax (name, transformer) as parameters of `Pipeline`
    in sequence:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用语法（name，transformer）将元组分配为`Pipeline`中的参数，按顺序排列：
- en: '[PRE48]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, transform `X_train`, our predictor columns, by placing `X_train` inside
    the `fit_transform` method of `data_pipeline`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将`X_train`放入`data_pipeline`的`fit_transform`方法中来转换我们的预测列`X_train`：
- en: '[PRE49]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now you have a numerical, sparse matrix with no null values that can be used
    as the predictor column for machine learning.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个数值稀疏矩阵，没有空值，可以作为机器学习的预测列。
- en: Furthermore, you have a pipeline that may be used to transform any incoming
    data in one line of code! Let's now finalize an XGBoost model to make predictions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你有一个管道，可以通过一行代码转换任何传入的数据！现在让我们完成一个XGBoost模型来进行预测。
- en: Finalizing an XGBoost model
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成XGBoost模型的最终调整
- en: 'It''s time to build a robust XGBoost model to add to the pipeline. Go ahead
    and import `XGBRegressor`, `numpy`, `GridSearchCV`, `cross_val_score`, `KFold`,
    and `mean_squared_error` as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建一个稳健的XGBoost模型并将其添加到管道中。请按以下方式导入`XGBRegressor`、`numpy`、`GridSearchCV`、`cross_val_score`、`KFold`和`mean_squared_error`：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now let's build the model.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建模型。
- en: First XGBoost model
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个XGBoost模型
- en: 'This Student Performance dataset has an interesting range of values for the
    predictor column, `y_train`, which can be shown as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个学生表现数据集在预测列`y_train`方面有一个有趣的值范围，可以如下所示：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The result is this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, the values range from `5`-`19` with `0` included.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数值范围从`5`到`19`，并且包括`0`。
- en: Since the target column is ordinal, meaning the values are numerically ordered,
    regression is preferable to classification even though the outputs are limited.
    After training a model via regression, the final results may be rounded to give
    the final predictions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标列是有序的，意味着其值是按数字顺序排列的，因此回归方法比分类方法更为合适，尽管输出有限。在通过回归训练模型后，最终结果可能会进行四舍五入，以给出最终预测。
- en: 'Here are the steps to score `XGBRegressor` with this dataset:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对 `XGBRegressor` 使用此数据集进行评分的步骤：
- en: 'Start by setting up cross-validation using `KFold`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从设置使用 `KFold` 的交叉验证开始：
- en: '[PRE53]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now define a cross-validation function that returns the `cross_val_score`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义一个交叉验证函数，该函数返回 `cross_val_score`：
- en: '[PRE54]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Establish a base score by calling `cross_val` with the `XGBRegressor` as input
    with `missing=-999.0` so that XGBoost can find the best replacement:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `cross_val` 以 `XGBRegressor` 为输入并将 `missing=-999.0`，为 XGBoost 寻找最佳替代值，建立一个基准分数：
- en: '[PRE55]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The score is this:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分数如下：
- en: '[PRE56]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is a respectable starting score. A root mean squared error of `2.97` out
    of 19 possibilities indicates that the grades are within a couple of points of
    accuracy. This is almost 15%, which is accurate within one letter grade using
    the American A-B-C-D-F system. In industry, you may even include a confidence
    interval using statistics to deliver a prediction interval, a recommended strategy
    that is outside the scope of this book.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个值得尊敬的起始分数。`2.97` 的均方根误差，基于 19 种可能性，表示分数的准确性相差不到几个点。这几乎是 15%，在美国 A-B-C-D-F
    系统中准确到一个字母等级。在工业界，您甚至可以使用统计学方法来包括置信区间，提供预测区间，这是本书范围之外的推荐策略。
- en: Now that you have a baseline score, let's fine-tune the hyperparameters to improve
    the model.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已有了基准分数，让我们微调超参数以改进模型。
- en: Fine-tuning the XGBoost hyperparameters
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微调 XGBoost 超参数
- en: 'Let''s start by checking `n_estimators` with early stopping. Recall that to
    use early stopping, we may check one test fold. Creating the test fold requires
    splitting `X_train` and `y_train` further:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从检查带有提前停止的 `n_estimators` 开始。回忆一下，为了使用提前停止，我们可能会检查一个测试折叠。创建测试折叠需要进一步划分 `X_train`
    和 `y_train`：
- en: 'Here is a second `train_test_split` that may be used to create a test set for
    validation purposes, making sure to keep the real test set hidden for later:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是第二个 `train_test_split`，可用于创建一个测试集进行验证，同时确保将真实的测试集保留到后期：
- en: '[PRE57]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now define a function that uses early stopping to return the optimal number
    of estimators for the regressor (see [*Chapter 6*](B15551_06_Final_NM_ePUB.xhtml#_idTextAnchor136)*,
    XGBoost Hyperparameters*):'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义一个函数，使用提前停止来返回回归器的最佳估计器数量（参见 [*第 6 章*](B15551_06_Final_NM_ePUB.xhtml#_idTextAnchor136)，XGBoost
    超参数）：
- en: '[PRE58]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now run the `n_estimators` function, setting to `5000` as a maximum:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行 `n_estimators` 函数，将最大值设置为 `5000`：
- en: '[PRE59]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here are the last five rows of the output:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是输出的最后五行：
- en: '[PRE60]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The score is as follows:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分数如下：
- en: '[PRE61]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using our default model, 31 estimators currently gives the best estimate. That
    will be our starting point.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们默认的模型，31 个估计器目前给出最佳估算值。这将是我们的起点。
- en: 'Next, here is a `grid_search` function, which we have used multiple times,
    that searches a grid of hyperparameters and displays the best parameters and best
    score:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是一个我们多次使用的 `grid_search` 函数，它搜索超参数网格并显示最佳参数和最佳分数：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here are a few recommended steps for fine-tuning the model:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些推荐的模型微调步骤：
- en: 'Start with `max_depth` ranging from `1` to `8` while setting `n_estimators`
    to `31`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从将 `max_depth` 范围设置为 `1` 到 `8` 开始，同时将 `n_estimators` 设置为 `31`：
- en: '[PRE63]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The result is this:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE64]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Narrow `max_depth` from `1` to `3` while ranging `min_child_weight` from `1`
    to `5` and holding `n_esimtators` at `31`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `max_depth` 从 `1` 缩小到 `3`，同时将 `min_child_weight` 范围设定为 `1` 到 `5`，并保持 `n_estimators`
    为 `31`：
- en: '[PRE65]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The result is this:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE66]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There is no improvement.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有改进。
- en: 'You may guarantee some changes by forcing `min_child_weight` to take on a value
    of `2` or `3` while including a range of `subsample` from `0.5` to `0.9`. Furthermore,
    increasing `n_estimators` may help by giving the model more time to learn:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过强制将 `min_child_weight` 设置为 `2` 或 `3`，同时包含 `subsample` 范围从 `0.5` 到 `0.9`，你可能可以保证一些变化。此外，增加
    `n_estimators` 可能有助于为模型提供更多学习时间：
- en: '[PRE67]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The result is as follows:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE68]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The score is nearly the same, but slightly worse.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分数几乎相同，但略有下降。
- en: 'Narrow `min_child_weight` and `subsample` while using a range of `0.5` to `0.9`
    for `colsample_bytree`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩小 `min_child_weight` 和 `subsample` 的范围，同时将 `colsample_bytree` 设置为 `0.5` 到 `0.9`
    的范围：
- en: '[PRE69]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The result is this:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE70]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is the best score so far.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是目前为止最好的分数。
- en: 'Holding the best current values, try ranges from `0.6` to `1.0` with `colsample_bynode`
    and `colsample_bylevel`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持当前最优值，尝试`colsample_bynode`和`colsample_bylevel`的范围从`0.6`到`1.0`：
- en: '[PRE71]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The result is given here:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE72]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The score has improved again.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 得分再次提高。
- en: Further experimentation with the base learner to `dart` and `gamma` resulted
    in no new gains.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步尝试使用基础学习器`dart`和`gamma`，但未获得新收益。
- en: Depending on the time and the scope of the project, it could be worth tuning
    hyperparameters further, and even trying them all together in `RandomizedSearch`.
    In industry, there is a good chance that you will have access to cloud computing,
    where inexpensive, preemptible **Virtual Machines** (**VMs**) will allow more
    hyperparameter searches to find even better results. Just note that scikit-learn
    currently does not offer a way to stop time-consuming searches to save the best
    parameters before the code completes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目的时间和范围，可能值得进一步调整超参数，甚至将它们一起放入`RandomizedSearch`中尝试。在工业界，你很有可能可以访问到云计算，在这里，廉价的、可抢占的**虚拟机**（**VMs**）将允许更多的超参数搜索，以找到更好的结果。只需要注意的是，scikit-learn目前没有提供一种方法来停止耗时的搜索，以便在代码完成之前保存最佳参数。
- en: Now that we have a robust model, we can move forward and test the model.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个健壮的模型，可以继续前进并测试该模型。
- en: Testing model
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试模型
- en: Now that you have a potential final model, it's important to test it against
    the test set.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个潜在的最终模型，重要的是在测试集上对它进行测试。
- en: 'Recall that the test set was not transformed in our pipeline. Fortunately,
    at this point, it only takes one line of code to transform it:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，测试集在我们的管道中并没有进行转化。幸运的是，此时只需要一行代码即可将其转化：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we can initialize a model with the best-tuned hyperparameters selected
    in the previous section, fit it on the training set, and test it against the test
    set that was held back:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用之前部分中选择的最佳超参数初始化一个模型，拟合训练集，并在保留的测试集上进行测试：
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The score is as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 得分如下：
- en: '[PRE75]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The score is a little higher, although this could be on account of the fold.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 得分稍微高一些，尽管这可能是由于折叠的原因。
- en: If not, our model has fit the validation set a little too closely, which can
    happen when fine-tuning hyperparameters and adjusting them closely to improve
    the validation set. The model generalizes fairly well, but it could generalize
    better.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有的话，我们的模型可能在验证集上拟合得过于紧密，这在微调超参数并将其精确调整以改进验证集时是可能发生的。模型的泛化能力还不错，但它可以有更好的泛化能力。
- en: 'For the next steps, when considering whether the score can be improved upon,
    the following options are available:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的步骤，当考虑是否可以改进得分时，以下选项是可用的：
- en: Return to hyperparameter fine-tuning.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回超参数微调。
- en: Keep the model as is.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持模型不变。
- en: Make a quick adjustment based on hyperparameter knowledge.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据超参数知识进行快速调整。
- en: Quickly adjusting hyperparameters is viable since the model could be overfitting.
    For instance, increasing `min_child_weight` and lowering `subsample` should help
    the model to generalize better.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 快速调整超参数是可行的，因为模型可能会过拟合。例如，增加`min_child_weight`并降低`subsample`应该有助于模型更好地泛化。
- en: 'Let''s make that final adjustment for a final model:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行最终的调整，得到一个最终模型：
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The result is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that the score has improved.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，得分已经提高。
- en: Also, you should absolutely not go back and forth trying to improve the hold-out
    test score. It is acceptable to make a few adjustments after receiving the test
    score, however; otherwise, you could never improve upon the first result.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你绝对不应该反复尝试提高验证集得分。在收到测试得分后进行少许调整是可以接受的；否则，你永远无法在第一次结果的基础上进行改进。
- en: Now all that remains is to complete the pipeline.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是完成管道。
- en: Building a machine learning pipeline
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建机器学习管道
- en: 'Completing the machine learning pipeline requires adding the machine learning
    model to the previous pipeline. You need a machine learning tuple after `NullValueImputer`
    and `SparseMatrix` as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 完成机器学习管道需要将机器学习模型添加到之前的管道中。你需要在`NullValueImputer`和`SparseMatrix`之后，得到一个机器学习元组，如下所示：
- en: '[PRE78]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This pipeline is now complete with a machine learning model, and it can be
    fit on any `X`, `y` combination, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道现在已经完成了机器学习模型，并且它可以在任何`X`，`y`组合上进行拟合，如下所示：
- en: '[PRE79]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now you can make predictions on any data whose target column is unknown:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以对任何目标列未知的数据进行预测：
- en: '[PRE80]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here are the first few rows of the expected output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期输出的前几行：
- en: '[PRE81]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To get realistic predictions, the data may be rounded as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到更真实的预测，数据可能需要按如下方式四舍五入：
- en: '[PRE82]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The expected output is given here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的输出如下：
- en: '[PRE83]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, if new data comes through, it can be concatenated with the previous
    data and placed through the same pipeline for a stronger model, since the new
    model may be fit on more data as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果新数据到达，可以将其与之前的数据连接，并通过相同的管道处理，从而得到一个更强大的模型，因为新的模型可能会基于更多的数据进行训练，如下所示：
- en: '[PRE84]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, this model may be used to make predictions on new data, as shown in the
    following code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个模型可以用于对新数据进行预测，如以下代码所示：
- en: '[PRE85]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The expected output is as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的输出如下：
- en: '[PRE86]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: There is one small catch.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小小的细节。
- en: What if you want to make a prediction on only one row of data? If you run a
    single row through the pipeline, the resulting sparse matrix will not have the
    correct number of columns, since it will only one-hot encode categories that are
    present in the single row. This will result in a *mismatch* error in the data,
    since the machine learning model has been fit to a sparse matrix that requires
    more rows of data.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想对一行数据进行预测怎么办？如果你将单行数据通过管道处理，生成的稀疏矩阵将没有正确的列数，因为它只会对单行数据中存在的类别进行独热编码。这将导致数据中的*不匹配*错误，因为机器学习模型已经适配了一个需要更多数据行的稀疏矩阵。
- en: A simple solution is to concatenate the new row of data with enough rows of
    data to guarantee that the full sparse matrix is present with all possible categorical
    columns transformed. We have seen that this works with 25 rows from `X_test` since
    there were no errors. Using 20 or fewer rows from `X_test` will result in a mismatch
    error in this particular case.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方法是将新的一行数据与足够多的行数据连接起来，以确保生成的稀疏矩阵包含所有可能的类别列并进行转换。我们已经看到，这样操作使用`X_test`中的25行数据是有效的，因为没有出现错误。使用`X_test`中的20行或更少的数据将导致在这种情况下出现不匹配错误。
- en: 'So, if you want to make a prediction with a single row of data, concatenate
    the single row with the first `25` rows of `X_test` and make a prediction as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想用单行数据进行预测，可以将这一行数据与`X_test`的前`25`行连接，并按如下方式进行预测：
- en: '[PRE87]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The result is this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这样的：
- en: '[PRE88]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You now know how machine learning models may be included in pipelines to transform
    and make predictions on new data.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何将机器学习模型纳入管道，以对新数据进行转换和预测。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations on making it to the end of the book! This has been an extraordinary
    journey that began with basic machine learning and `pandas` and ended with building
    your own customized transformers, pipelines, and functions to deploy robust, fine-tuned
    XGBoost models in industry scenarios with sparse matrices to make predictions
    on new data.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了本书！这是一次非凡的旅程，从基础的机器学习和`pandas`开始，到最终构建自己定制的转换器、管道和函数，以便在工业场景中使用稀疏矩阵部署强大、精细调优的XGBoost模型进行新数据预测。
- en: Along the way, you have learned the story of XGBoost, from the first decision
    trees through random forests and gradient boosting, before discovering the mathematical
    details and sophistication that has made XGBoost so special. You saw time and
    time again that XGBoost outperforms other machine learning algorithms, and you
    gained essential practice in tuning XGBoost's wide-ranging hyperparameters, including
    `n_estimators`, `max_depth`, `gamma`, `colsample_bylevel`, `missing`, and `scale_pos_weight`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，你了解了XGBoost的故事，从最初的决策树到随机森林和梯度提升，再到发现使XGBoost如此特别的数学细节和复杂性。你一次又一次地看到XGBoost超越了其他机器学习算法，并且你获得了调优XGBoost广泛超参数的实践经验，包括`n_estimators`、`max_depth`、`gamma`、`colsample_bylevel`、`missing`和`scale_pos_weight`。
- en: You learned how physicists and astronomers obtained knowledge about our universe
    in historically important case studies, and you learned about the extensive range
    of XGBoost through imbalanced datasets and the application of alternative base
    learners. You even learned tricks of the trade from Kaggle competitions through
    advanced feature engineering, non-correlated ensembles, and stacking. Finally,
    you learned advanced automation processes for industry.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了物理学家和天文学家如何通过历史上重要的案例研究获得关于我们宇宙的知识，并且通过不平衡数据集和替代基本学习器的应用，深入了解了XGBoost的广泛范围。你甚至通过先进的特征工程、非相关集成和堆叠等技巧，从Kaggle竞赛中学到了行业技巧。最后，你了解了工业中的高级自动化过程。
- en: At this point, your knowledge of XGBoost is at an advanced level. You can now
    use XGBoost efficiently, swiftly, and powerfully to tackle the machine learning
    problems that will come your way. Of course, XGBoost is not perfect. If you are
    dealing with unstructured data such as images or text, **neural networks** might
    serve you better. For most machine learning tasks, especially those with tabular
    data, XGBoost will usually give you an advantage.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你对 XGBoost 的知识已经达到高级水平。你现在可以高效、迅速、强大地使用 XGBoost 来解决你将面对的机器学习问题。当然，XGBoost
    并不完美。如果你处理的是非结构化数据，比如图像或文本，**神经网络**可能会更适合你。对于大多数机器学习任务，尤其是表格数据的任务，XGBoost 通常会给你带来优势。
- en: If you are interested in pursuing further studies with XGBoost, my personal
    recommendation is to enter Kaggle competitions. The reason is that Kaggle competitions
    consist of seasoned machine learning practitioners and competing against them
    will make you better. Furthermore, Kaggle competitions provide a structured machine
    learning environment consisting of many practitioners working on the same problem,
    which results in shared notebooks and forum discussions that can further boost
    the educational process. It's also where XGBoost first developed its extraordinary
    reputation with the Higgs boson competition, as outlined in this book.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣继续深入研究 XGBoost，我个人的建议是参加 Kaggle 竞赛。原因是 Kaggle 竞赛汇聚了经验丰富的机器学习从业者，与他们竞争会让你变得更强。此外，Kaggle
    竞赛提供了一个结构化的机器学习环境，许多从业者都在同一个问题上进行工作，这导致了共享笔记本和论坛讨论，进一步促进了学习过程。这也是 XGBoost 在希格斯玻色子竞赛中首次建立起非凡声誉的地方，如本书所述。
- en: You may now go confidently forward into the world of big data with XGBoost to
    advance research, enter competitions, and build machine learning models ready
    for production.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以自信地使用 XGBoost 进入大数据领域，推动研究、参加竞赛，并构建适合生产的机器学习模型。
