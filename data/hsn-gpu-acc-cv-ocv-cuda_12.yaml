- en: Basic Computer Vision Applications Using PyCUDA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyCUDA 的基本计算机视觉应用
- en: In the previous chapter, we saw important programming concepts related to PyCUDA.
    We also learned how to develop some programs in PyCUDA using these programming
    concepts. This chapter will build on this knowledge and we will use PyCUDA for
    developing basic image processing and computer vision applications. The parallel
    programming concepts of atomic operations and shared memory will also be explained
    in detail. The histogram of an image conveys important information related to
    the contrast of an image and it can also be used as an image feature for computer
    vision tasks. The program to calculate the histogram using PyCUDA will be explained
    in detail in this chapter. Other basic computer vision applications, such as the
    conversion of color spaces, image addition, and image inversion using PyCUDA,
    will also be described.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了与 PyCUDA 相关的重要编程概念。我们还学习了如何使用这些编程概念在 PyCUDA 中开发一些程序。本章将在此基础上构建知识，我们将使用
    PyCUDA 来开发基本的图像处理和计算机视觉应用。原子操作和共享内存的并行编程概念也将被详细解释。图像直方图传达了与图像对比度相关的信息，它还可以用作计算机视觉任务的图像特征。本章将详细解释使用
    PyCUDA 计算直方图的程序。其他基本的计算机视觉应用，如使用 PyCUDA 进行颜色空间转换、图像加法和图像反转，也将被描述。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Histogram calculation using atomic operations and shared memory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子操作和共享内存进行直方图计算
- en: Basic computer vision applications using PyCUDA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyCUDA 的基本计算机视觉应用
- en: Color space conversion for an image and video from a webcam
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络摄像头进行图像和视频的颜色空间转换
- en: Image addition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像加法
- en: Image inversion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像反转
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires a good understanding of the Python programming languages.
    It also requires any computer or laptop with an Nvidia GPU on board. All the code
    used in this chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA).
    Check out the following video to see the code in action: [http://bit.ly/2prC1wI](http://bit.ly/2prC1wI)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求对 Python 编程语言有良好的理解。它还需要任何带有 Nvidia GPU 的计算机或笔记本电脑。本章中使用的所有代码都可以从以下 GitHub
    链接下载：[https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA)。查看以下视频以查看代码的实际运行情况：[http://bit.ly/2prC1wI](http://bit.ly/2prC1wI)
- en: Histogram calculation in PyCUDA
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCUDA 中的直方图计算
- en: The histogram of an image conveys important information related to the contrast
    of an image, and it can also be used as an image feature for computer vision tasks.
    A histogram indicates the frequency of the occurrence of a particular pixel value.
    While calculating the histogram of an 8-bit image that is 256 x 256 in size, the
    65,535-pixel values will work on arrays of intensity values from 0-255\. If one
    thread is launched per pixel, then 65,535 threads will work on 256 memory locations
    of intensity values.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图像直方图传达了与图像对比度相关的信息，它还可以用作计算机视觉任务的图像特征。直方图表示特定像素值出现的频率。在计算大小为 256 x 256 的 8
    位图像的直方图时，65,535 个像素值将在 0-255 的强度值数组上工作。如果为每个像素启动一个线程，那么 65,535 个线程将在 256 个强度值内存位置上工作。
- en: Consider a situation in which a large number of threads try to modify a small
    portion of memory. While calculating the histogram of an image, read-modify-write
    operations have to be performed for all memory locations. This operation is `d_out[i]
    ++`, where first `d_out[i]` is read from memory, then incremented, and then written
    back to the memory. However, when multiple threads are doing this operation on
    the same memory location, it can give an incorrect output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，即大量线程试图修改内存的一小部分。在计算图像直方图时，必须对所有内存位置执行读取-修改-写入操作。这个操作是 `d_out[i] ++`，其中首先从内存中读取
    `d_out[i]`，然后增加，最后写回内存。然而，当多个线程在相同的内存位置执行此操作时，可能会给出错误的结果。
- en: Suppose one memory location has an initial value of `0` and the `a` and `b`
    threads try to increment this memory location, then the final answer should be
    `2`. However, at the time of execution, it may happen that both the `a` and `b`
    threads read this value simultaneously, then both threads will get the value `0`.
    They increment it to `1` and both will store this `1` on the memory. So instead
    of `2`, the calculated answer is `1`, which is incorrect.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个内存位置有一个初始值`0`，线程`a`和`b`尝试递增这个内存位置，那么最终答案应该是`2`。然而，在执行时，可能会发生`a`和`b`线程同时读取这个值的情况，那么这两个线程都将得到值`0`。它们将其递增到`1`，并且两个线程都将这个`1`存储在内存中。所以，计算出的答案是`1`，这是不正确的。
- en: To understand how this can be dangerous, consider the example of an ATM cash
    withdrawal. Suppose you have a balance of $50,000 in your account. You have two
    ATM cards for the same account. You and your friend go to two different ATMs simultaneously
    to withdraw $40,000\. Both of you swipe cards simultaneously; so, when the ATMs
    check the balance, both will get $50,000\. If you both withdraw $40,000, then
    both machines will look at the initial balance, which is $50,000\. The amount
    to withdraw is less than the balance, hence both machines will give $40,000\.
    Even though your balance was $50,000, you got $80,000, which is dangerous. To
    avoid these scenarios, atomic operations are used when parallel programming, which
    is explained in the next section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这可能会多么危险，考虑ATM现金取款的例子。假设你在账户中有$50,000的余额。你有两张同一账户的ATM卡。你和你的朋友同时去两个不同的ATM取款$40,000。你们同时刷卡；所以，当ATM检查余额时，两个都会得到$50,000。如果你俩都取款$40,000，那么两台机器都会查看初始余额，即$50,000。取款金额小于余额，因此两台机器都会给出$40,000。尽管你的余额是$50,000，但你得到了$80,000，这是危险的。为了避免这些情况，在并行编程中使用原子操作，这将在下一节中解释。
- en: Using atomic operations
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子操作
- en: 'CUDA provides an API called `atomicAdd` operations to avoid problems with parallel
    access of memory locations. It is a blocking operation, which means that when
    multiple threads try to access the same memory location, only one thread can access
    the memory location at a time. Other threads have to wait for this thread to finish
    and write its answer to memory. The kernel function to calculate a histogram using
    an `atomicAdd` operation is shown as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA提供了一个名为`atomicAdd`的API，用于避免并行访问内存位置时的问题。这是一个阻塞操作，这意味着当多个线程尝试访问相同的内存位置时，一次只能有一个线程可以访问该内存位置。其他线程必须等待此线程完成并将答案写入内存。以下是一个使用`atomicAdd`操作计算直方图的内核函数示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The kernel function has three arguments. The first argument is the output array
    in which the histogram will be stored after calculation. The size of this array
    will be 256 for an 8-bit image. The second argument is the flattened array of
    image intensities. The third argument is the size of a flattened array. The memory
    location of the histogram array indexed by pixel intensity at the thread index
    will be incremented for every thread. The number of threads is equal to the size
    of a flattened image array.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数有三个参数。第一个参数是计算后存储直方图输出的输出数组。对于8位图像，这个数组的大小将是256。第二个参数是图像强度的展平数组。第三个参数是展平数组的大小。在线程索引处按像素强度索引的直方图数组的内存位置将为每个线程递增。线程的数量等于展平图像数组的大小。
- en: 'The `atomicAdd` function is used to increment memory location. It takes two
    arguments. The first is the memory location we want to increment, and the second
    is the value by which this location has to be incremented. The `atomicadd` function
    will increase the cost in terms of execution time for histogram calculation. The
    Python code for histogram calculation using atomic operations is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`atomicAdd`函数用于递增内存位置。它接受两个参数。第一个是我们想要递增的内存位置，第二个是这个位置需要递增的值。`atomicadd`函数将增加直方图计算在执行时间上的成本。使用原子操作计算直方图的Python代码如下：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The pointer reference to the kernel function is created using the `get_function()`
    method. The image is read using the OpenCV library. If it is not installed for
    Python, you can execute the following command from the Command Prompt:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get_function()`方法创建指向内核函数的指针引用。图像读取使用OpenCV库。如果Python中没有安装，您可以从命令提示符执行以下命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, `OpenCV` library can be imported from any Python program using the `import
    cv2` command. The image read function is similar to what has been explained earlier
    in this book. The image is read as a grayscale image. The image is stored as a
    `numpy` array in Python. This array is flattened to a vector so that it can be
    operated upon by one-dimensional threads and blocks. It is also possible to work
    on an image with two-dimensional threads without flattening it. The `numpy` library
    provides a `flatten()` method to perform this operation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用`import cv2`命令从任何Python程序中导入`OpenCV`库。图像读取函数与本书前面解释过的类似。图像被读取为灰度图像。在Python中，图像被存储为一个`numpy`数组。这个数组被展平为一个向量，以便它可以被一维线程和块操作。也可以在不展平的情况下使用二维线程处理图像。`numpy`库提供了一个`flatten()`方法来执行此操作。
- en: The total number of blocks and threads are calculated from the size of an image
    and the number of bins for the histogram. The flattened image array, blank histogram
    array, and size of the flattened array are passed as arguments while calling the
    kernel function along with the number of blocks and threads to be launched. The
    kernel function returns the calculated histogram, which can be displayed or plotted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 块和线程的总数是根据图像的大小和直方图的桶数来计算的。在调用核函数时，将展平的图像数组、空直方图数组和展平数组的大小作为参数传递，同时传递要启动的块和线程数。核函数返回计算出的直方图，可以显示或绘制。
- en: 'Python provides a `matplotlib` library that contains a rich set of plotting
    functions. The `stem` function from this library is used to plot a discrete `histogram`
    function. The `xlim` function is used to set limits of the *X* axis. The `title`
    function is used to give a title to the plot. The output of the program is shown
    in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个包含丰富绘图函数的`matplotlib`库。该库中的`stem`函数用于绘制离散的直方图函数。`xlim`函数用于设置X轴的界限。`title`函数用于给图表添加标题。程序的输出如下所示：
- en: '![](img/3d855bba-b5c5-4a11-a2d7-eb592c3d3b82.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d855bba-b5c5-4a11-a2d7-eb592c3d3b82.png)'
- en: If a histogram does not have a uniform distribution of all intensities, then
    it can result in poor contrast images. The contrast can be enhanced by performing
    histogram equalization, which converts this distribution to a uniform one. A histogram
    also conveys information about the brightness of an image. If the histogram is
    concentrated on the left-hand side of the plot, then the image will be too dark
    and if it is concentrated on the right-hand side, then the image will be too bright.
    Again, histogram equalization can be used to correct this issue.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果直方图没有所有强度的均匀分布，则可能导致对比度差的图像。可以通过直方图均衡化来增强对比度，这会将这种分布转换为均匀分布。直方图还传达了关于图像亮度的信息。如果直方图集中在图表的左侧，则图像会太暗；如果集中在右侧，则图像会太亮。再次强调，可以使用直方图均衡化来纠正这个问题。
- en: The kernel function for calculating a histogram can also be developed using
    the concept of shared memory in parallel programming. This is illustrated in the
    following section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 计算直方图的核函数也可以使用并行编程中共享内存的概念来开发。这将在以下部分中说明。
- en: Using shared memory
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享内存
- en: Shared memory is available on-chip on a GPU device, hence it is much faster
    than global memory. Shared memory latency is roughly 100 times lower than uncached
    global memory latency. All the threads from the same block can access shared memory.
    This is very useful in many applications where threads need to share their results
    with other threads. However, it can also create chaos or false results if this
    is not synchronized. If one thread reads data from memory before the other thread
    has written to it, it can lead to false results. So, this memory access should
    be controlled or managed properly. This is done with the `__syncthreads()` directive,
    which ensures that all write operations to memory are completed before moving
    ahead in the programs. This is also called a **barrier**. The meaning of barrier
    is that all threads will reach this line and wait for other threads to finish.
    After all the threads have reached this barrier, they can move further. This section
    will demonstrate how shared memory can be used from a PyCUDA program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存可以在GPU设备上片上使用，因此它比全局内存快得多。共享内存的延迟大约是全球未缓存内存延迟的100倍。来自同一块的线程都可以访问共享内存。这在许多需要线程之间共享结果的场景中非常有用。然而，如果不进行同步，这也可能导致混乱或错误的结果。如果一个线程在另一个线程写入之前从内存中读取数据，可能会导致错误的结果。因此，这种内存访问应该得到适当的控制或管理。这通过`__syncthreads()`指令来完成，它确保在程序继续前进之前，所有对内存的写入操作都已完成。这也被称为**屏障**。屏障的含义是所有线程都将到达这一行并等待其他线程完成。当所有线程都到达这个屏障后，它们可以继续前进。本节将演示如何从PyCUDA程序中使用共享内存。
- en: 'This concept of shared memory can be utilized for calculating the histogram
    of an image. The kernel function is shown as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种共享内存的概念可以用于计算图像的直方图。内核函数如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The number of bins is 256 for an 8-bit image, so we are defining shared memory
    of size equal to the number of threads in a block, which is equal to a number
    of bins. We will calculate a histogram for the current block, so shared memory
    is initialized to zero and the histogram is computed for this block in the same
    way as discussed earlier. But this time, the result is stored in shared memory
    and not in global memory. In this case, only 256 threads are trying to access
    256 memory elements in shared memory instead of all 65,535 elements from the previous
    code. This will help in reducing the overhead time in the atomic operation. The
    final atomic add in the last line will add a histogram of one block to overall
    histogram values. As addition is a cumulative operation, we do not have to worry
    about the order in which each block is executed. The Python code to use this kernel
    function to calculate a histogram is shown as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于8位图像，bins的数量是256，所以我们定义的共享内存大小等于块中的线程数，也就是bins的数量。我们将为当前块计算一个直方图，因此共享内存被初始化为零，并按前面讨论的方式计算该块的直方图。但这次，结果存储在共享内存中而不是全局内存中。在这种情况下，只有256个线程试图访问共享内存中的256个内存元素，而不是之前代码中的所有65,535个元素。这将有助于减少原子操作中的开销时间。最后一行的最终原子加操作将一个块的直方图添加到整体直方图值中。由于加法是一个累积操作，我们不必担心每个块执行的顺序。以下是如何使用此内核函数计算直方图的Python代码示例：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code is almost similar to that in the last section. The only difference
    is in the kernel call. The size of the shared memory should be defined while calling
    the kernel. This can be specified using the shared argument in the kernel call
    function. It is specified as `256*4` because the shared memory has a size of 256
    integer elements, which require 4 bytes of storage each. The same histogram will
    be displayed as shown in the previous section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎与上一节相同。唯一的区别在于内核调用。在调用内核时应该定义共享内存的大小。这可以通过内核调用函数中的共享参数来指定。它被指定为`256*4`，因为共享内存的大小为256个整数元素，每个元素需要4字节存储。与上一节显示的相同直方图将被显示。
- en: 'To check the authenticity of the calculated histogram and compare the performance,
    the histogram is also calculated using the OpenCV inbuilt function, `calcHist`,
    as shown in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查计算出的直方图的准确性并比较性能，还使用OpenCV内置函数`calcHist`计算直方图，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `calcHist` function requires five arguments. The first argument is the
    name of the image variable. The second argument specifies the channels in the
    case of a color image. It is zero for a grayscale image. The third argument specifies
    the mask if you want to calculate the histogram for a particular portion of an
    image. The fourth argument specifies the number of bins, and the fifth argument
    specifies the range of intensity values. OpenCV also provides `getTickCount` and
    `getTickFrequency` functions in Python for calculating the performance of the
    OpenCV code. The performance of the code without shared memory, with shared memory,
    and using the OpenCV function, is shown as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`calcHist` 函数需要五个参数。第一个参数是图像变量的名称。第二个参数在彩色图像的情况下指定通道。对于灰度图像，它为零。第三个参数指定了如果您想计算图像特定部分的直方图，则需要指定掩码。第四个参数指定了箱子的数量，第五个参数指定了强度值的范围。OpenCV
    还在 Python 中提供了 `getTickCount` 和 `getTickFrequency` 函数来计算 OpenCV 代码的性能。没有共享内存、使用共享内存以及使用
    OpenCV 函数的性能如下所示：'
- en: '![](img/134bdb0d-ff13-4ef0-947e-80b4afae24b5.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/134bdb0d-ff13-4ef0-947e-80b4afae24b5.png)'
- en: The time taken by the kernel function without shared memory is 1 ms while, using
    shared memory, it is 0.8 ms, which further proves the point that the use of shared
    memory improves the performance of kernel functions. To summarize, in this section,
    we have seen two different methods of calculating histograms on the GPU. We have
    also seen the concept of atomic operations and shared memory, along with how they
    can be used in PyCUDA.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 没有共享内存的内核函数耗时 1 毫秒，而使用共享内存时为 0.8 毫秒，这进一步证明了使用共享内存可以提高内核函数性能的观点。总结来说，在本节中，我们看到了在
    GPU 上计算直方图的两种不同方法。我们还了解了原子操作和共享内存的概念，以及如何在 PyCUDA 中使用它们。
- en: Basic computer vision operations using PyCUDA
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PyCUDA 的基本计算机视觉操作
- en: This section will demonstrate the use of PyCUDA in developing simple computer
    vision applications. Images in Python are nothing but two- or three-dimensional
    `numpy` arrays, hence working and manipulating images in PyCUDA is similar to
    working with multidimensional arrays. This section will give you a basic idea
    of developing a simple application that you can utilize in developing complex
    computer vision applications using PyCUDA.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示如何使用 PyCUDA 开发简单的计算机视觉应用。在 Python 中，图像不过是二维或三维的 `numpy` 数组，因此在 PyCUDA 中处理和操作图像与处理多维数组类似。本节将为您提供一个基本的概念，帮助您开发一个简单的应用，您可以用它来利用
    PyCUDA 开发复杂的计算机视觉应用。
- en: Color space conversion in PyCUDA
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCUDA 中的颜色空间转换
- en: Most computer vision algorithms work on grayscale images, so there is a need
    for converting a color image captured from a camera to a grayscale image. Though
    OpenCV provides an inbuilt function to do this operation, it can be done by developing
    your own function. This section will demonstrate the method to develop a PyCUDA
    function for converting a color image to a grayscale image. If formulas for converting
    an image from one color space into another are known, then the function shown
    in this section can be written for any color space conversion by just replacing
    formulas.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机视觉算法都处理灰度图像，因此需要将相机捕获的彩色图像转换为灰度图像。尽管 OpenCV 提供了内置函数来完成此操作，但您也可以通过开发自己的函数来实现。本节将演示如何开发一个
    PyCUDA 函数，用于将彩色图像转换为灰度图像。如果已知将图像从一个颜色空间转换为另一个颜色空间的公式，那么本节中显示的函数可以通过替换公式来为任何颜色空间转换编写。
- en: 'OpenCV captures and stores image in BGR format, where blue is the first channel
    followed by green and red. The formula to convert from BGR format to grayscale
    is given as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 以 BGR 格式捕获和存储图像，其中蓝色是第一个通道，接着是绿色和红色。从 BGR 格式转换为灰度的公式如下：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The implementation of this function for an image and video is shown in the following
    two subsections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在图像和视频中的实现将在以下两个子节中展示。
- en: BGR to gray conversion on an image
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像上的 BGR 到灰度转换
- en: 'In this section, we will try to develop the kernel function for converting
    a BGR image into a grayscale image. The kernel function for converting a color
    image into grayscale is shown as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试开发将 BGR 图像转换为灰度图像的内核函数。将彩色图像转换为灰度的内核函数如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A small `INDEX` function is defined to calculate a particular index value for
    a two-dimensional image of 256 x 256 in size. The flattened image arrays of three
    channels of a color image are taken as the input of the kernel function and its
    output is the grayscale image of the same size. The `INDEX` function is used to
    convert the thread index into a particular pixel location in an image. The grayscale
    value at that location is calculated using the function shown. The Python code
    for converting a color image to a grayscale image is shown as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个小的 `INDEX` 函数来计算一个 256 x 256 大小的二维图像的特定索引值。将彩色图像三个通道的展平图像数组作为核函数的输入，其输出是相同大小的灰度图像。`INDEX`
    函数用于将线程索引转换为图像中的特定像素位置。使用所示函数计算该位置的灰度值。以下是将彩色图像转换为灰度图像的 Python 代码示例：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The color image is read using the OpenCV `imread` function. The size of an image
    should be 256 x 256, so if it isn't, then it should be converted into that size
    using the `cv2.resize` function. The color image is stored in BGR format so blue,
    green, and red channels are separated from it using array slicing in Python. These
    arrays are flattened so that they can be passed to a kernel function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 的 `imread` 函数读取彩色图像。图像的大小应为 256 x 256，因此如果不是这个大小，则应使用 `cv2.resize`
    函数将其转换为该大小。彩色图像以 BGR 格式存储，因此使用 Python 的数组切片将其蓝色、绿色和红色通道分离。这些数组被展平，以便可以将它们传递给核函数。
- en: 'The kernel function is called with three color channels as input and an array
    to store the output grayscale image. The kernel function will calculate a grayscale
    value at every pixel location and return a flattened array of a grayscale image.
    This resultant array is converted back to the original image size using the `reshape`
    function from the `numpy` library. The OpenCV `imshow` function needs an unsigned
    integer data type for displaying the image so that an array is also converted
    to the `uint8` data type. The grayscale image is displayed on the screen, as shown
    in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 核函数使用三个颜色通道作为输入和一个用于存储输出灰度图像的数组进行调用。核函数将在每个像素位置计算灰度值，并返回一个灰度图像的展平数组。使用 `numpy`
    库的 `reshape` 函数将此结果数组转换回原始图像大小。OpenCV 的 `imshow` 函数需要无符号整数数据类型来显示图像，因此数组也转换为 `uint8`
    数据类型。灰度图像显示在屏幕上，如下面的截图所示：
- en: '![](img/7458e8e8-add3-465f-b622-0fe1c14c3049.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7458e8e8-add3-465f-b622-0fe1c14c3049.png)'
- en: BGR to gray conversion on a webcam video
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在摄像头视频中执行 BGR 到灰度的转换
- en: 'The same kernel function developed in the last section to convert an image
    into grayscale can be utilized to convert a video captured from a webcam into
    grayscale. The Python code for this is shown as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中开发的将图像转换为灰度的相同核函数可以用来将来自摄像头的视频转换为灰度。以下是其 Python 代码示例：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'OpenCV in Python provides a `VideoCapture` class to capture video from a webcam.
    It requires a camera device index as an argument. It is specified as zero for
    a webcam. Then, a continuous `while` loop is started to capture frames from the
    webcam. The frames are read using the `read` method of a capture object. These
    frames are resized to 256 x 256 using the `resize` function of the `cv2` library.
    These frames are color images, so three channels are separated from them and flattened
    so that they can be passed to a kernel function. The kernel function is called
    in the same way as in the last section, and the result from it is reshaped for
    displaying on the screen. The output of the code for one frame of webcam stream
    is shown as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 OpenCV 提供了一个 `VideoCapture` 类来从摄像头捕获视频。它需要一个相机设备索引作为参数。对于摄像头，它被指定为零。然后，启动一个连续的
    `while` 循环来从摄像头捕获帧。使用捕获对象的 `read` 方法读取这些帧。这些帧使用 `cv2` 库的 `resize` 函数调整大小到 256
    x 256。这些帧是彩色图像，因此从它们中分离出三个通道并展平，以便可以将它们传递给核函数。以与上一节相同的方式调用核函数，并将结果重塑以在屏幕上显示。以下是一帧摄像头流的代码输出：
- en: '![](img/07916faa-c2e1-41c4-8a9a-37e22fff0b5f.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07916faa-c2e1-41c4-8a9a-37e22fff0b5f.png)'
- en: The webcam streaming will continue until the *q* key is pressed on the keyboard.
    To summarize, we have developed a kernel function in PyCUDA to convert a color
    image in BGR format into a grayscale image, which can work on an image as well
    as video. These kernel functions can be modified for other color space conversions
    by replacing equations for the same.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网络摄像头流将一直持续到在键盘上按下 *q* 键。总结一下，我们已经在 PyCUDA 中开发了一个内核函数，用于将 BGR 格式的彩色图像转换为灰度图像，这个函数既可以处理图像也可以处理视频。这些内核函数可以通过替换相同的方程来修改，以用于其他颜色空间的转换。
- en: Image addition in PyCUDA
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCUDA 中的图像加法
- en: 'The addition of two images can be performed when two images are of the same
    size. It performs a pixel-wise addition of two images. Suppose that, in two images,
    the pixel at (0,0) has intensity values of 100 and 150 respectively, then the
    intensity value in the resultant image will be 250, which is the addition of two
    intensity values, as shown in the following equation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个图像大小相同时，可以执行两个图像的加法。它执行两个图像的逐像素加法。假设在两个图像中，(0,0) 像素的强度值分别为 100 和 150，那么结果图像中的强度值将是
    250，这是两个强度值的和，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'OpenCV addition is a saturated operation, which means that if an answer of
    addition goes above 255, then it will be saturated at 255\. So, the same functionality
    is implemented as a PyCUDA kernel function. The code to perform image addition
    is shown as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 加法是一个饱和操作，这意味着如果加法的结果超过 255，则它将被饱和在 255。因此，相同的函数性作为 PyCUDA 内核函数实现。执行图像加法的代码如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The kernel function is similar to the array addition kernel function seen in
    the last chapter. The saturation condition is added to the kernel function, which
    indicates that if pixel intensity goes beyond 255 after addition, then it will
    be saturated at 255\. Two images of the same size are read, flattened, and converted
    into a single precision floating point data type. These flattened images, along
    with their size, are passed as arguments to the kernel function. The result calculated
    by the kernel function is reshaped to the original image size and converted into
    an unsigned integer type for displaying, using the `imshow` function. The result
    is shown in the following screenshot, along with the original images:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数与上一章中看到的数组加法内核函数类似。内核函数中添加了饱和条件，表示如果像素强度在加法后超过 255，则它将被饱和在 255。读取两个大小相同的图像，展平，并转换为单精度浮点数据类型。这些展平的图像及其大小作为参数传递给内核函数。内核函数计算的结果被重塑为原始图像大小，并使用
    `imshow` 函数转换为无符号整型以显示。结果如下面的截图所示，包括原始图像：
- en: '![](img/d61c8000-e347-4ead-a9fe-31422c27b7f0.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d61c8000-e347-4ead-a9fe-31422c27b7f0.png)'
- en: The same kernel functions can be used for other arithmetic and logical operations
    with minor modifications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的内核函数经过轻微修改后，可以用于其他算术和逻辑运算。
- en: Image inversion in PyCUDA using gpuarray
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 gpuarray 在 PyCUDA 中进行图像反转
- en: 'Apart from arithmetic operations, the `NOT` operation is also widely used for
    inverting an image where black is converted into white and white is converted
    into black. It can be represented by the following equation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术运算外，`NOT` 运算也广泛用于图像反转，其中黑色转换为白色，白色转换为黑色。它可以表示为以下方程：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding equation, 255 indicates the maximum intensity value for an
    8-bit image. The `gpuarray` class provided by PyCUDA is used to develop a program
    for image inversion, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，255 表示 8 位图像的最大强度值。PyCUDA 提供的 `gpuarray` 类用于开发图像反转程序，如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The image is read as a grayscale image, flattened and converted into a single
    precision floating point data type for further processing. It is uploaded to the
    GPU using the `to_gpu` method of a `gpuarray` class. The inversion is performed
    on the GPU using the preceding equation and the result is downloaded back to the
    host using the `get()` method. The result is displayed on the screen by reshaping
    it to the original image size, as shown in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图像被读取为灰度图像，展平并转换为单精度浮点数据类型以进行进一步处理。它使用 `gpuarray` 类的 `to_gpu` 方法上传到 GPU。使用前面的方程在
    GPU 上执行反转，然后使用 `get()` 方法将结果下载回主机。结果通过重塑为原始图像大小显示在屏幕上，如下面的截图所示：
- en: '![](img/63d9d72c-1604-4e0f-bedc-b08461c13072.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63d9d72c-1604-4e0f-bedc-b08461c13072.png)'
- en: To summarize, this section demonstrated the use of PyCUDA in developing basic
    computer vision operations, such as color space conversions, image addition, and
    image inversion. This concept can be used to develop complex computer vision applications
    using PyCUDA.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总结，本节展示了PyCUDA在开发基本计算机视觉操作中的应用，如颜色空间转换、图像加法和图像反转。这个概念可以用于使用PyCUDA开发复杂的计算机视觉应用。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter described the use of PyCUDA in the development of simple computer
    vision applications. It described the use of PyCUDA in calculating the histogram
    of an array. The histogram is a very important statistical global feature of an
    image that can be used to find out important information about it. The concept
    of atomic operations and shared memory was explained in detail, using histogram
    calculation as an example. Images in Python are stored as `numpy` arrays, so manipulating
    images in PyCUDA is similar to modifying multidimensional `numpy` arrays. This
    chapter described the use of PyCUDA in various basic computer vision applications,
    such as image addition, image inversion, and color space conversion. The concepts
    described in this chapter can be utilized for developing complex computer vision
    applications using PyCUDA.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了在开发简单的计算机视觉应用中使用PyCUDA。它描述了使用PyCUDA计算数组直方图的过程。直方图是图像的一个非常重要的统计全局特征，可以用来获取关于图像的重要信息。本章以直方图计算为例，详细解释了原子操作和共享内存的概念。Python中的图像存储为`numpy`数组，因此在PyCUDA中操作图像类似于修改多维`numpy`数组。本章描述了PyCUDA在多种基本计算机视觉应用中的使用，例如图像加法、图像反转和颜色空间转换。本章中描述的概念可以用于使用PyCUDA开发复杂的计算机视觉应用。
- en: This chapter also marks an end to this book, which described the use of CUDA
    programming and GPU hardware in accelerating computer vision applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也标志着本书的结束，本书描述了使用CUDA编程和GPU硬件加速计算机视觉应用。
- en: Questions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'State true or false: The use of the `d_out[i]++` line instead of the `atomicadd`
    operation will yield an accurate result in histogram calculation.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：使用`d_out[i]++`行而不是`atomicadd`操作将在直方图计算中产生准确的结果。
- en: What is the advantage of using shared memory with atomic operations?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原子操作共享内存的优势是什么？
- en: What is the modification in the kernel call function when shared memory is used
    in the kernel?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在内核中使用共享内存时，内核调用函数中的修改是什么？
- en: Which information can be obtained by calculating the histogram of an image?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算图像的直方图可以获得哪些信息？
- en: 'State true or false: The kernel function developed in this chapter for BGR
    into grayscale conversion will also work for RGB into grayscale conversion.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：本章开发的将BGR转换为灰度的内核函数也将适用于RGB转换为灰度。
- en: Why is the image flattened in all of the examples shown in this chapter? Is
    it a compulsory step?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么本章中展示的所有示例都将图像展平？这是一个强制性的步骤吗？
- en: Why is the image converted into the `uint8` data type from the `numpy` library
    before being displayed?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在显示之前将图像从`numpy`库的`uint8`数据类型转换？
