- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Analyzing Acoustic Signals to Predict the Next Simulated Earthquake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析声学信号以预测下一次模拟地震
- en: In the previous chapters, we explored basic table-formatted data, covering categories
    like categorical, ordinal, and numerical data, as well as text, geographical coordinates,
    and imagery. The current chapter shifts our focus to a different data category,
    specifically, simulated or experimental signal data. This data type often appears
    in a range of formats beyond the standard CSV file format.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了基本的表格格式数据，包括分类、有序和数值数据，以及文本、地理坐标和图像。当前章节将我们的关注点转向不同的数据类别，特别是模拟或实验信号数据。这种数据类型通常以多种格式出现，而不仅仅是标准的CSV文件格式。
- en: 'Our primary case study will be data from the *LANL Earthquake Prediction* Kaggle
    competition (see *Reference 1*). I contributed to this competition with a widely
    recognized and frequently forked notebook titled *LANL Earthquake EDA and Prediction*
    (see *Reference* *2*), which will serve as the foundational resource for this
    chapter’s principal notebook. We’ll then delve into feature engineering, employing
    a variety of signal analysis techniques vital for developing a predictive model
    for the competition. Our goal will be to construct an initial model that predicts
    the competition’s target variable: the time until failure, which is the remaining
    time before the next simulated lab earthquake.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要案例研究将是*LANL地震预测* Kaggle竞赛的数据（参见*参考文献1*）。我为此竞赛贡献了一个广为人知且经常被分叉的笔记本，名为*LANL地震EDA和预测*（参见*参考文献*
    *2*），它将作为本章主要笔记本的基础资源。然后我们将深入研究特征工程，采用各种对开发竞赛预测模型至关重要的信号分析技术。我们的目标是构建一个初始模型，该模型可以预测竞赛的目标变量：故障时间，即下一次模拟实验室地震前的剩余时间。
- en: The research in the domain of earthquake prediction has shown that before earthquakes,
    the movement of the tectonic plates generates signals in a low-frequency acoustic
    spectrum. By studying these signals, researchers try to understand the relationship
    between the signal’s profile and the moment when the failure (that is, the earthquake)
    occurs. In a laboratory, the sliding and shearing of tectonic plates are simulated.
    This competition uses the laboratory measurement data, including the acoustic
    signals, as well as the time when failures occur.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在地震预测领域的的研究表明，在地震发生之前，板块的运动会在低频声学频谱中产生信号。通过研究这些信号，研究人员试图理解信号的轮廓与故障（即地震）发生时刻之间的关系。在实验室中，模拟板块的滑动和剪切。这个竞赛使用实验室测量数据，包括声学信号以及故障发生的时间。
- en: 'To sum up, this chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章将涵盖以下主题：
- en: Data formats used for various signal data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于各种信号数据的数据格式
- en: Exploration of the *LANL Earthquake Prediction* Kaggle competition data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索*LANL地震预测* Kaggle竞赛数据
- en: Feature engineering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征工程
- en: Training the model for the competition *LANL Earthquake Prediction*
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练*LANL地震预测*竞赛的模型
- en: Introducing the LANL Earthquake Prediction competition
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍LANL地震预测竞赛
- en: The *LANL Earthquake Prediction* competition centers on utilizing seismic signals
    to determine the precise timing of a laboratory-induced earthquake. Currently,
    predicting natural earthquakes remains beyond the reach of our scientific knowledge
    and technological capabilities. The ideal scenario for scientists is to predict
    the timing, location, and magnitude of such an event.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*LANL地震预测*竞赛的核心是利用地震信号来确定实验室诱导地震的确切时间。目前，预测自然地震仍然超出了我们的科学知识和技术能力。科学家理想的情景是预测此类事件的时间、地点和震级。'
- en: 'Simulated earthquakes, however, created in highly controlled artificial environments,
    mimic real-world seismic activities. These simulations enable attempts to forecast
    lab-generated quakes using the same types of signals observed in natural settings.
    In this competition, participants use an acoustic data input signal to estimate
    the time until the next artificial earthquake occurs, as detailed in *Reference
    3*. The challenge is to predict the timing of the earthquake, addressing one of
    the three critical unknowns in earthquake forecasting: when it will happen, where
    it will occur, and how powerful it will be.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在高度控制的模拟环境中创造的模拟地震，模仿了真实的地震活动。这些模拟允许使用在自然环境中观察到的相同类型的信号来预测实验室生成的地震。在这场比赛中，参与者使用声学数据输入信号来估计下一次人工地震发生的时间，如*参考文献
    3*中详细说明。挑战在于预测地震的时间，解决地震预测中的三个关键未知因素之一：它将在何时发生，将在哪里发生，以及它将有多强大。
- en: 'The training data is a single file with two columns: acoustic signal amplitude
    and time to failure. The test data consists of multiple files (2,526 in total)
    with acoustic signal amplitude segments for which we will have to predict the
    time to failure. A sample submission file has one column with the segment ID,
    `seg_id`, and the value to predict: `time_to_failure`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 训练数据是一个包含两列的单个文件：声学信号幅度和时间至失效。测试数据由多个文件组成（总共2,526个），包含声学信号幅度段，我们将需要预测每个段的时间至失效。一个样本提交文件包含一个列，即段ID
    `seg_id` 和要预测的值：`time_to_failure`。
- en: The competitors are tasked with training their models with the acoustic signal
    and time-to-failure data in the training file and predicting the time-to-failure
    for each segment from each file in the test folder. This competition data is in
    a very convenient format, that is, **comma-separated values** (**CSV**) format,
    but this is not a requirement. Other competitions or datasets on Kaggle with signal
    data use different, less common formats. Because this chapter is about analyzing
    signal data, this is the right place to review this format. Let’s first look into
    some of these formats.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 竞赛者需要使用训练文件中的声学信号和时间至失效数据来训练他们的模型，并预测测试文件夹中每个文件的每个段的时间至失效。这些竞赛数据格式非常方便，即**逗号分隔值**（**CSV**）格式，但这不是必需的。Kaggle上其他带有信号数据的竞赛或数据集使用不同的、不太常见的格式。因为本章是关于分析信号数据的，所以这里是回顾这种格式的正确位置。让我们首先了解一下这些格式中的一些。
- en: Formats for signal data
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号数据的格式
- en: Several competitions on Kaggle used sound data as an addition to regular tabular
    features. There were three competitions organized by Cornell Lab of Ornithology’s
    BirdCLEF (LifeCLEF Bird Recognition Challenge) in 2021, 2022, and 2023 for predicting
    a bird species from samples of bird songs (see *Reference 4* for an example of
    one of these competitions). The format used in these competitions was `.ogg`.
    The `.ogg` format is used to store audio data with less bandwidth. It is considered
    technically superior to the `.mp3` format.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kaggle上举办的几场比赛使用了声音数据作为常规表格特征的补充。2021年、2022年和2023年，康奈尔鸟类实验室的BirdCLEF（LifeCLEF鸟类识别挑战）组织了三场比赛，用于从鸟鸣样本中预测鸟种（参见*参考文献
    4*以了解这些比赛中的一个示例）。这些比赛使用的格式是`.ogg`。`.ogg`格式用于以更少的带宽存储音频数据，技术上被认为优于`.mp3`格式。
- en: 'We can read these types of file formats using the `librosa` library (see *Reference
    5*). The following code can be used to load an `.ogg` file and display the sound
    wave:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`librosa`库（参见*参考文献 5*）读取这些类型的文件格式。以下代码可以用来加载一个`.ogg`文件并显示声音波形：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The library `librosa`, when loading the audio sound, will return values as a
    time series with floating-point values (see *Reference 6*). It isn’t just the
    `.ogg` format that is supported; it will work with any code supported by soundfile
    or Audioread. The default sampling rate is 22050 but this can be also set upon
    load, using the parameter *sr*. Other parameters that can be used when loading
    an audio wave are the offset and the duration (both given in seconds – together,
    they allow you to select the time interval of the sound wave you will load).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当`librosa`库加载音频声音时，将返回一个时间序列，包含浮点数值（参见*参考文献 6*）。它不仅支持`.ogg`格式；它还可以与soundfile或Audioread支持的任何代码一起工作。默认采样率为22050，但也可以在加载时设置，使用参数*sr*。在加载音频波形时还可以使用的其他参数是偏移量和持续时间（两者都以秒为单位
    - 一起，它们允许您选择要加载的声音波形的时问间隔）。
- en: In an earlier version of the BirdCLEF competition, *Cornell Birdcall Identification*
    (see *Reference 7*), audio sounds in the dataset were given in `.mp3` format.
    For this format, we can use librosa to load, transform, or visualize the sound
    waves. **Waveform Audio File** format (or **WAV**), another frequently used format,
    can also be loaded using librosa.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在BirdCLEF竞赛的早期版本中，*康奈尔鸟鸣识别*（见*参考文献7*），数据集中的音频声音以`.mp3`格式给出。对于这种格式，我们可以使用librosa来加载、转换或可视化声音波。**波形音频文件**格式（或**WAV**），另一种常用格式，也可以使用librosa加载。
- en: 'For `.wav` format, we can alternatively use the `scipy.io` module `wavfile`
    to load data. The following code will load and display a file in `.wav` format.
    In this case, the amplitude is not scaled down to a -1:1 interval (the maximum
    value is 32K):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`.wav`格式，我们可以使用`scipy.io`模块的`wavfile`来加载数据。以下代码将加载并显示一个`.wav`格式的文件。在这种情况下，振幅没有缩放到-1:1的区间（最大值为32K）：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Signal, not specifically audio signal, data can also be stored in `.npy` or
    `.npz` format, which are both `numpy` formats to store array data. These formats
    can be loaded using `numpy` functions, as you can see in the following code snippets.
    For `npy` format, this will load a multi-column array:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 信号，不仅仅是音频信号，也可以存储在`.npy`或`.npz`格式中，这两种格式都是`numpy`格式，用于存储数组数据。这些格式可以使用`numpy`函数加载，如下面的代码片段所示。对于`.npy`格式，这将加载一个多列数组：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For `.npz` format, the following code will load a similar structure, previously
    compressed (one file only):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`.npz`格式，以下代码将加载一个类似的结构，之前已压缩（只有一个文件）：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For data stored in `.rds` format, an R-specific format for saving data, we
    can load the data using the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储在`.rds`格式中的数据，这是一种用于保存数据的R特定格式，我们可以使用以下代码加载数据：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For more details, you can consult *Reference 9*. For now, let’s get back to
    our competition data, which is in CSV format, although it represents an audio
    signal (sound waves), as we already clarified.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请参阅*参考文献9*。现在，让我们回到我们的竞赛数据，它以CSV格式存储，尽管它代表音频信号（声波），正如我们之前所阐明的。
- en: Exploring our competition data
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索我们的竞赛数据
- en: 'The `LANL Earthquake Prediction` dataset consists of the following data:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`LANL 地震预测`数据集包含以下数据：'
- en: 'A `train.csv` file, with two columns only:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个只有两列的`train.csv`文件：
- en: '`acoustic_data`: This is the amplitude of the acoustic signal.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acoustic_data`: 这是声学信号的振幅。'
- en: '`time_to_failure`: This is the time to failure corresponding to the current
    data segment.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time_to_failure`: 这是指当前数据段对应的故障时间。'
- en: A test folder with 2,624 files with small segments of acoustic data.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含2,624个文件的小段声学数据的测试文件夹。
- en: A `sample_submission.csv` file; for each test file, those competing will need
    to give an estimate for time to failure.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`sample_submission.csv`文件；对于每个测试文件，参赛者需要提供一个故障时间的估计。
- en: 'The training data (9.56 GB) contains 692 million rows. The actual time constant
    for the samples in the training data results from the continuous variation of
    `time_to_failure` values. The acoustic data is integer values, from -5,515 to
    5,444, with an average of 4.52 and a standard deviation of 10.7 (values oscillating
    around 0). The `time_to_failure` values are real numbers, ranging from 0 to 16,
    with a mean of 5.68 and a standard deviation of 3.67\. To reduce the memory footprint
    for the training data, we read the data with a reduced dimension for both acoustic
    data and `time_to_failure`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 训练数据（9.56 GB）包含6.92亿行。训练数据中样本的实际时间常数是由`time_to_failure`值的连续变化引起的。声学数据是整数，从-5,515到5,444，平均值为4.52，标准差为10.7（值在0附近波动）。`time_to_failure`值是实数，范围从0到16，平均值为5.68，标准差为3.67。为了减少训练数据的内存占用，我们以减少的维度读取声学数据和`time_to_failure`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s check the first values in the `training` data. We will not use all the
    `time_to_failure` data (only values associated with the end-of-time interval for
    which we will aggregate interval acoustic data); therefore, rounding in order
    to reduce the size of the time to failure from double to float is not important
    here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`training`数据中的第一个值。我们不会使用所有的`time_to_failure`数据（只有与时间间隔结束相关的值，我们将对这些值进行聚合以获取声学数据）；因此，将时间到故障的大小从双精度浮点数缩小到浮点数不是很重要：
- en: '![A screenshot of a computer  Description automatically generated](img/B20963_08_01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B20963_08_01.png)'
- en: Figure 8.1\. First rows of data in the training data
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1\. 训练数据中的第一行数据
- en: 'Let’s visualize, on the same graph, the acoustic signal values and the time
    to failure. We will use a subsampling rate of 1/100 (sample each 100^(th) row)
    to represent the full training data (see *Figure 8.2*). We will use the following
    code to represent these graphs:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在同一张图上可视化声音信号值和故障时间。我们将使用1/100的子采样率（每100行取一个样本）来表示完整训练数据（参见*图8.2*）。我们将使用以下代码来表示这些图表：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![A graph with red and blue lines  Description automatically generated](img/B20963_08_02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![带有红色和蓝色线的图表  自动生成描述](img/B20963_08_02.png)'
- en: Figure 8.2\. Acoustic signal data and time to failure data over an entire training
    set, subsampled at 1/100
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2\. 整个训练集的声音信号数据和故障时间数据，以1/100的比例进行子采样
- en: Let’s zoom into the first part of the time interval. We will show the first
    1% of the data (no subsampling). In *Figure 8.3*, we are showing, on the same
    graph, the acoustic signal and time to failure for the first 6.29 million rows
    of data. We can observe that before the failure (but not very close in time),
    there is a large oscillation, with both negative and positive peaks. This oscillation
    is also preceded by a few smaller ones, at irregular time intervals.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们放大时间间隔的第一部分。我们将展示前1%的数据（不进行子采样）。在*图8.3*中，我们在同一张图上展示了前6.29百万行数据的声音信号和故障时间。我们可以观察到在故障前（但时间上不是非常接近），有一个大的振荡，既有负峰也有正峰。这个振荡还由几个较小的不规则振荡在非规则的时间间隔前导。
- en: '![A graph with red lines and blue lines  Description automatically generated](img/B20963_08_03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![带有红色和蓝色线的图表  自动生成描述](img/B20963_08_03.png)'
- en: 'Figure 8.3: Acoustic signal data and time to failure data for the first 1%
    of the data'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：数据前1%的声音信号数据和故障时间数据
- en: Let’s also look at the next 1% of the training data (without subsampling). In
    *Figure 8.4*, we show this time series for acoustic signal values and time to
    failure. There is no failure during this time interval. We observe many irregular
    small oscillations, with both negative and positive peaks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看训练数据的下一个1%（不进行子采样）。在*图8.4*中，我们展示了声音信号值和故障时间的时序图。在这个时间间隔内没有发生故障。我们观察到许多不规则的小振荡，既有负峰也有正峰。
- en: '![A graph with red lines  Description automatically generated](img/B20963_08_04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![带有红色线的图表  自动生成描述](img/B20963_08_04.png)'
- en: 'Figure 8.4: Acoustic signal data and time to failure for the second 1% of the
    data in the training set'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：训练集中第2%的数据的声音信号数据和故障时间
- en: 'Let’s also look at the last few percentages of the data (last 5% of time) in
    the training set. In *Figure 8.5*, we observe the same pattern of several larger
    oscillations superposed on smaller irregular oscillations, and with a major oscillation
    just before the failure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看训练集中数据的最后几个百分比（最后5%的时间）在训练集中。在*图8.5*中，我们观察到几个较大的振荡叠加在较小的不规则振荡上，并且在故障前有一个主要振荡：
- en: '![A graph with red and blue lines  Description automatically generated](img/B20963_08_05.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![带有红色和蓝色线的图表  自动生成描述](img/B20963_08_05.png)'
- en: 'Figure 8.5: Acoustic signal data and time to failure for the last 5% of the
    data in the training set'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：训练集中最后5%的数据的声音信号数据和故障时间
- en: 'Let’s now also look at a few examples of variations of the acoustic signal
    in the test data samples. There are 2,624 data segment files in the test data.
    We will select a few of them to visualize. We will use a modified visualization
    function since in the test data, we only have the acoustic signals:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也看看测试数据样本中声音信号变化的一些例子。测试数据中有2,624个数据段文件。我们将从中选择一些进行可视化。由于测试数据中我们只有声音信号，我们将使用修改后的可视化函数：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In *Figure 8.6*, we are showing the acoustic signal graph for the segment **seg_00030f**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.6*中，我们展示了**seg_00030f**段的声音信号图：
- en: '![A graph showing a red line  Description automatically generated](img/B20963_08_06.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![显示红色线的图表  自动生成描述](img/B20963_08_06.png)'
- en: 'Figure 8.6: Acoustic signal data for test segment seg_00030f'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：测试段seg_00030f的声音信号数据
- en: 'In the next figure, we are showing the acoustic signal graph for segment **seg_0012b5**:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一张图中，我们展示了**seg_0012b5**段的声音信号图：
- en: '![A graph showing a red line  Description automatically generated](img/B20963_08_07.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![显示红色线的图表  自动生成描述](img/B20963_08_07.png)'
- en: 'Figure 8.7: Acoustic signal data for test segment seg_0012b5'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：测试段seg_0012b5的声音信号数据
- en: In the notebooks associated with this chapter, you can see more examples of
    such test acoustic signals. The test segments show quite a large variety of signal
    profiles, depicting the same sequence of small oscillations with intercalated
    peaks with variable amplitude, similar to what we can see in the `training` data
    subsampled earlier.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在与本章相关的笔记本中，您可以查看更多此类测试声学信号的示例。测试段显示了相当大的信号波形多样性，描述了相同的小振荡序列，其中穿插着不同振幅的峰值，类似于我们在之前下采样的`训练`数据中可以看到的。
- en: Solution approach
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案方法
- en: 'The task in the competition is to accurately forecast a singular `time_to_failure`
    value for each segment in the test dataset. Each segment of the `test` set comprises
    150,000 data rows. In contrast, the `training` dataset is vast, encompassing 692
    million rows, with one column dedicated to our target variable: the time until
    failure. We plan to divide the training data into uniform segments, each containing
    150,000 rows, and use the final time-to-failure value from each segment as the
    target variable for that segment. This approach is designed to align the training
    data with the format of the test data, facilitating more effective model training.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 竞赛中的任务是准确预测测试数据集中每个段落的单一`time_to_failure`值。`test`集的每个段由150,000个数据行组成。相比之下，`training`数据集非常庞大，包含6.92亿行，其中一列专门用于我们的目标变量：失效时间。我们计划将训练数据分成均匀的段，每个段包含150,000行，并使用每个段的最终失效时间值作为该段的目标变量。这种方法旨在使训练数据与测试数据的格式相匹配，从而促进更有效的模型训练。
- en: Additionally, we will engineer new features by aggregating values across both
    the training and test datasets, resulting in a single row that encapsulates multiple
    features for each data segment. The subsequent section will delve into the signal
    processing techniques employed for feature generation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将通过聚合训练和测试数据集中的值来构建新的特征，从而得到一个包含每个数据段多个特征的单一行。下一节将深入探讨用于特征生成的信号处理技术。
- en: Feature engineering
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征工程
- en: We will use several libraries specific to signal processing to generate most
    of the features. From SciPy (Python scientific library), we are using a few functions
    from the `signal` module. The Hann function returns a Hann window, which modifies
    the signal to smooth the values at the end of the sampled signal to 0 (uses a
    cosine “bell” function). The Hilbert function computes the analytic signal, using
    the `Hilbert` transform. The Hilbert transform is a mathematical technique used
    in signal processing, with a property that shifts the phase of the original signal
    by 90 degrees.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用几个特定于信号处理的库来生成大多数特征。从SciPy（Python科学库）中，我们使用了`signal`模块的一些函数。Hann函数返回一个Hann窗口，它修改信号以平滑采样信号末尾的值到0（使用余弦“钟形”函数）。Hilbert函数通过`Hilbert`变换计算解析信号。Hilbert变换是信号处理中使用的数学技术，具有将原始信号的相位移动90度的特性。
- en: 'Other library functions used are from `numpy`: Fast Fourier Transform (FFT),
    `mean`, `min`, `max`, `std` (standard deviation), `abs` (absolute value), `diff`
    (the difference between two successive values in the signal), and `quantile` (where
    a sample is divided into equal-sized, adjacent groups). We are also using a few
    statistical functions that are available from `pandas`: `mad` (median absolute
    deviation), `kurtosis`, `skew`, and `median`. We are implementing functions to
    calculate trend features and classic STA/LTA. Classic STA/LTA represents the ratio
    between the amplitude of the signal of a short time window of length STA and a
    long time window, LTA. Let’s dive in!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其他使用的库函数来自`numpy`：快速傅里叶变换（FFT）、`mean`、`min`、`max`、`std`（标准差）、`abs`（绝对值）、`diff`（信号中两个连续值之间的差值）和`quantile`（将样本分为相等大小、相邻的组）。我们还使用了一些来自`pandas`的统计函数：`mad`（中值绝对偏差）、`kurtosis`、`skew`和`median`。我们正在实现计算趋势特征和经典STA/LTA的函数。经典STA/LTA表示STA长度短时间窗口信号振幅与长时间窗口LTA的比率。让我们深入探讨吧！
- en: Trend feature and classic STA/LTA
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 趋势特征和经典STA/LTA
- en: We start by defining two functions, for the calculation of a trend feature and
    classic **Short-Term Average**/**Long-Term Average** (**STA**/**LTA**). STA/LTA
    is a seismic signal analysis technique used in seismology. It measures the ratio
    of short-term to long-term signal averages. It is useful in earthquake detection
    as it identifies distinct patterns in seismic data. Therefore, it will also be
    a useful feature to include in our model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义两个函数，用于计算趋势特征和经典的**短期平均**/**长期平均**（**STA**/**LTA**）。STA/LTA是地震信号分析技术，在地震学中应用。它测量短期信号平均值与长期信号平均值的比率。在地震检测中很有用，因为它可以识别地震数据中的独特模式。因此，它也将是我们模型中一个有用的特征。
- en: 'We show here the code to calculate the trend feature. This is calculated using
    a linear regression model (for 1D data) and retrieves the slope of the resulting
    regression line. We use the option to transform all the sampled data into positive
    values before performing regression (that is, calculating the slope/trend for
    the absolute values of the data). The trend data contains important information
    about the overall signal:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此处展示了计算趋势特征的代码。这是使用线性回归模型（用于1D数据）来检索结果回归线的斜率。我们在进行回归（即计算数据的绝对值的斜率/趋势）之前将所有采样数据转换为正值。趋势数据包含有关整体信号的重要信息：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we calculate the classic STA/LTA, which represents the ratio between
    the amplitude of the signal of a short time window of length `STA` and a long
    time window, `LTA`. The function receives as parameters the signal and the length
    for the short-time average and long-time average windows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算经典的STA/LTA，它表示长度为`STA`的短时间窗口信号幅度与长时间窗口`LTA`的比值。该函数接收信号和短时间平均窗口以及长时间平均窗口的长度作为参数：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we implement the function to calculate features, which receives as parameters
    the sample index, the data subsample, and a handle to the transformed training
    data. This function will use various signal processing algorithms to build aggregated
    features from the time variation acoustic signal per segment. In the case of the
    training data, we use windows of 150K rows from the training set (without stride).
    In the case of the test set, each test file represents a segment of 150K. In the
    following subsections, we will review the engineered features that will be included
    in the model.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现一个计算特征的功能，该功能接收样本索引、数据子样本和转换后的训练数据句柄作为参数。此功能将使用各种信号处理算法从每个段的时间变化声学信号中构建聚合特征。在训练数据的情况下，我们使用训练集的150K行窗口（没有步长）。在测试集的情况下，每个测试文件代表150K的段。在以下小节中，我们将回顾将包含在模型中的工程特征。
- en: FFT-derived features
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 由FFT派生的特征
- en: One of the features of the model is the **Fast Fourier Transform** (**FFT**)
    applied to the entire segment; this is not directly used as a feature but as a
    basis for the calculation of multiple aggregation functions (see next subsection).
    The FFT is calculated using a fast implementation of the discrete Fourier transform.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的特征之一是对整个段应用**快速傅里叶变换**（**FFT**）；这并不是直接用作特征，而是作为计算多个聚合函数的基础（参见下一小节）。FFT使用快速实现的离散傅里叶变换来计算。
- en: 'We are using `numpy` implementations for **FFT** for one-dimensional arrays
    (`fft.fft`), which is extremely fast, `numpy` being based on **BLAS** (**Basic
    Linear Algebra Subprograms**) and **Lapack** (**Linear Algebra PACkage**), two
    libraries that provide routines for performing basic vector and matrix operations
    and solving linear algebra equations. The output of the function used here is
    a one-dimensional array of complex values. Then, we extract the vectors of real
    and imaginary parts from the array of complex values, and we calculate the following
    features:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`numpy`实现的一维数组**FFT**（`fft.fft`），这非常快，因为`numpy`基于**BLAS**（**基本线性代数子程序**）和**Lapack**（**线性代数包**），这两个库提供了执行基本向量和矩阵操作以及求解线性代数方程的程序。这里使用的函数的输出是一个复数值的一维数组。然后，我们从复数值数组中提取实部和虚部的向量，并计算以下特征：
- en: Extract real and imaginary parts of the FFT; this is the first part of further
    processing the Fourier fast transform of the acoustic signal.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取FFT的实部和虚部；这是进一步处理声学信号快速傅里叶变换的第一步。
- en: Calculate the mean, standard deviation, min, and max for both the real and imaginary
    parts of the FFT. From the previous transformation, which separates the real and
    imaginary parts of the FFT, we then calculate these aggregate functions.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算FFT的实部和虚部的平均值、标准差、最小值和最大值。从之前的变换中，该变换将FFT的实部和虚部分开，然后我们计算这些聚合函数。
- en: Calculate the mean, standard deviation, min and max for both the real and imaginary
    parts of the FFT for 5K and 15K data points from the end of the FFT vector.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算FFT向量末尾5K和15K数据点的FFT的实部和虚部的平均值、标准差、最小值和最大值。
- en: 'The code to create the file segment as well as the FFT and FFT-derived features
    is given here. First, we calculate the FFT for the subset of the acoustic data.
    Then, we calculate the real and imaginary parts of the FFT. From the real FFT
    component, we calculate, using pandas’ aggregated functions, the mean, standard
    deviation, max, and min values. We then calculate similar values from the imaginary
    part of the FFT signal:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件段以及FFT和由FFT派生的特征的代码如下。首先，我们计算声学数据子集的FFT。然后，我们计算FFT的实部和虚部。从实FFT分量中，我们使用pandas的聚合函数计算平均值、标准差、最大值和最小值。然后，我们从FFT信号的虚部计算类似值：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We then follow with calculating features derived from various aggregated functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着计算由各种聚合函数派生的特征。
- en: Features derived from aggregate functions
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 由聚合函数派生的特征
- en: 'The mean, standard deviation, max, and min applied to the entire segment are
    calculated with the following code, using pandas’ aggregate functions `mean`,
    `std`, `max`, and `min`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pandas的聚合函数`mean`、`std`、`max`和`min`计算整个段落的平均值、标准差、最大值和最小值的代码如下：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We continue to compute additional aggregated features. For our model, we will
    include various signal processing techniques, as you’ll notice, and then, by measuring
    the feature importance after we train our baseline model, we will qualify which
    features contribute more to our model prediction.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续计算额外的聚合特征。对于我们的模型，我们将包括各种信号处理技术，正如您将注意到的，然后，在训练我们的基线模型后，通过测量特征重要性，我们将确定哪些特征对我们的模型预测贡献更大。
- en: 'Moving on, we calculate the mean change for the entire segment; here, “segment”
    refers to the original subset of acoustic data. `change` is calculated with the
    `numpy` function `diff` and the parameter `1`. This function receives an array
    of values and calculates the difference between each successive value in the array.
    Then we calculate the average of the values in the array of differences. We also
    calculate the mean change rate for the entire acoustic data segment. This is calculated
    as the average of non-zero values in the new change vector divided by the original
    values in the data segment. The code for these features is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算整个段落的平均变化量；这里的“段落”指的是原始的声学数据子集。“变化”是通过`numpy`函数`diff`和参数`1`计算的。此函数接收一个值数组，并计算数组中每个连续值之间的差异。然后我们计算差异值数组的平均值。我们还计算整个声学数据段的变化率的平均值。这是通过将新变化向量中的非零值的平均值除以数据段中的原始值来计算的。这些特征的代码如下：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Additionally, we also calculate the maximum and minimum of the absolute values
    (per entire segment). After calculating the absolute values, we calculate the
    minimum and maximum values.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还计算每个整个段落的绝对值（最大值和最小值）。在计算绝对值之后，我们再计算最小值和最大值。
- en: 'We are trying to include a diverse range of features, to capture as much of
    the signal patterns as possible, when we aggregate the temporal signal. The code
    for this is:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们聚合时间信号时，我们试图包括一个多样化的特征范围，以尽可能多地捕捉信号模式。这个代码如下：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A set of aggregated functions on the first and last 10K and 50K values per
    acoustic data segment can also be calculated, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以计算每个声学数据段前10K、50K和最后10K值的聚合函数集，如下所示：
- en: Standard deviation for first 50K and last 10K values per acoustic data segment
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个声学数据段前50K和最后10K值的平均值
- en: Average value for first 50K and last 10K values per acoustic data segment
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个声学数据段前50K和最后10K值的平均值
- en: Minimum values for first 50K and last 10K values per acoustic data segment
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个声学数据段前50K和最后10K值的最小值
- en: Maximum values for first 50K and last 10K values per acoustic data segment
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个声学数据段前50K和最后10K值的最大值
- en: 'These features are aggregating a smaller part of the signal and therefore will
    capture signal characteristics from only a smaller interval before the failure.
    The combination of aggregated features on the whole signal length and on a smaller
    part of the signal will add more information about the signal. The code for these
    features will be:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征正在聚合信号的一部分较小部分，因此它们将只从故障前更小的时间间隔中捕获信号特征。在整个信号长度和信号较小部分上的聚合特征组合将增加更多关于信号的信息。这些特征的代码如下：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we include the ratio of maximum to minimum values for the entire acoustic
    data segment and the difference between the maximum and minimum values for the
    entire acoustic data segment. We also add the number of values exceeding a certain
    amplitude of oscillation (above 500 units) and the sum of values per entire segment.
    We try to capture some of the hidden patterns in the signal using this diversity
    of features we engineer. In particular, here, we include information from the
    extreme oscillations in the signal:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包括整个声学数据段的极大值与极小值之比以及极大值与极小值之间的差值。我们还添加了超过一定振荡幅度（超过500个单位）的值的数量以及整个段的值总和。我们试图使用我们构建的这些特征多样性来捕获信号中的某些隐藏模式。特别是，这里我们包括信号极端振荡的信息：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We continue to add diverse aggregated features that try to capture various
    characteristics of the original signal. We further calculate the mean change rate
    (excluding nulls) for the first 10K and last 50K data points per acoustic data
    segment:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续添加多样化的聚合特征，试图捕获原始信号的各个特征。我们进一步计算每个声学数据段前10K和最后50K数据点的平均变化率（排除空值）：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some of the features we are adding will exclude the elements in the data that
    are `0`, to ensure only non-zero values are included in the calculation of the
    aggregated function. The code for using the `nonzero` function is:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的一些特征将排除数据中的`0`元素，以确保只将非零值包含在聚合函数的计算中。使用`nonzero`函数的代码如下：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A set of engineered features involves quantiles, specifically the 01%, 05%,
    95%, and 99% quantile values, for the entire acoustic data segment. The quantiles
    are calculated using the `numpy` `quantile` function. A quantile is a statistical
    term that refers to dividing a dataset into intervals of equal probability. For
    example, a 75% quantile value is the point where 75% of the data has values less
    than that number. A 50% quantile is the point where 50% of the data has values
    less than that number (and is also called the median). We also add absolute values
    for the 01%, 05%, 95%, and 99% quantile values. See the following code for the
    calculation of these features:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一组工程特征涉及分位数，具体是整个声学数据段的01%，05%，95%，和99%分位数值。分位数是使用`numpy`的`quantile`函数计算的。分位数是一个统计术语，指的是将数据集分成等概率的区间。例如，75%的分位数值是75%的数据值小于该数值的点。50%的分位数是50%的数据值小于该数值的点（也称为中位数）。我们还添加了01%，05%，95%，和99%分位数的绝对值。以下代码用于计算这些特征：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another type of engineered feature introduced is trend values (calculated with
    the `add_trend_values` function with the absolute flag off). Trend values will
    capture the general direction in which the acoustic data signal is changing. For
    a signal that shows an oscillation around 0 with high frequency, the trend will
    capture the change in the average value of the actual signal.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种引入的工程特征类型是趋势值（使用不带绝对标志的`add_trend_values`函数计算）。趋势值将捕获声学数据信号变化的一般方向。对于显示围绕0高频振荡的信号，趋势将捕获实际信号平均值的变化。
- en: 'We also add absolute trend values (calculated with the `add_trend_values` function
    with the absolute flag on). We include this type of engineering feature to capture
    patterns in the signal that appear in the absolute value of the signal. In this
    case, for the calculation of the trend, we use the absolute values of the original
    signal. Therefore, this trend will capture the direction of variation of the absolute
    value of the signal. The corresponding code is given here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了绝对趋势值（使用带有绝对标志的`add_trend_values`函数计算）。我们包括这种工程特征来捕获信号绝对值中出现的模式。在这种情况下，对于趋势的计算，我们使用原始信号的绝对值。因此，这种趋势将捕获信号绝对值变化的方向。相应的代码如下：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we include the mean of absolute values and the standard deviation of
    absolute values. Median absolute deviation (`mad`), `Kurtosis`, `Skew` (skewness),
    and `Median` values are also calculated. These functions are calculated using
    a `numpy` implementation. The median absolute deviation is a robust measure of
    the variability of a univariate sample of quantitative data. Kurtosis is a measure
    of the combined weight of a distribution tail relative to the center of the distribution.
    Skew (from skewness) is a measure of the asymmetry or distortion of a symmetric
    distribution. The median is, as we’ve already observed, the value separating the
    higher half from the lower half of a set of data. All these aggregated functions
    capture complementary information about the signal. The code for the calculation
    of these aggregation functions is shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包括绝对值的平均值和绝对值的标准差。中位数绝对偏差（`mad`）、`峰度`、`偏度`（偏度）和中位数值也被计算。这些函数使用`numpy`实现。中位数绝对偏差是定量数据单变量样本变异性的稳健度量。峰度是分布尾部的综合权重相对于分布中心的度量。偏度（来自偏度）是对称分布的不对称或扭曲的度量。中位数，正如我们之前观察到的，是分隔数据集上半部分和下半部分值的数值。所有这些聚合函数都捕捉到关于信号的有益信息。这些聚合函数的计算代码如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we include several features calculated by using transformation functions
    specific to signal processing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包括几个通过使用信号处理特定的变换函数计算的特征。
- en: Features derived using the Hilbert transform and Hann window
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用希尔伯特变换和汉宁窗口派生的特征
- en: 'We also calculate the Hilbert mean. We apply the Hilbert transform of the acoustic
    signal segment using the `scipy.signal.hilbert` function. This calculates the
    analytic signal, using the Hilbert transform. Then, we calculate the mean of the
    absolute value of the transformed data. The Hilbert transform is used frequently
    in signal processing and captures important information about the signal. Because
    we use aggregation functions to generate features from our temporal data, we would
    like to include a large, diverse range of existing signal processing techniques,
    to add important complementary elements of the signal when training the model:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还计算希尔伯特均值。我们使用`scipy.signal.hilbert`函数对声学信号段应用希尔伯特变换。这通过希尔伯特变换计算解析信号，然后，我们计算变换数据的绝对值的平均值。希尔伯特变换在信号处理中经常被使用，并捕捉到关于信号的重要信息。因为我们使用聚合函数从我们的时间数据中生成特征，我们希望包括大量、多样化的现有信号处理技术，在训练模型时添加信号的重要补充元素：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we include a feature derived from the Hann window mean value. We use
    this feature derived from the Hann window to reduce the abrupt discontinuities
    at the edge of the signal. The Hann window mean value is calculated using the
    convolution of the original signal with the result of the Hanning window and dividing
    by the sum of all values in the Hanning window:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包括一个由汉宁窗口均值派生的特征。我们使用这个由汉宁窗口派生的特征来减少信号边缘的突然不连续性。汉宁窗口均值是通过将原始信号与汉宁窗口的结果进行卷积，然后除以汉宁窗口中所有值的总和来计算的：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We previously introduced the definition of classical STA/LTA. We calculate
    a few features like classical STA/LTA mean for 500-10K, 5K-100K, 3,333-6,666,
    and 10K-25K STA/LTA windows. These are calculated with the STA/LTA function introduced
    previously. We include a variety of transformations to try to capture diverse
    signal characteristics in the aggregated engineering features:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前介绍了经典STA/LTA的定义。我们计算了500-10K、5K-100K、3,333-6,666和10K-25K STA/LTA窗口的经典STA/LTA均值等几个特征。这些是通过之前介绍的STA/LTA函数计算的。我们在聚合工程特征中包括各种变换，试图捕捉不同的信号特性：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we will also calculate features based on moving averages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将计算基于移动平均的特征。
- en: Features based on moving averages
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于移动平均的特征
- en: 'Next, we calculate several moving averages, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算几个移动平均值，如下所示：
- en: Moving average means for the 700, 1.5K, 3K, and 6K windows (and excluding NaNs)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 700、1.5K、3K和6K窗口的移动平均值均值（排除NaNs）
- en: Exponentially weighted moving average with spans of 300, 3K, and 6K
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数加权移动平均，跨度为300、3K和6K
- en: Average standard deviation moving average over 700 and 400 windows
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 700和400窗口的平均标准差移动平均值
- en: Moving averages means for 700-size window plus or minus 2 times average standard
    deviation moving average over the same size window
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 700大小窗口加减2倍平均标准差的移动平均值
- en: 'The moving averages help us to discern patterns, reduce noise, and provide
    a clear picture of the underlying trends in the data. The code for that will be:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均线帮助我们辨别模式，减少噪声，并清晰地展示数据中潜在趋势的图像。相应的代码如下：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also calculate the **IQR**, the 001% and 999% quantiles. The **IQR** (meaning
    **interquartile range**) is calculated by subtracting the 25% percentile from
    the 75% percentile (using `numpy` functions). The interquartile range is the region
    where 50% of the data is found. The 001% and 999% quantiles are also calculated
    with the `numpy` function for quantiles. The IQR and the various other quantiles
    we have included are useful because they provide important information about the
    central tendency and the spread of the signal:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还计算**四分位距**（IQR）、0.01%和99.9%的分位数。**四分位距**（IQR，即**四分位数范围**）是通过从75%分位数减去25%分位数（使用`numpy`函数）来计算的。四分位距是数据中50%所在的范围。0.01%和99.9%的分位数也使用`numpy`函数进行计算。IQR和我们所包含的其他分位数是有用的，因为它们提供了关于信号集中趋势和分散的重要信息：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For windows of 10, 100, and 1,000, we calculate the moving average and moving
    standard deviation. With these values, we then calculate the min, max, mean, standard
    deviation, average absolute and relative change, 01%, 05%, 95%, and 99% quantiles,
    and absolute max roll. We include these features because they reveal information
    about the local characteristics of the signal within the specified window. Subsequently,
    for the features derived from the moving average standard deviation calculated
    for windows of 10, 100, and 1,000, the code is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于10、100和1,000个窗口，我们计算移动平均和移动标准差。有了这些值，我们随后计算最小值、最大值、平均值、标准差、平均绝对变化和相对变化、1%、5%、95%和99%的分位数，以及绝对最大滚动值。我们包括这些特征，因为它们揭示了在指定窗口内信号局部特性的信息。随后，对于从10、100和1,000个窗口计算得到的移动平均标准差派生出的特征，代码如下：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the features derived from the moving average mean, calculated for windows
    of 10, 100, and 1,000, the code is:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从10、100和1,000个窗口计算得到的移动平均平均值派生出的特征，代码如下：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For each 150K-row segment generated from the training data, we are calculating
    these features. Then, the time to failure is selected as the value from the last
    row in the current segment:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从训练数据生成的每个150K行段，我们计算这些特征。然后，选择当前段最后一行的值作为故障时间：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we are scaling all features using a `StandardScaler`. This is not mandatory
    if we are using a model based on decision trees (such as random forest or XGBoost).
    We include this step for a case where we would like to use other models, for example,
    one based on neural networks, where normalizing the features would be a necessary
    step:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`StandardScaler`对所有特征进行缩放。如果我们使用基于决策树（如随机森林或XGBoost）的模型，这一步不是必须的。我们包括这一步是为了考虑到我们可能想使用其他模型的情况，例如基于神经网络的模型，在这种情况下，对特征进行归一化将是一个必要的步骤：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We repeat the same process for test data segments:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对测试数据段重复同样的过程：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After we analyzed the data, we generated a set of engineered features. We intend
    to use these features to build a baseline model. Then, based on the model evaluation,
    we can further select what features to keep and, eventually, to create new features.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分析数据后，我们生成了一组工程特征。我们打算使用这些特征来构建一个基线模型。然后，基于模型评估，我们可以进一步选择保留哪些特征，并最终创建新的特征。
- en: Building a baseline model
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基线模型
- en: 'From the original temporal data, through feature engineering, we generated
    time-aggregated features for each time segment in the training data, equal in
    duration with one test set. For the baseline model demonstrated in this competition,
    we chose `LGBMRegressor`, one of the best-performing algorithms at the time of
    the competition, which, in many cases, had a similar performance to `XGBoost`.
    The training data is split using `KFold` into five splits, and we run training
    and validation for each fold until we reach the final number of iterations or
    when the validation error ceases to improve after a specified number of steps
    (given by the *patience* parameter). For each split, we then also run the prediction
    for the test set, with the best model – trained with the current train split for
    the current fold, that is, with 4/5 from the training set. At the end, we will
    work out the average of the predictions obtained for each fold. We can use this
    cross-validation approach because our data is no longer temporal (time-series)
    data. We split the data into segments of 150K rows, of the same length as the
    test data, and then created aggregated features from this data:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始的时间数据中，通过特征工程，我们为训练数据中的每个时间段生成了时间聚合特征，其持续时间与一个测试集相等。对于本次比赛中展示的基线模型，我们选择了`LGBMRegressor`，这是当时表现最好的算法之一，在很多情况下，其性能与`XGBoost`相似。训练数据使用`KFold`分割成五个部分，我们对每个部分进行训练和验证，直到达到最终的迭代次数或者验证误差在指定步骤数后不再改善（由`patience`参数给出）。对于每个分割，我们还会对测试集进行预测，使用的是当前折叠的最佳模型——即使用当前折叠的训练分割进行训练的模型，也就是使用训练集的4/5。最后，我们将计算每个折叠获得的预测的平均值。我们可以使用这种交叉验证方法，因为我们的数据不再是时间序列数据。我们将数据分割成150K行的段，与测试数据长度相同，然后从这些数据中创建了聚合特征：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The model parameters are given in the following code excerpt. We set some of
    the usual parameters for LightGBM, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模型参数如下代码片段所示。我们为LightGBM设置了以下一些常用参数：
- en: '**The number of leaves**: This parameter controls the number of leaves (or
    terminal nodes) in each tree. An increasing number of leaves allows the model
    to capture more complex patterns but also increases the risk of overfitting.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶子节点数**：此参数控制每个树中的叶子节点（或终端节点）的数量。增加叶子节点的数量允许模型捕捉更复杂的模式，但也增加了过拟合的风险。'
- en: '**Minimum data in leaf**: If the number of samples in a leaf node is below
    this threshold, the node will not split. This parameter helps control overfitting.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶子节点中的最小数据量**：如果一个叶子节点的样本数低于此阈值，则该节点不会分裂。此参数有助于控制过拟合。'
- en: '**The objective**: This is regression for our model.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：这是我们的模型的回归。'
- en: '**Learning rate**: This will control how fast the model learns.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习率**：这将控制模型学习的速度。'
- en: '**The boosting method**: We can choose between gradient-boosted decision trees
    (*gbdt*), dart gradient boosting (*dgb*), and gradient-based one-side sampling
    (*goss*). We are using *gbdt* here.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升方法**：我们可以选择梯度提升决策树（*gbdt*）、dart梯度提升（*dgb*）和基于梯度的单侧采样（*goss*）。在这里我们使用*gbdt*。'
- en: '**The feature fraction**: This is the percentage of features used in a subset
    of data presented to a tree within the tree ensemble employed by the algorithm.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特征分数**：这是在算法使用的树集成中，向树展示的数据子集中的特征百分比。'
- en: '**Bagging frequency, bagging fraction, and bagging seed**: These control how
    we divide the sample set presented to the algorithm when we subsample it to present
    it to different trees.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**袋装频率、袋装分数和袋装种子**：这些控制我们在对算法进行子采样以展示给不同的树时如何划分样本集。'
- en: '**Metric**: In this case, *mae*, which is the mean absolute error.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度量标准**：在这种情况下，*mae*，即平均绝对误差。'
- en: '**Regularization factor lambda_l1**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正则化因子lambda_l1**'
- en: '**Verbosity**: This parameter controls the amount of information the algorithm
    prints to the console during training. A verbosity of 0 means silent mode (no
    information), while a verbosity of 1 prints messages about the training progress.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细程度**：此参数控制算法在训练过程中打印到控制台的信息量。详细程度为0表示静默模式（无信息），而详细程度为1会打印有关训练进度的消息。'
- en: '**Number of parallel processing threads**: This parameter controls the number
    of parallel threads used by the algorithm during training.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行处理线程数**：此参数控制算法在训练期间使用的并行线程数。'
- en: '**The randomization factor random_state**: This parameter is the random seed
    used to initialize various parameters of the algorithm.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机化因子random_state**：此参数是用于初始化算法各种参数的随机种子。'
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The code for training, validation, and testing (per fold) is shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 训练、验证和测试（每个折叠）的代码如下：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We initialize the prediction vector (which has the dimension of the submission
    file, that is, one entry for each test segment) with zeros. We also initialize
    an out-of-folds vector (the length of the training data, which is the number of
    training segments).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将预测向量（其维度与提交文件的维度相同，即每个测试段一个条目）初始化为零。我们还初始化了一个超出折叠的向量（训练数据的长度，即训练段的数量）。
- en: For each fold, we sample subsets of data and target values for both the training
    and validation sets. Then, we use them as input for the model, `LGBMRegressor`,
    initialized with the model parameters defined before (we also add the number of
    estimators and the number of workers). We fit the model with the subset of the
    training set corresponding to the current fold and validate it with the corresponding
    validation subset of the training data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个折叠，我们为训练集和验证集采样数据子集和目标值。然后，我们将它们用作模型的输入，`LGBMRegressor`，使用之前定义的模型参数初始化（我们还将估计器的数量和工人的数量添加进去）。我们使用当前折叠对应的训练集子集来拟合模型，并使用相应的训练数据验证子集进行验证。
- en: 'We set the evaluation metric as well: *mae* – meaning *mean absolute error*
    – the frequency for printing out the evaluation error, and the number of iterations
    for early stopping. This parameter (number of iterations for early stopping) controls
    the number of steps that the algorithm waits before stopping, when the validation
    error does not improve during training. We accumulate the validation results in
    the **oof** (**out-of-folds**) vector and concatenate the feature importance vector
    for the current fold to the feature importance DataFrame. Early stopping is used
    to keep the best model for prediction – based on validation during training.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了评估指标：*mae*——表示*平均绝对误差*——打印评估错误的频率，以及早期停止的迭代次数。此参数（早期停止的迭代次数）控制算法在验证错误在训练期间没有改进时停止等待的步数。我们在**oof**（**超出折叠**）向量中累积验证结果，并将当前折叠的特征重要性向量连接到特征重要性DataFrame中。早期停止用于在训练期间保持最佳模型进行预测。
- en: Feature importance will be used to observe, during the iterative process of
    feature engineering, feature selection, and model training – if, for a model trained
    with certain features, the feature importance does not have a high variation between
    folds. At each fold, we are also running a prediction for the entire test set,
    with the model trained and validated per fold. Then, we increment the prediction
    vector with the values per fold, divided by the number of folds. This is equivalent
    to a model ensemble, where each model is trained with a different subset of data,
    corresponding to each fold split.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 特征重要性将用于在特征工程、特征选择和模型训练的迭代过程中观察——如果对于使用某些特征训练的模型，特征重要性在折叠间没有高变化。在每个折叠中，我们也在运行整个测试集的预测，使用每个折叠训练和验证的模型。然后，我们将每个折叠的值加到预测向量中，除以折叠数。这相当于一个模型集成，其中每个模型都使用对应于每个折叠分割的不同数据子集进行训练。
- en: 'When evaluating the current model, we will examine three pieces of information:
    the training and validation errors, the variation of these errors across the folds,
    and the variation of feature importance between the folds. Ideally, these variations
    – of training and validation errors across folds, as well as the feature importance
    variation across folds – are smaller. *Figure 8.8* shows the evaluation plots
    from the training of the baseline model.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估当前模型时，我们将检查三块信息：训练和验证错误、这些错误在折叠间的变化，以及特征重要性在折叠间的变化。理想情况下，这些变化——训练和验证错误在折叠间的变化，以及特征重要性在折叠间的变化——应该更小。*图8.8*显示了基线模型训练的评估图。
- en: As you can see, we plot the training progress at every 1,000th step (verbosity
    set to `1000`), and implement an early stop at 500 (training stops if there’s
    no improvement in the validation error for the last 500 iterations). The best
    model (in terms of validation error) is retained for predicting from the test.
    Test prediction is averaged over the five splits.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在每1,000步（详细程度设置为`1000`）处绘制训练进度，并在500步时实施早期停止（如果验证错误在最后500次迭代中没有改进，则停止训练）。保留最佳模型（就验证错误而言）用于测试预测。测试预测是五个分割的平均值。
- en: '![A screenshot of a computer program  Description automatically generated](img/B20963_08_08.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  自动生成描述](img/B20963_08_08.png)'
- en: 'Figure 8.8: Model training evaluation output – training and validation error'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：模型训练评估输出 – 训练和验证错误
- en: '*Figure 8.9* shows the feature importance graph, with the average value per
    fold and the standard deviation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.9*显示了特征重要性图，包括每个折的平均值和标准差：'
- en: '![A colorful graph with numbers  Description automatically generated with medium
    confidence](img/B20963_08_09.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有数字的彩色图表，描述自动生成，中等置信度](img/B20963_08_09.png)'
- en: 'Figure 8.9: Feature importance: average and standard deviation values (from
    values on the five folds) – top 20 features'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：特征重要性：平均和标准差值（来自五个折的值） – 前20个特征
- en: After we performed data analysis, we proceeded with building time-aggregated
    features, on subsets of the training set with the same duration as the test sets.
    With the new dataset formed with the engineered features, we trained a baseline
    model. For the baseline model, we used cross-validation with five folds and used
    each fold model for the prediction of the test set. The final prediction was formed
    by averaging the predictions for each fold.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行数据分析之后，我们继续构建时间聚合特征，这些特征是在与测试集相同持续时间的训练集子集上形成的。使用具有工程特征的新的数据集，我们训练了一个基线模型。对于基线模型，我们使用了五折交叉验证，并使用每个折的模型来预测测试集。最终预测是通过平均每个折的预测来形成的。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into handling signal data, focusing particularly
    on audio signals. We explored various storage formats for such data and examined
    libraries for loading, transforming, and visualizing this data type. To develop
    potent features, we applied a range of signal-processing techniques. Our feature
    engineering efforts transformed time-series data from each training segment and
    aggregated features for each test set.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了处理信号数据的方法，特别是音频信号。我们探讨了此类数据的各种存储格式，并检查了用于加载、转换和可视化此类数据类型的库。为了开发强大的特征，我们应用了一系列信号处理技术。我们的特征工程努力将每个训练段的时间序列数据转换为特征，并为每个测试集汇总特征。
- en: We consolidated all feature engineering processes into a single function, applicable
    to all training segments and test sets. The transformed features underwent scaling.
    We then used this prepared data to train a baseline model utilizing the LGBMRegressor
    algorithm. This model employed cross-validation, and we generated predictions
    for the test set using the model trained in each fold. Subsequently, we aggregated
    these predictions to create the submission file. Additionally, we captured and
    visualized the feature importance for each fold.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有特征工程过程合并为一个单一函数，适用于所有训练段和测试集。转换后的特征经过了缩放。然后我们使用这些准备好的数据，利用LGBMRegressor算法训练了一个基线模型。该模型采用了交叉验证，我们使用每个折训练的模型来生成测试集的预测。随后，我们将这些预测汇总以创建提交文件。此外，我们还捕获并可视化了每个折的特征重要性。
- en: References
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'LANL Earthquake Prediction, Can you predict upcoming laboratory earthquakes?,
    Kaggle Competition: [https://www.kaggle.com/competitions/LANL-Earthquake-Prediction](https://www.kaggle.com/competitions/LANL-Earthquake-Prediction)'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LANL地震预测，你能预测即将到来的实验室地震吗？Kaggle竞赛：[https://www.kaggle.com/competitions/LANL-Earthquake-Prediction](https://www.kaggle.com/competitions/LANL-Earthquake-Prediction)
- en: 'Gabriel Preda, LANL Earthquake EDA and Prediction: [https://www.kaggle.com/code/gpreda/lanl-earthquake-eda-and-prediction](https://www.kaggle.com/code/gpreda/lanl-earthquake-eda-and-prediction)'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gabriel Preda, LANL地震EDA和预测：[https://www.kaggle.com/code/gpreda/lanl-earthquake-eda-and-prediction](https://www.kaggle.com/code/gpreda/lanl-earthquake-eda-and-prediction)
- en: 'LANL Earthquake Prediction, dataset description: [https://www.kaggle.com/competitions/LANL-Earthquake-Prediction/data](https://www.kaggle.com/competitions/LANL-Earthquake-Prediction/data)'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LANL地震预测，数据集描述：[https://www.kaggle.com/competitions/LANL-Earthquake-Prediction/data](https://www.kaggle.com/competitions/LANL-Earthquake-Prediction/data)
- en: 'BirdCLEF 2021 - Birdcall Identification, identify bird calls in soundscape
    recordings, Kaggle competition: [https://www.kaggle.com/competitions/birdclef-2021](https://www.kaggle.com/competitions/birdclef-2021)'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BirdCLEF 2021 - 鸟鸣识别，在声音景观录音中识别鸟鸣，Kaggle竞赛：[https://www.kaggle.com/competitions/birdclef-2021](https://www.kaggle.com/competitions/birdclef-2021)
- en: 'McFee, Brian, Colin Raffel, Dawen Liang, Daniel PW Ellis, Matt McVicar, Eric
    Battenberg, and Oriol Nieto. “librosa: Audio and music signal analysis in Python.”
    In Proceedings of the 14th Python in Science Conference, pp. 18-25\. 2015'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'McFee, Brian, Colin Raffel, Dawen Liang, Daniel PW Ellis, Matt McVicar, Eric
    Battenberg, 和 Oriol Nieto. “librosa: Python中的音频和音乐信号分析.” 在第14届Python科学会议论文集中，第18-25页。2015'
- en: 'librosa load function: [https://librosa.org/doc/main/generated/librosa.load.html](https://librosa.org/doc/main/generated/librosa.load.html)'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: librosa 加载函数：[https://librosa.org/doc/main/generated/librosa.load.html](https://librosa.org/doc/main/generated/librosa.load.html)
- en: 'Cornell Birdcall Identification, Kaggle competition: [https://www.kaggle.com/competitions/birdsong-recognition](https://www.kaggle.com/competitions/birdsong-recognition)'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 康奈尔鸟鸣识别，Kaggle 比赛：[https://www.kaggle.com/competitions/birdsong-recognition](https://www.kaggle.com/competitions/birdsong-recognition)
- en: 'EarthData MERRA2 CO, Earth Data NASA Satellite Measurements, Kaggle dataset:
    [https://www.kaggle.com/datasets/gpreda/earthdata-merra2-co](https://www.kaggle.com/datasets/gpreda/earthdata-merra2-co)'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EarthData MERRA2 CO，地球数据 NASA 卫星测量，Kaggle 数据集：[https://www.kaggle.com/datasets/gpreda/earthdata-merra2-co](https://www.kaggle.com/datasets/gpreda/earthdata-merra2-co)
- en: 'Gabriel Preda, EARTHDATA-MERRA2 Data Exploration, Kaggle Notebook: [https://www.kaggle.com/code/gpreda/earthdata-merra2-data-exploration](https://www.kaggle.com/code/gpreda/earthdata-merra2-data-exploration)'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加布里埃尔·普雷达，EARTHDATA-MERRA2 数据探索，Kaggle 笔记本：[https://www.kaggle.com/code/gpreda/earthdata-merra2-data-exploration](https://www.kaggle.com/code/gpreda/earthdata-merra2-data-exploration)
- en: Join our book’s Discord space
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们书籍的 Discord 空间
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 5000 members at:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区，与志同道合的人相聚，并在以下地点与超过 5000 名成员一起学习：
- en: '[https://packt.link/kaggle](https://packt.link/kaggle)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/kaggle](https://packt.link/kaggle)'
- en: '![](img/QR_Code9220780366773140.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code9220780366773140.png)'
