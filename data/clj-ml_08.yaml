- en: Chapter 8. Anomaly Detection and Recommendation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 异常检测与推荐
- en: In this chapter, we will study a couple of modern forms of applied machine learning.
    We will first explore the problem of *anomaly detection* and we will discuss *recommendation
    systems* later in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些现代应用机器学习的形式。我们首先将探讨*异常检测*的问题，我们将在本章后面讨论*推荐系统*。
- en: '**Anomaly detection** is a machine learning technique in which we determine
    whether a given set of values for some selected features that represent the system
    are unexpectedly different from the normally observed values of the given features.
    There are several applications of anomaly detection, such as detection of structural
    and operational defects in manufacturing, network intrusion detection systems,
    system monitoring, and medical diagnosis.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常检测**是一种机器学习技术，其中我们确定代表系统的某些选定特征的给定值集是否与给定特征的正常观察值意外不同。异常检测有几个应用，例如在制造业检测结构性和操作缺陷、网络入侵检测系统、系统监控和医疗诊断。'
- en: '**Recommendation systems** are essentially information systems that seek to
    predict a given user''s liking or preference for a given item. Over recent years,
    there have been a vast number of recommendation systems, or **recommender systems**,
    that have been built for several business and social applications to provide a
    better experience for their users. Such systems can provide a user with useful
    recommendations depending on the items that the user has previously rated or liked.
    Most existing recommendation systems today provide recommendations to users about
    online products, music, and social media. There are also a significant number
    of financial and business applications on the Web that use recommendation systems.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**推荐系统**本质上是信息系统，旨在预测特定用户对特定项目的喜好或偏好。近年来，已经建立了大量推荐系统，或称为**推荐器系统**，用于多个商业和社会应用，以提供更好的用户体验。这些系统可以根据用户之前评分或喜欢的项目向用户提供有用的推荐。今天，大多数现有的推荐系统都向用户提供有关在线产品、音乐和社交媒体的推荐。在网络上，也有大量使用推荐系统的金融和商业应用。'
- en: Interestingly, both anomaly detection and recommendation systems are applied
    forms of machine learning problems, which we have previously encountered in this
    book. Anomaly detection is in fact an extension of binary classification, and
    recommendation is actually an extended form of linear regression. We will study
    more about these similarities in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，异常检测和推荐系统都是机器学习问题的应用形式，我们在这本书中之前已经遇到过。实际上，异常检测是二元分类的扩展，而推荐实际上是线性回归的扩展形式。我们将在本章中进一步研究这些相似之处。
- en: Detecting anomalies
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测异常
- en: '*Anomaly detection* is essentially the identification of items or observed
    values that do not conform to an expected pattern (for more information, refer
    to "A Survey of Outlier Detection Methodologies"). The pattern could be determined
    by values that have been previously observed, or by some limits across which the
    input values can vary. In the context of machine learning, anomaly detection can
    be performed in both supervised and unsupervised environments. Either way, the
    problem of anomaly detection is to find input values that are significantly different
    from other input values. There are several applications of this technique, and
    in the broad sense, we can use anomaly detection for the following reasons:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常检测*本质上是识别不符合预期模式的项目或观察值（更多信息，请参阅“异常检测方法综述”）。模式可以由先前观察到的值确定，也可以由输入值可以变化的某些限制确定。在机器学习的背景下，异常检测可以在监督和非监督环境中进行。无论哪种方式，异常检测的问题都是找到与其他输入值显著不同的输入值。这项技术有几种应用，从广义上讲，我们可以使用异常检测进行以下原因：'
- en: To detect problems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检测问题
- en: To detect a new phenomenon
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了检测新现象
- en: To monitor unusual behavior
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了监控异常行为
- en: The observed values that are found to be different from the other values are
    called outliers, anomalies, or exceptions. More formally, we define an **outlier**
    as an observation that lies outside the overall pattern of a distribution. By
    *outside*, we mean an observation that has a high numerical or statistical distance
    from the rest of the data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 被发现与其他值不同的观察值被称为异常值、异常或例外。更正式地说，我们定义**异常值**为位于分布整体模式之外的观察值。通过“之外”，我们指的是与数据中其他部分有较高数值或统计距离的观察值。
- en: 'Some examples of outliers can be depicted by the following plots, where the
    red crosses mark normal observations and the green crosses mark the anomalous
    observations:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表可以描述一些异常的例子，其中红色十字表示正常观测值，绿色十字表示异常观测值：
- en: '![Detecting anomalies](img/4351OS_08_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![检测异常](img/4351OS_08_01.jpg)'
- en: One possible approach to anomaly detection is to use a *probability distribution
    model*, which is built from the training data to detect anomalies. Techniques
    that use this approach are termed as *statistical methods* of anomaly detection.
    In this approach, an anomaly will have a low probability with respect to the overall
    probability distribution of the rest of the sample data. Hence, we try to fit
    a model onto the available sample data and use this formulated model to detect
    anomalies. The main problem with this approach is that it's hard to find a standard
    distribution model for stochastic data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 异常检测的一个可能方法是使用一个**概率分布模型**，该模型由训练数据构建，用于检测异常。使用这种方法的技术被称为异常检测的**统计方法**。在这种情况下，异常相对于其余样本数据的整体概率分布将具有较低的几率。因此，我们尝试将模型拟合到可用的样本数据上，并使用这个构建的模型来检测异常。这种方法的主要问题是很难为随机数据找到一个标准的分布模型。
- en: Another method that can be used to detect anomalies is a *proximity-based approach*.
    In this approach, we determine the proximity, or nearness, of a set of observed
    values with respect to the rest of the values in the sample data. For example,
    we could use the **K-Nearest Neighbors** (**KNN**) algorithm to determine the
    distances of a given observed value to its *k* nearest values. This technique
    is much simpler than estimating a statistical model over the sample data. This
    is because it's easier to determine a single measure, which is the proximity of
    an observed value, than it is to fit a standard model on the available training
    data. However, determining the proximity of a set of input values could be inefficient
    for larger datasets. For example, the KNN algorithm has a time complexity of ![Detecting
    anomalies](img/4351OS_08_02.jpg), and computing the proximity of a given set of
    values to its *k* nearest values could be inefficient for a large value of *k*.
    Also, the KNN algorithm could be sensitive to the value of the neighbors *k*.
    If the value of *k* is too large, clusters of values with less than *k* individual
    sets of input values could be falsely classified as anomalies. On the other hand,
    if *k* is too small, some anomalies that have a few neighbors with a low proximity
    may not be detected.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以用来检测异常的方法是**基于邻近度的方法**。在这种方法中，我们确定一组观测值相对于样本数据中其余值的邻近度或接近度。例如，我们可以使用**K-最近邻**（**KNN**）算法来确定给定观测值与其k个最近值之间的距离。这种技术比在样本数据上估计统计模型要简单得多。这是因为确定一个单一度量，即观测值的邻近度，比在可用的训练数据上拟合标准模型要容易。然而，对于大型数据集，确定一组输入值的邻近度可能效率低下。例如，KNN算法的时间复杂度为![检测异常](img/4351OS_08_02.jpg)，对于较大的k值，计算给定值与其k个最近值之间的邻近度可能效率低下。此外，KNN算法可能对邻居k的值敏感。如果k的值太大，包含少于k个输入值集的值簇可能会被错误地分类为异常。另一方面，如果k的值太小，一些具有少量低邻近度邻居的异常可能不会被检测到。
- en: 'We can also determine whether a given set of observed values is an anomaly
    based on the density of data around it. This approach is termed as the **density-based
    approach** to anomaly detection. A given set of input values can be classified
    as an anomaly if the data around the given values is low. In anomaly detection,
    the density-based and proximity-based approaches are closely related. In fact,
    the density of data is generally defined in terms of the proximity or distance
    of a given set of values with respect to the rest of the data. For example, if
    we use the KNN algorithm to determine the proximity or distance of a given set
    of values to the rest of the data, we can define the density as the reciprocal
    of the average distance to the *k* nearest values, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据围绕给定观测值的数据密度来判断该观测值是否为异常。这种方法被称为异常检测的**基于密度的方法**。如果给定值周围的数据密度低，则给定的一组输入值可以被视为异常。在异常检测中，基于密度和基于邻近度的方法密切相关。实际上，数据的密度通常是根据给定值相对于其余数据的邻近度或距离来定义的。例如，如果我们使用KNN算法来确定给定值相对于其余数据的邻近度或距离，我们可以将密度定义为到最近的k个值的平均距离的倒数，如下所示：
- en: '![Detecting anomalies](img/4351OS_08_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![检测异常](img/4351OS_08_03.jpg)'
- en: '*Clustering-based approaches* can also be used to detect anomalies. Essentially,
    clustering can be used to determine groups or clusters of values in the sample
    data. The items in a cluster can be assumed to be closely related, and anomalies
    are values that cannot be related to previously encountered values in the clusters
    in the sample data. Thus, we could determine all the clusters in the sample data
    and then mark the smallest clusters as anomalies. Alternatively, we can form clusters
    from the sample data and determine the clusters, if any, of a given set of previously
    unseen values.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于聚类的技术*也可以用于检测异常。本质上，聚类可以用来确定样本数据中的值组或簇。簇中的项目可以假设是紧密相关的，而异常是那些无法与样本数据中先前遇到的簇中的值相关联的值。因此，我们可以确定样本数据中的所有簇，并将最小的簇标记为异常。或者，我们可以从样本数据中形成簇，并确定给定的一组先前未见过的值的簇，如果有的话。'
- en: If a set of input values does not belong to any cluster, it's definitely an
    anomalous observation. The advantage of clustering techniques is that they can
    be used in combination with other machine learning techniques that we previously
    discussed. On the other hand, the problem with this approach is that most clustering
    techniques are sensitive to the number of clusters that have been chosen. Also,
    algorithmic parameters of clustering techniques, such as the average number of
    items in a cluster and number of clusters, cannot be determined easily. For example,
    if we are modeling some unlabeled data using the KNN algorithm, the number of
    clusters *K* would have to be determined either by trial-and-error or by scrutinizing
    the sample data for obvious clusters. However, both these techniques are not guaranteed
    to perform well on unseen data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组输入值不属于任何簇，那么它肯定是一个异常观测值。聚类技术的优点是它们可以与其他我们之前讨论过的机器学习技术结合使用。另一方面，这种方法的问题在于大多数聚类技术对选择的簇的数量很敏感。此外，聚类技术的算法参数，如簇中平均项目数和簇数，很难确定。例如，如果我们使用KNN算法对一些未标记的数据进行建模，簇数*K*可能需要通过试错法或通过仔细检查样本数据中的明显簇来确定。然而，这两种技术都不保证在未见过的数据上表现良好。
- en: In models where the sample values are all supposed to conform to some mean value
    with some allowable tolerance, the **Gaussian** or **normal distribution** is
    often used as the distribution model to train an anomaly detector. This model
    has two parameters—the mean ![Detecting anomalies](img/4351OS_08_04.jpg) and the
    variance ![Detecting anomalies](img/4351OS_08_05.jpg). This distribution model
    is often used in statistical approaches to anomaly detection, where the input
    variables are normally found statistically close to some predetermined mean value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些样本值都应符合某个平均值并允许一定容忍度的模型中，通常使用**高斯**或**正态分布**作为分布模型来训练异常检测器。此模型有两个参数——均值![检测异常](img/4351OS_08_04.jpg)和方差![检测异常](img/4351OS_08_05.jpg)。这种分布模型常用于异常检测的统计方法中，其中输入变量通常在统计上接近某个预定的平均值。
- en: 'The **Probability Density Function** (**PDF**) is often used by density-based
    methods of anomaly detection. This function essentially describes the likelihood
    that an input variable will take on a given value. For a random variable *x*,
    we can formally define the PDF as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**概率密度函数**（**PDF**）常被密度基异常检测方法使用。这个函数本质上描述了输入变量取某个给定值的可能性。对于随机变量*x*，我们可以正式定义PDF如下：'
- en: '![Detecting anomalies](img/4351OS_08_06.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![检测异常](img/4351OS_08_06.jpg)'
- en: 'The PDF can also be used in combination with a normal distribution model for
    the purpose of anomaly detection. The PDF of a normal distribution is parameterized
    by the mean ![Detecting anomalies](img/4351OS_08_04.jpg) and variance ![Detecting
    anomalies](img/4351OS_08_05.jpg) of the distribution, and can be formally expressed
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PDF也可以与正态分布模型结合用于异常检测的目的。正态分布的PDF由分布的均值![检测异常](img/4351OS_08_04.jpg)和方差![检测异常](img/4351OS_08_05.jpg)参数化，并且可以正式表示如下：
- en: '![Detecting anomalies](img/4351OS_08_07.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![检测异常](img/4351OS_08_07.jpg)'
- en: We will now demonstrate a simple implementation of an anomaly detector in Clojure,
    which is based on the PDF for a normal distribution as we previously discussed.
    For this example, we will use Clojure atoms to maintain all states in the model.
    Atoms are used to represent an atomic state in Clojure. By *atomic*, we mean that
    the underlying state changes completely or doesn't change at all—the changes in
    state are thus *atomic*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将展示一个基于先前讨论的正态分布PDF的简单异常检测器在Clojure中的实现。对于这个例子，我们将使用Clojure原子来维护模型中的所有状态。原子用于在Clojure中表示原子状态。通过“原子”，我们指的是底层状态要么完全改变，要么完全不改变——因此状态的变化是“原子”的。
- en: We now define some functions to help us manipulate the features of the model.
    Essentially, we intend to represent these features and their values as a map.
    To manage the state of this map, we use an atom. Whenever the anomaly detector
    is fed a set of feature values, it must first check for any previous information
    on the features in the new set of values, and then it should start maintaining
    the state of any new features when it is necessary. As a function on its own cannot
    contain any external state in Clojure, we will use closures to bind state and
    functions together. In this implementation, almost all the functions return other
    functions, and the resulting anomaly detector will also be used just like a function.
    In summary, we will model the state of the anomaly detector using an atom, and
    then bind this atom to a function using a closure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义一些函数来帮助我们操作模型的特性。本质上，我们打算将这些特性和它们的值表示为一个地图。为了管理这个地图的状态，我们使用一个原子。每当异常检测器被提供一组特征值时，它必须首先检查新值集中关于特征的前置信息，然后它应该开始维护任何新特征的状态，当需要时。由于在Clojure中，一个函数本身不能包含任何外部状态，我们将使用闭包将状态和函数绑定在一起。在这个实现中，几乎所有的函数都返回其他函数，并且生成的异常检测器也将像函数一样使用。总之，我们将使用原子来模拟异常检测器的状态，然后使用闭包将这个原子绑定到一个函数上。
- en: 'We start off by defining a function that initializes our model with some state.
    This state is essentially a map wrapped in an atom by using the `atom` function,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个函数，该函数使用一些状态初始化我们的模型。这个状态本质上是一个通过使用`atom`函数包裹的地图，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `accumulator` function defined in the preceding code initializes an atom
    and returns a function that applies the `update-totals` function to a value `n`.
    The value `n` represents a value of an input variable in our model. The `update-totals`
    function also returns a function that takes a single argument, and then it updates
    the state in the atom by using the `update-in` function. The function returned
    by the `accumulator` function will use the `update-totals` function to update
    the state of the mean and variance of the model.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义的`accumulator`函数初始化一个原子，并返回一个将`update-totals`函数应用于值`n`的函数。值`n`代表我们模型中输入变量的一个值。`update-totals`函数也返回一个接受单个参数的函数，然后它通过使用`update-in`函数更新原子中的状态。由`accumulator`函数返回的函数将使用`update-totals`函数来更新模型均值和方差的州。
- en: 'We now implement the following PDF function for normal distribution that can
    be used to monitor sudden changes in the feature values of the model:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在实现以下用于正态分布的PDF函数，可用于监控模型特征值的突然变化：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `density` function defined in the preceding code is a direct translation
    of the PDF function for normal distribution. It uses functions and constants from
    the `Math` namespace such as, `sqrt`, `exp`, and `PI` to find the PDF of the model
    by using the accumulated mean and variance of the model. We will define the the
    `density-detector` function as shown in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义的`density`函数是正态分布PDF的直接翻译。它使用来自`Math`命名空间的功能和常数，如`sqrt`、`exp`和`PI`，通过使用模型的累积均值和方差来找到模型的PDF。我们将定义`density-detector`函数，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `density-detector` function defined in the preceding code initializes the
    state of our anomaly detector using the `accumulator` function, and it uses the
    `density` function on the state maintained by the accumulator to determine the
    PDF of the model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义的`density-detector`函数使用`accumulator`函数初始化我们的异常检测器的状态，并使用累加器维护的状态上的`density`函数来确定模型的PDF。
- en: 'Since we are dealing with maps wrapped in atoms, we can implement a couple
    of functions to perform this check by using the `contains?`, `assoc-in`, and `swap!`
    functions, as shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是包裹在原子中的地图，我们可以通过使用`contains?`、`assoc-in`和`swap!`函数来实现几个函数来执行此检查，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `get-or-add-key` function defined in the preceding code looks up a given
    key in an atom containing a map by using the `contains?` function. Note the use
    of the `@` operator to dereference an atom into its wrapped value. If the key
    is found in the map, we simply call the map as a function as `(@a key)`. If the
    key is not found, we use the `swap!` and `assoc-in` functions to add a new key-value
    pair to the map in the atom. The value of this key-value pair is generated from
    the `create-fn` parameter that is passed to the g`et-or-add-key` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义的 `get-or-add-key` 函数通过使用 `contains?` 函数在包含映射的原子中查找给定的键。注意使用 `@` 操作符来取消引用原子到其包装的值。如果在映射中找到键，我们只需将映射作为函数调用，即
    `(@a key)`。如果没有找到键，我们使用 `swap!` 和 `assoc-in` 函数将新的键值对添加到原子中的映射中。此键值对的值是从传递给 `get-or-add-key`
    函数的 `create-fn` 参数生成的。
- en: 'Using the `get-or-add-key` and `density-detector` functions we have defined,
    we can implement the following functions that return functions while detecting
    anomalies in the sample data so as to create the effect of maintaining the state
    of the PDF distribution of the model within these functions themselves:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们定义的 `get-or-add-key` 和 `density-detector` 函数，我们可以实现以下函数，这些函数在检测样本数据中的异常时返回函数，从而在这些函数本身中创建维护模型
    PDF 分布状态的效果：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `atom-hash-map` function defined in the preceding code uses the `get-key`
    function with an arbitrary initialization function `create-fn` to maintain the
    state of a map in an atom. The detector function uses the `density-detector` function
    that we previously defined to initialize the state of every new feature in the
    input values that are fed to it. Note that this function returns a function that
    will accept a map with key-value parameters as the features. We can inspect the
    behavior of the implemented anomaly detector in the REPL as shown in the following
    code and output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中定义的 `atom-hash-map` 函数使用 `get-key` 函数和一个任意的初始化函数 `create-fn` 来在原子中维护映射的状态。检测函数使用我们之前定义的
    `density-detector` 函数来初始化输入值中每个新特征的初始状态。请注意，此函数返回一个函数，该函数将接受带有键值参数的映射作为特征。我们可以在以下代码和输出中检查实现的异常检测器的行为：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the preceding code and output, we created a new instance of our
    anomaly detector by using the `detector` function. The `detector` function returns
    a function that accepts a map of key-value pairs of features. When we feed the
    map with `{:x 10 :y 10 :z 10}`, the anomaly detector returns a PDF of `1.0` since
    all samples in the data so far have the same feature values. The anomaly detector
    will always return this value as long as the number of features and the values
    of these features remains the same in all sample inputs fed to it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码和输出所示，我们通过使用 `detector` 函数创建了一个新的异常检测器实例。`detector` 函数返回一个函数，该函数接受特征键值对的映射。当我们用
    `{:x 10 :y 10 :z 10}` 向映射提供数据时，异常检测器返回 PDF 为 `1.0`，因为到目前为止数据中的所有样本都具有相同的特征值。只要所有样本输入中的特征数量和这些特征值保持不变，异常检测器将始终返回此值。
- en: 'When we feed the anomaly detector with a set of features with different values,
    the PDF is observed to change to a finite number, as shown in the following code
    and output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向异常检测器提供具有不同值的特征集时，PDF 观察到变为有限数值，如下面的代码和输出所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the features show a large degree of variation, the detector has a sudden
    and large decrease in the PDF of its distribution model, as shown in the following
    code and output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当特征显示出很大的变化时，检测器在其分布模型的 PDF 中会有突然和大幅度的下降，如下面的代码和输出所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In summary, anomalous sample values can be detected when the PDF of the normal
    distribution model returned by the anomaly detector described previously has a
    large difference from its previous values. We can extend this implementation to
    check some kind of threshold value so that the result is quantized. The system
    thus detects an anomaly only when this threshold value of the PDF is crossed.
    When dealing with real-world data, all we would have to do is somehow represent
    the feature values we are modeling as a map and determine the threshold value
    to use via trial-and-error method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当之前描述的异常检测器返回的正常分布模型的 PDF 与其先前值有较大差异时，可以检测到异常样本值。我们可以扩展此实现以检查某种阈值值，以便结果被量化。因此，系统仅在
    PDF 的此阈值值被越过时检测到异常。在处理现实世界数据时，我们只需以某种方式表示我们正在建模的特征值作为映射，并通过试错法确定要使用的阈值值。
- en: 'Anomaly detection can be used in both supervised and unsupervised machine learning
    environments. In supervised learning, the sample data will be labeled. Interestingly,
    we could also use binary classification, among other supervised learning techniques,
    to model this kind of data. We can choose between anomaly detection and classification
    to model labeled data by using the following guidelines:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 异常检测可以用于监督学习和无监督机器学习环境。在监督学习中，样本数据将被标记。有趣的是，我们还可以使用二元分类等监督学习技术来模拟这类数据。我们可以通过以下指南在异常检测和分类之间选择来模拟标记数据：
- en: Choose binary classification when the number of positive and negative examples
    in the sample data is almost equal. Conversely, choose anomaly detection if there
    are a very small number of positive or negative examples in the training data.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当样本数据中正例和负例的数量几乎相等时，选择二元分类。相反，如果训练数据中正例或负例的数量非常少，则选择异常检测。
- en: Choose anomaly detection when there are many sparse classes and a few dense
    classes in the training data.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择异常检测，当训练数据中有许多稀疏类别和少数密集类别时。
- en: Choose supervised learning techniques such as classification when positive samples
    that may be encountered by the trained model will be similar to positive samples
    that the model has already seen.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当训练模型可能遇到的正样本将与模型已经看到的正样本相似时，选择监督学习技术，如分类。
- en: Building recommendation systems
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建推荐系统
- en: Recommendation systems are information filtering systems whose goal is to provide
    its users with useful recommendations. To determine these recommendations, a recommendation
    system can use historical data about the user's activity, or it can use recommendations
    that other users liked (for more information, refer to "A Taxonomy of Recommender
    Agents on the Internet"). These two approaches are the basis of the two types
    of algorithms used by recommendation systems—**content-based filtering** and **collaborative
    filtering**. Interestingly, some recommendation systems even use a combination
    of these two techniques to provide users with recommendations. Both these techniques
    aim to recommend items, or domain objects that are managed or exchanged by user-centric
    applications, to its users. Such applications include several websites that provide
    users with online content and information, such as online shopping and media.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统是信息过滤系统，其目标是向用户提供有用的推荐。为了确定这些推荐，推荐系统可以使用关于用户活动的历史数据，或者它可以使用其他用户喜欢的推荐（更多信息，请参阅“互联网上推荐代理的分类”）。这两种方法构成了推荐系统使用的两种类型算法的基础——**基于内容的过滤**和**协同过滤**。有趣的是，一些推荐系统甚至使用这两种技术的组合来向用户提供推荐。这两种技术都旨在向用户推荐项目，或由以用户为中心的应用程序管理或交换的领域对象。这类应用包括提供在线内容和信息的多个网站，例如在线购物和媒体。
- en: In *content-based filtering*, recommendations are determined by finding similar
    items by using a particular user's rating. Each item is represented as a set of
    discrete features or characteristics, and each item is also rated by several users.
    Thus, for each user, we have several sets of input variables to represent the
    characteristics of each item and a set of output variables that represent the
    user's rating for the item. This information can be used to recommend items with
    similar features or characteristics as items that were previously rated by a user.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在**基于内容的过滤**中，推荐是通过使用特定用户的评分来找到相似项目来确定的。每个项目都表示为一组离散的特征或特性，每个项目也被几个用户评分。因此，对于每个用户，我们都有几组输入变量来表示每个项目的特征，以及一组输出变量来表示用户对该项目的评分。这些信息可以用来推荐具有与之前评分的项目相似特征或特性的项目。
- en: '*Collaborative filtering* methods are based on collecting data about a given
    user''s behavior, activities, or preferences and using this information to recommend
    items to users. The recommendation is based on how similar a user''s behavior
    is to that of other users. In effect, a user''s recommendations are based on her
    past behavior as well as decisions made by other users in the system. A collaborative
    filtering technique will use the preferences of similar users to determine the
    features of all available items in the system, and then it will recommend items
    with similar features as the items that a given set of users are observed to like.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*协同过滤*方法基于收集关于特定用户的行为、活动或偏好的数据，并使用这些信息向用户推荐项目。推荐基于用户的行为与其他用户行为相似的程度。实际上，用户的推荐基于她的过去行为以及系统中其他用户所做的决策。协同过滤技术将使用类似用户的偏好来确定系统中所有可用项目的特征，然后它会推荐具有相似特征的项目，这些特征是观察到的特定用户群体所喜欢的。'
- en: Content-based filtering
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: As we mentioned earlier, content-based filtering systems provide users with
    recommendations based on their past behavior as well as the characteristics of
    items that are positively rated or liked by the given user. We can also take into
    account the items that were disliked by the given user. An item is generally represented
    by several discrete attributes. These attributes are analogous to the input variables
    or features of a classification or linear regression based machine learning model.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，基于内容的过滤系统为用户提供基于他们过去行为以及特定用户积极评价或喜欢的项目特征的推荐。我们还可以考虑特定用户不喜欢的项目。一个项目通常由几个离散属性表示。这些属性类似于分类或基于线性回归的机器学习模型的输入变量或特征。
- en: 'For example, suppose we want to build a recommendation system that uses content-based
    filtering to recommend online products to its users. Each product can be characterized
    and identified by several known characteristics, and users can provide a rating
    for each characteristic of every product. The feature values of the products can
    have values between the 0 and 10, and the ratings provided by users for the products
    will have values within the range of 0 and 5\. We can visualize the sample data
    for this recommendation system in a tabular representation, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要构建一个推荐系统，该系统使用基于内容的过滤来向其用户推荐在线产品。每个产品都可以通过几个已知特征来表征和识别，并且用户可以为每个产品的每个特征提供评分。产品的特征值可以在0到10之间，用户为产品提供的评分将在0到5的范围内。我们可以通过以下表格表示来可视化此推荐系统的样本数据：
- en: '![Content-based filtering](img/4351OS_08_08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![基于内容的过滤](img/4351OS_08_08.jpg)'
- en: 'In the preceding table, the system has ![Content-based filtering](img/4351OS_08_09.jpg)
    products and ![Content-based filtering](img/4351OS_08_10.jpg) users. Each product
    is defined by ![Content-based filtering](img/4351OS_08_11.jpg) features, each
    of which will have a value in the range of 0 and 10, and each product is also
    rated by a user. Let the rating of each product ![Content-based filtering](img/4351OS_08_12.jpg)
    by a user ![Content-based filtering](img/4351OS_08_13.jpg) be represented as ![Content-based
    filtering](img/4351OS_08_14.jpg). Using the input values ![Content-based filtering](img/4351OS_08_15.jpg),
    or rather the input vector ![Content-based filtering](img/4351OS_08_16.jpg), and
    the rating ![Content-based filtering](img/4351OS_08_14.jpg) of a user ![Content-based
    filtering](img/4351OS_08_13.jpg), we can estimate a parameter vector ![Content-based
    filtering](img/4351OS_08_17.jpg) that we can use to to predict a user''s rating.
    Thus, content-based filtering in fact applies a copy of linear regression to each
    user''s rating and each product''s feature values to estimate a regression model
    that can in turn be used to estimate the users rating for some unrated products.
    In effect, we learn the parameter ![Content-based filtering](img/4351OS_08_17.jpg)
    using the independent variables ![Content-based filtering](img/4351OS_08_16.jpg)
    and the dependent variable ![Content-based filtering](img/4351OS_08_14.jpg) and
    for all the users the system. Using the estimated parameter ![Content-based filtering](img/4351OS_08_17.jpg)
    and some given values for the independent variables, we can predict the value
    of the dependent variable for any given user. The optimization problem for content-based
    filtering can thus be expressed as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个表中，系统有![基于内容的过滤](img/4351OS_08_09.jpg)个产品以及![基于内容的过滤](img/4351OS_08_10.jpg)个用户。每个产品由![基于内容的过滤](img/4351OS_08_11.jpg)个特征定义，每个特征都将有一个在0到10之间的值，并且每个产品也会被用户评分。设用户![基于内容的过滤](img/4351OS_08_13.jpg)对产品![基于内容的过滤](img/4351OS_08_12.jpg)的评分表示为![基于内容的过滤](img/4351OS_08_14.jpg)。使用输入值![基于内容的过滤](img/4351OS_08_15.jpg)，或者说输入向量![基于内容的过滤](img/4351OS_08_16.jpg)，以及用户![基于内容的过滤](img/4351OS_08_13.jpg)的评分![基于内容的过滤](img/4351OS_08_14.jpg)，我们可以估计一个参数向量![基于内容的过滤](img/4351OS_08_17.jpg)，我们可以使用它来预测用户的评分。因此，基于内容的过滤实际上将线性回归的副本应用于每个用户的评分和每个产品的特征值，以估计一个回归模型，该模型反过来可以用来估计一些未评分产品的用户评分。实际上，我们使用独立变量![基于内容的过滤](img/4351OS_08_16.jpg)和因变量![基于内容的过滤](img/4351OS_08_14.jpg)以及系统中所有用户来学习参数![基于内容的过滤](img/4351OS_08_17.jpg)。使用估计的参数![基于内容的过滤](img/4351OS_08_17.jpg)和一些独立变量的给定值，我们可以预测任何给定用户的因变量值。因此，基于内容的过滤的优化问题可以表示如下：
- en: '![Content-based filtering](img/4351OS_08_18.jpg)![Content-based filtering](img/4351OS_08_19.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![基于内容的过滤](img/4351OS_08_18.jpg)![基于内容的过滤](img/4351OS_08_19.jpg)'
- en: 'The optimization problem defined in the preceding equation can be applied to
    all users of the system to produce the following optimization problem for Uusers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个方程中定义的优化问题可以应用于系统的所有用户，以产生以下针对Uusers的优化问题：
- en: '![Content-based filtering](img/4351OS_08_21.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![基于内容的过滤](img/4351OS_08_21.jpg)'
- en: In simple terms, the parameter vector ![Content-based filtering](img/4351OS_08_20.jpg)
    tries to scale or transform the input variables to match the output variable of
    the model. The second term that is added is for *regularization*. Interestingly,
    the optimization problem defined in the receding equation is analogous to that
    of linear regression, and thus content-based filtering can be considered as an
    extension of linear regression.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，参数向量![基于内容的过滤](img/4351OS_08_20.jpg)试图缩放或转换输入变量以匹配模型的输出变量。添加的第二项是为了*正则化*。有趣的是，在递减方程中定义的优化问题与线性回归类似，因此基于内容的过滤可以被视为线性回归的扩展。
- en: The key issue with content-based filtering is whether a given recommendation
    system can learn from a user's preferences or ratings. Direct feedback can be
    used by asking for the rating of items in the system that they like, although
    these ratings can also be implied from a user's past behavior. Also, a content-based
    filtering system that is trained for a set of users and a specific category of
    items cannot be used to predict the same user's ratings for a different category
    of items. For example, it's a difficult problem to use a user's preference for
    news to predict the user's liking for online shopping products.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的过滤的关键问题是给定的推荐系统是否能够从用户的偏好或评分中学习。可以通过要求用户对系统中他们喜欢的项目进行评分来使用直接反馈，尽管这些评分也可以从用户的历史行为中隐含得出。此外，为特定用户和特定项目类别训练的基于内容的过滤系统不能用来预测同一用户对其他类别项目的评分。例如，使用用户对新闻的偏好来预测用户对在线购物产品的喜好是一个难题。
- en: Collaborative filtering
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: The other major form of recommendation is *collaborative filtering*, in which
    data about the behavior of several users with similar interests is analyzed and
    used to predict recommendations for these users. The main advantage of this technique
    is that the system does not rely on the values for the feature variables of its
    items, and consequently such a system does not need to know about the characteristics
    of the items that are provided by it. The features of the items are in fact determined
    dynamically using the users rating for these items and the behavior of the system
    users. We will examine more about the advantage in the latter part of this section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种主要的推荐形式是**协同过滤**，在这种形式中，分析具有相似兴趣的多个用户的行为数据，并用于预测这些用户的推荐。这种技术的主要优势是系统不依赖于其项目特征变量的值，因此这样的系统不需要了解它提供的项目的特征。实际上，项目的特征是通过使用用户对项目的评分和系统用户的行怍动态确定的。我们将在本节的后面部分更详细地探讨这种优势。
- en: 'An essential part of the model used by collaborative filtering depends on the
    behavior of its users. To build this part of the model, we can use the following
    methods to determine the user''s rating for the items in the model in an explicit
    manner:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤模型使用的关键部分依赖于其用户的行为。为了构建模型的一部分，我们可以使用以下方法以显式方式确定模型中项目的用户评分：
- en: Asking the users to rate the items on a specific scale
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求用户对项目进行特定尺度的评分
- en: Asking users to mark items as favorites
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求用户将项目标记为收藏夹
- en: Presenting a small number of items to users and asking them to order them according
    to how much they like or dislike these items
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户展示少量项目，并要求他们根据对项目的喜好或厌恶程度进行排序
- en: Asking users to create a list of items or the kinds of items that they like.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求用户创建他们喜欢的项目或项目类型的列表。
- en: 'Alternatively, this information could also be gathered from a user''s activity
    in an implicit fashion. Examples of this method of modeling the behavior of a
    system''s users with a given set of items or products are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这些信息也可以通过用户的活动以隐式的方式收集。以下是一些使用给定项目或产品集建模系统用户行为的示例方法：
- en: Observing the items that a user views
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察用户查看的项目
- en: Analyzing the number of times a particular user views
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析特定用户查看特定项目的次数
- en: Analyzing the user's social network and discovering users with similar interests
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析用户的社会网络，并发现具有相似兴趣的用户
- en: 'For example, consider a recommendation system for an online shopping example
    that we discussed in the previous section. We we can use collaborative filtering
    to dynamically determine the feature values of the products available and predict
    the products that the user will be interested in. The sample data for such a system
    that uses collaborative filtering can be visualized by using the following table:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个在线购物推荐系统，这是我们之前章节讨论过的。我们可以使用协同过滤动态确定产品的特征值，并预测用户可能感兴趣的产品。使用以下表格可以可视化此类使用协同过滤的系统样本数据：
- en: '![Collaborative filtering](img/4351OS_08_22.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![协同过滤](img/4351OS_08_22.jpg)'
- en: In the data shown in the preceding table, the features of the products are unknown.
    The only available data is the ratings of the users and the behavior models of
    the users.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前表中显示的数据中，产品的特征是未知的。唯一可用的数据是用户的评分和用户的行为模型。
- en: 'The optimization problem for collaborative filtering and a product''s user
    can be expressed as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤和产品用户的优化问题可以表达如下：
- en: '![Collaborative filtering](img/4351OS_08_23.jpg)![Collaborative filtering](img/4351OS_08_24.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![协同过滤](img/4351OS_08_23.jpg)![协同过滤](img/4351OS_08_24.jpg)'
- en: 'The preceding equation is seen to be the converse of the optimization problem
    that we defined for content-based filtering. Instead of estimating the parameter''s
    vector ![Collaborative filtering](img/4351OS_08_17.jpg), collaborative filtering
    seeks to determine the values of the features of a product ![Collaborative filtering](img/4351OS_08_16.jpg).
    Similarly, we can define the optimization problem for multiple users as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方程式被视为我们为基于内容的过滤定义的优化问题的逆。不是估计参数向量![协同过滤](img/4351OS_08_17.jpg)，协同过滤试图确定产品的特征值![协同过滤](img/4351OS_08_16.jpg)。同样，我们可以如下定义多个用户的优化问题：
- en: '![Collaborative filtering](img/4351OS_08_25.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![协同过滤](img/4351OS_08_25.jpg)'
- en: Using collaborative filtering, we can estimate the features of the products
    ![Collaborative filtering](img/4351OS_08_26.jpg),![Collaborative filtering](img/4351OS_08_27.jpg),
    and then use these feature values to improve the behavior model of the users ![Collaborative
    filtering](img/4351OS_08_28.jpg). The improved user behavior models can then be
    used to again produce better feature values of the items. This process is then
    repeated until the feature values and behavior models converge to some appropriate
    values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协同过滤，我们可以估计产品的特征![协同过滤](img/4351OS_08_26.jpg)，![协同过滤](img/4351OS_08_27.jpg)，然后使用这些特征值来改进用户的行为模型![协同过滤](img/4351OS_08_28.jpg)。改进的用户行为模型可以再次用于生成物品的更好的特征值。这个过程然后重复进行，直到特征值和行为模型收敛到某些适当的值。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in this process, the algorithm never needed to know the initial feature
    values of its items, and it only needed to initially estimate the behavior model
    of the user to provide the user with useful recommendations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个过程中，算法从未需要知道其物品的初始特征值，它只需要最初估计用户的行为模型，以便为用户提供有用的推荐。
- en: 'Collaborative filtering can also be combined with content-based filtering in
    some special cases. Such approaches are called **hybrid methods** of recommendation.
    There are several ways in which we can combine or hybridize the two models of
    recommendation, and they are listed as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些特殊情况下，协同过滤也可以与基于内容的过滤相结合。这种方法被称为推荐系统的**混合方法**。我们可以以几种方式结合或混合两种推荐模型，具体如下：
- en: Results from the two models can be combined numerically in a weighted manner
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个模型的结果可以通过加权方式在数值上进行组合
- en: Either one of these two models can be chosen appropriately at a given time
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定时间可以选择这两个模型中的任何一个
- en: Show users a combined result of recommendations from the two models
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户展示两个模型推荐结果的组合
- en: Using the Slope One algorithm
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Slope One算法
- en: We will now study the Slope One algorithm for collaborative filtering. Also,
    we will demonstrate how we can implement it concisely in Clojure.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将研究协同过滤的Slope One算法。此外，我们还将展示如何在Clojure中简洁地实现它。
- en: The Slope One algorithm is one of the simplest forms of *item-based collaborative
    filtering*, which is essentially a collaborative filtering technique in which
    the users explicitly rate each item they like (for more information, refer to
    *Slope One Predictors for Online Rating-Based Collaborative Filtering*). Generally,
    item-based collaborative filtering techniques will use the user's ratings and
    past behavior of users to estimate a simple regression model for each user. Thus,
    we estimate a function ![Using the Slope One algorithm](img/4351OS_08_29.jpg)
    for all users ![Using the Slope One algorithm](img/4351OS_08_13.jpg) in the system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Slope One算法是*基于物品的协同过滤*最简单形式之一，它本质上是一种协同过滤技术，其中用户明确地对每个他们喜欢的物品进行评分（更多信息，请参阅*基于在线评分的协同过滤的Slope
    One预测器*）。通常，基于物品的协同过滤技术将使用用户的评分和过去用户的行为来估计每个用户的简单回归模型。因此，我们为系统中的所有用户![使用Slope
    One算法](img/4351OS_08_29.jpg)![使用Slope One算法](img/4351OS_08_13.jpg)估计一个函数。
- en: Slope One algorithm uses a simpler predictor ![Using the Slope One algorithm](img/4351OS_08_30.jpg)
    to model the regression pattern of a user's behavior, and is thus less computationally
    expensive. The parameter ![Using the Slope One algorithm](img/4351OS_08_31.jpg)
    can be estimated by calculating the differences in user ratings between two items.
    Since the definition of the Slope One algorithm is simple, it can be implemented
    easily and efficiently. Interestingly, this algorithm is less susceptible to overfitting
    than other collaborative filtering techniques.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Slope One 算法使用一个更简单的预测器 ![使用 Slope One 算法](img/4351OS_08_30.jpg) 来模拟用户的回归行为模式，因此计算成本更低。参数
    ![使用 Slope One 算法](img/4351OS_08_31.jpg) 可以通过计算两个项目之间用户评分的差异来估计。由于 Slope One 算法的定义简单，它可以轻松高效地实现。有趣的是，这个算法比其他协同过滤技术更不容易过拟合。
- en: 'Consider a simple recommendation system with two items and two users. We can
    visualize this sample data with the following table:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的推荐系统，包含两个项目和两个用户。我们可以用以下表格来可视化这些样本数据：
- en: '![Using the Slope One algorithm](img/4351OS_08_32.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Slope One 算法](img/4351OS_08_32.jpg)'
- en: In the data shown in the preceding table, the difference in the ratings of **Item
    A** and **Item B** can be found by using the ratings provided by **User 1**. This
    difference is found to be ![Using the Slope One algorithm](img/4351OS_08_33.jpg).
    Thus, we can add this difference to the rating of **Item A** by **User 2** to
    predict his/her rating of **Item B**, which is equal to ![Using the Slope One
    algorithm](img/4351OS_08_34.jpg).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面表格中显示的数据中，可以通过使用 **用户 1** 提供的评分来找到 **项目 A** 和 **项目 B** 之间的评分差异。这个差异是 ![使用
    Slope One 算法](img/4351OS_08_33.jpg)。因此，我们可以将这个差异加到 **用户 2** 对 **项目 A** 的评分上，以预测他对
    **项目 B** 的评分，这个评分等于 ![使用 Slope One 算法](img/4351OS_08_34.jpg)。
- en: 'Let''s extend the preceding example to three items and three users. The table
    for this data can be visualized as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的例子扩展到三个项目和三个用户。这个数据对应的表格可以可视化如下：
- en: '![Using the Slope One algorithm](img/4351OS_08_35.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Slope One 算法](img/4351OS_08_35.jpg)'
- en: In this example, the average difference in ratings between **Item A** and **Item
    B** for **User 2** (-1) and **User 1** (+2) is ![Using the Slope One algorithm](img/4351OS_08_36.jpg).
    Hence, on average, **Item A** is rated better than **Item B** by ![Using the Slope
    One algorithm](img/4351OS_08_37.jpg). Similarly, the average rating difference
    between **Item A** and **Item C** is ![Using the Slope One algorithm](img/4351OS_08_38.jpg).
    We can predict the rating of **User 3** for **Item A** using his/her rating for
    **Item B** and the average difference of ratings for **Item A** and **Item B**.
    This value comes out to ![Using the Slope One algorithm](img/4351OS_08_39.jpg).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**项目 A** 和 **项目 B** 之间对于 **用户 2** (-1) 和 **用户 1** (+2) 的评分差异的平均值是 ![使用
    Slope One 算法](img/4351OS_08_36.jpg)。因此，平均而言，**项目 A** 的评分比 **项目 B** 高 ![使用 Slope
    One 算法](img/4351OS_08_37.jpg)。同样，**项目 A** 和 **项目 C** 之间的平均评分差异是 ![使用 Slope One
    算法](img/4351OS_08_38.jpg)。我们可以使用 **用户 3** 对 **项目 B** 的评分以及 **项目 A** 和 **项目 B**
    的评分差异的平均值来预测 **用户 3** 对 **项目 A** 的评分。这个值是 ![使用 Slope One 算法](img/4351OS_08_39.jpg)。
- en: 'We will now describe a concise implementation the Slope One algorithm in Clojure.
    First off, we need to define our sample data. This can be done using a nested
    map, as shown in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将描述一个简洁的 Slope One 算法在 Clojure 中的实现。首先，我们需要定义我们的样本数据。这可以通过使用嵌套映射来完成，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code shown, we bind the value `nil` to the `?` symbol, and
    use it to define a nested map `data`, in which each key represents a user and
    its value represents a map of the user''s ratings with the item names as the keys.
    We will define some of the following utility methods to help us manipulate the
    nested map represented by `data`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面显示的代码中，我们将值 `nil` 绑定到 `?` 符号上，并使用它来定义嵌套映射 `data`，其中每个键代表一个用户，其值代表一个映射，该映射以项目名称作为键，包含用户的评分。我们将定义以下一些实用方法来帮助我们操作由
    `data` 表示的嵌套映射：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `flatten-to-vec` function defined in the preceding code simply converts
    a map to a flat vector using the `reduce` and `conj` functions. We can also define
    `flatten-to-vec`, by using a functional composition of the standard `vec`, `flatten`,
    and `seq` functions, as `(def flatten-to-vec (comp vec flatten seq))`. Since we
    are dealing with maps, we can define some of the following functions to map any
    function to the values of these maps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中定义的 `flatten-to-vec` 函数简单地将映射转换为平面向量，使用 `reduce` 和 `conj` 函数。我们也可以通过使用标准
    `vec`、`flatten` 和 `seq` 函数的功能组合来定义 `flatten-to-vec`，即 `(def flatten-to-vec (comp
    vec flatten seq))`。由于我们处理的是映射，我们可以定义以下一些函数，将任何函数映射到这些映射的值：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `map-vals` function defined in the preceding code can be used to mutate
    the values of a given map. This function uses the `assoc!` function to replace
    the value stored by a given key in the map, and it uses the `reduce` function
    to compose and apply the `assoc!` function to all the key-value pairs in the map.
    In Clojure, most collections, including maps, are persistent and immutable. Note
    the use of the `transient` function to convert a persistent and immutable map
    into a mutable one and the use of the `persistent!` function that converts a transient
    mutable collection to a persistent one. By isolating mutation, the performance
    of this function is improved while retaining the guarantee of immutability for
    the code that uses this function. The `map-nested-vals` function defined in the
    preceding code simply applies the `map-vals` function to the second level values
    in a nested map.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中定义的 `map-vals` 函数可以用来修改给定映射的值。此函数使用 `assoc!` 函数替换映射中给定键存储的值，并使用 `reduce`
    函数组合并应用 `assoc!` 函数到映射中的所有键值对。在 Clojure 中，大多数集合，包括映射，都是持久和不可变的。注意使用 `transient`
    函数将持久和不可变的映射转换为可变的，以及使用 `persistent!` 函数将瞬态可变集合转换为持久的。通过隔离修改，该函数的性能得到提高，同时保留了使用此函数的代码不可变性的保证。前面代码中定义的
    `map-nested-vals` 函数简单地将 `map-vals` 函数应用于嵌套映射的第二级值。
- en: 'We can examine the behavior of the `map-vals` and `map-nested-vals` functions
    in the REPL as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 REPL 中检查 `map-vals` 和 `map-nested-vals` 函数的行为，如下所示：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As shown the preceding REPL output, the `inc` function is applied to the values
    of maps `{:foo 1 :bar 2}` and `{:foo {:bar 3}}`. We now define a function to produce
    a trained model from the sample data by using the Slope One algorithm, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个 REPL 输出所示，`inc` 函数被应用于映射 `{:foo 1 :bar 2}` 和 `{:foo {:bar 3}}` 的值。我们现在定义一个函数，通过使用
    Slope One 算法从样本数据生成一个训练模型，如下所示：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The train function defined in the preceding code first finds the differences
    between the ratings of all the items in the model using the `for` macro, and then
    it adds the frequencies of ratings of the items and the differences in their ratings
    using the `update-fn` closure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中定义的 `train` 函数首先使用 `for` 宏找出模型中所有项目的评分差异，然后使用 `update-fn` 封闭调用添加项目的评分频率及其评分差异。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between a function and a macro is that a macro doesn't evaluate
    its parameters while being executed. Also, macros are resolved and expanded at
    compile time and functions are called at runtime.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和宏之间的主要区别在于，宏在执行时不会评估其参数。此外，宏在编译时解析和展开，而函数在运行时调用。
- en: 'The `update-fn` function uses the `update-in` function to replace the value
    of a key in a map. Note the use of the `fnil` function, which essentially returns
    a function that checks for the value `nil` and replaces it with the second argument.
    This is used to treat the values represented by the `?` symbol that has the value
    `nil` in the nested map data. Lastly, the `train` function applies the `map-nested-vals`
    and `get-in` functions to the map of rating differences returned in the previous
    step. Finally, it returns a map with the keys `:freqs` and `:differences`, which
    contain maps that represent the frequencies of items and differences in ratings
    with respect to other items in the model respectively. We can now use this trained
    model to predict the ratings of the given items by various users. To do this,
    we will implement a function in the following code that uses the value returned
    by the `train` function defined in the preceding code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`update-fn`函数使用`update-in`函数来替换映射中的一个键的值。注意`fnil`函数的使用，它本质上返回一个检查值`nil`并将其替换为第二个参数的函数。这用于处理在嵌套映射数据中表示的由`?`符号表示的值，该符号在嵌套映射中的值为`nil`。最后，`train`函数将`map-nested-vals`和`get-in`函数应用于前一步返回的评分差异映射。最后，它返回一个包含`:freqs`和`:differences`键的映射，这些键包含表示项目频率和相对于模型中其他项目的评分差异的映射。现在我们可以使用这个训练好的模型来预测不同用户对给定项目的评分。为此，我们将在以下代码中实现一个函数，该函数使用前一个代码中定义的`train`函数返回的值：'
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `predict` function defined in the preceding code uses the `get-in` function
    to retrieve the sum of frequencies and differences of each item in the maps returned
    by the `train` function. This function then averages these rating differences
    by using a composition of the `reduce` and `/` (division) functions. The behavior
    of the `predict` function can be examined in the REPL, as shown in the following
    code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码中定义的`predict`函数使用`get-in`函数检索由`train`函数返回的映射中每个项目的频率和差异的总和。然后，该函数通过使用`reduce`和`/`（除法）函数的组合来平均这些评分差异。`predict`函数的行为可以在REPL中检查，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As shown in the preceding REPL output, the `predict` function used the value
    returned by the `train` function to predict the rating of `Item B` by a user who
    has given `Item A` a rating of `2`. The `predict` function estimates the rating
    of `Item B` as `3/2`. We can now implement a function in the following code that
    wraps around the `predict` function to find the ratings of all items in our model:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个REPL输出所示，`predict`函数使用了`train`函数返回的值来预测一个给过`Item A`评分为`2`的用户对`Item B`的评分。`predict`函数估计`Item
    B`的评分为`3/2`。现在我们可以在以下代码中实现一个函数，该函数封装`predict`函数以找到模型中所有项目的评分：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `mapmap` function defined in the preceding code simply applied two functions
    to a given sequence and returns a map with keys that are created using the first
    function `kf` and with a value generated by the second function `vf`. If only
    a single function is passed to the `mapmap` function, it uses the `identity` function
    to generate keys in the map returned by it. The `known-items` function defined
    in the preceding code will determine all items in a model using the keys function
    on the map represented by the :`differences` key in the value returned by the
    `train` function. Finally, the `predictions` function uses the value returned
    by the `train` and `known-items` functions to determine all items in the model
    and then predict all unrated items for a particular user. The function also takes
    an optional third argument, which is a vector of the item names whose ratings
    are to be predicted, in order to return the predictions of all items with names
    present in the vector `items`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码中定义的`mapmap`函数简单地将两个函数应用于给定的序列，并返回一个映射，其键由第一个函数`kf`创建，其值由第二个函数`vf`生成。如果将单个函数传递给`mapmap`函数，它将使用`identity`函数生成映射返回的键。前一个代码中定义的`known-items`函数将使用映射的键函数确定模型中的所有项目，该映射由`train`函数返回的值中的`:differences`键表示。最后，`predictions`函数使用`train`和`known-items`函数返回的值来确定模型中的所有项目，然后预测特定用户的所有未评分项目。该函数还接受一个可选的第三个参数，即要预测评分的项目名称的向量，以便返回向量`items`中存在的所有项目的预测。
- en: 'Now, we can examine the behavior of the preceding function in the REPL, as
    follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在REPL中检查前面函数的行为，如下所示：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As shown in the preceding output, the `known-items` function returns the names
    of all items in the model. We can now try out the predictions function, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述输出所示，`known-items`函数返回模型中所有项目的名称。现在我们可以尝试使用predictions函数，如下所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that when we skip the last optional parameter of the `predictions` function,
    the map returned by this function will contain all items that are not previously
    rated by a particular user. This can be asserted in the REPL by using the `keys`
    function, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们跳过`predictions`函数的最后一个可选参数时，该函数返回的映射将包含所有尚未被特定用户评价的项目。这可以通过在REPL中使用`keys`函数来验证，如下所示：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To conclude, we have demonstrated how we can implement the Slope One algorithm
    using nested maps and standard Clojure functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们展示了如何使用嵌套映射和标准Clojure函数实现Slope One算法。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed anomaly detection and recommendation. We also
    implemented a simple anomaly detector and recommendation engine. The topics covered
    in this chapter can be summarized as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了异常检测和推荐。我们还实现了一个简单的异常检测器和推荐引擎。本章涵盖的主题可以总结如下：
- en: We explored anomaly detection and how we can implement an anomaly detector using
    the PDF in Clojure.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们探讨了异常检测以及如何使用Clojure中的PDF实现异常检测器。
- en: We studied recommendation systems that use both content-based and collaborative
    filtering techniques. We also studied the various optimization problems in these
    techniques.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了使用基于内容和协同过滤技术的推荐系统。我们还研究了这些技术中的各种优化问题。
- en: We also studied the Slope One algorithm, which is a form of collaborative filtering,
    and also described a concise implementation of this algorithm.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还研究了Slope One算法，这是一种协同过滤的形式，并描述了该算法的简洁实现。
- en: In the following chapter, we will discuss more applications of machine learning
    techniques that can be applied to large and complex data-centric applications.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论更多可以应用于大型和复杂以数据为中心的应用的机器学习技术的应用。
