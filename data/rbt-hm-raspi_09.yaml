- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Teleoperating a Raspberry Pi Pico Robot with Bluetooth LE
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝牙 LE 远程操作 Raspberry Pi Pico 机器人
- en: We intend for the robot we are building to be mobile. We already have the robot
    driving on the floor and able to sense and respond to its surroundings. However,
    we either rely on it blindly or are tethered to it with a laptop. Neither is quite
    what we want. What if we could get feedback while it’s untethered and roaming
    the floor?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算制造的机器人是移动的。我们已经有机器人能够在地面上行驶，能够感知并对其周围环境做出反应。然而，我们要么盲目地依赖它，要么用笔记本电脑连接到它。这两种情况都不太符合我们的需求。如果我们能够在它脱离连接并在地板上漫游时获得反馈会怎样？
- en: In this chapter, we’ll see how Bluetooth **Low Energy** (**LE**) is well suited
    to this task, allowing us to get data from the robot, use an app to graph data,
    and even remotely control our robot from our smartphone!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到蓝牙**低功耗**（**LE**）非常适合这项任务，它允许我们从机器人获取数据，使用应用程序来绘制数据图表，甚至可以从我们的智能手机上远程控制我们的机器人！
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Wireless robot connection options
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无线机器人连接选项
- en: Connecting Bluetooth LE to Raspberry Pi Pico
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将蓝牙 LE 连接到 Raspberry Pi Pico
- en: Making a Bluetooth LE sensor feed on Raspberry Pi Pico
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Raspberry Pi Pico 上制作蓝牙 LE 传感器馈电
- en: Teleoperating the robot with Bluetooth LE
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝牙 LE 远程操作机器人
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下设备：
- en: The robot from [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166), *Sensing Distances
    to Detect Objects* *with Pico*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自[*第 8 章*](B18001_08.xhtml#_idTextAnchor166)的机器人，*使用 Pico 感测距离以检测物体*
- en: An Adafruit Bluefruit LE UART Friend ADA2479
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit Bluefruit LE UART 朋友 ADA2479
- en: 1 x eight-way single-row 2.54-mm header (included with the module)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 个八位单排 2.54-mm 插头（包含在模块中）
- en: 5 x male-to-female jump wires with a 2.54-mm DuPont connector
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 条带有 2.54-mm 杜邦接头的公对母跳线
- en: Access to an Android or iOS smartphone
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以访问 Android 或 iOS 智能手机
- en: Velcro hook and loop dots
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比利牛斯钩和环点
- en: The code from previous chapters
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前几章的代码
- en: A Raspberry Pi Pico code editor such as Mu or Thonny
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 Mu 或 Thonny 之类的 Raspberry Pi Pico 代码编辑器
- en: A USB micro cable
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条 USB 微型线
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-09](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-09).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章的代码：[https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-09](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-09)。
- en: Wireless robot connection options
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无线机器人连接选项
- en: 'So far, we’ve been working with the robot tethered to our computer. We send
    code to it and use the REPL tools to see what it is doing or printing out. While
    the REPL tools can be convenient, having a wire between the computer and the robot
    is not so convenient and limits how far the robot can drive or has you running
    behind it with the laptop. The following diagram shows how we could do things:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在与连接到计算机的机器人一起工作。我们向它发送代码，并使用 REPL 工具查看它正在做什么或打印出什么。虽然 REPL 工具可能很方便，但计算机和机器人之间有电线连接并不那么方便，并且限制了机器人的行驶距离或需要你带着笔记本电脑跟在它后面。以下图表显示了我们可以如何操作：
- en: '![Figure 9.1 – Robot connections ](img/Figure_9.01_B18001.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 机器人连接](img/Figure_9.01_B18001.jpg)'
- en: Figure 9.1 – Robot connections
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 机器人连接
- en: The top part of the diagram shows things tethered with a wire. But the bottom
    part shows that the computer and the robot are not physically wired together.
    Instead, they are using wireless to send data to each other.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的上半部分显示了用线连接的物品。但下半部分显示计算机和机器人并没有物理上连接在一起。相反，它们正在使用无线方式相互发送数据。
- en: Once we are wireless, we can also consider a smartphone coming in as an alternative
    item. We can use a wireless medium to send data from the robot’s sensors or code
    to see what is going on and monitor it. We can also send control signals to take
    control and drive our robot.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现无线连接，我们也可以考虑将智能手机作为替代品。我们可以使用无线介质从机器人的传感器或代码发送数据，以查看正在发生的情况并对其进行监控。我们还可以发送控制信号来接管并驱动我们的机器人。
- en: There are several different wireless protocols we can use. All require our robot
    to have a **transceiver** – transmitter and receiver – board.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用几种不同的无线协议。所有这些都需要我们的机器人配备一个**收发器**——发射器和接收器——板。
- en: While some robot controllers, such as Raspberry Pi 4, have onboard transceivers,
    Raspberry Pi Pico does not. Therefore, we will need to add a breakout. In addition,
    they come with different protocols and different implementations of those protocols.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些机器人控制器，如 Raspberry Pi 4，具有板载收发器，但 Raspberry Pi Pico 则没有。因此，我们需要添加一个分线器。此外，它们还支持不同的协议和这些协议的不同实现。
- en: 'Which transceiver boards might we choose and why? The following table shows
    the comparison:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会选择哪些收发器板，以及为什么？以下表格显示了比较：
- en: '![Table 9.1 – Transceiver modules for Pico ](img/Table_9.01_B18001.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![表9.1 – Pico的收发器模块](img/Table_9.01_B18001.jpg)'
- en: Table 9.1 – Transceiver modules for Pico
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 – Pico的收发器模块
- en: In the preceding table, I’ve picked boards that come with onboard software stacks,
    reducing the amount of code we need. We are less concerned with speed as we don’t
    intend to send camera data; however, latency is important as we want our robot
    to respond quickly to commands and send up-to-date sensor data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，我选择了带有板载软件堆栈的板，以减少我们需要的代码量。我们不太关心速度，因为我们不打算发送相机数据；然而，延迟很重要，因为我们希望我们的机器人能够快速响应命令并发送最新的传感器数据。
- en: Support is important – we want to choose modules with good support from their
    vendors and the community. For example, Adafruit has excellent support and documentation
    for their modules, with online communities on Discord and other forums and all
    their code available on GitHub, which gives their modules a lot of credibility
    over cheaper and less well-supported options.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 支持很重要 – 我们希望选择那些从其供应商和社区获得良好支持的模块。例如，Adafruit为其模块提供了出色的支持和文档，拥有Discord和其他论坛上的在线社区，以及GitHub上所有代码的可用性，这使它们的模块比价格更低、支持更差的选项具有更多的可信度。
- en: An honorable mention must go to Raspberry Pi Pico W – a Pico with an onboard
    Wi-Fi chip. This has excellent support from the Raspberry Pi community. It has
    the added complexity of requiring you to serve up a graphing web frontend, however
    it may make a very good alternative.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico W – 带有板载Wi-Fi芯片的Pico – 值得特别一提，这个Pico得到了Raspberry Pi社区的出色支持。然而，它增加了需要你提供图形化Web前端服务的复杂性，但这可能是一个非常不错的选择。
- en: The HM-10 modules are widely available and may even be super cheap, but their
    unusual protocols mean connecting with them needs more code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: HM-10模块非常容易获得，甚至可能非常便宜，但它们不寻常的协议意味着与它们连接需要更多的代码。
- en: The choice with the most going for it here is the Adafruit Bluefruit LE board.
    It has low current usage and is small. There is a **Serial Peripheral Interface**
    (**SPI**) and a **Universal Asynchronous Receiver/Transmitter** (**UART**; defined
    in more detail as follows) version of this board. **Bluetooth LE** is a low-energy
    variant of Bluetooth, ideal for short-range communications between devices such
    as a robot and a controller. It has a range of up to 100 m. Bluetooth LE has two-thirds
    of the data rate compared to regular Bluetooth but consumes half the current when
    active. Smart software profiles allow it to frequently use low-power modes, and
    rapidly wake up when needed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最有利的选项是Adafruit Bluefruit板。它功耗低且体积小。该板有**串行外设接口**（**SPI**）和**通用异步收发传输器**（**UART**；如下所述）版本。**蓝牙LE**是蓝牙的低功耗变体，非常适合机器人与控制器等设备之间的短距离通信。其范围为100米。蓝牙LE的数据速率比常规蓝牙低三分之二，但在活动时电流消耗仅为一半。智能软件配置文件允许它频繁使用低功耗模式，并在需要时快速唤醒。
- en: UART doesn’t need much configuration and only uses two wires (as opposed to
    the three or more wires SPI or I2C uses). There is no clock line (just an agreement
    on speeds) and no address, just one-to-one device communication. We have already
    been using a USB-based UART to communicate with Raspberry Pi Pico.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: UART不需要太多配置，仅使用两根线（与SPI或I2C使用的三根或更多线相比）。没有时钟线（只有速度上的协议）和地址，只有一对一的设备通信。我们已经在使用基于USB的UART与Raspberry
    Pi Pico进行通信。
- en: We will use the Adafruit Bluefruit LE UART Friend board for simplicity in our
    project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的项目中使用Adafruit Bluefruit LE UART Friend板以简化操作。
- en: It is widely available through Adafruit directly or through distributors such
    as Pimoroni and Mouser Electronics.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过Adafruit直接或通过Pimoroni和Mouser Electronics等分销商广泛获得。
- en: Adafruit Bluefruit is an ecosystem of Bluetooth LE-based development boards,
    so there’s lots of compatible code. In addition, it works with computers and phones
    that have built-in Bluetooth LE transceivers, and Adafruit makes apps for both
    computers and phones to communicate with them. These apps will save us time, as
    other solutions require you to build your apps.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit Bluefruit是一个基于蓝牙LE的开发板生态系统，因此有很多兼容的代码。此外，它与内置蓝牙LE收发器的计算机和手机兼容，Adafruit还为计算机和手机提供了应用程序来与它们通信。这些应用程序将为我们节省时间，因为其他解决方案需要你构建自己的应用程序。
- en: We now know which module we will use. So we can make use of it, let’s take the
    Bluefruit LE UART board and connect it to our robot!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道我们将使用哪个模块了。因此，我们可以利用它，让我们拿一块Bluefruit LE UART板并将其连接到我们的机器人上！
- en: Connecting Bluetooth LE to Raspberry Pi Pico
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将蓝牙低功耗连接到Raspberry Pi Pico
- en: The Bluefruit LE UART Friend is relatively simple to wire in. First, the module
    will need headers soldered onto it, and then we can look at how to attach it to
    the robot physically and how to wire it. We will then connect to it from our robot
    and a smartphone.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Bluefruit LE UART Friend 模块相对简单，可以连接。首先，模块需要焊接上引脚头，然后我们可以看看如何将其物理连接到机器人以及如何布线。然后我们将从我们的机器人和智能手机连接到它。
- en: 'Adding Bluetooth LE will result in our robot having a block diagram as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 添加蓝牙低功耗（BLE）将使我们的机器人具有以下框图：
- en: '![Figure 9.2 – Robot block diagram with Bluetooth ](img/Figure_9.02_B18001.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 带蓝牙的机器人框图](img/Figure_9.02_B18001.jpg)'
- en: Figure 9.2 – Robot block diagram with Bluetooth
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 带蓝牙的机器人框图
- en: The preceding diagram shows the robot blocks with the additional Adafruit Bluefruit
    LE UART Friend (marked as a Bluefruit module) connected via UART to Raspberry
    Pi Pico.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了带有额外Adafruit Bluefruit LE UART Friend（标记为Bluefruit模块）的机器人模块，通过UART连接到Raspberry
    Pi Pico。
- en: Solder a set of male headers onto the board using the same techniques used for
    the modules in [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166), *Sensing Distances
    to Detect Objects* *with Pico*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与[*第8章*](B18001_08.xhtml#_idTextAnchor166)，*使用Pico检测物体距离*中模块相同的焊接技术，在板上焊接一组公头。
- en: Attaching the Bluetooth module to the robot
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将蓝牙模块连接到机器人
- en: We want to place the module above devices that are most likely to restrict and
    interfere with the Bluetooth. We created a breakout shelf in [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139),
    *Planning and Shopping for More Devices*, for this purpose.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将模块放置在最有可能限制和干扰蓝牙的设备上方。为此，我们在[*第7章*](B18001_07.xhtml#_idTextAnchor139)，*计划和购买更多设备*中创建了一个分线架。
- en: 'The following photo shows how the headers should be attached:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下照片显示了引脚头应该如何连接：
- en: '![Figure 9.3 – Adafruit Bluetooth LE UART Friend with headers ](img/Figure_9.03_B18001.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 带有引脚头的Adafruit蓝牙低功耗UART Friend](img/Figure_9.03_B18001.jpg)'
- en: Figure 9.3 – Adafruit Bluetooth LE UART Friend with headers
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 带有引脚头的Adafruit蓝牙低功耗UART Friend
- en: The previous figure shows the device with the headers. They should be soldered
    so they are standing above the pin names, facing the same way as the switch. The
    switch should be in UART mode.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图显示了带有引脚头的设备。它们应该焊接得足够高，以便在引脚名称上方，朝向与开关相同的方式。开关应处于UART模式。
- en: 'We want the attachment to be good enough not to slide around or stick out awkwardly
    due to cable tension. You could make a more permanent connection by drilling the
    appropriate holes in the shelf, but a convenient way for quick prototype platforms
    is to use Velcro (hook and loop) dots. Look at the following photo:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望附件足够牢固，不会因为电缆张力而滑动或尴尬地突出。你可以在搁板上钻孔以创建更持久的连接，但对于快速原型平台来说，使用魔术贴（钩和环）点是一个方便的方法。看看下面的照片：
- en: '![Figure 9.4 – Bluefruit module Velcro connection ](img/Figure_9.04_B18001.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – Bluefruit模块的魔术贴连接](img/Figure_9.04_B18001.jpg)'
- en: Figure 9.4 – Bluefruit module Velcro connection
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – Bluefruit模块的魔术贴连接
- en: The previous photo shows the Bluetooth breakout module with a Velcro dot ready
    to attach to the Velcro dot already attached to the robot’s shelf.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张照片显示了带有魔术贴点的蓝牙分线模块，准备连接到机器人搁板上已经连接的魔术贴点。
- en: The Velcro gives us a convenient way to attach/detach the module without it
    sliding off.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术贴为我们提供了一个方便的方法来连接/断开模块，而不会滑动掉落。
- en: Next, we need to wire the Bluetooth breakout into Raspberry Pi Pico.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将蓝牙分线板连接到Raspberry Pi Pico。
- en: Wiring the Bluetooth breakout to Raspberry Pi Pico
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将蓝牙分线板连接到Raspberry Pi Pico
- en: 'Wiring the Adafruit Bluefruit LE UART Friend module requires only five wires.
    The following photo shows the connections you will need:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 布线Adafruit Bluefruit LE UART Friend模块只需要五根线。以下照片显示了您需要的连接：
- en: '![Figure 9.5 – Connecting the Bluefruit LE module to Pico ](img/Figure_9.05_B18001.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 将Bluefruit LE模块连接到Pico](img/Figure_9.05_B18001.jpg)'
- en: Figure 9.5 – Connecting the Bluefruit LE module to Pico
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 将Bluefruit LE模块连接到Pico
- en: The preceding diagram shows, as a schematic, the connection between the Bluefruit
    module and Raspberry Pi Pico.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示以电路图的形式显示了Bluefruit模块和Raspberry Pi Pico之间的连接。
- en: 'First, connect the module to power and ground, with the VIN going to 3.3V power.
    Next, the CTS pin needs to be connected to ground to send and receive data via
    UART. The next figure shows how the TX and RX pins interact:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将模块连接到电源和地，VIN连接到3.3V电源。接下来，需要将CTS引脚连接到地，以便通过UART发送和接收数据。下一张图显示了TX和RX引脚的交互：
- en: '![Figure 9.6 – Transmit and receive pins ](img/Figure_9.06_B18001.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 发送和接收引脚](img/Figure_9.06_B18001.jpg)'
- en: Figure 9.6 – Transmit and receive pins
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 发送和接收引脚
- en: Pay close attention to the transmit and receive pins (shown in *Figure 9**.5*)
    on the UART. TX (transmit) on one device always goes to RX (receive) on the other.
    The most common wiring failure is to confuse these pins.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细注意UART上的发送和接收引脚（如图9.5所示）。一个设备的TX（发送）始终连接到另一个设备的RX（接收）。最常见的接线错误是混淆这些引脚。
- en: Connect the RXI (receive input) pin on the Bluefruit to PIN12, the TX (transmit)
    pin 12 on Pico, and TXD (transmit data) from Bluefruit to the RX pin 13 on Pico.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将Bluefruit的RXI（接收输入）引脚连接到Pico的PIN12，将Pico的TX（发送）引脚12连接到Bluefruit的TXD（发送数据），并将Bluefruit的TXD连接到Pico的RX引脚13。
- en: You should have now made five connections. The Bluetooth LE device is ready
    to turn on. Let’s try some code to connect to it over UART.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该已经建立了五个连接。蓝牙LE设备已准备好开启。让我们尝试一些代码来通过UART连接到它。
- en: Connecting to the Bluefruit LE device with UART
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用UART连接到Bluefruit LE设备
- en: Now we have the board connected and a smartphone ready to talk to it, how can
    we get our Raspberry Pi Pico to communicate? Let’s start by making a Hello Bluetooth
    app.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将电路板连接好，并且一部智能手机准备与之通信，那么我们如何让我们的Raspberry Pi Pico进行通信呢？让我们先制作一个Hello
    Bluetooth应用程序。
- en: Create a folder named `bluetooth-hello-world`. In a slight departure from our
    previous examples, we can name the main file `code.py`, and we only need to drag
    and drop the content of our example folders onto the CircuitPy volume.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`bluetooth-hello-world`的文件夹。与之前的示例略有不同，我们可以将主文件命名为`code.py`，我们只需要将示例文件夹的内容拖放到CircuitPy卷中。
- en: 'We start `bluetooth-hello-world/code.py` with imports for the board, and `busio`,
    which has code for the UART bus:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`bluetooth-hello-world/code.py`开始，导入`board`和`busio`，后者包含UART总线的代码：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then use the IO pins from `board` to create a UART object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用`board`中的IO引脚来创建一个UART对象：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we could have multiple UARTs on different pin combinations for other
    sensors and devices. We have specified the `9600` is the default for this device,
    as specified in its datasheet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以在不同的引脚组合上为其他传感器和设备设置多个UART。我们已指定`9600`是此设备的默认值，如其在数据表中所指定。
- en: 'We can use this in a loop to check for any input – this is how we know something
    is connected:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个循环来检查任何输入 – 这就是我们知道有什么东西连接上：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In every loop, we try reading up to 32 bytes. If we get anything (it’s not showing
    `None`), then we respond with a `hello` message. The `uart.write` method sends
    bytes, not strings, so we must encode the string to send it. Also, note the `\n`
    character at the end – this is a new line in the output.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个循环中，我们尝试读取最多32字节。如果我们得到任何东西（它不会显示`None`），那么我们就会发送一个`hello`消息。`uart.write`方法发送字节，而不是字符串，因此我们必须将字符串编码后才能发送。另外，注意末尾的`\n`字符
    – 这是在输出中的换行符。
- en: Copy this over to Pico, and it will now be running, waiting for something to
    connect. So, let’s connect something to our Pico via Bluetooth LE!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码复制到Pico上，现在它将运行，等待连接。所以，让我们通过蓝牙LE将某物连接到我们的Pico上！
- en: Connecting a smartphone
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接智能手机
- en: A smartphone makes a great client to connect to the robot and see what is going
    on. You can use an Android/iOS smartphone to connect to the Bluefruit by finding
    the Bluefruit LE Connect app on the app store appropriate to that phone.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 智能手机是连接到机器人并查看正在发生什么的绝佳客户端。您可以使用Android/iOS智能手机通过在相应手机的应用商店中找到Bluefruit LE Connect应用程序来连接到Bluefruit。
- en: This app is free. Alternatives are available at [https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/software-resources](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/software-resources),
    including desktop apps with similar functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序是免费的。在[https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/software-resources](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/software-resources)上提供了替代方案，包括具有类似功能的桌面应用程序。
- en: 'Load the Bluefruit LE Connect app. The following screenshots show what you’ll
    see:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 加载Bluefruit LE Connect应用程序。以下截图显示了您将看到的内容：
- en: '![ Figure 9.7 – Connecting to Bluetooth LE UART devices ](img/Figure_9.07_B18001.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 连接到蓝牙LE UART设备](img/Figure_9.07_B18001.jpg)'
- en: Figure 9.7 – Connecting to Bluetooth LE UART devices
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 连接到蓝牙LE UART设备
- en: In the preceding screenshots, the panel on the left shows the app. With your
    robot powered on and the Adafruit Bluefruit LE connected, you should see the device
    in the list on the app. There may be many Bluetooth devices; you can turn on the
    **Must have UART Service** toggle to filter these. You can then click the **Connect**
    button to connect to the device.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，左侧的面板显示了应用程序。当您的机器人开机并且 Adafruit Bluefruit LE 连接时，您应该在应用程序的列表中看到该设备。可能会有很多蓝牙设备；您可以通过打开
    **必须具有 UART 服务** 开关来过滤这些设备。然后您可以点击 **连接** 按钮来连接到该设备。
- en: When doing so, you should see a solid blue light on the Bluefruit board on the
    robot. You will also see the screen on the right. Bluefruit LE Connect may ask
    you to perform an update on the Bluetooth device; if so, please follow the onscreen
    instructions and accept this before proceeding. This may take a short while.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的时候，您应该在机器人的 Bluefruit 板上看到一个稳定的蓝色灯光。您还会看到右侧的屏幕。Bluefruit LE Connect 可能会要求您更新蓝牙设备；如果是这样，请按照屏幕上的说明操作并在继续之前接受此更新。这可能需要一点时间。
- en: 'Click the **UART** button in the menu to send and receive data. You should
    see screens like those shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜单中点击 **UART** 按钮以发送和接收数据。您应该会看到如下截图所示的屏幕：
- en: '![Figure 9.8 – Interacting over Bluetooth UART ](img/Figure_9.08_B18001.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 通过蓝牙 UART 交互](img/Figure_9.08_B18001.jpg)'
- en: Figure 9.8 – Interacting over Bluetooth UART
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 通过蓝牙 UART 交互
- en: The UART screen, shown in the preceding screenshot, lets you interact with and
    see output from the module. The left panel shows me typing `hello`. Try this yourself
    and hit the **Send** button to send data to the module – our code will respond
    when you send something to it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示的 UART 屏幕允许您与模块交互并查看输出。左侧面板显示我正在输入 `hello`。请尝试自己操作并点击 **发送** 按钮将数据发送到模块——当您向其发送信息时，我们的代码将做出响应。
- en: The right panel shows the robot responding with the message. It may take around
    a second to respond here. It may send the message twice if you send more than
    32 characters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧面板显示机器人响应的消息。这里可能需要大约一秒钟的响应时间。如果您发送超过 32 个字符，它可能会发送两次消息。
- en: You should now be in contact with the module. If not, try the following troubleshooting
    steps.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该与模块建立了联系。如果没有，请尝试以下故障排除步骤。
- en: Troubleshooting the Bluefruit module
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决 Bluefruit 模块的故障
- en: 'The following should get you up and running:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤可以帮助您开始使用：
- en: When it is powered up, there should be a red light on the Bluefruit module.
    If not, disconnect the power immediately and verify the power (3.3V) and ground
    wiring.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模块通电时，Bluefruit 模块上应该有一个红灯。如果没有，请立即断开电源并验证电源（3.3V）和接地线路。
- en: You should see a solid blue light when you connect to the Bluefruit device from
    the smartphone. If not, verify that you have connected to the correct device.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您从智能手机连接到 Bluefruit 设备时，您应该看到一个稳定的蓝色灯光。如果没有，请验证您是否连接到了正确的设备。
- en: If you cannot see the `Hello, Bluetooth World!` message, please verify that
    the TX and RX wiring is correct; reversing them is a common issue with the wiring.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您看不到 `Hello, Bluetooth World!` 消息，请验证 TX 和 RX 线路是否正确；线路反转是一个常见问题。
- en: You should now have this module connected and able to send data from the robot
    to a listening device. Let’s make use of this to send sensor data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该已经将这个模块连接好，并且能够从机器人发送数据到监听设备。让我们利用这个功能发送传感器数据。
- en: Getting sensor data over Bluetooth LE on Raspberry Pi Pico
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Raspberry Pi Pico 上通过蓝牙低功耗（BLE）获取传感器数据
- en: So far, you’ve tested the sensor-based examples, seeing their output in the
    console by connecting your laptop to it. However, building on our `hello world`
    example and the distance sensing in [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166),
    *Sensing Distances to Detect Objects with Pico*, we can not only see the sensor
    output over UART as text but also plot in in a graph. So, let’s get into it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经测试了基于传感器的示例，通过将笔记本电脑连接到它来查看控制台中的输出。然而，基于我们的 `hello world` 示例和第 [*8章*](B18001_08.xhtml#_idTextAnchor166)
    中的距离感应，*使用 Pico 检测物体距离的感应*，我们不仅可以以文本形式查看传感器输出，还可以将其绘制在图表中。所以，让我们开始吧。
- en: 'We’ll put this code in a folder named `bluetooth-distance-sensors`. Copy in
    the `robot.py` and `pio_encoder.py` files. We will add `code.py`. Let’s start
    with the imports, combining the sensors and bus setup:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个代码放在一个名为 `bluetooth-distance-sensors` 的文件夹中。将 `robot.py` 和 `pio_encoder.py`
    文件复制进去。我们将添加 `code.py`。让我们从导入开始，结合传感器和总线设置：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the UART now prepared, we can prepare the sensors:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在UART已经准备就绪，我们可以准备传感器：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ve set both sensors ranging and in the correct mode. We can now start a
    loop and fetch the sensor data:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了两个传感器的量程和正确的模式。现在我们可以开始一个循环并获取传感器数据：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We wait until the data is ready before fetching the distance, and we store
    the distance from both sensors. We can now send the data to the UART:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在获取距离之前等待数据准备就绪，并存储来自两个传感器的距离。现在我们可以将数据发送到UART：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use an f-string to format the data from both sensors into one line, separated
    by a comma. We must also include the end-of-line, `\n`, character again and encode
    it into bytes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用f-string将来自两个传感器的数据格式化成一行，用逗号分隔。我们还需要再次包括行结束符`\n`并将其编码成字节。
- en: 'We must then ensure the sensors on the robot are ready to take another reading:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保机器人上的传感器准备好进行下一次读取：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can wait for a little time before trying again. Add the following code outside
    the `if` block but inside the `while` loop:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次尝试之前，我们可以等待一段时间。在`if`块外但`while`循环内添加以下代码：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sleep completes the code for this example. As an overview, this loop will
    read the sensors, send data when it has a reading, and then send this over the
    UART, and it will sleep for a little time and go again.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个延时完成了本例的代码。作为一个概述，这个循环将读取传感器，在有读数时发送数据，然后通过UART发送，之后将暂停一段时间再次进行。
- en: 'If you copy this code to the robot and connect the phone with the **UART**
    menu option, you will be able to see the two numbers vary as you move things in
    front of the sensors. The following screenshot shows an example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此代码复制到机器人上，并通过**UART**菜单选项连接手机，你将能够看到随着你在传感器前移动物体，两个数值的变化。以下是一个示例截图：
- en: '![Figure 9.9 – The sensor output as text ](img/Figure_9.09_B18001.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 传感器输出文本](img/Figure_9.09_B18001.jpg)'
- en: Figure 9.9 – The sensor output as text
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 传感器输出文本
- en: The previous screenshot shows how the data is output as plain text numbers.
    You can disconnect the computer and put the robot on independent battery power,
    and you should still be able to connect to it and see the sensor readings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图显示了数据如何以纯文本数字的形式输出。你可以断开电脑，将机器人放在独立电池供电下，你应该仍然能够连接到它并看到传感器读数。
- en: This data feed is great as we have a remote view of the robot. However, we can
    now go one better and graph this data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据流很棒，因为我们有了机器人的远程视图。然而，我们现在可以更进一步，将此数据绘制成图表。
- en: Graphing the data
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制数据图表
- en: The phone app has the built-in ability to graph data in comma-separated format.
    We can use this for the output of numeric data to quickly visualize what is going
    on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 手机应用具有内置功能，可以以逗号分隔的格式绘制数据图表。我们可以用这个功能来输出数值数据，快速可视化正在发生的情况。
- en: From the UART screen, click on the back button to go back to the options menu
    for this connection. Then, click the **Plotter** button to access the plot mode.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从UART屏幕，点击返回按钮回到此连接的选项菜单。然后，点击**绘图器**按钮进入绘图模式。
- en: 'The following screenshots show how to do that:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如何进行操作：
- en: '![ Figure 9.10 – Enabling graphing ](img/Figure_9.10_B18001.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 启用绘图功能](img/Figure_9.10_B18001.jpg)'
- en: Figure 9.10 – Enabling graphing
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 启用绘图功能
- en: The preceding screenshots show how to access the graph functionality and an
    example sensor data graph.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图显示了如何访问图形功能以及一个示例传感器数据图表。
- en: The app will use any comma-separated numeric data, and I’ve tested it with six
    columns of data so far. If the output seems patchy, please ensure you allow the
    app to make an over-the-air update of the Bluetooth device, as this significantly
    improves the throughput.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用任何逗号分隔的数值数据，到目前为止我已经用六列数据进行了测试。如果输出看起来不完整，请确保你允许应用程序对蓝牙设备进行空中更新，因为这会显著提高吞吐量。
- en: We’ve seen how to get robot sensor data and use it to plot what is going on
    with the sensors. However, we might also want to use our Bluetooth services to
    take control of the robot. Let’s see how in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何获取机器人传感器数据并使用它来绘制传感器的情况。然而，我们可能还想使用我们的蓝牙服务来控制机器人。让我们在下一节中看看如何操作。
- en: Controlling the robot with Bluetooth LE
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝牙低功耗（BLE）控制机器人
- en: Bluetooth LE is a two-way medium. In this section, we’ll see how to receive
    data from the UART and, better yet, how to decode that data into control signals.
    By the end of this section, you’ll be able to drive your robot with a smartphone!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙低功耗（BLE）是一种双向媒介。在本节中，我们将了解如何从UART接收数据，以及如何将数据解码成控制信号。在本节结束时，你将能够用智能手机来控制你的机器人！
- en: Printing what we got
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印我们得到的数据
- en: Before we try to decode control packets, let’s just make a simple app to echo
    whatever shows on the Bluefruit UART out onto the Raspberry Pi Pico console.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试解码控制数据包之前，让我们先创建一个简单的应用，将 Bluefruit UART 输出的任何内容回显到 Raspberry Pi Pico 控制台中。
- en: 'Put the following code in `bluetooth-print-incoming/code.py`. We start by importing
    and setting up the UART port:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入 `bluetooth-print-incoming/code.py` 文件中。我们首先导入并设置 UART 端口：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The one difference here is that I’ve added a short timeout. Without the short
    timeout, the port will wait a full second for the number of bytes read. You might
    have noticed with the Hello world example that it took a second before you got
    the output, and this will be why. We want to get control data as soon as possible.
    There’s also a `print` statement, so we know it’s ready.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个区别是，我添加了一个短暂的超时。如果没有这个短暂的超时，端口将等待整整一秒钟来读取字节数。你可能注意到了，在 Hello World 示例中，你得到输出之前需要一秒钟的时间，这就是原因。我们希望尽快获取控制数据。还有一个
    `print` 语句，这样我们知道它已经准备好了。
- en: 'Now we have the main loop:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了主循环：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This loop reads data from the port. First, it checks whether there is data waiting,
    then tries to read up to 32 bytes and immediately prints what we got, then tries
    again.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环从端口读取数据。首先，它检查是否有等待的数据，然后尝试读取最多 32 个字节，并立即打印我们得到的内容，然后再次尝试。
- en: 'If you go back to the **UART** menu option in the phone app, you will be able
    to type messages on the phone and see them appear in the Pico console:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到手机应用中的 **UART** 菜单选项，你将能够在手机上输入信息，并看到它们出现在 Pico 控制台中：
- en: '![Figure 9.11 – Echoing incoming Bluetooth UART messages on the Pico console
    ](img/Figure_9.11_B18001.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 在 Pico 控制台中回显传入的蓝牙 UART 消息](img/Figure_9.11_B18001.jpg)'
- en: Figure 9.11 – Echoing incoming Bluetooth UART messages on the Pico console
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 在 Pico 控制台中回显传入的蓝牙 UART 消息
- en: '*Figure 9**.11* shows a screenshot of the phone on the left, ready to send
    a message. The screenshot on the right shows the message appearing in the Raspberry
    Pi Pico console. Notice the `b` prefix. This prefix means it’s a raw byte message.
    We will be able to extract our button data from this.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9.11* 显示了左侧手机的截图，准备发送消息。右侧的截图显示了消息出现在 Raspberry Pi Pico 控制台中。注意 `b` 前缀。这个前缀表示它是一个原始字节消息。我们将能够从这些消息中提取我们的按钮数据。'
- en: In the next section, let’s see how the smartphone app can use this for control.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看智能手机应用如何使用这些数据进行控制。
- en: Button control mode
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮控制模式
- en: 'On the phone app, there were several different menu modes for interacting with
    the robot. One of these is **Controller** mode. The following screenshots show
    how this looks:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在手机应用中，有几种不同的菜单模式可以与机器人交互。其中之一是 **控制器** 模式。以下截图显示了它的样子：
- en: '![Figure 9.12 – Bluefruit app Controller mode ](img/Figure_9.12_B18001.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – Bluefruit 应用控制器模式](img/Figure_9.12_B18001.jpg)'
- en: Figure 9.12 – Bluefruit app Controller mode
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – Bluefruit 应用控制器模式
- en: The screenshots show the controller mode. The leftmost screenshot shows the
    initial **Controller** app screen; from this, we pick **Control Pad**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了控制器模式。最左侧的截图显示了初始 **控制器** 应用屏幕；从这个屏幕中，我们选择 **控制板**。
- en: The screenshot in the middle shows the control pad. In this screenshot, on the
    left is a directional pad, and on the right is a set of numeric buttons. We can
    send both signals to the robot.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的截图显示了控制板。在这个截图中，左侧是一个方向垫，右侧是一组数字按钮。我们可以将这两个信号发送给机器人。
- en: The third, rightmost screenshot shows how the control signals look when printed.
    This output looks like some strange text, but that is because it is data encoded
    into a data **packet**. A packet is a chunk of data on a bus.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个、最右侧的截图显示了打印出来的控制信号的外观。这个输出看起来像一些奇怪的文本，但这是因为它是编码到数据 **包** 中的数据。一个包是在总线上的一段数据。
- en: These control signal packets encode the button that changed and whether it was
    pressed or released. Try pressing a button now with the `print-incoming` app,
    and you will see a set of control codes. They aren’t particularly human-readable,
    so we’ll need to decode them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制信号数据包编码了哪个按钮被改变以及它是被按下还是释放。现在尝试使用 `print-incoming` 应用程序按下一个按钮，你将看到一组控制代码。它们并不是特别适合人类阅读，所以我们需要解码它们。
- en: Let’s make some code to detect and decode button control packets.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来检测和解码按钮控制数据包。
- en: Decoding button control packets to drive the robot
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码按钮控制数据包以驱动机器人
- en: Adafruit has a library for specifically handling and decoding these packets.
    Copy the `adafruit_bluefruit_connect` folder from the CircuitPython bundle into
    your Pico at `CIRCUITY/lib`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit 有一个库专门用于处理和解析这些数据包。将 CircuitPython 包中的 `adafruit_bluefruit_connect`
    文件夹复制到你的 Pico 的 `CIRCUITY/lib` 目录下。
- en: 'We can import this into our code and use it to drive the robot. Create a folder
    called `bluetooth-teleoperation` on your computer. Copy the most recent `robot.py`
    and `pio_encoder.py` files into this. We’ll start a `code.py` file with the imports:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个函数导入到我们的代码中，并使用它来控制机器人。在你的电脑上创建一个名为 `bluetooth-teleoperation` 的文件夹。将最新的
    `robot.py` 和 `pio_encoder.py` 文件复制到这个文件夹中。我们将以一个 `code.py` 文件开始，并包含导入语句：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The imports are mostly familiar, but we’ve added the button packet type so we
    can decode control pad buttons. We also set up the UART to receive data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 导入部分大多数都很熟悉，但我们添加了按钮数据包类型，这样我们就可以解码控制面板按钮。我们还设置了 UART 来接收数据。
- en: 'The keys send a keypress and key release. What we don’t want is for the robot
    to receive nothing from the phone and keep driving, so we will have a stop time.
    We are also going to set an overall driving speed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘发送按键和释放信号。我们不希望机器人从手机那里什么都没有收到而继续行驶，所以我们将有一个停止时间。我们还将设置一个整体驾驶速度：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now get into the app’s main loop. The first thing we’ll do is check
    for waiting data, and if there is some, decode it as button presses:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入应用程序的主循环。我们首先会检查是否有等待的数据，如果有，就将其解码为按钮按压：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `from_stream` function will decode a button packet directly from the UART.
    It frees us from considering the byte size of that packet by trying to read the
    right number of bytes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_stream` 函数可以直接从 UART 解码按钮数据包。它使我们免于考虑该数据包的字节数，通过尝试读取正确的字节数来释放我们。'
- en: 'If we have a packet, we can check whether the button was pressed or released
    and ensure we stop the robot if it is released:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个数据包，我们可以检查按钮是被按下还是释放，并确保在释放时停止机器人：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code first checks whether you’ve pressed the button. We then started
    matching the button code with different buttons and changing motor speeds to drive
    or turn depending on which you pressed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先检查你是否按下了按钮。然后，我们开始匹配按钮代码与不同的按钮，并根据你按下的按钮来改变电机速度以驱动或转向。
- en: 'Next, we need to consider timeouts. If we have pressed a button, we should
    reset the timeout, and in the outer loop, we should check the timeout:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要考虑超时。如果我们按下了按钮，我们应该重置超时，在外部循环中，我们应该检查超时：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At the end of the `if` packet block, we add 3 seconds to the current time; this
    will be when we time out. Then, at the bottom of the `while` loop, if we’ve passed
    the `stop_at` time, we stop the robot.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 数据包块的末尾，我们将 3 秒加到当前时间上；这将是我们超时的时间。然后，在 `while` 循环的底部，如果我们已经超过了 `stop_at`
    时间，我们就停止机器人。
- en: Copy this over to CircuitPython on Pico, and you will now be able to use the
    buttons to drive the robot. You can disconnect it from the computer, turn on battery
    power, and drive it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将此复制到 Pico 的 CircuitPython 上，你现在可以使用按钮来控制机器人。你可以将其从电脑上断开连接，打开电池电源，然后驾驶它。
- en: You can now use control pad buttons to drive the robot. Press and hold a button
    and it will drive for up to 3 seconds without a further keypress; you’ll need
    to press multiple times to drive further. This 3-second timeout is a compromise
    between ensuring it doesn’t run away and making it fun to drive.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用控制面板按钮来控制机器人。按下并保持按钮，它将在没有进一步按键的情况下行驶最多 3 秒；你需要多次按下以行驶更远。这个 3 秒的超时是在确保它不会跑掉和使其驾驶有趣之间的一种折衷。
- en: Troubleshooting
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: If the robot is not responding and you have been through the previous examples,
    try this troubleshooting method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器人没有响应，并且你已经尝试了前面的示例，请尝试这种方法进行故障排除。
- en: In code like this, adding `print` statements will help. When you have the robot
    connected to the computer, you can just use `print`. Otherwise, use `uart.write(message.encode())`.
    Try adding these before the `while` loop starts and in places where the code handles
    buttons.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的代码中，添加 `print` 语句会有帮助。当你将机器人连接到电脑时，你只需使用 `print`。否则，使用 `uart.write(message.encode())`。尝试在
    `while` 循环开始之前和代码处理按钮的地方添加这些语句。
- en: By printing before the `while` loop, we know our code started (if not, we can
    connect it to the computer to look for error messages). Likewise, we can tell
    that button signals are being decoded by printing when it handles buttons.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `while` 循环之前打印，我们知道我们的代码已经开始（如果没有，我们可以将其连接到电脑以查找错误消息）。同样，我们可以在处理按钮时打印，以了解按钮信号是否被解码。
- en: Printing like this lets us narrow down where the problem is. By checking the
    lines around any output we fail to see, we can see what might be incorrect or
    whether there is wiring to verify.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式打印可以让我们缩小问题所在的范围。通过检查我们未能看到的任何输出周围的行，我们可以看到可能有什么不正确，或者是否有线路需要验证。
- en: You should now have a remote-controllable robot!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个可以远程控制的机器人！
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to hook a Bluefruit LE transceiver to our
    robot and then use it to send and receive data. We’ve seen the robot data go to
    a smartphone and data go from a smartphone back to Pico on the robot.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何将Bluefruit LE收发器连接到我们的机器人，然后使用它发送和接收数据。我们看到了机器人数据流向智能手机，数据从智能手机返回到机器人上的Pico。
- en: We then took this up a level and sent formatted data to plot sensor information
    on the phone, allowing us to remotely visualize the robot’s state.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将这一概念提升到更高层次，发送格式化的数据以在手机上绘制传感器信息，使我们能够远程可视化机器人的状态。
- en: Finally, we used the smartphone app to control and drive the robot. In the next
    chapter, we will look at the PID algorithm, a neat way to tie sensor data and
    outputs together in a feedback loop, and we’ll use our new remote data plotting
    ability to tune it!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用智能手机应用来控制和驱动机器人。在下一章中，我们将探讨PID算法，这是一种将传感器数据和输出在反馈回路中巧妙结合的方法，我们将使用我们新的远程数据绘图能力来调整它！
- en: Exercises
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'These exercises let you extend the functionality of your robot code and deepen
    your understanding of the topics:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习让你扩展机器人代码的功能，并加深对主题的理解：
- en: In the Bluetooth control app, there are four numeric buttons. Could you extend
    the control program to use these to control the robot’s speed?
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蓝牙控制应用中，有四个数字按钮。你能扩展控制程序，使用这些按钮来控制机器人的速度吗？
- en: The Bluetooth control pad app also has a little window to show messages. Try
    sending messages back from the robot code to the app to show in this window.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙控制板应用还有一个小窗口来显示消息。尝试从机器人代码发送消息到应用，以便在此窗口中显示。
- en: Could you use the plotting code with the encoder counts and plot these? Perhaps
    divide their total counts by elapsed time in the code, or reset the encoder counts
    and reread them to plot a rate per second.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否使用编码器计数并绘制这些图表？也许在代码中将它们的总计数除以经过的时间，或者重置编码器计数并重新读取它们以绘制每秒的速率。
- en: Further reading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Adafruit’s great support for the Bluefruit UART LE Friend includes a product
    page with dimensions – [https://www.adafruit.com/product/2479](https://www.adafruit.com/product/2479).
    In addition, they have content on the Adafruit learn website at [https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/),
    including material on more ways to connect and use the device, complete datasheets
    and specifications, along with additional software.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit对Bluefruit UART LE Friend的出色支持包括一个带有尺寸的产品页面 – [https://www.adafruit.com/product/2479](https://www.adafruit.com/product/2479)。此外，他们在Adafruit学习网站上提供了内容
    [https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/](https://learn.adafruit.com/introducing-the-adafruit-bluefruit-le-uart-friend/)，包括更多连接和使用设备的方法、完整的数据表和规格，以及额外的软件。
- en: Adafruit also has a `#help-with-radio` channel on their Discord with a community
    that specifically helps with problems, questions, and ideas about their transceiver
    modules.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit还在他们的Discord上有一个`#help-with-radio`频道，有一个专门帮助解决与他们的收发器模块相关的问题、疑问和想法的社区。
- en: For further information on Bluetooth LE, check out *Building Bluetooth Low Energy
    Systems* by Muhammad Usama bin Aftab. This book has a detailed dive into wireless
    network communication systems suitable for use in **Internet of Things** (**IoT**).
    IoT concepts translate well into robotics.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要了解更多关于蓝牙低功耗（Bluetooth LE）的信息，请查看穆罕默德·乌萨马·宾·阿夫塔布（Muhammad Usama bin Aftab）所著的《Building
    Bluetooth Low Energy Systems》。这本书详细探讨了适用于物联网（**IoT**）的无线网络通信系统。物联网的概念很好地转化为机器人技术。
- en: 'Part 3: Adding More Robotic Behaviors to Raspberry Pi Pico'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：为Raspberry Pi Pico添加更多机器人行为
- en: Now that we’ve seen some sensors, we can add more interesting robot behaviors.
    We will learn robot algorithms to make more use of the distance sensors and encoders.
    Then we introduce the Inertial Measurement unit. Finally, we will look at how
    to use the sensors to locate a robot in a known space.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一些传感器，我们可以添加更多有趣的机器人行为。我们将学习机器人算法，以更好地利用距离传感器和编码器。然后我们介绍惯性测量单元。最后，我们将探讨如何使用传感器在已知空间中定位机器人。
- en: 'This part contains the following chapters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B18001_10.xhtml#_idTextAnchor210), *Using the PID Algorithm
    to Follow Walls*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18001_10.xhtml#_idTextAnchor210)，*使用PID算法跟踪墙壁*'
- en: '[*Chapter 11*](B18001_11.xhtml#_idTextAnchor233), *Controlling Motion with
    Encoders on Raspberry Pi Pico*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18001_11.xhtml#_idTextAnchor233)，*在Raspberry Pi Pico上使用编码器控制运动*'
- en: '[*Chapter 12*](B18001_12.xhtml#_idTextAnchor252), *Detecting Orientation with
    an IMU on Raspberry Pi Pico*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18001_12.xhtml#_idTextAnchor252)，*在Raspberry Pi Pico上使用IMU检测方向*'
- en: '[*Chapter 13*](B18001_13.xhtml#_idTextAnchor274), *Determining Position using
    Monte Carlo Localization*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18001_13.xhtml#_idTextAnchor274), *使用蒙特卡洛定位确定位置*'
- en: '[*Chapter 14*](B18001_14.xhtml#_idTextAnchor302), *Continuing Your Journey
    – Your Next Robot*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18001_14.xhtml#_idTextAnchor302), *继续你的旅程 – 你的下一个机器人*'
