- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Learning BQ/BQML, TensorFlow, and Keras
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 BQ/BQML、TensorFlow 和 Keras
- en: 'After building the GCP and Python foundations in part one and understanding
    the ML concepts and development process in part two, we are now entering part
    three of the book: *Mastering ML in GCP*. We will start by learning how Google
    does ML for structured data and the Google ML frameworks TensorFlow and Keras.
    In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中构建了 GCP 和 Python 基础，并在第二部分中理解了机器学习概念和开发过程之后，我们现在进入本书的第三部分：*在 GCP 中精通机器学习*。我们将从学习
    Google 如何对结构化数据进行机器学习以及 Google 机器学习框架 TensorFlow 和 Keras 开始。在本章中，我们将涵盖以下主题：
- en: GCP BQ
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP BQ
- en: GCP BQML
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP BQML
- en: Introduction to TensorFlow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow 简介
- en: Introduction to Keras
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keras 简介
- en: In recent years, relational databases have been widely used in many enterprises,
    and thus structural data is a big portion of the big data available for many businesses.
    Google’s BQ and BQML play a big role in relational/structural data processing
    and analytics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，关系数据库在许多企业中得到广泛应用，因此结构化数据是许多企业可用的大数据的重要组成部分。Google 的 BQ 和 BQML 在关系/结构化数据处理和分析中发挥着重要作用。
- en: GCP BQ
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCP BQ
- en: 'As we mentioned in the *Google Cloud BigQuery* section in [*Chapter 1*](B18333_01.xhtml#_idTextAnchor015),
    *Comprehending Google Cloud Services*, BigQuery is a petabyte cloud enterprise
    data warehouse. BigQuery has the following features:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 [*第一章*](B18333_01.xhtml#_idTextAnchor015) 的 *Google Cloud BigQuery* 部分中提到的，*理解
    Google Cloud 服务*，BigQuery 是一个千兆字节云企业数据仓库。BigQuery 具有以下特点：
- en: '**Fully managed GCP service** – you do not concern yourself with the underlying
    backend data processing infrastructure, including compute, network storage, and
    other resources.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全托管 GCP 服务** – 您无需关心底层后端数据处理基础设施，包括计算、网络存储和其他资源。'
- en: '**Serverless** – you do not manage any servers in BigQuery. All of the data
    processing engines are taken care of by Google, including the invisible BigQuery
    BI Engine and ML Engine.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无服务器** – 在 BigQuery 中，您无需管理任何服务器。所有数据处理引擎都由 Google 负责，包括不可见的 BigQuery BI
    Engine 和 ML Engine。'
- en: '**Highly scalable** – it is incredibly elastic and can scale to any size, quickly
    and seamlessly.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度可扩展** – 它具有极高的弹性，可以快速无缝地扩展到任何规模。'
- en: '**Cost-effective** – you are only charged for the BigQuery resources you consume.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经济高效** – 您只需为使用的 BigQuery 资源付费。'
- en: 'In the Google Cloud big data processing pipeline, BigQuery is a key service
    for data ingestion, storing, analyzing, and visualization, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Cloud 大数据处理管道中，BigQuery 是数据摄取、存储、分析和可视化的关键服务，如下所示：
- en: 'BigQuery ingests data from data sources in three ways: archive, batch, and
    real-time streaming. With archived data, you can create a dataset with tables
    generated from data sources such as your computer, GCS, other GCP databases such
    as Bigtable, and Amazon **Simple Storage Services** (**S3**). With batch processing,
    you can load data into BigQuery from cloud storage or local storage, and the source
    data can be in the format of Avro, CSV, ORC, JSON, Parquet, or Firestore exports
    stored in GCS. Real-time events can be streamed into BigQuery. A common pattern
    is to push the events to GCP Pub/Sub, process them using a dataflow job, and ingest
    the outputs to BigQuery.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BigQuery 以三种方式从数据源摄取数据：存档、批量处理和实时流。使用存档数据，您可以从计算机、GCS、其他 GCP 数据库（如 Bigtable）和
    Amazon **简单存储服务**（**S3**）等数据源创建包含表的数据集。使用批量处理，您可以从云存储或本地存储将数据加载到 BigQuery 中，源数据可以是
    Avro、CSV、ORC、JSON、Parquet 或存储在 GCS 中的 Firestore 导出格式。实时事件可以流式传输到 BigQuery。一种常见的模式是将事件推送到
    GCP Pub/Sub，使用数据流作业进行处理，然后将输出摄取到 BigQuery 中。
- en: BigQuery stores data with scalable storage, which is ACID compliant and cost-effective.
    The separation of storage and compute in BigQuery provides high performance and
    service decoupling.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BigQuery 使用可扩展的存储来存储数据，该存储符合 ACID 标准，且经济高效。BigQuery 中的存储和计算分离提供了高性能和服务解耦。
- en: BigQuery processes data with an in-memory business intelligence engine – BigQuery
    BI Engine. Because BigQuery supports standard SQL, which is compliant with the
    ANSI SQL 2011 standard, it opens an avenue for the traditional relational databases
    and professionals to transform to BQ and BQML platforms. With SQL, BigQuery allows
    you to run queries, create reports and dashboards quickly, and export the results
    to Google Sheets or GCS.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BigQuery 使用内存中的商业智能引擎 – BigQuery BI Engine 处理数据。因为 BigQuery 支持符合 ANSI SQL 2011
    标准的标准化 SQL，这为传统的关系数据库和专业人员转向 BQ 和 BQML 平台开辟了道路。使用 SQL，BigQuery 允许您快速运行查询、创建报告和仪表板，并将结果导出到
    Google Sheets 或 GCS。
- en: With BigQuery, you can visualize your data with its integrated Google Data Studio
    tool. Leveraging the BigQuery connector in Data Studio, you can create a data
    source, a report, and charts that visualize data in BigQuery data warehouses.
    You can leverage other tools such as Google Datalab, Looker, and Tableau.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用BigQuery，您可以使用其集成的Google Data Studio工具可视化您的数据。利用Data Studio中的BigQuery连接器，您可以创建数据源、报告和图表，以可视化BigQuery数据仓库中的数据。您还可以利用其他工具，如Google
    Datalab、Looker和Tableau。
- en: You can launch the BigQuery service from the GCP web console, or the command-line
    tools from Cloud Shell – `bq` is a Python-based command-line tool. There are also
    a number of client libraries for programmatic access to BigQuery, using C#, Go,
    Java, Node.js, PHP, Python, Ruby, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GCP网页控制台启动BigQuery服务，或从Cloud Shell中的命令行工具启动 – `bq`是一个基于Python的命令行工具。还有许多客户端库，用于使用C#、Go、Java、Node.js、PHP、Python、Ruby等编程访问BigQuery。
- en: GCP BQML
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCP BQML
- en: BQML enables data scientists to create and train ML models directly in BigQuery
    using standard SQL queries. BQML improves the ML model development speed by eliminating
    the need to move data and directly using BigQuery datasets as training and testing
    datasets. BQML-trained models can be exported directly to Vertex AI (to be discussed
    in later chapters) or other cloud serving layers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: BQML允许数据科学家直接在BigQuery中使用标准SQL查询创建和训练机器学习模型。BQML通过消除移动数据的需求，并直接使用BigQuery数据集作为训练和测试数据集，提高了机器学习模型开发的速度。BQML训练的模型可以直接导出到Vertex
    AI（将在后续章节中讨论）或其他云服务层。
- en: 'BQML can be accessed and used in the following ways:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: BQML可以通过以下方式访问和使用：
- en: The GCP console via a web browser
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网页浏览器的GCP控制台
- en: The `bq` command-line tool via Google Cloud Shell or a VM shell
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Google Cloud Shell或虚拟机shell的`bq`命令行工具
- en: The BigQuery REST API
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BigQuery REST API
- en: External tools such as Jupyter Notebook
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部工具，如Jupyter Notebook
- en: As we discussed in [*Chapter 3*](B18333_03.xhtml#_idTextAnchor072), *Preparing
    for ML Development*, and [*Chapter 4*](B18333_04.xhtml#_idTextAnchor094), *ML
    Model Developing and Deploying*, the ML process includes data preparation, model
    creation and training, model validation/evaluation, and model deployment/prediction.
    Let’s go over this process with BQML.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[*第3章*](B18333_03.xhtml#_idTextAnchor072)“准备机器学习开发”和[*第4章*](B18333_04.xhtml#_idTextAnchor094)“机器学习模型开发和部署”中讨论的，机器学习过程包括数据准备、模型创建和训练、模型验证/评估以及模型部署/预测。让我们用BQML来回顾这个过程。
- en: The *first step* is data preparation. With BQML, you can prepare the training
    dataset by loading CSV files in the BigQuery console and directly running SQL
    statements after data is imported to BigQuery.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一步*是数据准备。使用BQML，您可以通过在BigQuery控制台中加载CSV文件并在数据导入BigQuery后直接运行SQL语句来准备训练数据集。'
- en: 'The *second step* is model creation and training. BigQuery ML supports the
    following ML models:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二步*是模型创建和训练。BigQuery ML支持以下机器学习模型：'
- en: '**Linear regression** – where we have a number of data points, and we basically
    fit a line to those data points to minimize the error.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性回归** – 在这种情况下，我们有一些数据点，我们基本上通过拟合一条线到这些数据点来最小化误差。'
- en: '**Binary logistic regression** – where we have two classes and we assign each
    example to one of the classes.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二元逻辑回归** – 在这种情况下，我们有两个类别，并且我们将每个示例分配给其中一个类别。'
- en: '**Multiclass logistic regression** – where we have more than two classes and
    we assign each example to one of the classes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多类逻辑回归** – 在这种情况下，我们有多于两个类别，并且我们将每个示例分配给其中一个类别。'
- en: '**K-means clustering** – where we have a number of points and we are able to
    separate them into different clusters.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**K-means聚类** – 在这种情况下，我们有一些点，并且能够将它们分离成不同的簇。'
- en: Other models are supported by BQML. For more details, please refer to [https://cloud.google.com/bigquery-ml/docs/introduction#supported_models_in](https://cloud.google.com/bigquery-ml/docs/introduction#supported_models_in).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BQML支持其他模型。有关更多详细信息，请参阅[https://cloud.google.com/bigquery-ml/docs/introduction#supported_models_in](https://cloud.google.com/bigquery-ml/docs/introduction#supported_models_in)。
- en: BQML implements the model creation and training in a single step using the BQML
    `create model` statement. Using *example 2* that we discussed in the previous
    chapters, *Table 6.1* shows two samples for the loan application processing model
    where the target is a binary value, *approval or not*, and the features include
    the application date, applicant credit score, loan amount, annual income, age,
    and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: BQML通过使用BQML的`create model`语句在单步中实现模型创建和训练。使用我们在前几章中讨论的*示例2*，*表6.1*显示了贷款申请处理模型的两个样本，其中目标是二进制值，*批准或不批准*，特征包括申请日期、申请人信用评分、贷款金额、年收入、年龄等。
- en: '![Table 6.1 – Sample table structure ](img/Figure_6.1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![表6.1 – 样本表结构](img/Figure_6.1.jpg)'
- en: Table 6.1 – Sample table structure
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 – 样本表结构
- en: 'The following is sample code for creating a model with logistic regression
    using the dataset from a sample table `t`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用样本表`t`中的数据集创建具有逻辑回归模型的示例代码：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the preceding code is run, BQML will execute the `SELECT` statement to
    filter all of the samples ranging from August 01, 2016 to July 31, 2019, and then
    use the results as the dataset input to train the logistic regression model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的代码时，BQML将执行`SELECT`语句以过滤从2016年8月1日到2019年7月31日的所有样本，然后使用这些结果作为数据集输入来训练逻辑回归模型。
- en: 'The *third step* is model validation/evaluation to determine how good the model
    is. With BQML, model evaluation is done using the `ML.EVALUATE` function as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是模型验证/评估，以确定模型的好坏。使用BQML，模型评估是通过以下`ML.EVALUATE`函数完成的：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the preceding code is run, BQML will execute the `SELECT` statement to
    filter all of the samples ranging from August 01, 2019 to July 31, 2020, and then
    use the results as the dataset input to evaluate the performance of the classifier
    (the logistic regression model). When the code is completed, you can view the
    results.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的代码时，BQML将执行`SELECT`语句以过滤从2019年8月1日到2020年7月31日的所有样本，然后使用这些结果作为数据集输入来评估分类器（逻辑回归模型）的性能。当代码完成时，您可以查看结果。
- en: '![Table 6.2 – Sample BQML model evaluation result ](img/Figure_6.2.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![表6.2 – 样本BQML模型评估结果](img/Figure_6.2.jpg)'
- en: Table 6.2 – Sample BQML model evaluation result
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2 – 样本BQML模型评估结果
- en: '*Table 6.2* shows the sample metrics for our binary classification model as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*表6.2*显示了我们的二元分类模型的样本指标如下：'
- en: '`Precision` – a metric that identifies the frequency with which a model was
    correct when predicting the positive class.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Precision` – 一个指标，用于识别模型在预测正类时正确的频率。'
- en: '`recall` – a metric that answers the following question: out of all the possible
    positive labels, how many did the model correctly identify?'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recall` – 一个指标，回答以下问题：在所有可能的正标签中，模型正确识别了多少个？'
- en: '`accuracy` – the fraction of predictions that a classification model got right.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accuracy` – 分类模型预测正确的比例。'
- en: '`f1_score` – the harmonic average of the precision and recall.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f1_score` – 精确率和召回率的调和平均值。'
- en: '`log_loss` – the loss function used in a logistic regression.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_loss` – 逻辑回归中使用的损失函数。'
- en: '`roc_auc` – the area under the ROC curve.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roc_auc` – ROC曲线下的面积。'
- en: Depending on the business use case, we can review the evaluation results, measure
    the model performance, and find the business indications. During the model evaluation
    process, we can tune model perimeters using the `model create` statement. More
    details are at [https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-hyperparameter-tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-hyperparameter-tuning).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据业务用例，我们可以审查评估结果，衡量模型性能，并找到业务指示。在模型评估过程中，我们可以使用`model create`语句调整模型参数。更多详情请参阅[https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-hyperparameter-tuning](https://cloud.google.com/bigquery-ml/docs/reference/standard-sql/bigqueryml-hyperparameter-tuning)。
- en: 'In the *fourth step*, we can use the model to predict production outcomes.
    A sample query to predict the outcome is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们可以使用模型来预测生产结果。以下是一个预测结果的示例查询：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see from the preceding four steps, BQML completes the full process
    of ML development within the BigQuery cloud service. For structured data, BQML
    has many advantages for our data scientists to train and develop ML models.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前四步中可以看到，BQML在BigQuery云服务中完成了机器学习开发的全部过程。对于结构化数据，BQML为我们数据科学家训练和开发机器学习模型提供了许多优势。
- en: Google Cloud BQ and BQML provide services for structured data processing and
    learning, and they are widely used in many business use cases. In the following
    section, we will introduce Google’s ML frameworks, TensorFlow and Keras.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud BQ和BQML提供结构化数据处理和学习服务，并且在许多商业用例中得到了广泛应用。在下一节中，我们将介绍Google的机器学习框架，TensorFlow和Keras。
- en: Introduction to TensorFlow
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow简介
- en: TensorFlow is an end-to-end open source platform for ML, developed by Google
    Brain, and it is one of the most widely used ML frameworks by data scientists.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow是由Google Brain开发的端到端开源机器学习平台，并且是数据科学家最广泛使用的机器学习框架之一。
- en: '**TensorFlow flow tensors** – TensorFlow’s name is directly derived from its
    core framework components: tensors. Let’s start by understanding **tensors**.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**TensorFlow流张量** – TensorFlow的名称直接来源于其核心框架组件：张量。让我们先从理解**张量**开始。'
- en: Understanding the concept of tensors
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解张量的概念
- en: 'A tensor is a container that holds data of various sizes and shapes in an N-dimensional
    space. A tensor can be originated from the input data or a computation of the
    input data. In ML, we call the tensor components **features**. A tensor has three
    main characters to describe itself, called a tensor’s **rank**, **shape**, and
    **dtype** as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 张量是一个容器，它在一个N维空间中以各种大小和形状存储数据。张量可以来自输入数据或输入数据的计算。在机器学习中，我们称张量的组件为**特征**。张量有三个主要特征来描述自身，称为张量的**秩**、**形状**和**dtype**，如下所示：
- en: Rank is the number of directions
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩是方向的数量
- en: Shape is the number of elements in each direction
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状是每个方向上的元素数量
- en: Dtype is the data type
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dtype是数据类型
- en: 'The rank of a tensor specifies the number of directions being measured for
    a tensor. From the number of ranks, a tensor can be categorized as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 张量的秩指定了测量张量的方向数量。从秩的数量，可以将张量分类如下：
- en: '**Rank 0**: A tensor that only has a magnitude and 0 directions.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秩0**：一个只有大小和0个方向的张量。'
- en: '**Rank 1**: A tensor that has one direction and a magnitude.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秩1**：一个具有一个方向和大小的张量。'
- en: '**Rank 2**: A tensor that has two directions (rows and columns), with each
    element having a magnitude.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秩2**：一个具有两个方向（行和列）的张量，每个元素都有一个大小。'
- en: '**Rank 3**: A tensor that has three directions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秩3**：一个具有三个方向的张量。'
- en: '**Rank 4**: A tensor with four directions.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秩4**：一个具有四个方向的张量。'
- en: '**High-rank tensors**.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高秩张量**。'
- en: '*Figure 6.3* illustrates the ranks of the tensors using the basic geometrical
    objects as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.3* 使用基本几何对象说明了张量的秩，如下所示：'
- en: A rank 0 tensor is a scalar with a magnitude but no directions.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为0的张量是一个具有大小但没有方向的单个标量。
- en: A rank 1 tensor is a vector with one direction and a magnitude.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为1的张量是一个具有一个方向和大小的向量。
- en: A rank 2 tensor is a matrix with two directions – its elements have magnitudes.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为2的张量是一个具有两个方向（行和列）的矩阵，其元素具有大小。
- en: A rank 3 tensor has three directions – its elements have two-dimensional magnitudes.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为3的张量有三个方向——其元素具有二维大小。
- en: A rank 4 tensor is a list of rank 3 sensors.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为4的张量是秩为3传感器的列表。
- en: '![Figure 6.3 – Ranks of tensors ](img/Figure_6.3.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 张量的秩](img/Figure_6.3.jpg)'
- en: Figure 6.3 – Ranks of tensors
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 张量的秩
- en: 'If we use the `list` data type, which we discussed in The *Python Basic Data
    Structure* section in [*Chapter 2*](B18333_02.xhtml#_idTextAnchor054), *Mastering
    Python Programming*, to define the rank of a tensor, then *each rank of tensors
    gives us a list of the objects from the previous rank of sensors* as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用在[*第2章*](B18333_02.xhtml#_idTextAnchor054)的*Python基本数据结构*部分中讨论的`list`数据类型来定义张量的秩，那么*每个张量的秩都给我们一个来自前一个秩传感器的对象列表*，如下所示：
- en: Rank 1 tensors (vectors) gave us a list of rank 0 tensors (scalars).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为1的张量（向量）给我们一个秩为0的张量（标量）列表。
- en: Rank 2 tensors (matrixes) gave us a list of rank 1 tensors (vectors).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为2的张量（矩阵）给我们一个秩为1的张量（向量）列表。
- en: Rank 3 tensors (tensors) gave us a list of rank 2 tensors (matrixes).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为3的张量（张量）给我们一个秩为2的张量（矩阵）列表。
- en: Rank 4 tensors gave us a list of rank 3 tensors (tensors).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秩为4的张量给我们一个秩为3的张量列表（张量）。
- en: 'Let’s use a color image as an example to illustrate the concept of *rank* for
    a tensor. For a color image, we can use three channels to describe each pixel:
    a red channel, a green channel, and a blue channel. Each channel measures the
    magnitude of the pixel within that color channel. The red channel is a *rank 2*
    tensor since it uses a matrix to represent the image pixel map in red light (0
    means zero light and 255 means maximum light), and so are the green channel and
    the blue channel. Combining these three channels, we have a *rank 3* tensor. If
    we add a time axis for the order of the color frames/images to form a video, then
    it becomes a *rank 4* tensor. If we then batch the videos, it will then come up
    with a list of *rank 4* tensors – a *rank 5* tensor.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个彩色图像作为例子来说明张量的 *rank* 概念。对于一个彩色图像，我们可以使用三个通道来描述每个像素：一个红色通道、一个绿色通道和一个蓝色通道。每个通道测量像素在该颜色通道内的强度。红色通道是一个
    *rank 2* 的张量，因为它使用矩阵来表示红色光下的图像像素映射（0 表示没有光，255 表示最大光），绿色通道和蓝色通道也是如此。结合这三个通道，我们得到一个
    *rank 3* 的张量。如果我们为颜色帧/图像的顺序添加一个时间轴来形成视频，那么它就变成了 *rank 4* 的张量。如果我们然后对视频进行批处理，那么它将生成一个
    *rank 4* 张量的列表——一个 *rank 5* 的张量。
- en: 'After we have examined the tensor ranks, let’s check out the shape and dtype
    of a tensor – shape is the number of elements of a tensor and dtype is the element’s
    data type. With the tensors of ranks 0, 1, 2, 3, and n, we have the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查了张量的秩之后，让我们来看看张量的形状和 dtype（数据类型）——形状是张量元素的数量，dtype 是元素的类型。对于秩为 0、1、2、3
    和 n 的张量，我们有以下内容：
- en: The shape for the *rank 0* tensor (scalar) is empty *()*.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*rank 0* 张量（标量）的形状是空的 *()*。'
- en: The shape for a *rank 1* tensor, for example, a vector ([3, 5, 7]), is *(3)*
    since it has three elements.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于形状为 *rank 1* 的张量，例如向量 ([3, 5, 7])，其形状是 *(3)*，因为它有三个元素。
- en: The shape for a *rank 2* tensor, for example, a matrix ([3, 5, 7], [4, 6, 8])
    is *(2,3)* since it has two elements in one direction (rows) and three elements
    in the other direction (columns).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，对于形状为 *rank 2* 的张量，比如矩阵 ([3, 5, 7], [4, 6, 8])，其形状是 *(2,3)*，因为它在一个方向（行）上有两个元素，在另一个方向（列）上有三个元素。
- en: Now that we have a good understanding of the tensor concept, let’s look at the
    second part of the name *TensorFlow*, flow, and see how tensors flow.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对张量概念有了很好的理解，让我们来看看 *TensorFlow* 名称的第二部分，flow（流动），看看张量是如何流动的。
- en: How tensors flow
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 张量的流动
- en: To describe the flowing of tensors in the **TensorFlow** (**TF**) framework,
    we adopt a computational graph with nodes and edges called a **Directed Acyclic
    Graph** (**DAG**). Directed means that the tensor (data) moves in a given order
    along a path in the graph. Acyclic means that the moving path does not form any
    cycles. So, tensors flow in no-loop DAGs to transform data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述在 **TensorFlow** (**TF**) 框架中张量的流动，我们采用一个带有节点和边的计算图，称为 **有向无环图** (**DAG**)。有向意味着张量（数据）沿着图中的路径以给定的顺序移动。无环意味着移动路径不形成任何循环。因此，张量在无环的
    DAG 中流动以转换数据。
- en: Using DAGs, a tensor has a node and an edge. The nodes represent the operations
    we perform on the tensor/data, and the edges represent the path that the tensor/data
    flows along. Let’s use a DAG to describe a sample algorithm. As shown in *Figure
    6.4*, we input two numbers, multiply them to get their product, and add the numbers
    to get their sum. Then, we divide the product by the sum and print the result.
    If we replace the constant values with variables and add more complex mathematical
    operations, we can see that this tensor flowing process is really an ML model
    – we can change the variables or the weights to produce the expected output from
    the inputs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DAG，张量有一个节点和一个边。节点代表我们对张量/数据执行的操作，边代表张量/数据流动的路径。让我们用一个 DAG 来描述一个示例算法。如图 *图
    6.4* 所示，我们输入两个数字，将它们相乘得到它们的乘积，然后将数字相加得到它们的和。然后，我们将乘积除以和并打印结果。如果我们用变量替换常数并添加更复杂的数学运算，我们可以看到这个张量流动过程实际上是一个机器学习模型——我们可以改变变量或权重，从输入中产生预期的输出。
- en: '![Figure 6.4 – A sample algorithm with DAG  ](img/Figure_6.4.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 带有 DAG 的示例算法](img/Figure_6.4.jpg)'
- en: Figure 6.4 – A sample algorithm with DAG
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 带有 DAG 的示例算法
- en: Since DAGs are mono-directional and have an order of execution, we can parallelize
    the operations when tensors flow in the diagram. For example, If you want to add
    1,000 tensors and multiply the same 1,000 tensors, the addition and multiplication
    operations can be performed in parallel by distributing the operations to multiple
    computing resources by utilizing many CPU, **Graphics Processing Unit** (**GPU**),
    or **Tensor Processing Unit** (**TPU**) cores, or even **Quantum Processors**
    (**QU**). Since DAG allows the execution of parallel operations on different physical
    machines or platforms, we can further execute these operations in parallel on
    distributed server farms or edge devices. As we know, cloud computing is featured
    as on-demand, globally distributed, auto-scalable, and pay-as-you-go and thus
    it provides a perfect environment to parallelize TensorFlow operations and train
    ML models. As we have also discussed in the previous chapters, Google Colab has
    preinstalled TensorFlow packages, and you can practice TensorFlow in Colab, with
    GPU and TPU free of cost.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DAGs是单向的并且有执行顺序，当张量在图中流动时，我们可以并行化操作。例如，如果你想要添加1,000个张量并乘以相同的1,000个张量，可以通过利用多个CPU、**图形处理单元**（**GPU**）、**张量处理单元**（**TPU**）核心，甚至**量子处理器**（**QU**）将操作分配到多个计算资源来并行执行加法和乘法操作。由于DAG允许在不同物理机器或平台上执行并行操作，我们可以在分布式服务器农场或边缘设备上进一步并行执行这些操作。众所周知，云计算具有按需、全球分布、自动可扩展和按使用付费的特点，因此它为并行化TensorFlow操作和训练ML模型提供了一个完美的环境。正如我们在前面的章节中讨论的那样，Google
    Colab预装了TensorFlow包，你可以在Colab中免费练习TensorFlow。
- en: Now that we have grasped the concepts of tensors and understand how tensors
    flow in the TF frame, it’s time to introduce Keras—a high-level API that is designed
    for us to develop ML models with TensorFlow very easily.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了张量的概念，并了解了张量如何在TF框架中流动，是时候介绍Keras了——这是一个为我们设计的高级API，使我们能够非常容易地使用TensorFlow开发ML模型。
- en: Introduction to Keras
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Keras简介
- en: Keras is a Google platform and a high-level interface to build ML/DL models
    with TensorFlow. Keras provides a high-level API that encapsulates data transformations
    and operations using logic units, called **layers**, as the building blocks to
    create neural networks. A layer performs data manipulation operations such as
    taking an average, calculating the minimum, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Keras是一个Google平台，是构建ML/DL模型的TensorFlow高级接口。Keras提供了一个高级API，它使用称为**层**的逻辑单元来封装数据转换和操作，作为创建神经网络的构建块。一个层执行数据操作，例如取平均值、计算最小值等。
- en: 'With Keras, ML models are built from layers. During the ML model training process,
    the variables in the layers are adjusted, via backpropagation, to optimize the
    model cost function. Behind the scenes, TensorFlow and Keras complete detailed
    data operations, such as linear algebra and calculus calculations, in the background.
    Keras provides the following two APIs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Keras，ML模型是由层构建的。在ML模型训练过程中，通过反向传播调整层的变量，以优化模型成本函数。在幕后，TensorFlow和Keras在后台完成详细的数据操作，例如线性代数和微积分计算。Keras提供了以下两个API：
- en: The **sequential API** provides the simplest interface and least complexity.
    With the sequential API, we can create the model layer by layer and thus build
    an ML/DL model as a simple list of layers.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序API**提供了最简单的接口和最低的复杂性。使用顺序API，我们可以逐层创建模型，从而将ML/DL模型构建为一个简单的层列表。'
- en: The **functional API** is more flexible and powerful than the sequential API
    since it allows thebranching or sharing of layers. With the functional API, we
    can have multiple inputs and outputs for ML models.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能API**比顺序API更灵活、更强大，因为它允许层的分支或共享。使用功能API，我们可以为ML模型提供多个输入和输出。'
- en: 'The following snippet shows an ML model training with the sequential API:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用顺序API进行ML模型训练：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following snippet shows an ML model training with the functional API:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用功能API进行ML模型训练：
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, the preceding two Keras APIs have their own pros and cons. The
    sequential API is simple and straightforward, and the functional API can be used
    to build complex models.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前两个Keras API各有其优缺点。顺序API简单直接，而功能API可以用来构建复杂模型。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed Google Cloud BQ and BQML and introduced some examples
    of using BQ/BQML for data processing and ML model development. We also learned
    about the concepts of TensorFlow and Keras – Google’s frameworks for building
    ML models and projects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Google Cloud BQ和BQML，并介绍了一些使用BQ/BQML进行数据处理和ML模型开发的示例。我们还学习了TensorFlow和Keras的概念——这是Google用于构建ML模型和项目的框架。
- en: In the following chapter, we will focus on Vertex AI, which provides an end-to-end
    platform for ML in the Google Cloud.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点关注Vertex AI，它为Google Cloud中的ML提供了一个端到端平台。
- en: Further reading
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further insights on the learning of the chapter, you can refer to the following
    links:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章学习的进一步见解，您可以参考以下链接：
- en: '[https://cloud.google.com/bigquery/docs/](https://cloud.google.com/bigquery/docs/)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cloud.google.com/bigquery/docs/](https://cloud.google.com/bigquery/docs/)'
- en: '[https://cloud.google.com/bigquery-ml/docs/](https://cloud.google.com/bigquery-ml/docs/)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cloud.google.com/bigquery-ml/docs/](https://cloud.google.com/bigquery-ml/docs/)'
- en: '[https://www.tensorflow.org/](https://www.tensorflow.org/)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.tensorflow.org/](https://www.tensorflow.org/)'
- en: '[https://keras.io/about/](https://keras.io/about/)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://keras.io/about/](https://keras.io/about/)'
