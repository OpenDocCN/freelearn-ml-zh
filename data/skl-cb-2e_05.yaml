- en: Linear Models – Logistic Regression
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性模型 – 逻辑回归
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Loading data from the UCI repository
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从UCI库加载数据
- en: Viewing the Pima Indians diabetes dataset with pandas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pandas查看Pima印第安人糖尿病数据集
- en: Looking at the UCI Pima Indians dataset web page
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看UCI Pima印第安人数据集网页
- en: Machine learning with logistic regression
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑回归进行机器学习
- en: Examining logistic regression errors with a confusion matrix
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混淆矩阵检查逻辑回归错误
- en: Varying the classification threshold in logistic regression
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变逻辑回归中的分类阈值
- en: Receiver operating characteristic – ROC analysis
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收器操作特征 – ROC分析
- en: Plotting an ROC curve without context
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制没有上下文的ROC曲线
- en: Putting it all together – UCI breast cancer dataset
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合所有内容 – UCI乳腺癌数据集
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Linear regression is a very old method and part of traditional statistics. *Machine
    learning linear regression* involves a training and testing set. This way, it
    can be compared by utilizing *cross-validation* with other models and algorithms.
    *Traditional linear regression* trains and tests on the whole dataset. This is
    still a common practice, possibly because linear regression tends to underfit
    rather than overfit.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归是一种非常古老的方法，是传统统计学的一部分。*机器学习线性回归*涉及训练集和测试集。通过这种方式，它可以与其他模型和算法通过*交叉验证*进行比较。*传统线性回归*则在整个数据集上进行训练和测试。这仍然是一种常见的做法，可能是因为线性回归往往是欠拟合，而非过拟合。
- en: Using linear methods for classification – logistic regression
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线性方法进行分类 – 逻辑回归
- en: As seen in [Chapter 1](9a5af114-e518-47ef-ac63-edf9ae69384c.xhtml), *High-Performance
    Machine Learning – NumPy*, logistic regression is a classification method. In
    some contexts, it is a regressor as it computes the real number probability of
    a class before assigning a categorical classification prediction. With this in
    mind, let's explore the Pima Indians diabetes dataset provided by the **University
    of California, Irvine** (**UCI**).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第一章](9a5af114-e518-47ef-ac63-edf9ae69384c.xhtml)所示，*高效机器学习 – NumPy*，逻辑回归是一种分类方法。在某些情况下，它也可以作为回归器使用，因为它计算一个类别的实数概率，然后再进行分类预测。考虑到这一点，我们来探索**加利福尼亚大学欧文分校**（**UCI**）提供的Pima印第安人糖尿病数据集。
- en: Loading data from the UCI repository
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从UCI库加载数据
- en: The first dataset we will load is the Pima Indians diabetes dataset. This will
    require access to the internet. The dataset is available thanks to Sigillito V.
    (1990), UCI machine learning repository ([https://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data](https://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data)),
    Laurel, MD at Johns Hopkins University, applied physics laboratory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将加载的第一个数据集是Pima印第安人糖尿病数据集。这需要访问互联网。数据集由Sigillito V.（1990）提供，存储在UCI机器学习库中（[https://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data](https://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/pima-indians-diabetes.data)），约翰·霍普金斯大学应用物理实验室，马里兰州劳雷尔。
- en: The first thing in your mind if you are an open source veteran is, what is the
    license/permission to this database? This is a very important issue. The UCI repository
    has a use policy that requires citation of the database whenever we are using
    it. We are allowed to use it but we must give them proper credit for their great
    help and provide a citation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是开源老手，首先想到的可能是，这个数据库的许可证/授权是什么？这是一个非常重要的问题。UCI库有一个使用政策，要求我们在使用数据库时引用它。我们可以使用它，但必须给予他们应有的赞扬并提供引用。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Go to IPython and import `pandas`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IPython并导入`pandas`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Type the web location of the Pima Indians diabetes dataset as a string as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Pima印第安人糖尿病数据集的网页地址作为字符串输入，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Type the column names of the data in a list:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据的列名输入为列表：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Store the feature names as a list. Exclude the `target` column, the last column
    name in `column_names`, because it is not a feature:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将特征名称存储为一个列表。排除`target`列，这是`column_names`中的最后一列，因为它不是特征：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Make a pandas dataframe to store the input data:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个pandas数据框来存储输入数据：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Viewing the Pima Indians diabetes dataset with pandas
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pandas查看Pima印第安人糖尿病数据集
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can view the data in various ways. View the top of the dataframe:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过多种方式查看数据。查看数据框的顶部：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/85474218-fbe0-41de-9f83-1595cc9f4845.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85474218-fbe0-41de-9f83-1595cc9f4845.png)'
- en: 'Nothing seems amiss here, except possibly an insulin level of zero. Is this
    possible? What about the `skin_mm` variable? Can that be zero? Make a note about
    it as a comment in your IPython:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里似乎没有什么问题，除了可能有一个胰岛素水平为零的情况。这可能吗？那`skin_mm`变量呢？它可以是零吗？在你的IPython中做个注释：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Get a rough overview of the dataframe with the `describe()` method:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`describe()`方法获取数据框的粗略概览：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/225b593a-a7f2-463b-a074-b2e258260e52.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/225b593a-a7f2-463b-a074-b2e258260e52.png)'
- en: 'Make a note again in your notebook about additional zeros:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在笔记本中做个注释，记录其他零值的情况：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Draw a histogram of the `pregnancy_x` variable. Set the `hist()` method variable
    bins equal to 50 for more bins and a higher resolution in the image; otherwise,
    the image is hard to read:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制`pregnancy_x`变量的直方图。将`hist()`方法中的bins参数设置为50，以获得更多的区间和更高分辨率的图像；否则，图像会难以阅读：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/3cd07e63-b559-4998-9f18-3b7f3c682de7.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cd07e63-b559-4998-9f18-3b7f3c682de7.png)'
- en: 'Make histograms for all columns of the dataframe. Change `figsize` within the
    method to the tuple `(15,9)` and bins to `50` again; otherwise, it is hard to
    read the image:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为数据框中的所有列绘制直方图。在方法中将`figsize`设置为元组`(15,9)`，并再次将bins设置为`50`；否则，图像会很难读取：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/5aaa8355-0f01-49a8-aa4a-df447d30b05c.png)`blood_pressure` and `bmi`
    look like normal distributions aside from the anomalous zeros.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/5aaa8355-0f01-49a8-aa4a-df447d30b05c.png)`blood_pressure`和`bmi`看起来呈正态分布，除了异常的零值。'
- en: The `pedigree_func` and `plasma_con` variables are skewed-normal (possibly log-normal).
    The `age` and `pregnancy_x` variables are decaying in some way. The insulin and
    `skin_mm` variables look like they could be normally distributed except for the
    many values of zero.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`pedigree_func`和`plasma_con`变量呈偏态正态分布（可能是对数正态分布）。`age`和`pregnancy_x`变量在某种程度上呈衰减状态。胰岛素和`skin_mm`变量看起来除了零值很多外，可能呈正态分布。'
- en: 'Finally, note the class imbalance in the `target` variable. Reexamine that
    imbalance with the `value_counts()` pandas series method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，注意`target`变量中的类别不平衡。使用`value_counts()` pandas系列方法重新检查这种不平衡：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There are more cases where the person is described by category zero instead
    of category one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，人的描述是类别零而不是类别一。
- en: Looking at the UCI Pima Indians dataset web page
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看UCI Pima Indians数据集的网页
- en: We did some exploratory analysis to get a rough understanding of the data. Now
    we will read the UCI Pima Indians dataset documentation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了初步的探索性分析，以大致了解数据。现在我们将阅读UCI Pima Indians数据集的文档。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怎么做...
- en: View the citation policy
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看引用政策
- en: Go to [https://archive.ics.uci.edu/ml/datasets/pima+indians+diabetes](https://archive.ics.uci.edu/ml/datasets/pima+indians+diabetes).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://archive.ics.uci.edu/ml/datasets/pima+indians+diabetes](https://archive.ics.uci.edu/ml/datasets/pima+indians+diabetes)。
- en: Here is all the information about the UCI Pima Indians diabetes dataset. First,
    scroll down to the bottom of the page and look at their citation policy. The diabetes
    dataset has the general UCI citation policy available at; [https://archive.ics.uci.edu/ml/citation_policy.html](https://archive.ics.uci.edu/ml/citation_policy.html).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是关于UCI Pima Indians糖尿病数据集的所有信息。首先，滚动到页面底部，查看他们的引用政策。糖尿病数据集的通用UCI引用政策可以在以下链接找到：[https://archive.ics.uci.edu/ml/citation_policy.html](https://archive.ics.uci.edu/ml/citation_policy.html)。
- en: The general policy says that to publish material using the dataset, please cite
    the UCI repository.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用政策表示，若要发布使用数据集的材料，请引用UCI存储库。
- en: Read about missing values and context
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读关于缺失值和上下文的说明
- en: 'The top of the page has important links and an abstract of the dataset. The
    abstract mentions there are missing values in the dataset:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面顶部有重要链接和数据集摘要。摘要提到数据集中存在缺失值：
- en: '![](img/d6af13eb-bcc7-471d-b8ad-f10be76a4503.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6af13eb-bcc7-471d-b8ad-f10be76a4503.png)'
- en: 'Below the abstract, there is a description of the attributes (this is how I
    came up with the names for the columns at the beginning):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在摘要下方，有一个属性描述（这就是我最初为列命名的方式）：
- en: '![](img/20fa3278-8e3b-4085-ae7b-0c97cb891847.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20fa3278-8e3b-4085-ae7b-0c97cb891847.png)'
- en: 'What do the class variables mean anyway? What does the zero or one mean in
    the target? To figure this out, click on the Data Set Description link above the
    abstract. Scroll to point nine on the page, which yields the desired information:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么这些类别变量到底意味着什么呢？目标变量中的零和一分别代表什么？为了弄清楚这一点，点击摘要上方的“数据集描述”链接。滚动到页面的第九点，那里会给出所需的信息：
- en: '![](img/67a2dc7c-d858-437a-815d-dcaa29a1f815.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67a2dc7c-d858-437a-815d-dcaa29a1f815.png)'
- en: This means that a 1 refers to a positive for diabetes. This is important information
    and with regard to this data analysis, provides a context.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 1 代表糖尿病的阳性结果。这是重要信息，并且在数据分析中提供了上下文。
- en: 'Finally, there is a disclaimer noting that: As pointed out by a repository
    user, this cannot be true: there are zeros in places where they are biologically
    impossible, such as the blood pressure attribute. It seems very likely that zero
    values encode missing data.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，有一个免责声明指出：正如一个仓库用户所指出的那样，这不可能是正确的：在某些地方有零值，而这些地方在生物学上是不可能的，例如血压属性。很可能零值表示缺失数据。
- en: Thus, we were right in suspecting some of the impossible zeros in the data exploration
    phase. Many datasets have corrupt or missing values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在数据探索阶段怀疑某些不可能出现的零值时是正确的。许多数据集都有损坏或缺失的值。
- en: Machine learning with logistic regression
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用逻辑回归进行机器学习
- en: 'You are familiar with the steps of training and testing a classifier. With
    logistic regression, we will do the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你熟悉训练和测试分类器的步骤。使用逻辑回归时，我们将执行以下操作：
- en: Load data into feature and target arrays, `X` and `y`, respectively
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据加载到特征和目标数组 `X` 和 `y` 中
- en: Split the data into training and testing sets
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据拆分为训练集和测试集
- en: Train the logistic regression classifier on the training set
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在训练集上训练逻辑回归分类器
- en: Test the performance of the classifier on the test set
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试集上测试分类器的性能
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Define X, y – the feature and target arrays
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 X、y——特征和目标数组
- en: 'Let''s start predicting with scikit-learn''s logistic regression. Perform the
    necessary imports and set the input variables X and the target variable `y`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 scikit-learn 的逻辑回归进行预测。首先执行必要的导入并设置输入变量 X 和目标变量 `y`：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Provide training and testing sets
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供训练集和测试集
- en: 'Import `train_test_split` to create testing and training sets for both `X`
    and `y`: the inputs and target. Note the `stratify=y`, which stratifies the categorical
    variable `y`. This means that there are the same proportions of zeros and ones
    in both `y_train` and `y_test`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `train_test_split` 以为 `X` 和 `y` 创建测试集和训练集：输入和目标。注意 `stratify=y`，它会将分类变量 `y`
    进行分层。这意味着 `y_train` 和 `y_test` 中的零和一的比例是相同的：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Train the logistic regression
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练逻辑回归模型
- en: 'Now import the `LogisticRegression` and fit it to the training data:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导入 `LogisticRegression` 并将其拟合到训练数据上：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Make a prediction on the test set and store it as `y_pred`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上进行预测并将其存储为 `y_pred`：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Score the logistic regression
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对逻辑回归进行评分
- en: 'Check the accuracy of the prediction with `accuracy_score`, the percentage
    of classifications that are correct:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `accuracy_score` 检查预测的准确性，这是分类正确的百分比：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, we have obtained a score, but is this score the best measure we can use
    under these circumstances? Can we do better? Perhaps yes. Look at a confusion
    matrix of the results as follows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们得到了一个分数，但这个分数是我们在这些情况下可以使用的最佳度量吗？我们能做得更好吗？也许可以。请看一下下面的结果混淆矩阵。
- en: Examining logistic regression errors with a confusion matrix
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用混淆矩阵检查逻辑回归的错误
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Import and view the confusion matrix for the logistic regression we constructed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 导入并查看我们构建的逻辑回归的混淆矩阵：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I passed three arguments to the confusion matrix:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我向混淆矩阵传递了三个参数：
- en: '`y_test`: The test target set'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y_test`：测试目标集'
- en: '`y_pred`: Our logistic regression predictions'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y_pred`：我们的逻辑回归预测'
- en: '`labels`: References to a positive class'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labels`：指代阳性类别'
- en: The `labels = [1,0]` means that the positive class is `1` and the negative class
    is `0`. In the medical context, we found while exploring the Pima Indians diabetes
    dataset that class `1` tested positive for diabetes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`labels = [1,0]` 表示阳性类别为 `1`，阴性类别为 `0`。在医学背景下，我们在探索 Pima 印第安糖尿病数据集时发现，类别 `1`
    测试为糖尿病阳性。'
- en: 'Here is the confusion matrix, again in pandas dataframe form:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是混淆矩阵，再次以 pandas 数据框形式呈现：
- en: '![](img/e53803a3-fc60-4560-93a4-ac3b7e6cfbad.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e53803a3-fc60-4560-93a4-ac3b7e6cfbad.png)'
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Reading the confusion matrix
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读混淆矩阵
- en: 'The small array of numbers has the following meaning:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的数字数组具有以下含义：
- en: '![](img/9f6802ef-d273-48e3-8bd3-1503d8a707db.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f6802ef-d273-48e3-8bd3-1503d8a707db.png)'
- en: The confusion matrix tells us a bit more about what occurred during classification,
    not only the accuracy score. The diagonal elements from upper-left to lower-right
    are correct classifications. There were 27 + 88 = 115 correct classifications.
    Off that diagonal, 27 + 12 = 39 mistakes were made in classification. Note that
    115 / (115 + 39) yields the classifier accuracy again, of about 0.75.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆矩阵不仅告诉我们分类过程中发生了什么，还能提供准确率评分。矩阵从左上到右下的对角线元素表示正确的分类。共有27 + 88 = 115个正确分类。对角线之外，共犯了27
    + 12 = 39个错误分类。注意，115 / (115 + 39)再次得到分类器的准确度，大约为0.75。
- en: Let us focus on the errors again. In the confusion matrix, 27 people were labelled
    as not having diabetes although they do. In a real-life context, this is a worse
    error than those who were thought to have diabetes but did not. The first set
    might go home in real-life and forget while the second set might be retested.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次关注错误。在混淆矩阵中，27个人被错误地标记为没有糖尿病，尽管他们确实患有糖尿病。在实际情况下，这是比那些被认为患有糖尿病但实际上没有的人更严重的错误。第一类可能会回家后忘记，而第二类则可能会重新测试。
- en: General confusion matrix in context
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文中的一般混淆矩阵
- en: 'A general confusion matrix where the positive class refers to identifying a
    condition (diabetes in this case) thereby having a medical diagnosis context:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的混淆矩阵，其中正类表示识别一种病症（此处为糖尿病），因此具有医学诊断背景：
- en: '![](img/f51675e3-8550-44cc-a45b-398e68a110ba.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f51675e3-8550-44cc-a45b-398e68a110ba.png)'
- en: Varying the classification threshold in logistic regression
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变逻辑回归中的分类阈值
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the fact that underlying the logistic regression classification,
    there is regression to minimize the number of times people were sent home for
    not having diabetes although they do. Do so by calling the `predict_proba()` method
    of the estimator:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用以下事实：在逻辑回归分类中，存在回归过程，用于最小化那些本应被诊断为糖尿病的人却被送回家的次数。通过调用估算器的`predict_proba()`方法来实现：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This yields an array of probabilities. View the array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将得到一个概率数组。查看该数组：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first row, a probability of about 0.87 is assigned to class `0` and a
    probability of 0.13 is assigned to `1`. Note that, as probabilities, these numbers
    add up to 1\. Because there are only two categories, this result can be viewed
    as a regressor, a real number that talks about the probability of the class being
    `1` (or `0`). Visualize the probabilities of the class being `1` with a histogram.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，类别`0`的概率约为0.87，类别`1`的概率为0.13。注意，作为概率，这些数字加起来为1。由于只有两类，这个结果可以看作是一个回归器，一个关于类别为`1`（或`0`）概率的实数。通过直方图可视化类别为`1`的概率。
- en: 'Take the second column of the array, turn it into a pandas series, and draw
    a histogram:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 取数组的第二列，将其转换为pandas序列并绘制直方图：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/910ab5af-85bb-40e2-8268-f2e3af798570.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/910ab5af-85bb-40e2-8268-f2e3af798570.png)'
- en: 'In the probability histogram, high probabilities in regards to selecting 1
    are fewer than low probabilities. For example, often the probability of selecting
    1 is from 0.1 to 0.2\. Within logistic regression, the algorithm will pick 1 by
    default only if the probability is greater than 0.5 or half. Now, contrast this
    with the target histogram at the beginning:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在概率直方图中，相比选择1的高概率，低概率的选择较多。例如，选择1的概率通常在0.1到0.2之间。在逻辑回归中，算法默认只有在概率大于0.5（即一半）时才会选择1。现在，将其与开始时的目标直方图进行对比：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/5d263257-e2ab-46a9-86e9-bd06f35db1ef.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d263257-e2ab-46a9-86e9-bd06f35db1ef.png)'
- en: 'In the following recipe, we will:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将：
- en: Call the class method `y_pred_proba()`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用类方法`y_pred_proba()`
- en: Use the `binarize` function with a specific threshold
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有特定阈值的`binarize`函数
- en: Look at the confusion matrix that is generated by the threshold
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看由阈值生成的混淆矩阵
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To select the classification class based on a threshold, use `binarize` from
    the `preprocessing` module. First import it:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要基于阈值选择分类类，请使用`preprocessing`模块中的`binarize`。首先导入它：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Look at the first two columns of `y_pred_proba`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`y_pred_proba`的前两列：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then try `binarize` function on `y_pred_proba` with a threshold of `0.5`. View
    the result:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后尝试对`y_pred_proba`使用`binarize`函数，设置阈值为`0.5`。查看结果：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `binarize` function fills the array with `1` if values in `y_pred_proba`
    are greater than 0.5; otherwise it places a `0`. In the first row, 0.87 is greater
    than 0.5 while 0.13 is not. So to binarize, replace the 0.87 with a `1` and the
    0.13 with a `0`. Now, take the first column of `y_pred_default`. View it:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`binarize`函数如果`y_pred_proba`中的值大于0.5，则用`1`填充数组；否则填入`0`。在第一行，0.87大于0.5，而0.13不大于。因此，为了二值化，将0.87替换为`1`，将0.13替换为`0`。现在，查看`y_pred_default`的第一列：'
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This recovers the decisions made by the default logistic regression classifier
    with threshold `0.5`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这恢复了默认逻辑回归分类器在阈值`0.5`下所做的决策。
- en: 'Trying the confusion matrix function on the NumPy array yields the first confusion
    matrix we encountered (note that the labels are chosen to be `[1,0]` again):'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在NumPy数组上尝试混淆矩阵函数会得到我们遇到的第一个混淆矩阵（请注意，标签再次选择为`[1,0]`）：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Try a different threshold so that class `1` has a better chance of being selected.
    View its confusion matrix:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的阈值，使得类别`1`有更高的选择概率。查看其混淆矩阵：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By changing the threshold, we increased the likelihood of predicting class `1`—increasing
    the size of the numbers in the first column of the confusion matrix. The first
    column now adds up to 50 + 48 = 98\. Before, the first column was 27 + 12 = 39,
    a much lower number. Now only four people were classified to not have diabetes
    although they do. Note that this is a good thing in some contexts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改阈值，我们增加了预测类别`1`的概率——增加了混淆矩阵第一列中数字的大小。现在，第一列的总和为50 + 48 = 98。之前，第一列是27 +
    12 = 39，数字要小得多。现在只有四个人被错误分类为没有糖尿病，尽管他们实际上有。请注意，在某些情况下，这是一件好事。
- en: When the algorithm predicts zero, it is likely to be correct. When it predicts
    one, it tends to not work. Suppose you run a hospital. You might like this test
    because you rarely send someone home believing they do not have diabetes although
    they do. Whenever you send people home who do have diabetes, they cannot be treated
    earlier and incur greater costs to the hospital, insurance companies, and themselves.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法预测为零时，它很可能是正确的。当它预测为一时，它通常不准确。假设你经营一家医院。你可能喜欢这个测试，因为你很少会送走一个看似没有糖尿病的人，尽管他实际上有糖尿病。每当你送走那些确实有糖尿病的人时，他们就无法尽早治疗，导致医院、保险公司和他们自己都面临更高的费用。
- en: 'You can measure the accuracy of the test when it predicts zero. Observe the
    second column of the confusion matrix, [4, 52]. In this situation, it is 52 /
    (52 + 4) or about 0.93 accurate. This is called the **negative predictive value**
    (**NPV**). You can write a function to calculate NPV-based on the threshold:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以衡量测试在预测为零时的准确性。观察混淆矩阵的第二列，[4, 52]。在这种情况下，准确率为52 / (52 + 4)，大约是0.93。这叫做**负预测值**（**NPV**）。你可以编写一个函数来根据阈值计算NPV：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then plot it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后绘制它：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/be4025da-47f3-4060-9590-8b888bb16644.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be4025da-47f3-4060-9590-8b888bb16644.png)'
- en: Receiver operating characteristic – ROC analysis
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收者操作特征 – ROC分析
- en: Along the same lines of examining NPV, there are standard measures that examine
    cells within a confusion matrix.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着检查NPV的思路，还有一些标准的度量方法用于检查混淆矩阵中的单元格。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Sensitivity
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏感性
- en: 'Sensitivity, like NPV in the previous section, is a mathematical function of
    the confusion matrix cells. Sensitivity is the proportion of people who took the
    test with a condition and were correctly labeled as having the condition, diabetes
    in this case:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感性，像上一节中的NPV一样，是混淆矩阵单元格的数学函数。敏感性是接受测试且实际患有疾病的人群中，正确标记为有疾病的人群的比例，在这个例子中是糖尿病：
- en: '![](img/29bbe2b5-5c8d-4b78-bc12-bbc736ff415d.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29bbe2b5-5c8d-4b78-bc12-bbc736ff415d.png)'
- en: 'Mathematically, it is the ratio of patients correctly labeled as having a condition
    (TP) divided by the total number of people who actually have the condition (TP
    + FN). First, recall the confusion matrix cells. Focus on the **Truth** row, which
    corresponds to *all people who have diabetes*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度看，它是正确标记为有疾病（TP）的患者与实际有疾病的所有人（TP + FN）之比。首先，回顾混淆矩阵的单元格。重点关注**真实**行，对应于*所有患有糖尿病的人*：
- en: '![](img/43d62022-e905-4a75-94aa-8f392ffee870.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43d62022-e905-4a75-94aa-8f392ffee870.png)'
- en: 'Consequently:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '![](img/65760563-8d44-4d1b-8d30-ef81a9bf88f1.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65760563-8d44-4d1b-8d30-ef81a9bf88f1.png)'
- en: Another name for sensitivity is **true positive rate** (**TPR**).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感性另一个名字是**真正阳性率**（**TPR**）。
- en: A visual perspective
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从视觉角度来看
- en: Another perspective on the confusion matrix is very visual. Let us visualize
    both the positive class having diabetes and the negative class having no diabetes
    with histograms (on the left column in the next diagram). Each class roughly looks
    like a normal distribution. With SciPy, I can find the best fit normal distributions.
    Note on the bottom right that the threshold is set to 0.5, the default setting
    in the logistic regression. Observe how the threshold causes us to select, imperfectly,
    **false negatives** (**FN**) and **false positives** (**FP**).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个角度来看，混淆矩阵非常直观。让我们用直方图（下一张图中的左列）来可视化有糖尿病的阳性类别和没有糖尿病的阴性类别。每个类别大致呈正态分布。借助SciPy，我可以找到最佳拟合的正态分布。右下角注明了阈值被设置为0.5，这是逻辑回归中的默认设置。观察阈值是如何让我们选择**假阴性**（**FN**）和**假阳性**（**FP**）的，尽管这种选择并不完美。
- en: '![](img/c6f1aa07-1abf-470c-b7ac-36d7e76b09e0.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6f1aa07-1abf-470c-b7ac-36d7e76b09e0.png)'
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Calculating TPR in scikit-learn
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在scikit-learn中计算TPR
- en: 'scikit-learn has convenient functions for calculating the sensitivity or TPR
    for the logistic regression given a vector of probabilities of the positive class,
    `y_pred_proba[:,1]`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: scikit-learn提供了方便的函数，用于根据阳性类别的概率向量`y_pred_proba[:,1]`来计算逻辑回归的敏感度或TPR：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, given the positive class vector, the `roc_curve` function in scikit-learn
    yielded a tuple of three arrays:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，给定阳性类别向量，scikit-learn中的`roc_curve`函数返回了一个包含三个数组的元组：
- en: The TPR array (denoted by `tpr`)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TPR数组（记作`tpr`）
- en: The FPR array (denoted by `fpr`)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FPR数组（记作`fpr`）
- en: A custom set of thresholds to calculate TPR and FPR (denoted by `ths`)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于计算TPR和FPR的自定义阈值集（记作`ths`）
- en: 'To elaborate on the **false positive rate** (**FPR**), it describes the rate
    of false alarms. It is the number of people incorrectly thought to have diabetes
    although they do not:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 详细说明**假阳性率**（**FPR**），它描述了假警报的发生率。它是错误地认为没有糖尿病的人却被判定为有糖尿病的比例：
- en: '![](img/1fe1f564-fd47-475b-bf6a-95d64b006750.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fe1f564-fd47-475b-bf6a-95d64b006750.png)'
- en: 'It is a statement of people who do not have diabetes. Mathematically, with
    the cells of the confusion matrix:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有糖尿病的人的陈述。从数学角度来看，混淆矩阵的单元格如下：
- en: '![](img/2a8a70d8-c8ea-4270-a7b2-c61494829ef9.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a8a70d8-c8ea-4270-a7b2-c61494829ef9.png)'
- en: Plotting sensitivity
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制敏感度图
- en: 'Plot sensitivity in the *y* axis and the thresholds in the *x* axis:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*y*轴绘制敏感度，在*x*轴绘制阈值：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](img/a026c031-1967-402d-81a1-4c8e7d51c7be.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a026c031-1967-402d-81a1-4c8e7d51c7be.png)'
- en: 'Thus, the lower the threshold, the better the sensitivity. Looking at the confusion
    matrix for the threshold at `0.1`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，阈值越低，敏感度越高。查看阈值为`0.1`时的混淆矩阵：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this case, no one went home believing they had diabetes when they did not.
    Yet, like our computation with NPV, when the test predicts that someone has diabetes,
    it is very inaccurate. The best scenario of this type is when the threshold is
    `0.146`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，没有人会误以为自己得了糖尿病。然而，就像我们在计算NPV时的情况一样，当测试预测某人患有糖尿病时，它的准确性非常低。这种情况下的最佳情形是当阈值为`0.146`时：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Even then, the test does not work when the person is predicted to have diabetes.
    It works 33 / (33 + 121) = 0.21, or 21% of the time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，当预测某人患有糖尿病时，测试结果也不起作用。它的有效性为33 / (33 + 121) = 0.21，或者说21%的准确率。
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The confusion matrix in a non-medical context
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非医疗背景下的混淆矩阵
- en: Suppose you are a banker and want to determine whether a customer deserves a
    mortgage loan to buy a house. Up next is a possible confusion matrix showing whether
    to give a person a mortgage loan based on customer data available to the bank.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一位银行工作人员，想要确定一个客户是否值得获得购买房屋的抵押贷款。接下来是一个可能的混淆矩阵，展示了根据银行可用的客户数据是否应该给某人抵押贷款。
- en: 'The task is to classify people and determine whether they should receive a
    mortgage loan or not. In this context, numbers can be assigned to every scenario.
    When every cell in the confusion matrix has a clear cost, it is easier to find
    the best classifier:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是对人群进行分类，并决定他们是否应该获得抵押贷款。在这种情况下，可以为每种情况分配一个数字。当混淆矩阵中的每个单元格都有明确的成本时，找到最佳分类器就更容易了：
- en: '![](img/fc33a826-1ae3-4fcd-b6f0-fe46c11304ff.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc33a826-1ae3-4fcd-b6f0-fe46c11304ff.png)'
- en: Plotting an ROC curve without context
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制没有上下文的ROC曲线
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'An ROC curve is a diagnostic tool for any classifier without any context. No
    context means that we do not know yet which error type (FP or FN) is less desirable
    yet. Let us plot it right away using a vector of probabilities, `y_pred_proba[:,1]`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ROC 曲线是任何分类器的诊断工具，没有任何上下文。没有上下文意味着我们尚不知道哪个错误类型（FP 或 FN）是更不可取的。让我们立即使用概率向量 `y_pred_proba[:,1]`
    绘制它：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![](img/aad4b839-f44c-4922-ac95-c0edb0c51ab1.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aad4b839-f44c-4922-ac95-c0edb0c51ab1.png)'
- en: The ROC is a plot of the FPR (false alarms) in the *x* axis and TPR (finding
    everyone with the condition who really has it) in the *y* axis. Without context,
    it is a tool to measure classifier performance.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ROC 曲线是 FPR（假警报）在 *x* 轴和 TPR（找出所有有病且确实有病的人）在 *y* 轴上的图示。没有上下文时，它是一个衡量分类器性能的工具。
- en: Perfect classifier
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完美分类器
- en: 'A perfect classifier would have a TPR of 1 regardless of the **false alarm
    rate** (**FAR**):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的分类器无论如何都会有 TPR 为 1，**假警报率**（**FAR**）：
- en: '![](img/8f83c56a-c8ed-4bc7-b11b-5897cb3d9be6.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f83c56a-c8ed-4bc7-b11b-5897cb3d9be6.png)'
- en: 'In the preceding graph, FN is very small; so the TPR, TP / (TP + FN), is close
    to 1\. Its ROC curve has an L-shape:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，FN 非常小；因此 TPR，TP / (TP + FN)，接近 1\. 其 ROC 曲线呈 L 形：
- en: '![](img/6f7fffa4-8f06-451e-a5a7-0b59e9b1a72f.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f7fffa4-8f06-451e-a5a7-0b59e9b1a72f.png)'
- en: Imperfect classifier
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不完美的分类器
- en: 'In the following images, the distributions overlap and the categories cannot
    be distinguished from one another:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，分布重叠，类别之间无法区分：
- en: '![](img/843b64d1-18f8-4b71-b71a-9056f62473bf.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/843b64d1-18f8-4b71-b71a-9056f62473bf.png)'
- en: 'In the imperfect classifier, FN and TN are nearly equal and so are FP and TP.
    Thus, by substitution, the TPR TP/ (TP + FP) is nearly equal to the **false negative
    rate** (**FNR**) FP/ (FP + TN). This is true even if you vary the threshold. Consequently,
    we obtain an ROC curve that is a straight line with a slope of about 1:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在不完美的分类器中，FN 和 TN 几乎相等，FP 和 TP 也几乎相等。因此，通过替代，TPR TP/ (TP + FP) 几乎等于**假阴性率**（**FNR**）FP/
    (FP + TN)。即使您改变阈值，这也是成立的。因此，我们得到的 ROC 曲线是斜率大约为 1 的直线：
- en: '![](img/a1a7e274-4ccc-4c4d-aa07-4fed11a65f7a.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1a7e274-4ccc-4c4d-aa07-4fed11a65f7a.png)'
- en: AUC – the area under the ROC curve
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AUC – ROC 曲线下面积
- en: 'The area of the L-shaped perfect classifier is 1 x 1 = 1\. The area of the
    bad classifier is 0.5\. To measure classifier performance, scikit-learn has a
    handy **area under the ROC curve** (**AUC**) calculating function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: L 形完美分类器的面积是 1 x 1 = 1\. 坏分类器的面积是 0.5\. 为了衡量分类器的性能，scikit-learn 提供了一个便捷的 **ROC
    曲线下面积**（**AUC**）计算函数：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Putting it all together – UCI breast cancer dataset
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起 – UCI 乳腺癌数据集
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The dataset is provided thanks to Street, N (1990), UCI machine learning repository
    ([https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data](https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data)),
    Madison, WI: University of Wisconsin, computer sciences department:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集感谢 Street, N (1990)，UCI 机器学习库提供 ([https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data](https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data))，威斯康星大学，麦迪逊，WI：计算机科学系：
- en: 'After reading the citation/license information, load the dataset from UCI:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读引用/许可证信息后，从 UCI 加载数据集：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Look at the data types:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看数据类型：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It turns out that the feature compactness has characters like `?`. For now,
    we do not use this feature.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，特征紧凑度具有像 `?` 这样的特征。目前，我们不使用这个特征。
- en: 'Now, reading the documentation, the target variable is set to `2` (not having
    cancer) and `4` (having cancer). Change the variables to `0` for not having cancer
    and `1` for having cancer:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，阅读文档，目标变量设置为 `2`（没有癌症）和 `4`（有癌症）。将变量更改为 `0` 代表没有癌症，`1` 代表有癌症：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define `X` and `y`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `X` 和 `y`：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Split `X` and `y` into training and testing sets:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `X` 和 `y` 分割成训练集和测试集：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Draw the ROC curve and compute the AUC score:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制 ROC 曲线并计算 AUC 分数：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](img/d754055f-d6fa-4430-acbc-b5c4eaaa6831.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d754055f-d6fa-4430-acbc-b5c4eaaa6831.png)'
- en: This classifier performs fairly well.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分类器表现得相当不错。
- en: Outline for future projects
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来项目的概要
- en: 'Overall, for future classification projects, you can do the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，对于未来的分类项目，您可以执行以下操作：
- en: Load the best data you can find for a particular problem.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载您能找到的最佳数据，以解决特定问题。
- en: 'Determine whether there is a classification context: is FP better or worse
    than FN?'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定是否有分类上下文：是 FP 更好还是 FN 更好？
- en: Perform training and testing of the data without context using ROC-AUC scores.
    If several algorithms perform poorly at this step, you might want to go back to
    step 1.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 ROC-AUC 分数对数据进行无上下文的训练和测试。如果几个算法在此步骤中表现不佳，您可能需要回到第 1 步。
- en: If the context is important, explore it with confusion matrices.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果上下文很重要，可以使用混淆矩阵进行探索。
- en: Logistic regression is particularly well suited for all these steps, though
    any algorithm with a `predict_proba()` method will work very similarly. As an
    exercise, you can generalize this process for other algorithms or even general
    regression if you are ambitious. The main point here is that not all errors are
    the same, a point easily emphasized with health datasets, wherein it is very important
    to treat all patients that have a condition.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归特别适合执行这些步骤，尽管任何具有 `predict_proba()` 方法的算法也能非常相似地工作。作为一个练习，如果您有雄心，可以将此过程推广到其他算法甚至是一般回归。这里的主要观点是，并非所有的错误都是相同的，这一点在健康数据集中尤其重要，因为治疗所有患有某种病症的患者非常关键。
- en: 'A final note on the breast cancer dataset: observe that the data consists of
    cell measurements. You can gather these measurements by automating looking at
    the pictures with computers and finding the measurements with a traditional program
    or machine learning.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 关于乳腺癌数据集的最后一点：观察数据由细胞测量值组成。您可以通过自动化计算机查看图片并使用传统程序或机器学习找到这些测量值来收集这些数据。
