- en: Foreign Exchange Rate Forecast
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外汇汇率预测
- en: In this chapter, we are going to start building regression models in C#. Up
    until now, we have built **machine learning** (**ML**) models with the goal of
    classifying data into binary or multiple buckets using logistic regression, Naive
    Bayes, and random forest learning algorithms. However, we are now going to switch
    gears and start building models that predict continuous outcomes. In this chapter,
    we will explore a financial dataset, more specifically a Foreign Exchange Rate
    market dataset. We will be using historical data of daily currency exchange rates
    between Euros (EUR) and U.S. Dollars (USD) to build a regression model that forecasts
    future exchange rates. We are going to start with the problem definition and then
    move on to data preparation and data analysis. During the data preparation and
    analysis steps, we are going to explore how we can manage the time series data
    and analyze the distributions of daily returns. Then, we are going to start building
    features that can forecast currency exchange rates in the feature engineering
    step. We are going to discuss a few commonly used technical indicators in the
    financial market, such as moving averages, Bollinger Bands, and lagging variables.
    Using those technical indicators, we will be building regression ML models using
    linear regression and **Support Vector Machine** (**SVM**) learning algorithms.
    While building such models, we will also explore some of the ways we can fine-tune
    hyperparameters for the SVM model. Lastly, we will discuss a few validation metrics
    and methods for evaluating our regression models. We will discuss how we can use
    **root mean square error** (**RMSE**), R², and an observed versus fitted values
    plot to evaluate the performances of our models. By the end of this chapter, you
    will have working regression models for forecasting daily EUR/USD exchange rates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用C#构建回归模型。到目前为止，我们已经构建了**机器学习**（**ML**）模型，目的是使用逻辑回归、朴素贝叶斯和随机森林学习算法将数据分类到二元或多个类别中。然而，我们现在将转换方向，开始构建预测连续结果的模型。在本章中，我们将探索一个金融数据集，更具体地说是一个外汇汇率市场数据集。我们将使用欧元（EUR）和美元（USD）之间的每日汇率的历史数据来构建一个预测未来汇率的回归模型。我们将从问题定义开始，然后转向数据准备和数据分析。在数据准备和分析步骤中，我们将探讨如何管理时间序列数据和分析每日回报率的分布。然后，在特征工程步骤中，我们将开始构建可以预测货币汇率的特征。我们将讨论金融市场中常用的几个技术指标，例如移动平均线、布林带和滞后变量。使用这些技术指标，我们将使用线性回归和支持向量机（SVM）学习算法构建回归ML模型。在构建这些模型的同时，我们还将探讨一些微调SVM模型超参数的方法。最后，我们将讨论几个验证指标和评估回归模型的方法。我们将讨论如何使用**均方根误差**（**RMSE**）、R²以及观察值与拟合值图来评估我们模型的性能。到本章结束时，你将拥有用于预测每日EUR/USD汇率的工作回归模型。
- en: 'In this chapter, we will cover the following steps:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下步骤：
- en: Problem definition for the Foreign Exchange Rate (EUR versus USD) forecast project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外汇汇率（欧元对美元）预测项目的问题定义
- en: Data preparation using time-series functionalities in the Deedle framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Deedle框架中的时间序列功能进行数据准备
- en: Time series data analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列数据分析
- en: Feature engineering using various technical indicators in Forex
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外汇中的各种技术指标进行特征工程
- en: Linear regression versus SVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归与支持向量机（SVM）的比较
- en: Model validations using RMSE, R², and the actual versus predicted plot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RMSE、R²以及实际与预测图进行模型验证
- en: Problem definition
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题定义
- en: Let's start this chapter by defining what we are trying to solve in this project.
    You might have heard the terms *Algorithmic Trading* or *Quantitative Finance/Trading*.
    This is one of the well-known fields in the finance industry where data science
    and ML meet finance. Algorithmic Trading or Quantitative Finance refers to a strategy
    where you use statistical learning models that were built from a large amount
    of historical data to forecast future financial market movements. Such strategies
    and techniques are used widely by various traders and investors forecast future
    prices for various financial assets. The foreign exchange market is one of the
    largest and most liquid financial markets, and a large pool of traders and investors
    take part in it. It is a unique market that is open 24 hours a day and five days
    a week and traders from all over the world come in to buy and sell certain currency
    pairs. Due to this advantage and uniqueness, the foreign exchange market is also
    an attractive financial market for algorithmic and quantitative traders to build
    ML models to forecast future exchange rates and automate their trades to take
    advantage of the fast decisions and executions that computers can make.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义本项目试图解决的问题开始这一章。你可能听说过术语*算法交易*或*量化金融/交易*。这是金融行业中数据科学和机器学习与金融相结合的知名领域之一。算法交易或量化金融指的是一种策略，即你使用从大量历史数据构建的统计学习模型来预测未来的金融市场走势。这些策略和技术被各种交易者和投资者广泛使用，以预测各种金融资产的未来价格。外汇市场是最大的、流动性最强的金融市场之一，大量的交易者和投资者参与其中。这是一个独特的市场，每天24小时、每周5天开放，来自世界各地的交易者进入市场买卖特定的货币对。由于这一优势和独特性，外汇市场也是算法交易和量化交易者构建机器学习模型来预测未来汇率并自动化他们的交易以利用计算机做出的快速决策和执行的吸引人的金融市场。
- en: 'To get a feel for how we can apply our ML knowledge to financial markets and
    regression models, we are going to use historical data of daily EUR/USD rates
    from January 1, 1999 to December 31st, 2017\. We are going to use a publicly available
    dataset, which can be downloaded from this link: [http://www.global-view.com/forex-trading-tools/forex-history/index.html](http://www.global-view.com/forex-trading-tools/forex-history/index.html).
    With this data, we are going to build features by using commonly used technical
    indicators, such as moving averages, Bollinger Bands, and lagging variables. Then,
    we are going to build regression models using linear regression and SVM learning
    algorithms that forecast future daily exchange rates for EUR/USD currency pairs.
    Once we have built these models, we are going to use RMSE, R^([2]), and a plot
    of observed values against predicted values to evaluate our models.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们如何将我们的机器学习知识应用于金融市场和回归模型，我们将使用从1999年1月1日到2017年12月31日的每日EUR/USD汇率的历史数据。我们将使用一个公开可用的数据集，可以从以下链接下载：[http://www.global-view.com/forex-trading-tools/forex-history/index.html](http://www.global-view.com/forex-trading-tools/forex-history/index.html)。使用这些数据，我们将通过使用常用的技术指标，如移动平均线、布林带和滞后变量来构建特征。然后，我们将使用线性回归和SVM学习算法构建回归模型，以预测EUR/USD货币对的未来每日汇率。一旦我们构建了这些模型，我们将使用RMSE、R^([2])以及观察值与预测值对比图来评估我们的模型。
- en: 'To summarize our problem definition for the foreign exchange rate forecasting
    project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们对外汇汇率预测项目的问题定义：
- en: What is the problem? We need a regression model that forecasts future foreign
    exchange rates between Euros and U.S. Dollars; more specifically, we want to build
    a ML model that forecasts daily changes in EUR/USD exchange rates.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题是怎样的？我们需要一个回归模型来预测欧元和美元之间的未来汇率；更具体地说，我们希望构建一个机器学习模型来预测EUR/USD汇率每日的变化。
- en: Why is it a problem? Due to the fast-paced and volatile environments in the
    foreign exchange market, it is advantageous to have a ML model that can forecast
    and make autonomous decisions on when to buy and when to sell certain currency
    pairs.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么这是一个问题？由于外汇市场的快节奏和波动性环境，拥有一个能够预测并自主决定何时买入和何时卖出特定货币对的机器学习模型是有利的。
- en: What are some of the approaches to solving this problem? We are going to use
    historical data of daily exchange rates between EUR and USD. With this dataset,
    we are going to build financial features using often used technical indicators,
    such as moving averages, Bollinger Bands, and lagging variables. We will explore
    linear regression and SVM learning algorithms as our candidates for the regression
    model. Then, we will look at RMSE, R², and use an observed versus predicted plot
    to evaluate the performances of the models that we built.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决这个问题的有哪些方法？我们将使用欧元与美元之间的每日汇率的历史数据。使用这个数据集，我们将使用常用的技术指标，如移动平均线、布林带和滞后变量来构建金融特征。我们将探索线性回归和SVM学习算法作为我们的回归模型候选。然后，我们将查看RMSE、R²，并使用观察值与预测值图来评估我们构建的模型的表现。
- en: What are the success criteria? We want low RMSE, as we want our predictions
    to be as close to the actual values as possible. We want high R², as it indicates
    the goodness of fit for our models. Lastly, we would like to see data points lined
    up closely to a diagonal line in the observed versus predicted plot.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功标准是什么？我们希望RMSE低，因为我们希望我们的预测尽可能接近实际值。我们希望R²高，因为它表示我们模型的拟合优度。最后，我们希望看到数据点在观察值与预测值图中紧密地排列在对角线上。
- en: Data preparation
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据准备
- en: Now that we know what kind of problem we are trying to solve in this chapter,
    let's start looking into the data. Unlike the two previous chapters, where we
    precompiled and prelabeled data, we are going to start with raw EUR/USD exchange
    rate data. Follow this link: [http://www.global-view.com/forex-trading-tools/forex-history/index.html](http://www.global-view.com/forex-trading-tools/forex-history/index.html)
    and select **EUR/USD Close**, **EUR/USD High**, and **EUR/USD Low**. You can also
    select different currency pairs, if you'd like to explore different datasets.
    Once you have selected the data points you want, you can then select the start
    and end dates and you can also choose whether you want to download daily, weekly,
    or monthly data. For this chapter, we choose **01/01/1999** as the **Start Date**
    and **12/31/2017** as the **Stop Date** and we download the daily dataset that
    contains close, high, and low prices for the EUR/USD currency pair.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了本章试图解决的问题类型，让我们开始查看数据。与前面两章不同，那里我们预先编译并预先标记了数据，我们将从原始的EUR/USD汇率数据开始。点击此链接：[http://www.global-view.com/forex-trading-tools/forex-history/index.html](http://www.global-view.com/forex-trading-tools/forex-history/index.html)并选择**EUR/USD收盘价**、**EUR/USD最高价**和**EUR/USD最低价**。如果您想探索不同的数据集，您也可以选择不同的货币对。一旦您选择了想要的数据点，您可以选择开始和结束日期，也可以选择您想要下载的每日、每周或每月数据。对于本章，我们选择**1999年1月1日**作为**开始日期**，**2017年12月31日**作为**结束日期**，并下载包含EUR/USD货币对收盘价、最高价和最低价的每日数据集。
- en: 'Once you have downloaded the data, there are a few tasks we need to do to get
    it ready for our future data analysis, feature engineering, and ML modeling. First,
    we need to define target variables. As discussed in our problem definition step,
    our target variable is going to be the daily change in EUR/USD exchange rates.
    To compute daily returns, we need to subtract the previous day''s close price
    from today''s close price and then divide it by previous day''s close price. The
    formula for calculating daily returns is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完数据后，我们需要做一些任务来为未来的数据分析、特征工程和机器学习建模做好准备。首先，我们需要定义目标变量。正如我们在问题定义步骤中讨论的，我们的目标变量将是EUR/USD汇率每日变化。为了计算每日回报率，我们需要从今天的收盘价中减去昨天的收盘价，然后除以昨天的收盘价。计算每日回报率的公式如下：
- en: '![](img/00051.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00051.jpeg)'
- en: 'We can use the `Diff` method in Deedle''s data frame to calculate the difference
    between the previous price and the current price. You can actually use the `Diff`
    method to calculate the difference between a data point at any arbitrary point
    in time and the current data point. For example, the following code shows how
    you can calculate the differences between the current data point and the data
    points at one step ahead, three steps ahead, and five steps ahead:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Deedle数据框中的`Diff`方法来计算前一个价格和当前价格之间的差异。实际上，您可以使用`Diff`方法来计算任何任意时间点的数据点与当前数据点之间的差异。例如，以下代码显示了如何计算当前数据点与一步之遥、三步之遥和五步之遥的数据点之间的差异：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/00052.gif)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00052.gif)'
- en: 'Using this `Diff` method, the following code is how we can calculate the daily
    returns of EUR/USD exchange rates:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `Diff` 方法，以下是如何计算 EUR/USD 汇率的每日回报的代码：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we are taking the difference in close prices between the previous
    day and the current day and then dividing them by the previous close price. By
    multiplying them by `100`, we can get the daily returns in a percentage. Finally,
    we add this daily return series back to the original data frame with a column
    name, `DailyReturn`, by using the `AddColumn` method in Deedle's data frame.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们计算了前一天和当天收盘价之间的差异，然后除以前一天的收盘价。通过乘以 `100`，我们可以得到百分比形式的每日回报。最后，我们使用 Deedle
    数据框中的 `AddColumn` 方法，将这个每日回报序列添加到原始数据框中，列名为 `DailyReturn`。
- en: 'However, we are not quite done yet with building the target variables. Since
    we are building a forecasting model, we need to take the next day return as the
    target variable. We can use the `Shift` method in Deedle''s data frame to associate
    each record with the next day return. Similar to the `Diff` method, you can use
    the `Shift` method to move a series back and forth to any arbitrary point in time.
    The following code shows how you can move the `DailyReturn` column by `1`, `3`,
    and `5` steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在构建目标变量方面还没有完成。由于我们正在构建一个预测模型，我们需要将下一天的回报作为目标变量。我们可以使用 Deedle 数据框中的 `Shift`
    方法将每个记录与下一天的回报关联起来。类似于 `Diff` 方法，你可以使用 `Shift` 方法将序列向前或向后移动到任何任意的时间点。以下是如何将 `DailyReturn`
    列通过 `1`、`3` 和 `5` 步移动的代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/00053.gif)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.gif)'
- en: 'As you can see from this example, the `DailyReturn` column or series has been
    moved forward by `1`, `3`, and `5` steps, depending on the parameters you fed
    into the `Shift` method. Using this `Shift` method, we are going to move daily
    returns back one step, so that each record has the next day''s return as a target
    variable. The following code is how we created a target variable column, `Target`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，`DailyReturn` 列或序列已经根据你输入到 `Shift` 方法的参数向前移动了 `1`、`3` 和 `5` 步。使用这个 `Shift`
    方法，我们将每日回报向前移动一步，以便每个记录都有下一天的回报作为目标变量。以下是如何创建目标变量列 `Target` 的代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have encoded target variables, there is one more step we need to
    take to get our data prepared for future tasks. When you are working with financial
    data, you will often hear the terms *OHLC chart* or *OHLC prices*. OHLC stands
    for Open, High, Low, and Close and it is often used to show price movements over
    time. If you look at the data that we downloaded, you will notice that open prices
    are missing in the dataset. However, we are going to need open prices for our
    future feature engineering step. We are going to assume that the open price for
    a given day is the close price of the previous day, given that the foreign exchange
    market is run 24 hours a day and is very liquid with high trading volume. In order
    to take previous close prices as open prices, we are going to use the `Shift`
    method. The following code shows how we created and added open prices into our
    data frame:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编码了目标变量，我们还需要进行一个额外的步骤来为未来的任务准备数据。当你处理金融数据时，你经常会听到术语 *OHLC 图表* 或 *OHLC
    价格*。OHLC 代表开盘价、最高价、最低价和收盘价，通常用于显示价格随时间的变化。如果你查看我们下载的数据，你会注意到数据集中缺少开盘价。然而，为了我们未来的特征工程步骤，我们需要开盘价。鉴于外汇市场每天24小时运行，并且交易量很大，非常流动，我们将假设给定一天的开盘价是前一天收盘价。为了将前一天的收盘价作为开盘价，我们将使用
    `Shift` 方法。以下是如何创建并添加开盘价到我们的数据框中的代码：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code is the full code that we used for the data preparation step:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们用于数据准备步骤的完整代码：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When you run this code, it is going to output the results into a file named `eurusd-daily-ohlc.csv`,
    which contains the OHLC prices, daily returns, and target variables. We are going
    to use this file for the future data analysis and feature engineering steps.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，它将输出结果到一个名为 `eurusd-daily-ohlc.csv` 的文件中，该文件包含开盘价、最高价、最低价和收盘价，以及每日回报和目标变量。我们将使用这个文件进行未来的数据分析特征工程步骤。
- en: This code can also be found in the following repository: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataPrep.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataPrep.cs).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码也可以在以下仓库中找到： [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataPrep.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataPrep.cs)。
- en: Time series data analysis
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列数据分析
- en: 'Let''s start looking into the data. We are going to take the output from the
    previous data preparation step and start looking at the distributions of daily
    returns. Unlike previous chapters, where we primarily worked with categorical
    variables, we are dealing with continuous and time series variables. We will look
    at this data in a few different ways. First, let''s look at the time series close
    prices chart. The following code shows how to build a line chart using the Accord.NET
    framework:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始查看数据。我们将从之前的数据准备步骤的输出开始，查看每日收益的分布情况。与之前的章节不同，我们主要处理的是分类变量，而现在我们处理的是连续和时间序列变量。我们将以几种不同的方式查看这些数据。首先，让我们查看时间序列收盘价图表。以下代码展示了如何使用Accord.NET框架构建折线图：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Refer to the Accord.NET documentation the `DataSeriesBox.Show` method for various
    other ways to display a line chart. In this example, we built a line chart with
    the integer indexes of our data frame as the *x* axis values and the close prices
    as the *y* axis values. The following is the time series line chart that you will
    see when you run the code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考Accord.NET文档中的`DataSeriesBox.Show`方法，了解显示折线图的多种其他方式。在这个例子中，我们使用数据框的整数索引作为*x*轴值，收盘价作为*y*轴值来构建折线图。以下是在运行代码时您将看到的时序线图表：
- en: '![](img/00054.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00054.jpeg)'
- en: 'This chart shows us the overall movements of EUR/USD exchange rates over time
    from 1999 to 2017\. It started from around 1.18 and went below 1.0 in 2000 and
    2001\. Then, it went as high as 1.6 in 2008 and then ended 2017 at around 1.20\.
    Let''s now look at the historical daily returns. The following code shows you
    how to build a line chart of historical daily returns:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表显示了从1999年到2017年EUR/USD汇率随时间的变化情况。它从大约1.18开始，在2000年和2001年降至1.0以下。然后，它在2008年达到了1.6的高点，并在2017年结束时的约为1.20。现在，让我们查看历史每日收益。以下代码展示了如何构建历史每日收益的折线图：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One thing to note here is the usage of the `FillMissing` method. If you remember
    from the previous data preparation step, the `DailyReturn` series was built by
    taking the difference between the previous period and the current period. As a
    result, we have a missing value for the very first data point, since there is
    no previous period data point for the first record. The `FillMissing` method helps
    you encode missing values with custom values. Depending on your dataset and assumptions,
    you can encode missing values with different values, and the `FillMissing` method
    in Deedle's data frame will come in handy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点需要注意，即`FillMissing`方法的用法。如果您还记得之前的数据准备步骤，`DailyReturn`序列是通过计算前一时期与当前时期的差值来构建的。因此，对于第一个数据点，我们没有前一时期的数据点，所以存在一个缺失值。`FillMissing`方法可以帮助您使用自定义值来编码缺失值。根据您的数据集和假设，您可以使用不同的值来编码缺失值，Deedle数据框中的`FillMissing`方法将非常有用。
- en: 'When you run the previous code, it will display a chart as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行前面的代码时，它将显示如下图表：
- en: '![](img/00055.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00055.jpeg)'
- en: 'As you can see from this chart, daily returns oscillate around **0**, mostly
    between -2.0% and +2.0%. Let''s look at the distribution of daily returns more
    closely. We are going to look at the minimum, maximum, mean, and standard deviation
    values. Then, we are going to look at the quartiles of daily returns, which we
    will discuss in more detail after looking at the code. The code to compute those
    numbers is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这张图表中可以看到，每日收益在**0**附近波动，主要介于-2.0%和+2.0%之间。让我们更仔细地查看每日收益的分布情况。我们将查看最小值、最大值、平均值和标准差。然后，我们将查看每日收益的四分位数，我们将在查看代码后更详细地讨论这一点。计算这些数字的代码如下：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see from this code, the Deedle framework has numerous built-in methods for
    computing basic statistics. As shown in the first six lines of the code, you can
    use the `Max`, `Mean`, `Median`, `Min`, and `StdDev` methods in the Deedle framework
    in order to get corresponding statistics for daily returns.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中可以看到，Deedle框架提供了许多内置方法用于计算基本统计数据。正如代码的前六行所示，您可以使用Deedle框架中的`Max`、`Mean`、`Median`、`Min`和`StdDev`方法来获取每日收益的相应统计数据。
- en: 'In order to get quartiles, we need to use the `Quantiles` method in the `Accord.Statistics.Measures`
    module of the Accord.NET Framework. Quantiles are the points that divide an ordered
    distribution into equal-length intervals. For example, ten-quantiles break an
    ordered distribution into ten subsets of equal sizes, so that the first subset
    represents the bottom 10% of the distribution and the last subset represents the
    top 10% of the distribution. Similarly, four-quantiles break an ordered distribution
    into four subsets of equal sizes, where the first subset represents the bottom
    25% of the distribution and the last subset represents the top 25% of the distribution.
    Four-quantiles are often called **quartiles**, ten-quantiles are called **deciles**,
    and 100-quantiles are called **percentiles**. As you can deduce from these definitions,
    the 1^(st )quartile is the same as the 0.25^(th )decile and the 25^(th )percentile.
    Similarly, the 2^(nd )and 3^(rd )quartiles are the same as the 0.50^(th )and 0.75^(th )deciles and the
    50^(th )and 75^(th )percentiles. As we are interested in the quartiles, we used
    25%, 50%, and 75% as the inputs for the `percentiles` parameter in the `Quantiles`
    method. The following shows the output when you run this code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取四分位数，我们需要在 Accord.NET 框架的 `Accord.Statistics.Measures` 模块中使用 `Quantiles`
    方法。四分位数是将有序分布划分为等长度区间的点。例如，十个四分位数将有序分布划分为十个大小相等的子集，因此第一个子集代表分布的底部 10%，最后一个子集代表分布的顶部
    10%。同样，四个四分位数将有序分布划分为四个大小相等的子集，其中第一个子集代表分布的底部 25%，最后一个子集代表分布的顶部 25%。四个四分位数通常被称为**四分位数**，十个四分位数被称为**十分位数**，而一百个四分位数被称为**百分位数**。从这些定义中，你可以推断出第一个四分位数与
    0.25 分位数和 25 分位数相同。同样，第二个和第三个四分位数与 0.50 分位数和 0.75 分位数以及 50 分位数和 75 分位数相同。由于我们对四分位数感兴趣，我们在
    `Quantiles` 方法中使用了 25%、50% 和 75% 作为 `percentiles` 参数的输入。以下是在运行此代码时的输出：
- en: '![](img/00056.gif)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.gif)'
- en: 'Similar to what we have noticed from the daily return time series line chart,
    mean, and median are about 0, suggesting the daily returns oscillate around 0%.
    From 1999 to 2017, the largest negative daily return in history is -2.86% and
    the largest positive daily return is 3.61%. The first quartile, which is the middle
    number between the minimum and median, is at -0.36% and the third quartile, which
    is the middle number between the median and the maximum, is at 0.35%. From these
    summary statistics, we can see that the daily returns are spread almost symmetrically
    from 0%. To show this more visually, let''s now look at the histogram of daily
    returns. The code to plot a histogram of daily returns is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们从日回报率时间序列线图、平均值和中位数中观察到的类似，平均值和中位数大约为 0，这表明日回报率围绕 0% 振荡。从 1999 年到 2017 年，历史上最大的负日回报率是
    -2.86%，最大的正日回报率是 3.61%。第一个四分位数，即最小值和平均值之间的中间数，为 -0.36%，第三个四分位数，即平均值和最大值之间的中间数，为
    0.35%。从这些汇总统计数据中，我们可以看到日回报率几乎对称地分布在 0% 附近。为了更直观地展示这一点，现在让我们看一下日回报率的直方图。绘制日回报率直方图的代码如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We used `HistogramBox` in the Accord.NET framework to build a histogram chart
    of daily returns. Here, we set the number of bins as `20`. You can increase or
    decrease the number of bins to show more or less granular buckets. When you run
    this code, the following chart is what you will see:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Accord.NET 框架中使用了 `HistogramBox` 来构建日回报率的直方图图表。在这里，我们将桶的数量设置为 `20`。你可以增加或减少桶的数量以显示更多或更少的粒度桶。当你运行此代码时，你将看到以下图表：
- en: '![](img/00057.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: Similar to what we have observed in the summary statistics, daily returns are
    spread almost symmetrically from 0%. This histogram of daily returns shows a clear
    bell curve, which suggests that daily returns follow a normal distribution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在摘要统计中观察到的类似，日回报率几乎对称地分布在 0% 附近。这个日回报率的直方图显示了一个清晰的钟形曲线，这表明日回报率遵循正态分布。
- en: The full code that we ran for this data analysis step can be found at this link: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataAnalyzer.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataAnalyzer.cs).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行此数据分析步骤的完整代码可以在以下链接中找到：[https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataAnalyzer.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/DataAnalyzer.cs)。
- en: Feature engineering
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征工程
- en: Now that we have a better understanding of the distribution of daily returns,
    let's start building features for our ML modeling. In this step, we are going
    to discuss a couple of frequently used technical indicators that traders in the
    foreign exchange market use and how we can build features for our ML models using
    those technical indicators.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对每日收益率的分布有了更好的理解，让我们开始为我们的机器学习建模构建特征。在这一步，我们将讨论一些在外汇市场中被交易者频繁使用的技术指标，以及我们如何使用这些技术指标为我们的机器学习模型构建特征。
- en: Moving average
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平均线
- en: 'The first set of features we are going to build moving averages. A moving average
    is a rolling average for a pre-defined number of periods and is an often used
    technical indicator. A moving average helps smooth out volatile price movements
    and shows the overall trends of price actions. An in-depth discussion about how
    moving averages are used in trading financial assets is beyond the scope of this
    book, but in short, looking at multiple moving averages with different timeframes
    helps traders to identify trends and support and resistance levels for trading.
    In this chapter, we are going to use four moving averages, where the look-back
    periods are 10 days, 20 days, 50 days, and 200 days. The following code shows
    how we can compute moving averages using the `Window` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的第一个特征集是移动平均线。移动平均线是预定义数量的周期内的滚动平均，是一种常用的技术指标。移动平均线有助于平滑价格波动，并显示价格行为的整体趋势。关于移动平均线在交易金融资产中的应用的深入讨论超出了本书的范围，但简而言之，查看不同时间框架的多个移动平均线有助于交易者识别趋势和交易中的支撑和阻力水平。在本章中，我们将使用四个移动平均线，其回望周期分别为10天、20天、50天和200天。以下代码展示了我们如何使用`Window`方法计算移动平均线：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Window` method in the Deedle framework helps us easily compute moving
    averages. The `Window` method takes a data frame and builds a series of data frames
    where each data frame contains a pre-defined number of records. For example, if
    your input to the `Window` method is `10`, then it is going to build a series
    of data frames, where the first data frame contains records from the 0th index
    to the 9^(th) index, the second data frame contains records from the 1^(st) index
    to the 11^(th) index, and so forth. Using this method, we can easily compute moving
    averages for different time windows, as shown in the code. Now, let''s plot a
    time series close price chart with these moving averages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Deedle框架中的`Window`方法帮助我们轻松计算移动平均线。`Window`方法接受一个数据框，并构建一系列数据框，其中每个数据框包含一个预定义数量的记录。例如，如果你的`Window`方法的输入是`10`，那么它将构建一系列数据框，其中第一个数据框包含从0索引到9索引的记录，第二个数据框包含从1索引到11索引的记录，依此类推。使用这种方法，我们可以轻松计算不同时间窗口的移动平均线，如代码所示。现在，让我们绘制一个包含这些移动平均线的时序收盘价图表：
- en: '![](img/00058.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00058.jpeg)'
- en: 'As you can see from this chart, moving averages smooth out volatile price movements.
    The red line shows moving averages of 10 days, the green line shows moving averages
    of 20 days, the black line for 50 days, and the pink line for 200 days. As you
    can see from this chart, the shorter the time window the closer it follows price
    actions and the less smooth the chart is. The code we used to generate this chart
    is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这张图表中可以看到，移动平均线平滑了价格波动。红色线表示10天的移动平均线，绿色线表示20天的移动平均线，黑色线表示50天，粉色线表示200天。从这张图表中可以看出，时间窗口越短，它就越接近价格变动，图表就越不平滑。我们用来生成这张图表的代码如下：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With these moving averages we just calculated, the actual features that we
    are going to use for our model are the distances between the close price and the
    moving averages. As briefly mentioned, moving averages often work as support and
    resistance levels and by looking at how far each price point is from each of the
    moving averages, we can figure out whether we are approaching the support and
    resistance lines. The code to calculate the distances between the close price
    and the moving averages is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们刚刚计算出的这些移动平均线，我们将用于我们模型的实际特征是收盘价与移动平均线之间的距离。正如简要提到的，移动平均线通常充当支撑和阻力水平，通过观察每个价格点与每个移动平均线的距离，我们可以判断我们是否正在接近支撑和阻力线。计算收盘价与移动平均线之间距离的代码如下：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Bollinger Bands
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布林带
- en: 'The second technical indicator that we are going to look at is Bollinger Bands. Bollinger
    Bands comprise a moving average and the moving standard deviation of the same
    time window as the moving average that it is using. Then, Bollinger Bands are
    plotted two standard deviations above and below the moving average on the price
    time series chart. We will use a 20-day time window for computing Bollinger Bands.
    The code to compute Bollinger Bands is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第二项技术指标是布林带。布林带由移动平均和与移动平均相同时间窗口的移动标准差组成。然后，布林带在价格时间序列图上绘制在移动平均上方和下方两个标准差的位置。我们将使用20日时间窗口来计算布林带。计算布林带的代码如下：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see from this code, we are using the `Window` and `StdDev` methods
    to calculate moving standard deviations. Then, we calculate the upper and lower
    boundaries of Bollinger Bands by adding and subtracting two standard deviations
    from 20-day moving averages. When you plot Bollinger Bands with price series,
    the result looks as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中可以看到，我们正在使用`Window`和`StdDev`方法来计算移动标准差。然后，我们通过从20日移动平均中加减两个标准差来计算布林带的上限和下限。当您在价格时间序列图上绘制布林带时，结果如下所示：
- en: '![](img/00059.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00059.jpeg)'
- en: 'The blue line shows the price movements, the green line shows 20-day moving
    averages, the red line shows the upper boundary of Bollinger Bands, which is two
    standard deviations above the moving averages, and the black line shows the lower
    boundary of Bollinger Bands, which is two standard deviations below the moving
    averages. As you can see from this chart, Bollinger Bands form bands around the
    price movements. The code to display this chart is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝线表示价格变动，绿线表示20日移动平均，红线表示布林带的上限，即比移动平均高出两个标准差，黑线表示布林带的下限，即比移动平均低出两个标准差。如您从这张图表中看到，布林带在价格变动周围形成带状。显示此图表的代码如下：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similar to the previous case of moving averages, we are going to use the distances
    between the close price and Bollinger Bands. Since most of the trades are made
    between the upper and lower bands, the distances between the price and the bands
    can be features for our ML models. The code to calculate the distances is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的移动平均案例类似，我们将使用收盘价与布林带之间的距离。由于大多数交易都是在上下带之间进行的，因此价格与带之间的距离可以成为我们机器学习模型的特征。计算距离的代码如下：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Lagged variables
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滞后变量
- en: 'Finally, the last set of features we are going to use is lagged variables.
    Lagged variables contain information about previous periods. For example, if we
    use the daily return value of a previous day as a feature for our model, then
    it is a lagged variable that lagged one period. We can also use the daily return
    of two days prior to the current date as a feature for our model. These types
    of variable are called **lagged variables** and are often used in time series
    modeling. We are going to use daily returns and previously built features as lagged
    variables. In this project, we look back as far as five periods, but you can experiment
    with longer or shorter look-back periods. The code to create lagged variables
    for daily returns is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用的一组最后特征是滞后变量。滞后变量包含关于先前时期的信息。例如，如果我们使用前一天的日回报值作为我们模型的特征，那么它就是一个滞后了一个周期的滞后变量。我们还可以使用当前日期前两天的日回报作为我们模型的特征。这类变量被称为**滞后变量**，通常用于时间序列建模。我们将使用日回报和先前构建的特征作为滞后变量。在这个项目中，我们回顾了五个周期，但您可以尝试更长的或更短的回顾周期。创建日回报滞后变量的代码如下：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similarly, we can create lagged variables for the differences between moving
    averages and the close prices, using the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用以下代码为移动平均与收盘价之间的差异创建滞后变量：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lastly, we can create lagged variables for Bollinger Band indicators, using
    the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下代码为布林带指标创建滞后变量：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see from these code snippets, it is very simple and straightforward
    to create such lagged variables. We can simply use the `Shift` method in the Deedle
    framework and change the input to the method according to the look-back period.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些代码片段中可以看到，创建这样的滞后变量非常简单直接。我们只需在Deedle框架中使用`Shift`方法，并根据回顾周期更改方法输入。
- en: 'One last thing we are going to do in this section is drop the missing values.
    Because we were building many time series features, we created a lot of missing
    values. For example, when we calculate 200-day moving averages, the first 199
    records will have no moving averages, and as a result will have missing values.
    When you happen to have missing values in your dataset, there are two ways you
    can handle them—you can either encode them with certain values, or drop the missing
    values from the dataset. Since we have enough data, we are going to drop all the
    records with missing values. The code for dropping missing values from our data
    frame is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将做的一件事是删除缺失值。因为我们构建了许多时间序列特征，所以我们创建了很多缺失值。例如，当我们计算200天的移动平均时，前199条记录将没有移动平均，因此将会有缺失值。当您在数据集中遇到缺失值时，有两种方法可以处理它们——您可以用某些值编码它们，或者从数据集中删除缺失值。由于我们有足够的数据，我们将删除所有包含缺失值的记录。从我们的数据框中删除缺失值的代码如下：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see from this code, the Deedle framework has a handy function that
    we can use to drop missing values. We can use the `DropSparseRows` method to drop
    all the missing values. When you run this code, your output will look as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中可以看到，Deedle框架有一个方便的函数，我们可以用它来删除缺失值。我们可以使用`DropSparseRows`方法来删除所有缺失值。当您运行这段代码时，您的输出将如下所示：
- en: '![](img/00060.gif)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00060.gif)'
- en: 'As you can see from this output, it dropped 250 records for having missing
    values. The full code to run the data analysis step from end to end can be found
    at this link: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/FeatureEngineer.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/FeatureEngineer.cs).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中可以看到，它删除了250条因缺失值而导致的记录。运行数据分析步骤的完整代码可以在以下链接中找到：[https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/FeatureEngineer.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/FeatureEngineer.cs)。
- en: Linear regression versus SVM
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性回归与SVM对比
- en: In this section, we are going to build models that are completely different
    from previous chapters. We are going to build models that predict continuous variables
    and provide a daily return of EUR/USD exchange rates, and we are going to use
    two new learning algorithms, linear regression and SVM. Linear regression models
    try to find linear relationships between the target variables and the features,
    whereas SVM models try to build hyperplanes that maximize the distances between
    different classes. For this foreign exchange rate forecasting project, we are
    going to discuss how to build linear regression and SVM models for regression
    problems in C# using the Accord.NET Framework.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建与之前章节完全不同的模型。我们将构建预测连续变量的模型，并提供EUR/USD汇率每日回报率，我们将使用两种新的学习算法，即线性回归和SVM。线性回归模型试图在目标变量和特征之间找到线性关系，而SVM模型试图构建最大化不同类别之间距离的超平面。对于这个外汇汇率预测项目，我们将讨论如何使用Accord.NET框架在C#中构建线性回归和SVM模型来解决回归问题。
- en: 'Before we build models, we will have to split our sample set into two subsets—one
    for training and another for testing. In the previous chapter, we used `SplitSetValidation`in
    the Accord.NET Framework to randomly split a sample set into train and test sets
    at a pre-defined proportion. However, we cannot apply the same approach in this
    chapter. Since we are dealing with time series data, we cannot randomly select
    and split records into train and test sets. If we do randomly split the sample
    set, then we are going to have cases where we train our ML models with future
    events and test our models on past events. So, we want to split our sample set
    at a certain point in time and take the records up to that point into a train
    set and the records after that point into a test set. The following code shows
    how we split our sample set into train and test sets:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建模型之前，我们必须将我们的样本集分成两个子集——一个用于训练，另一个用于测试。在上一章中，我们使用了Accord.NET框架中的`SplitSetValidation`来随机将样本集分成训练集和测试集，按照预定义的比例。然而，我们无法在本章中采用相同的方法。因为我们处理的是时间序列数据，我们不能随机选择并分割记录为训练集和测试集。如果我们随机分割样本集，那么我们可能会遇到用未来的事件训练我们的机器学习模型，而在过去的事件上测试模型的情况。因此，我们希望在某个时间点分割我们的样本集，并将那个时间点之前的记录放入训练集，之后的记录放入测试集。下面的代码展示了我们如何将样本集分割成训练集和测试集：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we are ready to start building model objects and training our ML models.
    Let''s first look at how to instantiate a linear regression model. The code we
    used to train a linear regression model is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始构建模型对象并训练我们的机器学习模型了。让我们首先看看如何实例化一个线性回归模型。我们用来训练线性回归模型的代码如下：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s now look at another learning algorithm and model that we are going to
    use in this chapter. The following code shows how to build and train a SVM model
    for regression problems:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下本章将要使用的另一个学习算法和模型。以下代码展示了如何为回归问题构建和训练一个SVM模型：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see from this code, we are using `LinearRegressionNewtonMethod` as
    a learning algorithm to train a SVM model. `LinearRegressionNewtonMethod`is a
    learning algorithm for SVM using linear kernel. Simply put, a kernel is a way
    of projecting data points onto another space where the data points are more separable
    than in the original space. Other kernels, such as polynomial and Gaussian kernels,
    are also often used when training SVM models. We will experiment with and further
    discuss these other kernels in the next chapter, but you can certainly experiment
    with the model performances on other kernels for this project. When making predictions
    with a trained SVM model, you can use the `Score` method, as shown in the code
    snippet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用`LinearRegressionNewtonMethod`作为学习算法来训练一个SVM模型。`LinearRegressionNewtonMethod`是使用线性核的SVM学习算法。简单来说，核是一种将数据点投影到另一个空间的方法，在这个空间中，数据点比在原始空间中更容易分离。在训练SVM模型时，也经常使用其他核，如多项式核和高斯核。我们将在下一章中实验和进一步讨论这些其他核，但你当然可以在这个项目中尝试其他核对模型性能的影响。在使用训练好的SVM模型进行预测时，你可以使用代码片段中所示的`Score`方法。
- en: The full code that we used to train and validate linear regression and SVM models
    can be found here: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/Modeling.cs).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来训练和验证线性回归和SVM模型的完整代码可以在以下链接找到：[https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.4/Modeling.cs)。
- en: Model validations
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型验证
- en: Now that you have built and trained regression models for this chapter's foreign
    exchange rate forecast project, let's start looking into how our models performed.
    In this section, we are going to discuss two commonly used basic metrics, RMSE,
    and R², and a diagnostic plot, actual or observed values versus predicted values.
    Before we delve into those metrics and a diagnostic plot, let's first briefly
    discuss how to extract coefficient and intercept values from the linear regression
    model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为本章的外汇汇率预测项目构建并训练了回归模型，让我们开始探讨我们的模型表现如何。在本节中，我们将讨论两个常用的基本指标，RMSE和R²，以及一个诊断图，实际或观察值与预测值对比。在我们深入探讨这些指标和诊断图之前，让我们首先简要讨论如何从线性回归模型中提取系数和截距值。
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you run this code, you will see an output like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此代码时，你将看到以下类似的输出：
- en: '![](img/00061.gif)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00061.gif)'
- en: Looking at the coefficients and intercept of the fitted linear regression model
    helps us understand the model and gain some insights into how each feature affects
    the prediction results. The fact that we can understand and visualize exactly
    how the relationships between the features and the target variable are formed
    and how they interact with each other makes linear regression models still attractive,
    even though other black-box models, such as random forest models or support vector
    machines, often outperform linear regression models. As you can see from this
    output, you can easily tell which features affect daily return predictions negatively
    or positively and the magnitudes of their impacts.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 观察拟合的线性回归模型的系数和截距有助于我们理解模型，并深入了解每个特征如何影响预测结果。我们能够理解和可视化特征与目标变量之间的关系是如何形成的，以及它们是如何相互作用的，这使得线性回归模型即使在其他黑盒模型（如随机森林模型或支持向量机）通常优于线性回归模型的情况下，仍然具有吸引力。正如你可以从输出中看到的那样，你可以轻松地判断哪些特征对每日回报预测有负面影响或正面影响，以及它们的影响程度。
- en: 'Let''s now look at the first metrics that we are using for regression model
    validation in this chapter. You might already be familiar with RMSE, which measures
    the square root of the errors between the predicted values and the actual values.
    The lower RMSE values are, the better the model fit is. The following code shows
    how you can compute the RMSE of the model fit:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看本章中用于回归模型验证的第一个指标。你可能已经熟悉RMSE，它衡量的是预测值与实际值之间误差的平方根。RMSE值越低，模型拟合度越好。以下代码展示了如何计算模型拟合的RMSE：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see from this code, we are using the `SquareLoss` class in the Accord.NET
    framework, which computes the squared values of the differences between the predicted
    and the actual values. In order to get the RMSE, we need to take a square root
    of this value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，我们正在使用Accord.NET框架中的`SquareLoss`类，该类计算预测值与实际值之间差异的平方值。为了得到RMSE，我们需要取这个值的平方根。
- en: 'The next metric that we are going to look at is R². R^(*2*) is frequently used
    as an indicator of the goodness of fit. The closer the value is to 1, the better
    the model fit. The following code shows how we can compute R² values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要看的下一个指标是R²。R²经常被用作拟合优度的一个指标。值越接近1，模型拟合度越好。以下代码展示了如何计算R²值：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see from this code, we are using the `RSquaredLoss` class in the
    Accord.NET framework. We are computing once for in-sample predictions (predictions
    on the train set) and once for out-of-sample predictions (predictions on the test
    set). The closer the two values are, the less overfitting the models.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，我们正在使用Accord.NET框架中的`RSquaredLoss`类。我们分别对样本内预测（在训练集上的预测）和样本外预测（在测试集上的预测）进行计算。这两个值越接近，模型的过拟合程度就越低。
- en: 'When you run this code for RMSE and R² for the linear regression model, the
    following is an output you will get:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为线性回归模型运行RMSE和R²的代码时，你将得到以下输出：
- en: '![](img/00062.gif)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.gif)'
- en: 'And for the SVM model, the output you will see is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SVM模型，你将看到的输出如下：
- en: '![](img/00063.gif)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.gif)'
- en: From these outputs, we can see that the SVM model outperforms the linear regression
    model by a large amount. The SVM model has a much lower RMSE compared to the linear
    regression model. Also, the SVM model has a much higher R² value than the linear
    regression model. Note the R² value for the linear regression model. This happens
    when the fit of the model is worse than a simple horizontal line, and this suggests
    that our linear regression model fit is not good. On the other hand, the R² for
    the SVM model is about 0.26, which suggests that 26% of the target variable variance
    can be explained by this model.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些输出中，我们可以看到SVM模型在性能上远超线性回归模型。与线性回归模型相比，SVM模型的RMSE要低得多。此外，SVM模型的R²值也远高于线性回归模型。注意线性回归模型的R²值。当模型的拟合度不如一条简单的水平线时，就会出现这种情况，这表明我们的线性回归模型拟合度不佳。另一方面，SVM模型的R²值约为0.26，这意味着26%的目标变量方差可以通过此模型解释。
- en: 'Lastly, we are going to look at a diagnostic plot; actual values versus predicted
    values. This diagnostic plot is a good way to visually see the goodness of the
    model fit. Ideally, we would want all the points to be on a diagonal line. For
    example, if the actual value is 1.0, then we would want to have predicted value
    close to 1.0\. The closer the points are to the diagonal line, the better the
    model fit is. You can use the following code to plot actual values against predicted
    values:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看一个诊断图；实际值与预测值之间的比较。这个诊断图是观察模型拟合优度的一个很好的视觉方式。理想情况下，我们希望所有点都位于对角线上。例如，如果实际值是1.0，那么我们希望预测值接近1.0。点越接近对角线，模型拟合度越好。你可以使用以下代码来绘制实际值与预测值：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are using the `ScatterplotBox` class in the Accord.NET framework to build
    a scatter plot of actual values against predicted values. When you run this code
    for linear regression model results, you will see the following diagnostic plot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Accord.NET框架中的`ScatterplotBox`类来构建实际值与预测值之间的散点图。当你为线性回归模型运行此代码时，你会看到以下诊断图：
- en: '![](img/00064.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: 'When you run the same code for the SVM model results, the diagnostic plot appears
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为SVM模型运行相同的代码时，诊断图如下所示：
- en: '![](img/00065.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: As you can see from these plots, predictions from the linear regression model
    are more clogged around 0, while those from the SVM model are more spread out
    across a wider range. Although both plots for the linear regression and SVM model
    results do now show a perfect diagonal line, the plot for the SVM model shows
    better results and is aligned with the results we have seen from the RMSE and
    R² metrics.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些图中可以看到，线性回归模型的预测值在 0 附近更为集中，而 SVM 模型的预测值则在一个更宽的范围内分布更广。尽管线性回归和 SVM 模型结果的两个图现在都没有显示完美的对角线，但
    SVM 模型的图显示了更好的结果，并且与 RMSE 和 R² 指标我们看到的结果一致。
- en: 'The method we wrote and used to run validations for the models is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写并使用的方法来运行模型验证如下：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built and trained our first regression models. We used a
    time series dataset that contains historical daily exchange rates between Euros
    and U.S. Dollars from 1999 to 2017\. We first discussed how to create a target
    variable from an unlabeled raw dataset and how to apply the `Shift` and `Diff`
    methods in the Deedle framework in order to compute daily returns and create the
    target variable, which is the daily return for one period ahead. We further looked
    at the distributions of daily returns in a few different ways, such as a time
    series line chart, summary statistics using mean, standard deviation, and quantiles.
    We also looked at the histogram of daily returns and saw a well-drawn bell curve
    that follows a normal distribution. Then, we covered a few frequently used technical
    indicators in the foreign exchange market and how to apply them to our feature
    building processes. Using technical indicators, such as moving averages, Bollinger
    Bands, and lagged variables, we built various features that help our learning
    algorithms to learn how to predict future daily returns. With these features that
    we built in the feature engineering step, we built linear regression and SVM models
    to forecaste EUR/USD rates. We learned how to extract coefficients and the intercept
    from the `MultipleLinearRegression`object to gain insights into, and a better
    understanding, of how each feature affects the outcome of predictions. We briefly
    discussed the usage of kernels in building SVM models. Lastly, we went over two
    frequently used metrics for regression models, RMSE and R², and a diagnostic plot
    of actual values versus predicted values. From this model validation step, we
    observed how the SVM model outperformed the linear regression model by a large
    amount. We also discussed the comparative benefits of explainability we can gain
    from using the linear regression model, compared to other black-box models such
    as random forest and SVM models.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建并训练了我们的第一个回归模型。我们使用了一个包含 1999 年至 2017 年间欧元和美元历史每日汇率的时间序列数据集。我们首先讨论了如何从一个未标记的原始数据集中创建目标变量，以及如何在
    Deedle 框架中应用 `Shift` 和 `Diff` 方法来计算每日回报并创建目标变量，即一个周期前的一日回报。我们还从几个不同的角度研究了每日回报的分布，例如时间序列折线图、使用均值、标准差和分位数进行的总结统计。我们还研究了每日回报的直方图，并看到了一个绘制得很好的钟形曲线，它遵循正态分布。然后，我们介绍了外汇市场中一些常用的技术指标以及如何将它们应用于我们的特征构建过程。使用移动平均线、布林带和滞后变量等技术指标，我们构建了各种特征，帮助我们的学习算法学习如何预测未来的每日回报。在特征工程步骤中构建的这些特征，我们构建了线性回归和
    SVM 模型来预测 EUR/USD 汇率。我们学习了如何从 `MultipleLinearRegression` 对象中提取系数和截距，以深入了解每个特征如何影响预测结果。我们还简要讨论了在构建
    SVM 模型时核函数的使用。最后，我们回顾了两个常用的回归模型指标，RMSE 和 R²，以及实际值与预测值之间的诊断图。从这个模型验证步骤中，我们观察到 SVM
    模型在性能上大幅优于线性回归模型。我们还讨论了与其他黑盒模型（如随机森林和 SVM 模型）相比，使用线性回归模型可以获得的可解释性比较优势。
- en: In the next chapter, we are going to extend our knowledge and experience by
    building regression models in C# using the Accord.NET framework. We will use a
    house price dataset that contains both continuous and categorical variables and
    learn how to build regression models for such a complex dataset. We will also
    discuss various other kernels we can use for SVMs and how they affect the performance
    of our SVM models.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用 Accord.NET 框架在 C# 中构建回归模型来扩展我们的知识和经验。我们将使用一个包含连续和分类变量的房价数据集，并学习如何为如此复杂的数据集构建回归模型。我们还将讨论我们可以用于
    SVM 的各种核函数以及它们如何影响我们的 SVM 模型的性能。
