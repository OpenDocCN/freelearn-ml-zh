- en: Build a Recommendation Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建推荐引擎
- en: Like so many things, it was born of frustration and stiff cocktails. It was
    a Saturday, and the two young men were once again stuck without a date for the
    night. As they sat pouring drinks and sharing laments, the two Harvard freshmen
    began to flesh out an idea. What if, instead of relying on random chance to meet
    the right girl, they could use a computer algorithm?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多事情一样，它源于挫败感和烈酒。那是一个星期六，两个年轻人再次陷入了没有约会的困境。当他们坐下来倒酒、分享苦恼时，这两个哈佛大学的新生开始构思一个想法。如果他们不再依赖随机机会来遇到合适的女孩，而是能利用计算机算法呢？
- en: The key to matching people up, they felt, would be to create a set of questions
    that provided the sort of information everyone is really looking for on those
    first awkward dates. By matching people using these questionnaires, you could
    eliminate dates that could best be avoided. The process would be super efficient.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 他们认为，匹配人们的关键是创建一组问题，提供每个人在第一次尴尬约会时真正想了解的信息。通过使用这些问卷来匹配人们，你可以消除那些最好避免的约会。这个过程将是超级高效的。
- en: The idea was to market their new service to college students in Boston and around
    the country. And in short order, that's exactly what they did.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将他们的新服务推向波士顿及全国各地的大学生。简而言之，他们确实做到了这一点。
- en: Soon after, the digital matchmaking service they built went on to become a huge
    success. It received national media attention and generated tens of thousands
    of matches over the course of the next few years. The company was so successful,
    in fact, it was eventually bought out by a larger company that wanted to use its
    technology.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，他们所构建的数字匹配服务获得了巨大的成功。它吸引了全国媒体的关注，并在接下来的几年里生成了数万次匹配。事实上，这家公司如此成功，以至于最终被一家更大的公司收购，该公司希望利用其技术。
- en: If you think I'm talking about **OkCupid**, you would be wrong—and off by about
    40 years. The company I'm speaking of did all of this beginning in 1965—a time
    when computing matches was done using punch cards on an IBM 1401 mainframe. It
    also took three days just to run the computations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为我在谈论**OkCupid**，那你就错了——而且错得有点远，大约错了40年。我说的这家公司从1965年开始就做了这些事——那时候，匹配计算是通过IBM
    1401主机上的穿孔卡来完成的。完成计算甚至需要三天时间。
- en: But oddly enough, there's a connection between OkCupid and its 1965 precursor,
    Compatibility Research, Inc. The co-founder of Compatibility Research is Jeff
    Tarr, whose daughter, Jennifer Tarr, is the wife of OkCupid's co-founder Chris
    Coyne. Small world indeed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但奇怪的是，**OkCupid**和它1965年的前身兼容性研究公司（Compatibility Research, Inc.）之间有一种联系。兼容性研究的共同创始人是杰夫·塔尔（Jeff
    Tarr），他的女儿詹妮弗·塔尔（Jennifer Tarr）是**OkCupid**共同创始人克里斯·科因（Chris Coyne）的妻子。真是个小世界。
- en: But why is any of this relevant to a chapter on building a recommendation engine?
    Because it's quite likely that this was in fact the first one. And while most
    people tend to think of recommendation engines as tools for finding closely related
    products or music and movies they're likely to appreciate, the original incarnation
    was to find potential mates. And as a model for thinking about how these systems
    work, it provides a good frame of reference.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这一切和构建推荐引擎的章节有关系呢？因为很可能这实际上是第一个推荐引擎。而尽管大多数人通常把推荐引擎视为用来寻找相关产品、音乐和电影的工具，这些是人们可能会喜欢的，但最初的版本是用来寻找潜在的伴侣的。作为思考这些系统如何工作的模型，它提供了一个很好的参考框架。
- en: In this chapter, we're going to explore the different varieties of recommendation
    systems. We'll see how they're implemented commercially and how they work. Finally,
    we'll implement our own recommendation engine for finding GitHub repositories.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探索推荐系统的不同种类。我们将看到它们是如何商业化实施的，以及它们是如何运作的。最后，我们将实现自己的推荐引擎，用来查找GitHub上的仓库。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Collaborative filtering
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协同过滤
- en: Content-based filtering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: Hybrid systems
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合系统
- en: Building a recommendation engine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建推荐引擎
- en: Collaborative filtering
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: In early 2012, a story broke about a man who had come into a Target store in
    Minneapolis to complain about a book of coupons sent to his home. He was in fact
    quite incensed about these coupons, which had been addressed to his daughter,
    a high school student at the time. And although it might seem like an odd reaction
    to a potential money-saving opportunity, learning that the coupons were exclusively
    for products such as prenatal vitamins, diapers, baby formula, cribs, and so on
    might change your view.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年初，一则新闻报道了一个男人的故事，他来到明尼阿波利斯的Target商店投诉送到他家中的一本优惠券书。实际上，他对这些优惠券非常生气，这些优惠券是寄给他女儿的，而她当时是一名高中生。虽然这看起来像是对一项潜在的省钱机会的奇怪反应，但得知这些优惠券只针对产前维生素、尿布、婴儿配方奶粉、婴儿床等产品时，可能会改变你的看法。
- en: The manager, upon hearing the complaint, apologized profusely. He felt bad enough,
    in fact, that he called several days later to follow up and explain how this could
    have happened. But before the manager was able to even begin his apology, the
    father began to apologize to the manager. As it turned out, his daughter was in
    fact pregnant and her shopping habits had given her away.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 经理在听到投诉后，深感抱歉。事实上，他感到十分难过，以至于几天后他再次打电话进行跟进并解释事情是如何发生的。但在经理还没开始道歉之前，父亲开始向经理道歉。事实证明，他的女儿实际上已经怀孕了，而且她的购物习惯暴露了这一点。
- en: The algorithm that gave her away was likely based—at least in part—on one type
    of algorithm used in recommendation engines called **collaborative filtering**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 揭露她的算法很可能至少部分基于一种在推荐引擎中使用的算法，叫做**协同过滤**。
- en: So, what's collaborative filtering?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，什么是协同过滤？
- en: Collaborative filtering is based on the idea that, somewhere out there in the
    world, you have a taste doppelganger—someone who shares the same notions about
    how good *Star Wars* is and how awful *Love Actually* is.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤基于这样一个理念：在世界的某个地方，你有一个品味的双胞胎——一个与自己在评价*星际大战*的好坏以及*真爱至上*的糟糕程度上有相同看法的人。
- en: The idea is that you've rated some set of items in a way that's very similar
    to the way this other person, this doppelganger, has rated them, but then each
    of you has rated additional items that the other hasn't. Because you've established
    that your tastes are similar, recommendations can be generated from the items
    your doppelganger has rated highly but which you haven't rated and vice versa.
    It's in a way much like digital matchmaking, but with the outcome being songs
    or products you would like, rather than actual people.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其核心理念是，你对一组物品的评分方式非常类似于另一个人——这个双胞胎——对这些物品的评分方式，但你们每个人又分别对其他物品进行了评分，而这些物品对方并没有评分。由于你们的品味相似，推荐可以基于你们的双胞胎对某些你没有评分的高分物品，或者基于你对某些他没有评分的高分物品进行生成。从某种意义上讲，这就像是数字化的配对，但结果是你会喜欢的歌曲或产品，而不是实际的人。
- en: So, in the case of our pregnant high schooler, when she bought the right combination
    of unscented lotions, cotton balls, and vitamin supplements, she likely found
    herself paired up with people who went on to buy cribs and diapers at some point
    later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们怀孕的高中女生的例子中，当她购买了正确的无香料润肤霜、棉花球和维生素补充剂组合时，她很可能与那些后来购买婴儿床和尿布的人配对了。
- en: Let's go through an example to see how this works in practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看这在实际中是如何运作的。
- en: We'll start with what's called a **utility matrix**. This is similar to a **term-document
    matrix** but, instead of terms and documents, we'll be representing products and
    users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从所谓的**效用矩阵**开始。这与**词-文档矩阵**类似，但我们将代表的是产品和用户，而不是词汇和文档。
- en: 'Here we''ll assume that we have customers *A-D* and a set of products that
    they''ve rated on a scale from 0 to 5:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设我们有客户*A-D*，以及一组他们根据0到5的评分标准对产品的评价：
- en: '| **Customer** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** |
    **Duffly** **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football
    Jersey** | **Snowy** **Cotton**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '| **客户** | **斯纳奇薯片** | **顺滑润肤霜** | **达夫啤酒** | **更佳水** | **XX大型生活足球衫** | **雪白棉花**'
- en: '**Balls** | **Disposos''** **Diapers** |'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**尿布** | **迪斯波索尿布** |'
- en: '| **A** | 4 |  | 5 | 3 | 5 |  |  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **A** | 4 |  | 5 | 3 | 5 |  |  |'
- en: '| **B** |  | 4 |  | 4 |  | 5 |  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **B** |  | 4 |  | 4 |  | 5 |  |'
- en: '| **C** | 2 |  | 2 |  | 1 |  |  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **C** | 2 |  | 2 |  | 1 |  |  |'
- en: '| **D** |  | 5 |  | 3 |  | 5 | 4 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **D** |  | 5 |  | 3 |  | 5 | 4 |'
- en: 'We''ve seen previously that, when we want to find similar items, we could use
    cosine similarity. Let''s try that here. We''ll find the user most like user *A*.
    Because we have a sparse vector containing many unrated items, we''ll have to
    input something for those missing values. We''ll just go with 0 here. We''ll start
    by comparing user *A* to user *B*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，当我们想要找到相似的项目时，可以使用余弦相似度。我们就在这里尝试一下。我们将找到最像用户 *A* 的用户。由于我们有一个稀疏向量，其中包含许多未评分的项目，我们需要为这些缺失值输入一些内容。我们这里就使用0。我们从比较用户
    *A* 和用户 *B* 开始：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous code results in the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果是以下输出：
- en: '![](img/5672e7bc-e966-477e-9ab0-95cdadabfaec.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5672e7bc-e966-477e-9ab0-95cdadabfaec.png)'
- en: As you can see, the two don't have a high similarity rating, which makes sense
    as they have no ratings in common.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两者的相似度评分并不高，这也有道理，因为他们没有共同的评分项。
- en: 'Let''s now look at user C compared to user *A*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下用户 C 与用户 *A* 进行比较：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous code results in the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果是以下输出：
- en: '![](img/608f4fa0-0045-464c-b0a4-493eaa5c34ad.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/608f4fa0-0045-464c-b0a4-493eaa5c34ad.png)'
- en: Here, we see that they have a high similarity rating (remember 1 is perfect
    similarity), despite the fact they rated the same products very differently. Why
    are we getting these results? The problem lies with our choice of using 0 for
    the unrated products. It's registering as strong (negative) agreement on those
    unrated products. 0 isn't neutral in this case.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到他们之间有很高的相似度评分（记住，1是完美相似），尽管他们对相同的产品给出了截然不同的评分。为什么会得到这样的结果呢？问题出在我们选择使用0来表示未评分的产品。它被视为这些未评分产品的强烈（负向）一致性。0在这种情况下并不是中立的。
- en: So, how can we fix this?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何解决这个问题呢？
- en: What we can do instead of just using 0 for the missing values is to re-center
    each user's ratings so that the mean rating is 0, or neutral. We do this by taking
    each user rating and subtracting the mean for all ratings of that user. For example,
    for user *A*, the mean is 17/4, or 4.25\. We then subtract that from every individual
    rating that user *A* provided.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的，不仅仅是对缺失值使用0，而是重新调整每个用户的评分，使得平均评分为0，或者说是中立的。我们通过将每个用户的评分减去该用户所有评分的平均值来实现这一点。例如，对于用户
    *A*，其平均值为17/4，即4.25。然后，我们从用户 *A* 提供的每个评分中减去这个平均值。
- en: Once that's been done, we then continue on to find the mean for every other
    user and subtract it from each of their ratings until every user has been processed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，我们继续为每个用户计算平均值，并将其从每个用户的评分中减去，直到所有用户都被处理完。
- en: 'This procedure will result in a table like the following. You will notice each
    user row sums to 0 (ignore the rounding issues here):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将生成如下表格。你会注意到每个用户的行总和为0（这里忽略四舍五入问题）：
- en: '| **Customers** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** |
    **Duffly** **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football
    Jersey** | **Snowy** **Cotton**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '| **顾客** | **Snarky''s 土豆片** | **SoSo 顺滑** **乳液** | **Duffly** **啤酒** | **BetterTap**
    **水** | **XXLargeLivin''** **橄榄球球衣** | **Snowy** **棉花**'
- en: '**Balls** | **Disposos''** **Diapers** |'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Balls** | **Disposos''** **尿布** |'
- en: '| **A** | -.25 |  | .75 | -1.25 | .75 |  |  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **A** | -.25 |  | .75 | -1.25 | .75 |  |  |'
- en: '| **B** |  | -.33 |  | -.33 |  | .66 |  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **B** |  | -.33 |  | -.33 |  | .66 |  |'
- en: '| **C** | .33 |  | .33 |  | -.66 |  |  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **C** | .33 |  | .33 |  | -.66 |  |  |'
- en: '| **D** |  | .75 |  | -1.25 |  | .75 | -.25 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **D** |  | .75 |  | -1.25 |  | .75 | -.25 |'
- en: Let's now try our cosine similarity on our newly centered data. We'll do user
    *A* compared to user *B* and *C* again.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们重新调整过的数据上尝试余弦相似度。我们将再次进行用户 *A* 与用户 *B* 和 *C* 的比较。
- en: 'First, let''s compare user *A* to user *B*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将用户 *A* 与用户 *B* 进行比较：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code results in the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果是以下输出：
- en: '![](img/0f996df4-2bae-40a3-8a4d-e42e49ed0faa.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f996df4-2bae-40a3-8a4d-e42e49ed0faa.png)'
- en: 'Now let''s try between users *A* and *C*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试将用户 *A* 和 *C* 进行比较：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code results in the following output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果是以下输出：
- en: '![](img/be39db7c-65c3-435f-8a0e-e1def4064051.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be39db7c-65c3-435f-8a0e-e1def4064051.png)'
- en: What we can see is that the similarity between *A* and *B* increased slightly,
    while the similarity between *A* and *C* decreased dramatically. This is exactly
    as we would hope.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，*A* 和 *B* 之间的相似度略有增加，而 *A* 和 *C* 之间的相似度则大幅下降。这正是我们希望看到的结果。
- en: This centering process, besides helping us deal with missing values, also has
    the side benefit of helping us to deal with difficult or easy raters since now
    everyone is centered around a mean of 0\. This formula, you may notice, is equivalent
    to the Pearson correlation coefficient and, just like with that coefficient, the
    values fall between `-1` and `1`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中心化过程，除了帮助我们处理缺失值外，还具有一个副作用，帮助我们处理评分严格或宽松的用户，因为现在每个人的评分都是围绕0进行中心化的。你可能会注意到，这个公式等同于皮尔逊相关系数，就像那个系数一样，数值范围在`-1`到`1`之间。
- en: Predicting the rating for the product
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测产品评分
- en: Let's now take this framework and use it to predict the rating for a product.
    We'll limit our example to three users, person *X*, person *Y*, and person *Z*.
    We'll predict the rating of a product that person *X* hasn't rated, but that persons
    *Y* and *Z*, who are very similar to *X*, have rated.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用这个框架来预测某个产品的评分。我们将示例限定为三位用户，用户*X*、用户*Y*和用户*Z*。我们将预测用户*X*未评分的产品，但用户*Y*和用户*Z*已经对其进行了评分，而且他们与*X*非常相似。
- en: 'We''ll start with our base ratings for each user, as shown in the following
    table:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从每个用户的基础评分开始，如下表所示：
- en: '| **Customers** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** |
    **Duffly** **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football
    Jersey** | **Snowy** **Cotton**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '| **客户** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** | **Duffly**
    **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football Jersey** |
    **Snowy** **Cotton**'
- en: '**Balls** | **Disposos''** **Diapers** |'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**球** | **Disposos''** **Diapers** |'
- en: '| **X** |  | 4 |  | 3 |  | 4 |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **X** |  | 4 |  | 3 |  | 4 |  |'
- en: '| **Y** |  | 3.5 |  | 2.5 |  | 4 | 4 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **Y** |  | 3.5 |  | 2.5 |  | 4 | 4 |'
- en: '| **Z** |  | 4 |  | 3.5 |  | 4.5 | 4.5 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **Z** |  | 4 |  | 3.5 |  | 4.5 | 4.5 |'
- en: 'Next, we''ll center the ratings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对评分进行中心化处理：
- en: '| **Customers** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** |
    **Duffly** **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football
    Jersey** | **Snowy** **Cotton**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '| **客户** | **Snarky''s Potato Chips** | **SoSo Smooth** **Lotion** | **Duffly**
    **Beer** | **BetterTap** **Water** | **XXLargeLivin''** **Football Jersey** |
    **Snowy** **Cotton**'
- en: '**Balls** | **Disposos''** **Diapers** |'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**球** | **Disposos''** **Diapers** |'
- en: '| **X** |  | .33 |  | -.66 |  | .33 | ? |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **X** |  | .33 |  | -.66 |  | .33 | ? |'
- en: '| **Y** |  | 0 |  | -1 |  | .5 | .5 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **Y** |  | 0 |  | -1 |  | .5 | .5 |'
- en: '| **Z** |  | -.125 |  | -.625 |  | .375 | .375 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **Z** |  | -.125 |  | -.625 |  | .375 | .375 |'
- en: Now, we'd like to know what rating user *X* might be likely to give **Disposos'
    Diapers**. Using the ratings from user *Y* and user *Z*, we can calculate this
    by taking the weighted average according to their centered cosine similarity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想知道用户*X*可能给**Disposos' Diapers**的评分是多少。通过使用用户*Y*和用户*Z*的评分，我们可以根据他们的中心化余弦相似度计算加权平均值来得到这个评分。
- en: 'Let''s first get that figure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先计算出这个数值：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code results in the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了以下输出：
- en: '![](img/a5611a3e-2da1-4821-a782-a64680fd5565.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5611a3e-2da1-4821-a782-a64680fd5565.png)'
- en: 'Now, let''s get that figure for user *Z*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们计算用户*Z*的数值：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code results in the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了以下输出：
- en: '![](img/2bf43f2d-e87c-46aa-a3c4-048480370cb7.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bf43f2d-e87c-46aa-a3c4-048480370cb7.png)'
- en: So, now we have a figure for the similarity between user *X* and user *Y* (`0.42447212`)
    and user *Z* (`0.46571861`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经得到了用户*X*与用户*Y*（`0.42447212`）和用户*Z*（`0.46571861`）之间的相似度值。
- en: 'Putting it all together, we weight each users rating by their similarity to
    *X*, and then divide by the total similarity, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起，我们通过每个用户与*X*的相似度加权评分，然后再按总相似度进行除法，如下所示：
- en: '*(.42447212 * (4) + .46571861 * (4.5) ) / (.42447212 + .46571861) = 4.26*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*(.42447212 * (4) + .46571861 * (4.5) ) / (.42447212 + .46571861) = 4.26*'
- en: And we can see that the expected rating of user *X* for **Disposos' Diapers**
    is 4.26\. (Better send a coupon!)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，用户*X*对**Disposos' Diapers**的预期评分是4.26（最好发送一个优惠券！）
- en: 'Now, so far, we''ve looked only at user-to-user collaborative filtering, but
    there''s another method we can use. In practice, this method outperforms user-to-user
    filtering; it''s called **item-to-item filtering**. Here''s how the method works:
    rather than match each user up with other similar users based on their past ratings,
    each rated item is compared against all other items to find the most similar ones,
    again using centered cosine similarity.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们只看了用户对用户的协同过滤方法，但还有一种方法可以使用。在实际应用中，这种方法优于用户对用户的过滤；它被称为**项目对项目过滤**。该方法的工作原理是：与其基于过去的评分将每个用户与其他相似的用户进行匹配，不如将每个已评分的项目与所有其他项目进行比较，以找到最相似的项目，再次使用中心化余弦相似度。
- en: Let's take a look at how this would work.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的。
- en: 'Again we have a utility matrix; this time, we''ll look at users'' ratings of
    songs. The users are along the columns and the songs are along the rows, shown
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又有了一个效用矩阵；这次，我们将查看用户对歌曲的评分。用户在列上，歌曲在行上，结果如下：
- en: '| **Entity** | **U1** | **U2** | **U3** | **U4** | **U5** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **实体** | **U1** | **U2** | **U3** | **U4** | **U5** |'
- en: '| **S1** | 2 |  | 4 |  | 5 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **S1** | 2 |  | 4 |  | 5 |'
- en: '| **S2** |  | 3 |  | 3 |  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **S2** |  | 3 |  | 3 |  |'
- en: '| **S3** | 1 |  | 5 |  | 4 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **S3** | 1 |  | 5 |  | 4 |'
- en: '| **S4** |  | 4 | 4 | 4 |  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **S4** |  | 4 | 4 | 4 |  |'
- en: '| **S5** | 3 |  |  |  | 5 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **S5** | 3 |  |  |  | 5 |'
- en: Now, suppose we would like to know the rating that user 3 will assign to song
    5\. Instead of looking for similar users, we'll look for songs that are similar
    based upon how they were rated across the users.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想知道用户3会给歌曲5打多少分。我们不再寻找相似的用户，而是根据这些歌曲在不同用户中的评分相似度，寻找相似的歌曲。
- en: Let's see an example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。
- en: 'First, we start by centering each song row, and calculating the cosine similarity
    for each versus our target row, which is *S5*, shown as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过对每首歌的行进行居中，并计算与我们的目标行*S5*的余弦相似度，结果如下：
- en: '| **Entity** | **U1** | **U2** | **U3** | **U4** | **U5** | **CntrdCoSim**
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **实体** | **U1** | **U2** | **U3** | **U4** | **U5** | **CntrdCoSim** |'
- en: '| **S1** | -1.66 |  | .33 |  | 1.33 | .98 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **S1** | -1.66 |  | .33 |  | 1.33 | .98 |'
- en: '| **S2** |  | 0 |  | 0 |  | 0 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **S2** |  | 0 |  | 0 |  | 0 |'
- en: '| **S3** | -2.33 |  | 1.66 |  | .66 | .72 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **S3** | -2.33 |  | 1.66 |  | .66 | .72 |'
- en: '| **S4** |  | 0 | 0 | 0 |  | 0 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **S4** |  | 0 | 0 | 0 |  | 0 |'
- en: '| **S5** | -1 |  | ? |  | 1 | 1 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **S5** | -1 |  | ? |  | 1 | 1 |'
- en: You can see the far right column has been calculated with the centered cosine
    similarity for each row versus row *S5*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到最右列是通过每一行与行*S5*的中心余弦相似度计算出来的。
- en: We next need to select a number, *k*, that's the number of the nearest neighbors
    we'll use to rate songs for user 3\. We use *k = 2* in our simple example.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要选择一个数字，*k*，即我们用来对用户3打分的最近邻数量。在这个简单的示例中，我们使用*k = 2*。
- en: You can see that song *S1* and song *S3* are the most similar, so we'll use
    those two along with the ratings user 3 had for *S1* and *S3* (4 and 5, respectively).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到歌曲*S1*和歌曲*S3*是最相似的，因此我们将使用这两首歌曲以及用户3对*S1*和*S3*的评分（分别为4和5）。
- en: 'Let''s now calculate the rating:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来计算评分：
- en: '*(.98 * (4) + .72 * (5)) / (.98 + .72) = 4.42*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*(.98 * (4) + .72 * (5)) / (.98 + .72) = 4.42*'
- en: So, based on this item-to-item collaborative filtering, we can see user 3 is
    likely to rate song *S5* very highly at 4.42 from our calculations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，根据这个物品到物品的协同过滤，我们可以看到用户3可能会对歌曲*S5*给出非常高的评分，计算结果为4.42。
- en: Earlier, I said that user-to-user filtering is less effective than item-to-item
    filtering. Why might that be?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我说过用户到用户过滤不如物品到物品过滤有效。这是为什么呢？
- en: There's a good chance you have friends who really enjoy some of things that
    you enjoy as well, but then each of you has other areas of interest that the other
    has absolutely no interest in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 很有可能你有一些朋友非常喜欢你也喜欢的东西，但每个人还有其他一些兴趣领域，而这些领域是对方完全没有兴趣的。
- en: For example, perhaps you both love *Game of Thrones*, but your friend also loves
    Norwegian death metal. You, however, would rather be dead than listen to Norwegian
    death metal. If you're similar in many ways—excluding the death metal—with user-to-user
    recommendations, you're still going to see a lot of recommendations for bands
    with names that include words such as *flaming*, *axe*, *skull*, and *bludgeon*.
    With item-to-item filtering, most likely, you would be spared those suggestions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，也许你们俩都喜欢*权力的游戏*，但你的朋友还喜欢挪威死亡金属。然而，你宁愿死掉也不愿听挪威死亡金属。如果你们在许多方面相似——排除死亡金属——通过用户到用户的推荐，你仍然会看到许多包含*火焰*、*斧头*、*骷髅*和*重击*等词语的乐队推荐。而通过物品到物品的过滤，最有可能的是，你将避免这些建议。
- en: So far, we've looked at users and items as a single entity when making comparisons,
    but now let's move on to look at another method that decomposes our users and
    items into what might be called **feature baskets**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将用户和物品视为一个整体进行比较，但现在让我们看看另一种方法，它将用户和物品分解为可能称为**特征篮子**的东西。
- en: Content-based filtering
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: As a musician himself, Tim Westergren had spent years on the road listening
    to other talented musicians, wondering why they could never get ahead. Their music
    was good—just as good as anything you might hear on the radio—and yet, somehow,
    they just never caught their big break. He imagined it must be because their music
    just never got in front of enough of the right people.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名音乐人，Tim Westergren 曾在路上度过多年时间，聆听其他有才华的音乐人，思考为什么他们始终无法成功突破。尽管他们的音乐很好——与无线电广播上播放的音乐一样出色——然而，他们似乎从未迎来大爆发。他想，这一定是因为他们的音乐从未出现在足够多合适的人面前。
- en: Tim eventually quit his job as a musician and took another job as a composer
    for movie scores. It was there that he began to think of each piece of music as
    having a distinct structure that could be decomposed into constituent parts—a
    form of musical DNA.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Tim 最终辞去了音乐人工作，转而担任电影配乐作曲家。在那里，他开始认为每一段音乐都有独特的结构，可以被分解成组成部分——一种音乐DNA的形式。
- en: After giving it some thought, he began to consider creating a company around
    this idea of building a **musical genome**. He ran the concept by one of his friends,
    who had previously created and sold a company. The friend loved Tim's idea. So
    much so, in fact, that he began helping him to write a business plan and gather
    the initial funding round for the project. It was a go.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 思考了一段时间后，他开始考虑围绕构建**音乐基因组**的这个想法成立一家公司。他向一位曾经创建并出售过公司朋友介绍了这个概念。朋友非常喜欢 Tim 的这个想法。事实上，他喜欢到开始帮助
    Tim 编写商业计划书，并为项目筹集初期的资金。这项计划得到了推进。
- en: Over the next several years, they employed a small army of musicians who meticulously
    codified almost 400 distinct musical features for over a million pieces of music.
    Each feature was rated on a 0 to 5 point scale by hand (or maybe by ear is a better
    way to say it). Each three- or four-minute song took nearly a half hour to classify.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几年里，他们雇佣了一支小型的音乐家团队，细致地为超过百万首音乐作品制定了近400个独特的音乐特征。每个特征都用0到5分的评分标准手工评分（或者说是用耳朵评分可能更为恰当）。每首三到四分钟的歌曲需要将近半小时才能分类完毕。
- en: The features included things such as how gravelly the lead singers' voice was
    or how many beats per minute the tempo was. It took nearly a year for their first
    prototype to be completed. Built entirely in Excel using a VBA macro, it took
    nearly four minutes just to return a single recommendation. But in the end, it
    worked and it worked well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 特征包括主唱的声音沙哑程度或节奏的每分钟节拍数等。他们的第一个原型花了近一年时间才完成。这个原型完全是用 Excel 和 VBA 宏构建的，单单返回一个推荐就需要近四分钟的时间。但最终，它成功了，并且效果非常好。
- en: That company is now known as Pandora music, and chances are you've either heard
    of it or used its products as it has millions of daily users around the world.
    It's without a doubt a triumphant example of content-based filtering.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这家公司现在被称为 Pandora 音乐，可能你要么听说过它，要么使用过它的产品，因为它在全球有数百万的日活跃用户。毫无疑问，这是基于内容的过滤的一个成功案例。
- en: Rather than treat each song as a single indivisible unit, as in content-based
    filtering, the songs become feature vectors that can be compared using our friend
    cosine similarity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于内容的过滤方法将每首歌视为一个不可分割的单元不同，这些歌曲变成了特征向量，可以使用我们的老朋友余弦相似度进行比较。
- en: Another benefit is that not only are the songs subject to being decomposed into
    feature vectors, but the listeners can be as well. Each listener's taste profile
    becomes a vector in this space so that measurements can be made between their
    taste profiles and the songs themselves.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，不仅歌曲可以被分解成特征向量，听众的偏好也可以被分解。每个听众的品味档案也会变成该空间中的一个向量，这样就可以在他们的品味档案和歌曲之间进行衡量。
- en: For Tim Westergren, this was the magic, because rather than rely on the popularity
    of the music like so many recommendations are, the recommendations from this system
    were made based upon the inherent structural similarity. Maybe you've never heard
    of song *X*, but if you like song *Y*, then you should like song *X* because it's
    *genetically* almost identical. That's content-based filtering.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Tim Westergren 来说，这就是魔力所在，因为与许多基于流行度的推荐不同，这个系统的推荐是基于固有的结构相似性做出的。也许你从未听说过歌曲*X*，但如果你喜欢歌曲*Y*，那么你也应该喜欢歌曲*X*，因为它在*基因上*几乎是相同的。这就是基于内容的过滤。
- en: Hybrid systems
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合系统
- en: We've now looked at the two primary forms of recommender systems, but you should
    know that, in any large-scale production environment, you're likely to see recommendations
    that leverage both of these. This is known as a **hybrid system**, and the reason
    hybrid systems are preferred is that they help eliminate the drawbacks that can
    be present when using either system alone. The two systems together create a more
    robust solution.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看了两种主要的推荐系统，但你应该知道，在任何大规模的生产环境中，你可能会看到结合这两种方式的推荐系统。这被称为**混合系统**，混合系统的偏好原因在于，它们有助于消除使用单一系统时可能出现的缺点。这两个系统结合在一起，创造了一个更强大的解决方案。
- en: Let's examine the pros and cons of each type.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每种类型的优缺点。
- en: Collaborative filtering
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: 'The pros of collaborative filtering are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤的优点如下：
- en: There's no need to hand-craft features
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要手动制作特征
- en: 'The cons are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: Doesn't work well without a large number of items and users
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有大量的商品和用户，效果不好
- en: Sparsity when the number of items far exceeds the number that could be purchased
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当商品数量远远超过可以购买的数量时，会出现稀疏性问题
- en: Content-based filtering
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: 'The pros of content-based filtering are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的过滤的优点如下：
- en: It doesn't require a large number of users
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要大量的用户
- en: 'The cons are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: Defining the right features can be a challenge
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义正确的特征可能是一个挑战
- en: Lack of serendipity
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏偶然性
- en: As you can see, content-based filtering is a better choice when you haven't
    built up a large user base but, as you grow, adding on collaborative filtering
    can help introduce more serendipity into the recommendations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当你还没有建立起庞大的用户基础时，基于内容的过滤是一个更好的选择，但随着你的发展，增加协同过滤可以帮助将更多的偶然性引入推荐中。
- en: Now that you're familiar with the types and inner-workings of recommendation
    engines, let's begin constructing one of our own.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了推荐引擎的类型和工作原理，让我们开始构建一个自己的推荐引擎。
- en: Building a recommendation engine
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建推荐引擎
- en: One thing I love to stumble upon is a really useful GitHub repository. You can
    find repositories that contain everything from hand-curated tutorials on machine
    learning to libraries that will save you dozens of lines of code when using **Elasticsearch**.
    The trouble is, finding these libraries is far more difficult than it should be.
    Fortunately, we now have the knowledge to leverage the GitHub API in a way that
    will help us to find these code gems.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢偶然发现一些非常有用的 GitHub 仓库。你可以找到从手工策划的机器学习教程到可以节省你大量代码行数的库，特别是在使用 **Elasticsearch**
    时。问题是，找到这些库比应该的更难。幸运的是，我们现在有了足够的知识，可以通过 GitHub API 来帮助我们找到这些代码宝藏。
- en: We're going to be using the GitHub API to create a recommendation engine based
    on collaborative filtering. The plan is to get all of the repositories I've starred
    over time and to then get all of the creators of those repositories to find what
    repositories they've starred. Once that's done, we'll find which users are most
    similar to me (or you, if you're running this for your own repository, which I
    suggest). Once we have the most similar users, we can use the repositories they've
    starred and that I haven't to generate a set of recommendations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GitHub API 来基于协同过滤创建一个推荐引擎。计划是获取我一段时间内标记的所有仓库，然后获取这些仓库的所有创建者，查看他们标记了哪些仓库。一旦完成，我们将找到与我（或你，如果你为自己的仓库运行此过程，我建议这样做）最相似的用户。一旦找到最相似的用户，我们就可以使用他们标记的，而我没有标记的仓库来生成推荐列表。
- en: 'Let''s get started:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'We''ll import the libraries we''ll need:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将导入所需的库：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You'll need to have opened an account with GitHub and to have starred a number
    of repositories for this to work for your GitHub handle, but you won't actually
    need to sign up for the developer program. You can get an authorization token
    from your profile, which will allow you to use the API. You can also get it to
    work with this code, but the limits are too restrictive to make it usable for
    our example.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在 GitHub 上注册一个帐户，并标记一些仓库，这样才能使你的 GitHub 账号生效，但实际上你不需要注册开发者程序。你可以从你的个人资料中获得一个授权令牌，这将允许你使用
    API。你也可以用这段代码使它正常工作，但由于限制太多，无法在我们的示例中使用。
- en: 'To create a token for use with the API, go to the following URL at [https://github.com/settings/tokens](https://github.com/settings/tokens).
    There, you will see a button in the upper-right corner like the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为API创建一个令牌，请访问以下网址：[https://github.com/settings/tokens](https://github.com/settings/tokens)。在这里，你会看到右上角有一个按钮，像这样：
- en: '![](img/6093907c-b461-403b-b45a-1e54166869ad.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6093907c-b461-403b-b45a-1e54166869ad.png)'
- en: 'You''ll need to click on that Generate new token button. Once you''ve done
    that, you need to select the permissions, I chose just public_repo. Then, finally,
    copy the token it gives you for use in the following code. Be sure to enclose
    both in quotes:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要点击那个生成新令牌的按钮。点击之后，你需要选择权限，我选择了仅限public_repo。然后，最后复制它给你的令牌，并在以下代码中使用。确保将其包含在引号内：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll create the function that will pull the names of every repository you''ve
    starred:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个函数，提取你标星的每个仓库的名字：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's a lot going on in there, but, essentially, we're querying the API to
    get our own starred repositories. GitHub uses pagination rather than return everything
    in one call. Because of this, we'll need to check the `.links` that are returned
    from each response. As long as there is a next link to call, we'll continue to
    do so.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，但本质上，我们在查询API以获取我们自己的标星仓库。GitHub使用分页，而不是一次性返回所有内容。因此，我们需要检查每个响应中返回的`.links`。只要还有“下一页”链接可调用，我们就会继续这样做。
- en: 'We just need to call that function we created:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要调用我们创建的那个函数：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we can see the full list of starred repositories:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以看到所有被标星的仓库的完整列表：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will result in output similar to the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将输出类似以下内容：
- en: '![](img/d5f6c6d1-d138-4a60-8863-fce88149a145.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5f6c6d1-d138-4a60-8863-fce88149a145.png)'
- en: 'We need to parse out the user names for each of the libraries we starred so
    that we can retrieve the libraries they starred:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要解析出我们标星的每个库的用户名，以便我们可以获取他们标星的库：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will result in output similar to the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '![](img/d61cd8d7-6229-474c-8904-b38d4e680787.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d61cd8d7-6229-474c-8904-b38d4e680787.png)'
- en: 'Now that we have the handles for all of the users we starred, we''ll need to
    retrieve all of the repositories they starred. The following function will do
    just that:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经获取了所有我们标星的用户的用户名，我们需要获取他们标星的所有仓库。以下函数将实现这一功能：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function works in nearly the same way as the function we called earlier,
    but calls a different endpoint. It'll add their starred repositories to a dict
    we'll use later.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的工作方式与我们之前调用的函数几乎相同，但它调用的是不同的端点。它将把他们标星的仓库添加到我们稍后会用到的字典中。
- en: 'Let''s call it now. It may take a few minutes to run, depending on the number
    of repositories each user has starred. I actually had one that starred over 4,000
    repositories:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们调用它。根据每个用户标星的仓库数量，它可能需要几分钟才能运行完成。实际上，我有一个用户标星了超过4,000个仓库：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code will result in output similar to the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将输出类似以下内容：
- en: '![](img/98699917-fcac-48cc-99db-1f272910481d.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98699917-fcac-48cc-99db-1f272910481d.png)'
- en: 'Notice that I turned the list of starred users into a set before I called it.
    I noticed some duplication that resulted from starring multiple repositories under
    one user handle, so it makes sense to follow these steps to reduce extra calls:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用它之前，我将标星用户列表转成了集合。我注意到有一些重复项，是因为一个用户标星了多个仓库，所以按这些步骤操作来减少额外的调用是很有意义的：
- en: 'We now need to build a feature set that includes all of the starred repositories
    of everyone we have starred:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要构建一个特征集，包含我们所有标星的用户标星的所有仓库：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll convert that into a set to remove duplicates that may be present from
    multiple users starring the same repositories:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把它转换为集合，去除可能存在的重复项，这些重复项可能是多个用户标星了相同的仓库：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s see how many that produces:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这会生成多少内容：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code should result in output similar to the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该会输出类似以下内容：
- en: '![](img/b1945589-999e-41b7-8532-67ae6570a9c7.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1945589-999e-41b7-8532-67ae6570a9c7.png)'
- en: I had starred 170 repositories, and together the users of those repositories
    starred over 27,000 unique repositories. You can imagine if we went one degree
    further out how many we might see.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我标星了170个仓库，此外，这些仓库的用户们一共标星了超过27,000个独立的仓库。你可以想象，如果我们再往外推一步，会看到多少仓库。
- en: 'Now that we have the full feature set, or repository vocabulary, we need to
    run every user to create a binary vector that contains a `1` for every repository
    they''ve starred and a `0` for every repository they haven''t:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了完整的特征集或仓库词汇，我们需要对每个用户进行操作，创建一个二进制向量，对于每个他们标星的仓库赋值`1`，对于每个没有标星的仓库赋值`0`：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What we just did was check for every user whether they had starred every repository
    in our repository vocabulary. If they did, they received a `1`, if they didn't,
    they received a `0`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才做的事情是检查每个用户是否标星了我们仓库词汇中的每个仓库。如果标星了，他们会得到`1`，如果没有，他们会得到`0`。
- en: 'At this point, we have a 27,098 item binary vector for each user—all 170 of
    them. Let''s now put this into a `DataFrame`. The row index will be the user handles
    we starred, and the columns will be the repository vocabulary:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们为每个用户（总共170个用户）创建了一个包含27,098个项目的二进制向量。现在，让我们将其放入一个`DataFrame`中。行索引将是我们标星过的用户句柄，列将是仓库词汇：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code will generate output similar to the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将生成类似以下的输出：
- en: '![](img/13164eb3-0140-47d5-b8d9-e0bb7ae78ff7.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13164eb3-0140-47d5-b8d9-e0bb7ae78ff7.png)'
- en: 'Next, in order to compare ourselves to the other users, we need to add our
    own row to this frame. Here, I add my user handle, but you should add your own:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了与其他用户进行比较，我们需要将我们自己的行添加到这个框架中。在这里，我添加了我的用户句柄，但你应该添加你自己的：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will generate output similar to the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将生成类似以下的输出：
- en: '![](img/88bf2a5c-5bd1-4ac6-b737-18bb530ac824.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88bf2a5c-5bd1-4ac6-b737-18bb530ac824.png)'
- en: 'We now need add the appropriate column names and to concatenate this to our
    other `DataFrame`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要添加适当的列名，并将其与我们的其他`DataFrame`进行拼接：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code will result in output similar to the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将生成类似以下的输出：
- en: '![](img/877967fd-8853-45f8-80e8-e32663d021a3.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/877967fd-8853-45f8-80e8-e32663d021a3.png)'
- en: You can see in the previous screenshot that I've been added into the `DataFrame`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在上面的截图中看到，我已经被加入到了`DataFrame`中。
- en: 'From here, we just need to calculate the similarity between ourselves and the
    other users we''ve starred. We''ll do that now using the `pearsonr` function which
    we''ll need to import from SciPy:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们只需要计算自己与其他我们标星过的用户之间的相似度。我们现在就用`pearsonr`函数来做这个计算，我们需要从SciPy导入这个函数：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code will generate output similar to the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将生成类似以下的输出：
- en: '![](img/08e99592-0732-40f3-b1f3-5dba3b2360fa.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e99592-0732-40f3-b1f3-5dba3b2360fa.png)'
- en: 'What we''ve just done is compare our vector, the last one in the `DataFrame`,
    to every other user''s vector to generate a centered cosine similarity (Pearson
    correlation coefficient). Some values are by necessity `NaN`, as they''ve starred
    no repositories, and hence result in division by zero in the calculation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才所做的是将我们的向量（`DataFrame`中的最后一个）与其他所有用户的向量进行比较，以生成一个居中的余弦相似度（皮尔逊相关系数）。由于某些用户没有标星任何仓库，因此有些值必然为`NaN`，这会导致在计算时除以零：
- en: 'Let''s now sort these values to return the index of the users who are most
    similar:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们对这些值进行排序，返回最相似用户的索引：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code will result in output similar to the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将生成类似以下的输出：
- en: '![](img/4e0c87e0-5c41-4154-8298-c1b8c54a0d1c.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e0c87e0-5c41-4154-8298-c1b8c54a0d1c.png)'
- en: So there we have it, those are the most similar users, and hence the ones that
    we can use to recommend repositories we might enjoy. Let's take a look at these
    users and what they have starred that we might like.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们得到了最相似的用户，因此我们可以利用这些用户来推荐我们可能喜欢的仓库。让我们看看这些用户以及他们标星了哪些我们可能喜欢的仓库。
- en: 'You can ignore that first user with a perfect similarity score; that''s our
    own repository. Going down the list, the three nearest matches are user 6, user
    42, and user 116\. Let''s look at each:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以忽略第一个具有完美相似度分数的用户；那是我们自己的仓库。向下看，三个最接近的匹配是用户6、用户42和用户116。我们来看看每一个：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code will result in output similar to the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将生成类似以下的输出：
- en: '![](img/7e4949d8-0add-4d51-83f2-e9c940281dba.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e4949d8-0add-4d51-83f2-e9c940281dba.png)'
- en: 'Let''s take a look at who this is and their repository. From [https://github.com/cchi](https://github.com/cchi),
    I can see who the repository belongs to the following user:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这个用户是谁以及他们的仓库。通过[https://github.com/cchi](https://github.com/cchi)，我可以看到这个仓库属于以下用户：
- en: '![](img/4171a7e8-7065-45b6-98ce-4464443fc815.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4171a7e8-7065-45b6-98ce-4464443fc815.png)'
- en: 'This is actually Charles Chi, a former colleague of mine from Bloomberg, so
    this is no surprise. Let''s see what he has starred:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人实际上是Charles Chi，我以前在彭博社的同事，所以这不是什么意外。我们来看看他标星了哪些内容：
- en: 'There are a couple of ways to do this; we can either use our code, or just
    click under their picture on stars. Let''s do both for this one, just to compare
    and make sure everything matches up. First, let''s do it via code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点；我们可以使用代码，或者直接点击他们头像下方的星标。我们这次做两者，比较一下并确保结果一致。首先，让我们通过代码来操作：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This results in the following output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/b2363349-f1b3-4e15-acab-0ad246dfbb49.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2363349-f1b3-4e15-acab-0ad246dfbb49.png)'
- en: 'We see 30 starred repositories. Let''s compare those to the ones from GitHub''s
    site:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到他加星了30个仓库。让我们将这些仓库与GitHub网站上的仓库进行比较：
- en: '![](img/a67bbc65-7c4e-4a76-9d6c-c8ffc54cfa5a.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a67bbc65-7c4e-4a76-9d6c-c8ffc54cfa5a.png)'
- en: 'Here we can see they''re identical, and you''ll notice you can ID the repositories
    that we''ve both starred: they are the ones labelled Unstar.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里我们看到它们是相同的，你会注意到可以标识出我们都加星的仓库：它们是那些标记为Unstar的。
- en: Unfortunately, with just 30 starred repositories, there aren't a lot of repositories
    to generate recommendations.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，仅凭30个加星的仓库，推荐的仓库数量并不多。
- en: 'The next user in terms of similarity is 42, Artem Golubin:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我相似的下一个用户是42，Artem Golubin：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code results in the following output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '![](img/9e826b79-e99b-468e-9bf5-ea87d04475a1.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e826b79-e99b-468e-9bf5-ea87d04475a1.png)'
- en: 'And his GitHub profile below:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以及他下面的GitHub资料：
- en: '![](img/2fd46a81-dbcc-4aec-9dae-74db19f2f4c1.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fd46a81-dbcc-4aec-9dae-74db19f2f4c1.png)'
- en: 'Here we see the repositories he has starred:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是他加星的仓库：
- en: '![](img/688655ef-721a-4503-8cb7-d90fd6ca56c1.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/688655ef-721a-4503-8cb7-d90fd6ca56c1.png)'
- en: Artem has starred over 500 repositories, so there are definitely some recommendations
    to be found there.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Artem加星了超过500个仓库，所以那里肯定有一些推荐。
- en: 'And finally, let''s look at the third most similar user:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下第三位最相似的用户：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This results in the following output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/80d07cbf-9bc3-4acc-8fc5-026dec03b83a.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80d07cbf-9bc3-4acc-8fc5-026dec03b83a.png)'
- en: 'This user, Kevin Markham, has starred around 60 repositories:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这位用户，Kevin Markham，加星了大约60个仓库：
- en: '![](img/d7801ab7-37c5-4a81-b8df-0bd6a2a39ef8.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7801ab7-37c5-4a81-b8df-0bd6a2a39ef8.png)'
- en: 'We can see the starred repositories in the following image:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的图像中看到加星的仓库：
- en: '![](img/2f7d43f9-fa57-4307-94f9-780a6c73fbdf.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f7d43f9-fa57-4307-94f9-780a6c73fbdf.png)'
- en: 'This is definitely fertile ground for generating recommendations. Let''s now
    do just that; let''s use the links from these three to produce some recommendations:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是生成推荐的肥沃土壤。现在，让我们就做这件事；我们将使用这三个链接来生成一些推荐：
- en: 'We need to gather the links to the repositories they''ve starred and that I
    haven''t. We''ll create a `DataFrame` that has the repositories I''ve starred
    as well as the three most similar users to me:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要收集他加星的仓库链接，而我没有加星的仓库。我们将创建一个`DataFrame`，包含我加星的仓库以及与我最相似的三位用户：
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code will produce the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '![](img/0c9c7b37-46ef-45c0-acd3-6edcdb94bb6a.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c9c7b37-46ef-45c0-acd3-6edcdb94bb6a.png)'
- en: 'Don''t worry if it looks like it''s all zeros; this is a sparse matrix so most
    will be 0\. Let''s see whether there are any repositories we''ve all starred:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它看起来全是零，不用担心；这是一个稀疏矩阵，所以大部分值为0。让我们看看是否有我们都加星的仓库：
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code will produce the following output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '![](img/fa2dbf18-0845-4435-92e9-f9c1b1db9616.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa2dbf18-0845-4435-92e9-f9c1b1db9616.png)'
- en: 'As you can see, we all seem to love scikit-learn and machine learning repositories—no
    surprise there. Let''s see what they might have all starred that I missed. We''ll
    start by creating a frame that excludes me, and then we''ll query it for commonly
    starred repositories:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所见，我们似乎都热衷于scikit-learn和机器学习的仓库——这不令人惊讶。让我们看看他们可能都加星了哪些我错过的仓库。我们将先创建一个不包含我的框架，然后查询其中共同加星的仓库：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code produces the following output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出：
- en: '![](img/aa86dd2f-5706-4d00-88d5-4c6329d650de.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa86dd2f-5706-4d00-88d5-4c6329d650de.png)'
- en: 'Okay, so it looks like I haven''t been missing anything super obvious. Let''s
    see if there any repositories that at least two out of three users starred. To
    find this, we''ll just sum across the rows:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，看起来我没有错过任何明显的内容。让我们看看是否有至少三位用户中有两位加星的仓库。为了找到这些仓库，我们将对行进行求和：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code will result in output similar to the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生类似以下的输出：
- en: '![](img/9160ebd7-e513-4038-ad8a-8eff7cd4c253.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9160ebd7-e513-4038-ad8a-8eff7cd4c253.png)'
- en: This looks promising. There are lots of good ML and AI repositories, and I'm
    honestly ashamed I never starred fuzzywuzzy as I use that quite frequently.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很有前景。有很多很好的机器学习和人工智能的存储库，老实说，我很羞愧以前没收藏 fuzzywuzzy，因为我经常用到它。
- en: At this point, I have to say I'm impressed with the results. These are definitely
    repositories that interest me, and I'll be checking them out.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我必须说我对结果感到印象深刻。这些确实是我感兴趣的存储库，我会去查看它们。
- en: So far, we've generated the recommendations using collaborative filtering and
    done some light additional filtering using aggregation. If we wanted to go further,
    we could order the recommendation based upon the total number of stars they received.
    This could be achieved by making another call to the GitHub API. There's an endpoint
    that provides this information.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过协同过滤生成了推荐，并且通过聚合做了一些轻量的附加过滤。如果我们想更进一步，可以根据推荐所收到的总星标数来排序。这可以通过再次调用
    GitHub API 来实现。GitHub 有一个端点提供这一信息。
- en: Another thing we could do to improve the results is to add in a layer of content-based
    filtering. This is the hybridization step we discussed earlier. We would need
    to create a set of features from our own repository that was indicative of the
    types of things we would be interested in. One way to do this would be to create
    a feature set by tokenizing the names of the repositories we have starred along
    with their descriptions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的另一件事是增加一层基于内容的过滤。这就是我们之前讨论的混合化步骤。我们需要从我们自己的存储库中创建一组特征，来表示我们感兴趣的内容类型。一种方法是通过对我们已收藏的存储库名称及其描述进行分词，来创建一组特征。
- en: 'Here''s a look at my starred repositories:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我收藏的存储库：
- en: '![](img/f755b271-db4e-45e1-9e4f-8aa9779c097b.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f755b271-db4e-45e1-9e4f-8aa9779c097b.png)'
- en: As you might imagine, this would generate a set of word features that we could
    use to vet the repositories of those we found using collaborative filtering. This
    would include a lot of words such as *Python*, *Machine Learning*, and *Data Science*.
    This would ensure that users who are less similar to ourselves are still providing
    recommendations that are based on our own interests. It would also reduce the
    serendipity of the recommendations, which is something to consider. Perhaps there's
    something unlike anything I have currently that I would love to see. It's certainly
    a possibility.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你想象的那样，这将生成一组我们可以用来筛选通过协同过滤找到的存储库的词特征。这将包括许多词，如 *Python*、*机器学习* 和 *数据科学*。这可以确保即使是与我们不太相似的用户，也能提供基于我们自己兴趣的推荐。同时，这也会减少推荐的偶然性，这一点需要考虑。也许有些东西与我目前拥有的完全不同，我会喜欢看到。这个可能性是存在的。
- en: What would that content-based filtering step look like in terms of a DataFrame?
    The columns would be word features (n-grams) and the rows would be the repositories
    generated from our collaborative filtering step. We would just run the similarity
    process once again using our own repository for comparison.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，基于内容的过滤步骤在 DataFrame 中会是什么样子的呢？列将是词特征（n-grams），行则是通过协同过滤步骤生成的存储库。我们只需要再次运行相似度处理，使用我们自己的存储库进行比较。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned about recommendation engines. We learned about
    the two primary types of systems in use today: collaborative filtering and content-based
    filtering. We also learned how they can be used together to form a hybrid system.
    We also discussed the pros and cons of each type of system. And finally, we learned
    step by step how to build a recommendation engine from scratch using the GitHub
    API.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了推荐引擎。我们学习了当前使用的两种主要系统：协同过滤和基于内容的过滤。我们还学习了如何将这两者结合使用，形成一个混合系统。我们还讨论了每种系统的优缺点。最后，我们一步步了解了如何使用
    GitHub API 从零开始构建推荐引擎。
- en: I hope you build your own recommendation engine using the guidance in this chapter,
    and I hope you find resources that are useful to you. I know I've found a number
    of things I will certainly be using. Best of luck to you on your journey!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能按照本章的指导，构建你自己的推荐引擎，并找到对你有用的资源。我知道我已经发现了许多我一定会使用的东西。祝你在旅程中好运！
