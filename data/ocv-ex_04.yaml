- en: Chapter 4. Delving into Histograms and Filters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：深入直方图和滤波器
- en: In the previous chapter, we learned the basics of user interfaces in OpenCV
    using QT or native libraries and how to use advanced OpenGL user interfaces. We
    learned basic color conversions and filters that helped us create our first application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了使用QT或本地库在OpenCV中用户界面的基础知识以及如何使用高级OpenGL用户界面。我们学习了基本的颜色转换和过滤器，这些有助于我们创建我们的第一个应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Histogram and histogram equalization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图和直方图均衡化
- en: Look up tables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找表
- en: The blur and median blur
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊和中值模糊
- en: The Gaussian Canny filter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯Canny滤波器
- en: Image color equalization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像颜色均衡化
- en: Understanding conversion between image types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图像类型之间的转换
- en: 'After we learn the basics of OpenCV and user interfaces, we will create our
    first complete application and a basic photo tool with the following functionalities
    in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习OpenCV和用户界面的基础知识之后，我们将在本章创建我们的第一个完整应用程序和一个基本的照片工具，具有以下功能：
- en: Calculate and draw a histogram
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算并绘制直方图
- en: Histogram equalization
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: The lomography camera effect
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洛马格诺伊相机效果
- en: The cartoonize effect
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡通化效果
- en: This application will help you understand how to create a whole project from
    scratch and understand the histogram concept. We will see how to equalize the
    histogram of a color image and create two effects using a combination of filters
    and the use of look up tables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将帮助您了解如何从头开始创建整个项目并理解直方图概念。我们将看到如何使用组合滤波器和查找表来均衡彩色图像的直方图，并创建两种效果。
- en: Generating a CMake script file
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成CMake脚本文件
- en: 'Before we start creating our source file, we will generate the `CMakeLists.txt`
    file that will allow us to compile our project, structure, and executable. The
    following `cmake` script is simple and basic but enough to compile and generate
    the executable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建源文件之前，我们将生成`CMakeLists.txt`文件，这将允许我们编译我们的项目、结构和可执行文件。以下`cmake`脚本简单且基本，但足以编译和生成可执行文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's try to understand the script file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解脚本文件。
- en: 'The first line indicates the minimum `cmake` version required to generate our
    project, and the second line sets the `CMP0012` policy variable to allow you to
    identify numbers and Boolean constants and remove the CMake warning if it is not
    set:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行指示生成我们项目所需的最低`cmake`版本，第二行将`CMP0012`策略变量设置为允许您识别数字和布尔常量，并在未设置时移除CMake警告：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After these two lines, we define the project name:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两行之后，我们定义项目名称：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of course, we need to include the OpenCV library. The first thing to do is
    find the library and show a message about the OpenCV library version with the
    `MESSAGE` function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要包含OpenCV库。首先要做的是找到库，并使用`MESSAGE`函数显示有关OpenCV库版本的消息：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the library with the minimum version 3.0 is found, then we include the headers
    and library files in our project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到最小版本为3.0的库，那么我们将包含头文件和库文件到我们的项目中：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we only need to add the source files that are to be compiled; in order
    to link them to the OpenCV library, we use the project name variable as an executable
    name and use only a single source file called `main.cpp`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要添加要编译的源文件；为了将它们链接到OpenCV库，我们使用项目名称变量作为可执行文件名称，并仅使用一个名为`main.cpp`的单个源文件：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating the Graphical User Interface
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图形用户界面
- en: Before we start with the image processing algorithms, we will create the main
    user interface for our application. We will use a QT-based user interface to allow
    us to create single buttons.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始图像处理算法之前，我们将创建应用程序的主要用户界面。我们将使用基于QT的用户界面，以便我们可以创建单个按钮。
- en: 'The application receives one input parameter to load the image to be processed,
    and we will create the following four buttons:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序接收一个输入参数来加载要处理的图像，我们将创建以下四个按钮：
- en: '**Show histogram**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示直方图**'
- en: '**Equalize histogram**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均衡直方图**'
- en: '**Lomography effect**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**洛马格诺伊效果**'
- en: '**Cartoonize effect**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卡通化效果**'
- en: 'We can see the four results in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图中看到四个结果：
- en: '![Creating the Graphical User Interface](img/B04283_04_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![创建图形用户界面](img/B04283_04_01.jpg)'
- en: 'Let''s develop our project. First of all, we will include the required OpenCV
    headers. We define an `img` matrix to store the input image, and create a constant
    string to use the new command-line parser, which is only available in OpenCV 3.0\.
    In this constant, we allow only two input parameters: common help and the required
    image input:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发我们的项目。首先，我们将包含所需的OpenCV头文件。我们定义一个`img`矩阵来存储输入图像，并创建一个常量字符串来使用仅适用于OpenCV
    3.0的新命令行解析器。在这个常量中，我们只允许两个输入参数：常见帮助和必需的图像输入：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `main` function starts with the command-line parser variable. We then set
    the instructions and print the help message. The following lines will help you
    set up the help instructions for our final executable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数从命令行解析变量开始。然后我们设置说明并打印帮助信息。以下行将帮助您设置最终可执行文件的帮助说明：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the user doesn''t require help, then we need to get the file path image
    in an `imgFile` variable string and check whether all the required parameters
    are added to the `parser.check()` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不需要帮助，那么我们需要在`imgFile`变量字符串中获取文件路径图像并检查是否将所有必需的参数添加到`parser.check()`函数中：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can read the image file with the `imread` function and then create
    the window in which the input image will be shown later using the `namedWindow`
    function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`imread`函数读取图像文件，然后使用`namedWindow`函数创建一个窗口，稍后将在其中显示输入图像：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the image loaded and window created, we only need to create the buttons
    for our interface and link them to the `callback` functions. Each `callback` function
    is defined in the source code, and we will explain them later in this chapter.
    We will create the buttons with the `createButton` function with the `QT_PUSH_BUTTON`
    constant in the button style:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图像加载和窗口创建后，我们只需要创建我们的界面按钮并将它们链接到`callback`函数。每个`callback`函数都在源代码中定义，我们将在本章后面解释它们。我们将使用带有`QT_PUSH_BUTTON`常量的`createButton`函数创建按钮：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To complete our `main` function, we show the input image and wait for a key
    press to finish our application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的`main`函数，我们显示输入图像并等待按键以结束我们的应用程序：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we only need to define the `callback` functions in the following sections,
    and we will define and describe each one of them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要定义以下部分中的`callback`函数，我们将定义并描述每个函数。
- en: Drawing a histogram
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制直方图
- en: A histogram is a statistical graphic representation of variable distribution.
    This allows us to understand the density estimation and probability distribution
    of data. The histogram is created by dividing the entire range of variable values
    into a fixed number of intervals and then counting how many values fall into each
    interval.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是变量分布的统计图形表示。这使我们能够理解数据的密度估计和概率分布。直方图是通过将变量的整个值域划分为固定数量的区间，然后计算每个区间中落入的值的数量来创建的。
- en: If we apply this histogram concept to an image, it seems to be complex to understand,
    but it is really very simple. In a gray image, our variable values can take any
    possible gray value ranging from `0` to `255`, and the density is the number of
    pixels in the image that have this value. This means that we have to count the
    number of image pixels that have the value `0`, count the number of pixels of
    value `1`, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个直方图概念应用到图像上，它看起来很复杂，但实际上非常简单。在灰度图像中，我们的变量值可以取从`0`到`255`的任何可能的灰度值，密度是具有此值的图像中的像素数量。这意味着我们必须计算具有值`0`的图像像素数量，计算值为`1`的像素数量，依此类推。
- en: The callback function that shows the histogram of the input image is called
    `showHistoCallback`. This function calculates the histogram of each channel image
    and shows the result of each histogram channel in a new image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显示输入图像直方图的回调函数称为`showHistoCallback`。此函数计算每个通道图像的直方图，并在新图像中显示每个直方图通道的结果。
- en: 'Now, let''s check the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查以下代码：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's try to understand how to extract each channel histogram and how to draw
    it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解如何提取每个通道的直方图以及如何绘制它。
- en: 'First, we need to create three matrices to process each input image channel.
    We use a `vector` type variable to store each one, and use the split `OpenCV`
    function to divide the input image into three channels:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建三个矩阵来处理每个输入图像通道。我们使用`vector`类型变量来存储每个矩阵，并使用`split` OpenCV函数将输入图像划分为三个通道：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we will define the number of bins in our histogram; in our case, one bin
    per possible pixel value:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义直方图中的bin数量；在我们的情况下，每个可能的像素值一个bin：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need to define our range of variables and create three matrices to
    store each histogram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义我们的变量范围并创建三个矩阵来存储每个直方图：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can calculate the histogram using the OpenCV `calcHist` function. This
    function has several parameters, which are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用OpenCV的`calcHist`函数来计算直方图。此函数有几个参数，如下所示：
- en: The input image; in our case, we use one image channel stored in the `bgr` vector
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入图像；在我们的例子中，我们使用存储在`bgr`向量中的一个图像通道
- en: The number of images required to calculate the histogram in the input; in our
    case, we only use one image
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算输入中直方图所需的图像数量；在我们的例子中，我们只使用一个图像
- en: The dimensions of the number channel used to compute the histogram; we use 0
    in our case
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于计算直方图的通道数维度；在我们的例子中，我们使用0
- en: The optional mask matrix
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的掩码矩阵
- en: The variable used to store the calculated histogram
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储计算出的直方图的变量
- en: The histogram dimensionality (the dimension of the space where the image (here,
    it's a gray plane) takes its values); in our case, it's 1
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图维度（图像（在这里，是一个灰度平面）取值的空间的维度）；在我们的例子中，它是1
- en: The number of bins to be calculated; in our case, we use 256 bins, one per pixel
    value
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要计算的bin数量；在我们的例子中，我们使用256个bin，每个像素值一个
- en: The range of the input variable; in our case, it's a range of possible pixel
    values from `0` to `255`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入变量的范围；在我们的例子中，是从`0`到`255`的可能像素值范围
- en: 'Our `calcHist` function for each channel looks like the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个通道的`calcHist`函数如下所示：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we have calculated the histogram for each channel. We need to draw each
    channel histogram and show it to the user. To do this, we will create a color
    image with a size of 512 x 300 pixels:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为每个通道计算了直方图。我们需要绘制每个通道的直方图并展示给用户。为此，我们将创建一个大小为512 x 300像素的颜色图像：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before we draw the histogram values in our image, we will normalize the histogram
    matrices between the `min` value `0` and a `max` value; in our case, the same
    value as that of the height of our image, 300 pixels:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在图像中绘制直方图值之前，我们将直方图矩阵在`min`值`0`和`max`值之间进行归一化；在我们的例子中，这个值与图像的高度相同，300像素：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we need to draw a line from bin 0 to bin 1 and so on. We need to calculate
    the number of pixels between each bin, and then a `binStep` variable is calculated
    by dividing the width by the number of bins.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从bin 0到bin 1等绘制线条。我们需要计算每个bin之间的像素数，然后通过除以bin的数量来计算`binStep`变量。
- en: 'Each small line is drawn from the horizontal position, `i-1` to `i`, and the
    vertical position is the histogram value in the corresponding `i`. It is drawn
    with the color channel representation, which is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个小线条是从水平位置`i-1`到`i`绘制的，垂直位置是相应的`i`处的直方图值。它使用如下所示的颜色通道表示法绘制：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we show the histogram image with the `imshow` function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`imshow`函数显示直方图图像：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the result of the lena.png image:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是lena.png图像的结果：
- en: '![Drawing a histogram](img/B04283_04_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![绘制直方图](img/B04283_04_02.jpg)'
- en: Image color equalization
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像颜色均衡化
- en: In this section, we will learn how to equalize a color image. Image equalization
    and histogram equalization try to obtain a histogram with a uniform distribution
    of values. The result of equalization is an increase in the contrast of an image.
    The equalization allows lower local contrast areas to gain higher contrast, spreading
    out the most frequent intensities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何对彩色图像进行均衡化。图像均衡化和直方图均衡化试图获得一个具有均匀分布值的直方图。均衡化的结果是图像对比度的增加。均衡化允许局部对比度较低的区域获得更高的对比度，使最频繁的强度分布更广。
- en: This method is very useful when the image is almost dark or completely bright
    and there are very small differences between the background and foreground. Using
    histogram equalization, we increase the contrast and the details that are over-
    or under-exposed. This technique is very useful in medical images, such as X-rays.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像几乎全暗或完全明亮，背景和前景之间差异非常小的时候，这种方法非常有用。使用直方图均衡化，我们可以增加过曝或欠曝的细节对比度。这种技术在医学图像，如X光片中非常有用。
- en: 'However, there are two main disadvantages to this method: it increases the
    background noise and decreases useful signals.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有两个主要缺点：它增加了背景噪声并减少了有用信号。
- en: 'We can see the effect of equalization in the following image and see how the
    histogram changes and spreads on increasing the image contrast:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图像中看到均衡化的效果，并看到直方图在增加图像对比度时如何变化和扩散：
- en: '![Image color equalization](img/B04283_04_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图像颜色均衡化](img/B04283_04_03.jpg)'
- en: 'Let''s try to implement our histogram equalization. We will implement it in
    the callback function defined in the user interface''s code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试实现我们的直方图均衡化。我们将在用户界面代码中定义的回调函数中实现它：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To equalize a color image, we only need to equalize the luminance channel.
    We can do this with each color channel, but the result is not usable. Then, we
    can use any other color image format, such as HSV or YCrCb, that separates the
    luminance component in an individual channel. We choose this last color format
    and use a Y channel (luminance) to equalize it. Then, we perform the following
    steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要均衡一个彩色图像，我们只需要均衡亮度通道。我们可以对每个颜色通道进行此操作，但结果不可用。然后，我们可以使用任何其他颜色图像格式，例如HSV或YCrCb，这些格式将亮度分量分离到单独的通道中。我们选择这种最后的颜色格式，并使用Y通道（亮度）来均衡它。然后，我们执行以下步骤：
- en: 'We convert our input BGR image into YCrCb using the `cvtColor` function:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`cvtColor`函数将我们的输入BGR图像转换为YCrCb：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After converting our image, we split the YCrCb image into different `channels`
    matrices:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将我们的图像转换后，我们将YCrCb图像分割成不同的`通道`矩阵：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then equalize the histogram only in the `Y channel` using the `equalizeHist`
    function, which has only two parameters: input and output matrices:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们仅使用`equalizeHist`函数在`Y通道`中均衡直方图，该函数只有两个参数：输入和输出矩阵：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we only need to merge the resulted channels and convert the result to
    the BGR format to show the user the result:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要合并生成的通道，并将结果转换为BGR格式，以便向用户展示结果：
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The process applied to a low contrast `Lena` image will have the following
    result:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对低对比度的`Lena`图像应用此过程将得到以下结果：
- en: '![Image color equalization](img/B04283_04_04.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图像颜色均衡](img/B04283_04_04.jpg)'
- en: Lomography effect
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洛马摄影效果
- en: In this section, we will create another image effect, a photographic effect
    that is commonly used in different mobile applications, such as Google Camera
    or Instagram.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建另一种图像效果，这是一种在Google Camera或Instagram等不同移动应用中常用的摄影效果。
- en: In this section, we will discover how to use a **Look up Table** or **LUT**.
    We will discuss LUTs later in this chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用**查找表**或**LUT**。我们将在本章后面讨论LUT。
- en: We will learn how to add an over image; in this case, a dark halo to create
    our desired effect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何添加一个覆盖图像；在这种情况下，添加一个暗晕来达到我们想要的效果。
- en: 'The function that implements this effect is the callback `lomoCallback` and
    has the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此效果的函数是回调`lomoCallback`，其代码如下：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's understand the code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下代码。
- en: 'The lomography effect is divided into different steps, but in our example we
    applied a very simple lomography effect using the following two steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 洛马摄影效果分为不同的步骤，但在我们的例子中，我们使用了以下两个非常简单的步骤来实现洛马摄影效果：
- en: A color manipulation with a look up table that applies a curve to the red channel
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用查找表进行颜色操作，并将曲线应用到红色通道上
- en: A vintage effect that applies a dark halo to the image.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种复古效果，将暗晕应用到图像上。
- en: 'The first step is to manipulate the red color with a curve transform that applies
    this function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用曲线变换来调整红色，该变换应用以下函数：
- en: '![Lomography effect](img/B04283_04_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![洛马摄影效果](img/B04283_04_05.jpg)'
- en: 'This formula generates a curve that makes the dark values darker and light
    values lighter, where *x* is the possible pixel value (0 to 255) and *s* is a
    constant that we set to *0.1* in our tutorial. A lower constant value that generates
    pixels with values lower than 128 is very dark and over 128 is very bright. Values
    that are near to *1* convert the curve to a line and do not generate our desired
    effect:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此公式生成一个曲线，使暗值更暗，亮值更亮，其中*x*是可能的像素值（0到255），而*s*是一个常数，我们在教程中将其设置为*0.1*。产生像素值低于128的较低常数值非常暗，而高于128的非常亮。接近*1*的值将曲线转换为直线，不会产生我们想要的效果：
- en: '![Lomography effect](img/B04283_04_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![洛马摄影效果](img/B04283_04_06.jpg)'
- en: This function is very easy to implement by applying a **Look Up Table**, more
    commonly called a LUT. A LUT is a vector or table that returns a preprocess value
    for a given value to perform computation in the memory. A LUT is a common technique
    used to spare CPU cycles by avoiding performing costly computations repeatedly.
    Instead of calling the exponential/divide function for each pixel, we perform
    it only once for each possible pixel value (256 times) and store the result in
    a table. Thus, we save the CPU time at the cost of a bit of memory. While this
    may not make a great difference for the standard PC with small image sizes, this
    makes a huge difference for CPU-limited hardware, such as the Raspberry Pi. In
    our case, if we want to apply our function for each pixel, we need to make the
    width by calculating the height; in 100 x 100 pixels, there are 10,000 calculations,
    but there are only 256 possible values for a pixel. We can then precalculate the
    pixel values and save them in a LUT vector.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过应用**查找表**（通常称为LUT）非常容易实现。LUT是一个向量或表，它为给定的值返回一个预处理的值以在内存中执行计算。LUT是一种常用的技术，通过避免重复执行昂贵的计算来节省CPU周期。我们不是对每个像素调用指数/除法函数，而是对每个可能的像素值（256次）只执行一次，并将结果存储在表中。因此，我们以牺牲一些内存为代价节省了CPU时间。虽然这可能在标准PC和较小图像尺寸的情况下不会产生很大差异，但对于CPU受限的硬件（如树莓派）来说，这会产生巨大的差异。在我们的情况下，如果我们想对每个像素应用我们的函数，我们需要通过计算高度来增加宽度；在100
    x 100像素中，有10,000次计算，但像素只有256个可能的值。然后，我们可以预先计算像素值并将它们存储在LUT向量中。
- en: 'In our sample code, we define the `E` variable and create a `lut` matrix of
    1 row and 256 columns. Then, we do a loop over all possible pixel values by applying
    our formula and saving them in the `lut` variable:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们定义了`E`变量并创建了一个1行256列的`lut`矩阵。然后，我们通过应用我们的公式并保存到`lut`变量中，对所有可能的像素值进行循环：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As mentioned earlier, in this section we don''t apply the function to all channels.
    We need to split our input image by channels using the `split` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在本节中，我们不将函数应用于所有通道。我们需要使用`split`函数按通道拆分输入图像：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then apply our `lut` table variable to the red channel. OpenCV give us the
    `LUT` function that has the following three parameters:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们的`lut`表变量应用于红色通道。OpenCV为我们提供了具有以下三个参数的`LUT`函数：
- en: An input image
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入图像
- en: A matrix of a look up table
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找表的矩阵
- en: An output image
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出图像
- en: 'Then, our call to the `LUT` function and red channels looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的`LUT`函数和红色通道的调用看起来是这样的：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we only have to merge our computed channels:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要合并我们计算出的通道：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The first step is done, and we only have to create the dark halo to finish
    our effect. Then, we create a gray image with a white circle inside with the same
    input image size:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步已完成，我们只需要创建暗光环来完成我们的效果。然后，我们创建一个与输入图像大小相同的灰色图像，其中包含一个白色圆圈：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Lomography effect](img/B04283_04_07.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Lomography效果](img/B04283_04_07.jpg)'
- en: 'However, if we apply this image to our input image, it will change from dark
    to white, and we can then apply a big blur using the `blur` filter function to
    our circle halo image to get a smooth effect:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将此图像应用于输入图像，它将从暗变亮，然后我们可以使用`blur`滤镜函数对圆光环图像应用大模糊以获得平滑效果：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result after applying the blur filter is shown in the following image:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 应用模糊滤镜后的结果如下所示：
- en: '![Lomography effect](img/B04283_04_08.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Lomography效果](img/B04283_04_08.jpg)'
- en: 'Now, we need to apply this halo to our image from step 1\. An easy way to do
    this is to multiply both the images. But we need to convert our input image from
    an 8-bit image to a 32-bit float because we need to multiply our blurred image
    that has values ranging from 0 to 1 by our input image that has integer values:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这个光环应用到我们的第一步图像上。一种简单的方法是乘以两个图像。但是，我们需要将我们的输入图像从8位图像转换为32位浮点图像，因为我们需要将值在0到1之间的模糊图像与具有整数值的输入图像相乘：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After we convert our image, we only need to multiply each matrix per element:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将图像转换后，我们只需要逐元素乘以每个矩阵：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we convert the float image matrix result to an 8-bit image and show
    the result:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将浮点图像矩阵结果转换为8位图像并显示结果：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![Lomography effect](img/B04283_04_09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Lomography效果](img/B04283_04_09.jpg)'
- en: The cartoonize effect
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡通化效果
- en: 'In the last section of this chapter, we create another effect called **cartoonize**.
    The purpose of this effect is to create an image that looks like a cartoon. To
    do this, we divide the algorithm into two steps: edge detection and color filtering.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们创建了一个名为**卡通化**的另一种效果。这个效果的目的创建一个看起来像卡通的图像。为此，我们将算法分为两个步骤：边缘检测和颜色过滤。
- en: 'The `cartoonCallback` functions define this effect with the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`cartoonCallback`函数使用以下代码定义此效果：'
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's try to understand the code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解这段代码。
- en: 'The first step is to detect the most important edges of the image. We need
    to remove noise from the input image before we detect the edges. There are several
    ways and methods to do this. We will use a median filter to remove any possible
    small noise, but we can use other methods such as Gaussian blur and so on. The
    OpenCV function is called `medianBlur` and accepts three parameters: an input
    image, an output image, and the kernel size (a kernel is a small matrix used to
    apply some mathematical operation such as convolutional to an image).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是检测图像中最重要的边缘。在检测边缘之前，我们需要从输入图像中去除噪声。有几种方法和方式可以做到这一点。我们将使用中值滤波器来去除任何可能的小噪声，但我们可以使用其他方法，如高斯模糊等。OpenCV函数名为`medianBlur`，接受三个参数：输入图像、输出图像和核大小（核是一个用于对图像应用某些数学运算，如卷积的小矩阵）。
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After removing any possible noise, we detect the strong edges with a `canny`
    filter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在去除任何可能的噪声后，我们使用`canny`滤波器检测强边缘：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `canny` filter accepts the following parameters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`canny`滤波器接受以下参数：'
- en: An input image
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入图像
- en: An output image
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出图像
- en: The first threshold
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个阈值
- en: The second threshold
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个阈值
- en: The Sobel size aperture
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sobel大小孔径
- en: The Boolean value to check whether to use a more accurate image gradient magnitude
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，用于检查是否使用更精确的图像梯度幅度
- en: The smallest value between the first and second threshold is used for edge linking.
    The largest value is used to find initial segments of strong edges. The `solbel`
    size aperture is the kernel size of the `sobel` filter that will be used in the
    algorithm.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个阈值之间的最小值用于边缘连接。最大值用于找到强边缘的初始段。`solbel`大小孔径是算法中将使用的`sobel`滤波器的核大小。
- en: 'After detecting the edges, we will apply a small dilation to join the broken
    edges:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到边缘后，我们将应用一个小膨胀来连接断裂的边缘：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similar to what we did in the Lomography effect, we need to multiply our edges''
    result image by the color image. Then, we require a pixel value between `0` and
    `1`, and so we divide the canny result by `256` and invert the edges to black:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在Lomography效果中所做的一样，我们需要将我们的边缘结果图像乘以颜色图像。然后，我们需要一个介于`0`和`1`之间的像素值，因此我们将canny结果除以`256`并反转边缘为黑色：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Transform the Canny 8 unsigned bit format to a float matrix:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将Canny 8无符号位格式转换为浮点矩阵：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To give a cool result, we can blur the edges to give a smooth result line,
    and then we apply a blur filter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一个酷炫的结果，我们可以模糊边缘以得到平滑的结果线，然后我们应用一个模糊滤镜：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first step of the algorithm is complete, and now we will work with the color.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的第一步已经完成，现在我们将处理颜色。
- en: 'To get a cartoon look and feel, we will use the bilateral filter:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到卡通的外观和感觉，我们将使用双边滤波器：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A bilateral filter is a filter used to reduce the noise of an image while keeping
    edges, but we can get a cartoonish effect with appropriate parameters that we
    will explore later.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 双边滤波器是一种用于减少图像噪声同时保持边缘的滤波器，但我们可以通过适当的参数得到卡通效果，我们将在后面探讨。
- en: 'The bilateral filter parameters are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 双边滤波器参数如下：
- en: An input image
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入图像
- en: An output image
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出图像
- en: The diameter of a pixel neighborhood; if it's set to negative, it is computed
    from a sigma space value
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素邻域的直径；如果设置为负值，则从sigma空间值计算得出
- en: A sigma color value
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个sigma颜色值
- en: A sigma coordinate space
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个sigma坐标空间
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With a diameter greater than 5, the bilateral filter becomes slow. With sigma
    values greater than 150, a cartoonish effect appears.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当直径大于5时，双边滤波器会变慢。当sigma值大于150时，会出现卡通效果。
- en: 'To create a stronger cartoonish effect, we truncate the possible color values
    to 10 by dividing and multiplying the pixel values. For other values, and to better
    understand the sigma parameters, read the OpenCV documentation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更强的卡通效果，我们将通过除法和乘法将可能的颜色值截断到10。对于其他值，以及为了更好地理解sigma参数，请阅读OpenCV文档：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we need to merge the color and edges'' results. Then, we need to create
    a `3`-channel image from the first step:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要合并颜色和边缘的结果。然后，我们需要从第一步创建一个`3`通道图像：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we convert our color result image to a 32 float image and then multiply
    both the images per element:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们的颜色结果图像转换为32位浮点图像，然后对两个图像的每个元素进行乘法运算：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we only need to convert our image to an 8-bit image and show the resulting
    image to the user:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需将我们的图像转换为8位图像，并将结果图像展示给用户：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the following image, we can see the input image (the left-hand side image)
    and the result after applying the cartoonize effect (the right-hand side image):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，我们可以看到输入图像（左侧图像）以及应用卡通化效果后的结果（右侧图像）：
- en: '![The cartoonize effect](img/B04283_04_10.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![卡通化效果](img/B04283_04_10.jpg)'
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create a complete project that manipulates
    images after applying different effects. We also split a color image in multiple
    matrices in order to apply effects to only one channel. We learned how to create
    look up tables, merge multiple matrices in one, use a canny and bilateral filter,
    draw circles, and multiply images to perform halo effects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建一个完整的项目，该项目在应用不同效果后操作图像。我们还把彩色图像分割成多个矩阵，以便只对一个通道应用效果。我们学习了如何创建查找表，将多个矩阵合并为一个，使用Canny和双边滤波器，绘制圆形，以及通过乘法图像来执行晕影效果。
- en: In the next chapter, we will learn how to do object inspection and how to segment
    an image in different parts and detect it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何进行对象检查以及如何将图像分割成不同的部分并检测它。
