- en: Chapter 2. Handling Files, Cameras, and GUIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：处理文件、摄像头和GUI
- en: Installing OpenCV and running samples is fun, but at this stage, we want to
    try it out ourselves. This chapter introduces OpenCV's I/O functionality. We also
    discuss the concept of a project and the beginnings of an object-oriented design
    for this project, which we will flesh out in subsequent chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安装OpenCV并运行示例很有趣，但在这个阶段，我们想亲自尝试。本章介绍了OpenCV的I/O功能。我们还讨论了项目概念以及这个项目的面向对象设计的开始，我们将在随后的章节中详细阐述。
- en: 'By starting with a look at the I/O capabilities and design patterns, we will
    build our project in the same way we would make a sandwich: from the outside in.
    Bread slices and spread, or endpoints and glue, come before fillings or algorithms.
    We choose this approach because computer vision is mostly extroverted—it contemplates
    the real world outside our computer—and we want to apply all our subsequent algorithmic
    work to the real world through a common interface.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从查看I/O能力和设计模式开始，我们将以制作三明治的方式构建我们的项目：从外到内。面包切片和涂抹，或者端点和胶水，在填充或算法之前。我们选择这种方法是因为计算机视觉主要是外向的——它考虑的是我们计算机之外的现实世界——我们希望通过一个公共接口将我们后续的所有算法工作应用到现实世界中。
- en: Basic I/O scripts
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本I/O脚本
- en: Most CV applications need to get images as input. Most also produce images as
    output. An interactive CV application might require a camera as an input source
    and a window as an output destination. However, other possible sources and destinations
    include image files, video files, and raw bytes. For example, raw bytes might
    be transmitted via a network connection, or they might be generated by an algorithm
    if we incorporate procedural graphics into our application. Let's look at each
    of these possibilities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CV应用程序需要获取图像作为输入。大多数也会生成图像作为输出。一个交互式CV应用程序可能需要一个摄像头作为输入源和一个窗口作为输出目标。然而，其他可能的源和目标包括图像文件、视频文件和原始字节。例如，原始字节可能通过网络连接传输，或者如果我们将过程图形纳入我们的应用程序，它们可能由算法生成。让我们看看这些可能性中的每一个。
- en: Reading/writing an image file
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取/写入图像文件
- en: OpenCV provides the `imread()` and `imwrite()` functions that support various
    file formats for still images. The supported formats vary by system but should
    always include the BMP format. Typically, PNG, JPEG, and TIFF should be among
    the supported formats too.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了`imread()`和`imwrite()`函数，支持各种静态图像的文件格式。支持的格式因系统而异，但应始终包括BMP格式。通常，PNG、JPEG和TIFF也应包括在支持的格式中。
- en: Let's explore the anatomy of the representation of an image in Python and NumPy.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索在Python和NumPy中图像表示的结构。
- en: 'No matter the format, each pixel has a value, but the difference is in how
    the pixel is represented. For example, we can create a black square image from
    scratch by simply creating a 2D NumPy array:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不论格式如何，每个像素都有一个值，但区别在于像素的表示方式。例如，我们可以通过简单地创建一个2D NumPy数组从头开始创建一个黑色方形图像：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we print this image to a console, we obtain the following result:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此图像打印到控制台，我们将获得以下结果：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each pixel is represented by a single 8-bit integer, which means that the values
    for each pixel are in the 0-255 range.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个像素由一个单一的8位整数表示，这意味着每个像素的值在0-255范围内。
- en: 'Let''s now convert this image into **Blue-green-red** (**BGR**) using `cv2.cvtColor`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`cv2.cvtColor`将此图像转换为**蓝绿红**（**BGR**）：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s observe how the image has changed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们观察图像是如何变化的：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, each pixel is now represented by a three-element array, with
    each integer representing the B, G, and R channels, respectively. Other color
    spaces, such as HSV, will be represented in the same way, albeit with different
    value ranges (for example, the hue value of the HSV color space has a range of
    0-180) and different numbers of channels.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个像素现在由一个包含三个元素的数组表示，其中每个整数分别代表B、G和R通道。其他颜色空间，如HSV，将以相同的方式表示，尽管值范围不同（例如，HSV颜色空间的色调值范围为0-180）以及通道数量不同。
- en: You can check the structure of an image by inspecting the `shape` property,
    which returns rows, columns, and the number of channels (if there is more than
    one).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查`shape`属性来检查图像的结构，该属性返回行、列和通道数（如果有多个通道）。
- en: 'Consider this example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code will print `(3,3)`. If you then converted the image to BGR,
    the shape would be `(3,3,3)`, which indicates the presence of three channels per
    pixel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打印`(3,3)`。如果您然后将图像转换为BGR，形状将是`(3,3,3)`，这表明每个像素有三个通道。
- en: 'Images can be loaded from one file format and saved to another. For example,
    let''s convert an image from PNG to JPEG:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以从一种文件格式加载并保存到另一种格式。例如，让我们将图像从 PNG 转换为 JPEG：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the OpenCV functionalities that we use are in the `cv2` module. You
    might come across other OpenCV guides that instead rely on the `cv` or `cv2.cv`
    modules, which are legacy versions. The reason why the Python module is called
    `cv2` is not because it is a Python binding module for OpenCV 2.x.x, but because
    it has introduced a better API, which leverages object-oriented programming as
    opposed to the previous `cv` module, which adhered to a more procedural style
    of programming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的 OpenCV 功能大多位于 `cv2` 模块中。你可能会遇到其他依赖 `cv` 或 `cv2.cv` 模块的 OpenCV 指南，这些是旧版本。Python
    模块被称为 `cv2` 并不是因为它是 OpenCV 2.x.x 的 Python 绑定模块，而是因为它引入了一个更好的 API，它利用面向对象编程，而不是之前的
    `cv` 模块，后者遵循更过程化的编程风格。
- en: By default, `imread()` returns an image in the BGR color format even if the
    file uses a grayscale format. BGR represents the same color space as **red-green-blue**
    (**RGB**), but the byte order is reversed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，即使文件使用灰度格式，`imread()` 也返回 BGR 颜色格式的图像。BGR 代表与 **红-绿-蓝**（**RGB**）相同的颜色空间，但字节顺序相反。
- en: 'Optionally, we may specify the mode of `imread()` to be one of the following
    enumerators:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择指定 `imread()` 的模式为以下枚举之一：
- en: '`IMREAD_ANYCOLOR = 4`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_ANYCOLOR = 4`'
- en: '`IMREAD_ANYDEPTH = 2`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_ANYDEPTH = 2`'
- en: '`IMREAD_COLOR = 1`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_COLOR = 1`'
- en: '`IMREAD_GRAYSCALE = 0`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_GRAYSCALE = 0`'
- en: '`IMREAD_LOAD_GDAL = 8`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_LOAD_GDAL = 8`'
- en: '`IMREAD_UNCHANGED = -1`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_UNCHANGED = -1`'
- en: 'For example, let''s load a PNG file as a grayscale image (losing any color
    information in the process), and then, save it as a grayscale PNG image:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将 PNG 文件作为灰度图像加载（在此过程中丢失任何颜色信息），然后将其保存为灰度 PNG 图像：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To avoid unnecessary headaches, use absolute paths to your images (for example,
    `C:\Users\Joe\Pictures\MyPic.png` on Windows or `/home/joe/pictures/MyPic.png`
    on Unix) at least while you're familiarizing yourself with OpenCV's API. The path
    of an image, unless absolute, is relative to the folder that contains the Python
    script, so in the preceding example, `MyPic.png` would have to be in the same
    folder as your Python script or the image won't be found.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不必要的麻烦，在使用 OpenCV 的 API 时，至少使用图像的绝对路径（例如，Windows 上的 `C:\Users\Joe\Pictures\MyPic.png`
    或 Unix 上的 `/home/joe/pictures/MyPic.png`），路径必须是相对的，除非它是绝对路径。图像的路径，除非是绝对路径，否则相对于包含
    Python 脚本的文件夹，所以在前面的例子中，`MyPic.png` 必须与你的 Python 脚本在同一文件夹中，否则找不到图像。
- en: Regardless of the mode, `imread()` discards any alpha channel (transparency).
    The `imwrite()` function requires an image to be in the BGR or grayscale format
    with a certain number of bits per channel that the output format can support.
    For example, `bmp` requires 8 bits per channel, while PNG allows either 8 or 16
    bits per channel.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无论模式如何，`imread()` 都会丢弃任何 alpha 通道（透明度）。`imwrite()` 函数要求图像以 BGR 或灰度格式存在，并且每个通道需要支持一定数量的位，该位数为输出格式所能支持。例如，`bmp`
    需要每个通道 8 位，而 PNG 允许每个通道 8 或 16 位。
- en: Converting between an image and raw bytes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在图像和原始字节之间进行转换
- en: Conceptually, a byte is an integer ranging from 0 to 255\. In all real-time
    graphic applications today, a pixel is typically represented by one byte per channel,
    though other representations are also possible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，一个字节是一个介于 0 到 255 之间的整数。在所有今天的实时图形应用中，一个像素通常由每个通道一个字节表示，尽管其他表示也是可能的。
- en: An OpenCV image is a 2D or 3D array of the `.array` type. An 8-bit grayscale
    image is a 2D array containing byte values. A 24-bit BGR image is a 3D array,
    which also contains byte values. We may access these values by using an expression,
    such as `image[0, 0]` or `image[0, 0, 0]`. The first index is the pixel's *y*
    coordinate or row, `0` being the top. The second index is the pixel's *x* coordinate
    or column, `0` being the leftmost. The third index (if applicable) represents
    a color channel.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 图像是一个 `.array` 类型的 2D 或 3D 数组。一个 8 位灰度图像是一个包含字节的 2D 数组。一个 24 位 BGR 图像是一个
    3D 数组，它也包含字节值。我们可以通过使用表达式来访问这些值，例如 `image[0, 0]` 或 `image[0, 0, 0]`。第一个索引是像素的
    *y* 坐标或行，`0` 表示顶部。第二个索引是像素的 *x* 坐标或列，`0` 表示最左边。如果适用，第三个索引代表一个颜色通道。
- en: For example, in an 8-bit grayscale image with a white pixel in the upper-left
    corner, `image[0, 0]` is `255`. For a 24-bit BGR image with a blue pixel in the
    upper-left corner, `image[0, 0]` is `[255, 0, 0]`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个 8 位灰度图像中，如果左上角有一个白色像素，`image[0, 0]` 是 `255`。对于一个 24 位 BGR 图像，如果左上角有一个蓝色像素，`image[0,
    0]` 是 `[255, 0, 0]`。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an alternative to using an expression, such as `image[0, 0]` or `image[0,
    0] = 128`, we may use an expression, such as `image.item((0, 0))` or `image.setitem((0,
    0), 128)`. The latter expressions are more efficient for single-pixel operations.
    However, as we will see in subsequent chapters, we usually want to perform operations
    on large slices of an image rather than on single pixels.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用表达式（如 `image[0, 0]` 或 `image[0, 0] = 128`）的替代，我们可以使用表达式，如 `image.item((0,
    0))` 或 `image.setitem((0, 0), 128)`。后者的表达式对于单像素操作更有效率。然而，正如我们将在后续章节中看到的，我们通常希望对图像的大块区域进行操作，而不是单个像素。
- en: 'Provided that an image has 8 bits per channel, we can cast it to a standard
    Python `bytearray`, which is one-dimensional:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设图像每个通道有 8 位，我们可以将其转换为标准的 Python `bytearray`，它是一维的：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Conversely, provided that `bytearray` contains bytes in an appropriate order,
    we can cast and then reshape it to get a `numpy.array` type that is an image:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果 `bytearray` 中的字节顺序适当，我们可以将其转换并重塑为 `numpy.array` 类型，得到一个图像：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As a more complete example, let''s convert `bytearray`, which contains random
    bytes to a grayscale image and a BGR image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更完整的示例，让我们将包含随机字节的 `bytearray` 转换为灰度图像和BGR图像：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After running this script, we should have a pair of randomly generated images,
    `RandomGray.png` and `RandomColor.png`, in the script's directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后，我们应该在脚本目录中有一对随机生成的图像，`RandomGray.png` 和 `RandomColor.png`。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we use Python's standard `os.urandom()` function to generate random raw
    bytes, which we will then convert to a NumPy array. Note that it is also possible
    to generate a random NumPy array directly (and more efficiently) using a statement,
    such as `numpy.random.randint(0, 256, 120000).reshape(300, 400)`. The only reason
    we use `os.urandom()` is to help demonstrate a conversion from raw bytes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 Python 的标准 `os.urandom()` 函数生成随机原始字节，然后将其转换为 NumPy 数组。请注意，也可以直接（并且更高效地）使用语句生成随机
    NumPy 数组，例如 `numpy.random.randint(0, 256, 120000).reshape(300, 400)`。我们使用 `os.urandom()`
    的唯一原因是为了帮助演示从原始字节到转换的过程。
- en: Accessing image data with numpy.array
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 numpy.array 访问图像数据
- en: Now that you have a better understanding of how an image is formed, we can start
    performing basic operations on it. We know that the easiest (and most common)
    way to load an image in OpenCV is to use the `imread` function. We also know that
    this will return an image, which is really an array (either a 2D or 3D one, depending
    on the parameters you passed to `imread()`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更好地理解了图像的形成方式，我们可以开始对其进行基本操作。我们知道，在 OpenCV 中加载图像最简单（也是最常见）的方法是使用 `imread`
    函数。我们也知道这将返回一个图像，实际上是一个数组（二维或三维，取决于你传递给 `imread()` 的参数）。
- en: 'The `y.array` structure is well optimized for array operations, and it allows
    certain kinds of bulk manipulations that are not available in a plain Python list.
    These kinds of `.array` type-specific operations come in handy for image manipulations
    in OpenCV. Let''s explore image manipulations from the start and step by step
    though, with a basic example: say you want to manipulate a pixel at the coordinates,
    (0, 0), of a BGR image and turn it into a white pixel.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`y.array` 结构针对数组操作进行了很好的优化，并允许进行某些在普通 Python 列表中不可用的批量操作。这类 `.array` 类型特定的操作在
    OpenCV 中的图像处理中非常有用。让我们从最基本的例子开始，逐步探索图像处理：假设你想操作 BGR 图像中坐标为 (0, 0) 的像素，并将其转换为白色像素。'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you then showed the image with a standard `imshow()` call, you will see a
    white dot in the top-left corner of the image. Naturally, this isn't very useful,
    but it shows what can be accomplished. Let's now leverage the ability of `numpy.array`
    to operate transformations to an array much faster than a plain Python array.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用标准的 `imshow()` 调用显示图像，你将在图像的左上角看到一个白色点。当然，这并不很有用，但它展示了可以完成的事情。现在让我们利用 `numpy.array`
    的能力，以比普通 Python 数组快得多的速度对数组进行转换操作。
- en: 'Let''s say that you want to change the blue value of a particular pixel, for
    example, the pixel at coordinates, (150, 120). The `numpy.array` type provides
    a very handy method, `item()`, which takes three parameters: the x (or left) position,
    y (or top), and the index within the array at (x, y) position (remember that in
    a BGR image, the data at a certain position is a three-element array containing
    the B, G, and R values in this order) and returns the value at the index position.
    Another `itemset()` method sets the value of a particular channel of a particular
    pixel to a specified value (`itemset()` takes two arguments: a three-element tuple
    (x, y, and index) and the new value).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要改变特定像素的蓝色值，例如，坐标为（150，120）的像素。`numpy.array`类型提供了一个非常方便的方法，`item()`，它接受三个参数：x（或左）位置、y（或顶）以及数组中（x，y）位置的索引（记住，在BGR图像中，某个位置的数是一个包含B、G和R值的三个元素的数组，顺序如下）并返回索引位置的值。另一个`itemset()`方法将特定像素的特定通道的值设置为指定的值（`itemset()`接受两个参数：一个包含三个元素（x、y和索引）的元组以及新值）。
- en: 'In this example, we will change the value of blue at (150, 120) from its current
    value (127) to an arbitrary 255:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将（150，120）处的蓝色值从其当前值（127）更改为任意值255：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Remember that we do this with `numpy.array` for two reasons: `numpy.array`
    is an extremely optimized library for these kind of operations, and because we
    obtain more readable code through NumPy''s elegant methods rather than the raw
    index access of the first example.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们使用`numpy.array`做这件事有两个原因：`numpy.array`是一个针对这类操作进行了高度优化的库，而且我们通过NumPy优雅的方法而不是第一个示例中的原始索引访问获得了更易读的代码。
- en: This particular code doesn't do much in itself, but it does open a world of
    possibilities. It is, however, advisable that you utilize built-in filters and
    methods to manipulate an entire image; the above approach is only suitable for
    small regions of interest.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段特定的代码本身并没有做什么，但它开启了一个可能性的世界。然而，建议你使用内置的过滤器和方法来操作整个图像；上述方法仅适用于小区域。
- en: Now, let's take a look at a very common operation, namely, manipulating channels.
    Sometimes, you'll want to zero-out all the values of a particular channel (B,
    G, or R).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个非常常见的操作，即操作通道。有时，你可能想要将特定通道（B、G或R）的所有值置零。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Using loops to manipulate the Python arrays is very costly in terms of runtime
    and should be avoided at all costs. Using array indexing allows for efficient
    manipulation of pixels. This is a costly and slow operation, especially if you
    manipulate videos, you''ll find yourself with a jittery output. Then a feature
    called indexing comes to the rescue. Setting all G (green) values of an image
    to `0` is as simple as using this code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环来操作Python数组在运行时间上非常昂贵，应该尽量避免。使用数组索引允许高效地操作像素。这是一个昂贵且缓慢的操作，特别是如果你在操作视频时，你会发现输出会有抖动。然后，一个名为索引的功能就派上用场了。将图像中所有G（绿色）值设置为`0`就像使用以下代码一样简单：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a fairly impressive piece of code and easy to understand. The relevant
    line is the last one, which basically instructs the program to take all pixels
    from all rows and columns and set the resulting value at index one of the three-element
    array, representing the color of the pixel to `0`. If you display this image,
    you will notice a complete absence of green.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当令人印象深刻且易于理解的代码。相关行是最后一行，它基本上指示程序从所有行和列中获取所有像素，并将结果值的三元素数组的索引一设置为`0`。如果你显示这张图片，你会注意到绿色完全消失。
- en: 'There are a number of interesting things we can do by accessing raw pixels
    with NumPy''s array indexing; one of them is defining **regions of interests**
    (**ROI**). Once the region is defined, we can perform a number of operations,
    namely, binding this region to a variable, and then even defining a second region
    and assigning it the value of the first one (visually copying a portion of the
    image over to another position in the image):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用NumPy的数组索引访问原始像素，我们可以做许多有趣的事情；其中之一是定义**感兴趣区域**（**ROI**）。一旦定义了区域，我们可以执行一系列操作，例如，将此区域绑定到一个变量上，然后甚至定义第二个区域并将第一个区域的值赋给它（在图像中将一部分图像复制到另一个位置）：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It's important to make sure that the two regions correspond in terms of size.
    If not, NumPy will (rightly) complain that the two shapes mismatch.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 确保两个区域在大小上是一致的非常重要。如果不是，NumPy会（正确地）抱怨两个形状不匹配。
- en: 'Finally, there are a few interesting details we can obtain from `numpy.array`,
    such as the image properties using this code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从`numpy.array`中获得一些有趣的细节，例如使用此代码获取图像属性：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These three properties are in this order:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个属性按此顺序排列：
- en: '**Shape**: NumPy returns a tuple containing the width, height, and—if the image
    is in color—the number of channels. This is useful to debug a type of image; if
    the image is monochromatic or grayscale, it will not contain a channel''s value.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状**：NumPy返回一个包含宽度、高度以及如果图像是彩色的则包含通道数的元组。这对于调试图像类型很有用；如果图像是单色或灰度，则不会包含通道值。'
- en: '**Size**: This property refers to the size of an image in pixels.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：此属性指图像的像素大小。'
- en: '**Datatype**: This property refers to the datatype used for an image (normally
    a variation of an unsigned integer type and the bits supported by this type, that
    is, `uint8`).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型**：此属性指用于图像的数据类型（通常是未签名的整数类型及其支持的字节数，即`uint8`）。'
- en: All in all, it is strongly advisable that you familiarize yourself with NumPy
    in general and `numpy.array` in particular when working with OpenCV, as it is
    the foundation of an image processing done with Python.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，强烈建议您在处理OpenCV时熟悉NumPy，特别是`numpy.array`，因为它是使用Python进行图像处理的基础。
- en: Reading/writing a video file
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取/写入视频文件
- en: OpenCV provides the `VideoCapture` and `VideoWriter` classes that support various
    video file formats. The supported formats vary by system but should always include
    an AVI. Via its `read()` method, a `VideoCapture` class may be polled for new
    frames until it reaches the end of its video file. Each frame is an image in a
    BGR format.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了`VideoCapture`和`VideoWriter`类，支持各种视频文件格式。支持的格式因系统而异，但应始终包括AVI。通过其`read()`方法，`VideoCapture`类可以轮询新帧，直到达到视频文件的末尾。每个帧都是以BGR格式的图像。
- en: 'Conversely, an image may be passed to the `write()` method of the `VideoWriter`
    class, which appends the image to a file in `VideoWriter`. Let''s look at an example
    that reads frames from one AVI file and writes them to another with a YUV encoding:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，可以将图像传递给`VideoWriter`类的`write()`方法，该方法将图像追加到`VideoWriter`中的文件。让我们看看一个例子，从AVI文件中读取帧并使用YUV编码写入另一个文件：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The arguments to the `VideoWriter` class constructor deserve special attention.
    A video''s filename must be specified. Any preexisting file with this name is
    overwritten. A video codec must also be specified. The available codecs may vary
    from system to system. These are the options that are included:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoWriter`类构造函数的参数值得特别注意。必须指定视频的文件名。任何具有此名称的现有文件都将被覆盖。还必须指定视频编解码器。可用的编解码器可能因系统而异。以下是一些选项：'
- en: '`cv2.VideoWriter_fourcc(''I'',''4'',''2'',''0'')`: This option is an uncompressed
    YUV encoding, 4:2:0 chroma subsampled. This encoding is widely compatible but
    produces large files. The file extension should be `.avi`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.VideoWriter_fourcc(''I'',''4'',''2'',''0'')`：此选项是不压缩的YUV编码，4:2:0色度子采样。这种编码广泛兼容，但生成的文件很大。文件扩展名应为`.avi`。'
- en: '`cv2.VideoWriter_fourcc(''P'',''I'',''M'',''1'')`: This option is MPEG-1\.
    The file extension should be `.avi`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.VideoWriter_fourcc(''P'',''I'',''M'',''1'')`：此选项是MPEG-1。文件扩展名应为`.avi`。'
- en: '`cv2.VideoWriter_fourcc(''X'',''V'',''I'',''D'')`: This option is MPEG-4 and
    a preferred option if you want the resulting video size to be average. The file
    extension should be `.avi`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.VideoWriter_fourcc(''X'',''V'',''I'',''D'')`：此选项是MPEG-4，如果您希望生成的视频大小为平均大小，这是一个首选选项。文件扩展名应为`.avi`。'
- en: '`cv2.VideoWriter_fourcc(''T'',''H'',''E'',''O'')`: This option is Ogg Vorbis.
    The file extension should be `.ogv`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.VideoWriter_fourcc(''T'',''H'',''E'',''O'')`：此选项是Ogg Vorbis。文件扩展名应为`.ogv`。'
- en: '`cv2.VideoWriter_fourcc(''F'',''L'',''V'',''1'')`: This option is a Flash video.
    The file extension should be `.flv`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.VideoWriter_fourcc(''F'',''L'',''V'',''1'')`：此选项是Flash视频。文件扩展名应为`.flv`。'
- en: A frame rate and frame size must be specified too. Since we are copying video
    frames from another video, these properties can be read from the `get()` method
    of the `VideoCapture` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指定帧率和帧大小。由于我们是从另一个视频复制视频帧，这些属性可以从`VideoCapture`类的`get()`方法中读取。
- en: Capturing camera frames
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获相机帧
- en: 'A stream of camera frames is represented by the `VideoCapture` class too. However,
    for a camera, we construct a `VideoCapture` class by passing the camera''s device
    index instead of a video''s filename. Let''s consider an example that captures
    10 seconds of video from a camera and writes it to an AVI file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相机帧流也由`VideoCapture`类表示。然而，对于相机，我们通过传递相机的设备索引而不是视频的文件名来构建一个`VideoCapture`类。让我们考虑一个例子，从相机捕获10秒的视频并将其写入AVI文件：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unfortunately, the `get()` method of a `VideoCapture` class does not return
    an accurate value for the camera''s frame rate; it always returns `0`. The official
    documentation at [http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html](http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html)
    reads:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，`VideoCapture` 类的 `get()` 方法并不能返回相机帧率的准确值；它总是返回 `0`。在官方文档[http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html](http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html)中写道：
- en: '*"When querying a property that is not supported by the backend used by the
    `VideoCapture` class, value `0` is returned."*'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"当查询 `VideoCapture` 类后端不支持的一个属性时，返回值 `0`。"*'
- en: This occurs most commonly on systems where the driver only supports basic functionalities.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常发生在只支持基本功能的驱动程序的系统上。
- en: For the purpose of creating an appropriate `VideoWriter` class for the camera,
    we have to either make an assumption about the frame rate (as we did in the code
    previously) or measure it using a timer. The latter approach is better and we
    will cover it later in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为相机创建一个合适的 `VideoWriter` 类，我们不得不要么对帧率做出假设（就像我们在之前的代码中所做的那样），要么使用计时器来测量它。后者方法更好，我们将在本章后面讨论。
- en: The number of cameras and their order is of course system-dependent. Unfortunately,
    OpenCV does not provide any means of querying the number of cameras or their properties.
    If an invalid index is used to construct a `VideoCapture` class, the `VideoCapture`
    class will not yield any frames; its `read()` method will return `(false, None)`.
    A good way to prevent it from trying to retrieve frames from `VideoCapture` that
    were not opened correctly is to use the `VideoCapture.isOpened` method, which
    returns a Boolean.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的数量及其顺序当然是系统相关的。不幸的是，OpenCV 并没有提供查询相机数量或其属性的方法。如果使用无效的索引来构造 `VideoCapture`
    类，该类将不会输出任何帧；其 `read()` 方法将返回 `(false, None)`。为了避免尝试从未正确打开的 `VideoCapture` 中检索帧，一个很好的方法是使用
    `VideoCapture.isOpened` 方法，它返回一个布尔值。
- en: 'The `read()` method is inappropriate when we need to synchronize a set of cameras
    or a multihead camera (such as a stereo camera or Kinect). Then, we use the `grab()`
    and `retrieve()` methods instead. For a set of cameras, we use this code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要同步一组相机或多头相机（如立体相机或 Kinect）时，`read()` 方法是不合适的。这时，我们使用 `grab()` 和 `retrieve()`
    方法代替。对于一组相机，我们使用以下代码：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Displaying images in a window
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在窗口中显示图像
- en: 'One of the most basic operations in OpenCV is displaying an image. This can
    be done with the `imshow()` function. If you come from any other GUI framework
    background, you would think it sufficient to call `imshow()` to display an image.
    This is only partially true: the image will be displayed, and will disappear immediately.
    This is by design, to enable the constant refreshing of a window frame when working
    with videos. Here''s a very simple example code to display an image:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 中最基本的一个操作就是显示图像。这可以通过 `imshow()` 函数实现。如果你来自任何其他 GUI 框架的背景，你可能会认为调用 `imshow()`
    来显示图像就足够了。这仅部分正确：图像会被显示，然后立即消失。这是设计上的考虑，以便在处理视频时能够不断刷新窗口框架。以下是一个显示图像的非常简单的示例代码：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `imshow()` function takes two parameters: the name of the frame in which
    we want to display the image, and the image itself. We''ll talk about `waitKey()`
    in more detail when we explore the displaying of frames in a window.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`imshow()` 函数接受两个参数：我们想要在其中显示图像的窗口名称，以及图像本身。当我们探讨在窗口中显示帧时，我们将更详细地讨论 `waitKey()`。'
- en: The aptly named `destroyAllWindows()` function disposes of all the windows created
    by OpenCV.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `destroyAllWindows()` 的函数会销毁 OpenCV 创建的所有窗口。
- en: Displaying camera frames in a window
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在窗口中显示相机帧
- en: 'OpenCV allows named windows to be created, redrawn, and destroyed using the
    `namedWindow()`, `imshow()`, and `destroyWindow()` functions. Also, any window
    may capture keyboard input via the `waitKey()` function and mouse input via the
    `setMouseCallback()` function. Let''s look at an example where we show the frames
    of a live camera input:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 允许使用 `namedWindow()`、`imshow()` 和 `destroyWindow()` 函数创建、重绘和销毁命名窗口。此外，任何窗口都可以通过
    `waitKey()` 函数捕获键盘输入，通过 `setMouseCallback()` 函数捕获鼠标输入。让我们看看一个示例，其中我们展示了实时相机输入的帧：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The argument for `waitKey()` is a number of milliseconds to wait for keyboard
    input. The return value is either `-1` (meaning that no key has been pressed)
    or an ASCII keycode, such as `27` for *Esc*. For a list of ASCII keycodes, see
    [http://www.asciitable.com/](http://www.asciitable.com/). Also, note that Python
    provides a standard function, `ord()`, which can convert a character to its ASCII
    keycode. For example, `ord('a')` returns `97`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitKey()` 的参数是等待键盘输入的毫秒数。返回值是 `-1`（表示没有按键被按下）或一个 ASCII 键码，例如 `27` 对应于 *Esc*。有关
    ASCII 键码的列表，请参阅 [http://www.asciitable.com/](http://www.asciitable.com/)。此外，请注意，Python
    提供了一个标准函数 `ord()`，可以将字符转换为它的 ASCII 键码。例如，`ord(''a'')` 返回 `97`。'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'On some systems, `waitKey()` may return a value that encodes more than just
    the ASCII keycode. (A bug is known to occur on Linux when OpenCV uses GTK as its
    backend GUI library.) On all systems, we can ensure that we extract just the ASCII
    keycode by reading the last byte from the return value like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统上，`waitKey()` 可能返回一个编码了不仅仅是 ASCII 键码的值。（已知当 OpenCV 使用 GTK 作为其后端 GUI 库时，Linux
    上会发生一个错误。）在所有系统上，我们可以确保通过从返回值中读取最后一个字节来仅提取 ASCII 键码，如下所示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: OpenCV's window functions and `waitKey()` are interdependent. OpenCV windows
    are only updated when `waitKey()` is called, and `waitKey()` only captures input
    when an OpenCV window has focus.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 的窗口函数和 `waitKey()` 是相互依赖的。只有当调用 `waitKey()` 时，OpenCV 窗口才会更新，并且只有当 OpenCV
    窗口获得焦点时，`waitKey()` 才会捕获输入。
- en: 'The mouse callback passed to `setMouseCallback()` should take five arguments,
    as seen in our code sample. The callback''s `param` argument is set as an optional
    third argument to `setMouseCallback()`. By default, it is `0`. The callback''s
    event argument is one of the following actions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `setMouseCallback()` 的鼠标回调应接受五个参数，如我们的代码示例所示。回调的 `param` 参数被设置为 `setMouseCallback()`
    的可选第三个参数。默认情况下，它是 `0`。回调的事件参数是以下动作之一：
- en: '`cv2.EVENT_MOUSEMOVE`: This event refers to mouse movement'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_MOUSEMOVE`: 此事件表示鼠标移动'
- en: '`cv2.EVENT_LBUTTONDOWN`: This event refers to the left button down'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_LBUTTONDOWN`: 此事件表示左键按下'
- en: '`cv2.EVENT_RBUTTONDOWN`: This refers to the right button down'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_RBUTTONDOWN`: 这表示右键按下'
- en: '`cv2.EVENT_MBUTTONDOWN`: This refers to the middle button down'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_MBUTTONDOWN`: 这表示中间按钮按下'
- en: '`cv2.EVENT_LBUTTONUP`: This refers to the left button up'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_LBUTTONUP`: 这表示左键释放'
- en: '`cv2.EVENT_RBUTTONUP`: This event refers to the right button up'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_RBUTTONUP`: 此事件表示右键释放'
- en: '`cv2.EVENT_MBUTTONUP`: This event refers to the middle button up'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_MBUTTONUP`: 此事件表示中间按钮释放'
- en: '`cv2.EVENT_LBUTTONDBLCLK`: This event refers to the left button being double-clicked'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_LBUTTONDBLCLK`: 此事件表示左键被双击'
- en: '`cv2.EVENT_RBUTTONDBLCLK`: This refers to the right button being double-clicked'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_RBUTTONDBLCLK`: 这表示右键被双击'
- en: '`cv2.EVENT_MBUTTONDBLCLK`: This refers to the middle button being double-clicked'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_MBUTTONDBLCLK`: 这表示中间按钮被双击'
- en: 'The mouse callback''s flags argument may be some bitwise combination of the
    following events:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标回调的标志参数可能是以下事件的位运算组合：
- en: '`cv2.EVENT_FLAG_LBUTTON`: This event refers to the left button being pressed'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_FLAG_LBUTTON`: 此事件表示左键被按下'
- en: '`cv2.EVENT_FLAG_RBUTTON`: This event refers to the right button being pressed'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_FLAG_RBUTTON`: 此事件表示右键被按下'
- en: '`cv2.EVENT_FLAG_MBUTTON`: This event refers to the middle button being pressed'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_FLAG_MBUTTON`: 此事件表示中间按钮被按下'
- en: '`cv2.EVENT_FLAG_CTRLKEY`: This event refers to the *Ctrl* key being pressed'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_FLAG_CTRLKEY`: 此事件表示按下 *Ctrl* 键'
- en: '`cv2.EVENT_FLAG_SHIFTKEY`: This event refers to the *Shift* key being pressed'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_FLAG_SHIFTKEY`: 此事件表示按下 *Shift* 键'
- en: '`cv2.EVENT_FLAG_ALTKEY`: This event refers to the *Alt* key being pressed'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.EVENT_FLAG_ALTKEY`: 此事件表示按下 *Alt* 键'
- en: Unfortunately, OpenCV does not provide any means of handling window events.
    For example, we cannot stop our application when a window's close button is clicked.
    Due to OpenCV's limited event handling and GUI capabilities, many developers prefer
    to integrate it with other application frameworks. Later in this chapter, we will
    design an abstraction layer to help integrate OpenCV into any application framework.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，OpenCV 不提供处理窗口事件的方法。例如，当窗口的关闭按钮被点击时，我们无法停止我们的应用程序。由于 OpenCV 有限的的事件处理和 GUI
    功能，许多开发者更喜欢将其与其他应用程序框架集成。在本章的后面部分，我们将设计一个抽象层，以帮助将 OpenCV 集成到任何应用程序框架中。
- en: Project Cameo (face tracking and image manipulation)
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Cameo（人脸追踪和图像处理）
- en: 'OpenCV is often studied through a cookbook approach that covers a lot of algorithms
    but nothing about high-level application development. To an extent, this approach
    is understandable because OpenCV''s potential applications are so diverse. OpenCV
    is used in a wide variety of applications: photo/video editors, motion-controlled
    games, a robot''s AI, or psychology experiments where we log participants'' eye
    movements. Across such different use cases, can we truly study a useful set of
    abstractions?'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV通常通过一种类似于食谱的方法来研究，它涵盖了大量的算法，但没有关于高级应用程序开发的内容。在一定程度上，这种方法是可以理解的，因为OpenCV的潜在应用非常多样。OpenCV被用于广泛的领域：照片/视频编辑器、动作控制游戏、机器人的AI，或者记录参与者眼动行为的心理学实验。在如此不同的用例中，我们真的能够研究出一套有用的抽象吗？
- en: I believe we can and the sooner we start creating abstractions, the better.
    We will structure our study of OpenCV around a single application, but, at each
    step, we will design a component of this application to be extensible and reusable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我们可以，而且越早开始创建抽象，越好。我们将围绕单个应用程序来结构化我们对OpenCV的研究，但在每个步骤中，我们将设计这个应用程序的一个组件，使其可扩展和可重用。
- en: We will develop an interactive application that performs face tracking and image
    manipulations on camera input in real time. This type of application covers a
    broad range of OpenCV's functionality and challenges us to create an efficient,
    effective implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个交互式应用程序，该应用程序在实时摄像头输入上执行面部跟踪和图像操作。这类应用程序涵盖了OpenCV的广泛功能，并挑战我们创建一个高效、有效的实现。
- en: Specifically, our application will perform real-time facial merging. Given two
    streams of camera input (or, optionally, prerecorded video input), the application
    will superimpose faces from one stream onto faces in the other. Filters and distortions
    will be applied to give this blended scene a unified look and feel. Users should
    have the experience of being engaged in a live performance where they enter another
    environment and persona. This type of user experience is popular in amusement
    parks such as Disneyland.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们的应用程序将执行实时面部融合。给定两个摄像头输入流（或者，可选地，预先录制的视频输入），应用程序将把一个流中的面部叠加到另一个流中的面部上。将应用滤镜和扭曲，使这个混合场景看起来和感觉上统一。用户应该体验到参与现场表演的感觉，进入另一个环境和角色。这种用户体验在像迪士尼乐园这样的游乐园中很受欢迎。
- en: In such an application, users would immediately notice flaws, such as a low
    frame rate or inaccurate tracking. To get the best results, we will try several
    approaches using conventional imaging and depth imaging.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的应用程序中，用户会立即注意到缺陷，例如帧率低或跟踪不准确。为了获得最佳结果，我们将尝试使用传统成像和深度成像的几种方法。
- en: We will call our application Cameo. A cameo is (in jewelry) a small portrait
    of a person or (in film) a very brief role played by a celebrity.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的应用程序命名为Cameo。在珠宝中，Cameo是指一个人的小肖像，或者在电影中是指名人扮演的非常短暂的角色。
- en: Cameo – an object-oriented design
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cameo – 面向对象设计
- en: Python applications can be written in a purely procedural style. This is often
    done with small applications, such as our basic I/O scripts, discussed previously.
    However, from now on, we will use an object-oriented style because it promotes
    modularity and extensibility.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Python应用程序可以编写为纯过程式风格。这通常用于小型应用程序，例如我们之前讨论的基本I/O脚本。然而，从现在开始，我们将使用面向对象风格，因为它促进了模块化和可扩展性。
- en: From our overview of OpenCV's I/O functionality, we know that all images are
    similar, regardless of their source or destination. No matter how we obtain a
    stream of images or where we send it as output, we can apply the same application-specific
    logic to each frame in this stream. Separation of I/O code and application code
    becomes especially convenient in an application, such as Cameo, which uses multiple
    I/O streams.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们对OpenCV I/O功能的概述中，我们知道所有图像都是相似的，无论它们的来源或目的地。无论我们如何获取图像流或将其发送到何处作为输出，我们都可以将相同的应用特定逻辑应用于这个流中的每一帧。在像Cameo这样的应用程序中，分离I/O代码和应用代码变得特别方便，因为它使用多个I/O流。
- en: We will create classes called `CaptureManager` and `WindowManager` as high-level
    interfaces to I/O streams. Our application code may use `CaptureManager` to read
    new frames and, optionally, to dispatch each frame to one or more outputs, including
    a still image file, a video file, and a window (via a `WindowManager` class).
    A `WindowManager` class lets our application code handle a window and events in
    an object-oriented style.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建名为`CaptureManager`和`WindowManager`的类，作为I/O流的高级接口。我们的应用程序代码可以使用`CaptureManager`读取新帧，并且可选地将每个帧派发到一个或多个输出，包括静态图像文件、视频文件和窗口（通过`WindowManager`类）。`WindowManager`类允许我们的应用程序代码以面向对象的方式处理窗口和事件。
- en: Both `CaptureManager` and `WindowManager` are extensible. We could make implementations
    that do not rely on OpenCV for I/O. Indeed, *Appendix A*, *Integrating with Pygame*,
    *OpenCV Computer Vision with Python*, uses a `WindowManager` subclass.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`CaptureManager`和`WindowManager`都是可扩展的。我们可以实现不依赖于OpenCV进行I/O的版本。实际上，*附录A*，*与Pygame集成*，*使用Python的OpenCV计算机视觉*，使用了一个`WindowManager`子类。'
- en: Abstracting a video stream with managers.CaptureManager
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CaptureManager从管理器中抽象视频流。
- en: As we have seen, OpenCV can capture, show, and record a stream of images from
    either a video file or a camera, but there are some special considerations in
    each case. Our `CaptureManager` class abstracts some of the differences and provides
    a higher-level interface to dispatch images from the capture stream to one or
    more outputs—a still image file, video file, or a window.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，OpenCV可以从视频文件或摄像头捕获、显示和记录一系列图像，但在每种情况下都有一些特殊考虑。我们的`CaptureManager`类抽象了一些差异，并提供了一个更高级别的接口，将捕获流中的图像派发到一个或多个输出——静态图像文件、视频文件或窗口。
- en: A `CaptureManager` class is initialized with a `VideoCapture` class and has
    the `enterFrame()` and `exitFrame()` methods that should typically be called on
    every iteration of an application's main loop. Between a call to `enterFrame()`
    and `exitFrame()`, the application may (any number of times) set a `channel` property
    and get a `frame` property. The `channel` property is initially `0` and only multihead
    cameras use other values. The `frame` property is an image corresponding to the
    current channel's state when `enterFrame()` was called.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`CaptureManager`类使用`VideoCapture`类初始化，并具有`enterFrame()`和`exitFrame()`方法，这些方法通常在应用程序主循环的每次迭代中调用。在调用`enterFrame()`和`exitFrame()`之间，应用程序可以（任意次数）设置`channel`属性并获取`frame`属性。`channel`属性最初为`0`，只有多头摄像头使用其他值。`frame`属性是当调用`enterFrame()`时对应当前通道状态的图像。'
- en: A `CaptureManager` class also has the `writeImage()`, `startWritingVideo()`,
    and `stopWritingVideo()` methods that may be called at any time. Actual file writing
    is postponed until `exitFrame()`. Also, during the `exitFrame()` method, the `frame`
    property may be shown in a window, depending on whether the application code provides
    a `WindowManager` class either as an argument to the constructor of `CaptureManager`
    or by setting a `previewWindowManager` property.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`CaptureManager`类还具有`writeImage()`、`startWritingVideo()`和`stopWritingVideo()`方法，这些方法可以在任何时候调用。实际的文件写入将推迟到`exitFrame()`。此外，在`exitFrame()`方法中，`frame`属性可能会在窗口中显示，具体取决于应用程序代码是否提供了一个`WindowManager`类，无论是作为`CaptureManager`构造函数的参数，还是通过设置`previewWindowManager`属性。'
- en: If the application code manipulates `frame`, the manipulations are reflected
    in recorded files and in the window. A `CaptureManager` class has a constructor
    argument and property called `shouldMirrorPreview`, which should be `True` if
    we want `frame` to be mirrored (horizontally flipped) in the window but not in
    recorded files. Typically, when facing a camera, users prefer live camera feed
    to be mirrored.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序代码操作`frame`，则这些操作将反映在记录的文件和窗口中。`CaptureManager`类有一个名为`shouldMirrorPreview`的构造函数参数和属性，如果我们要在窗口中镜像（水平翻转）`frame`但不在记录的文件中，则该参数应为`True`。通常，当面对摄像头时，用户更喜欢镜像的实时摄像头流。
- en: Recall that a `VideoWriter` class needs a frame rate, but OpenCV does not provide
    any way to get an accurate frame rate for a camera. The `CaptureManager` class
    works around this limitation by using a frame counter and Python's standard `time.time()`
    function to estimate the frame rate if necessary. This approach is not foolproof.
    Depending on frame rate fluctuations and the system-dependent implementation of
    `time.time()`, the accuracy of the estimate might still be poor in some cases.
    However, if we deploy to unknown hardware, it is better than just assuming that
    the user's camera has a particular frame rate.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`VideoWriter`类需要一个帧率，但OpenCV并没有提供任何方法来获取摄像头的准确帧率。`CaptureManager`类通过使用帧计数器和Python的标准`time.time()`函数来估计帧率来绕过这个限制。这种方法并不是万无一失的。根据帧率波动和系统依赖的`time.time()`实现，在某些情况下，估计的准确性可能仍然很差。然而，如果我们部署到未知的硬件上，这比仅仅假设用户的摄像头具有特定的帧率要好。
- en: 'Let''s create a file called `managers.py`, which will contain our implementation
    of `CaptureManager`. The implementation turns out to be quite long. So, we will
    look at it in several pieces. First, let''s add imports, a constructor, and properties,
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`managers.py`的文件，该文件将包含我们的`CaptureManager`实现。这个实现相当长。因此，我们将分几个部分来看它。首先，让我们添加导入、构造函数和属性，如下所示：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that most of the `member` variables are non-public, as denoted by the
    underscore prefix in variable names, such as `self._enteredFrame`. These nonpublic
    variables relate to the state of the current frame and any file-writing operations.
    As discussed previously, the application code only needs to configure a few things,
    which are implemented as constructor arguments and settable public properties:
    the camera channel, window manager, and the option to mirror the camera preview.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大多数的`member`变量都是非公开的，这可以通过变量名前的下划线前缀来表示，例如`self._enteredFrame`。这些非公开变量与当前帧的状态以及任何文件写入操作相关。正如之前讨论的，应用程序代码只需要配置一些事情，这些事情作为构造函数参数和可设置的公共属性来实现：摄像头通道、窗口管理器以及是否镜像摄像头预览的选项。
- en: This book assumes a certain level of familiarity with Python; however, if you
    are getting confused by those `@` annotations (for example, `@property`), refer
    to the Python documentation about `decorators`, a built-in feature of the language
    that allows the wrapping of a function by another function, normally used to apply
    a user-defined behavior in several places of an application (refer to [https://docs.python.org/2/reference/compound_stmts.html#grammar-token-decorator](https://docs.python.org/2/reference/compound_stmts.html#grammar-token-decorator)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设读者对Python有一定程度的熟悉；然而，如果你对那些`@`注解（例如，`@property`）感到困惑，请参考Python文档中关于`decorators`的部分，这是语言的一个内置特性，允许一个函数被另一个函数包装，通常用于在应用程序的多个地方应用用户定义的行为（参考[https://docs.python.org/2/reference/compound_stmts.html#grammar-token-decorator](https://docs.python.org/2/reference/compound_stmts.html#grammar-token-decorator))）。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python does not have the concept of private member variables and the single/double
    underscore prefix (`_`) is only a convention.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有私有成员变量的概念，单下划线前缀（`_`）只是一个约定。
- en: By this convention, in Python, variables that are prefixed with a single underscore
    should be treated as protected (accessed only within the class and its subclasses),
    while variables that are prefixed with a double underscore should be treated as
    private (accessed only within the class).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个约定，在Python中，以单个下划线为前缀的变量应被视为受保护的（只能在类及其子类中访问），而以双下划线为前缀的变量应被视为私有的（只能在类内部访问）。
- en: 'Continuing with our implementation, let''s add the `enterFrame()` and `exitFrame()`
    methods to `managers.py`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的实现，让我们将`enterFrame()`和`exitFrame()`方法添加到`managers.py`中：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the implementation of `enterFrame()` only grabs (synchronizes) a frame,
    whereas actual retrieval from a channel is postponed to a subsequent reading of
    the `frame` variable. The implementation of `exitFrame()` takes the image from
    the current channel, estimates a frame rate, shows the image via the window manager
    (if any), and fulfills any pending requests to write the image to files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`enterFrame()`的实现只是获取（同步）一个帧，而实际从通道检索则推迟到后续读取`frame`变量。`exitFrame()`的实现从当前通道获取图像，估算帧率，通过窗口管理器（如果有）显示图像，并满足任何待处理的将图像写入文件的请求。
- en: 'Several other methods also pertain to file writing. To finish our class implementation,
    let''s add the remaining file-writing methods to `managers.py`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其他几个方法也与文件写入有关。为了完成我们的类实现，让我们将剩余的文件写入方法添加到`managers.py`中：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `writeImage()`, `startWritingVideo()`, and `stopWritingVideo()` public methods
    simply record the parameters for file-writing operations, whereas the actual writing
    operations are postponed to the next call of `exitFrame()`. The `_writeVideoFrame()`
    nonpublic method creates or appends a video file in a manner that should be familiar
    from our earlier scripts. (See the *Reading/writing a video file* section.) However,
    in situations where the frame rate is unknown, we skip some frames at the start
    of the capture session so that we have time to build up an estimate of the frame
    rate.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeImage()`、`startWritingVideo()`和`stopWritingVideo()`公共方法只是记录文件写入操作的参数，而实际的写入操作则推迟到`exitFrame()`的下一次调用。非公共方法`_writeVideoFrame()`以我们早期脚本中熟悉的方式创建或追加视频文件。（见*读取/写入视频文件*部分。）然而，在帧率未知的情况下，我们在捕获会话的开始处跳过一些帧，以便我们有时间建立对帧率的估计。'
- en: Although our current implementation of `CaptureManager` relies on `VideoCapture`,
    we could make other implementations that do not use OpenCV for input. For example,
    we could make a subclass that is instantiated with a socket connection, whose
    byte stream could be parsed as a stream of images. We could also make a subclass
    that uses a third-party camera library with different hardware support than what
    OpenCV provides. However, for Cameo, our current implementation is sufficient.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们当前的`CaptureManager`实现依赖于`VideoCapture`，但我们可以实现不使用OpenCV作为输入的其他实现。例如，我们可以创建一个子类，它通过套接字连接实例化，其字节流可以解析为图像流。我们还可以创建一个使用第三方相机库的子类，该库具有与OpenCV提供的不同硬件支持。然而，对于Cameo，我们的当前实现是足够的。
- en: Abstracting a window and keyboard with managers.WindowManager
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`managers.WindowManager`管理窗口和键盘
- en: As we have seen, OpenCV provides functions that cause a window to be created,
    destroyed, show an image, and process events. Rather than being methods of a window
    class, these functions require a window's name to pass as an argument. Since this
    interface is not object-oriented, it is inconsistent with OpenCV's general style.
    Also, it is unlikely to be compatible with other window or event handling interfaces
    that we might eventually want to use instead of OpenCV's.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，OpenCV提供了创建窗口、销毁窗口、显示图像和处理事件的函数。这些函数不是窗口类的成员方法，而是需要将窗口的名称作为参数传递。由于这个接口不是面向对象的，它不符合OpenCV的一般风格。此外，它可能与我们可能最终想要使用的其他窗口或事件处理接口不兼容。
- en: For the sake of object orientation and adaptability, we abstract this functionality
    into a `WindowManager` class with the `createWindow()`, `destroyWindow()`, `show()`,
    and `processEvents()` methods. As a property, a `WindowManager` class has a function
    object called `keypressCallback`, which (if not `None`) is called from `processEvents()`
    in response to any key press. The `keypressCallback` object must take a single
    argument, such as an ASCII keycode.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了面向对象和适应性，我们将此功能抽象成一个具有`createWindow()`、`destroyWindow()`、`show()`和`processEvents()`方法的`WindowManager`类。作为一个属性，`WindowManager`类有一个名为`keypressCallback`的函数对象，该对象（如果非`None`）在`processEvents()`中响应任何按键时被调用。`keypressCallback`对象必须接受一个单一参数，例如ASCII键码。
- en: 'Let''s add the following implementation of `WindowManager` to `managers.py`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`managers.py`中添加以下`WindowManager`的实现：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our current implementation only supports keyboard events, which will be sufficient
    for Cameo. However, we could modify `WindowManager` to support mouse events too.
    For example, the class's interface could be expanded to include a `mouseCallback`
    property (and optional constructor argument), but could otherwise remain the same.
    With some event framework other than OpenCV's, we could support additional event
    types in the same way by adding callback properties.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的实施方案仅支持键盘事件，这对Cameo来说将足够。然而，我们可以修改`WindowManager`以支持鼠标事件。例如，类的接口可以扩展以包括一个`mouseCallback`属性（以及可选的构造函数参数），但其他方面可以保持不变。通过添加回调属性，我们可以使用除OpenCV之外的事件框架以相同的方式支持其他事件类型。
- en: '*Appendix A*, *Integrating with Pygame*, *OpenCV Computer Vision with Python*,
    shows a `WindowManager` subclass that is implemented with Pygame''s window handling
    and event framework instead of OpenCV''s. This implementation improves on the
    base `WindowManager` class by properly handling quit events—for example, when
    a user clicks on a window''s close button. Potentially, many other event types
    can be handled via Pygame too.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*附录A*，*与Pygame集成*，*使用Python的OpenCV计算机视觉*展示了使用Pygame的窗口处理和事件框架实现的`WindowManager`子类，而不是使用OpenCV的。这个实现通过正确处理退出事件（例如，当用户点击窗口的关闭按钮时）改进了基本的`WindowManager`类。潜在地，许多其他事件类型也可以通过Pygame来处理。'
- en: Applying everything with cameo.Cameo
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用所有内容到cameo.Cameo
- en: 'Our application is represented by a `Cameo` class with two methods: `run()`
    and `onKeypress()`. On initialization, a `Cameo` class creates a `WindowManager`
    class with `onKeypress()` as a callback, as well as a `CaptureManager` class using
    a camera and the `WindowManager` class. When `run()` is called, the application
    executes a main loop in which frames and events are processed. As a result of
    event processing, `onKeypress()` may be called. The spacebar causes a screenshot
    to be taken, *Tab* causes a screencast (a video recording) to start/stop, and
    *Esc* causes the application to quit.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序由一个`Cameo`类表示，包含两个方法：`run()`和`onKeypress()`。在初始化时，`Cameo`类创建一个带有`onKeypress()`作为回调的`WindowManager`类，以及使用摄像头和`WindowManager`类的`CaptureManager`类。当调用`run()`时，应用程序执行一个主循环，在该循环中处理帧和事件。由于事件处理的结果，可能会调用`onKeypress()`。空格键会触发截图，*Tab*键会导致屏幕录制（视频录制）开始/停止，而*Esc*键会导致应用程序退出。
- en: 'In the same directory as `managers.py`, let''s create a file called `cameo.py`
    containing the following implementation of `Cameo`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`managers.py`相同的目录下，让我们创建一个名为`cameo.py`的文件，包含以下`Cameo`的实现：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When running the application, note that the live camera feed is mirrored, while
    screenshots and screencasts are not. This is the intended behavior, as we pass
    `True` for `shouldMirrorPreview` when initializing the `CaptureManager` class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行应用程序时，请注意，实时摄像头视频流是镜像的，而截图和屏幕录制则不是。这是预期的行为，因为我们初始化`CaptureManager`类时传递了`True`给`shouldMirrorPreview`。
- en: So far, we do not manipulate the frames in any way except to mirror them for
    preview. We will start to add more interesting effects in [Chapter 3](part0023.xhtml#aid-LTSU1
    "Chapter 3. Processing Images with OpenCV 3"), *Filtering Images*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们除了镜像预览之外，没有以任何方式操作帧。我们将在[第3章](part0023.xhtml#aid-LTSU1 "第3章。使用OpenCV
    3处理图像")，*过滤图像*中开始添加更多有趣的效果。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By now, we should have an application that displays a camera feed, listens for
    keyboard input, and (on command) records a screenshot or screencast. We are ready
    to extend the application by inserting some image-filtering code ([Chapter 3](part0023.xhtml#aid-LTSU1
    "Chapter 3. Processing Images with OpenCV 3"), *Filtering Images*) between the
    start and end of each frame. Optionally, we are also ready to integrate other
    camera drivers or application frameworks (*Appendix A*, *Integrating with Pygame*,
    *OpenCV Computer Vision with Python*) besides the ones supported by OpenCV.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该有一个显示摄像头视频流、监听键盘输入，并且（在命令下）记录截图或屏幕录制的应用程序。我们现在准备通过在每一帧的开始和结束之间插入一些图像过滤代码（[第3章](part0023.xhtml#aid-LTSU1
    "第3章。使用OpenCV 3处理图像")，*过滤图像*）来扩展应用程序。可选地，我们也准备集成其他摄像头驱动程序或应用程序框架（*附录A*，*与Pygame集成*，*使用Python的OpenCV计算机视觉*），除了OpenCV支持的那些。
- en: We also now have the knowledge to process images and understand the principle
    of image manipulation through the NumPy arrays. This forms the perfect foundation
    to understand the next topic, filtering images.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在也拥有了处理图像和理解通过NumPy数组进行图像操作原理的知识。这为理解下一个主题，过滤图像，奠定了完美的基础。
