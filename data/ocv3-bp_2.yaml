- en: Chapter 2. Photographing Nature and Wildlife with an Automated Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 使用自动相机拍摄自然和野生动物
- en: '*National Geographic* is famous for its intimate photos of wild animals. Often,
    in the magazine''s pages, the animals seem larger than life, as if they belong
    to the same "geographic" scale as the landscapes behind them. This enlargement
    effect can be achieved by capturing the subject at a very close distance with
    a wide-angle lens. For example, one memorable photograph by Steve Winter shows
    a snarling tiger reaching out to strike the lens!'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*国家地理*以其野生动物的亲密照片而闻名。在杂志的页面上，动物常常显得比生命还要大，仿佛它们属于与背后的风景相同的“地理”尺度。这种放大效果可以通过使用广角镜头在非常近的距离上捕捉主题来实现。例如，史蒂夫·温特拍摄的一张难忘的照片显示了一只咆哮的老虎伸出爪子去击打镜头！'
- en: Let's consider the possible methods behind such a photo. The photographer could
    try to stalk a wild tiger in person, but for safety, this approach would require
    some distance and a long lens. A close encounter is likely to endanger the human,
    the tiger, or both. Alternatively, the photographer could use a remote-controlled
    rover or drone to approach and photograph the tiger. This would be safer but like
    the first technique it is laborious, only covers one site at a time, and may spoil
    opportunities for candid or natural photos because it attracts the animal's attention.
    Finally, the photographer could deploy concealed and automated cameras, called
    **camera traps**, in multiple locations that the tiger is likely to visit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑实现这种照片的可能方法。摄影师可以亲自跟踪一只野生老虎，但出于安全考虑，这种方法需要一定的距离和长焦镜头。近距离接触可能会危及人类、老虎或两者。或者，摄影师可以使用遥控车或无人机接近并拍摄老虎。这会更安全，但就像第一种技术一样，它很费力，一次只能覆盖一个地点，并且可能会因为吸引动物的注意而破坏即兴或自然照片的机会。最后，摄影师可以在老虎可能访问的多个地点部署隐蔽和自动化的相机，称为**相机陷阱**。
- en: This chapter will explore techniques for programming a camera trap. Maybe we
    will not capture any tigers, but something will wander into our trap!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨编程相机陷阱的技术。也许我们不会捕捉到任何老虎，但总会有东西走进我们的陷阱！
- en: 'Despite the name, a camera trap does not physically "trap" anything. It just
    captures photos when a trigger is tripped. Different camera traps may use different
    triggers but in our case, the trigger will be a computer vision system that is
    sensitive to motion, color, or certain classes of objects. Our system''s software
    components will include OpenCV 3, Python scripts, shell scripts, and a camera
    control tool called gPhoto2\. While building our system, we will address the following
    questions:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字叫“陷阱”，但相机陷阱实际上并没有物理上“捕捉”任何东西。它只是在触发器被触发时捕捉照片。不同的相机陷阱可能使用不同的触发器，但在我们的案例中，触发器将是一个对运动、颜色或某些类别的物体敏感的计算机视觉系统。我们系统的软件组件将包括OpenCV
    3、Python脚本、shell脚本以及一个名为gPhoto2的相机控制工具。在构建我们的系统时，我们将解决以下问题：
- en: How can we configure and trigger a photo camera from a host computer?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何从主机计算机配置和触发照片相机？
- en: How can we detect the presence of a photogenic subject?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何检测具有摄影价值的主题的存在？
- en: How can we capture and process multiple photos of a subject to create an effective
    composite image or video?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何捕捉和处理一个主题的多个照片以创建一个有效的合成图像或视频？
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the scripts and data for this chapter's project can be found in the book's
    GitHub repository at [https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap](https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章项目的所有脚本和数据都可以在本书的GitHub仓库中找到，网址为[https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap](https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap)。
- en: This chapter will focus on techniques for Unix-like systems, including Linux
    and Mac. We assume that users will ultimately deploy our camera trap on low-cost,
    low-powered, single-board computers (SBCs), which will typically run Linux. A
    good example is the Raspberry Pi 2 hardware, which typically runs the Raspbian
    distribution of Linux.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍适用于类Unix系统（包括Linux和Mac）的技术。我们假设用户最终将在低成本、低功耗的单板计算机（SBCs）上部署我们的相机陷阱，这些计算机通常运行Linux操作系统。一个好的例子是Raspberry
    Pi 2硬件，它通常运行Raspbian版本的Linux。
- en: Let's begin with an outline of a few simple tasks that our software will perform
    before, during, and after image capture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的软件在图像捕获之前、期间和之后将执行的一些简单任务概述开始。
- en: Planning the camera trap
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划相机陷阱
- en: Our camera trap will use a computer with two attached cameras. One camera will
    continuously capture low-resolution images. For example, this first camera may
    be an ordinary webcam. Our software will analyze the low-resolution images to
    detect the presence of a subject. We will explore three basic detection techniques
    based on motion, color, and object classification. When a subject is detected,
    the second camera will activate to capture and save a finite series of high-resolution
    images. This second camera will be a dedicated photo camera, with its own battery
    and storage. We will not necessarily analyze and record images at the fastest
    possible rate; rather, we will take care to conserve the host computer's resources
    as well as the photo camera's battery power and storage so that our photo trap
    can function for a long time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一台配备两个摄像头的计算机来设置相机陷阱。一个摄像头将连续捕捉低分辨率图像。例如，这个第一个摄像头可能是一个普通的网络摄像头。我们的软件将分析低分辨率图像以检测主体的存在。我们将探索基于运动、颜色和物体分类的三个基本检测技术。当检测到主体时，第二个摄像头将激活以捕捉和保存一系列有限的高分辨率图像。这个第二个摄像头将是一个专用的数码相机，拥有自己的电池和存储。我们不一定以最快的速度分析和记录图像；相反，我们将注意节约主机计算机的资源以及数码相机的电池功率和存储，以便我们的相机陷阱可以长时间运行。
- en: 'Optionally, our software will configure the photo camera for **exposure bracketing**.
    This means that some photos in a series will be deliberately underexposed while
    others will be overexposed. Later, we will upload photos from the camera to the
    host computer, and merge the exposures to produce **high dynamic range** (**HDR**)
    images. This means that the merged photo will exhibit fine details and saturated
    colors throughout a broader range of shadows, midtones, and highlights than any
    one exposure could capture. For example, the following lineup illustrates underexposure
    (left), overexposure (right), and a merged HDR photo (center):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们的软件将为数码相机配置**曝光分级**。这意味着系列中的一些照片将被故意曝光不足，而其他照片将被过度曝光。稍后，我们将从相机上传照片到主机计算机，并合并曝光以产生**高动态范围**（**HDR**）图像。这意味着合并后的照片将在比任何单一曝光能够捕捉的更广泛的阴影、中色调和高光范围内展示精细的细节和饱和的颜色。例如，以下阵容说明了曝光不足（左侧）、过度曝光（右侧）和合并的HDR照片（中间）：
- en: '![Planning the camera trap](img/00020.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![规划相机陷阱](img/00020.jpeg)'
- en: HDR imaging is especially important in landscape photography. Typically, the
    sky is much brighter than the land, yet we want to tame this contrast in order
    to obtain saturated midtone colors in both these regions, rather than white, featureless
    sky or black, featureless land. We will also explore techniques for turning a
    series of images into a time-lapse video.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HDR成像在风景摄影中尤为重要。通常，天空比地面亮得多，但我们希望驯服这种对比度，以便在这两个区域都获得饱和的中色调颜色，而不是白色的无特征天空或黑色的无特征土地。我们还将探索将一系列图像转换为时间流逝视频的技术。
- en: 'Note that the two cameras in this project fulfill different requirements. The
    webcam provides a stream of images for real-time processing, and the photo camera
    stores images for high-quality processing later. Consider the following comparison
    table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本项目中的两个摄像头满足不同的需求。网络摄像头提供用于实时处理的图像流，而数码相机存储用于后期高质量处理的图像。考虑以下比较表：
- en: '| Feature | Typical webcam | Typical photo camera | High-end industrial camera
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 典型网络摄像头 | 典型数码相机 | 高端工业相机 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Price | Low | Medium | High |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 价格 | 低 | 中等 | 高 |'
- en: '| Power consumption | Low | High (but has its own battery) | Medium |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 功耗 | 低 | 高（但有自己的电池） | 中等 |'
- en: '| Configuration options | Few | Many | Many |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 配置选项 | 少 | 多 | 多 |'
- en: '| Latency | Low | High | Low |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 延迟 | 低 | 高 | 低 |'
- en: '| Resolution | Low | Very high | High |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 分辨率 | 低 | 非常高 | 高 |'
- en: '| Ruggedness | Poor | Good | Fair |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 耐用性 | 差 | 好 | 一般 |'
- en: 'Potentially, a high-end industrial camera could serve both purposes—real-time
    imaging and high-quality imaging. However, the combination of a webcam and a photo
    camera is likely to be cheaper. Consider the following examples:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，高端工业相机可以同时满足实时成像和高质量成像的双重目的。然而，一个网络摄像头和数码相机的组合可能更便宜。考虑以下例子：
- en: '| Name | Purpose | Sensor Format | Highest Res Mode | Interface | Price |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 目的 | 传感器格式 | 最高分辨率模式 | 接口 | 价格 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Point Grey Research Grasshopper 3 GS3-U3-120S6M-C | Industrial camera | 1"
    | 4242x2830 @ 7 FPS | USB 3.0 | $3,700 (new) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Point Grey Research Grasshopper 3 GS3-U3-120S6M-C | 工业相机 | 1" | 4242x2830
    @ 7 FPS | USB 3.0 | $3,700（新品） |'
- en: '| Carl Zeiss Jena DDR Tevidon 10mm f/2 lens | Lens for industrial camera |
    Covers 1" | Sharp, suitable for high res |   | $300 (used) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 卡尔·蔡司耶拿 DDR Tevidon 10mm f/2 镜头 | 工业相机镜头 | 1" | 清晰，适合高分辨率 |  | 300 美元（二手）|'
- en: '| Nikon 1 J5 with 10-30mm PD-ZOOM lens | Photo camera and lens | 1" | 5568x3712
    @ 20 FPS | USB 2.0 | $500 (new) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 尼康 1 J5 配 10-30mm PD-ZOOM 镜头 | 照相机和镜头 | 1" | 5568x3712 @ 20 FPS | USB 2.0
    | 500 美元（新品）|'
- en: '| Odroid USB-Cam 720p | Webcam | 1/4" | 1280x720 @ 30 FPS | USB 2.0 | $20 (new)
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Odroid USB-Cam 720p | Webcam | 1/4" | 1280x720 @ 30 FPS | USB 2.0 | 20 美元（新品）|'
- en: Here, the industrial camera and lens cost eight times as much as the photo camera,
    lens, and webcam, yet the photo camera should offer the best image quality. Although
    the photo camera has a *capture mode* of 5568x3712 @ 20 FPS, note that its USB
    2.0 interface is much too slow to support this as a *transfer mode*. At the listed
    resolution and rate, the photo camera can just record the images to its local
    storage.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，工业相机和镜头的成本是照相机、镜头和摄像头的八倍，但照相机应该提供最佳图像质量。尽管照相机具有 5568x3712 @ 20 FPS 的 *捕获模式*，请注意，其
    USB 2.0 接口速度过慢，无法支持作为 *传输模式*。在列出的分辨率和速率下，照相机只能将图像记录到其本地存储。
- en: 'For our purposes, a photo camera''s main weakness is its high latency. The
    latency pertains to not only the electronics, but also the moving mechanical parts.
    To mitigate the problem, we can take the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，照相机的主要弱点是高延迟。延迟不仅涉及电子设备，还包括移动的机械部件。为了减轻问题，我们可以采取以下步骤：
- en: Use a webcam with a slightly wider angle of view than the photo camera. This
    way, the camera trap may detect the subject early, and provide the photo camera
    with more lead time to take the first shot.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用比照相机视角略宽的摄像头。这样，相机陷阱可以提前检测到主题，并为照相机提供更多时间进行第一次拍摄。
- en: Put the photo camera in the manual focus mode, and set the focus to the distance
    where you plan to photograph a subject. Manual focus is quicker and quieter because
    the autofocus motor does not run.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将照相机置于手动对焦模式，并将焦点设置在您计划拍摄主题的距离。手动对焦更快、更安静，因为自动对焦电机不会运行。
- en: If you are using a **digital single-lens reflex** (**DSLR**) camera, put it
    in **mirror lock-up** (**MLU**) mode (if it supports MLU). Without MLU, the reflex
    mirror (which deflects light into the optical viewfinder) must move out of the
    optical path before each shot. With MLU, the mirror is already out of the way
    (but the optical viewfinder is disabled). MLU is quicker, quieter, and has less
    vibration because the mirror does not move. On some cameras, MLU is called **live
    view** because the digital ("live") viewfinder may be activated when the optical
    viewfinder is disabled.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是 **数码单反相机**（**DSLR**），请将其置于 **镜锁**（**MLU**）模式（如果支持 MLU）。如果没有 MLU，反射镜（将光线反射到光学取景器）必须在每次拍摄之前移出光学路径。使用
    MLU 时，反射镜已经移开（但光学取景器已禁用）。MLU 更快、更安静、振动更小，因为反射镜不会移动。在某些相机上，MLU 被称为 **实时视图**，因为当光学取景器禁用时，数字（实时）取景器可能会被激活。
- en: Controlling a photo camera is a big part of this project. Once you learn to
    write scripts of photographic commands, perhaps you will begin to think about
    photography in new ways—for it is a process, not just a final moment when the
    shutter falls. Let's turn our attention to this scripting topic now.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 控制照相机是这个项目的重要组成部分。一旦你学会了编写摄影命令脚本，也许你将开始以新的方式思考摄影——因为它是一个过程，而不仅仅是快门落下的那一刻。现在让我们将注意力转向这个脚本主题。
- en: Controlling a photo camera with gPhoto2
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 gPhoto2 控制 photo camera
- en: 'gPhoto2 is an open source, vendor-neutral camera control tool for Unix-like
    systems, such as Linux and Mac. It supports photo cameras of multiple brands,
    including Canon, Nikon, Olympus, Pentax, Sony, and Fuji. The supported features
    vary by model. The following table lists gPhoto2''s major features, alongside
    the official count of supported cameras for each feature:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: gPhoto2 是一个开源、厂商中立的 Unix-like 系统（如 Linux 和 Mac）相机控制工具。它支持多个品牌的相机，包括佳能、尼康、奥林巴斯、宾得、索尼和富士。支持的功能因型号而异。以下表格列出了
    gPhoto2 的主要功能，以及每个功能支持的官方相机数量：
- en: '| Feature | Number of Supported Devices | Description |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 支持的设备数量 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| File transfer | 2105 | files to and from the device |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 文件传输 | 2105 | 在设备和设备之间传输文件 |'
- en: '| Image capture | 489 | Make the device capture an image to its local storage
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 图像捕捉 | 489 | 使设备捕获图像到其本地存储 |'
- en: '| Configuration | 428 | Change the device''s settings, such as shutter speed
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 配置 | 428 | 更改设备的设置，例如快门速度 |'
- en: '| Liveview | 309 | Continuously grab frames of live video from the device |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 直播预览 | 309 | 从设备持续抓取实时视频帧 |'
- en: These numbers are current as of version 2.5.8, and are conservative. For example,
    some configuration features are supported on the Nikon D80, even though the gPhoto2
    documentation does not list this camera as configurable. For our purposes, image
    capture and configuration are required features, so gPhoto2 adequately supports
    at least 428 cameras, and perhaps many more. This number includes all manner of
    cameras, from point-and-shoot compacts to professional DSLRs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字截至版本2.5.8，是保守的。例如，一些配置功能在尼康D80上得到支持，尽管gPhoto2文档没有列出此相机为可配置。就我们的目的而言，图像捕获和配置是必需的功能，因此gPhoto2至少支持428款相机，也许还有更多。这个数字包括各种类型的相机，从便携式紧凑型到专业单反相机。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To check whether the latest version of gPhoto2 officially supports a feature
    on a specific camera, see the official list at [http://www.gphoto.org/proj/libgphoto2/support.php](http://www.gphoto.org/proj/libgphoto2/support.php).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查gPhoto2的最新版本是否官方支持特定相机的功能，请查看官方列表[http://www.gphoto.org/proj/libgphoto2/support.php](http://www.gphoto.org/proj/libgphoto2/support.php)。
- en: 'Typically, gPhoto2 communicates with a camera via USB using a protocol called
    **Picture Transfer Protocol** (**PTP**). Before proceeding, check whether your
    camera has any instructions regarding PTP mode. You might need to change a setting
    on the camera to ensure that the host computer will see it as a PTP device and
    not a USB mass storage device. For example, on many Nikon cameras, it is necessary
    to select **SETUP MENU** | **USB** | **PTP**, as seen in the following image:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，gPhoto2通过USB使用名为**图片传输协议**（**PTP**）的协议与相机通信。在继续之前，请检查您的相机是否有关于PTP模式的说明。您可能需要更改相机上的设置，以确保主机计算机将其视为PTP设备而不是USB存储设备。例如，在许多尼康相机上，必须选择**设置菜单**
    | **USB** | **PTP**，如下面的图片所示：
- en: '![Controlling a photo camera with gPhoto2](img/00021.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![使用gPhoto2控制照片相机](img/00021.jpeg)'
- en: Moreover, if a camera is mounted as a disk drive, gPhoto2 cannot communicate
    with it. This is slightly problematic because most operating systems automatically
    mount a camera as a disk drive, regardless of whether the camera is in the PTP
    mode. Thus, before we proceed to install and use gPhoto2, let's look at ways to
    programmatically unmount a camera drive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果相机作为磁盘驱动器挂载，gPhoto2无法与其通信。这有点问题，因为大多数操作系统都会自动将相机作为磁盘驱动器挂载，无论相机是否处于PTP模式。因此，在我们继续安装和使用gPhoto2之前，让我们看看如何通过编程方式卸载相机驱动器。
- en: Writing a shell script to unmount camera drives
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写卸载相机驱动器的shell脚本
- en: 'On Mac, a process called PTPCamera is responsible for mounting and controlling
    cameras on behalf of applications such as iPhoto. After connecting a camera, we
    can kill PTPCamera by running the following command in Terminal:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，一个名为PTPCamera的进程负责代表iPhoto等应用程序挂载和控制相机。连接相机后，我们可以在终端中运行以下命令来终止PTPCamera：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, the camera will be available to receive commands from gPhoto2\. However,
    keep reading because we want to write code that will support Linux too!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，相机将可用于接收来自gPhoto2的命令。然而，请继续阅读，因为我们想编写支持Linux的代码！
- en: 'On most desktop Linux systems, when the camera is connected, it will be mounted
    as a **Gnome Virtual** **File System** (**GVFS**) volume. We can list the mounted
    GVFS volumes by running the following command in Terminal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数桌面Linux系统上，当相机连接时，它将被挂载为**Gnome虚拟文件系统**（**GVFS**）卷。我们可以在终端中运行以下命令来列出挂载的GVFS卷：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, this command produces the following output in Ubuntu, on a MacBook
    Pro laptop with a Nikon D80 camera attached via USB:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此命令在连接了尼康D80相机的MacBook Pro笔记本电脑（通过USB连接）的Ubuntu上产生以下输出：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the output includes the camera''s mount point, in this case, `gphoto2://[usb:001,007]/`.
    For a camera drive, the GVFS mount point will always start with `gphoto2://`.
    We can unmount the camera drive by running a command such as the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出包括相机的挂载点，在本例中为`gphoto2://[usb:001,007]/`。对于相机驱动器，GVFS挂载点始终以`gphoto2://`开头。我们可以通过运行如下命令来卸载相机驱动器：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, if we run `gvfs-mount -l` again, we should see that the camera is no longer
    listed. Thus, it is unmounted and should be available to receive commands from
    gPhoto2.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行`gvfs-mount -l`，我们应该会看到相机不再列出。因此，它已卸载，应该可以接收来自gPhoto2的命令。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Alternatively, a file browser such as Nautilus will show mounted camera drives,
    and will provide GUI controls to unmount them. However, as programmers, we prefer
    shell commands because they are easier to automate.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，文件浏览器（如 Nautilus）将显示挂载的相机驱动器，并提供卸载它们的 GUI 控制。然而，作为程序员，我们更喜欢 shell 命令，因为它们更容易自动化。
- en: 'We will need to unmount the camera every time it is plugged in. To simplify
    this, let''s write a Bash shell script that supports multiple operating systems
    (Mac or any Linux system with GVFS) and multiple cameras. Create a file named
    `unmount_cameras.sh` and fill it with the following Bash code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次插入相机时都卸载相机。为了简化这个过程，让我们编写一个支持多个操作系统（Mac 或任何带有 GVFS 的 Linux 系统）和多个相机的
    Bash shell 脚本。创建一个名为 `unmount_cameras.sh` 的文件，并填充以下 Bash 代码：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that this script checks the operating system's family (where `"Darwin"`
    is the family of Mac). On Mac, it runs `killall PTPCamera`. On other systems,
    it uses a combination of the `gvfs-mount`, `grep`, and `uniq` commands to find
    each unique `gphoto2://` mount point and then unmount all the cameras.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此脚本检查操作系统的家族（其中 `"Darwin"` 是 Mac 的家族）。在 Mac 上，它运行 `killall PTPCamera`。在其他系统上，它使用
    `gvfs-mount`、`grep` 和 `uniq` 命令的组合来查找每个唯一的 `gphoto2://` 挂载点，然后卸载所有相机。
- en: 'Let''s give the script "executable" permissions by running the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令给脚本赋予“可执行”权限：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Anytime we want to ensure that the camera drives are unmounted, we can execute
    the script like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随时可以通过执行脚本来确保相机驱动器已卸载：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we have a standard way to make a camera available, so we are ready to install
    and use gPhoto2.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个标准的方式来使相机可用，因此我们准备安装和使用 gPhoto2。
- en: Setting up and testing gPhoto2
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和测试 gPhoto2
- en: gPhoto2 and related libraries are widely available in open source software repositories
    for Unix-like systems. No wonder—connecting to a photo camera is a common task
    in desktop computing today!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: gPhoto2 及相关库在 Unix-like 系统的开源软件仓库中广泛可用。这并不奇怪——连接到数码相机是当今桌面计算中的常见任务！
- en: For Mac, Apple does not provide a package manager but third parties do. The
    MacPorts package manager has the most extensive repository.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Mac，Apple 不提供包管理器，但第三方提供了。MacPorts 包管理器拥有最广泛的仓库。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To set up MacPorts and its dependencies, follow the official guide at [https://www.macports.org/install.php](https://www.macports.org/install.php).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 MacPorts 及其依赖项，请遵循官方指南 [https://www.macports.org/install.php](https://www.macports.org/install.php)。
- en: 'To install gPhoto2 via MacPorts, run the following command in Terminal:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 MacPorts 安装 gPhoto2，请在终端运行以下命令：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On Debian and its derivatives, including Ubuntu, Linux Mint, and Raspbian,
    we can install gPhoto2 by running the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Debian 及其衍生版本中，包括 Ubuntu、Linux Mint 和 Raspbian，我们可以通过运行以下命令来安装 gPhoto2：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On Fedora and its derivatives, including Red Hat Enterprise Linux (RHEL) and
    CentOS, we can use the following installation command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora 及其衍生版本中，包括 Red Hat Enterprise Linux (RHEL) 和 CentOS，我们可以使用以下安装命令：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: OpenSUSE has a one-click installer for gPhoto2 at [https://software.opensuse.org/package/gphoto](https://software.opensuse.org/package/gphoto).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSUSE 在 [https://software.opensuse.org/package/gphoto](https://software.opensuse.org/package/gphoto)
    提供了 gPhoto2 的一键安装器。
- en: 'After installing gPhoto2, let''s connect a camera. Ensure that the camera is
    turned on and in PTP mode. Then, run the following commands to unmount the camera
    drive and take a photo:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 gPhoto2 后，让我们连接一个相机。确保相机已开启并处于 PTP 模式。然后，运行以下命令来卸载相机驱动器和拍照：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the camera is in autofocus mode, you might see or hear the lens move. (Ensure
    that the camera has a subject in view so that autofocus will succeed. Otherwise,
    no photo will be captured.) Then, you might hear the shutter open and close. Disconnect
    the camera and use its review menu to browse the captured photos. If a new photo
    is there, gPhoto2 is working!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相机处于自动对焦模式，你可能会看到或听到镜头移动。（确保相机有可观察的物体，以便自动对焦成功。否则，将不会捕捉到任何照片。）然后，你可能会听到快门打开和关闭。断开相机，使用其查看菜单浏览捕获的照片。如果那里有新照片，gPhoto2
    正在运行！
- en: 'To upload all images from the camera to the current working directory, we could
    reconnect the camera and run the following commands:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要将相机中的所有图像上传到当前工作目录，我们可以重新连接相机并运行以下命令：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To read about all the flags that gphoto2 supports, we can open its manual by
    running the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 gphoto2 支持的所有标志，我们可以通过运行以下命令打开其手册：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, let's try a more advanced task, involving configuration as well as image
    capture. We will take a series of photos with exposure bracketing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试一个更高级的任务，涉及配置以及图像捕捉。我们将以曝光包围的方式拍摄一系列照片。
- en: Writing a shell script for exposure bracketing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写用于曝光包围的 shell 脚本
- en: 'gPhoto2 provides a flag, `--set-config`, which allows us to reconfigure many
    camera parameters, including **exposure compensation**. For example, suppose we
    want to overexpose an image by the equivalent of one full f-stop (doubling the
    aperture''s area or increasing its radius by a factor of sqrt(2)). This bias is
    called an exposure compensation (or exposure adjustment) of +1.0 **exposure value**
    (**EV**). The following command configures the camera to use +1.0 EV and then
    takes a photo:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: gPhoto2 提供了一个标志，`--set-config`，允许我们重新配置许多相机参数，包括**曝光补偿**。例如，假设我们想要通过相当于一整个光圈的等效值（加倍光圈面积或将其半径增加
    sqrt(2) 倍）来过度曝光图像。这种偏差称为曝光补偿（或曝光调整）+1.0 **曝光值**（**EV**）。以下命令配置相机使用 +1.0 EV，然后拍摄照片：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the value of `exposurecompensation` is denominated in thousandths
    of an EV, so `1000` is +1.0 EV. To underexpose, we would use a negative value.
    A series of these commands, each with a different EV, would achieve exposure bracketing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`exposurecompensation` 的值以千分之一 EV 计价，因此 `1000` 是 +1.0 EV。要欠曝，我们将使用负值。一系列具有不同
    EV 的这些命令将实现曝光包围。
- en: 'We can use the `--set-config` flag to control many photographic properties,
    not just exposure compensation. For example, the following command captures a
    photo with an exposure time of one second, while firing the flash in slow sync
    mode:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `--set-config` 标志来控制许多摄影属性，而不仅仅是曝光补偿。例如，以下命令以一秒的曝光时间捕捉照片，同时以慢同步模式触发闪光灯：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following command lists all the supported properties and values for the
    given camera:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出了给定相机的所有支持属性和值：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For further discussion of f-stops, exposure, and other photographic properties,
    refer back to [Chapter 1](part0015_split_000.html#E9OE2-940925703e144daa867f510896bffb69
    "Chapter 1. Getting the Most out of Your Camera System"), *Getting the Most out
    of Your Camera System*, especially the *Capturing the subject in the moment* section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于光圈、曝光和其他摄影属性的进一步讨论，请参阅[第 1 章](part0015_split_000.html#E9OE2-940925703e144daa867f510896bffb69
    "第 1 章。充分利用您的相机系统")，*充分利用您的相机系统*，特别是*捕捉瞬间的主题*部分。
- en: Before taking a series of exposure bracketed photos, dial your camera to the
    **aperture priority (A)** mode. This means that the aperture will be held constant
    while the shutter speed will vary based on lighting and EV. A constant aperture
    will help ensure that the same region is in focus in all images.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在拍摄一系列曝光包围照片之前，将您的相机调至**光圈优先（A）**模式。这意味着光圈将保持不变，而快门速度将根据光线和 EV 值变化。恒定的光圈将有助于确保所有图像中的同一区域保持对焦。
- en: 'Let''s automate the exposure bracketing commands with another shell script,
    which we will call `capture_exposure_bracket.sh`. It will accept a flag, `-s`,
    to specify the exposure step size between frames (in thousandths of an EV), and
    another flag `-f`, to specify the number of frames. The defaults will be 3 frames
    spaced at an interval of 1.0 EV. Here is the script''s implementation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用另一个 shell 脚本自动化曝光包围命令，我们将称之为 `capture_exposure_bracket.sh`。它将接受一个标志 `-s`，用于指定帧之间的曝光步长（以千分之一
    EV 计），以及另一个标志 `-f`，用于指定帧数。默认值将是 3 帧，间隔为 1.0 EV。以下是脚本的实现：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All the commands in this script are cross-platform for Linux and Mac. Note that
    we are using the `getopts` command to parse arguments, and Bash arithmetic to
    compute the EV of each photo.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中的所有命令都适用于 Linux 和 Mac 的跨平台。请注意，我们正在使用 `getopts` 命令来解析参数，并使用 Bash 算术来计算每张照片的
    EV 值。
- en: 'Remember to give the script "executable" permissions by running the following
    command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记得通过运行以下命令给脚本赋予“可执行”权限：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To unmount the camera and capture 5 photos at an interval of 1.5 EV, we could
    run the following commands:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载相机并每隔 1.5 EV 捕捉 5 张照片，我们可以运行以下命令：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have a clear idea of how to control a camera from the command line,
    let's consider how to wrap this functionality in a general-purpose programming
    language that can also interface with OpenCV.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经清楚地了解了如何从命令行控制相机，让我们考虑如何将此功能封装在一种通用编程语言中，该语言还可以与 OpenCV 交互。
- en: Writing a Python script to wrap gPhoto2
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写用于封装 gPhoto2 的 Python 脚本
- en: Python is a high-level, dynamic programming language with great third-party
    libraries for mathematics and science. OpenCV's Python bindings are efficient
    and quite mature, wrapping all the C++ library's major functionality except GPU
    optimizations. Python is also a convenient scripting language, as its standard
    libraries provide cross-platform interfaces to access much of the system's functionality.
    For example, it is easy to write Python code to spawn a subprocess (also called
    a child process), which may run any executable, even another interpreter such
    as a Bash shell.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种高级、动态的编程语言，拥有强大的第三方数学和科学库。OpenCV 的 Python 绑定既高效又相当成熟，封装了 C++ 库的所有主要功能，除了
    GPU 优化。Python 也是一种方便的脚本语言，因为其标准库提供了跨平台的接口，可以访问系统的大部分功能。例如，编写 Python 代码来启动一个子进程（也称为子进程）很容易，它可以运行任何可执行文件，甚至是另一个解释器，如
    Bash shell。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on spawning and communicating with a child process from
    Python, see the `subprocess` module's documentation at [https://docs.python.org/2/library/subprocess.html](https://docs.python.org/2/library/subprocess.html).
    For the special case where the child process is an additional Python interpreter,
    see the documentation of the `multiprocessing` module at [https://docs.python.org/2/library/multiprocessing.html](https://docs.python.org/2/library/multiprocessing.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关从 Python 中启动和与子进程通信的更多信息，请参阅 `subprocess` 模块的文档，网址为 [https://docs.python.org/2/library/subprocess.html](https://docs.python.org/2/library/subprocess.html)。对于子进程是附加
    Python 解释器的特殊情况，请参阅 `multiprocessing` 模块的文档，网址为 [https://docs.python.org/2/library/multiprocessing.html](https://docs.python.org/2/library/multiprocessing.html)。
- en: We will use Python's standard subprocessing functionality to wrap gPhoto2 and
    our own shell scripts. By sending camera commands from a child process, we will
    enable the caller (in Python) to treat these as "fire and forget" commands. That
    is to say, functions in the Python process return immediately so that the caller
    is not obliged to wait for the camera to handle the commands. This is a good thing
    because a camera might typically require several seconds to autofocus and capture
    a series of photos.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Python 的标准子进程功能来封装 gPhoto2 和我们自己的 shell 脚本。通过从子进程中发送相机命令，我们将使调用者（在 Python
    中）将这些视为“发射并忘记”命令。也就是说，Python 进程中的函数会立即返回，这样调用者就不必等待相机处理命令。这是好事，因为相机通常需要几秒钟来自动对焦并捕获一系列照片。
- en: 'Let''s create a new file, `CameraCommander.py`, and begin its implementation
    with the following import statements:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件，`CameraCommander.py`，并从以下导入语句开始其实现：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will write a class, `CameraCommander`. As member variables, it will have
    a current capture process (which may be `None`) and a log file. By default, the
    log file will be `/dev/null`, which means that the log output will be discarded.
    After setting member variables, the initialization method will call a helper method
    to unmount thecamera drive so that the camera is ready to receive commands. Here
    are the class''s declaration and initializer:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为 `CameraCommander` 的类。作为成员变量，它将有一个当前捕获过程（可能为 `None`）和一个日志文件。默认情况下，日志文件将是
    `/dev/null`，这意味着日志输出将被丢弃。在设置成员变量之后，初始化方法将调用一个辅助方法来卸载相机驱动，以便相机准备好接收命令。以下是类的声明和初始化器：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When an instance of `CameraCommander` is deleted, it should close the log file,
    as seen in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `CameraCommander` 的实例被删除时，它应该关闭日志文件，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Every time `CameraCommander` opens a subprocess, the command should be interpreted
    by the shell (Bash), and the command''s print output and errors should be redirected
    to the log file. Let''s standardize this configuration of a subprocess in the
    following helper method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每次打开 `CameraCommander` 的子进程时，命令应由 shell（Bash）解释，命令的打印输出和错误应重定向到日志文件。让我们在以下辅助方法中标准化子进程的这种配置：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, as our first wrapper around a shell command, let''s write a method to
    run `unmount_cameras.sh` in a subprocess. Unmounting the camera drives is a short
    process, and it must finish before other camera commands can run. Thus, we will
    implement our wrapper method so that it does not return until `unmount_cameras.sh`
    returns. That is to say, the subprocess will run synchronously in this case. Here
    is the wrapper''s implementation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为我们对 shell 命令的第一个包装器，让我们编写一个方法来在子进程中运行 `unmount_cameras.sh`。卸载相机驱动是一个短暂的过程，它必须在其他相机命令运行之前完成。因此，我们将实现我们的包装器方法，使其在
    `unmount_cameras.sh` 返回之前不返回。也就是说，在这种情况下，子进程将以同步方式运行。以下是包装器实现的代码：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s consider how to capture a single image. We will start by calling
    a helper method to stop any previous, conflicting command. Then, we will invoke
    the `gphoto2` command with the usual `--capture-image` flag. Here is the implementation
    of the wrapper method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑如何捕获单个图像。我们首先将调用一个辅助方法来停止任何之前的、冲突的命令。然后，我们将使用通常的`--capture-image`标志调用`gphoto2`命令。以下是包装方法的实现：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As another capture mode, we can invoke `gphoto2` to record a time-lapse series.
    The `-I` or `--interval` flag, with an integer value, specifies the delay between
    frames, in seconds. The `-F` or `--frames` flag also takes an integer value, specifying
    the number of frames in the series. If the `-I` flag is used but `-F` is omitted,
    the process continues to capture frames indefinitely until forced to terminate.
    Let''s provide the following wrapper for time-lapse functionality:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一种捕获模式，我们可以调用`gphoto2`来记录延时摄影系列。`-I`或`--interval`标志，带有一个整数值，指定帧之间的延迟，单位为秒。`-F`或`--frames`标志也接受一个整数值，指定系列中的帧数。如果使用了`-I`标志但省略了`-F`，则过程会无限期地捕获帧，直到被迫终止。让我们提供以下用于延时功能的包装器：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Before taking a series of time-lapse photos, you might want to dial your camera
    to the **manual exposure** (**M**) mode. This means that the aperture and shutter
    speed will be held constant at manually specified values. Assuming that the scene's
    light level is approximately constant, a constant exposure will help prevent unpleasant
    flickering in the time-lapse video. On the other hand, if we do expect lighting
    conditions to vary a lot over the course of the time-lapse series, the M mode
    may be inappropriate because in these circumstances, it will cause some frames
    to be noticeably underexposed and others overexposed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在拍摄一系列延时摄影照片之前，你可能需要将你的相机调整到**手动曝光**（**M**）模式。这意味着光圈和快门速度将保持恒定，使用手动指定的值。假设场景的光线水平大致恒定，恒定的曝光将有助于防止延时视频中出现不愉快的闪烁。另一方面，如果我们预计在延时摄影系列过程中光线条件会有很大变化，那么M模式可能不合适，因为这些情况下，它会导致一些帧曝光不足，而其他帧则曝光过度。
- en: 'To allow for exposure bracketing, we can simply wrap our `capture_exposure_bracket.sh`
    script, as seen in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许曝光包围，我们可以简单地包装我们的`capture_exposure_bracket.sh`脚本，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we have seen in the previous three methods, it is sensible to terminate
    any ongoing capture process before trying to start another. (After all, a camera
    can only process one command at a time). Moreover, a caller might have other reasons
    to terminate a capture process. For example, the subject might have gone away.
    We will provide the following method to force the termination of any ongoing capture
    process:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前三个方法中看到的，在尝试启动另一个之前终止任何正在进行的捕获过程是合理的。（毕竟，相机一次只能处理一个命令）。此外，调用者可能有其他原因要终止捕获过程。例如，主题可能已经离开。我们将提供以下方法来强制终止任何正在进行的捕获过程：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, we will provide the following method to await the completion of
    any currently running capture process:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将提供以下方法来等待任何当前正在运行的捕获过程的完成：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we will provide the following property getter to enable a caller to
    check whether a capture process is currently running:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将提供以下属性获取器，以便调用者可以检查是否有一个捕获过程目前正在运行：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This concludes the `CameraCommander` module. To test our work, let''s write
    another script, `test_camera_commands.py`, with the following implementation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`CameraCommander`模块。为了测试我们的工作，让我们编写另一个脚本`test_camera_commands.py`，其实现如下：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Ensure that your camera is on, is in the PTP mode, and is connected. Then,
    make the test script executable and run it, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的相机已开启，处于PTP模式，并且已连接。然后，使测试脚本可执行并运行，如下所示：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Wait for all the commands to finish, and then disconnect the camera to review
    the images. Check the timestamp and EV number of each photo. Ideally, a total
    of six photos should have been captured. However, the actual number could vary
    depending on factors such as the success or failure of autofocus, and the time
    spent capturing and saving each image. In case of any doubts, review the log file,
    `test_camera_commands.log`, in a text editor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 等待所有命令完成，然后断开相机以查看图像。检查每张照片的时间戳和EV值。理想情况下，应该已经捕获了总共六张照片。然而，实际数量可能会根据诸如自动对焦的成功或失败、捕获和保存每张图像所花费的时间等因素而有所不同。如果有任何疑问，请使用文本编辑器查看日志文件`test_camera_commands.log`。
- en: Finding libgphoto2 and wrappers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找libgphoto2和包装器
- en: As an alternative to using the gPhoto2 command line tool, we could use the underlying
    C library, libgphoto2 ([https://github.com/gphoto/libgphoto2](https://github.com/gphoto/libgphoto2)).
    The library has several third-party wrappers, including a set of up-to-date Python
    bindings called python-gphoto2 ([https://github.com/gphoto/libgphoto2-python](https://github.com/gphoto/libgphoto2-python)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用gPhoto2命令行工具的替代方案，我们可以使用底层的C库，libgphoto2 ([https://github.com/gphoto/libgphoto2](https://github.com/gphoto/libgphoto2))。该库有几个第三方包装器，包括一组最新的Python绑定，称为python-gphoto2
    ([https://github.com/gphoto/libgphoto2-python](https://github.com/gphoto/libgphoto2-python))。
- en: 'OpenCV 3''s videoio module has optional support for libgphoto2\. To enable
    this feature, we could configure and build OpenCV from source using the `WITH_GPHOTO2`
    CMake definition. Of course, for this option to work, the system must already
    have an installation of libgphoto2 and its header files. For example, these can
    be installed by the following command on Debian, Ubuntu, Linux Mint, Raspbian,
    and similar systems:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 3的videoio模块对libgphoto2有可选支持。要启用此功能，我们可以使用`WITH_GPHOTO2` CMake定义从源代码配置和构建OpenCV。当然，为了使此选项工作，系统必须已经安装了libgphoto2及其头文件。例如，在Debian、Ubuntu、Linux
    Mint、Raspbian和类似系统上，可以通过以下命令安装：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For our purposes, controlling the photo camera via libgphoto2 or OpenCV's videoio
    module is overkill. We do not want to grab frames for real-time processing. We
    simply want our Python scripts to initiate additional processes to unmount and
    configure the camera, and make it capture photos to its local storage. The gPhoto2
    command-line tool and our own shell scripts are perfectly convenient to use as
    subprocesses, so we will continue to rely on them throughout the rest of this
    chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，通过libgphoto2或OpenCV的videoio模块控制相机是过度的。我们不想抓取帧进行实时处理。我们只想让我们的Python脚本启动额外的进程来卸载和配置相机，并使其捕获照片到其本地存储。gPhoto2命令行工具和我们的shell脚本作为子进程使用非常方便，因此我们将继续在本章的其余部分依赖它们。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One of OpenCV's official samples demonstrates the use of a gPhoto2-compatible
    camera via the videoio module. Specifically, the sample deals with focus control.
    See the source code in OpenCV's GitHub repository at [https://github.com/Itseez/opencv/blob/master/samples/cpp/autofocus.cpp](https://github.com/Itseez/opencv/blob/master/samples/cpp/autofocus.cpp).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV的一个官方示例演示了通过videoio模块使用gPhoto2兼容的相机。具体来说，该示例处理焦点控制。请参阅OpenCV的GitHub仓库中的源代码：[https://github.com/Itseez/opencv/blob/master/samples/cpp/autofocus.cpp](https://github.com/Itseez/opencv/blob/master/samples/cpp/autofocus.cpp)。
- en: Detecting the presence of a photogenic subject
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测有摄影价值主题的存在
- en: '[Chapter 1](part0015_split_000.html#E9OE2-940925703e144daa867f510896bffb69
    "Chapter 1. Getting the Most out of Your Camera System"), *Getting the Most out
    of Your Camera System*, proposed that a photograph ought to capture a subject
    in a moment. Let''s explore this notion further as we search for ways to detect
    a desirable or "photogenic" subject and moment.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](part0015_split_000.html#E9OE2-940925703e144daa867f510896bffb69 "第一章.
    充分利用您的相机系统")，《充分利用您的相机系统》，提出了一幅照片应该捕捉一个主题在某个时刻。让我们在寻找检测理想或“有摄影价值”的主题和时刻的方法时进一步探讨这个概念。'
- en: As a medium, photography uses light, an aperture, a photosensitive surface,
    and time to draw an image of a scene. The earliest photographic technology, in
    the 1820s, lacked the resolution and speed to convey a detailed subject in a precise
    moment, but it was able to capture a grainy scene on a sunny day. Later, with
    better lenses, flashes, and photosensitive surfaces, photography became capable
    of capturing a sharp scene, a formal portrait, a faster and more natural portrait,
    and finally a moment of action, frozen in time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种媒介，摄影利用光线、光圈、感光表面和时间来描绘场景的图像。最早期的摄影技术，在19世纪20年代，缺乏分辨率和速度，无法在精确的时刻传达一个详细的主题，但它能够捕捉到晴朗日子里模糊的场景。后来，随着更好的镜头、闪光灯和感光表面，摄影能够捕捉到清晰的场景、正式的肖像、更快更自然的肖像，最终是动作的瞬间，被冻结在时间中。
- en: 'Consider the following series of famous photographs, ranging from 1826 to 1942:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一系列著名的照片，时间跨度从1826年到1942年：
- en: '![Detecting the presence of a photogenic subject](img/00022.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![检测有摄影价值主题的存在](img/00022.jpeg)'
- en: 'For general interest, here are some details about the preceding photographs:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一般兴趣，以下是关于前面照片的一些细节：
- en: 'Upper left: *View from the Window at Le Gras* is history''s earliest surviving
    photograph, taken by Nicéphore Niépce in 1826 or 1827 at Saint-Loup-de-Varennes,
    France. The scene includes parts of the rooftops and countryside at Niépce''s
    estate.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右上角：*勒格拉的窗景*是历史上最早存活的照片，由尼埃普斯在1826年或1827年在法国圣洛佩-德-瓦雷涅斯拍摄。场景包括尼埃普斯庄园的部分屋顶和乡村。
- en: 'Middle left: *Boulevard du Temple*, taken by Louis Daguerre in 1838, is believed
    to be the first photograph to include people. The scene is a busy street in Paris,
    but most of the passersby are invisible because of the photograph''s slow speed.
    Near the street corner, one man is polishing another man''s boots, so these two
    people were in one place long enough to be recorded.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中左：路易·达盖尔在1838年拍摄的*特姆普尔大道*被认为是第一张包含人的照片。场景是巴黎的一条繁忙街道，但由于照片的慢速，大多数路人都是不可见的。在街角附近，一个男人正在擦另一个男人的靴子，所以这两个人在一个地方待了足够长的时间，可以被记录下来。
- en: 'Upper right: Jean-Baptiste Sabatier-Blot captured this formal portrait of Louis
    Daguerre in 1844.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右上角：让-巴蒂斯特·萨巴蒂耶-布洛特在1844年捕捉了路易·达盖尔的这张正式肖像。
- en: 'Lower left: Sergei Prokudin-Gorsky, a pioneer of color photography, captured
    this relatively informal portrait of factory workers in Kasli, Russia, in 1910\.
    The men in the photograph are creating casts at the Kasli Iron Works, which produced
    sculptures and luxury furniture in the 19th and early 20th centuries.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左下角：彩色摄影先驱谢尔盖·普罗库丁-戈尔斯基在1910年捕捉了这张相对随意的俄罗斯卡斯利工厂工人的肖像。照片中的男子正在卡斯利铁工厂制作铸件，该工厂在19世纪和20世纪初生产雕塑和豪华家具。
- en: 'Lower right: Max Alpert took this combat photograph on July 12, 1942, near
    Luhansk (today in Ukraine). The subject is Aleksey Gordeyevich Yeremenko, a 23-year-old
    junior political officer in the Red Army. At the moment of the photograph, Yeremenko
    is rallying his regiment to attack. A few seconds later, he was shot dead.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左下角：马克斯·阿尔伯特在1942年7月12日，在卢甘斯克（今天在乌克兰）附近拍摄了这张战斗照片。主题是阿列克谢·戈尔杰耶维奇·耶尔缅科，他是红军的一名23岁初级政治军官。在照片的瞬间，耶尔缅科正在召集他的部队进攻。几秒钟后，他被击毙。
- en: Even from these few examples, we can infer a historical trend toward more dynamic
    images, which capture an atmosphere of activity, change, or even violence. Let's
    contemplate this trend in the context of nature and wildlife photography. Color
    photography began to reach the public eye around 1907, and after several more
    decades of technological improvements, it prevailed as a more popular format than
    black and white. Color is dynamic. Landscapes, plants, and even animals change
    color depending on the season, weather, time of day, and their age. Today, it
    would seem strange to see a nature documentary shot in black and white.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从这些少数例子中，我们也可以推断出一种历史趋势，即更动态的图像，这些图像捕捉了活动、变化甚至暴力的氛围。让我们在自然和野生动物摄影的背景下思考这一趋势。彩色摄影大约在1907年开始进入公众视野，经过几十年的技术改进，它成为比黑白更受欢迎的格式。色彩是动态的。风景、植物甚至动物的颜色会根据季节、天气、一天中的时间和它们的年龄而变化。今天，看到一部黑白自然纪录片似乎会很奇怪。
- en: Changes in lens technology have also had a profound influence on nature and
    wildlife photography. With longer, faster, and sharper lenses, photographers have
    been able to peer into the lives of wild animals from a distance. For example,
    today, documentaries are filled with scenes of predatory animals chasing their
    prey. To shoot these scenes would have been difficult, or impossible, with lenses
    of the 1920s. Similarly, the quality of macro (close-up) lenses has improved a
    lot, and has been a boon to documentary work on insects and other small creatures.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头技术的变化也对自然和野生动物摄影产生了深远的影响。随着更长、更快、更锐利的镜头，摄影师能够从远处窥视野生动物的生活。例如，今天，纪录片中充满了捕食者追逐猎物的场景。要拍摄这些场景，使用20世纪20年代的镜头将是困难的，甚至是不可能的。同样，微距（特写）镜头的质量也得到了很大提高，这对昆虫和其他小型生物的纪录片工作是一个福音。
- en: Finally, as we discussed in the opening of this chapter, advances in automation
    have enabled photographers to deploy cameras in remote wilderness, in the midst
    of the action. With digital technology, a remote camera can store a huge number
    of photos, and these photos can be combined easily to produce effects, such as
    time-lapse (which accentuates motion) or HDR (which accentuates color). Today,
    these techniques are in widespread use, so documentary fans may be familiar with
    the sight of time-lapse flowers rocketing up from the ground, or time-lapse clouds
    racing across saturated HDR skies. Whether small or large, everything is portrayed
    as dynamic.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如我们在本章开头的讨论中提到的，自动化技术的进步使得摄影师能够在偏远荒野、行动中部署相机。借助数字技术，远程相机可以存储大量的照片，并且这些照片可以轻松组合，产生效果，如时间流逝（强调运动）或HDR（强调色彩）。如今，这些技术已被广泛使用，因此纪录片爱好者可能熟悉时间流逝的花朵从地面迅速生长或时间流逝的云朵在饱和的HDR天空中疾驰的景象。无论大小，一切都被描绘成动态的。
- en: 'We can design a few simple rules to help distinguish between a dynamic scene
    and a static scene. Here are some useful cues:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计一些简单的规则来帮助区分动态场景和静态场景。以下是一些有用的线索：
- en: '**Motion**: We may assume that any movement in a scene represents a chance
    to capture a subject in a moment of action or change. Without needing to know
    what the subject is, we can detect its motion and capture a photograph.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动**：我们可以假设场景中的任何运动都代表捕捉主题在行动或变化时刻的机会。无需知道主题是什么，我们就可以检测其运动并捕捉照片。'
- en: '**Color**: We may assume that certain color patterns are unusual in a given
    environment, and that they arise in a dynamic situation. Without needing to know
    exactly what the colorful subject is, we can detect its presence and photograph
    it. For example, a big new splash of color could be a sunset as the clouds part,
    or a flower as it opens.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：我们可以假设在特定环境中某些颜色模式是不寻常的，并且它们出现在动态情况下。无需确切知道多彩的主题是什么，我们就可以检测其存在并拍摄它。例如，一大片新颜色可能是云层散开时的日落，或者花朵开放时的景象。'
- en: '**Classification**: We may assume that certain kinds of subjects are alive
    and will interact with their environment, creating opportunities for dynamic photos.
    When we detect a given class of subject, we can respond by photographing it. As
    an example, we will detect and photograph the faces of mammals.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类**：我们可以假设某些类型的主题是活着的，并且会与它们的环境互动，从而为动态照片创造机会。当我们检测到某个特定的主题类别时，我们可以通过拍照来响应。例如，我们将检测并拍摄哺乳动物的面部。'
- en: 'Regardless of the approach to detecting a subject, we must ensure that our
    webcam and photo camera have a similar view of the scene. They should point at
    the same target. The webcam''s angle of view should be as wide as the photo camera''s,
    and perhaps a little wider to allow the webcam to detect a subject just before
    it enters the photo camera''s view. Both cameras should be fixed firmly in place
    so that they do not become misaligned due to vibrations, wind, or other typical
    disturbances. For example, the photo camera could be mounted on a sturdy tripod,
    and the webcam could be taped to the photo camera''s hotshoe (the slot that is
    typically reserved for an external flash or external viewfinder). The following
    image shows an example of this setup:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用何种检测主题的方法，我们必须确保我们的网络摄像头和照相机对场景有相似的观点。它们应该指向同一目标。网络摄像头的视野角度应该与照相机一样宽，甚至更宽，以便网络摄像头能够在照相机视野之前检测到主题。两个摄像头都应该固定牢固，以防止由于振动、风或其他典型干扰而错位。例如，照相机可以安装在坚固的三脚架上，而网络摄像头可以贴在照相机的热靴上（通常为外部闪光灯或外部取景器预留的插槽）。以下图像显示了这种设置的示例：
- en: '![Detecting the presence of a photogenic subject](img/00023.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![检测具有摄影主题的存在](img/00023.jpeg)'
- en: 'For context, the following image is a slightly more distant view of the same
    setup. Observe that the webcam and photo camera point at the same subject:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供背景，以下图像是同一设置的稍微远一点的视角。注意，网络摄像头和照相机指向同一主题：
- en: '![Detecting the presence of a photogenic subject](img/00024.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![检测具有摄影主题的存在](img/00024.jpeg)'
- en: We will implement each type of camera trap as a separate script, which will
    accept command-line arguments to adjust the trap's sensitivity. To begin, let's
    develop a motion-sensitive trap.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现每种类型的相机陷阱作为单独的脚本，该脚本将接受命令行参数以调整陷阱的灵敏度。首先，让我们开发一个运动敏感的陷阱。
- en: Detecting a moving subject
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测移动主题
- en: 'Our motion-activated camera trap will rely on the `CameraCommander` module
    that we implemented earlier, in the section *Writing a Python script to wrap gPhoto2*.
    Also, we will use OpenCV and NumPy to capture and analyze webcam images. Finally,
    from Python''s standard library, we will import the `argparse` module, which will
    help parse command-line arguments, and the `time` module, which we will use to
    control the time delay between detection attempts. Let''s create a file, `set_motion_trap.py`,
    and begin its implementation with the following imports:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运动感应摄像头陷阱将依赖于我们之前在*编写用于封装gPhoto2的Python脚本*部分中实现的`CameraCommander`模块。此外，我们将使用OpenCV和NumPy来捕捉和分析网络摄像头图像。最后，从Python的标准库中，我们将导入`argparse`模块，它将帮助我们解析命令行参数，以及`time`模块，我们将用它来控制检测尝试之间的时间延迟。让我们创建一个文件，`set_motion_trap.py`，并从以下导入开始其实现：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This script will have a simple structure, with just a `main()` function that
    reads command-line arguments and performs motion detection in a loop. Several
    arguments pertain to the use of the webcam, which we will call the detection camera.
    Other arguments concern the motion detection algorithm and the use of the photo
    camera. The `main()` function begins with the following definitions of the command-line
    arguments:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将具有简单的结构，只有一个`main()`函数，它读取命令行参数并在循环中进行运动检测。一些参数与网络摄像头的使用有关，我们将称之为检测摄像头。其他参数涉及运动检测算法和相机的使用。`main()`函数开始于以下命令行参数的定义：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The arguments'' `help` text will appear when we run our script with the `-h`
    or `--help` flag, like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行带有`-h`或`--help`标志的脚本时，将显示参数的`help`文本，如下所示：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At this point, we have only declared the arguments. Next, we need to parse
    them and access their values, as shown in the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只声明了参数。接下来，我们需要解析它们并访问它们的值，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Besides the arguments, we will use several variables. A `VideoCapture` object
    will enable us to configure and capture from the webcam. Matrices (which are actually
    NumPy arrays in OpenCV''s Python wrapper) will enable us to store BGR and grayscale
    versions of each webcam frame as well as a **foreground mask**. The foreground
    mask will be output from a motion detection algorithm, and it will be a grayscale
    image that is white in foreground (moving) areas, gray in shadow areas, and black
    in background areas. Specifically, in our case, the motion detector will be an
    instance of OpenCV''s `BackgroundSubtractorMOG2` class. Last, we need an instance
    of our `CameraCommander` class to control the photo camera. Here are the declarations
    of the relevant variables:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了参数之外，我们还将使用几个变量。一个`VideoCapture`对象将使我们能够配置并从网络摄像头进行捕捉。矩阵（在OpenCV的Python包装器中实际上是NumPy数组）将使我们能够存储每个网络摄像头的BGR和灰度版本，以及一个**前景掩码**。前景掩码将由运动检测算法输出，它将是一个灰度图像，前景（移动）区域为白色，阴影区域为灰色，背景区域为黑色。具体来说，在我们的案例中，运动检测器将是OpenCV的`BackgroundSubtractorMOG2`类的实例。最后，我们需要一个`CameraCommander`类的实例来控制相机。以下是相关变量的声明：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The remainder of the `main()` function''s implementation is a loop. On each
    iteration, we will put the thread to sleep for a specified interval (by default,
    0.25 seconds) because this will conserve system resources. As a result, we will
    skip some of the webcam''s frames, but we probably do not need the full frame
    rate to detect the subject. If we did not impose a sleep period, the camera trap
    could utilize 100% of a CPU core all the time, particularly on a slow CPU in a
    low-powered SBC. Here is this first part of the loop''s implementation:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数实现的剩余部分是一个循环。在每次迭代中，我们将线程休眠一个指定的间隔（默认为0.25秒），因为这将节省系统资源。因此，我们将跳过一些网络摄像头的帧，但我们可能不需要完整的帧率来检测主题。如果我们没有设置休眠期，摄像头陷阱可能会一直使用100%的CPU核心，尤其是在低功耗SBC上的慢速CPU。以下是循环实现的第一部分：'
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When we do read a frame, we will convert it to grayscale and equalize it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们读取帧时，我们将将其转换为灰度并均衡化：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will pass the equalized frame and the foreground mask to the `BackgroundSubtractorMOG2`''s
    `apply` method. This method accumulates a history of frames, and estimates whether
    each pixel is part of a foreground region, shadow, or background region based
    on differences between frames in the history. As a third argument, we will pass
    a **learning rate**, which is a value in the range [0.0, 1.0]. A low value means
    that more weight will be given to old frames, and thus the estimates will change
    slowly. See how we call the method in this line of code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把均衡后的帧和前景掩码传递给`BackgroundSubtractorMOG2`的`apply`方法。此方法累积帧的历史记录，并根据历史记录中帧之间的差异来估计每个像素是否是前景区域、阴影或背景区域的一部分。作为第三个参数，我们将传递一个**学习率**，它是一个范围在[0.0,
    1.0]之间的值。低值意味着将更多地考虑旧帧，因此估计将缓慢变化。看看我们如何在以下代码行中调用该方法：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in background subtraction algorithms such as MOG2, the foreground
    is defined as a region whose pixel values have changed in recent history. Conversely,
    the background is a region whose pixel values have not changed. The shadow refers
    to the foreground's shadow. For details about MOG2 and the other background subtraction
    algorithms supported in OpenCV, see the official documentation at [http://docs.opencv.org/3.0-beta/modules/video/doc/motion_analysis_and_object_tracking.html#backgroundsubtractormog2](http://docs.opencv.org/3.0-beta/modules/video/doc/motion_analysis_and_object_tracking.html#backgroundsubtractormog2).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在背景减法算法（如MOG2）中，前景被定义为像素值在最近历史中发生变化的区域。相反，背景是像素值没有变化的区域。阴影指的是前景的阴影。有关MOG2和其他OpenCV支持的背景减法算法的详细信息，请参阅官方文档[http://docs.opencv.org/3.0-beta/modules/video/doc/motion_analysis_and_object_tracking.html#backgroundsubtractormog2](http://docs.opencv.org/3.0-beta/modules/video/doc/motion_analysis_and_object_tracking.html#backgroundsubtractormog2)。
- en: 'As an example of the background subtractor''s input and output, consider the
    following pair of images. The top image is an RGB frame from a video, while the
    bottom image is a foreground mask based on the video. Note that the scene is a
    rocky seacoast with waves breaking in the foreground and boats going past in the
    distance:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为背景减法器输入和输出的示例，考虑以下图像对。上面的图像是视频的RGB帧，而下面的图像是基于视频的前景掩码。请注意，场景是一个岩石海岸，前景有波浪拍打，远处有船只经过：
- en: '![Detecting a moving subject](img/00025.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![检测移动主体](img/00025.jpeg)'
- en: 'By counting the white (foreground) values in the foreground mask, we can get
    a rough measurement of the amount of movement that the webcam has captured in
    recent history. We should normalize this figure based on the number of pixels
    in the frame. Here is the relevant code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算前景掩码中的白色（前景）值，我们可以得到摄像头在最近历史中捕获的运动量的粗略测量值。我们应该根据帧中的像素数量来归一化这个数值。以下是相关代码：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the script is running with the `--debug` flag, we will print the measurement
    of motion:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本以`--debug`标志运行，我们将打印运动测量值：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the motion exceeds a specified threshold, and if we are not already capturing
    photos, we will start to capture photos now. Depending on the command-line arguments,
    we may capture either an exposure-bracketed series or a time-lapse series, as
    seen in the next block of code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运动超过指定的阈值，并且如果我们还没有开始捕获照片，我们现在将开始捕获照片。根据命令行参数，我们可能捕获曝光分级的系列或时间间隔系列，如下面的代码块所示：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, the loop and the `main()` function end. To ensure that `main()` runs
    when the script is executed, we must add the following code to the script:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，循环和`main()`函数结束了。为了确保在执行脚本时`main()`运行，我们必须在脚本中添加以下代码：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can give this Python script "executable" permissions and then run it like
    any other shell script, as seen in following example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给这个Python脚本赋予“可执行”权限，然后像其他shell脚本一样运行它，如下面的示例所示：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Consider the pair of images below. The left-hand image shows the physical setup
    of the motion-activated camera trap, which happens to be running `set_motion_trap.py`
    with default parameters. The right-hand image is one of the resulting photos:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下面的图像对。左边的图像显示了运动激活的相机陷阱的物理设置，它恰好运行了带有默认参数的`set_motion_trap.py`。右边的图像是结果照片之一：
- en: '![Detecting a moving subject](img/00026.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![检测移动主体](img/00026.jpeg)'
- en: These images were taken with two different cameras, and for this reason they
    differ in color and contrast. However, they represent the same scene.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像是用两个不同的相机拍摄的，因此它们在颜色和对比度上有所不同。然而，它们代表的是同一个场景。
- en: Experiment with the optional arguments to see which settings work best for a
    given camera and a particular kind of moving subject. Once you have gained an
    understanding of this camera trap's sensitivities, let's proceed to another design,
    using a set of color values as the trigger.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整可选参数，以查看哪些设置对特定相机和移动主体类型最为有效。一旦我们了解了这个相机陷阱的敏感性，让我们继续进行另一个设计，使用一组颜色值作为触发器。
- en: Detecting a colorful subject
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测彩色主体
- en: 'OpenCV provides a set of functions to measure and compare the color distribution
    in images. This field is called histogram analysis. A histogram is just an array
    of pixel counts for various colors or ranges of colors. Thus, for a BGR image
    with 256 possible values per channel, a histogram can have as many as 256 ^ 3
    = 16.8 million elements. To create such a histogram, we can use the following
    code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一套用于测量和比较图像中颜色分布的函数。这个领域被称为直方图分析。直方图只是各种颜色或颜色范围的像素计数的数组。因此，对于每个通道有256个可能值的BGR图像，直方图可以有高达256^3
    = 1680万个元素。要创建此类直方图，我们可以使用以下代码：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The sum of the histogram''s values equals the total number of pixels in the
    input images. To facilitate comparisons, we should normalize the histogram so
    that the sum of its values is 1.0 or, in other words, each value represents the
    *proportion* of pixels belonging to the given color bin. We can use the following
    code to perform this type of normalization:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图值的总和等于输入图像中的像素总数。为了便于比较，我们应该将直方图归一化，使其值的总和为1.0，换句话说，每个值代表属于给定颜色分组的像素的*比例*。我们可以使用以下代码执行此类归一化：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, to obtain a similarity measurement for two normalized histograms, we
    can use code such as the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了获得两个归一化直方图的相似度测量值，我们可以使用如下代码：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For the `HISTCMP_INTERSECT` method, the similarity is the sum of the per-element
    minimums of the two histograms. If we consider the histograms as two curves, this
    value measures the intersecting area beneath the curves.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`HISTCMP_INTERSECT`方法，相似度是两个直方图的每个元素的最小值的总和。如果我们把直方图看作两条曲线，这个值衡量的是曲线下方的交叠面积。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a list of all the supported methods of histogram comparison and their mathematical
    definitions, see the official documentation at [http://docs.opencv.org/3.0-beta/modules/imgproc/doc/histograms.html#comparehist](http://docs.opencv.org/3.0-beta/modules/imgproc/doc/histograms.html#comparehist).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有支持的直方图比较方法及其数学定义的列表，请参阅官方文档中的[http://docs.opencv.org/3.0-beta/modules/imgproc/doc/histograms.html#comparehist](http://docs.opencv.org/3.0-beta/modules/imgproc/doc/histograms.html#comparehist)。
- en: 'We will build a camera trap that uses histogram similarity as a trigger. When
    the histogram of the webcam''s image is sufficiently similar to the histogram
    of a reference image, we will activate the photo camera. The reference image could
    be a colorful landscape (if we are interested in all the colors of the landscape),
    or it could be a tightly cropped photo of a colorful object (if we are interested
    in just the object''s colors, regardless of the surroundings). Consider the following
    examples of tightly cropped photos:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个使用直方图相似性作为触发器的相机陷阱。当网络摄像头的图像直方图与参考图像的直方图足够相似时，我们将激活照相机。参考图像可以是彩色风景（如果我们对风景的所有颜色都感兴趣），或者它可以是彩色物体的紧密裁剪照片（如果我们只对物体的颜色感兴趣，而不管周围环境如何）。考虑以下紧密裁剪照片的例子：
- en: '![Detecting a colorful subject](img/00027.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![检测彩色主体](img/00027.jpeg)'
- en: The first image (left) shows an orange jacket, which is a common piece of outdoor
    clothing during hunting season. (The intense, warm color makes the wearer more
    visible, reducing the risk of hunting accidents.) This is potentially a good reference
    image if we want to detect people in the woods. The second image (right) shows
    an alpine poppy with red petals and yellow stamen. This may be a good reference
    image if we want to detect a flower when it opens.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张图像（左）展示了一件橙色夹克，这是狩猎季节期间常见的户外服装。 (鲜艳、温暖的色彩使穿着者更易被看到，从而降低了狩猎事故的风险。) 如果我们想检测树林中的人，这可能是一个好的参考图像。第二张图像（右）展示了一种高山罂粟，其花瓣为红色，花蕊为黄色。如果我们想检测花朵开放时的情况，这可能是一个好的参考图像。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These and other colorful images can be found in the book's GitHub repository
    at [https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap/media](https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap/media).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些以及其他丰富多彩的图像可以在本书的GitHub仓库中找到，网址为[https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap/media](https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap/media)。
- en: Let's implement the color-based camera trap in a new script called `set_color_trap.py`.
    Much of the code will be similar to `set_motion_trap.py`, but we will cover the
    differences here.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为`set_color_trap.py`的新脚本中实现基于颜色的相机陷阱。大部分代码将与`set_motion_trap.py`相似，但我们将在这里介绍差异。
- en: 'Under some circumstances, `set_color_trap.py` will print error messages to
    `stderr`. For this functionality, Python 2 and Python 3 have different syntax.
    We will add the following import statement for compatibility, to make Python 3''s
    `print` syntax available even if we are running Python 2:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`set_color_trap.py`将打印错误信息到`stderr`。为了实现这一功能，Python 2和Python 3有不同的语法。我们将添加以下导入语句以实现兼容性，即使我们在运行Python
    2，也能使Python 3的`print`语法可用：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our script''s command-line arguments will include the path to the reference
    image, and a similarity threshold, which will determine the trap''s sensitivity.
    Here are the definitions of the arguments:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本命令行参数将包括参考图像的路径和一个相似度阈值，这将决定陷阱的灵敏度。以下是参数的定义：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To read the omitted sections of this script, go to the book's GitHub repository
    at [https://github.com/OpenCVBlueprints/OpenCVBlueprints/chapter_2/CameraTrap/set_color_trap.py](https://github.com/OpenCVBlueprints/OpenCVBlueprints/chapter_2/CameraTrap/set_color_trap.py).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读此脚本中省略的部分，请访问本书的GitHub仓库，网址为[https://github.com/OpenCVBlueprints/OpenCVBlueprints/chapter_2/CameraTrap/set_color_trap.py](https://github.com/OpenCVBlueprints/OpenCVBlueprints/chapter_2/CameraTrap/set_color_trap.py)。
- en: 'We will parse the arguments and try to load the reference image from file.
    If the image cannot be loaded, the script will print an error message and exit
    prematurely, as the following code shows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解析参数并尝试从文件中加载参考图像。如果无法加载图像，脚本将打印错误信息并提前退出，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will create a normalized histogram of the reference image, and later, we
    will also create a normalized histogram of each frame from the webcam. To help
    with the creation of a normalized histogram, we will define another function locally.
    (Python allows nested function definitions.) Here is the relevant code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建参考图像的归一化直方图，稍后，我们还将创建来自网络摄像头的每一帧的归一化直方图。为了帮助创建归一化直方图，我们将在本地定义另一个函数。（Python允许嵌套函数定义。）以下是相关代码：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To reiterate, every time we capture a frame from the webcam, we will find its
    normalized histogram. Then, we will measure the similarity of the reference histogram
    and the current scene's histogram based on the `HISTCMP_INTERSECT` method of comparison,
    meaning that we simply want to calculate the histograms' intersection or overlapping
    area. If the similarity is equal to or greater than the threshold, we will begin
    to capture photos.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，每次我们从网络摄像头捕获一帧时，我们将找到其归一化直方图。然后，我们将根据比较的`HISTCMP_INTERSECT`方法测量参考直方图和当前场景直方图的相似度，这意味着我们只想计算直方图的交集或重叠区域。如果相似度等于或大于阈值，我们将开始捕获照片。
- en: 'Here is the main loop''s implementation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主循环的实现：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This concludes the `main()` function. Again, to ensure that `main()` is called
    when the script is executed, we will add the following code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了`main()`函数。再次强调，为了确保在脚本执行时调用`main()`，我们将添加以下代码：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Make the script executable. Then, for example, we can run it like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使脚本可执行。然后，例如，我们可以这样运行它：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'See the pair of the following images. The left-hand image shows the physical
    setup of the camera trap, which is running `set_color_trap.py` with the custom
    parameters that we just noted. The right-hand image is one of the resulting photos:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下图像对。左侧图像显示了相机陷阱的物理设置，正在运行`set_color_trap.py`，并使用我们刚才提到的自定义参数。右侧图像是结果照片之一：
- en: '![Detecting a colorful subject](img/00028.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![检测彩色主题](img/00028.jpeg)'
- en: Again, these images come from different cameras, which give different renditions
    of the scene's color and contrast.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些图像来自不同的相机，它们以不同的方式呈现场景的颜色和对比度。
- en: You may wish to experiment with `set_color_trap`'s arguments, especially the
    reference image and similarity threshold. Note that the `HISTCMP_INTERSECT` method
    of comparison tends to produce low similarities, so the default threshold is just
    0.02, or a 2% overlap of the histograms. If you modify the code to use a different
    method of comparison, you may need a much higher threshold, and the maximum similarity
    may exceed 1.0.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想尝试`set_color_trap`的参数，特别是参考图像和相似度阈值。请注意，比较方法`HISTCMP_INTERSECT`倾向于产生较低的相似度，因此默认阈值仅为0.02，即直方图的重叠为2%。如果你修改代码以使用不同的比较方法，你可能需要一个更高的阈值，并且最大相似度可能超过1.0。
- en: Once you finish testing the color-based camera trap, let's proceed to use face
    detection as our final kind of trigger.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成基于颜色的相机陷阱测试，我们就继续使用人脸检测作为我们的最终触发方式。
- en: Detecting the face of a mammal
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测哺乳动物的脸
- en: 'As you probably know, OpenCV''s `CascadeClassifier` class is useful for face
    detection and other kinds of object detection, using a model of the object''s
    features called a cascade, which is loaded from an XML file. We used `CascadeClassifier`
    and `haarcascade_frontalface_alt.xml` for human face detection in the section
    *Supercharging the GS3-U3-23S6M-C and other Point Grey Research cameras* of [Chapter
    1](part0015_split_000.html#E9OE2-940925703e144daa867f510896bffb69 "Chapter 1. Getting
    the Most out of Your Camera System"), *Getting the Most out of Your Camera System*.
    Later in this book, in [Chapter 5](part0043_split_000.html#190862-940925703e144daa867f510896bffb69
    "Chapter 5. Generic Object Detection for Industrial Applications"), *Generic Object
    Detection for Industrial Applications*, we will examine all of `CascadeClassifier`''s
    functionality, along with a set of tools to create a cascade for any kind of object.
    For now, we will continue to use pretrained cascades that come with OpenCV. Notably,
    OpenCV offers the following cascade files for human and cat face detection:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，OpenCV的`CascadeClassifier`类对于人脸检测和其他类型的对象检测非常有用，它使用一个称为级联的对象特征模型，该模型从XML文件中加载。我们在[第1章](part0015_split_000.html#E9OE2-940925703e144daa867f510896bffb69
    "第1章。充分利用您的相机系统")的*Supercharging the GS3-U3-23S6M-C and other Point Grey Research
    cameras*部分使用了`CascadeClassifier`和`haarcascade_frontalface_alt.xml`进行人脸检测，*充分利用您的相机系统*。在本书的后续章节中，在[第5章](part0043_split_000.html#190862-940925703e144daa867f510896bffb69
    "第5章。工业应用中的通用对象检测")的*Generic Object Detection for Industrial Applications*中，我们将检查`CascadeClassifier`的所有功能，以及一组用于创建任何类型对象的级联的工具。目前，我们将继续使用OpenCV附带的前训练级联。值得注意的是，OpenCV为人类和猫的人脸检测提供了以下级联文件：
- en: 'For human frontal faces:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于人类的前脸：
- en: '`data/haarcascades/haarcascade_frontalface_default.xml`'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/haarcascades/haarcascade_frontalface_default.xml`'
- en: '`data/haarcascades/haarcascade_frontalface_alt.xml`'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/haarcascades/haarcascade_frontalface_alt.xml`'
- en: '`data/haarcascades/haarcascade_frontalface_alt2.xml`'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/haarcascades/haarcascade_frontalface_alt2.xml`'
- en: '`data/lbpcascades/lbpcascade_frontalface.xml`'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/lbpcascades/lbpcascade_frontalface.xml`'
- en: 'For human profile faces:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于人类的侧面脸：
- en: '`data/haarcascades/haarcascade_profileface.xml`'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/haarcascades/haarcascade_profileface.xml`'
- en: '`data/lbpcascades/lbpcascade_profileface.xml`'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/lbpcascades/lbpcascade_profileface.xml`'
- en: 'For cat frontal faces:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于猫的前脸：
- en: '`data/haarcascades/haarcascade_frontalcatface.xml`'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/haarcascades/haarcascade_frontalcatface.xml`'
- en: '`data/haarcascades/haarcascade_frontalcatface_extended.xml`'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/haarcascades/haarcascade_frontalcatface_extended.xml`'
- en: '`data/lbpcascades/lbpcascade_frontalcatface.xml`'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data/lbpcascades/lbpcascade_frontalcatface.xml`'
- en: LBP cascades are faster but slightly less accurate than Haar cascades. The extended
    version of Haar cascades (as used in `haarcascade_frontalcatface_extended.xml`)
    is sensitive to both horizontal and diagonal features, whereas standard Haar cascades
    are only sensitive to horizontal features. For example, a cat's whiskers could
    register as diagonal features.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: LBP级联比Haar级联更快，但稍微不太准确。Haar级联的扩展版本（如`haarcascade_frontalcatface_extended.xml`中使用的那样）对水平和对角特征都很敏感，而标准的Haar级联只对水平特征敏感。例如，猫的胡须可能会被识别为对角特征。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Chapter 5](part0043_split_000.html#190862-940925703e144daa867f510896bffb69
    "Chapter 5. Generic Object Detection for Industrial Applications"), *Generic Object
    Detection for Industrial Applications*, in this book, will discuss types of cascades
    in detail. Also, for a complete tutorial on how OpenCV''s cat cascades were trained,
    see [Chapter 3](part0029_split_000.html#RL0A1-940925703e144daa867f510896bffb69
    "Chapter 3. Recognizing Facial Expressions with Machine Learning"), *Training
    a Smart Alarm to Recognize the Villain and His Cat*, in the book *OpenCV for Secret
    Agents*, by Joseph Howse (Packt Publishing, 2015).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第5章[通用工业应用对象检测](part0043_split_000.html#190862-940925703e144daa867f510896bffb69
    "第5章。通用工业应用对象检测")将详细讨论级联类型。此外，有关如何使用OpenCV的猫级联进行训练的完整教程，请参阅Joseph Howse（Packt
    Publishing，2015年）所著的《OpenCV for Secret Agents》一书中的第3章[使用机器学习识别面部表情](part0029_split_000.html#RL0A1-940925703e144daa867f510896bffb69
    "第3章。训练智能警报器以识别恶棍及其猫")。
- en: 'Incidentally, the cat face detection cascades may also detect other mammal
    faces. The following images are visualizations of the detection results using
    `haarcascade_frontalcatface_extended.xml` on photos of a cat (left), a red panda
    (upper right), and a lynx (lower right):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，猫脸检测级联也可能检测到其他哺乳动物的面部。以下图片是使用`haarcascade_frontalcatface_extended.xml`在猫（左）、红熊猫（右上）和猞猁（右下）的照片上检测结果的可视化：
- en: '![Detecting the face of a mammal](img/00029.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![检测哺乳动物的面部](img/00029.jpeg)'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The photos of the red panda and lynx are by Mathias Appel, who has generously
    released these and many other images into the public domain. See his Flickr page
    at [https://www.flickr.com/photos/mathiasappel/](https://www.flickr.com/photos/mathiasappel/).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 红熊猫和猞猁的照片由Mathias Appel拍摄，他慷慨地将这些以及其他许多图片发布到公共领域。请参阅他的Flickr页面[https://www.flickr.com/photos/mathiasappel/](https://www.flickr.com/photos/mathiasappel/)。
- en: 'Let''s implement the classification-based camera trap in a new script called
    `set_classifier_trap.py`. The necessary imports are the same as for `set_color_trap.py`.
    The command-line arguments for `set_classifier_trap.py` include the path to the
    cascade file as well as other parameters that affect the use of `CascadeClassifer`.
    Here is the relevant code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为`set_classifier_trap.py`的新脚本中实现基于分类的相机陷阱。必要的导入与`set_color_trap.py`相同。`set_classifier_trap.py`的命令行参数包括级联文件的路径以及影响`CascadeClassifier`使用的其他参数。以下是相关代码：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To read the omitted sections of this script, go to the book's GitHub repository
    at [https://github.com/OpenCVBlueprints/OpenCVBlueprints/chapter_2/CameraTrap/set_classifier_trap.py](https://github.com/OpenCVBlueprints/OpenCVBlueprints/chapter_2/CameraTrap/set_classifier_trap.py).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读此脚本省略的部分，请访问本书的GitHub仓库[https://github.com/OpenCVBlueprints/OpenCVBlueprints/chapter_2/CameraTrap/set_classifier_trap.py](https://github.com/OpenCVBlueprints/OpenCVBlueprints/chapter_2/CameraTrap/set_classifier_trap.py)。
- en: 'After parsing the arguments as usual, we will initialize an instance of `CascadeClassifier`
    with the specified cascade file. If the file failed to load, we will print an
    error message and exit the script prematurely. See the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在像往常一样解析参数之后，我们将使用指定的级联文件初始化一个`CascadeClassifier`实例。如果文件加载失败，我们将打印错误消息并提前退出脚本。请参阅以下代码：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'On each iteration of the script''s main loop, we will convert the webcam image
    to an equalized black and white version, which we will pass to the `CascadeClassifier`''s
    `detectMultiScale` method. We will use some of the command-line arguments as additional
    parameters to control the sensitivity of `detectMultiScale`. If at least one face
    (or other relevant object) is detected, we will start to capture photos, as usual.
    Here is the loop''s implementation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本主循环的每次迭代中，我们将网络摄像头图像转换为均衡的黑白版本，并将其传递给`CascadeClassifier`的`detectMultiScale`方法。我们将使用一些命令行参数作为额外的参数来控制`detectMultiScale`的灵敏度。如果至少检测到一个面部（或其他相关对象），我们将开始捕获照片，就像往常一样。以下是循环的实现：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This completes the `main()` function, and all that remains is to call `main()`
    when the script executes, as usual:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了`main()`函数，剩下的只是在脚本执行时像往常一样调用`main()`：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Make the script executable. Then, for example, we can run it like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使脚本可执行。然后，例如，我们可以这样运行它：
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Refer to the following set of images. The left-hand image shows the physical
    setup of the camera trap, which is running `set_classifier_trap.py` with the custom
    parameters that we just noted. The right-hand images are two of the resulting
    photos:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下一组图片。左侧图片展示了相机陷阱的物理设置，它正在运行`set_classifier_trap.py`，并使用我们刚刚提到的自定义参数。右侧图片是其中两张结果照片：
- en: '![Detecting the face of a mammal](img/00030.jpeg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![检测哺乳动物的面部](img/00030.jpeg)'
- en: The left-hand image and right-hand images come from two different cameras, so
    the color and contrast differ. Also, the two right-hand images come from separate
    runs of `set_classifier_trap.py`, and the lighting conditions and camera position
    have changed very slightly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧图像和右侧图像来自两个不同的相机，因此颜色和对比度不同。此外，两个右侧图像来自`set_classifier_trap.py`的单独运行，照明条件和相机位置略有变化。
- en: Feel free to experiment with the arguments of `set_classifier_trap.py`. You
    might even want to create your own cascade files to detect different kinds of
    faces or objects. [Chapter 5](part0043_split_000.html#190862-940925703e144daa867f510896bffb69
    "Chapter 5. Generic Object Detection for Industrial Applications"), *Generic Object
    Detection for Industrial Applications*, will provide a wealth of information to
    help you do more with `CascadeClassifier` and cascade files.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试`set_classifier_trap.py`的参数。你可能甚至想创建自己的级联文件来检测不同类型的面部或对象。[第五章](part0043_split_000.html#190862-940925703e144daa867f510896bffb69
    "第五章. 工业应用中的通用对象检测")，*工业应用中的通用对象检测*，将提供大量信息，帮助你更好地使用`CascadeClassifier`和级联文件。
- en: Next, we will consider ways to process the photos that we may capture with any
    of our scripts, or with simple gPhoto2 commands.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑处理我们可能用任何脚本或简单的gPhoto2命令捕获的相片的方法。
- en: Processing images to show subtle colors and motion
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图像以显示细微的颜色和运动
- en: 'By now, you have probably captured some exposure-bracketed photos and time-lapse
    photos. Upload them onto your computer using a photo management application, a
    file browser, or the following gPhoto2 command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经捕获了一些曝光包围的相片和延时摄影相片。使用照片管理应用、文件浏览器或以下gPhoto2命令将它们上传到你的电脑上：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The latter command will upload the files to the current working directory.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 后者命令会将文件上传到当前工作目录。
- en: We will merge exposure-bracketed photos to create HDR images, which will improve
    color rendition in shadows and highlights. Similarly, we will merge time-lapse
    photos to create time-lapse videos, which will show gradual motion on an accelerated
    scale. We will start by processing some of the sample photos from the book's GitHub
    repository at [https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap/media](https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap/media),
    and then you will be able to adapt the code to use your photos instead.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将合并曝光包围的相片来创建HDR图像，这将改善阴影和亮部的色彩表现。同样，我们将合并延时摄影相片来创建延时视频，这将展示加速尺度上的渐进运动。我们将首先处理来自书籍GitHub仓库的一些样本相片，该仓库地址为[https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap/media](https://github.com/OpenCVBlueprints/OpenCVBlueprints/tree/master/chapter_2/CameraTrap/media)，然后你将能够将代码适配以使用你的相片。
- en: Creating HDR images
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建HDR图像
- en: OpenCV 3 has a new module called "photo". Two of its classes, `MergeDebevec`
    and `MergeMertens`, create an HDR image by merging exposure-bracketed photos.
    Regardless of which class is used, the resulting HDR image has channel values
    in the range [0.0, 1.0]. `MergeDebevec` produces an HDR image that requires gamma
    correction before it can be displayed or printed. The photo module provides several
    **tone mapping** functions that are capable of performing the correction.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 3有一个名为“photo”的新模块。其中两个类，`MergeDebevec`和`MergeMertens`，通过合并曝光包围的相片来创建HDR图像。无论使用哪个类，生成的HDR图像的通道值都在范围[0.0,
    1.0]内。`MergeDebevec`生成的HDR图像在可以显示或打印之前需要伽玛校正。该照片模块提供了几个**色调映射**函数，能够执行校正。
- en: On the other hand, the HDR image from `MergeMertens` does not require gamma
    correction. Its channel values just need to be scaled up to the range [0, 255].
    We will use `MergeMertens` because it is simpler and tends to be better at preserving
    color saturation.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`MergeMertens`生成的HDR图像不需要伽玛校正。其通道值只需放大到范围[0, 255]。我们将使用`MergeMertens`，因为它更简单，并且通常在保留颜色饱和度方面表现更好。
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about HDR imaging and tone mapping in OpenCV 3, see the
    official documentation at [http://docs.opencv.org/3.0-beta/modules/photo/doc/hdr_imaging.html](http://docs.opencv.org/3.0-beta/modules/photo/doc/hdr_imaging.html).
    Also, see the official tutorial at [http://docs.opencv.org/3.0-beta/doc/tutorials/photo/hdr_imaging/hdr_imaging.html](http://docs.opencv.org/3.0-beta/doc/tutorials/photo/hdr_imaging/hdr_imaging.html).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OpenCV 3中HDR成像和色调映射的更多信息，请参阅官方文档[http://docs.opencv.org/3.0-beta/modules/photo/doc/hdr_imaging.html](http://docs.opencv.org/3.0-beta/modules/photo/doc/hdr_imaging.html)。还可以查看官方教程[http://docs.opencv.org/3.0-beta/doc/tutorials/photo/hdr_imaging/hdr_imaging.html](http://docs.opencv.org/3.0-beta/doc/tutorials/photo/hdr_imaging/hdr_imaging.html)。
- en: 'The `MergeDebevec` and `MergeMertens` classes are based on the following papers,
    respectively:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`MergeDebevec`和`MergeMertens`类分别基于以下论文：'
- en: P. Debevec, and J. Malik, *Recovering High Dynamic Range Radiance Maps from
    Photographs*, Proceedings OF ACM SIGGRAPH, 1997, 369 - 378.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: P. Debevec, and J. Malik, *从照片中恢复高动态范围辐射图*, ACM SIGGRAPH会议论文集，1997年，369 - 378。
- en: T. Mertens, J. Kautz, and F. Van Reeth, *Exposure Fusion*, Proceedings of the
    15th Pacific Conference on Computer Graphics and Applications, 2007, 382 - 390.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: T. Mertens, J. Kautz, and F. Van Reeth, *曝光融合*, 第15届太平洋计算机图形和应用会议论文集，2007年，382
    - 390。
- en: 'For demonstration purposes, the GitHub repository contains a pair of exposure-bracketed
    photos of a cat named Plasma. (Her photos and the HDR merged version appear earlier
    in this chapter, in the section *Planning the camera trap*.) Let''s create a script,
    `test_hdr_merge.py`, to merge the unprocessed photos, `media/PlasmaWink_0.jpg`
    and `media/PlasmaWink_1.jpg`. Here is the implementation:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，GitHub仓库包含一对名为Plasma的猫的曝光包围照片。（她的照片和HDR合并版本在本章的*规划相机陷阱*部分中较早出现。）让我们创建一个脚本，`test_hdr_merge.py`，以合并未处理的照片，`media/PlasmaWink_0.jpg`和`media/PlasmaWink_1.jpg`。以下是实现方式：
- en: '[PRE62]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Obtain the script and media from the repository, run the script, and view the
    resulting HDR image. Then, adapt the script to process your own exposure-bracketed
    photos. HDR can produce dramatic results for any scene that has intense light
    and deep shadows. Landscapes and sunlit rooms are good examples.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从仓库中获取脚本和媒体文件，运行脚本，查看生成的HDR图像。然后，修改脚本以处理您自己的曝光包围照片。HDR可以为任何具有强烈光线和深阴影的场景产生戏剧性的效果。风景和阳光照射的房间是很好的例子。
- en: With HDR imaging, we have compressed differences in exposure. Next, with time-lapse
    videography, we will compress differences in time.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HDR成像，我们压缩了曝光差异。接下来，通过延时摄影，我们将压缩时间差异。
- en: Creating time-lapse videos
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建延时视频
- en: Previously, in the section *Supercharging the PlayStation Eye* in [Chapter 1](part0015_split_000.html#E9OE2-940925703e144daa867f510896bffb69
    "Chapter 1. Getting the Most out of Your Camera System"), *Getting the Most out
    of Your Camera System*, we created a slow-motion video. Remember that we simply
    captured images at a high speed (187 FPS) and put them in a video that was configured
    to play at a normal speed (60 FPS). Similarly, to create a time-lapse video, we
    will read image files that were captured at a low speed (less than 1 FPS) and
    put them in a video that is configured to play at a normal speed (60 FPS).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0015_split_000.html#E9OE2-940925703e144daa867f510896bffb69 "第1章。充分利用您的相机系统")的*超级充电PlayStation
    Eye*部分中，我们创建了一个慢动作视频。记住，我们只是以高速（187 FPS）捕获图像，并将它们放入一个配置为以正常速度（60 FPS）播放的视频中。同样，要创建延时视频，我们将读取以低速（小于1
    FPS）捕获的图像文件，并将它们放入一个配置为以正常速度（60 FPS）播放的视频中。
- en: 'For demonstration purposes, the book''s GitHub repository contains a set of
    time-lapse photographs of a cat named Josephine. When we make a time-lapse video
    of Josephine, we will see that she is very dynamic, even when she is sitting in
    a chair! As a preview, here are three consecutive frames of the time lapse:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，本书的GitHub仓库包含一组名为Josephine的猫的延时照片。当我们为Josephine制作延时视频时，我们会看到她非常活跃，即使她坐在椅子上时也是如此！作为预览，以下是延时视频的三个连续帧：
- en: '![Creating time-lapse videos](img/00031.jpeg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![创建延时视频](img/00031.jpeg)'
- en: 'The series spans 56 photos with names ranging from `media/JosephineChair_00.jpg`
    to `media/JosephineChair_55.jpg`. The following script, which we will call `test_time_lapse_merge.py`,
    will read the photos and produce a one-second time-lapse video named `media/JosephineChair_TimeLapse.avi`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 该系列包含56张照片，名称从`media/JosephineChair_00.jpg`到`media/JosephineChair_55.jpg`。以下脚本，我们将称之为`test_time_lapse_merge.py`，将读取照片并生成一个名为`media/JosephineChair_TimeLapse.avi`的一秒延时视频：
- en: '[PRE63]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Obtain the script and media from the repository, run the script, and view the
    resulting video of Josephine watching the world from her chair. Then, adapt the
    script to process some of your own images. Perhaps you will capture the motion
    of other slow animals, flowers as they bloom, or sunlight and clouds as they cross
    a landscape.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 从仓库中获取脚本和媒体，运行脚本，观看约瑟芬从她的椅子上观看世界的视频结果。然后，修改脚本以处理你自己的图像。也许你会捕捉到其他慢动作动物的运动，花朵的绽放，或者阳光和云朵穿越景观的景象。
- en: As a further project, you may wish to create HDR time-lapse videos. You could
    start by modifying our `capture_exposure_bracket.sh` script to capture multiple
    batches of exposure-bracketed images, with a time delay between each batch. (For
    example, the command `sleep 3` could be used to delay for 3 seconds.) After uploading
    the captured images onto your computer, you can merge each batch into an HDR image,
    and then merge the HDR images into a time-lapse video.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的项目，你可能希望创建HDR延时视频。你可以通过修改我们的`capture_exposure_bracket.sh`脚本来开始，捕捉多批曝光包围的图像，每批之间有时间延迟。（例如，可以使用`sleep
    3`命令延迟3秒。）将捕获的图像上传到你的电脑后，你可以将每批合并成HDR图像，然后将HDR图像合并成延时视频。
- en: Explore other photographic techniques, and then try to automate them!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 探索其他摄影技术，然后尝试自动化它们！
- en: Further study
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步学习
- en: 'Computational photography is a diverse and popular field, which combines the
    work of artists, technicians, and scientists. Thus, there are many types of authors,
    instructors, and mentors who can help you become a better "computational photographer".
    Here are just a few examples of helpful guides:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 计算摄影是一个多样化和受欢迎的领域，它结合了艺术家、技术人员和科学家的工作。因此，有许多类型的作者、讲师和导师可以帮助你成为一名更好的“计算摄影师”。以下是一些有用的指南示例：
- en: '*Learning Image Processing with OpenCV*, by Gloria Bueno García et al (Packt
    Publishing, 2015), covers a wide range of OpenCV 3''s capabilities with respect
    to image capture, image editing, and computational photography. The book uses
    C++, and is suitable for beginners in computer vision.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《使用OpenCV学习图像处理》，作者格洛丽亚·布埃诺·加西亚等（Packt Publishing，2015年），涵盖了OpenCV 3在图像捕捉、图像编辑和计算摄影方面的广泛功能。本书使用C++编写，适合计算机视觉初学者。
- en: The *National Geographic Masters of Photography* video lectures (The Great Courses,
    2015) provide great insight into the goals and techniques of master photographers.
    Several of the lecturers are wildlife photographers, whose use of camera traps
    was an inspiration for this chapter.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《国家地理摄影大师视频讲座》（The Great Courses，2015年）提供了对大师摄影师目标和技术的深刻见解。几位讲师是野生动物摄影师，他们使用相机陷阱的做法为这一章节提供了灵感。
- en: '*OpenSource Astrophotography*, by Karl Sarnow (CreateSpace Independent Publishing
    Platform, 2013), covers the use of gPhoto2 and other open source software, along
    with photographic hardware, to capture and process detailed images of the night
    sky.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《开源天体摄影》，作者卡尔·萨诺（CreateSpace Independent Publishing Platform，2013年），涵盖了使用gPhoto2和其他开源软件，以及摄影硬件来捕捉和处理夜空详细图像的使用方法。
- en: '*Science for the Curious Photographer*, by Charles S. Johnson, Jr. (CRC Press,
    2010), explains the scientific history and principles of light, lenses, and photography.
    Moreover, it provides practical solutions to common photographic problems, such
    as selecting and setting up good equipment for macro photography.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《好奇摄影师的科学》，作者查尔斯·S·约翰逊（CRC Press，2010年），解释了光、镜头和摄影的科学历史和原理。此外，它还提供了解决常见摄影问题的实用解决方案，例如为微距摄影选择和设置良好的设备。
- en: Whether as a hobby or a profession, computational photography is a great way
    to explore and chronicle the world from a particular viewpoint. It requires observation,
    experimentation, and patience, so slow down! Take time to learn from other people's
    explorations, and to share yours.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是作为爱好还是职业，计算摄影都是一种探索和记录世界的绝佳方式，从特定的视角来看。它需要观察、实验和耐心，所以请放慢脚步！花时间从他人的探索中学习，并分享你的经验。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has demonstrated a set of surprisingly flexible commands and classes,
    which enable us to conduct experiments in computational photography, with short
    and simple code. We have written scripts to control a photo camera. Along the
    way, we have acquainted ourselves with gPhoto2, the Bash shell, PTP communication,
    GVFS mount points, and Python's support for subprocesses. We have also scripted
    several variations of a photo trap to take pictures when a subject comes into
    view. For this, OpenCV has provided us with the capability to detect motion, measure
    color similarities, and classify objects. Finally, we have used OpenCV to combine
    a set of photos into a time-lapse video or HDR image.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了一套令人惊讶的灵活的命令和类，使我们能够用简短和简单的代码进行计算摄影实验。我们已经编写了控制相机的脚本。在这个过程中，我们熟悉了gPhoto2、Bash
    shell、PTP通信、GVFS挂载点和Python对子进程的支持。我们还编写了几个照片陷阱的变体，以便在主题进入视野时拍照。为此，OpenCV为我们提供了检测运动、测量颜色相似性和分类对象的能力。最后，我们使用OpenCV将一组照片组合成时间流逝视频或HDR图像。
- en: So far, this book has provided a fairly broad survey of ways to capture light
    as data, control a camera, detect a subject, and process a photo. The remaining
    chapters will focus on a selection of advanced techniques, which will enable us
    to perform much finer classification and identification of an image's subject,
    and to process photos and videos in ways that account for camera motion and perspective.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这本书已经提供了一种相当广泛的概述，介绍了如何捕捉光作为数据、控制相机、检测主题以及处理照片的方法。接下来的章节将专注于一系列高级技术，这将使我们能够对图像的主题进行更精细的分类和识别，并且能够以考虑相机运动和视角的方式处理照片和视频。
