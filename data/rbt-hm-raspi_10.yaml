- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Using the PID Algorithm to Follow Walls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PID 算法跟随墙壁
- en: We built a robot with multiple sensors and used distance sensors in [*Chapter
    8*](B18001_08.xhtml#_idTextAnchor166), *Sensing Distances to Detect Objects with
    Pico*. We can use smarter algorithms with these sensors to make smoother behaviors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个具有多个传感器的机器人，并在[*第 8 章*](B18001_08.xhtml#_idTextAnchor166)，*使用 Pico 感测距离以检测物体*中使用了距离传感器。我们可以使用更智能的算法来使这些传感器的行为更平滑。
- en: In this chapter, we will investigate the PID algorithm, building its stages
    into something that will follow objects, then turning that into something that
    will follow a wall. We will use our new ability to graph over Bluetooth to tune
    the settings and get a smooth result.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究 PID 算法，将其阶段构建成能够跟随物体的东西，然后将其转化为能够跟随墙壁的东西。我们将使用我们通过蓝牙绘图的新能力来调整设置并获得平滑的结果。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing the PID algorithm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 PID 算法
- en: Using a PID to follow a wall
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PID 跟随墙壁
- en: PID tuning – using graphs to tune the PID
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PID 调节 – 使用图表调节 PID
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following items for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下物品来完成本章：
- en: The robot and code from [*Chapter 9*](B18001_09.xhtml#_idTextAnchor189), *Teleoperating
    Raspberry Pi Pico Robot with* *Bluetooth LE*
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人与代码来自[*第 9 章*](B18001_09.xhtml#_idTextAnchor189)，*使用蓝牙 LE 远程操作 Raspberry
    Pi Pico 机器人*
- en: An open space with room to move, and objects suitable for following
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有足够空间移动的开放空间，以及适合跟随的对象
- en: An Android/iOS device with the Bluefruit app
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有 Bluefruit 应用的 Android/iOS 设备
- en: A hand screwdriver with a 2 mm bit
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 2 毫米螺钉的螺丝刀
- en: Digital calipers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数显卡尺
- en: A pencil
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一支铅笔
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-10](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-10).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-10](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-10)找到本章的代码。
- en: Introducing the PID algorithm
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 PID 算法
- en: In this section, we will introduce the different parts of the PID algorithm
    while building on what you have already seen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 PID 算法的不同部分，同时基于您已经看到的内容进行构建。
- en: Control and feedback
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制和反馈
- en: 'Controlling robot systems generally depends on feedback loops like the following
    one:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 控制机器人系统通常依赖于如下所示的反馈回路：
- en: '![Figure 10.1 – Control and feedback loop ](img/Figure_10.01_B18001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 控制和反馈回路](img/Figure_10.01_B18001.jpg)'
- en: Figure 10.1 – Control and feedback loop
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 控制和反馈回路
- en: The preceding figure shows data from the sensors going into a control algorithm.
    The algorithm controls the motor as its output. The motor will cause the robot
    to move. This movement leads to a feedback loop as the sensor reading changes
    and goes through the cycle again. This concept is known as **closed-loop control**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了传感器数据进入控制算法。该算法以电机控制作为其输出。电机将使机器人移动。这种移动导致反馈回路，因为传感器读数发生变化并再次通过循环。这个概念被称为**闭环控制**。
- en: This closed-loop lets the robot interact with the real world, adjusting its
    behavior to produce the desired result.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭环系统使机器人能够与真实世界互动，调整其行为以产生所需的结果。
- en: We built a simple system like this for our distance sensors. We’ll look more
    closely at that system next.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的距离传感器构建了一个类似的简单系统。我们将在下一节更详细地研究那个系统。
- en: Bang-bang control
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 震荡控制
- en: 'In the examples provided in [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166),
    *Sensing Distances to Detect Objects with Pico*, the system compared the distance
    sensors on our robot against a threshold. For example, look at the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 8 章*](B18001_08.xhtml#_idTextAnchor166)，*使用 Pico 感测距离以检测物体*提供的示例中，系统将我们的机器人上的距离传感器与阈值进行比较。例如，看看以下图表：
- en: '![Figure 10.2 – Bang-bang motor control ](img/Figure_10.02_B18001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 震荡电机控制](img/Figure_10.02_B18001.jpg)'
- en: Figure 10.2 – Bang-bang motor control
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 震荡电机控制
- en: '*Figure 10**.2* summarizes **bang-bang control**. This control system has two
    modes. If the actual measurement is above the expected value and too far away,
    it will drive forward; otherwise, it assumes that it is below the value and too
    close and will drive backward. It will always drive in one of the directions and
    at a fixed motor power. Controlling with only a fixed power is known as **constant
    correction**.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.2* 总结了**bang-bang 控制**。这个控制系统有两个模式。如果实际测量值高于预期值且距离太远，它将前进；否则，它假设它低于该值且太近，将后退。它将始终朝一个方向以固定的电机功率行驶。仅用固定功率进行控制被称为**恒定校正**。'
- en: 'This method is simple and suitable in some situations, but occasionally, something
    smoother is needed. What if we wanted the robot’s motor power to change depending
    on how far away it is from the object? We’ll need to calculate an error value,
    as shown in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简单且在某些情况下适用，但有时需要更平滑的处理。如果我们希望机器人的电机功率根据其与物体的距离变化，该怎么办？我们需要计算一个误差值，如下面的图所示：
- en: '![Figure 10.3 – Calculating an error value ](img/Figure_10.03_B18001.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 计算误差值](img/Figure_10.03_B18001.jpg)'
- en: Figure 10.3 – Calculating an error value
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 计算误差值
- en: '*Figure 10**.3* shows how we calculate the error value. By subtracting the
    actual value from the expected, we will get the error. This error will change
    in magnitude, depending on how different things are, and change in direction,
    depending on which side of the expected measurement the actual measurement falls.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.3* 展示了如何计算误差值。通过从预期值减去实际值，我们将得到误差。这个误差将根据事物之间的差异程度改变大小，并根据实际测量值落在预期测量的哪一侧改变方向。'
- en: 'If we multiply this error by some value, this could be turned into a motor
    speed, such that a higher magnitude error will lead to a larger motor movement.
    This process will form the feedback control loop shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个误差乘以某个值，这可以转化为电机速度，使得较大的误差幅度将导致更大的电机运动。这个过程将形成这里所示的反馈控制回路：
- en: '![Figure 10.4 – A proportional feedback loop ](img/Figure_10.04_B18001.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 比例反馈回路](img/Figure_10.04_B18001.jpg)'
- en: Figure 10.4 – A proportional feedback loop
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 比例反馈回路
- en: '*Figure 10**.4* builds upon *Figure 10**.1*, feeding an error value through
    a multiplier (or gain) to calculate the motor speed, which moves the robot. Robot
    movement feedback changes the sensor reading. With the right gain value, this
    robot will slow down as it approaches the object.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.4* 基于 *图 10.1*，通过乘法器（或增益）传递误差值来计算电机速度，从而移动机器人。机器人运动反馈改变传感器的读数。通过合适的增益值，这个机器人在接近物体时会减速。'
- en: Multiplying the error value to control the output like this is known as **proportional
    control**, which is one part of the system we are building. The amount by which
    we multiply the error is known as the **proportional gain**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将误差值乘以以这种方式控制输出被称为**比例控制**，这是我们正在构建的系统的一部分。我们乘以误差的量被称为**比例增益**。
- en: At this point, I think we are ready to write the code for this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我认为我们已经准备好编写这段代码了。
- en: Distance sensing with proportional control
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比例控制距离感应
- en: In this section, we’ll write code to approach an object and maintain the expected
    distance from the object. Create a folder on the host named `proportional-distance-control`.
    We’ll copy the content of this folder into the top directory on the Pico. We can
    also copy the robot and `pio_encoder` files there.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写代码来接近一个物体并保持与物体的预期距离。在主机上创建一个名为 `proportional-distance-control` 的文件夹。我们将把这个文件夹的内容复制到
    Pico 的顶级目录中。我们也可以将机器人和 `pio_encoder` 文件复制到那里。
- en: 'Add a `code.py` file, starting with imports and enabling the UART:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `code.py` 文件，从导入和启用 UART 开始：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can add our proportional controller as a class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的比例控制器作为一个类添加：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code lets us make proportional controller (`PController`) objects with
    a proportional gain, `kp`. We can call the `calculate` method with an error value
    to get the control value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码让我们可以创建具有比例增益 `kp` 的比例控制器 (`PController`) 对象。我们可以使用误差值调用 `calculate` 方法来获取控制值。
- en: 'Let’s set up a sensor:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个传感器：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We make a set point of 10 cm for our expected distance. Then, we have our `distance_controller`,
    which is using the `PController` object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将预期距离的设定点设为 10 厘米。然后，我们有我们的 `distance_controller`，它使用 `PController` 对象。
- en: When our robot is further away, we need to drive forward, so we need to use
    a negative proportional gain. The motor speeds are between -1 and 1, so -0.1 will
    reduce the distance by a tenth and negate it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的机器人距离更远时，我们需要向前行驶，因此我们需要使用负比例增益。电机速度在-1和1之间，所以-0.1将减少十分之一的距离并取反。
- en: 'The main loop will only check the `PController` when there’s a new distance
    reading:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环仅在有新的距离读取时才会检查`PController`：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use this with the set point to calculate the error and feed it into
    the proportional controller:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个设置点来计算误差，并将其输入到比例控制器中：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While we’re here, we can send the numbers to the UART (so that we can plot
    them). We have a speed from the error. Now, we can send this speed to both motors:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里时，我们可以将这些数字发送到UART（这样我们就可以绘制它们）。我们有一个来自误差的速度。现在，我们可以将这个速度发送到两个电机：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we must reset the sensor for another reading and delay it a little:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须重置传感器以进行另一次读取并稍微延迟：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Send this code to the robot. If you place an object in front of the robot, it
    will find and hold a position about 10 cm from the object. You should also be
    able to plot the output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码发送到机器人。如果您在机器人前方放置一个物体，它将找到并保持距离物体大约10厘米的位置。您也应该能够绘制输出。
- en: The motors here may be beeping a lot; this is not good for them and will make
    them hot. We can use code to establish a **dead zone**, where we expect the control
    output to be too small for the motors to respond and turn them off instead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的电机可能会频繁发出蜂鸣声；这对它们来说不好，并且会使它们变热。我们可以使用代码来建立一个**死区**，在这个区域内，我们期望控制输出对电机来说太小，以至于无法响应，并关闭它们。
- en: 'Add the following code after the speed calculation to stop the beeping:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在速度计算后添加以下代码以停止蜂鸣声：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code uses `abs` to get the magnitude of the speed only. If the magnitude
    is below 0.3, it sends a `0` instead. I found `0.3` experimentally, but this may
    be different on your robot.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用`abs`仅获取速度的大小。如果大小低于0.3，它将发送一个`0`。我在实验中找到了`0.3`，但这可能因机器人而异。
- en: Before continuing, you should test this on the robot and check the next section
    if this behavior did not try to find the distance to the object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您应该在机器人上测试此功能，并在此行为没有尝试找到物体距离的情况下检查下一节。
- en: Troubleshooting
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'The following are some solutions to try if you aren’t getting the follow behavior
    to work:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有得到以下行为正常工作，以下是一些可以尝试的解决方案：
- en: First, check the distance sensor functionality using the [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166)
    code. Then, verify the sensor and motor connections.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用[*第8章*](B18001_08.xhtml#_idTextAnchor166)的代码检查距离传感器的功能。然后，验证传感器和电机连接。
- en: If the robot is driving the wrong way, reverse the proportional constant.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人行驶方向错误，请反转比例常数。
- en: There is a problem where this robot may get close to the right place but leave
    a gap for small distances. As a result, it might not generate a speed large enough
    to move the motors. In the next section, we’ll see why.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个问题，这个机器人可能接近正确位置，但留下小距离的间隙。结果，它可能不会产生足够大的速度来移动电机。在下一节中，我们将看到原因。
- en: Using the integral to handle small distances
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用积分处理小距离
- en: 'The following graph shows a small error remaining after activity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了活动后剩余的小误差：
- en: '![Figure 10.5 – Small remaining error ](img/Figure_10.05_B18001.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 剩余的小误差](img/Figure_10.05_B18001.jpg)'
- en: Figure 10.5 – Small remaining error
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 剩余的小误差
- en: The preceding figure shows a graph of the error and motor output versus time.
    The error line varies by up to 10 units. The motor graph is more flat. This line
    is between 0 and 1 and in the opposite direction, as expected from the proportional
    experiment. The graph is divided into two portions. Portion A shows the robot
    moving as we move an object closer and further away, with the motor responding.
    In portion B, we gradually move the object, creating a small error of -1\. This
    small error results in a speed of 0.1, which is insufficient to move.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了误差和电机输出随时间变化的图表。误差线变化幅度达10个单位。电机图更平坦。这条线在0到1之间，与预期的比例实验相反。图表分为两部分。部分A显示了当我们移动一个物体靠近和远离时，机器人移动，电机响应。在部分B中，我们逐渐移动物体，产生一个小的-1误差。这个小的误差导致速度为0.1，不足以移动。
- en: What we have is a **steady-state error**. The system has not converged on the
    set point and will not act further to reduce the error.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是一个**稳态误差**。系统尚未收敛到设置点，并且不会进一步采取行动来减少误差。
- en: 'This situation is where the integral element is useful. The **integral** is
    equivalent to an area under a graph. Look at the following graph for an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下，积分元素是有用的。**积分**相当于图表下的一个面积。看看下面的图表作为例子：
- en: '![Figure 10.6 – Plotting the integral ](img/Figure_10.06_B18001.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 绘制积分](img/Figure_10.06_B18001.jpg)'
- en: Figure 10.6 – Plotting the integral
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 绘制积分
- en: This graph has two elements. The bars represent the error value from the previous
    graph, approximated as discrete time steps. Then, there’s the thick line over
    this, which represents the integral. While the graph varies, the integral varies
    perhaps a little later. However, when it reaches a steady state, the graph starts
    to pull downwards continuously.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表有两个元素。柱状图代表前一个图表中的误差值，近似为离散的时间步。然后，还有覆盖在这个上面的粗线，代表积分。虽然图表在变化，但积分可能稍后变化。然而，当它达到稳态时，图表开始持续向下拉动。
- en: 'If we take this and multiply it by another small constant, we can cause the
    motors to move a little to iron out a steady-state error. We call this the `ki`.
    The following diagram shows the control system with the integral term:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个值乘以另一个小的常数，我们可以使电机稍微移动以消除稳态误差。我们称之为`ki`。以下图示显示了包含积分项的控制系统：
- en: '![Figure 10.7 – The feedback loop with the integral ](img/Figure_10.07_B18001.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 带积分的反馈回路](img/Figure_10.07_B18001.jpg)'
- en: Figure 10.7 – The feedback loop with the integral
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 带积分的反馈回路
- en: The preceding diagram shows the feedback loop control system with the integral
    added – this box shows *I * ki*, the integral multiplied by an integral gain.
    It feeds into the motor speed, which is added to the proportional output. The
    integral is given the same error term as the proportional element.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了添加了积分的反馈回路控制系统 – 这个框显示了*I * ki*，积分乘以积分增益。它输入到电机速度中，并添加到比例输出中。积分被赋予了与比例元素相同的误差项。
- en: The integral will store the area of the error graph seen until this point. This
    would be the area under a graph. How do we calculate the area? We can take each
    error and multiply it by the time interval during which it was produced. Adding
    this to a running total represents a good approximation of the area.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 积分将存储到目前为止看到的误差图面积。这将是图表下的面积。我们如何计算面积？我们可以将每个误差乘以它产生的持续时间。将这些加到运行总和中，代表面积的良好近似。
- en: The following code extends the previous example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码扩展了前面的例子。
- en: 'Let’s update the `PController` code so that it’s a `PIController` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`PController`代码，使其成为`PIController`类：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we added `ki` as an integral gain to scale our integral.
    We also store an integral total, starting at `0`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了`ki`作为积分增益来缩放我们的积分。我们还存储了一个积分总和，从`0`开始。
- en: Important Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Prefixing gain constants like these with *k* is due to them being treated as
    *constants* by the PID algorithm, but the outer code can tune these. So, mathematically,
    this is a constant, but not a constant in the code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在PID算法中将像这样的增益常数用*k*前缀表示，是因为它们被视为*常数*，但外部代码可以调整这些值。所以，从数学上讲，这是一个常数，但在代码中并不是一个常数。
- en: 'Then, we must change the `calculate` method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须更改`calculate`方法：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`calculate` now adds the error to the integral, which means the integral will
    continue moving in the error direction. However, we will multiply this by the
    elapsed time (or delta time, `dt`), so that a longer interval between measurements
    will result in a larger area. The last line multiplies the current integral by
    the integral gain.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate`现在将误差添加到积分中，这意味着积分将继续在误差方向上移动。然而，我们将乘以经过的时间（或时间差，`dt`），这样较长的测量间隔将导致更大的面积。最后一行将当前积分乘以积分增益。'
- en: 'We’ll need to set the integral constant when we create the controller:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建控制器时，我们需要设置积分常数：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The values of `–0.19` and `–0.005` work for my robot. We will learn how to tune
    these later in the chapter. The integral constant should be negative in this case
    and small. Larger values will cause overshoots, and the system will go back and
    forth (oscillate).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`–0.19`和`–0.005`的值适用于我的机器人。我们将在本章后面学习如何调整这些值。在这种情况下，积分常数应该是负的且较小。较大的值会导致超调，系统会来回移动（振荡）。'
- en: 'We can now alter the main loop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改主循环：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The highlighted changes start with the time delta calculations. We keep a previous
    time (`prev_time`) so that we can subtract this from `current_time` later and
    feed this time difference into the controller with the error. Next, we store `current_time`
    in `prev_time` so that we are ready for the next loop. The `time.monotonic` function
    provides a time in seconds with fractions, guaranteeing that subsequent calls
    cannot return a lower value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的变化始于时间差计算。我们保留上一个时间（`prev_time`），以便稍后从`current_time`中减去，并将这个时间差与误差一起输入控制器。接下来，我们将`current_time`存储在`prev_time`中，以便我们为下一个循环做好准备。`time.monotonic`函数提供了一个带有分数的秒数时间，保证后续调用不会返回更低的值。
- en: 'We also send the current integral value to the UART to plot it. Send this code
    to the robot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将当前积分值发送到UART以进行绘图。将此代码发送到机器人：
- en: '![Figure 10.8 – Oscillation versus smaller integral ](img/Figure_10.08_B18001.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 振荡与较小的积分](img/Figure_10.08_B18001.jpg)'
- en: Figure 10.8 – Oscillation versus smaller integral
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 振荡与较小的积分
- en: In *Figure 10**.8 (a)* the screenshot shows an error with a large integral gain.
    This rise makes the motors move and carry on while the system overshoots, until
    the integral flips the other way - this causes oscillation. In *Figure 10**.8
    (b)* the integral gain is much lower, so the integral must reach a higher value
    before it creates a change. The motors respond to the proportional change first,
    but the integral makes a slight adjustment later. This setting may still oscillate
    a tiny amount, but the oscillations will be slow and subtle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.8（a）*的屏幕截图显示了一个具有大积分增益的误差。这种上升使得电机移动并继续工作，直到系统超调，直到积分反向翻转——这导致振荡。在*图10.8（b）*中，积分增益要低得多，因此积分必须达到更高的值才能产生变化。电机首先对比例变化做出反应，但积分稍后进行轻微调整。这种设置可能仍然会有微小的振荡，但振荡会缓慢而微妙。
- en: Note that when the robot corrects the steady state and the error reaches zero,
    this doesn’t reduce the integral.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当机器人纠正稳态并使误差达到零时，这并不会减少积分。
- en: Important Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Stop the code (or robot) if the wheels/motors are not moving the robot forward,
    and restart the code when the wheels are in contact with the floor or motors are
    turned on (they are on battery power only). Otherwise, the system can build up
    a large integral and will ram the next object placed in front of it. This problem
    is known as **integral wind-up** and can be a big problem if you do not account
    for it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果车轮/电机没有使机器人向前移动，请停止代码（或机器人），当车轮接触地面或电机开启（它们仅使用电池供电）时，重新启动代码。否则，系统可能会积累大量的积分，并将撞到其前面的下一个物体。这个问题被称为**积分风车效应**，如果不加以考虑，可能会成为一个大问题。
- en: Some overshoot here is inevitable, but the system is reacting to steady-state
    errors. This PI controller will work, but if you move the target object quickly,
    you may still be able to induce oscillation. How can we dampen that? We’ll see
    how in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一些超调是不可避免的，但系统正在对稳态误差做出反应。这个PID控制器将工作，但如果快速移动目标物体，你仍然可能能够引起振荡。我们如何在下一节中减弱它？我们将看到。
- en: Dealing with oscillations using the derivative
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导数处理振荡
- en: Oscillations are made due to sudden state changes, creating a large reacting
    output, which can cause a large change of state in the opposite direction. This
    may repeat on either side of the set point. The state change is equivalent to
    a slope on a graph at any point.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于状态突然变化，产生了大量的反应输出，这可能导致状态在相反方向上发生大幅变化。这种情况可能在设定点的两侧重复发生。状态变化相当于图表上任意点的斜率。
- en: 'The following graph shows a varying value, with the slopes marked at a few
    points:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了变化值，并在几个点上标出了斜率：
- en: '![Figure 10.9 – Slopes on a graph ](img/Figure_10.09_B18001.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 图表上的斜率](img/Figure_10.09_B18001.jpg)'
- en: Figure 10.9 – Slopes on a graph
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 图表上的斜率
- en: The preceding graph shows an error PID response settling. Along the graph are
    dots, with dashed lines showing the slope. The derivative represents this slope
    at any point.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了误差PID响应的稳定。在图表上，有一些点，虚线显示了斜率。导数代表任意点的这个斜率。
- en: The essential factor is that when there is a steep change in the error, there
    is a steeper slope. This slope value is the **derivative**. It represents the
    rate of change in our system. Using this value with a gain can reduce overshoot,
    dampening the system. So, we could add this along with the PI components and dampen
    the movement a little.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关键因素是当误差有急剧变化时，其斜率也会更陡。这个斜率值就是**导数**。它代表我们系统中变化的速度。使用这个值与增益结合可以减少超调，抑制系统。因此，我们可以添加这个值以及
    PI 元件，稍微抑制运动。
- en: 'However, before we do that, there is another issue: the output from the distance
    sensors is a little noisy. The following zoomed-in view shows noise on the sensor
    when the robot is not moving:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，还有一个问题：距离传感器的输出有点噪声。以下放大视图显示了当机器人不移动时传感器上的噪声：
- en: '![Figure 10.10 – Noise from the sensor ](img/Figure_10.10_B18001.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 传感器的噪声](img/Figure_10.10_B18001.jpg)'
- en: Figure 10.10 – Noise from the sensor
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 传感器的噪声
- en: The preceding screenshot is enlarged to show the sensor data noise. One of the
    lines is frequently going above or below the line. This noise is slight but makes
    many fast changes in the slope.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图放大以显示传感器数据噪声。其中一条线经常高于或低于该线。这种噪声很小，但会使斜率发生许多快速变化。
- en: Using the derivative directly with this noise may cause our robot to produce
    large movements. To reduce this, we will use a **low pass filter** in front of
    the integral. This only allows sustained error movements in, filtering out the
    constant jiggle of noise.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用导数与这种噪声结合可能会导致我们的机器人产生大幅度的运动。为了减少这种情况，我们将在积分之前使用一个**低通滤波器**。这仅允许持续的误差运动进入，过滤掉噪声的恒定抖动。
- en: 'Let’s see this as a feedback control diagram:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其视为一个反馈控制图：
- en: '![Figure 10.11 – Feedback flow for the PID controller ](img/Figure_10.11_B18001.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – PID 控制器的反馈流程](img/Figure_10.11_B18001.jpg)'
- en: Figure 10.11 – Feedback flow for the PID controller
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – PID 控制器的反馈流程
- en: '*Figure 10**.11* extends *Figure 10**.7* by adding two additional blocks. First,
    the error splits through a block labeled LPF – this is a low pass filter, with
    a stylized frequency graph showing how this tails off for higher frequencies.
    The LPF block feeds into the next block – the derivative multiplied by a `kd`
    derivative gain. This block has a stylized graph showing the slope lines. The
    derivative output is then added to the other PI outputs to make the motor speed
    signal.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.11* 通过添加两个额外的模块扩展了 *图 10.7*。首先，误差通过一个标记为 LPF 的模块，这是一个低通滤波器，其风格化的频率图显示了对于更高频率的衰减。LPF
    模块输入到下一个模块 – 导数乘以 `kd` 导数增益。这个模块有一个风格化的图表显示了斜率线。然后，导数输出被添加到其他 PI 输出，以生成电机速度信号。'
- en: 'Now that we have seen how this operates, let’s modify the code, starting with
    the PID class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了它是如何工作的，让我们修改代码，从 PID 类开始：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we add two additional construction parameters to the `PIDController`
    class – a derivative gain, `kd`, and a derivative filter gain. We also store a
    previous error to calculate the difference from the current error. The `calculate`
    function also changes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向 `PIDController` 类添加了两个额外的构造参数 – 一个导数增益，`kd`，和一个导数滤波器增益。我们还存储一个之前的误差来计算当前误差的差值。`calculate`
    函数也发生了变化：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We need the difference between the current error and the previous error. We
    multiply this difference by the filter gain, and add this onto the previous error.
    This means that the error changes by a smoothed out amount and sets us up for
    the next calculation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要当前误差与之前误差之间的差值。我们将这个差值乘以滤波器增益，并将其加到之前的误差上。这意味着误差以平滑的量变化，为我们进行下一次计算做好准备。
- en: The next line divides this difference by the change in time, to get the rate
    of change. We store this in `self.derivative` so that we can graph this term later.
    Finally, we multiply `self.derivative` by the `d` gain (`kd`) and add this to
    the calculations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将这个差值除以时间的变化，以得到变化率。我们将这个值存储在 `self.derivative` 中，以便我们可以在以后绘制这个项。最后，我们将 `self.derivative`
    乘以 `d` 增益（`kd`）并将其添加到计算中。
- en: The PID controller is now complete. We can make this reusable by moving the
    `PIDController` class into a `pid_controller.py` file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PID 控制器现在已完成。我们可以通过将 `PIDController` 类移动到 `pid_controller.py` 文件中来使其可重用。
- en: 'The `code.py` file can use `pid_controller` like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`code.py` 文件可以这样使用 `pid_controller`：'
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The highlighted parts of the code show how this changed from the previous `code.py`
    example. First, we imported the `PIDController` class. Then, we swapped our use
    of `PIController` for `PIDController`. PID tuning parameters are tuned as we expand
    on this code. Adding additional terms, such as the derivative, will make tuning
    the others necessary.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中高亮的部分展示了如何从之前的`code.py`示例中做出改变。首先，我们导入了`PIDController`类。然后，我们将`PIController`的使用替换为`PIDController`。随着我们对这段代码的扩展，PID调整参数将被调整。添加额外的项，如导数，将使得调整其他参数成为必要。
- en: We send the error and time difference into the controller calculation to get
    the speed, then send the derivative to the UART to see what our robot is doing
    and tune the parameters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将误差和时间差发送到控制器计算中，以获取速度，然后将导数发送到UART，以查看我们的机器人正在做什么并调整参数。
- en: With that, we’ve built a PID controller and used it to keep a certain amount
    of distance from an object. We’ll make this into a more dynamic example in the
    next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经构建了一个PID控制器，并使用它来保持与物体的特定距离。我们将在下一节将其变成一个更动态的例子。
- en: Using PID to follow a wall
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PID跟随墙壁
- en: 'Driving along a wall using the PID algorithm requires a little more coordination.
    Let’s visualize the problem with a diagram:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PID算法沿墙壁行驶需要更多的协调。让我们用一个图表来可视化这个问题：
- en: '![Figure 10.12 – The robot following a wall ](img/Figure_10.12_B18001.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – 机器人跟随墙壁](img/Figure_10.12_B18001.jpg)'
- en: Figure 10.12 – The robot following a wall
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 机器人跟随墙壁
- en: '*Figure 10**.12* shows how our robot will follow a wall. First, the robot drives
    forward in the direction shown by the solid line with an arrow. We have turned
    the sensor out so that it can detect the wall in its cone (these distance sensors
    cover around 20 degrees). Based on the return of a close object (shown as a dashed
    line), the robot will adjust its heading to try and keep a constant distance.
    When the robot faces the wall, it will curve outward, and it may overshoot, but
    also, there is a step change in the wall, so the robot will adjust its path and
    straighten up.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10**.12* 展示了我们的机器人如何跟随墙壁。首先，机器人沿着由实线箭头指示的方向前进。我们将传感器向外转动，以便它能在其锥形区域内检测到墙壁（这些距离传感器覆盖大约20度）。根据接近物体的返回值（以虚线表示），机器人将调整其航向以尝试保持恒定的距离。当机器人面对墙壁时，它会向外弯曲，可能会超出预定距离，但墙壁上有一个阶跃变化，因此机器人将调整其路径并直行。'
- en: We have a few issues. First, we have put the motors a little forward, and turning
    the sensor with the current placement would have the wheel in the path of the
    sensor, so we’ll need to move them back. Then, we’ll need to make that 90-degree
    sensor turn. After, we’ll need to use the PID to determine how much to change
    the robot’s heading, a deflection, as the robot drives forward.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个问题。首先，我们将电机放置得有点靠前，并且使用当前的位置转动传感器会使轮子进入传感器的路径，所以我们需要将它们向后移动。然后，我们需要进行90度的传感器转向。之后，我们需要使用PID来确定在机器人前进时需要调整机器人航向的程度，即偏转，作为机器人前进的一部分。
- en: Let’s start by making some changes to move the sensor.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先做一些改动来移动传感器。
- en: Changing the sensor’s placement
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变传感器的位置
- en: We will need to make some changes to our CAD sketches, then use a drawing to
    drill some holes. Note that with the front of the robot facing down in the CAD
    sketches, the left-hand side of the CAD sketch is for the robot’s right-hand side.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们的CAD草图做一些改动，然后使用绘图来钻一些孔。注意，在CAD草图上，机器人面向下方时，草图左侧对应于机器人的右侧。
- en: 'The following FreeCAD screenshots show how to make the CAD changes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下FreeCAD截图显示了如何进行CAD更改：
- en: '![Figure 10.13 – FreeCAD sketches for turning the sensor sideways ](img/Figure_10.13_B18001.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 将传感器侧置的FreeCAD草图](img/Figure_10.13_B18001.jpg)'
- en: Figure 10.13 – FreeCAD sketches for turning the sensor sideways
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 将传感器侧置的FreeCAD草图
- en: The left-hand screenshot of *Figure 10**.13* shows how we move the motor back
    in the `UpperParts` sketch. First, delete the horizontal constraint between the
    bottom corner of the motor (shown on the left) and the breadboard. Then, add an
    18 mm vertical dimension between the same two points. Moving the motor back 18
    mm gives ample space for the sensor, but it will also mean we can reuse one of
    the existing holes since the distance between them is 18 mm. In addition, the
    two motors have symmetry constraints so that they will move together. Now, you
    can close this sketch.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.13* 的左侧截图显示了我们在 `UpperParts` 绘图中如何将电机向后移动。首先，删除电机底部角落（如图左侧所示）和面包板之间的水平约束。然后，在这两个相同点之间添加一个
    18 毫米的垂直尺寸。将电机向后移动 18 毫米为传感器提供了足够的空间，但这也意味着我们可以重用其中一个现有的孔，因为它们之间的距离是 18 毫米。此外，两个电机有对称约束，这样它们就会一起移动。现在，你可以关闭这个草图。'
- en: The right-hand side of *Figure 10**.13* is a screenshot of the sketch for an
    additional front sensor hole at 90 degrees. Import the existing distance sensor
    holes as external geometry. Then, use construction lines to constrain the distance
    between this hole and the top outer hole so that it is equal to the distance between
    the initial distance sensor holes. Add an equals constraint on the circles and
    a perpendicular constraint between the lines. You can make a similar circle on
    the other side, although we will only use one sensor for this demonstration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.13* 的右侧是草图截图，显示了一个额外的 90 度前传感器孔。将现有的距离传感器孔作为外部几何形状导入。然后，使用构造线约束这个孔和顶部外侧孔之间的距离，使其等于初始距离传感器孔之间的距离。在圆上添加等距约束，在线之间添加垂直约束。你可以在另一侧做类似的圆，尽管我们在这个演示中只会使用一个传感器。'
- en: 'The following figure shows the CAD drawing and parts fitted in new positions
    on the robot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 CAD 绘图和机器人上新的位置安装的部件：
- en: '![Figure 10.14 – The drawing and result of this robot change ](img/Figure_10.14_B18001.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 机器人变化的绘图和结果](img/Figure_10.14_B18001.jpg)'
- en: Figure 10.14 – The drawing and result of this robot change
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 机器人变化的绘图和结果
- en: The left-hand side of the preceding figure shows the drawing. I’ve marked the
    new holes, using the existing ones as a reference. You will need to detach the
    motors and sensors to do this – unbolt them but leave the wiring connected and
    put them carefully to one side while doing this. After removing the motors, attach
    one side of the motor bracket and use the hole on the other side of the bracket
    to mark the new hole.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前一张图的左侧显示了绘图。我已用现有的孔作为参考标记了新的孔。你需要拆卸电机和传感器来完成这项工作——卸下螺栓，但保持电线连接，并小心地将它们放在一边。在移除电机后，安装电机支架的一侧，并使用支架另一侧的孔来标记新的孔。
- en: With the distance sensor, remove the inner bolt, then turn it to face out 90
    degrees. You can then use the inner bolt hole to mark where to drill.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用距离传感器，卸下内六角螺栓，然后将其旋转 90 度朝外。然后，你可以使用内六角螺栓孔来标记钻孔的位置。
- en: The right-hand side of the preceding figure shows the motor and sensor moved
    into position. Ensure that the connections are still correct.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前一张图的右侧显示了电机和传感器已经移动到正确的位置。请确保连接仍然正确。
- en: This robot is ready for us to write wall-following code on it. Let’s see how.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机器人已经准备好供我们编写墙面跟随代码。让我们看看如何。
- en: Wall-following code
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 墙面跟随代码
- en: Wall following is an extension of the code we’ve already been working on, with
    a few key differences. First, our robot will drive at a constant speed, but depending
    on the sensor feedback, it will steer closer to/farther from the wall. It can
    do this by adding a PID output to the speed of one side and subtracting it from
    another.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 墙面跟随是我们在之前已经工作的代码的一个扩展，有一些关键的不同之处。首先，我们的机器人将以恒定的速度行驶，但根据传感器的反馈，它将更靠近/远离墙壁。它可以通过向一侧的速度添加
    PID 输出，并从另一侧减去它来实现这一点。
- en: 'Start by taking a copy of the previous code example. We’ll make changes to
    `code.py`. The imports and setup stay the same:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，复制之前的代码示例。我们将对 `code.py` 进行修改。导入和设置保持不变：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, along with the other settings, we must add a base speed for the robot
    to drive. The distance set point should also be further out:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了其他设置之外，我们必须为机器人添加一个基本速度。距离设定点也应该更远：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have set up the PID here so that you can tweak its settings.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里设置了 PID，这样你就可以调整其设置。
- en: 'The main loop gets the sensor data and error in the same way:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环以相同的方式获取传感器数据和错误：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we calculate the PID, we now store it in `deflection`, describing how
    fast we will turn:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计算 PID 时，我们现在将其存储在 `deflection` 中，描述我们将如何快速转向：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We write this to the UART so that we can plot and debug it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其写入 UART，以便我们可以绘制和调试它：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code uses this deflection by adding it to the right motor speed and subtracting
    it from the left. This deflection should pull us toward the set point, a distance
    from the wall, while driving forward:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过将其添加到右侧电机速度中并从中减去左侧来使用这种偏转。这种偏转应该在我们向前行驶时将我们拉向设定点，即离墙壁的距离：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finish by resetting the sensor and sleeping a bit before looping:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过重置传感器并在循环之前稍微休息来完成：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can send this to the robot and start it near a wall, and it may try to follow
    it. I’ve found a few boxes in the middle of the room good as it can drive around
    them; however, it will likely struggle with anything concave.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个指令发送给机器人，并在靠近墙壁的地方启动它，它可能会尝试跟随它。我发现房间中间的几个箱子很好，因为它可以绕着它们行驶；然而，它可能很难处理任何凹形物体。
- en: The result of this may be unstable, so we’ll need to tune this PID. However,
    even if unstable, it should try to follow the wall, even if it collides.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结果可能是不稳定的，因此我们需要调整这个 PID。然而，即使不稳定，它也应该尝试跟随墙壁，即使它发生碰撞。
- en: Troubleshooting
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'Try these steps if the robot isn’t following or starting:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器人不跟随或启动，请尝试以下步骤：
- en: First, check the distance sensor wiring; now that you’ve moved it, the wires
    may have been dislodged. [*Chapter 8*](B18001_08.xhtml#_idTextAnchor166), *Sensing
    Distances to Detect Objects with Pico*, contains guides on sensor wiring if you
    need to check this.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，检查距离传感器的接线；现在你已经移动了它，线可能已经被松动了。[*第 8 章*](B18001_08.xhtml#_idTextAnchor166)，*使用
    Pico 检测物体距离的感应*，其中包含有关传感器接线的指南，如果你需要检查这一点。
- en: Ensure you have a fresh set of batteries – this won’t work well on low batteries.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你有全新的电池组 – 在低电量下这不会很好地工作。
- en: If the robot is spinning, put it closer to the wall, and if it is reacting too
    hard, bring down the P value. We’ll tune this more shortly.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人正在旋转，请将其靠近墙壁，如果它反应过于激烈，请降低 P 值。我们将在稍后调整它。
- en: You should now have a robot that is kind of following the wall but may be quite
    unstable or crashing somewhat. To make this work well, we’ll need to tune the
    PID.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该有一个机器人，它有点在跟随墙壁，但可能非常不稳定或有时会撞到。为了使它工作得更好，我们需要调整 PID。
- en: PID tuning – using graphs to tune the PID
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PID 调节 – 使用图表来调整 PID
- en: The PID algorithm is great for responding to sensor input, adjusting for constant
    errors, and dampening out overcompensation with the derivative. The only problem
    is that getting these three values right is tricky. How you tune a PID depends
    on the system. In our case, for wall following, much of this will be on how the
    robot feels in the situation. This method works for small robots, but there are
    formal methods that require a mathematical model of the system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: PID 算法对于响应传感器输入、调整恒定误差以及通过导数来抑制过度补偿是非常好的。唯一的问题是正确获取这三个值是棘手的。如何调整 PID 取决于系统。在我们的案例中，对于跟随墙壁，这很大程度上取决于机器人在这种情况下的感觉。这种方法适用于小型机器人，但还有一些需要系统数学模型的形式化方法。
- en: Depending on the situation, we may only use one constant, but for this, we’ll
    try to use all three. It’s also a good practice to change only one gain constant
    at a time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况，我们可能只使用一个常数，但为了这个目的，我们将尝试使用所有三个。同时，一次只更改一个增益常数也是一个好的实践。
- en: We already have graphing for our system on the phone. While we are starting,
    we’ll only show the error and response; we can add other components as needed.
    The derivative and integral components can dwarf the proportional component, and
    the Bluefruit app does not allow plots with different scales on the same graph.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在手机上为我们的系统有了图表。当我们开始时，我们只会显示错误和响应；根据需要我们可以添加其他组件。导数和积分组件可能会使比例组件相形见绌，而 Bluefruit
    应用程序不允许在同一图表上使用不同比例的绘图。
- en: We are also going to add some controls other than graphing. Otherwise, you’ll
    be plugging the robot in to reprogram a lot! So, let’s start with some basic controls.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一些除了图表之外的控件。否则，你将需要经常插上机器人来重新编程！所以，让我们从一些基本控件开始。
- en: Controlling motor speed
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制电机速度
- en: First, we’ll need the ability to start and stop our motors. Currently, our system
    starts with motors live and running. Turning the motors off or slowing things
    down will make tuning far less frustrating.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要能够启动和停止我们的电机。目前，我们的系统以电机开启和运行的状态启动。关闭电机或减慢速度将使调整变得不那么令人沮丧。
- en: 'The motor speeds are down to the PWM system. The current PWM settings on our
    robot have a frequency of 500 Hz. This is a little high for DC motors, which means
    they can stall (stop) at low speeds. So, we’ll reduce the motor PWM frequency.
    In `robot.py`, make the highlighted changes on the matching lines:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 电机速度由PWM系统控制。我们机器人的当前PWM设置频率为500 Hz。这对直流电机来说有点高，这意味着它们在低速时可能会卡住（停止）。因此，我们将降低电机PWM频率。在`robot.py`中，对匹配的行进行高亮显示的更改：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `code.py`, we will modify our system to allow motors to be turned off:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`code.py`中，我们将修改我们的系统以允许关闭电机：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we’ll want to add UART control:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将想要添加UART控制：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`if` checks for waiting commands; if we have one, we read in a line of input
    and decode it. `strip` removes the line end character.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`检查等待的命令；如果有，我们读取一行输入并对其进行解码。`strip`移除行尾字符。'
- en: 'Now, we can start checking for commands:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始检查命令：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code means we can send the robot an instruction such as `M0.7` via the
    Bluefruit UART app, and the straight motor speed will be 0.7.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着我们可以通过Bluefruit UART应用向机器人发送指令，例如`M0.7`，并且直线电机速度将为0.7。
- en: 'We also want to be able to activate/deactivate the motors:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够激活/停用电机：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can stop or start the motors by sending the `G` instruction to the robot.
    This handler toggles the `motors_active` variable. It will always stop the motors.
    The next loop cycle will turn them on only if it’s active, ensuring they stop.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向机器人发送`G`指令来停止或启动电机。这个处理程序切换`motors_active`变量。它将始终停止电机。在下一次循环周期中，只有当它处于活动状态时，才会打开它们，确保它们停止。
- en: Finally this resets the integral to avoid integral wind up while the motors
    are not running. Having the integral running while the robot cannot act to counter
    it is known as **integral wind-up** and can cause big problems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这会将积分重置，以避免在电机不运行时积分累积。当机器人无法采取行动来抵消它时，运行积分被称为**积分累积**，可能会引起大问题。
- en: 'We can test this with the existing proportional and send it to the robot. You
    should be able to test the instructions from the UART panel in the Bluefruit app:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用现有的比例控制来测试这个功能，并将其发送到机器人。你应该能够在Bluefruit应用中的UART面板上测试指令：
- en: '`G` -> Enable/disable robot motors: think Go/Stop.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G` -> 启用/停用机器人电机：想想前进/停止。'
- en: '`M<speed>` -> Set the motor speed: this should be between 0.3 and 1.0\. It
    will likely not move under 0.3\. This will behave incorrectly at negative speeds,
    and the motor code truncates values above 1.0.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M<速度>` -> 设置电机速度：这应该在0.3和1.0之间。它可能不会在0.3以下移动。在负速度下，它将表现不正确，并且电机代码会截断大于1.0的值。'
- en: Now that you have control of the robot, let’s figure out how to tweak the proportional
    component.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经控制了机器人，让我们来看看如何调整比例组件。
- en: The proportional component
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比例组件
- en: The proportional gain constant, `pk`, is the starting point and is usually dominant
    in a system. Multiplying the error by `pk` will create the most immediate reaction
    to a sensor.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 比例增益常数，`pk`，是起点，通常在系统中占主导地位。将误差乘以`pk`将对传感器产生最直接的反应。
- en: 'We can start by adding code to change the proportional constant:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从添加代码来更改比例常数开始：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code checks for the input, `P<proportional gain>`, and uses it in the
    same way as the motor speed. When you type a value, the proportional constant
    is updated. So, let’s review the state of the robot by adding an instruction to
    inspect these:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查输入，`P<比例增益>`，并以与电机速度相同的方式使用它。当你输入一个值时，比例常数将被更新。所以，让我们通过添加一个指令来检查机器人的状态：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This handler for `?` will print the PID constants and speed settings. The `.3f`
    annotation encodes the value as a number with 3 decimal places. Because the robot
    usually outputs the graph values via UART, we pause for 3 seconds here. Do not
    use this command with the motors active.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序用于`?`，将打印PID常数和速度设置。`.3f`注解将值编码为带有3位小数的数字。因为机器人通常通过UART输出图形值，所以我们在这里暂停3秒钟。不要在电机运行时使用此命令。
- en: 'When we send this to the robot, we have two additional control abilities:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向机器人发送这个指令时，我们有两个额外的控制能力：
- en: '`P0.045` -> Set the proportional gain value to `0.045`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P0.045` -> 将比例增益值设置为`0.045`。'
- en: '`?` -> Print the current state:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?` -> 打印当前状态：'
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Send this to the robot. Before we engage the motors (`G`), let’s consider a
    good proportional value. For this example, we expect an error between 5 and -5,
    giving us a range of 10 cm. Corners will go beyond this and set the turning at
    full (saturation, maximum value). With a speed of 0.7, to turn back, we would
    need an output of -1.4\. We can divide 1.4 by 10, giving us a starting guess of
    0.14\. Send `P0.14` to set this and `G` to start the robot moving.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到机器人。在我们启动电机（`G`）之前，让我们考虑一个良好的比例值。对于这个例子，我们期望误差在5到-5之间，给我们10厘米的范围。角落会超出这个范围并设置全转向（饱和，最大值）。以0.7的速度，要反转，我们需要-1.4的输出。我们可以将1.4除以10，得到一个起始猜测值0.14。发送`P0.14`来设置这个值，并使用`G`来启动机器人移动。
- en: 'This setting is responding but has some oscillation. Use `G` to stop it. We
    will use trial and error here by halving the P value and trying again. We can
    test this and use two rules:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置正在响应但有一些振荡。使用`G`来停止它。我们将通过减半P值并再次尝试来使用试错法。我们可以测试这一点并使用两条规则：
- en: If the robot is oscillating too much, divide the value by 2.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人振荡得太厉害，将值除以2。
- en: If the robot responds too slowly, multiply by 1.5 (the value between here and
    the previous one is high).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人响应得太慢，乘以1.5（这里的值与上一个值之间较高）。
- en: This method lets us home in on a value. When you find values that you like,
    you can put them back into `code.py` to keep for later. Use `?` to see the last
    `P` setting you had.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法让我们能够聚焦到一个值。当你找到你喜欢的值时，你可以把它们放回`code.py`中以便稍后使用。使用`?`来查看你最后的`P`设置。
- en: 'The following screenshot shows how this looks on the graph output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了这在图表输出中的样子：
- en: '![Figure 10.15 – Proportional response ](img/Figure_10.15_B18001.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 比例响应](img/Figure_10.15_B18001.jpg)'
- en: Figure 10.15 – Proportional response
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 比例响应
- en: The preceding phone screenshot shows a graph with only a proportional response.
    The X axis specifies the time in seconds. The Y axis is the distance in cm for
    the error, but more arbitrary for the output value. The error has a higher range
    in tens of cms. The robot is driving around some obstacles. The huge swings are
    when it reaches a corner and drives around it. The blue line shows the PID output
    and the deflection. The deflection scale is usually below 1, but the large swings
    will take it above that. Motor speeds are clamped between -1.0 and 1.0, so those
    large corners will saturate the motors, making the robot turn on the spot.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的电话截图显示了一个只有比例响应的图表。X轴指定秒数。Y轴是厘米单位的误差距离，但对于输出值来说更为任意。误差在几十厘米的范围内有更高的范围。机器人正在绕一些障碍物行驶。当它到达一个角落并绕过它时，会有巨大的摆动。蓝色线显示PID输出和偏转。偏转刻度通常在1以下，但大摆动会超过这个值。电机速度被限制在-1.0和1.0之间，所以那些大角落会使电机饱和，使机器人原地转动。
- en: In summary, a high proportional gain will make a system respond quickly, but
    it will overshoot and may even start to oscillate. Too low, and it will not respond
    fast enough.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，高的比例增益会使系统快速响应，但它会超调，甚至可能开始振荡。太低，它将不会足够快地响应。
- en: A proportional-only system can oversteer when there are larger changes. We want
    to damp this out. We’ll adjust the *D* component to deal with this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当有较大的变化时，只有比例的系统可能会过度转向。我们希望将其抑制。我们将调整*D*组件来处理这个问题。
- en: Adjusting the derivative gain
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整导数增益
- en: The derivative component allows the robot to deal with large changes in the
    error and react by either damping or pulling harder if there’s a sudden change,
    such as oversteering, running out of wall (a corner), or finding a step change
    in the wall.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 导数组件允许机器人处理误差的大变化，并通过增加或减少力度来反应，例如在突然变化时，如过度转向、墙角（角落）或找到墙的阶跃变化。
- en: 'Let’s modify our code to make it easier to work with the derivative. In `code.py`,
    add `,{distance_controller.derivative}` to the `uart.write` line after we calculate
    the deflection:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的代码，使其更容易处理导数。在`code.py`中，在计算偏转后，在`uart.write`行后添加`,{distance_controller.derivative}`：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need to control the derivative. Add the following after the `P` command
    handler:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要控制导数。在`P`命令处理程序之后添加以下内容：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, this sets a simple pattern, the same as `P`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这设置了一个简单的模式，与`P`相同。
- en: 'Now, we can start this with half the P value, `D0.035`, which results in fewer
    collisions with occasional bouncing. The following screenshot shows the robot
    going around boxes:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用一半的P值，`D0.035`，来启动它，这会导致碰撞减少，偶尔弹跳。下面的截图显示了机器人绕盒子行驶：
- en: '![Figure 10.16 – Initial derivative graph ](img/Figure_10.16_B18001.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 初始导数图表](img/Figure_10.16_B18001.jpg)'
- en: Figure 10.16 – Initial derivative graph
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 初始导数图
- en: The preceding graph shows the derivative in orange, overlaid on the error in
    red, and the output in blue. Note that the derivative spikes are very large but
    can sometimes be the opposite sign of the error allowing it to dampen changes.
    The largest spikes are still walls. Between 10 and 15 seconds, the derivative
    dampens the proportional output.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了橙色中的导数，叠加在红色中的误差上，以及蓝色中的输出。请注意，导数尖峰非常大，但有时可以是误差的相反符号，允许它抑制变化。最大的尖峰仍然是墙壁。在10到15秒之间，导数抑制了比例输出。
- en: 'A sudden distance increase, such as the end of a wall, can cause strong oscillation,
    as shown in the following graph:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 突然的距离增加，例如墙壁的尽头，可以导致强烈的振荡，如下面的图表所示：
- en: '![Figure 10.17 – Strong derivative oscillations ](img/Figure_10.17_B18001.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – 强烈的导数振荡](img/Figure_10.17_B18001.jpg)'
- en: Figure 10.17 – Strong derivative oscillations
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 强烈的导数振荡
- en: In the preceding screenshot, at around 42 seconds, the robot encounters a concave
    step. That step caused the derivative to overshoot, pushing the robot right out.
    However, this put the sensor past the obstacle and detected a long-range distance,
    going rapidly from too close to too far. The derivative swings strongly back the
    other way – time to stop with `G`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图，大约42秒时，机器人遇到了一个凹形台阶。这个台阶导致导数超调，将机器人推到了右边。然而，这使传感器超出了障碍物，检测到了长距离，从太近到太远快速变化。导数强烈地向另一边摆动
    – 是时候用`G`停止了。
- en: 'We can roughly half the value again to `0.017` for another attempt, but it
    will still have the same issue. We need to be more aggressive with reducing `D`
    than we were with `P`. We can divide the proportional constant by 10 (`0.0035`)
    for a more stable robot. The resulting plot looks as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将值再次减半到`0.017`进行另一次尝试，但它仍然会有同样的问题。我们需要比`P`更积极地减少`D`。我们可以将比例常数除以10（`0.0035`）以获得更稳定的机器人。结果图如下所示：
- en: '![Figure 10.18 – The tuned derivative graph ](img/Figure_10.18_B18001.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – 调整后的导数图](img/Figure_10.18_B18001.jpg)'
- en: Figure 10.18 – The tuned derivative graph
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 调整后的导数图
- en: The preceding screenshot shows a graph with the same properties as *Figure 10**.17*
    but using a `0.0035` setting. While the corners still show up as large spikes,
    the blue output graph is now calmer, with the derivative dampening the output.
    The robot will now be driving quite smoothly.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了一个与*图10.17*具有相同特性的图表，但使用了`0.0035`设置。虽然角落仍然显示为大的尖峰，但蓝色输出图现在更平静，导数抑制了输出。现在机器人将驾驶得相当平稳。
- en: We may need a slightly different scenario to tune the integral.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要一个稍微不同的场景来调整积分。
- en: Tuning the integral
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整积分
- en: In an environment with many step changes, such as driving around boxes in a
    room, the integral will not play as much of a part. Not every problem requires
    all three parts of the PID, and in this case, the integral may not be particularly
    suitable. Let’s set this nice and slow and find a long straight wall. I had to
    use a garden path for this (and change some values to suit).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有许多阶跃变化的环境中，例如在房间中绕盒子驾驶，积分将不会扮演那么大的角色。不是每个问题都需要PID的所有三个部分，在这种情况下，积分可能不太合适。让我们将其设置得既好又慢，并找到一个长直墙。我不得不使用花园小径来做这个（并改变一些值以适应）。
- en: Let’s add the integral control and output to the `code.py` file first. The output
    is swapping `{distance_controller.derivative}` for `{distance_controller.integral}`
    in the output line.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将积分控制和输出添加到`code.py`文件中。输出行中将`{distance_controller.derivative}`替换为`{distance_controller.integral}`。
- en: 'We can also add this to the control handling:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其添加到控制处理中：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will accept a command such as `I0.001` to set the integral. This is also
    a good starting value. We now have a comprehensive control system.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将接受一个如`I0.001`的命令来设置积分。这也是一个好的起始值。我们现在有一个全面的控制系统。
- en: Send `M0.35` to reduce the speed. We can send half the `P` and `D` values to
    match, using `?` to see what they were. Send `I0.001` and then `G` to start the
    robot against a long straight wall.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 发送`M0.35`以降低速度。我们可以发送一半的`P`和`D`值以匹配，使用`?`查看它们的值。发送`I0.001`然后`G`以启动机器人对抗一堵长直墙。
- en: You should see some large adjustments as the `P` and `D` terms settle; then,
    the `I` term will settle more slowly. Observe the graph while driving.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当`P`和`D`项稳定下来时，你应该会看到一些大的调整；然后，`I`项将更慢地稳定。在驾驶时观察图表。
- en: For this term, the strategy I use is settling on a small value and slowly incrementing
    it if the reaction to a constant error is too slow. Like the other terms, making
    this too high will lead to instability. If the starting point of `0.001` pushes
    the system into instability, divide it by 10 and slowly increment that.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个术语，我使用的策略是在一个小的值上稳定下来，如果对恒定误差的反应太慢，就慢慢增加它。和其他术语一样，如果起点`0.001`使系统不稳定，就将其除以10，并慢慢增加那个值。
- en: You now have a strategy to tune PID values on a robot, along with a control
    system to do so.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有了在机器人上调整PID值的方法，以及一个用于此目的的控制系统。
- en: Closing notes on tuning
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整的结束语
- en: Tuning a PID will take time. Algorithms such as Ziegler-Nichols can be used
    to solve this with mathematical modeling and will work in some situations.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 调整PID需要时间。可以使用Ziegler-Nichols等算法通过数学建模来解决这个问题，并在某些情况下有效。
- en: Another thing to note is that changes in the system response, such as its turning
    circle, will alter things. For example, driving a robot on a carpet causes drag
    on the wheels, making turning slower. If a PID was tuned to work well on carpet,
    putting the same robot on wooden flooring may cause it to oversteer as its steering
    effort results in larger changes. Tune a PID for a particular behavior to the
    environment where you expect it to be operating.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，系统响应的变化，如转弯半径，会改变事情。例如，在地毯上驾驶机器人会在轮子上产生阻力，使转弯变慢。如果PID调整得很好，在木地板上放置相同的机器人可能会导致它过度转向，因为其转向努力导致更大的变化。为特定环境中的特定行为调整PID。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The PID controller is a great way to build robot behavior that adjusts to sensor
    input. In this chapter, you learned what a PID controller and its components are,
    including where a low-pass filter makes it behave better.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: PID控制器是构建能够根据传感器输入调整的机器人行为的一种好方法。在本章中，你学习了PID控制器及其组件是什么，包括低通滤波器如何使其表现更好。
- en: The PID controller allows for dynamic responses but requires a lot of tuning
    to get it right. You’ve seen how to add a wireless control method, which is essential
    for tuning a PID. You’ve also observed the graphs of PID systems, understanding
    how they relate to their operations and tuning.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: PID控制器允许动态响应，但需要大量调整才能正确设置。你已经看到了如何添加无线控制方法，这对于调整PID至关重要。你也观察了PID系统的图表，了解了它们如何与它们的操作和调整相关。
- en: In the next chapter, we will be taking our PID controller and using it with
    encoders to drive in straight lines.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用PID控制器并与编码器一起使用，以直线行驶。
- en: Exercises
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'These exercises will deepen your understanding of the topics discussed in this
    chapter and make the robot code better:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习将加深你对本章讨论主题的理解，并使机器人代码更加完善：
- en: Enhance the settings code so that the set point can be adjusted in the same
    way. `S<set point>` is probably a good idea.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强设置代码，以便可以以相同的方式调整设定点。`S<设定点>`可能是一个好主意。
- en: Modify the command handlers for setting PID values to stop the motors and reset
    the integral when these values change.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改设置PID值的命令处理程序，以便在更改这些值时停止电机并重置积分。
- en: Try adapting the control code back to the distance control app used earlier
    in this chapter.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将控制代码调整回本章早期使用的距离控制应用。
- en: Try the robot wall-follow when driving on a completely different surface and
    adjust the PID values to get a smooth wall following.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在完全不同的表面上驾驶机器人，并调整PID值以实现平滑的墙壁跟随。
- en: Further reading
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These study aids will let you read on and dive deeper into the PID algorithm
    and its quirks:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这些学习辅助工具将帮助你继续阅读并深入了解PID算法及其特性：
- en: 'Christopher Lam on YouTube has an excellent control theory video course: [https://www.youtube.com/playlist?list=PLxdnSsBqCrrF9KOQRB9ByfB0EUMwnLO9o](https://www.youtube.com/playlist?list=PLxdnSsBqCrrF9KOQRB9ByfB0EUMwnLO9o).
    This uses MATLAB and goes into detail about control systems such as PID, tuning
    them, problems with them, modeling them, and analyzing them. There are at least
    30 hours of content that takes a very mathematical approach.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YouTube上的Christopher Lam有一个出色的控制理论视频课程：[https://www.youtube.com/playlist?list=PLxdnSsBqCrrF9KOQRB9ByfB0EUMwnLO9o](https://www.youtube.com/playlist?list=PLxdnSsBqCrrF9KOQRB9ByfB0EUMwnLO9o)。这个课程使用MATLAB，详细介绍了PID等控制系统，包括它们的调整、问题、建模和分析。内容至少有30小时，采用非常数学的方法。
- en: For a deeper dive into PID control systems, consider *PID-based Practical Digital
    Control with Raspberry Pi and Arduino Uno* from Elektor Electronics. This book
    discusses control theory, transform functions, and PID tuning, while providing
    code and practical examples.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要深入了解PID控制系统，可以考虑Elektor Electronics出版的《*基于PID的实用数字控制：使用Raspberry Pi和Arduino
    Uno*》。这本书讨论了控制理论、变换函数和PID调整，同时提供了代码和实际示例。
- en: '*PID Control Fundamentals*, by Jens Graf, published via CreateSpace, is a comprehensive
    look at PID control systems. This provides more detail on each of the components
    and building PI, PD, and full PID algorithm control systems.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*PID控制基础*》，作者Jens Graf，由CreateSpace出版，全面探讨了PID控制系统。它提供了对每个组件的更多细节，以及构建PI、PD和完整PID算法控制系统的方法。
