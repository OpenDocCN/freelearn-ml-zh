- en: '*Chapter 9*: Using the Deployed TPOT Model in Production'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：在生产中使用部署的 TPOT 模型'
- en: You've made it to the final chapter – congratulations! So far, you've learned
    the basics of TPOT by solving classification and regression tasks, how TPOT works
    with Dask and neural networks, and how to deploy machine learning models both
    locally and to the cloud.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经到达了最后一章——恭喜！到目前为止，您通过解决分类和回归任务学习了 TPOT 的基础知识，了解了 TPOT 如何与 Dask 和神经网络协同工作，以及如何在本地和云端部署机器学习模型。
- en: This chapter will serve as icing on the cake, as you'll learn how to communicate
    with your deployed models to build something even a 5-year-old could use. To be
    more precise, you'll learn how to communicate with your API through a notebook
    environment and a simple GUI web application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将作为甜点，因为您将学习如何与您的部署模型进行通信，以构建即使是 5 岁的孩子也能使用的东西。更具体地说，您将学习如何通过笔记本环境和简单的 GUI
    网页应用程序与您的 API 进行通信。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Making predictions in a notebook environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在笔记本环境中进行预测
- en: Developing a simple GUI web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个简单的 GUI 网页应用程序
- en: Making predictions in a GUI environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GUI 环境中进行预测
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This is the last chapter in the book, so some prior knowledge is assumed. You
    need to know how to build basic machine learning models with TPOT to deploy them.
    It's assumed that your model is deployed to the AWS virtual machine created in
    [*Chapter 8*](B16954_08_Final_SK_ePub.xhtml#_idTextAnchor093)*, TPOT Model Deployment*.
    If that's not the case, please revisit that chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，因此假设您有一些先验知识。您需要知道如何使用 TPOT 构建基本的机器学习模型以便部署。假设您的模型已部署到在 [*第 8 章*](B16954_08_Final_SK_ePub.xhtml#_idTextAnchor093)*，TPOT
    模型部署*中创建的 AWS 虚拟机上。如果不是这种情况，请回顾该章节。
- en: 'This chapter will be quite code-heavy, so you can refer to the official GitHub
    repository if you get stuck: [https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09](https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包含大量的代码，如果您遇到困难，可以参考官方 GitHub 仓库：[https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09](https://github.com/PacktPublishing/Machine-Learning-Automation-with-TPOT/tree/main/Chapter09)。
- en: Making predictions in a notebook environment
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记本环境中进行预测
- en: 'If you took a day''s (or a few days'') break after the previous chapter, it''s
    likely that your connection to the remote virtual machine ended. Because of that,
    you''ll need to reconnect and start the API once again. There are ways to make
    your API always running, but that''s out of the scope of this book. Furthermore,
    if you''ve moved the `TPOT_Book_KeyPair.pem` file to some other folder, you''ll
    have to reset the permissions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在上一章之后休息了一天（或几天），那么您与远程虚拟机的连接可能已经结束。因此，您需要重新连接并再次启动 API。有方法可以使您的 API 总是运行，但这超出了本书的范围。此外，如果您已将
    `TPOT_Book_KeyPair.pem` 文件移动到其他文件夹，您将需要重置权限：
- en: 'With that in mind, execute the first command line from the following snippet,
    only if you have to reset the permissions:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，如果您需要重置权限，请仅执行以下片段中的第一个命令行：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your API is running now. The next step is to open a JupyterLab or Jupyter Notebook
    environment and make a request. You''ll need the `requests` library to do so,
    so here''s how to import it:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的 API 正在运行。下一步是打开 JupyterLab 或 Jupyter Notebook 环境，并发出请求。您需要 `requests` 库来完成此操作，以下是导入它的方法：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s declare a couple of variables next. These will hold the values for the
    host name, port, and endpoint:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，让我们声明几个变量。这些变量将保存主机名、端口和端点的值：
- en: '[PRE2]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From there, we can easily concatenate these three variables into a single one
    to form a URL:'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从那里，我们可以轻松地将这三个变量连接成一个，形成一个 URL：
- en: '[PRE3]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s how it should look:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是它应该看起来像的样子：
- en: '![Figure 9.1 – URL connection string'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.1 – URL 连接字符串'
- en: '](img/B16954_09_1.jpg)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B16954_09_1.jpg]'
- en: Figure 9.1 – URL connection string
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.1 – URL 连接字符串
- en: Yours will be a bit different due to the difference in the hostname.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于主机名的差异，您的操作可能略有不同。
- en: 'Next, we''ll declare a dictionary that will serve as input data. It will be
    identical to the data sent in the previous chapter through Postman. Here''s the
    code snippet:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将声明一个字典，它将作为输入数据。它将与通过 Postman 发送的上一章中的数据相同。以下是代码片段：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's all we need to make a request. Let's do that next.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是我们需要进行请求的所有内容。让我们接下来这么做。
- en: 'You can use the `post()` function from the `requests` package to make a POST
    request. Two parameters are required – the URL and the data in JSON format:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `requests` 包中的 `post()` 函数来发送 POST 请求。需要两个参数——URL 和 JSON 格式的数据：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The results are displayed in the following figure:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果将在以下图中显示：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s how the response looks:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是响应的外观：
- en: '![Figure 9.3 – API response as a string'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.3 – API 响应作为字符串
- en: '](img/B16954_09_3.jpg)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_09_3.jpg]'
- en: Figure 9.3 – API response as a string
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.3 – API 响应作为字符串
- en: As you can see, the prediction is returned successfully but not in the desired
    format by default.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，预测成功返回了，但默认情况下不是所需的格式。
- en: 'To change that, you''ll need to transform the response string to a JSON object.
    You can use the `loads()` function from the `json` package to do so:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要改变这一点，你需要将响应字符串转换为 JSON 对象。你可以使用 `json` 包中的 `loads()` 函数来完成此操作：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here are the results:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '![Figure 9.4 – API response as a JSON object'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 9.4 – API 响应作为 JSON 对象]'
- en: '](img/B16954_09_4.jpg)'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_09_4.jpg]'
- en: Figure 9.4 – API response as a JSON object
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.4 – API 响应作为 JSON 对象
- en: 'You can access the predicted class (or any other property) just as you would
    for a normal dictionary object. Here''s an example:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以像访问普通字典对象一样访问预测的类别（或任何其他属性）。以下是一个示例：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And here''s what''s returned:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是返回的内容：
- en: '![Figure 9.5 – API predicted class'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – API 预测类别]'
- en: '](img/B16954_09_5.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16954_09_5.jpg]'
- en: Figure 9.5 – API predicted class
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – API 预测类别
- en: And that's essentially how you can obtain predictions from a deployed REST API
    with Python! In the next section, you'll build a basic interactive web application
    around this API to make it utterly simple for anyone to use.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是你可以使用 Python 从部署的 REST API 获取预测的方法！在下一节中，你将围绕这个 API 构建一个基本的交互式网络应用程序，使其对任何人来说都极其简单易用。
- en: Developing a simple GUI web application
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发一个简单的 GUI 网络应用程序
- en: 'This section aims to demonstrate how the `Flask` framework can be used to develop
    a simple web application. The focus is shifted toward building an application
    that captures form data, which is then passed to our deployed machine learning
    API:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在展示如何使用 `Flask` 框架开发一个简单的网络应用程序。重点转向构建一个捕获表单数据的应用程序，然后将其传递到我们部署的机器学习 API：
- en: To start, create the following directory structure:![Figure 9.6 – Web application
    directory structure
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建以下目录结构：![图 9.6 – 网络应用程序目录结构]
- en: '](img/B16954_09_6.jpg)'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B16954_09_6.jpg]'
- en: Figure 9.6 – Web application directory structure
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.6 – 网络应用程序目录结构
- en: Most of the logic is handled in `app.py`, and the `templates` folder is used
    to store HTML files for the app – more on that in a bit.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大部分逻辑都在 `app.py` 中处理，而 `templates` 文件夹用于存储应用中的 HTML 文件——稍后我会详细介绍这一点。
- en: 'This time we''ll organize the code a bit better, so you''ll need to create
    an additional file for storing the environment variables. Inside the root directory
    (`webapp`), create a file called `.env` – and populate it with the following:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们将更好地组织代码，因此你需要创建一个额外的文件来存储环境变量。在根目录 (`webapp`) 中创建一个名为 `.env` 的文件——并填充以下内容：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating a separate file like this is considered to be a best practice when
    developing any sort of web application.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建这样的单独文件被认为是开发任何类型的网络应用程序的最佳实践。
- en: 'To use these environment variables, you''ll have to install an additional package
    to your virtual environment:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用这些环境变量，你需要在虚拟环境中安装一个额外的包：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s build the basic structure of the application now. Open the `app.py`
    file and write the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来构建应用程序的基本结构。打开 `app.py` 文件并编写以下代码：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you were to run the application now, you wouldn''t get an error, but nothing
    would be displayed on the screen. The reason is simple – we haven''t handled the
    `index.html` file yet. Before we do so, let''s discuss the only potentially unfamiliar
    part of code: the `render_template()` function. Put simply, this function will
    display an HTML file instead of showing merely a string or value returned from
    the function. There''s a way to pass parameters, but more on that later.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你不会得到错误，但屏幕上不会显示任何内容。原因是简单的——我们还没有处理 `index.html` 文件。在我们这样做之前，让我们讨论代码中唯一可能不熟悉的部分：`render_template()`
    函数。简单地说，这个函数将显示一个 HTML 文件，而不是显示函数返回的字符串或值。有一种方法可以传递参数，但稍后再说。
- en: 'Onto the `index.html` now – here''s the code you can paste inside the file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `index.html`——以下是你可以粘贴到文件中的代码：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Don't worry if you haven't written a line of HTML before – it's a simple markup
    language. Think of everything you see here as boilerplate. It's what's inside
    the `<body></body>` tag that we're interested in.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你之前没有写过一行HTML，不要担心——它是一种简单的标记语言。把这里看到的一切都当作样板。我们感兴趣的是`<body></body>`标签内的内容。
- en: 'If you were to run your application now, here''s how it would look:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在运行你的应用程序，它看起来会是这样：
- en: '![Figure 9.7 – Iris prediction application (v1)'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.7 – 爱尔兰预测应用程序（v1）'
- en: '](img/B16954_09_7.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_09_7.jpg)'
- en: Figure 9.7 – Iris prediction application (v1)
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.7 – 爱尔兰预测应用程序（v1）
- en: It's a simple and utterly boring web application, but at least it works.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单且极其无聊的Web应用程序，但至少它工作了。
- en: 'As mentioned before, our web application has to handle form data somehow, so
    let''s start working on that. There''s a dedicated package for handling form data
    with `Flask` called `Flask-WTF`. Here''s how you can install it:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们的Web应用程序必须以某种方式处理表单数据，因此让我们开始工作。有一个专门的包用于处理`Flask`中的表单数据，称为`Flask-WTF`。以下是安装它的方法：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: from flask_wtf import FlaskForm
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from flask_wtf import FlaskForm
- en: from wtforms import FloatField, SubmitField
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from wtforms import FloatField, SubmitField
- en: from wtforms.validators import DataRequired
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from wtforms.validators import DataRequired
- en: 'class IrisForm(FlaskForm):'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'class IrisForm(FlaskForm):'
- en: sepal_length = FloatField(
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sepal_length = FloatField(
- en: label='Sepal Length', validators=[DataRequired()]
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: label='花瓣长度', 验证器=[DataRequired()]
- en: )
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: sepal_width = FloatField(
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sepal_width = FloatField(
- en: label='Sepal Width', validators=[DataRequired()]
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: label='花瓣宽度', 验证器=[DataRequired()]
- en: )
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: petal_length = FloatField(
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: petal_length = FloatField(
- en: label='Petal Length', validators=[DataRequired()]
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: label='花瓣长度', 验证器=[DataRequired()]
- en: )
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: petal_width = FloatField(
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: petal_width = FloatField(
- en: label='Petal Width', validators=[DataRequired()]
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: label='花瓣宽度', 验证器=[DataRequired()]
- en: )
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: submit = SubmitField(label='Predict')
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: submit = SubmitField(label='预测')
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Onto the `app.py` now. A couple of changes are required:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`app.py`。需要做一些更改：
- en: '`Flask-WTF` forms need a secret key configured to work. You can add it by accessing
    the `.env` file. What you declare as a value is entirely arbitrary.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-WTF`表单需要一个配置好的密钥才能工作。你可以通过访问`.env`文件来添加它。你声明的值完全是任意的。'
- en: Our index route now needs to allow for both POST and GET methods since it will
    handle forms. Inside the `index()` function, you'll have to instantiate the previously
    written `IrisForm` class and return relevant results if there are no validation
    errors once the submit button is clicked.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在的索引路由需要允许POST和GET方法，因为它将处理表单。在`index()`函数内部，你将需要实例化之前编写的`IrisForm`类，并在点击提交按钮且没有验证错误时返回相关结果。
- en: You can use the `validate_on_submit()` function to check. If the check is passed,
    the input data is returned in a heading format (we'll see how to show predictions
    later). If not, the `index.html` template is returned.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用`validate_on_submit()`函数进行检查。如果检查通过，输入数据将以标题格式返回（我们稍后会看到如何显示预测）。如果没有通过，则返回`index.html`模板。
- en: A call to `render_template()` now passes a parameter to our HTML file – `iris_form`.
    This gives access to form data to our HTML file. You'll see how to deal with it
    in a minute.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在调用`render_template()`时，会传递一个参数到我们的HTML文件——`iris_form`。这给了HTML文件访问表单数据的能力。你将在下一分钟看到如何处理它。
- en: 'Here''s how your file should look once the changes are made:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是更改后你的文件应有的样子：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We're almost there. Let's tweak the `index.html` file next.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们几乎完成了。让我们接下来调整`index.html`文件。
- en: '`index.html` is the last file you''ll need to tweak to have a working application.
    The only thing we need inside it is a form that displays the fields declared earlier.
    It''s also mandatory to protect your app from **Cross-Site Request Forgery** (**CSRF**)
    attacks. To do so, you''ll have to place a token before the form fields.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`index.html`是你需要调整以使应用程序工作的最后一个文件。我们需要的只是显示之前声明的字段的表单。同时，保护你的应用程序免受**跨站请求伪造**（**CSRF**）攻击也是强制性的。为此，你必须在表单字段之前放置一个令牌。'
- en: 'Here''s how the HTML file should look:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是HTML文件应有的样子：
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, to access parameters sent from the Python file, you have to
    surround the code with double curly brackets.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，要访问从Python文件发送的参数，你必须用双大括号包围代码。
- en: 'If you were to launch the application now, here''s what you''d see on the screen:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在启动应用程序，屏幕上会显示以下内容：
- en: '![Figure 9.8 – Iris prediction application'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 – 爱尔兰预测应用程序'
- en: '](img/B16954_09_8.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_09_8.jpg)'
- en: Figure 9.8 – Iris prediction application
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 爱尔兰预测应用程序
- en: And that's a frontend for your machine learning application! It's a bit ugly,
    but we'll style it later. Let's test the functionality first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的机器学习应用的前端！它有点丑陋，但我们稍后会对其进行美化。让我们先测试一下功能。
- en: 'We don''t want the form submitted if any of the input values are empty. Here''s
    what happens if the button is pressed immediately:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望表单在任何一个输入值都为空的情况下被提交。如果立即按下按钮，会发生以下情况：
- en: '![Figure 9.9 – Iris prediction application form validation (1)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – 爱尔兰预测应用表单验证（1）'
- en: '](img/B16954_09_9.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16954_09_9.jpg](img/B16954_09_9.jpg)'
- en: Figure 9.9 – Iris prediction application form validation (1)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 爱尔兰预测应用表单验证（1）
- en: 'Validation test 1 – check. Let''s see what happens if only one input field
    remains empty:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 验证测试 1 – 完成。让我们看看如果只有一个输入字段为空会发生什么：
- en: '![Figure 9.10 – Iris prediction application form validation (2)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.10 – 爱尔兰预测应用表单验证（2）'
- en: '](img/B16954_09_10.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16954_09_10.jpg](img/B16954_09_10.jpg)'
- en: Figure 9.10 – Iris prediction application form validation (2)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 爱尔兰预测应用表单验证（2）
- en: The same message occurs, just as you would expect. To conclude, the form can't
    be submitted if any of the input fields are empty.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了同样的消息，正如你所期望的那样。为了总结，如果任何一个输入字段为空，表单将无法提交。
- en: 'To continue, fill out all of the fields, as shown in the following figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，填写所有字段，如图所示：
- en: '![Figure 9.11 – Iris prediction application form values'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – 爱尔兰预测应用表单值'
- en: '](img/B16954_09_11.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16954_09_11.jpg](img/B16954_09_11.jpg)'
- en: Figure 9.11 – Iris prediction application form values
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 爱尔兰预测应用表单值
- en: 'If you were to click on the button now, here''s the result you''d see:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在点击按钮，你会看到以下结果：
- en: '![Figure 9.12 – Iris prediction application results'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 爱尔兰预测应用结果'
- en: '](img/B16954_09_12.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16954_09_12.jpg](img/B16954_09_12.jpg)'
- en: Figure 9.12 – Iris prediction application results
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 爱尔兰预测应用结果
- en: So far, everything works, but there's still one step we should do before connecting
    the application to our Iris prediction API – styling. This step is optional, as
    the application will still work if you decide to jump to the API connection part
    immediately.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切正常，但在将应用连接到我们的爱尔兰预测 API 之前，我们还需要做一步——美化。这一步是可选的，因为如果你决定立即跳到 API 连接部分，应用仍然可以工作。
- en: 'Setting adequate styles to your Flask application will require a bit of work
    and refactoring. You''ll find the entire list of steps here. Keep in mind that
    this book assumes no HTML and CSS knowledge. You''re free to copy and paste the
    content of these files but are encouraged to explore further on your own:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的 Flask 应用设置适当的样式需要一点工作和重构。你可以在这里找到整个步骤列表。请注意，这本书假设没有 HTML 和 CSS 知识。你可以自由地复制粘贴这些文件的内容，但鼓励你自己进一步探索：
- en: Let's start with `app.py`. Instead of returning an `H2` tag with input values
    printed as a single long string, we'll return an HTML template that will show
    a table. For now, we'll fill out the input data only and set dummy values for
    prediction and prediction probability.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 `app.py` 开始。我们不会返回一个包含打印为单个长字符串的输入值的 `H2` 标签，而是返回一个将显示表格的 HTML 模板。现在，我们只填写输入数据，并为预测和预测概率设置假值。
- en: 'Here''s how the file should look after the changes:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是更改后的文件应该看起来是什么样子：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's create a template file while we're at it. Under `/templates`, create a
    `predicted.html` file. As mentioned earlier, this file will contain a table showing
    the API response (once we implement it).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在做这件事的同时创建一个模板文件。在 `/templates` 目录下创建一个 `predicted.html` 文件。如前所述，这个文件将包含一个显示
    API 响应的表格（一旦我们实现它）。
- en: 'Here''s how the file should look:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是文件应该看起来是什么样子：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we've utilized the power of parameter passing to show the data
    going in and out of the predictive model. If you're wondering what the deal is
    with CSS file linking in the document head – don't worry about it for now. We
    still need to work on one thing before dealing with CSS.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们已经利用了参数传递的强大功能来显示数据在预测模型中的进出。如果你对文档头中 CSS 文件链接的问题感到好奇——现在不用担心。在处理 CSS
    之前，我们还需要处理一件事。
- en: 'Finally, let''s reformat `index.html`. This file will need only minor changes
    – a couple of CSS classes and a couple of `div` elements. Here is the entire code
    snippet for the reformatted version:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们重新格式化 `index.html`。这个文件只需要进行一些小的更改——几个 CSS 类和几个 `div` 元素。以下是重新格式化版本的整个代码片段：
- en: '[PRE19]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We're almost there. So far, you've refactored every file that needed refactoring,
    and now you'll create an additional folder and file. Inside the root directory,
    create a folder named `static`. Once created, make an additional folder inside
    it called `css`. This folder will contain all stylings for our application. Inside
    the `css` folder, create a file called `main.css`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们几乎完成了。到目前为止，你已经重构了所有需要重构的文件，现在你将创建一个额外的文件夹和文件。在根目录下，创建一个名为`static`的文件夹。创建后，在它里面创建一个名为`css`的额外文件夹。这个文件夹将包含我们应用程序的所有样式。在`css`文件夹中，创建一个名为`main.css`的文件。
- en: 'To summarize, here''s how your directory structure should look once you have
    created these folders and file:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结一下，创建这些文件夹和文件后，你的目录结构应该如下所示：
- en: '![Figure 9.13 – New directory structure'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图9.13 – 新的目录结构'
- en: '](img/B16954_09_13.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B16954_09_13.jpg)'
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And we're done. Let's run the application to see how it looks now.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成了。让我们运行应用程序，看看现在的样子。
- en: 'If you were to re-run the application now, you''d see the stylings taking effect.
    The following figure shows how the input form looks:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在重新运行应用程序，你会看到样式开始生效。以下图示显示了输入表单的外观：
- en: '![Figure 9.14 – Styled Iris prediction application'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – 样式化的Iris预测应用程序'
- en: '](img/B16954_09_14.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_09_14.jpg)'
- en: Figure 9.14 – Styled Iris prediction application
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 样式化的Iris预测应用程序
- en: 'The application by no means looks perfect now, but it''s at least in a presentable
    form. Let fill it out as shown in the following figure:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在远非完美，但至少已经是一个可展示的形式。让我们按照以下图示来完善它：
- en: '![Figure 9.15 – Styled Iris prediction application (2)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15 – 样式化的Iris预测应用程序（2）'
- en: '](img/B16954_09_15.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_09_15.jpg)'
- en: Figure 9.15 – Styled Iris prediction application (2)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 样式化的Iris预测应用程序（2）
- en: 'And finally, let''s click on the **Predict** button to see how the other page
    looks:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们点击**预测**按钮，看看另一页的样子：
- en: '![Figure 9.16 – Iris prediction application predictions'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16 – Iris预测应用程序预测'
- en: '](img/B16954_09_16.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_09_16.jpg)'
- en: Figure 9.16 – Iris prediction application predictions
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – Iris预测应用程序预测
- en: Let's call it a day stylings-wise. The application is at a pretty decent point
    now, but you're free to tweak it further.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式方面，我们可以到此为止。应用程序现在看起来相当不错，但你也可以自由地进一步调整它。
- en: And there you have it – how to build and style a `Flask` application built around
    a machine learning model. The next section will connect the app to our API, making
    the app fully functional. See you there.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，你就可以看到如何构建和样式化一个围绕机器学习模型构建的`Flask`应用程序。下一节将连接我们的API，使应用程序完全可用。在那里见。
- en: Making predictions in a GUI environment
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GUI环境中进行预测
- en: Welcome to the last section of the book. This section will tie our simple web
    application to an already-deployed machine learning API. This closely resembles
    a production environment, where you have one or more machine learning models deployed,
    and the application development team wants to use them in their application. The
    only difference is that you're both the data science and application development
    team.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的最后一部分。本节将把我们的简单Web应用程序与已部署的机器学习API联系起来。这非常类似于生产环境，其中你部署了一个或多个机器学习模型，而应用程序开发团队希望将其用于他们的应用程序。唯一的区别是，你既是数据科学团队也是应用程序开发团队。
- en: 'Once again, we''ll have to make a couple of changes to the application structure:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们还需要对应用程序结构进行一些修改：
- en: Let's start with the simpler part. Inside the root directory, create a Python
    file called `predictor.py`. This file will hold a single function that implements
    the logic discussed at the beginning of this chapter when we made predictions
    in the notebook environment.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从简单的部分开始。在根目录下，创建一个名为`predictor.py`的Python文件。这个文件将包含一个函数，该函数实现了本章开头在笔记本环境中进行预测时讨论的逻辑。
- en: Put simply, this function has to make a POST request to the API and return a
    response in JSON format.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简而言之，这个函数必须向API发送POST请求，并以JSON格式返回响应。
- en: 'Here''s the entire code snippet for the file:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是文件中的整个代码片段：
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Keep in mind that the URL parameter's value will be different on your machine,
    so please change it accordingly.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，URL参数的值在你的机器上可能会有所不同，所以请相应地更改它。
- en: There's no point in further explaining this code snippet, as it is nearly identical
    to the code you've seen and written before.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有必要进一步解释这个代码片段，因为它几乎与你之前看到和编写的代码相同。
- en: Let's make a couple of changes in `app.py` now. We'll import this file and call
    the `predict()` function right after the input fields are validated. Once the
    response is returned, its values are passed as parameters to the corresponding
    field of the `return` statement.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们对 `app.py` 进行一些修改。我们将在输入字段验证后立即导入此文件并调用 `predict()` 函数。一旦返回响应，其值将作为参数传递给
    `return` 语句的相应字段。
- en: 'Here is the entire code snippet for the `app.py` file:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `app.py` 文件的整个代码片段：
- en: '[PRE22]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the prediction probability is converted to a percentage and
    rounded to two decimal points. The only reason for doing so is to have nicer-formatted
    output in the application.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，预测概率被转换为百分比并四舍五入到小数点后两位。这样做的原因只是为了在应用程序中输出更美观的格式。
- en: 'And now the fun part – testing. Open the application and enter some data into
    the form. Here''s an example:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候进行有趣的测试了。打开应用程序，在表单中输入一些数据。以下是一个示例：
- en: '![Figure 9.17 – Iris prediction application final test'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.17 – 爱尔兰预测应用程序最终测试'
- en: '](img/B16954_09_17.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_09_17.jpg)'
- en: Figure 9.17 – Iris prediction application final test
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 爱尔兰预测应用程序最终测试
- en: 'Once you click on the **Predict** button, you''ll see the following results
    on the screen:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击了**预测**按钮，你将在屏幕上看到以下结果：
- en: '![Figure 9.18 – Iris prediction application final results'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.18 – 爱尔兰预测应用程序最终结果'
- en: '](img/B16954_09_18.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16954_09_18.jpg)'
- en: Figure 9.18 – Iris prediction application final results
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – 爱尔兰预测应用程序最终结果
- en: And there you have it – a complete and fully working GUI web application based
    on a deployed machine learning model.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你就有了一个基于部署的机器学习模型的完整且完全工作的 GUI Web 应用程序。
- en: Not including the summary that follows, this was the last section of the chapter,
    but also the entire book. You now know how to deploy machine learning models and
    build simple web applications around a deployed model. Congratulations!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不包括随后的摘要，这是本章的最后一部分，也是整本书的结尾。你现在知道如何部署机器学习模型并在部署的模型周围构建简单的 Web 应用程序。恭喜！
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter fell into the category of extensive hands-on chapters, but I hope
    you've managed to follow along. If you have, you've learned a lot – from how to
    make predictions in a notebook environment to making predictions in a simple and
    custom-built web application.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章属于实践性很强的章节，但我希望你已经设法跟上了。如果你做到了，你已经学到了很多——从如何在笔记本环境中进行预测到在简单和自定义构建的 Web 应用程序中进行预测。
- en: Not only that, but you've also completed the entire book. Congratulations! You've
    learned a lot throughout these nine chapters. We started with the basics of machine
    learning through basic regression and classification examples, and from there
    slowly built our knowledge of TPOT. You've also learned how TPOT works with parallel
    training and with neural networks. But probably the most important new skill you've
    acquired is model deployment. Without it, your models are useless, as no one can
    use them to create value.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，你还完成了整本书。恭喜！在这九个章节中，你学到了很多。我们从机器学习的基础，通过基本的回归和分类示例开始，然后逐渐构建我们对 TPOT 的知识。你还学习了
    TPOT 如何与并行训练和神经网络一起工作。但可能你获得的最重要的新技能是模型部署。没有它，你的模型就毫无用处，因为没有人可以使用它们来创造价值。
- en: As always, feel free to explore TPOT and every amazing functionality it has
    to offer on your own. This book should serve you as a great starting point, as
    it took you from zero to building web applications around your deployed automated
    machine learning models in only a couple of hundred pages. Now that's something
    you can be proud of!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以自由探索 TPOT 以及它提供的所有惊人的功能。这本书应该为你提供一个很好的起点，因为它只用了几百页就带你从零开始构建围绕部署的自动化机器学习模型的
    Web 应用程序。这确实值得骄傲！
- en: Q&A
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: Which Python library can you use to make requests to deployed REST APIs?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用哪个 Python 库向部署的 REST API 发送请求？
- en: In which format is data provided when making a POST request?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发送 POST 请求时，数据以什么格式提供？
- en: Name the Flask extension used to build and work with forms.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名用于构建和操作表单的 Flask 扩展。
- en: Why is it important to validate web application forms if we're talking about
    data going into a machine learning model?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们谈论的是进入机器学习模型的数据，为什么验证 Web 应用程序表单很重要？
- en: Can you pass parameters to HTML template files through Flask? If so, how can
    you display their values in HTML?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过 Flask 将参数传递给 HTML 模板文件吗？如果是这样，你如何在 HTML 中显示它们的值？
- en: Explain the process of linking CSS files to Flask applications.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释将 CSS 文件链接到 Flask 应用程序的过程。
- en: Explain why there's no point in leaving machine learning models sitting idle
    on your PC.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么将机器学习模型闲置在您的电脑上是没有意义的。
