- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Embedding a Machine Learning Model into a Web Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将机器学习模型嵌入Web应用程序
- en: In the previous chapters, you learned about the many different machine learning
    concepts and algorithms that can help us with better and more efficient decision-making.
    However, machine learning techniques are not limited to offline applications and
    analyses, and they have become the predictive engine of various web services.
    For example, popular and useful applications of machine learning models in web
    applications include spam detection in submission forms, search engines, recommendation
    systems for media or shopping portals, and many more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你学习了许多不同的机器学习概念和算法，它们可以帮助我们做出更好、更高效的决策。然而，机器学习技术不仅限于离线应用和分析，它们已经成为各种Web服务的预测引擎。例如，机器学习模型在Web应用中的一些流行且有用的应用包括提交表单中的垃圾邮件检测、搜索引擎、媒体或购物门户的推荐系统等等。
- en: 'In this chapter, you will learn how to embed a machine learning model into
    a web application that can not only classify, but also learn from data in real
    time. The topics that we will cover are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将机器学习模型嵌入到一个Web应用程序中，该应用程序不仅可以分类，还可以实时从数据中学习。我们将覆盖的主题如下：
- en: Saving the current state of a trained machine learning model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存训练过的机器学习模型的当前状态
- en: Using SQLite databases for data storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQLite数据库进行数据存储
- en: Developing a web application using the popular Flask web framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流行的Flask Web框架开发Web应用程序
- en: Deploying a machine learning application to a public web server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将机器学习应用程序部署到公共Web服务器
- en: Serializing fitted scikit-learn estimators
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化拟合的scikit-learn估算器
- en: Training a machine learning model can be computationally expensive, as you saw
    in *Chapter 8*, *Applying Machine Learning to Sentiment Analysis*. Surely, we
    don't want to retrain our model every time we close our Python interpreter and
    want to make a new prediction or reload our web application?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 训练机器学习模型可能需要大量计算资源，就像你在*第8章*，*将机器学习应用于情感分析*中看到的那样。当然，我们不希望每次关闭Python解释器并想要进行新预测或重新加载我们的Web应用程序时，都重新训练模型吧？
- en: 'One option for model persistence is Python''s in-built `pickle` module ([https://docs.python.org/3.7/library/pickle.html](https://docs.python.org/3.7/library/pickle.html)),
    which allows us to serialize and deserialize Python object structures to compact
    bytecode so that we can save our classifier in its current state and reload it
    if we want to classify new, unlabeled examples, without needing the model to learn
    from the training data all over again. Before you execute the following code,
    please make sure that you have trained the out-of-core logistic regression model
    from the last section of *Chapter 8* and have it ready in your current Python
    session:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模型持久化的选项是Python内置的`pickle`模块（[https://docs.python.org/3.7/library/pickle.html](https://docs.python.org/3.7/library/pickle.html)），它允许我们将Python对象结构序列化并反序列化为紧凑的字节码，这样我们就可以将分类器以当前状态保存下来，并在需要分类新的未标记样本时重新加载它，而无需让模型重新从训练数据中学习。在执行以下代码之前，请确保你已经在*第8章*的最后部分训练了外部核心逻辑回归模型，并且它已经准备好在当前的Python会话中使用：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the preceding code, we created a `movieclassifier` directory where we
    will later store the files and data for our web application. Within this `movieclassifier`
    directory, we created a `pkl_objects` subdirectory to save the serialized Python
    objects to our local hard drive or solid-state drive. Via the `dump` method of
    the `pickle` module, we then serialized the trained logistic regression model
    as well as the stop-word set from the **Natural Language Toolkit** (**NLTK**)
    library, so that we don't have to install the NLTK vocabulary on our server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们创建了一个`movieclassifier`目录，在其中存储我们Web应用程序的文件和数据。在这个`movieclassifier`目录中，我们创建了一个`pkl_objects`子目录，用来将序列化的Python对象保存到本地硬盘或固态硬盘中。通过`pickle`模块的`dump`方法，我们将训练好的逻辑回归模型以及**自然语言工具包**（**NLTK**）库的停用词集合序列化，这样我们就不需要在服务器上安装NLTK词汇。
- en: The `dump` method takes as its first argument the object that we want to pickle.
    For the second argument, we provided an open file object that the Python object
    will be written to. Via the `wb` argument inside the `open` function, we opened
    the file in binary mode for pickle, and we set `protocol=4` to choose the latest
    and most efficient pickle protocol that was added to Python 3.4, which is compatible
    with Python 3.4 or newer. If you have problems using `protocol=4`, please check
    whether you are using the latest Python 3 version—Python 3.7 is recommended for
    this book. Alternatively, you may consider choosing a lower protocol number.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`dump` 方法的第一个参数是我们要进行 Pickle 的对象。第二个参数是一个已打开的文件对象，Python 对象将被写入该文件。通过 `open`
    函数中的 `wb` 参数，我们以二进制模式打开文件进行 Pickle，并设置 `protocol=4` 来选择 Python 3.4 中新增的最新且最有效的
    Pickle 协议，它与 Python 3.4 或更新版本兼容。如果你在使用 `protocol=4` 时遇到问题，请检查你是否正在使用最新版本的 Python
    3——本书推荐使用 Python 3.7。或者，你可以选择使用较低的协议版本。'
- en: Also note that if you are using a custom web server, you have to ensure that
    the Python installation on that server is compatible with this protocol version
    as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，如果你使用的是自定义 Web 服务器，则需要确保该服务器上的 Python 安装与该协议版本兼容。
- en: '**Serializing NumPy arrays with joblib**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 joblib 序列化 NumPy 数组**'
- en: Our logistic regression model contains several NumPy arrays, such as the weight
    vector, and a more efficient way to serialize NumPy arrays is to use the alternative
    `joblib` library. To ensure compatibility with the server environment that we
    will use in later sections, we will use the standard pickle approach. If you are
    interested, you can find more information about `joblib` at [https://joblib.readthedocs.io](https://joblib.readthedocs.io).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的逻辑回归模型包含多个 NumPy 数组，例如权重向量。更高效的序列化 NumPy 数组的方式是使用替代库 `joblib`。为了确保与我们将在后续章节中使用的服务器环境兼容，我们将使用标准的
    pickle 方法。如果你感兴趣，可以在 [https://joblib.readthedocs.io](https://joblib.readthedocs.io)
    找到更多关于 `joblib` 的信息。
- en: 'We don''t need to pickle `HashingVectorizer`, since it does not need to be
    fitted. Instead, we can create a new Python script file from which we can import
    the vectorizer into our current Python session. Now, copy the following code and
    save it as `vectorizer.py` in the `movieclassifier` directory:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要对 `HashingVectorizer` 进行 Pickle，因为它不需要拟合。相反，我们可以创建一个新的 Python 脚本文件，并从中将矢量化器导入到当前的
    Python 会话中。现在，复制以下代码并将其保存为 `vectorizer.py` 文件，放在 `movieclassifier` 目录中：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After we have pickled the Python objects and created the `vectorizer.py` file,
    it would be a good idea to restart our Python interpreter or Jupyter Notebook
    kernel to test whether we can deserialize the objects without error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对 Python 对象进行 Pickle 并创建了 `vectorizer.py` 文件后，最好重新启动 Python 解释器或 Jupyter
    Notebook 内核，以测试我们是否能够顺利反序列化这些对象。
- en: '**Pickle can be a security risk**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pickle 可能带来安全风险**'
- en: Please note that unpickling data from an untrusted source can be a potential
    security risk, since the `pickle` module is not secured against malicious code.
    Since `pickle` was designed to serialize arbitrary objects, the unpickling process
    will execute code that has been stored in a pickle file. Thus, if you receive
    pickle files from an untrusted source (for example, by downloading them from the
    internet), please proceed with extra care and unpickle the items in a virtual
    environment and/or on a non-essential machine that does not store important data
    that no one except you should have access to.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从不受信任的来源反序列化数据可能会带来安全风险，因为 `pickle` 模块无法防范恶意代码。由于 `pickle` 被设计用来序列化任意对象，反序列化过程会执行存储在
    pickle 文件中的代码。因此，如果你从不受信任的来源（例如从互联网下载）接收到 pickle 文件，请务必小心，并在虚拟环境中或在不存储重要数据的非关键机器上反序列化这些项目，这样除了你自己，其他人无法访问这些数据。
- en: 'From your terminal, navigate to the `movieclassifier` directory, start a new
    Python session, and execute the following code to verify that you can import the
    `vectorizer` and unpickle the classifier:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端进入 `movieclassifier` 目录，启动一个新的 Python 会话，并执行以下代码以验证你是否能够导入 `vectorizer` 并反序列化分类器：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After we have successfully loaded the `vectorizer` and unpickled the classifier,
    we can use these objects to preprocess document examples and make predictions
    about their sentiments:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 成功加载 `vectorizer` 并反序列化分类器后，我们可以使用这些对象对文档示例进行预处理，并对其情感进行预测：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since our classifier returns the class label predictions as integers, we defined
    a simple Python dictionary to map these integers to their sentiment (`"positive"`
    or `"negative"`). While this is a simple application with two classes only, it
    should be noted that this dictionary-mapping approach also generalizes to multiclass
    settings. Furthermore, this mapping dictionary should also be archived alongside
    the model.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的分类器返回的类别标签预测是整数类型，我们定义了一个简单的Python字典，将这些整数映射到其情感（`"positive"`或`"negative"`）。虽然这是一个仅包含两个类别的简单应用，但需要注意的是，这种字典映射的方法也可以推广到多类别的设置。此外，这个映射字典也应该与模型一同存档。
- en: In this case, since the dictionary definition only consists of one line of code,
    we will not go to the trouble of serializing it using pickle. However, in real-world
    applications with more extensive mapping dictionaries, you can utilize the same
    `pickle.dump` and `pickle.load` commands that we used in the previous code example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于字典定义只包含一行代码，我们不会费心使用pickle进行序列化。然而，在实际应用中，如果字典映射较大，可以利用我们在之前代码示例中使用的相同`pickle.dump`和`pickle.load`命令。
- en: Continuing with the discussion of the previous code example, we then used `HashingVectorizer`
    to transform the simple example document into a word vector, `X`. Finally, we
    used the `predict` method of the logistic regression classifier to predict the
    class label, as well as the `predict_proba` method to return the corresponding
    probability of our prediction. Note that the `predict_proba` method call returns
    an array with a probability value for each unique class label. Since the class
    label with the largest probability corresponds to the class label that is returned
    by the `predict` call, we used the `np.max` function to return the probability
    of the predicted class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接着讨论之前的代码示例，我们使用了`HashingVectorizer`将简单的示例文档转换成了一个词向量`X`。最后，我们使用逻辑回归分类器的`predict`方法来预测类别标签，并使用`predict_proba`方法返回相应的预测概率。请注意，`predict_proba`方法返回一个数组，其中包含每个唯一类别标签的概率值。由于具有最大概率的类别标签就是`predict`方法返回的类别标签，我们使用了`np.max`函数来返回预测类别的概率。
- en: Setting up an SQLite database for data storage
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置SQLite数据库以存储数据
- en: In this section, we will set up a simple SQLite database to collect optional
    feedback about the predictions from users of the web application. We can use this
    feedback to update our classification model. SQLite is an open source SQL database
    engine that doesn't require a separate server to operate, which makes it ideal
    for smaller projects and simple web applications. Essentially, an SQLite database
    can be understood as a single, self-contained database file that allows us to
    directly access storage files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置一个简单的SQLite数据库，用于收集Web应用用户对预测结果的可选反馈。我们可以使用这些反馈来更新我们的分类模型。SQLite是一个开源的SQL数据库引擎，无需单独的服务器即可操作，这使得它非常适合小型项目和简单的Web应用。实际上，SQLite数据库可以理解为一个单一的、独立的数据库文件，允许我们直接访问存储文件。
- en: Furthermore, SQLite doesn't require any system-specific configuration and is
    supported by all common operating systems. It has gained a reputation for being
    very reliable and is used by popular companies such as Google, Mozilla, Adobe,
    Apple, Microsoft, and many more. If you want to learn more about SQLite, visit
    the official website at [http://www.sqlite.org](http://www.sqlite.org).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，SQLite不需要任何系统特定的配置，并且支持所有常见的操作系统。它因其高可靠性而广受欢迎，被谷歌、Mozilla、Adobe、苹果、微软等许多知名公司使用。如果你想了解更多关于SQLite的信息，请访问官网：[http://www.sqlite.org](http://www.sqlite.org)。
- en: Fortunately, following Python's *batteries included* philosophy, there is already
    an API in the Python standard library, `sqlite3`, which allows us to work with
    SQLite databases. (For more information about `sqlite3`, please visit [https://docs.python.org/3.7/library/sqlite3.html](https://docs.python.org/3.7/library/sqlite3.html).)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，遵循Python的*电池包含*哲学，Python标准库中已经有一个API`sqlite3`，允许我们与SQLite数据库进行交互。（有关`sqlite3`的更多信息，请访问：[https://docs.python.org/3.7/library/sqlite3.html](https://docs.python.org/3.7/library/sqlite3.html)）。
- en: 'By executing the following code, we will create a new SQLite database inside
    the `movieclassifier` directory and store two example movie reviews:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下代码，我们将在`movieclassifier`目录下创建一个新的SQLite数据库，并存储两个示例电影评论：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Following the preceding code example, we created a connection (`conn`) to an
    SQLite database file by calling the `connect` method of the `sqlite3` library,
    which created the new database file `reviews.sqlite` in the `movieclassifier`
    directory if it didn't already exist.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的代码示例，我们通过调用`sqlite3`库的`connect`方法，创建了一个与SQLite数据库文件的连接（`conn`），如果该数据库文件`reviews.sqlite`在`movieclassifier`目录下不存在，它会被新建。
- en: 'Next, we created a cursor via the `cursor` method, which allows us to traverse
    over the database records using the versatile SQL syntax. Via the first `execute`
    call, we then created a new database table, `review_db`. We used this to store
    and access database entries. Along with `review_db`, we also created three columns
    in this database table: `review`, `sentiment`, and `date`. We used these to store
    two example movie reviews and respective class labels (sentiments).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过`cursor`方法创建了一个游标，它允许我们使用多功能的SQL语法遍历数据库记录。通过第一次调用`execute`，我们创建了一个新的数据库表`review_db`。我们用这个表来存储和访问数据库条目。除了`review_db`，我们还在这个数据库表中创建了三列：`review`、`sentiment`和`date`。我们用这些列来存储两条电影评论及其对应的分类标签（情感）。
- en: Using the `DATETIME('now')` SQL command, we also added date and timestamps to
    our entries. In addition to the timestamps, we used the question mark symbols
    (`?`) to pass the movie review texts (`example1` and `example2`) and the corresponding
    class labels (`1` and `0`) as positional arguments to the `execute` method, as
    members of a tuple. Lastly, we called the `commit` method to save the changes
    that we made to the database and closed the connection via the `close` method.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`DATETIME('now')` SQL命令，我们还为我们的条目添加了日期和时间戳。除了时间戳，我们使用问号符号（`?`）将电影评论文本（`example1`和`example2`）和相应的分类标签（`1`和`0`）作为位置参数传递给`execute`方法，作为元组的成员。最后，我们调用了`commit`方法来保存对数据库所做的更改，并通过`close`方法关闭连接。
- en: 'To check if the entries have been stored in the database table correctly, we
    will now reopen the connection to the database and use the SQL `SELECT` command
    to fetch all rows in the database table that have been committed between the beginning
    of the year 2017 and today:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查数据是否正确存储在数据库表中，我们现在将重新打开与数据库的连接，并使用SQL的`SELECT`命令来获取自2017年初至今天所有已提交的数据库表中的行：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, we could also use the free DB browser for SQLite app (available
    at [https://sqlitebrowser.org/dl/](https://sqlitebrowser.org/dl/)), which offers
    a nice graphical user interface for working with SQLite databases, as shown in
    the following figure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们也可以使用免费的SQLite浏览器应用（可通过[https://sqlitebrowser.org/dl/](https://sqlitebrowser.org/dl/)下载），它提供了一个漂亮的图形用户界面来操作SQLite数据库，如下图所示：
- en: '![](img/B13208_09_01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_01.png)'
- en: Developing a web application with Flask
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask开发Web应用
- en: Having prepared the code for classifying movie reviews in the previous subsection,
    let's discuss the basics of the Flask web framework to develop our web application.
    Since Armin Ronacher's initial release of Flask in 2010, the framework has gained
    huge popularity, and examples of popular applications that use Flask include LinkedIn
    and Pinterest. Since Flask is written in Python, it provides us Python programmers
    with a convenient interface for embedding existing Python code, such as our movie
    classifier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一小节准备好用于分类电影评论的代码后，让我们讨论Flask Web框架的基础知识，以便开发我们的Web应用。自2010年Armin Ronacher首次发布Flask以来，该框架获得了巨大的受欢迎程度，使用Flask的流行应用实例包括LinkedIn和Pinterest。由于Flask是用Python编写的，它为我们Python程序员提供了一个方便的接口，用于嵌入现有的Python代码，例如我们的电影分类器。
- en: '**The Flask microframework**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flask微框架**'
- en: Flask is also known as a **microframework**, which means that its core is kept
    lean and simple but it can be easily extended with other libraries. Although the
    learning curve of the lightweight Flask API is not nearly as steep as those of
    other popular Python web frameworks, such as Django, you are encouraged to take
    a look at the official Flask documentation at [https://flask.palletsprojects.com/en/1.0.x/](https://flask.palletsprojects.com/en/1.0.x/)
    to learn more about its functionality.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Flask也被称为**微框架**，这意味着它的核心保持简洁而轻量，但可以通过其他库轻松扩展。虽然轻量级的Flask API的学习曲线远不如其他流行的Python
    Web框架（如Django）陡峭，但仍建议你查看Flask的官方文档：[https://flask.palletsprojects.com/en/1.0.x/](https://flask.palletsprojects.com/en/1.0.x/)，了解其更多功能。
- en: 'If the Flask library is not already installed in your current Python environment,
    you can simply install it via `conda` or `pip` from your terminal (at the time
    of writing, the latest stable release was version 1.0.2):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Flask 库还没有安装在你当前的 Python 环境中，你可以通过终端使用`conda`或`pip`轻松安装它（在撰写本文时，最新的稳定版本是
    1.0.2）：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our first Flask web application
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个 Flask Web 应用
- en: In this subsection, we will develop a very simple web application to become
    more familiar with the Flask API before we implement our movie classifier. This
    first application that we are going to build consists of a simple web page with
    a form field that lets us enter a name. After submitting the name to the web application,
    it will render it on a new page. While this is a very simple example of a web
    application, it helps with building an understanding of how to store and pass
    variables and values between the different parts of our code within the Flask
    framework.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将开发一个非常简单的 web 应用，以便更熟悉 Flask API，然后再实现我们的电影分类器。我们将要构建的这个第一个应用包含一个简单的网页，网页上有一个表单字段，让我们输入一个名字。提交名字后，web
    应用会将其渲染在一个新页面上。虽然这是一个非常简单的 web 应用示例，但它有助于理解如何在 Flask 框架中在不同部分之间存储和传递变量及值。
- en: 'First, we create a directory tree:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个目录树：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `app.py` file will contain the main code that will be executed by the Python
    interpreter to run the Flask web application. The `templates` directory is the
    directory in which Flask will look for static HTML files for rendering in the
    web browser. Let''s now take a look at the contents of `app.py`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件将包含由 Python 解释器执行的主要代码，以运行 Flask 网络应用。`templates` 目录是 Flask 查找静态
    HTML 文件以供在网页浏览器中渲染的目录。现在，让我们来看看 `app.py` 的内容：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After looking at the previous code example, let''s discuss the individual pieces
    step by step:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看过前面的代码示例后，让我们逐步讨论各个部分：
- en: We ran our application as a single module; thus, we initialized a new Flask
    instance with the argument `__name__` to let Flask know that it can find the HTML
    template folder (`templates`) in the same directory where it is located.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将应用程序作为单个模块运行，因此我们使用参数 `__name__` 初始化了一个新的 Flask 实例，让 Flask 知道它可以在当前所在的目录中找到
    HTML 模板文件夹（`templates`）。
- en: Next, we used the route decorator (`@app.route('/')`) to specify the URL that
    should trigger the execution of the `index` function.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用路由装饰器（`@app.route('/')`）来指定应触发 `index` 函数执行的 URL。
- en: Here, our `index` function simply rendered the `first_app.html` HTML file, which
    is located in the `templates` folder.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们的 `index` 函数简单地渲染了位于 `templates` 文件夹中的 `first_app.html` HTML 文件。
- en: Lastly, we used the `run` function to run the application on the server only
    when this script was directly executed by the Python interpreter, which we ensured
    using the `if` statement with `__name__ == '__main__'`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `run` 函数来仅在 Python 解释器直接执行此脚本时运行应用程序，这一点我们通过使用 `if` 语句和 `__name__ ==
    '__main__'` 来确保。
- en: 'Now, let''s take a look at the contents of the `first_app.html` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看 `first_app.html` 文件的内容：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**HTML basics**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTML 基础**'
- en: If you are not familiar with the HTML syntax yet, visit [https://developer.mozilla.org/en-US/docs/Web/HTML](https://developer.mozilla.org/en-US/docs/Web/HTML)
    for useful tutorials on learning the basics of HTML.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉 HTML 语法，可以访问 [https://developer.mozilla.org/en-US/docs/Web/HTML](https://developer.mozilla.org/en-US/docs/Web/HTML)
    查阅关于 HTML 基础知识的有用教程。
- en: 'Here, we have simply filled an empty HTML template file with a `<div>` element
    (a block-level element) that contains this sentence: `Hi, this is my first Flask
    web app!`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地填充了一个空的 HTML 模板文件，里面有一个包含这句话的`<div>`元素（块级元素）：`Hi, this is my first
    Flask web app!`。
- en: 'Conveniently, Flask allows us to run our applications locally, which is useful
    for developing and testing web applications before we deploy them on a public
    web server. Now, let''s start our web application by executing the command from
    the terminal inside the `1st_flask_app_1` directory:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，Flask 允许我们在本地运行应用程序，这对在将 web 应用部署到公共服务器之前进行开发和测试非常有用。现在，让我们通过在 `1st_flask_app_1`
    目录中的终端执行命令来启动我们的 web 应用：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We should see a line such as the following displayed in the terminal:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在终端看到类似以下的行：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line contains the address of our local server. We can enter this address
    in our web browser to see the web application in action.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行包含了我们本地服务器的地址。我们可以在网页浏览器中输入此地址来查看 web 应用的运行效果。
- en: 'If everything has executed correctly, we should see a simple website with the
    content `Hi, this is my first Flask web app!` as shown in the following figure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利执行，我们应该能看到一个简单的网站，内容为`Hi, this is my first Flask web app!`，如以下图所示：
- en: '![](img/B13208_09_02.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_02.png)'
- en: Form validation and rendering
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单验证与渲染
- en: 'In this subsection, we will extend our simple Flask web application with HTML
    form elements to learn how to collect data from a user using the WTForms library
    ([https://wtforms.readthedocs.org/en/latest/](https://wtforms.readthedocs.org/en/latest/)),
    which can be installed via `conda` or `pip`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将通过HTML表单元素扩展我们的简单Flask Web应用程序，学习如何使用WTForms库从用户收集数据（可以通过`conda`或`pip`安装该库），详细信息请参见[https://wtforms.readthedocs.org/en/latest/](https://wtforms.readthedocs.org/en/latest/)：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This web application will prompt a user to type in his or her name into a text
    field, as shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Web应用程序将提示用户在文本字段中输入姓名，如下图所示：
- en: '![](img/B13208_09_03.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_03.png)'
- en: 'After the submission button (**Say Hello**) has been clicked and the form has
    been validated, a new HTML page will be rendered to display the user''s name:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交按钮（**Say Hello**）被点击并且表单验证通过后，一个新的HTML页面将被渲染，显示用户的姓名：
- en: '![](img/B13208_09_04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_04.png)'
- en: Setting up the directory structure
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置目录结构
- en: 'The new directory structure that we need to set up for this application looks
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为此应用程序设置的新目录结构如下：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following are the contents of our modified `app.py` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们修改后的`app.py`文件的内容：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s discuss what the previous code does step by step:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步讨论之前的代码：
- en: Using `wtforms`, we extended the `index` function with a text field that we
    will embed in our start page using the `TextAreaField` class, which automatically
    checks whether a user has provided valid input text or not.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`wtforms`，我们扩展了`index`函数，添加了一个文本字段，我们将通过`TextAreaField`类将其嵌入到我们的首页中，该类会自动检查用户是否提供了有效的输入文本。
- en: Furthermore, we defined a new function, `hello`, which will render an HTML page,
    `hello.html`, after validating the HTML form.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们定义了一个新的函数`hello`，该函数将在验证HTML表单后渲染HTML页面`hello.html`。
- en: Here, we used the `POST` method to transport the form data to the server in
    the message body. Finally, by setting the `debug=True` argument inside the `app.run`
    method, we further activated Flask's debugger. This is a useful feature for developing
    new web applications.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用`POST`方法将表单数据通过消息体传输到服务器。最后，通过在`app.run`方法中设置`debug=True`参数，我们进一步激活了Flask的调试器。这是开发新Web应用程序时非常有用的功能。
- en: Implementing a macro using the Jinja2 templating engine
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Jinja2模板引擎实现宏
- en: 'Now, we will implement a generic macro in the `_formhelpers.html` file via
    the Jinja2 templating engine, which we will later import in our `first_app.html`
    file to render the text field:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在`_formhelpers.html`文件中通过Jinja2模板引擎实现一个通用宏，稍后我们将在`first_app.html`文件中导入该宏以渲染文本字段：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An in-depth discussion about the Jinja2 templating language is beyond the scope
    of this book. However, you can find comprehensive documentation on the Jinja2
    syntax at [http://jinja.pocoo.org](http://jinja.pocoo.org).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对Jinja2模板语言的深入讨论超出了本书的范围。不过，您可以在[http://jinja.pocoo.org](http://jinja.pocoo.org)找到Jinja2语法的详细文档。
- en: Adding style via CSS
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过CSS添加样式
- en: 'Next, we will set up a simple **Cascading Style Sheets** (**CSS**) file, `style.css`,
    to demonstrate how the look and feel of HTML documents can be modified. We have
    to save the following CSS file, which will simply double the font size of our
    HTML body elements, in a subdirectory called `static`, which is the default directory
    where Flask looks for static files such as CSS. The file content is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置一个简单的**层叠样式表**（**CSS**）文件，`style.css`，以演示如何修改HTML文档的外观和感觉。我们必须将以下CSS文件保存到名为`static`的子目录中，这是Flask查找静态文件（如CSS）的默认目录。文件内容如下：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the contents of the modified `first_app.html` file that will
    now render a text form where a user can enter a name:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改后的`first_app.html`文件的内容，该文件现在将渲染一个文本表单，用户可以在其中输入姓名：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the header section of `first_app.html`, we loaded the CSS file. It should
    now alter the size of all text elements in the HTML body. In the HTML body section,
    we imported the form macro from `_formhelpers.html`, and we rendered the `sayhello`
    form that we specified in the `app.py` file. Furthermore, we added a button to
    the same form element so that a user can submit the text field entry. The changes
    between the original and modified `first_app.html` file are illustrated in the
    following figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `first_app.html` 的头部部分，我们加载了 CSS 文件。现在它应该会改变 HTML 页面正文中所有文本元素的大小。在 HTML 页面正文部分，我们从
    `_formhelpers.html` 导入了表单宏，并渲染了我们在 `app.py` 文件中指定的 `sayhello` 表单。此外，我们在同一表单元素中添加了一个按钮，以便用户能够提交文本框中的内容。原始和修改后的
    `first_app.html` 文件之间的变化如以下图所示：
- en: '![](img/B13208_09_05.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_05.png)'
- en: Creating the result page
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建结果页面
- en: 'Lastly, we will create a `hello.html` file that will be rendered via the `render_template(''hello.html'',
    name=name)` line return inside the `hello` function, which we defined in the `app.py`
    script to display the text that a user submitted via the text field. The file
    content is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个 `hello.html` 文件，该文件将通过 `hello` 函数中的 `render_template('hello.html',
    name=name)` 这一行进行渲染，该函数是在 `app.py` 脚本中定义的，用于显示用户通过文本框提交的内容。文件内容如下：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since we have covered a lot of ground in the previous section, the following
    figure provides an overview of the files we have created:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前一部分已经涵盖了很多内容，下面的图提供了我们创建的文件的概述：
- en: '![](img/B13208_09_06.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_06.png)'
- en: Please note that you do not need to copy any code from the previous figure,
    since all file contents are present in the previous sections. For your convenience,
    copies of all files can also be found online at [https://github.com/rasbt/python-machine-learning-book-3rd-edition/tree/master/ch09/1st_flask_app_2](https://github.com/rasbt/python-machine-learning-book-3rd-edition/tree/master/ch09/1st_flask_app_2).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不需要复制前一图中的任何代码，因为所有文件内容已经在之前的部分中提到过了。为了方便您，所有文件的副本也可以在网上找到，链接为 [https://github.com/rasbt/python-machine-learning-book-3rd-edition/tree/master/ch09/1st_flask_app_2](https://github.com/rasbt/python-machine-learning-book-3rd-edition/tree/master/ch09/1st_flask_app_2)。
- en: 'Having set up our modified Flask web application, we can run it locally by
    executing the following command from the application''s main directory:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好修改后的 Flask Web 应用程序后，我们可以通过在应用程序主目录中执行以下命令来在本地运行它：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, to see the resulting web page, enter the IP address shown in your terminal,
    which is usually `http://127.0.0.1:5000/,` into your web browser to view the rendered
    web app as summarized in the following figure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了查看最终的网页，请在您的终端中输入显示的 IP 地址，通常是 `http://127.0.0.1:5000/`，将其输入到您的浏览器中查看渲染后的
    Web 应用程序，具体内容总结如下图所示：
- en: '![](img/B13208_09_07.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_07.png)'
- en: '**Flask documentation and examples**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flask 文档和示例**'
- en: If you are new to web development, some of those concepts may seem very complicated
    at first sight. In that case, simply set up the preceding files in a directory
    on your hard drive and examine them closely. You will see that the Flask web framework
    is relatively straightforward and much simpler than it might initially appear!
    Also, for more help, don't forget to consult the excellent Flask documentation
    and examples at [http://flask.pocoo.org/docs/1.0/](http://flask.pocoo.org/docs/1.0/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是 Web 开发新手，一开始可能会觉得一些概念非常复杂。这种情况下，只需在您的硬盘上创建上述文件，并仔细查看它们。您会发现 Flask Web 框架相对简单，远比它初看起来要容易！此外，如果需要更多帮助，别忘了查阅优秀的
    Flask 文档和示例，链接为 [http://flask.pocoo.org/docs/1.0/](http://flask.pocoo.org/docs/1.0/)。
- en: Turning the movie review classifier into a web application
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将电影评论分类器转化为 Web 应用程序
- en: 'Now that we are somewhat familiar with the basics of Flask web development,
    let''s advance to the next step and implement our movie classifier into a web
    application. In this section, we will develop a web application that will first
    prompt a user to enter a movie review, as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Flask Web 开发的基础知识有所了解，接下来让我们进入下一步，将我们的电影分类器实现为一个 Web 应用程序。在这一部分，我们将开发一个
    Web 应用程序，首先提示用户输入电影评论，如下图所示：
- en: '![](img/B13208_09_08.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_08.png)'
- en: 'After the review has been submitted, the user will see a new page that shows
    the predicted class label and the probability of the prediction. Furthermore,
    the user will be able to provide feedback about this prediction by clicking on
    the **Correct** or **Incorrect** button, as shown in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 提交评论后，用户将看到一个新页面，显示预测的类别标签和预测的概率。此外，用户还可以通过点击 **Correct** 或 **Incorrect** 按钮对预测结果提供反馈，如下所示的截图：
- en: '![](img/B13208_09_09.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_09.png)'
- en: If a user clicked on either the **Correct** or **Incorrect** button, our classification
    model will be updated with respect to the user's feedback. Furthermore, we will
    also store the movie review text provided by the user, as well as the suggested
    class label, which can be inferred from the button click, in an SQLite database
    for future reference. (Alternatively, a user could skip the update step and click
    the **Submit another review** button to submit another review.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击了 **Correct** 或 **Incorrect** 按钮，我们的分类模型将根据用户的反馈进行更新。此外，我们还将把用户提供的电影评论文本以及从按钮点击中推断出的建议类别标签存储到
    SQLite 数据库中，以便将来参考。（另外，用户也可以跳过更新步骤，点击 **Submit another review** 按钮提交另一条评论。）
- en: 'The third page that the user will see after clicking on one of the feedback
    buttons is a simple *thank you* screen with a **Submit another review** button
    that redirects the user back to the start page. This is shown in the following
    screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在点击反馈按钮后看到的第三个页面是一个简单的 *感谢* 页面，带有 **Submit another review** 按钮，点击该按钮将用户重定向回首页。如下所示的截图：
- en: '![](img/B13208_09_10.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_10.png)'
- en: '**Live demo**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时演示**'
- en: Before we take a closer look at the code implementation of this web application,
    take a look at this live demo at [http://raschkas.pythonanywhere.com](http://raschkas.pythonanywhere.com)
    to get a better understanding of what we are trying to accomplish in this section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们仔细查看此 Web 应用程序的代码实现之前，请访问 [http://raschkas.pythonanywhere.com](http://raschkas.pythonanywhere.com)
    查看实时演示，以便更好地理解我们在本节中要完成的任务。
- en: Files and folders – looking at the directory tree
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和文件夹 - 查看目录结构
- en: 'To start with the big picture, let''s take a look at the directory tree that
    we are going to create for this movie classification application, which is shown
    here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从整体上了解，先来看看我们将为这个电影分类应用程序创建的目录结构，如下所示：
- en: '![](img/B13208_09_11.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_11.png)'
- en: Earlier in this chapter, we created the `vectorizer.py` file, the SQLite database,
    `reviews.sqlite`, and the `pkl_objects` subdirectory with the pickled Python objects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们创建了 `vectorizer.py` 文件、SQLite 数据库 `reviews.sqlite` 以及 `pkl_objects`
    子目录，里面存储了已序列化的 Python 对象。
- en: The `app.py` file in the main directory is the Python script that contains our
    Flask code, and we will use the `review.sqlite` database file (which we created
    earlier in this chapter) to store the movie reviews that are being submitted to
    our web application. The `templates` subdirectory contains the HTML templates
    that will be rendered by Flask and displayed in the browser, and the `static`
    subdirectory will contain a simple CSS file to adjust the look of the rendered
    HTML code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 主目录中的 `app.py` 文件是包含 Flask 代码的 Python 脚本，我们将使用本章前面创建的 `review.sqlite` 数据库文件来存储提交到我们
    Web 应用程序中的电影评论。`templates` 子目录包含将由 Flask 渲染并显示在浏览器中的 HTML 模板，`static` 子目录则包含一个简单的
    CSS 文件，用于调整渲染 HTML 代码的外观。
- en: '**Getting the movieclassifier code files**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取 movieclassifier 代码文件**'
- en: A separate directory containing the movie review classifier application with
    the code discussed in this section is provided with the code examples for this
    book, which you can either obtain directly from Packt or download from GitHub
    at [https://github.com/rasbt/python-machine-learning-book-3rd-edition/](https://github.com/rasbt/python-machine-learning-book-3rd-edition/).
    The code in this section can be found in the `.../code/ch09/movieclassifier` subdirectory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的代码示例中提供了一个单独的目录，其中包含本节讨论的电影评论分类应用程序的代码，你可以直接从 Packt 获取或从 GitHub 下载，网址为 [https://github.com/rasbt/python-machine-learning-book-3rd-edition/](https://github.com/rasbt/python-machine-learning-book-3rd-edition/)。本节的代码可以在
    `.../code/ch09/movieclassifier` 子目录中找到。
- en: Implementing the main application as app.py
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将主应用程序实现为 app.py
- en: 'Since the `app.py` file is rather long, we will conquer it in two steps. The
    first section of `app.py` imports the Python modules and objects that we are going
    to need, as well as the code to unpickle and set up our classification model:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `app.py` 文件相当长，我们将分两步来处理。`app.py` 的第一部分导入了我们需要的 Python 模块和对象，并包含了解压和设置分类模型的代码：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This first part of the `app.py` script should look very familiar by now. We
    simply imported `HashingVectorizer` and unpickled the logistic regression classifier.
    Next, we defined a `classify` function to return the predicted class label, as
    well as the corresponding probability prediction of a given text document. The
    `train` function can be used to update the classifier, given that a document and
    a class label are provided.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 脚本的第一部分现在应该非常熟悉了。我们简单地导入了 `HashingVectorizer` 并解压了逻辑回归分类器。接着，我们定义了一个
    `classify` 函数，用来返回预测的类别标签，以及给定文本文档的相应概率预测。`train` 函数可以在提供文档和类别标签的情况下，用来更新分类器。'
- en: Using the `sqlite_entry` function, we can store a submitted movie review in
    our SQLite database along with its class label and timestamp for our personal
    records. Note that the `clf` object will be reset to its original, pickled state
    if we restart the web application. At the end of this chapter, you will learn
    how to use the data that we collect in the SQLite database to update the classifier
    permanently.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `sqlite_entry` 函数，我们可以将提交的电影评论连同其类别标签和时间戳一起存储到我们的 SQLite 数据库中，供个人记录使用。请注意，如果我们重新启动
    web 应用程序，`clf` 对象将被重置为其原始的、已序列化的状态。在本章结束时，您将学会如何使用我们在 SQLite 数据库中收集的数据来永久更新分类器。
- en: 'The concepts in the second part of the `app.py` script should also look quite
    familiar:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 脚本第二部分的概念也应该相当熟悉：'
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We defined a `ReviewForm` class that instantiates a `TextAreaField`, which will
    be rendered in the `reviewform.html` template file (the landing page of our web
    application). This, in turn, will be rendered by the `index` function. With the
    `validators.length(min=15)` parameter, we require the user to enter a review that
    contains at least 15 characters. Inside the `results` function, we fetch the contents
    of the submitted web form and pass it on to our classifier to predict the sentiment
    of the movie classifier, which will then be displayed in the rendered `results.html`
    template.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `ReviewForm` 类，该类实例化了一个 `TextAreaField`，该字段将渲染在 `reviewform.html` 模板文件中（即我们
    web 应用程序的首页）。这个字段又会被 `index` 函数渲染。通过 `validators.length(min=15)` 参数，我们要求用户输入至少包含
    15 个字符的评论。在 `results` 函数中，我们获取提交的网页表单内容，并将其传递给我们的分类器来预测电影的情感，预测结果将显示在渲染的 `results.html`
    模板中。
- en: The `feedback` function, which we implemented in `app.py` in the previous subsection,
    may look a little bit complicated at first glance. It essentially fetches the
    predicted class label from the `results.html` template if a user clicked on the
    **Correct** or **Incorrect** feedback button, and it transforms the predicted
    sentiment back into an integer class label that will be used to update the classifier
    via the `train` function, which we implemented in the first section of the `app.py`
    script. Also, a new entry to the SQLite database will be made via the `sqlite_entry`
    function if feedback was provided, and eventually, the `thanks.html` template
    will be rendered to thank the user for the feedback.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`feedback` 函数在 `app.py` 中的实现可能乍一看会显得有点复杂。它本质上是从 `results.html` 模板中获取预测的类别标签（如果用户点击了
    **正确** 或 **错误** 反馈按钮），然后将预测的情感转换回整数类别标签，以便通过我们在 `app.py` 脚本第一部分实现的 `train` 函数来更新分类器。如果提供了反馈，还会通过
    `sqlite_entry` 函数向 SQLite 数据库中添加新的记录，最终，`thanks.html` 模板将被渲染，感谢用户的反馈。'
- en: Setting up the review form
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置评论表单
- en: 'Next, let''s take a look at the `reviewform.html` template, which constitutes
    the starting page of our application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `reviewform.html` 模板，它构成了我们应用程序的起始页：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we simply imported the same `_formhelpers.html` template that we defined
    in the *Form validation and rendering* section earlier in this chapter. The `render_field`
    function of this macro is used to render a `TextAreaField` where a user can provide
    a movie review and submit it via the **Submit review** button displayed at the
    bottom of the page. This `TextAreaField` is 30 columns wide and 10 rows tall,
    and will look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅仅导入了之前在本章*表单验证与渲染*部分中定义的相同的`_formhelpers.html`模板。这个宏的`render_field`函数用于渲染一个`TextAreaField`，用户可以在其中提供电影评论，并通过页面底部显示的**提交评论**按钮提交。这一个`TextAreaField`宽度为30列，高度为10行，效果如下所示：
- en: '![](img/B13208_09_12.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_12.png)'
- en: Creating a results page template
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建结果页面模板
- en: 'Our next template, `results.html`, looks a little bit more interesting:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个模板，`results.html`，看起来稍微有点有趣：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we inserted the submitted review, as well as the results of the prediction,
    in the corresponding fields `{{ content }}`, `{{ prediction }}`, and `{{ probability
    }}`. You may notice that we used the `{{ content }}` and `{{ prediction }}` placeholder
    variables (in this context, also known as *hidden fields*) a second time in the
    form that contains the **Correct** and **Incorrect** buttons. This is a workaround
    to `POST` those values back to the server to update the classifier and store the
    review in case the user clicks on one of those two buttons.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将提交的评论以及预测结果插入到对应的字段`{{ content }}`、`{{ prediction }}`和`{{ probability
    }}`中。你可能会注意到，我们在包含**正确**和**错误**按钮的表单中第二次使用了`{{ content }}`和`{{ prediction }}`占位符变量（在此上下文中，也称为*隐藏字段*）。这是通过`POST`这些值回传给服务器，以便更新分类器并在用户点击这两个按钮中的一个时存储评论的解决方法。
- en: 'Furthermore, we imported a CSS file (`style.css`) at the beginning of the `results.html`
    file. The setup of this file is quite simple: it limits the width of the contents
    of this web application to 600 pixels and moves the **Incorrect** and **Correct**
    buttons labeled with the div id `button` down by 20 pixels:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还在`results.html`文件的开头导入了一个CSS文件（`style.css`）。该文件的设置相当简单：它将Web应用程序内容的宽度限制为600像素，并将带有div
    id `button`的**错误**和**正确**按钮向下移动了20像素：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This CSS file is merely a placeholder, so please feel free to modify it to adjust
    the look and feel of the web application to your liking.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CSS文件只是一个占位符，因此请随意修改它，以便根据你的喜好调整Web应用程序的外观和感觉。
- en: 'The last HTML file we will implement for our web application is the `thanks.html`
    template. As the name suggests, it simply provides a nice *thank you* message
    to the user after providing feedback via the **Correct** or **Incorrect** button.
    Furthermore, we will put a **Submit another review** button at the bottom of this
    page, which will redirect the user to the starting page. The contents of the `thanks.html`
    file are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为Web应用程序实现的最后一个HTML文件是`thanks.html`模板。顾名思义，它在用户通过**正确**或**错误**按钮提供反馈后，简单地向用户展示一条*感谢*信息。此外，我们还将在此页面底部放置一个**提交另一个评论**按钮，点击该按钮将把用户重定向到起始页面。`thanks.html`文件的内容如下：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, it would be a good idea to start the web application locally from our
    command-line terminal via the following command before we advance to the next
    subsection and deploy it on a public web server:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续进行下一小节并将应用程序部署到公共Web服务器之前，最好先通过以下命令在命令行终端中本地启动Web应用程序：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After we have finished testing our application, we also shouldn''t forget to
    remove the `debug=True` argument in the `app.run()` command of our `app.py` script
    (or set `debug=False` ) as illustrated in the following figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成应用程序的测试后，我们也不应该忘记删除`app.py`脚本中`app.run()`命令中的`debug=True`参数（或者设置`debug=False`），如下图所示：
- en: '![](img/B13208_09_13.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_13.png)'
- en: Deploying the web application to a public server
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Web应用程序到公共服务器
- en: After we have tested the web application locally, we are now ready to deploy
    our web application onto a public web server. For this tutorial, we will be using
    the PythonAnywhere web hosting service, which specializes in the hosting of Python
    web applications and makes it extremely simple and hassle-free. Furthermore, PythonAnywhere
    offers a beginner account option that lets us run a single web application free
    of charge.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们本地测试完Web应用程序后，现在可以将其部署到公共Web服务器上。对于本教程，我们将使用PythonAnywhere Web托管服务，该服务专门托管Python
    Web应用程序，使用起来非常简单方便。而且，PythonAnywhere提供了一个初学者账户选项，允许我们免费运行一个Web应用程序。
- en: Creating a PythonAnywhere account
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建PythonAnywhere账户
- en: To create a new PythonAnywhere account, we visit the website at [https://www.pythonanywhere.com/](https://www.pythonanywhere.com/)
    and click on the **Pricing & signup** link that is located in the top-right corner.
    Next, we click on the **Create a Beginner account** button where we need to provide
    a username, password, and valid email address. After we have read and agreed to
    the terms and conditions, we should have a new account.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 PythonAnywhere 账户，我们访问 [https://www.pythonanywhere.com/](https://www.pythonanywhere.com/)
    网站，点击右上角的**定价与注册**链接。接着，我们点击**创建初学者账户**按钮，在那里需要提供用户名、密码和有效的电子邮件地址。阅读并同意条款和条件后，我们就应该拥有一个新的账户。
- en: Unfortunately, the free beginner account doesn't allow us to access the remote
    server via the Secure Socket Shell (SSH) protocol from our terminal. Thus, we
    need to use the PythonAnywhere web interface to manage our web application. But
    before we can upload our local application files to the server, we need to create
    a new web application for our PythonAnywhere account. After we click on the **Dashboard**
    button in the top-right corner, we have access to the control panel shown at the
    top of the page. Next, we click on the **Web** tab that is now visible at the
    top of the page. We proceed by clicking on the **+Add a new web app** button on
    the left, which lets us create a new Python 3.7 Flask web application that we
    name `movieclassifier`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，免费的初学者账户不允许我们通过安全套接字外壳（SSH）协议从终端访问远程服务器。因此，我们需要使用 PythonAnywhere 的网页界面来管理我们的网页应用。但在将本地应用文件上传到服务器之前，我们需要为我们的
    PythonAnywhere 账户创建一个新的网页应用。在点击右上角的**仪表盘**按钮后，我们可以访问页面顶部显示的控制面板。接下来，我们点击页面顶部现在可见的**Web**标签。然后，我们点击左侧的**+
    添加新网页应用**按钮，这样就可以创建一个新的 Python 3.7 Flask 网页应用，并将其命名为 `movieclassifier`。
- en: Uploading the movie classifier application
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传电影分类器应用
- en: 'After creating a new application for our PythonAnywhere account, we head over
    to the **Files** tab to upload the files from our local `movieclassifier` directory
    using the PythonAnywhere web interface. After uploading the web application files
    that we created locally on our computer, we should have a `movieclassifier` directory
    in our PythonAnywhere account. It will contain the same directories and files
    as our local `movieclassifier` directory, as shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的 PythonAnywhere 账户创建了一个新应用后，我们前往**文件**标签页，使用 PythonAnywhere 的网页界面上传我们本地
    `movieclassifier` 目录中的文件。上传完我们在本地计算机上创建的网页应用文件后，我们的 PythonAnywhere 账户中应该会有一个 `movieclassifier`
    目录，它将包含与本地 `movieclassifier` 目录相同的目录和文件，如下图所示：
- en: '![](img/B13208_09_14.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13208_09_14.png)'
- en: Then, we head over to the **Web** tab one more time and click on the **Reload
    <username>.pythonanywhere.com** button to propagate the changes and refresh our
    web application. Finally, our web application should now be up and running and
    publicly available via `<username>.pythonanywhere.com`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次前往**Web**标签，点击**重新加载 <username>.pythonanywhere.com**按钮，以传播更改并刷新我们的网页应用。最后，我们的网页应用应该已经启动并运行，并通过
    `<username>.pythonanywhere.com` 公开可用。
- en: '**Troubleshooting**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障排除**'
- en: Unfortunately, web servers can be quite sensitive to the tiniest problems in
    our web application. If you are experiencing problems with running the web application
    on PythonAnywhere and are receiving error messages in your browser, you can check
    the server and error logs, which can be accessed from the **Web** tab in your
    PythonAnywhere account, to better diagnose the problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，网页服务器对我们网页应用中的任何小问题都非常敏感。如果你在 PythonAnywhere 上运行网页应用时遇到问题，并且浏览器中显示错误信息，你可以检查服务器和错误日志，这些日志可以从你的
    PythonAnywhere 账户中的**Web**标签访问，以便更好地诊断问题。
- en: Updating the movie classifier
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新电影分类器
- en: While our predictive model is updated on the fly whenever a user provides feedback
    about the classification, the updates to the `clf` object will be reset if the
    web server crashes or restarts. If we reload the web application, the `clf` object
    will be reinitialized from the `classifier.pkl` pickle file. One option to apply
    the updates permanently would be to pickle the `clf` object once again after each
    update. However, this would become computationally very inefficient with a growing
    number of users and could corrupt the pickle file if users provide feedback simultaneously.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每当用户提供分类反馈时，我们的预测模型都会即时更新，但如果 Web 服务器崩溃或重启，`clf` 对象的更新将会被重置。如果我们重新加载 Web 应用程序，`clf`
    对象将会从 `classifier.pkl` pickle 文件中重新初始化。为了永久应用更新，一个选择是在每次更新后再次对 `clf` 对象进行 pickling。然而，随着用户数量的增加，这样做会变得在计算上非常低效，并且如果用户同时提供反馈，pickle
    文件可能会损坏。
- en: 'An alternative solution is to update the predictive model from the feedback
    data that is being collected in the SQLite database. One option would be to download
    the SQLite database from the PythonAnywhere server, update the `clf` object locally
    on our computer, and upload the new pickle file to PythonAnywhere. To update the
    classifier locally on our computer, we create an `update.py` script file in the
    `movieclassifier` directory with the following contents:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是从收集到的 SQLite 数据库中的反馈数据中更新预测模型。一种选择是从 PythonAnywhere 服务器下载 SQLite 数据库，在本地计算机上更新
    `clf` 对象，然后将新的 pickle 文件上传到 PythonAnywhere。为了在本地计算机上更新分类器，我们需要在 `movieclassifier`
    目录中创建一个名为 `update.py` 的脚本文件，内容如下：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Getting the movieclassifier code files with the update functionality**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取具有更新功能的电影分类器代码文件**'
- en: A separate directory containing the movie review classifier application with
    the update functionality discussed in this chapter comes with the code examples
    for this book, which you can either obtain directly from Packt or download from
    GitHub at [https://github.com/rasbt/python-machine-learning-book-3rd-edition](https://github.com/rasbt/python-machine-learning-book-3rd-edition).
    The code in this section is located in the `.../code/ch09/movieclassifier_with_update`
    subdirectory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含本章讨论的带有更新功能的电影评论分类器应用程序的独立目录，随书提供的代码示例一同提供，您可以直接从 Packt 获取，或者从 GitHub 下载：[https://github.com/rasbt/python-machine-learning-book-3rd-edition](https://github.com/rasbt/python-machine-learning-book-3rd-edition)。本节中的代码位于
    `.../code/ch09/movieclassifier_with_update` 子目录中。
- en: The `update_model` function will fetch entries from the SQLite database in batches
    of 10,000 entries at a time, unless the database contains fewer entries. Alternatively,
    we could also fetch one entry at a time by using `fetchone` instead of `fetchmany`,
    which would be computationally very inefficient. However, keep in mind that using
    the alternative `fetchall` method could be a problem if we are working with large
    datasets that exceed the computer or server's memory capacity.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_model` 函数将一次性从 SQLite 数据库中批量获取 10,000 条记录，除非数据库中的记录更少。或者，我们也可以通过使用
    `fetchone` 代替 `fetchmany` 来逐条获取记录，但这样做会在计算上非常低效。然而，请记住，如果我们处理的是超过计算机或服务器内存容量的大型数据集，使用替代的
    `fetchall` 方法可能会成为一个问题。'
- en: 'Now that we have created the `update.py` script, we could also upload it to
    the `movieclassifier` directory on PythonAnywhere and import the `update_model`
    function in the main application script, `app.py`, to update the classifier from
    the SQLite database every time we restart the web application. In order to do
    so, we just need to add a line of code to import the `update_model` function from
    the `update.py` script at the top of `app.py`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 `update.py` 脚本，我们还可以将其上传到 PythonAnywhere 上的 `movieclassifier` 目录，并在主应用程序脚本
    `app.py` 中导入 `update_model` 函数，以便每次重新启动 Web 应用程序时从 SQLite 数据库中更新分类器。为此，我们只需要在
    `app.py` 顶部添加一行代码，导入 `update.py` 脚本中的 `update_model` 函数：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then need to call the `update_model` function in the main application body:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要在主应用程序代码中调用 `update_model` 函数：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As discussed, the modification in the previous code snippet will update the
    pickle file on PythonAnywhere. However, in practice, we do not often have to restart
    our web application, and it would make sense to validate the user feedback in
    the SQLite database prior to the update to make sure that the feedback is valuable
    information for the classifier.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前面的代码片段中的修改将更新 PythonAnywhere 上的 pickle 文件。然而，在实际操作中，我们并不经常需要重启 Web 应用程序，因此，在更新之前验证
    SQLite 数据库中的用户反馈，以确保这些反馈对分类器有价值，显得更加合理。
- en: '**Creating backups**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建备份**'
- en: 'In a real-world application, you may also want to back up the `classifier.pkl`
    pickle file periodically to have a safeguard against file corruption, for instance,
    by creating a timestamped version prior to each update. In order to create backups
    of the pickled classifier, you can import the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你可能还希望定期备份`classifier.pkl`的pickle文件，以防止文件损坏，例如在每次更新之前创建带时间戳的版本。为了创建pickle分类器的备份，你可以导入以下内容：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, above the code that updates the pickled classifier, which is as follows,
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在更新pickle分类器的代码上方，代码如下：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'insert the following lines of code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 插入以下代码行：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As a consequence, backup files of the pickled classifier will be created following
    the format `YearMonthDay-HourMinuteSecond`, for example, `classifier_20190822-092148.pkl`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，pickle后的分类器的备份文件将按照`YearMonthDay-HourMinuteSecond`的格式创建，例如`classifier_20190822-092148.pkl`。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about many useful and practical topics that will
    extend your knowledge of machine learning theory. You learned how to serialize
    a model after training and how to load it for later use cases. Furthermore, we
    created an SQLite database for efficient data storage and created a web application
    that lets us make our movie classifier available to the outside world.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了许多有用且实用的主题，这些内容将扩展你对机器学习理论的理解。你学习了如何在训练后序列化一个模型，以及如何加载它以供以后使用。此外，我们创建了一个SQLite数据库用于高效的数据存储，并创建了一个网页应用程序，让我们能够将我们的电影分类器提供给外部世界。
- en: So far, in this book, we have covered many machine learning concepts, best practices,
    and supervised models for classification. In the next chapter, we will take a
    look at another subcategory of supervised learning, regression analysis, which
    lets us predict outcome variables on a continuous scale, in contrast to the categorical
    class labels of the classification models that we have been working with so far.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经涵盖了许多机器学习概念、最佳实践以及用于分类的监督模型。在下一章中，我们将探讨监督学习的另一个子类别——回归分析，它可以让我们在连续尺度上预测结果变量，这与我们迄今为止所使用的分类模型的类别标签不同。
