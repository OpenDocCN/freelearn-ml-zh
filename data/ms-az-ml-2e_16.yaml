- en: '*Chapter 13*: Building a Recommendation Engine in Azure'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：在Azure中构建推荐引擎'
- en: In the previous chapter, we discussed distributed training methods for ML models,
    and you learned how to train distributed ML models efficiently in Azure. In this
    chapter, we will dive into traditional and modern recommendation engines, which
    often combine technologies and techniques covered in the previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了机器学习模型的分布式训练方法，并学习了如何在Azure中高效地训练分布式机器学习模型。在本章中，我们将深入探讨传统和现代推荐引擎，这些推荐引擎通常结合了前几章中介绍的技术和技巧。
- en: First, we will take a quick look at the different types of recommendation engines,
    what data is needed for each type, and what can be recommended using these different
    approaches. This will help you understand when to choose from non-personalized,
    content-based, or rating-based recommenders.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将快速浏览不同类型的推荐引擎，每种类型需要哪些数据，以及可以使用这些不同方法推荐什么。这将帮助您了解何时选择非个性化、基于内容或基于评分的推荐器。
- en: After this, we will dive into content-based recommendations, namely item-item
    and user-user recommenders, based on feature vectors and similarity. You will
    learn about cosine distance to measure the similarity between feature vectors
    and feature engineering techniques to avoid common pitfalls while building content-based
    recommendation engines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将深入探讨基于内容的推荐，即基于特征向量和相似度的项目-项目和用户-用户推荐器。您将学习如何使用余弦距离来衡量特征向量之间的相似性，以及如何通过特征工程技术避免在构建基于内容的推荐引擎时常见的陷阱。
- en: Subsequently, we will discuss rating-based recommendations that can be used
    once enough user-item interaction data has been collected. You will learn the
    difference between implicit and explicit ratings, develop your own implicit metric
    function, and think about the recency of user ratings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们将讨论在收集到足够的用户-项目交互数据后可以使用的基于评分的推荐。您将了解隐式评分和显式评分之间的区别，开发自己的隐式度量函数，并思考用户评分的时效性。
- en: In the section following this, we will combine content- and rating-based recommenders
    into a single hybrid recommender and learn about state-of-the-art techniques for
    modern recommendation engines. You will implement two recommenders using Azure
    Machine Learning, one using Python and one using Azure Machine Learning designer
    – the graphical UI of Azure Machine Learning.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将结合基于内容和基于评分的推荐器，构建一个单一的混合推荐器，并了解现代推荐引擎的最新技术。您将使用Azure机器学习实现两个推荐器，一个使用Python，另一个使用Azure机器学习设计器——Azure机器学习的图形用户界面。
- en: In the last section, we will look into an online recommender system as a service
    using reinforcement learning – Azure Personalizer. Having understood both content-
    and rating-based methods, you will learn how to improve your recommendations on
    the fly using a fitness function and online learning.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将探讨使用强化学习作为服务的在线推荐系统——Azure Personalizer。在理解了基于内容和基于评分的方法之后，您将学习如何使用适应函数和在线学习实时改进您的推荐。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to recommendation engines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐引擎简介
- en: A content-based recommender system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的推荐系统
- en: Collaborative filtering – a rating-based recommender system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协同过滤——基于评分的推荐系统
- en: Combining content and ratings in hybrid recommendation engines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在混合推荐引擎中结合内容和评分
- en: Automatic optimization through reinforcement learning
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过强化学习实现自动优化
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will use the following Python libraries and versions to
    create content- and rating-based recommendation engines, as well as hybrid and
    online recommenders:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下Python库和版本来创建基于内容和基于评分的推荐引擎，以及混合和在线推荐器：
- en: '`azureml-core 1.34.0`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azureml-core 1.34.0`'
- en: '`azureml-sdk 1.34.0`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azureml-sdk 1.34.0`'
- en: '`numpy 1.19.5`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy 1.19.5`'
- en: '`scipy 1.7.1`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scipy 1.7.1`'
- en: '`pandas 1.3.2`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pandas 1.3.2`'
- en: '`scikit-learn 0.24.2`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scikit-learn 0.24.2`'
- en: '`lightgbm 3.2.1`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightgbm 3.2.1`'
- en: '`pyspark 3.2.0`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyspark 3.2.0`'
- en: '`azure-cognitiveservices-personalizer 0.1.0`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azure-cognitiveservices-personalizer 0.1.0`'
- en: Similar to previous chapters, you can run this code using either a local Python
    interpreter or a notebook environment hosted in Azure Machine Learning.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章类似，您可以使用本地Python解释器或Azure机器学习托管的工作区中的笔记本环境运行此代码。
- en: For the Matchbox recommender example, you need to use Azure Machine Learning
    designer in your Azure Machine Learning workspace. For Azure Personalizer, you
    need to set up an Azure Personalizer resource in the Azure portal.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Matchbox推荐引擎的例子，你需要在Azure Machine Learning工作区中使用Azure Machine Learning designer。对于Azure
    Personalizer，你需要在Azure门户中设置一个Azure Personalizer资源。
- en: 'All code examples in this chapter can be found in the GitHub repository for
    this book: [https://github.com/PacktPublishing/Mastering-Azure-Machine-Learning-Second-Edition/tree/main/chapter13](https://github.com/PacktPublishing/Mastering-Azure-Machine-Learning-Second-Edition/tree/main/chapter13).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码示例都可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Mastering-Azure-Machine-Learning-Second-Edition/tree/main/chapter13](https://github.com/PacktPublishing/Mastering-Azure-Machine-Learning-Second-Edition/tree/main/chapter13)。
- en: Introduction to recommendation engines
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐引擎简介
- en: In today's digital world, recommendation engines are ubiquitous among many industries.
    Many online businesses, such as streaming, shopping, news, and social media, rely
    at their core on recommending the most relevant articles, news, and items to their
    users. How often have you clicked on a suggested video on YouTube, scrolled through
    your Facebook feed, listened to a personalized playlist on Spotify, or clicked
    on a recommended item on Amazon?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的数字世界中，推荐引擎在许多行业中无处不在。许多在线业务，如流媒体、购物、新闻和社交媒体，在其核心都依赖于向用户推荐最相关的文章、新闻和项目。你有多少次点击了YouTube上推荐的视频，浏览了你的Facebook动态，在Spotify上听了个性化的播放列表，或者在Amazon上点击了推荐的商品？
- en: If you ask yourself what the term *relevant* means for the different services
    and industries, you are on the right track. In order to recommend relevant information
    to the user, we need to first define a relevancy metric, and a way to describe
    and compare different items and their similarity. These two properties are the
    key to understanding the different recommendation engines. We will learn more
    about this in the following sections of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问自己，对于不同的服务和行业，“相关”这个术语意味着什么，你就在正确的道路上。为了向用户推荐相关内容，我们首先需要定义一个相关性指标，以及描述和比较不同项目及其相似性的方法。这两个属性是理解不同推荐引擎的关键。我们将在本章接下来的部分中了解更多关于这方面的内容。
- en: While the purpose of a recommendation engine is clear to most people, the different
    approaches are usually not. Hence, in order to better understand this, in this
    chapter, we will compare the different types of recommender systems and give some
    examples of them that you might have seen in your daily life. It's also worth
    mentioning that many services implement more than one of these approaches to produce
    great recommendations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数人对于推荐引擎的目的都很清楚，但不同的方法通常并不明显。因此，为了更好地理解这一点，在本章中，我们将比较不同类型的推荐系统，并给出一些你可能已经在日常生活中见过的例子。也值得提到的是，许多服务实施了这些方法中的多个，以产生出色的推荐。
- en: The easiest recommendation engines and methods are *non-personalized* recommendations.
    They are often used to show global interest (for example, Twitter global trends,
    popular Netflix shows, and a news website's front page) or trends where no user
    data is available. A good example is the recommendations of any streaming service
    that appear when you register and log into the service for the first time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单推荐引擎和方法是*非个性化*推荐。它们通常用于显示全球兴趣（例如，Twitter全球趋势、流行的Netflix节目和新闻网站首页）或没有可用用户数据的趋势。一个很好的例子是在你第一次注册并登录服务时，任何流媒体服务出现的推荐。
- en: 'Once you log into a web service and start using it moderately, you are usually
    confronted with *content-based recommendations*. Content-based recommenders look
    for similar items or items of similar users, based on the item and user profile
    features. User profile items can contain many personality-based or socio-demographic
    traits including the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你登录到一个网络服务并开始适度地使用它，你通常会面临*基于内容的推荐*。基于内容的推荐者会根据项目和使用者配置文件的特征寻找相似的项目或具有相似用户特征的项目。用户配置文件项目可以包含许多基于个性或社会人口统计特征的属性，包括以下内容：
- en: Age
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄
- en: Gender
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性别
- en: Nationality
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国籍
- en: Country of residence
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 居住国
- en: Mother tongue
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 母语
- en: Imagine logging into Amazon without having bought anything there yet. Most recommended
    items will be similar to the ones you just viewed or the ones matching your demographics
    and location.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在没有在Amazon上购买任何东西的情况下登录Amazon。大多数推荐的商品将与你刚刚查看的商品相似，或者与你的人口统计和位置相匹配。
- en: Once enough interaction data is available, you will start seeing *rating-based
    recommendations*, a method that is also called collaborative filtering. In rating-based
    recommenders, the users' interactions with items are transformed into explicit
    or implicit ratings. Based on these ratings, recommendations are made based on
    similar recommendations given by other users. Rating a movie on Netflix is an
    explicit rating, while watching a full 20-minute documentary on YouTube is an
    implicit rating. Therefore, a user will be shown movies liked by other people
    who also liked the movie that you just rated. And similarly, YouTube will show
    videos watched by other users who also watched the video you just saw.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有足够的交互数据可用，你将开始看到*基于评分的推荐*，这种方法也被称为协同过滤。在基于评分的推荐器中，用户与物品的交互被转换成显式或隐式的评分。基于这些评分，推荐是基于其他用户给出的相似推荐来进行的。在Netflix上评分一部电影是显式评分，而在YouTube上观看完整的20分钟纪录片是隐式评分。因此，用户将看到其他也喜欢你所评分电影的用户的电影。同样，YouTube将展示其他用户观看过而你刚刚看过的视频。
- en: Important Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Microsoft provides many different implementations for popular recommendation
    engines in their GitHub repository at [https://github.com/Microsoft/Recommenders/](https://github.com/Microsoft/Recommenders/).
    This makes it easy to get started, pick the right algorithm, and implement, train,
    and deploy a recommendation engine on Azure.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在其GitHub仓库[https://github.com/Microsoft/Recommenders/](https://github.com/Microsoft/Recommenders/)中提供了许多流行的推荐引擎的不同实现。这使得开始使用、选择正确的算法以及实现、训练和部署Azure上的推荐引擎变得容易。
- en: The next natural step is to combine both content- and rating-based recommenders
    into a single *hybrid recommendation engine* that can deal with both user ratings
    and cold-start users, who are users without ratings. The benefit of this approach
    is that both recommender systems are optimized together and create a combined
    recommendation. Azure Machine Learning Studio (classic) and Azure Machine Learning
    designer provide the building blocks to train and deploy the Matchbox recommender,
    an online Bayesian hybrid recommendation engine built by Microsoft Research.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个自然的步骤是将基于内容和基于评分的推荐器结合成一个单一的*混合推荐引擎*，它可以处理用户评分和没有评分的新用户。这种方法的好处是两个推荐系统一起优化，并创建一个综合推荐。Azure机器学习工作室（经典）和Azure机器学习设计器提供了训练和部署Matchbox推荐器的构建块，这是一个由微软研究院构建的在线贝叶斯混合推荐引擎。
- en: Another exciting new development in the past year was the introduction of hybrid
    online recommender optimization based on reinforcement learning. By providing
    a fitness function for the user rating, the algorithm can continuously learn to
    optimize this function. In the last section of this chapter, we will take a look
    at Azure Personalizer, a reinforcement learning-based recommendation engine as
    a service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 过去一年中另一个令人兴奋的新发展是基于强化学习的混合在线推荐优化。通过为用户评分提供一个适应函数，算法可以持续学习以优化此函数。在本章的最后部分，我们将探讨Azure
    Personalizer，这是一个基于强化学习的推荐引擎作为服务。
- en: Let's dive right into the methods discussed and develop some example solutions
    for scalable recommendation engines in Azure.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入讨论的方法，并为Azure的可扩展推荐引擎开发一些示例解决方案。
- en: A content-based recommender system
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的推荐系统
- en: We first start with content-based recommendations, as they are the most similar
    to what we previously discussed in this book. The term *content* refers to the
    usage of only an item's or user's content information in the shape of a (numeric)
    feature vector. The way to arrive at a feature vector from an item (an article
    in a web shop) or a user (a browser session in a web service) is through data
    mining, data pre-processing, and feature engineering – skills you learned in the
    previous chapters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从基于内容的推荐开始，因为它们与我们在这本书中之前讨论的内容最为相似。术语*内容*指的是仅使用物品或用户的（数值）特征向量形式的内容信息。从物品（网店中的文章）或用户（网络服务中的浏览器会话）到达特征向量的方式是通过数据挖掘、数据预处理和特征工程——这些技能你在前面的章节中学过。
- en: 'Using users'' and items'' feature vectors, we can divide content-based recommendations
    into roughly two approaches:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户和物品的特征向量，我们可以将基于内容的推荐分为大致两种方法：
- en: Item-item similarity
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物品-物品相似度
- en: User-user similarity
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户-用户相似度
- en: Hence, recommendations are based on the similarity of items or the similarity
    of users. Both approaches work great in cases where little to no interaction data
    between user and items is available (for example, a user with no purchase history
    on Amazon, no search history on YouTube, or no movies yet watched on Netflix –
    the so-called cold-start problem).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，推荐是基于项目之间的相似性或用户之间的相似性。这两种方法在用户和项目之间几乎没有交互数据的情况下效果很好（例如，在亚马逊上没有购买历史记录的用户，在YouTube上没有搜索历史记录，或者在Netflix上还没有观看过电影——所谓的冷启动问题）。
- en: You will always have to deal with the cold-start problem the moment you decide
    to roll out recommendations or the moment a new user starts using your service.
    In both cases, you don't have sufficient user-item interactions (so-called ratings)
    available and need to recommend items based on content only.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定推出推荐或新用户开始使用你的服务时，你将始终需要处理冷启动问题。在这两种情况下，你都没有足够的用户-项目交互（所谓的评分）数据，需要仅基于内容推荐项目。
- en: 'For the first approach, we design a system that recommends similar items to
    the one a user currently interacts with. When a user looks at an item, the recommender
    returns the most similar items. The item similarity is based on the similarity
    of the item''s feature vectors – we will see in the subsequent section how to
    compute this similarity. This approach can be used when no or little user interaction
    data is available. *Figure 13.1* visualizes this approach of recommending similar
    items based on content features and a single user interaction:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，我们设计了一个系统，该系统推荐与用户当前交互的项目相似的项目。当用户查看一个项目时，推荐器返回最相似的项目。项目相似性基于项目特征向量的相似性——我们将在下一节中看到如何计算这种相似性。当没有或几乎没有用户交互数据时，可以使用这种方法。*图13.1*展示了基于内容特征和单个用户交互推荐相似项目的这种方法：
- en: '![Figure 13.1 – Finding similar products using a content-based recommendation
    ](img/B17928_13_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 使用基于内容的推荐查找相似产品](img/B17928_13_01.jpg)'
- en: Figure 13.1 – Finding similar products using a content-based recommendation
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 使用基于内容的推荐查找相似产品
- en: 'Creating a playlist on Spotify will yield a box with recommended songs at the
    bottom, as shown in *Figure 13.2*. We can see that the recommended songs are based
    on the songs in the playlist; hence, it is similar content:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spotify上创建播放列表会在底部显示推荐歌曲的框，如图*图13.2*所示。我们可以看到，推荐的歌曲是基于播放列表中的歌曲；因此，它是相似的内容：
- en: '![Figure 13.2 – Spotify''s recommended songs ](img/B17928_13_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – Spotify的推荐歌曲](img/B17928_13_02.jpg)'
- en: Figure 13.2 – Spotify's recommended songs
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – Spotify的推荐歌曲
- en: We can see songs listed that are similar to the ones in the playlist – similar
    in terms of genre, style, artists, and many more features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到列出的歌曲与播放列表中的歌曲相似——在流派、风格、艺术家等多个方面相似。
- en: 'Clicking on a product on Amazon will yield a box with related products at the
    bottom of the page, as shown in *Figure 13.3*. Again, similar products mean it
    is a content-based recommendation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 点击亚马逊上的一个产品，页面底部会显示相关产品列表，如图*图13.3*所示。再次强调，相似产品意味着这是基于内容的推荐：
- en: '![Figure 13.3 – Amazon''s recommended products ](img/B17928_13_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 亚马逊的推荐产品](img/B17928_13_03.jpg)'
- en: Figure 13.3 – Amazon's recommended products
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 亚马逊的推荐产品
- en: This recommendation has nothing to do with your previous shopping experience
    and can be displayed even when no user-purchase history is found.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推荐与你的先前购物经验无关，即使没有找到用户购买历史记录，也可以显示。
- en: 'In the second approach, the system recommends similar users based on a user
    profile. From those similar users, we can then select the favorite items and present
    them as a recommendation. Please note that in digital systems, the user profile
    can be implicitly defined via location (for example, through an IP address), language,
    demographic, and device fingerprinting. This technique can be used when user-item
    interaction data is available from other users but not for the current user. *Figure
    13.4* visualizes this recommendation of the purchases of a similar user based
    on content features:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中，系统根据用户配置文件推荐相似用户。然后，我们可以从这些相似用户中选择最喜欢的项目，并将它们作为推荐展示。请注意，在数字系统中，用户配置文件可以通过位置（例如，通过IP地址）、语言、人口统计和设备指纹隐式定义。当可以从其他用户那里获得用户-项目交互数据，但不能为当前用户获得时，可以使用这种技术。*图13.4*展示了基于内容特征推荐的相似用户的购买：
- en: '![Figure 13.4 – Finding similar users using a content-based recommendation
    ](img/B17928_13_04.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 使用基于内容的推荐查找相似用户](img/B17928_13_04.jpg)'
- en: Figure 13.4 – Finding similar users using a content-based recommendation
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 使用基于内容的推荐寻找相似用户
- en: From a user's perspective, it is usually hard to distinguish between this kind
    of recommendation and a non-personalized recommendation (for example, the top
    products in your location for your demographic or your language – all properties
    that can be extracted from your browser's fingerprint).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，通常很难区分这种推荐与非个性化推荐（例如，你所在地区的顶级产品，针对你的人口统计或你的语言——所有这些都可以从你的浏览器指纹中提取出来的属性）。
- en: Measuring the similarity between items
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量项目之间的相似度
- en: 'The crucial part of training a content-based recommendation engine is to specify
    a metric that can measure and rank the similarity between two items. A popular
    choice is to use the **cosine similarity** or **cosine distance** between the
    items'' feature vectors to measure the similarity between two items. The *cosine
    similarity* is computed as the cosine of the angle between two vectors where a
    vector is an observation in the dataset. The *cosine distance* is computed as
    1 minus the cosine similarity. *Figure 13.5* shows two numeric feature vectors
    and the cosine distance between the feature vectors:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 训练基于内容的推荐引擎的关键部分是指定一个可以测量和排名两个项目之间相似度的度量标准。一个流行的选择是使用项目特征向量之间的**余弦相似度**或**余弦距离**来测量两个项目之间的相似度。**余弦相似度**是通过计算两个向量之间角度的余弦值来计算的，其中向量是数据集中的观察值。**余弦距离**是通过1减去余弦相似度来计算的。*图13.5*显示了两个数值特征向量和特征向量之间的余弦距离：
- en: '![Figure 13.5 – Cosine distance ](img/B17928_13_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 余弦距离](img/B17928_13_05.jpg)'
- en: Figure 13.5 – Cosine distance
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 余弦距离
- en: We can see in the figure that if both vectors are the same, the cosine distance
    between the two vectors is 0\. On the other hand, the cosine similarity yields
    1 when both vectors are pointing in the same direction, and 0 when both vectors
    are orthogonal to each other; hence, there is no similarity between the observations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从图中看到，如果两个向量相同，它们之间的余弦距离为0。另一方面，当两个向量指向同一方向时，余弦相似度产生1，当两个向量相互垂直时，余弦相似度为0；因此，观察值之间没有相似度。
- en: 'If you are unsure, you can always compute the cosine distance or similarity
    between two feature vectors using the following code (make sure that your DataFrame
    (`df`) has no additional `id` column and all columns are numeric):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定，你可以始终使用以下代码计算两个特征向量之间的余弦距离或相似度（确保你的DataFrame (`df`) 没有额外的 `id` 列，并且所有列都是数值型）：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Looking at the preceding snippet, I recommend you pick a few rows from your
    dataset, estimate their similarity (1 if they are the same or 0 if they are completely
    different), and then compute the cosine similarity using the aforementioned approach.
    If your guess and the computed approach are very different and you don't understand
    the reason, you'd better go back to data pre-processing and feature engineering.
    In the next section, you will learn the most common mistakes in feature engineering
    for recommender systems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的片段，我建议你从你的数据集中选择几行，估计它们的相似度（如果它们相同则为1，如果它们完全不同则为0），然后使用上述方法计算余弦相似度。如果你的猜测和计算的方法差异很大，并且你不理解原因，你最好回到数据预处理和特征工程。在下一节中，你将了解推荐系统中特征工程最常见的错误。
- en: Feature engineering for content-based recommenders
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于内容的推荐器的特征工程
- en: Training a content-based recommendation engine is very similar to training a
    classical ML model. For end-to-end ML pipelines, all the steps, such as data preparation,
    training, validation, optimization, and deployment, are the same and use very
    similar or even the same tools and libraries as any traditional embedding, clustering,
    regression, or classification technique.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 训练基于内容的推荐引擎与训练经典机器学习模型非常相似。对于端到端的机器学习管道，所有步骤，如数据准备、训练、验证、优化和部署，都是相同的，并且使用与任何传统嵌入、聚类、回归或分类技术非常相似甚至相同的工具和库。
- en: As for most other ML algorithms, great feature engineering is the key to good
    results from a recommendation engine. The difficulty for clustering-based recommenders
    is that most embeddings and similarity metrics only work in numeric space. While
    other techniques, such as tree-based classifiers, give you more freedom in the
    structure of input data, many clustering techniques require numeric features.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数其他机器学习算法，出色的特征工程是推荐引擎获得良好结果的关键。对于基于聚类的推荐器来说，困难在于大多数嵌入和相似度度量标准仅在数值空间中工作。虽然其他技术，如基于树的分类器，在输入数据的结构上给你更多的自由度，但许多聚类技术需要数值特征。
- en: Another important factor for training content-based recommenders is the semantic
    meaning of categorical features. Therefore, you most likely want to use advanced
    natural language processingmethods to embed categorical features into numerical
    space to capture this semantic meaning and provide it for the recommendation engine.
    The reason for the effect of categorical features in recommendation systems is
    based on the way similarity is measured.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 训练基于内容的推荐器的一个重要因素是分类特征的语义意义。因此，你很可能想使用高级自然语言处理方法将分类特征嵌入到数值空间中，以捕获这种语义意义并将其提供给推荐引擎。分类特征在推荐系统中的影响是基于相似度测量的方式。
- en: As we discussed in the previous section, a similarity is often expressed/measured
    as the cosine similarity and, hence, computing the cosine between two feature
    vectors. Therefore, even if there is only a single different character between
    two categorical values, those categorical values would yield a similarity of 0
    using one-hot encoding – although they are semantically very similar. Using simple
    label encoding, the results are even less obvious. With label encoding, the resulting
    similarity is now not only 0 but a non-interpretable value different from 0.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节所讨论的，相似性通常被表示/测量为余弦相似度，因此计算两个特征向量之间的余弦值。因此，即使两个分类值之间只有一个不同的字符，使用独热编码，这些分类值也会产生相似度为0的结果——尽管它们在语义上非常相似。使用简单的标签编码，结果甚至更不明显。使用标签编码，得到的相似度现在不仅是0，而且是一个与0不同的不可解释的值。
- en: Therefore, we recommend semantic embedding of nominal/textual variables in order
    to capture their semantic meaning in numeric space and avoid common pitfalls,
    with categorical embeddings leaking into the similarity metric.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议对名义/文本变量进行语义嵌入，以在数值空间中捕获它们的语义意义并避免常见的陷阱，因为分类嵌入会泄露到相似度指标中。
- en: In general, there are two possible ways to implement content-based recommenders.
    If you are looking for a pure similarity, you can use any non-supervised embedding
    and clustering technique for finding similar items or users. The second possibility
    is to implement the recommender as a regression or classification technique. With
    this, you can predict a discrete or continuous value of relevance for all items,
    only considering item features or combinations of an item and user features. We
    will take a look at an example method in the subsequent section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有两种可能的实现基于内容的推荐器的方法。如果你在寻找纯相似度，你可以使用任何无监督的嵌入和聚类技术来寻找相似的项目或用户。第二种可能性是将推荐器实现为回归或分类技术。这样，你可以预测所有项目的相关性的离散或连续值，只考虑项目特征或项目与用户特征的组合。在下一节中，我们将查看一个示例方法。
- en: Content-based recommendations using gradient boosted trees
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于内容的推荐使用梯度提升树
- en: For our content-based model, we will use the *Criteo dataset* to predict the
    **Click-Through Rate** (**CTR**) per article, based on article features. We will
    use the predicted CTR to recommend articles with the highest predicted CTR. As
    you can see, it's very simple to formulate a content-based recommendation engine
    as a standard classification or regression problem.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的基于内容的模型，我们将使用*Criteo数据集*来预测每篇文章的**点击通过率**（CTR），基于文章特征。我们将使用预测的CTR来推荐预测CTR最高的文章。正如你所看到的，将基于内容的推荐引擎表述为一个标准的分类或回归问题非常简单。
- en: 'For this example, we will use a gradient-boosted tree regressor from LightGBM.
    The model to predict the CTR is very similar to any regression model previously
    trained in this book. Let''s get started:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用LightGBM中的梯度提升树回归器。预测点击通过率（CTR）的模型与本书中之前训练的任何回归模型非常相似。让我们开始吧：
- en: 'First, we define the parameters for the LightGBM model:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义LightGBM模型的参数：
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we define the training and test set as LightGBM datasets:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将训练集和测试集定义为LightGBM数据集：
- en: '[PRE2]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using this information, we can now train the model:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些信息，我们现在可以训练模型：
- en: '[PRE3]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we can evaluate the model performance by predicting the CTR and computing
    the area under the ROC curve as an error metric:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过预测CTR并计算ROC曲线下的面积作为错误指标来评估模型性能：
- en: '[PRE4]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great! You have learned to create recommendations based on item similarities.
    However, these recommendations have a poor diversity and will only recommend similar
    items. Therefore, they can be used when no user-item interaction data is available
    but will perform poorly once the user is active on your service. A better recommendation
    engine would recommend a variety of different items to help users explore and
    discover new and unrelated items they might like. This is exactly what we will
    do with collaborative filtering in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你已经学会了如何根据项目相似性创建推荐。然而，这些推荐缺乏多样性，只会推荐相似的项目。因此，当没有用户-商品交互数据可用时，它们可以发挥作用，但一旦用户开始使用你的服务，它们的性能就会很差。一个更好的推荐引擎会推荐各种不同的项目，以帮助用户探索和发现他们可能喜欢的新和无关的项目。这正是我们在下一节中将要使用协同过滤来做的。
- en: Collaborative filtering – a rating-based recommender system
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤 – 一种基于评分的推荐系统
- en: By recommending only similar items or items from similar users, your users might
    get bored of the recommendations provided due to the lack of diversity and variety.
    Once a user starts interacting with a service (for example, watching videos on
    YouTube, reading and liking posts on Facebook, or rating movies on Netflix), we
    want to provide them with great personalized recommendations and relevant content
    to keep them happy and engaged. A great way to do so is to provide a good mix
    of similar content and new content to explore and discover.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过只推荐相似的项目或来自相似用户的商品，你的用户可能会因为缺乏多样性和变化而厌倦提供的推荐。一旦用户开始与一个服务（例如，在 YouTube 上观看视频，在
    Facebook 上阅读和点赞帖子，或在 Netflix 上评分电影）互动，我们希望为他们提供出色的个性化推荐和相关的内容，以保持他们的快乐和参与度。这样做的一个好方法是提供相似内容和新内容的好混合，以供探索和发现。
- en: 'Collaborative filtering is a popular approach for providing such diverse recommendations
    by comparing user-item interactions, finding other users who interact with similar
    items, and recommending items that those users also interacted with. It''s almost
    as if you were to build many custom stereotypes and recommend other items consumed
    from by same stereotype. *Figure 13.6* illustrates this example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤是一种流行的推荐方法，通过比较用户-商品交互，找到与其他人互动相似项目的用户，并推荐那些用户也互动过的项目。这几乎就像你构建了许多定制的刻板印象，并推荐其他由相同刻板印象消费的项目。*图
    13.6* 展示了这个例子：
- en: '![Figure 13.6 – Finding similar user ratings using collaborative filtering
    ](img/B17928_13_06.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 使用协同过滤查找相似的用户评分](img/B17928_13_06.jpg)'
- en: Figure 13.6 – Finding similar user ratings using collaborative filtering
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 使用协同过滤查找相似的用户评分
- en: As the person on the left buys similar items to the person on the right, we
    can recommend a new item to the person on the left that the person on the right
    bought. In this case, the user-item interaction is a person buying a product.
    However, in recommender language, we speak about ratings as a term summarizing
    all possible interactions between a user and an item. Let's look at building such
    a rating function (also called a feedback function).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当左边的人购买与右边的人相似的商品时，我们可以向左边的人推荐右边的人购买的新商品。在这种情况下，用户-商品交互是一个人购买产品。然而，在推荐系统中，我们谈论评分作为一个术语，它总结了用户和商品之间所有可能的交互。让我们看看如何构建这样的评分函数（也称为反馈函数）。
- en: 'One great example of amazing rating-based recommendations are the personalized
    recommended playlists in Spotify, as shown in *Figure 13.7*. In contrast to the
    previous Spotify recommendation at the bottom of each playlist, these recommendations
    are personalized based on my interaction history and feedback:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于评分的推荐的一个很好的例子是 Spotify 中的个性化推荐播放列表，如图 *图 13.7* 所示。与之前在播放列表底部的 Spotify 推荐相比，这些推荐是基于我的互动历史和反馈进行个性化的：
- en: '![Figure 13.7 – Spotify''s rating-based song recommendation ](img/B17928_13_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – Spotify 的基于评分的歌曲推荐](img/B17928_13_07.jpg)'
- en: Figure 13.7 – Spotify's rating-based song recommendation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – Spotify 的基于评分的歌曲推荐
- en: These playlists contain songs similar to the ones I listened to and that are
    also listened to by other people with my taste. Another nifty extension is that
    the song recommendations are categorized by genre into these six playlists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些播放列表包含与我听过的歌曲相似的歌曲，并且也是与我品味相似的其他人听过的歌曲。另一个巧妙的扩展是，歌曲推荐根据流派分类到这六个播放列表中。
- en: What is a rating? Explicit feedback versus implicit feedback
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评分是什么？显式反馈与隐式反馈
- en: A **feedback function** (or rating) quantifies the interaction between a user
    and an item. We differentiate between two types of feedback – explicit ratings
    (or non-observable feedback) and implicit ratings (or directly observable feedback).
    An **explicit rating** would be leaving a five-star review of a product on Amazon,
    whereas an **implicit rating** is buying the said product. While the former is
    a biased decision of the user, the latter can be objectively observed and evaluated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**反馈函数**（或评分）量化了用户与项目之间的互动。我们区分两种类型的反馈——明确评分（或不可观察的反馈）和隐式评分（或直接可观察的反馈）。**明确评分**可能是对亚马逊上的产品留下五星评价，而**隐式评分**则是购买该产品。虽然前者是用户的主观决定，但后者可以客观地观察到并评估。'
- en: The most obvious form of rating is to explicitly ask the user for feedback –
    for example, to rate a certain movie, song, article, or the helpfulness of a support
    document. This is the method most people think about when first implementing recommendations
    engines. In the case of an explicit rating, we cannot directly observe the user's
    sentiment but must rely on the user's ability to quantify their sentiment with
    a rating, such as rating a movie on an ordinal scale from one to five.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的评分形式是明确要求用户进行反馈——例如，对某部电影、歌曲、文章或支持文档的有用性进行评分。这是人们在首次实施推荐引擎时首先想到的方法。在明确评分的情况下，我们无法直接观察到用户的情感，但必须依赖用户使用评分来量化他们的情感，例如在从一到五的顺序尺度上对电影进行评分。
- en: There are many problems with explicit ratings – especially on ordinal scales
    (for example, stars from one to five) – that we should consider when building
    our feedback function. Most people will have a bias when rating items on an ordinal
    scale – for example, some users might rate a movie 3/5 if they are unsatisfied
    and 5/5 if they liked the movie, while other users might rate 1/5 for a bad movie,
    3/5 for a good one, and only very rarely 5/5 for an exceptional one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 明确评分存在许多问题——尤其是在顺序尺度上（例如，从一到五的星级）——我们在构建反馈函数时应加以考虑。大多数人在对顺序尺度上的项目进行评分时都会存在偏见——例如，一些用户如果对电影不满意可能会评3/5，如果喜欢则评5/5，而其他用户可能会对糟糕的电影评1/5，对好的电影评3/5，而只有极少数情况下会评5/5。
- en: Therefore, the ordinal scales either need to be normalized across users or you'll
    need to use a binary scale (such as thumbs up/thumbs down) to collect binary feedback.
    Binary feedback is usually much easier to handle, as we can remove the user bias
    from the feedback function, simplify the error metric, and therefore provide better
    recommendations. Many popular streaming services nowadays collect binary (thumbs
    up/thumbs down, star/unstar, and so on) feedback.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，顺序尺度要么需要在用户之间进行标准化，要么你需要使用二进制尺度（如点赞/踩不点赞）来收集二进制反馈。二进制反馈通常更容易处理，因为我们可以从反馈函数中去除用户偏见，简化误差指标，从而提供更好的推荐。如今，许多流行的流媒体服务收集二进制（点赞/踩不点赞、星标/取消星标等）反馈。
- en: 'Here is a little snippet to help normalize user ratings. It applies a normalization
    across each group of user ratings:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小片段可以帮助标准化用户评分。它对每个用户评分组应用标准化：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another popular way to train recommender systems is to build an implicit feedback
    function based on the direct observation of an implicit user rating. This has
    the benefit that the user feedback is unbiased. Common implicit ratings include
    the user adding an item to the cart, the user buying the item, the user scrolling
    to the end of the article, and the user watching the full video to the end.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 训练推荐系统的另一种流行方法是建立一个基于直接观察隐式用户评分的隐式反馈函数。这有一个好处，即用户反馈是无偏见的。常见的隐式评分包括用户将项目添加到购物车、用户购买项目、用户滚动到文章的末尾以及用户观看完整视频到结束。
- en: One additional problem to consider is that the way a user interacts with items
    will change over time. This could be due to a user's habit due to consuming more
    and more items on the service or changing user preferences. Recommending a video
    to you that you once liked in your childhood might not be helpful to another adult.
    Similar to this user drift, the popularity of items will also change over time.
    Recommending the song *Somebody That I Used to Know* to a user today might not
    lead to the same CTR as in 2011\. Therefore, we also must model time and account
    for temporal drift in our item ratings and feedback function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是，用户与项目互动的方式会随时间而变化。这可能是由于用户在服务上消费越来越多的项目而形成的习惯，或者是因为用户偏好的改变。向一个曾经喜欢童年视频的用户推荐视频可能对另一个成年人没有帮助。与这种用户漂移相似，项目的流行度也会随时间变化。今天向用户推荐歌曲
    *Somebody That I Used to Know* 可能不会像 2011 年那样带来相同的点击率。因此，我们也必须在项目评分和反馈函数中建模时间和考虑时间漂移。
- en: 'The time drift of explicit or implicit ratings can be modeled using exponential
    time decay on the numeric rating. Depending on the business rules, we can, for
    example, use explicit ratings with a binary scale [1, -1] and exponentially decay
    these ratings with a half-life time of 1 year. Hence, after 1 year, a rating of
    1 becomes 0.5; after 2 years, it becomes 0.25, and so on. Here is a snippet to
    exponentially decay your ratings:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用指数时间衰减在数值评分上对显式或隐式评分的时间漂移进行建模。根据业务规则，例如，我们可以使用具有二进制刻度 [1, -1] 的显式评分，并以 1
    年的半衰期对这些评分进行指数衰减。因此，1 年后，评分为 1 的评分变为 0.5；2 年后，变为 0.25，依此类推。以下是一个指数衰减评分的示例：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We learned that the choice of a proper feedback function matters greatly and
    is as important for designing a rating-based recommendation engine as feature
    engineering is for content-based recommenders.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，选择合适的反馈函数非常重要，并且对于设计基于评分的推荐引擎来说，与内容推荐器中的特征工程一样重要。
- en: Predicting the missing ratings to make a recommendation
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测缺失评分以做出推荐
- en: 'By collecting user-item ratings, we generate a sparse user-item-rating matrix
    that looks similar to *Figure 13.8*. However, in order to make a recommendation,
    we first need to fill the unknown ratings displayed red in the diagram. Collaborative
    filtering is about filling the blank rows or columns of the user-item-ratings
    matrix, depending on the prediction use case:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过收集用户-项目评分，我们生成一个类似于 *图 13.8* 的稀疏用户-项目-评分矩阵。然而，为了做出推荐，我们首先需要填写图中显示为红色的未知评分。协同过滤是根据预测用例来填充用户-项目-评分矩阵中的空白行或列：
- en: '![Figure 13.8 – The user-item-ratings matrix ](img/B17928_13_08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 用户-项目-评分矩阵](img/B17928_13_08.jpg)'
- en: Figure 13.8 – The user-item-ratings matrix
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 用户-项目-评分矩阵
- en: To recommend the best movie for Alice, we only need to compute the first row
    of the rating matrix, whereas to compute the best candidates for Terminator, we
    only need to compute the last column of the matrix. It is important to know that
    we don't have to compute the whole matrix all the time, which helps to significantly
    improve the recommendation performance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向 Alice 推荐最佳电影，我们只需要计算评分矩阵的第一行，而为了计算终结者的最佳候选人，我们只需要计算矩阵的最后一列。重要的是要知道，我们不必每次都计算整个矩阵，这有助于显著提高推荐性能。
- en: You can also probably already guess that this matrix will get really, really
    large as the number of users and/or items grows. Therefore, we need an efficient
    parallelizable algorithm for computing the blank ratings in order to make a recommendation.
    The most popular method to solve this problem is to use matrix factorization and,
    hence, decompose the matrix into a product of two lower dimensional matrices.
    These two matrices and their dimensions can be interpreted as user trait and item
    trait matrices; by way of analogy, the dimension refers to the number of different
    distinct traits – the so-called latent representation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也已经猜到，随着用户和/或项目数量的增加，这个矩阵会变得非常大。因此，我们需要一个高效的并行算法来计算空白评分，以便做出推荐。解决这个问题的最流行的方法是使用矩阵分解，因此将矩阵分解为两个低维矩阵的乘积。这两个矩阵及其维度可以解释为用户特征矩阵和项目特征矩阵；通过类比，维度指的是不同独特特征的数目——所谓的潜在表示。
- en: Once the latent representation is known, we can fill the missing ratings by
    multiplying the correct rows and columns from the latent trait matrices. A recommendation
    can then be made by using the top *n* highest computed ratings. But that's enough
    of the theory – let's look at an example using the `PySpark`. Apart from the method,
    everything else in the pipeline is the same as in a standard ML pipeline.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了潜在表示，我们可以通过乘以潜在特质矩阵中的正确行和列来填充缺失的评分。然后，可以通过使用计算出的最高* n* 个评分来做出推荐。但理论就到这里了——让我们看看使用`PySpark`的例子。除了方法之外，管道中的其他所有内容都与标准ML管道相同。
- en: Similar to all previous pipelines, we also compute a training and testing set
    for validating the model performance using a grouped selection algorithm (for
    example, `LeavePGroupsOut` and `GroupShuffleSplit`), performing training, optimizing
    the hyperparameters, validating the model test performance, and eventually, stacking
    multiple models together. As in many other methods, most models are trained using
    gradient descent. We can also use a standard regression loss function, such as
    the **RMSE**, to compute the fit of our recommendations on the test set. Let's
    dive into the example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有之前的管道类似，我们也计算了用于验证模型性能的训练集和测试集，使用分组选择算法（例如，`LeavePGroupsOut`和`GroupShuffleSplit`），执行训练、优化超参数、验证模型测试性能，最后，将多个模型堆叠在一起。正如许多其他方法一样，大多数模型都是使用梯度下降进行训练的。我们还可以使用标准的回归损失函数，如**RMSE**，来计算我们的推荐在测试集上的拟合度。让我们深入到例子中。
- en: Scalable recommendations using ALS factorization
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ALS分解进行可扩展的推荐
- en: To train a large collaborative filtering model using matrix factorization, we
    need an algorithm that is easily distributable. The ALS algorithm of the Spark
    `MLlib` package is an excellent choice – however, many other algorithms for factorizing
    matrices are available, such as *Bayesian personalized ranking*, FastAI's *EmbeddingDotBias*,
    or *neural collaborative filtering*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用矩阵分解训练一个大型协同过滤模型，我们需要一个易于分布的算法。Spark `MLlib`包中的ALS算法是一个很好的选择——然而，还有许多其他用于矩阵分解的算法，例如*贝叶斯个性化排名*、FastAI的*嵌入点偏差*或*神经协同过滤*。
- en: Important Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A summary of example applications using the preceding methods can be found on
    Microsoft's GitHub repository at [https://github.com/Microsoft/Recommenders](https://github.com/Microsoft/Recommenders).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的示例应用总结可以在微软的GitHub仓库[https://github.com/Microsoft/Recommenders](https://github.com/Microsoft/Recommenders)中找到。
- en: 'By using Spark, or more precisely PySpark – the Python bindings for Spark and
    its libraries – we can take advantage of the distributed computing framework of
    Spark. While it''s possible to run Spark on a single-node, single-core process
    locally, it can be easily distributed to a cluster with hundreds and thousands
    of nodes. Hence, it is a good choice, as your code automatically becomes scalable
    if your input data scales and exceeds the memory limits of a single node:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Spark，或者更确切地说，PySpark——Spark及其库的Python绑定——我们可以利用Spark的分布式计算框架。虽然可以在本地单节点、单核进程中运行Spark，但它可以轻松地扩展到拥有数百甚至数千个节点的集群。因此，它是一个很好的选择，因为如果你的输入数据规模扩大并超过了单个节点的内存限制，你的代码会自动变得可扩展：
- en: 'Let''s first create and parametrize an ALS estimator in PySpark using `MLlib`,
    the standard ML library of Spark. We will find `ALS` in the recommendation package
    of `MLlib`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在PySpark中使用`MLlib`（Spark的标准ML库）创建和参数化一个ALS估计器。我们将在`MLlib`的推荐包中找到`ALS`：
- en: '[PRE7]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we initialize the `ALS` estimator and define the number
    of iterations for gradient descent optimization, the rank of the latent trait
    matrices, and the L2 regularization constant.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们初始化了`ALS`估计器，并定义了梯度下降优化的迭代次数、潜在特质矩阵的秩和L2正则化常数。
- en: 'Next, we fit the model using this estimator:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用这个估计器来拟合模型：
- en: '[PRE8]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That''s all we have to do. Once the model is successfully trained, we can now
    predict the ratings for the test set by calling the `transform` method on the
    trained model:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们必须要做的。一旦模型成功训练，我们就可以通过在训练模型上调用`transform`方法来预测测试集的评分：
- en: '[PRE9]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To compute the performance of the recommendations, we use a regression evaluator
    and the `rmse` metric as a scoring function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了计算推荐的性能，我们使用回归评估器和`rmse`指标作为评分函数：
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To compute the `rmse` score, we simply call the `evaluate` method on the `scoring`
    object:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了计算`rmse`评分，我们只需在`scoring`对象上调用`evaluate`方法：
- en: '[PRE11]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Congratulations! You successfully implemented a rating-based recommendation
    engine with a collaborative filtering approach by factorizing the user-item-ratings
    matrix. Have you realized that this approach is similar to finding the eigenvectors
    of a matrix and that they can be interpreted as user stereotypes (or user tastes,
    traits, and so on)? While this approach is great for creating diverse recommendations,
    it requires the availability of (many) user-item ratings. Therefore, it would
    work great in a service with a lot of user interaction and poorly with completely
    new users (the cold-start problem).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功实现了一个基于评分的推荐引擎，该引擎通过分解用户-项目评分矩阵采用协同过滤方法。您是否意识到这种方法类似于寻找矩阵的特征向量，并且它们可以被解释为用户原型（或用户口味、特质等）？虽然这种方法非常适合创建多样化的推荐，但它需要（许多）用户-项目评分的可用性。因此，它非常适合用户交互频繁的服务，而对于完全新用户（冷启动问题）则效果不佳。
- en: Combining content and ratings in hybrid recommendation engines
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在混合推荐引擎中结合内容和评分
- en: Instead of seeing rating-based recommenders as a successor to content-based
    recommenders, you should consider them as a different recommender after having
    acquired enough user-item interaction data to provide rating-only recommendations.
    In most practical cases, a recommendation engine will exist for both approaches
    – either as two distinct algorithms or a single hybrid model. In this section,
    we will look into training such a hybrid model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与将基于评分的推荐器视为基于内容的推荐器的继任者不同，你应该在积累了足够用户-项目交互数据以提供仅评分推荐之后，将它们视为一种不同的推荐器。在大多数实际情况下，推荐引擎将同时存在这两种方法——要么是两种不同的算法，要么是一个单一的混合模型。在本节中，我们将探讨如何训练这样的混合模型。
- en: 'To build a state-of-the-art recommender using the **Matchbox recommender**,
    open Azure Machine Learning designer and add the building blocks for the Matchbox
    recommender to the canvas, as shown in the following diagram. As we can see, the
    recommender can now take ratings and user and item features as input to create
    a hybrid recommendation model:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**Matchbox推荐器**构建最先进的推荐器，请打开Azure机器学习设计器，并将Matchbox推荐器的构建块添加到画布上，如图下所示。正如我们所看到的，推荐器现在可以接受评分和用户及项目特征作为输入，以创建混合推荐模型：
- en: '![Figure 13.9 – The Matchbox recommender in Azure Machine Learning designer
    ](img/B17928_13_09.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图13.9 – Azure机器学习设计器中的Matchbox推荐器](img/B17928_13_09.jpg)'
- en: Figure 13.9 – The Matchbox recommender in Azure Machine Learning designer
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 – Azure机器学习设计器中的Matchbox推荐器
- en: In order to configure the Matchbox recommender, we need to configure the number
    of traits and, hence, the dimensions of the latent space matrices. We set this
    value to 10\. Similar to the content-based recommender, instead of feeding raw
    unprocessed feature vectors into the recommender, we should pre-process the data
    and encode categorical variables using advanced NLP techniques.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置Matchbox推荐器，我们需要配置特质的数量，从而确定潜在空间矩阵的维度。我们将此值设置为10。类似于基于内容的推荐器，我们不应将原始未经处理的特征向量直接输入到推荐器中，而应该预处理数据，并使用高级NLP技术对分类变量进行编码。
- en: Once you have built the recommendation engine in Azure Machine Learning designer,
    you simply press **Run** to train the model. You can also pull-request input and
    output blocks to the canvas to deploy this model as a web service.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在Azure机器学习设计器中构建了推荐引擎，只需简单地按**运行**来训练模型。您还可以将输入和输出块拖放到画布上，以将此模型作为Web服务部署。
- en: Currently, the Matchbox recommender is only available through the graphical
    interface. However, you can use other hybrid models, such as Extreme Deep Factorization
    Machines and Wide and Deep, to train hybrid recommenders from Python.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Matchbox推荐器仅通过图形界面提供。但是，您可以使用其他混合模型，如极端深度因子分解机和宽深度，从Python中训练混合推荐器。
- en: Hybrid recommenders are very powerful, as they help avoid the cold-start problem
    but refine recommendations based on ratings once a user provides item ratings.
    However, the additional ratings are only used to refine predictions, and similar
    to all previous techniques, hybrid recommenders have to be trained before being
    deployed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 混合推荐器非常强大，因为它们有助于避免冷启动问题，但一旦用户提供了项目评分，就会根据评分来细化推荐。然而，额外的评分仅用于细化预测，并且类似于所有之前的技巧，混合推荐器在部署之前必须进行训练。
- en: In the next section, we will take a look at recommenders that can be deployed
    without any user ratings and trained online while users interact with items –
    recommenders based on reinforcement learning.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一种无需用户评分即可部署，并在用户与物品互动时在线训练的推荐器——基于强化学习的推荐器。
- en: Automatic optimization through reinforcement learning
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过强化学习进行自动优化
- en: You can improve your recommendations by providing online training techniques,
    which will retrain your recommender systems after every user-item interaction.
    By replacing the feedback function with a reward function and adding a reinforcement
    learning model, we can now make recommendations, make decisions, and optimize
    choices that optimize the reward function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过提供在线训练技术来改进您的推荐，这些技术会在每次用户与物品互动后重新训练您的推荐系统。通过用奖励函数替换反馈函数并添加强化学习模型，我们现在可以做出推荐、做出决策，并优化选择以优化奖励函数。
- en: This is a fantastic new approach to training recommender models. The Azure Personalizer
    service offers exactly this functionality – to make and optimize decisions and
    choices by providing contextual features and a reward function to the user. Azure
    Personalizer uses contextual bandits, an approach to reinforcement learning that
    is framed around making decisions or choices between discrete actions in a given
    context.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种训练推荐模型的新颖方法。Azure Personalizer服务正好提供了这种功能——通过向用户提供上下文特征和奖励函数来做出和优化决策和选择。Azure
    Personalizer使用上下文赌博机，这是一种围绕在给定上下文中做出或选择离散动作的强化学习方法。
- en: Important Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Under the hood, Azure Personalizer uses the Vowpal Wabbit ([https://github.com/VowpalWabbit/vowpal_wabbit/wiki](https://github.com/VowpalWabbit/vowpal_wabbit/wiki))
    learning system from Microsoft Research to provide high-throughput and low-latency
    optimization for the recommendation system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Azure Personalizer使用微软研究机构的Vowpal Wabbit ([https://github.com/VowpalWabbit/vowpal_wabbit/wiki](https://github.com/VowpalWabbit/vowpal_wabbit/wiki))
    学习系统，为推荐系统提供高吞吐量和低延迟的优化。
- en: From a developer's perspective, Azure Personalizer is quite easy to use. The
    basic recommender API consists of two main requests, the rank request and the
    reward request. During the rank request, we send the user features of the current
    user, plus all possible item features, to the API which returns a ranking of those
    items and an event ID in the response.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，Azure Personalizer非常易于使用。基本的推荐器API由两个主要请求组成，即排名请求和奖励请求。在排名请求期间，我们向API发送当前用户的用户特征，以及所有可能的物品特征，API返回这些物品的排名和响应中的事件ID。
- en: Using this response, we can present the items to the user who will then interact
    with these items. Whenever the user creates implicit feedback (for example, they
    click on an item or scroll to the end of the item), we make a second call to the
    service, this time to the reward API. In this request, we only send the event
    ID and the reward (a numeric value) to the service. This will trigger another
    training iteration using the new reward and the previously submitted user and
    item features. Hence, with each iteration and each service call, we optimize the
    performance of the recommendation engine.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此响应，我们可以向用户展示物品，然后用户将与这些物品互动。每当用户创建隐式反馈（例如，点击物品或滚动到物品的末尾），我们就会向服务发出第二次调用，这次是奖励API。在这个请求中，我们只向服务发送事件ID和奖励（一个数值）。这将触发使用新奖励和之前提交的用户和物品特征的另一个训练迭代。因此，随着每次迭代和每次服务调用，我们优化推荐引擎的性能。
- en: 'Azure Personalizer SDKs are available for many different languages and are
    mainly wrappers around the official REST API. In order to install the Python SDK,
    run the following command in your shell:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Personalizer SDK适用于多种不同的语言，主要是官方REST API的包装器。为了安装Python SDK，请在您的shell中运行以下命令：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, go to the Azure portal and deploy an instance of Azure Personalizer from
    your portal and configure the **Rewards** and **Exploration** settings, as discussed
    in the following paragraphs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往Azure门户，从门户部署Azure Personalizer的一个实例，并配置**奖励**和**探索**设置，如以下段落所述。
- en: Important Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can find more information about Azure Personalizer configurations in the
    official documentation at [https://docs.microsoft.com/en-us/azure/cognitive-services/personalizer/how-to-settings](https://docs.microsoft.com/en-us/azure/cognitive-services/personalizer/how-to-settings).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到有关Azure Personalizer配置的更多信息，请参阅[https://docs.microsoft.com/en-us/azure/cognitive-services/personalizer/how-to-settings](https://docs.microsoft.com/en-us/azure/cognitive-services/personalizer/how-to-settings)。
- en: 'First, you need to configure how long the algorithm should wait to collect
    rewards for a certain event, as shown in *Figure 13.10*. Up to this time, rewards
    are collected and aggregated by the reward aggregation function. You can also
    define the model update frequency, which allows you to train your model frequently
    when requiring recommendations for quick-changing user behaviors. It makes sense
    to set the reward time and model update frequency to the same value – for example,
    10 minutes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要配置算法应该等待多长时间来收集特定事件的奖励，如图 *图 13.10* 所示。在此时间内，奖励由奖励聚合函数收集和汇总。您还可以定义模型更新频率，当需要快速变化的用户行为的推荐时，这允许您频繁地训练您的模型。将奖励时间和模型更新频率设置为相同的值是有意义的——例如，10分钟：
- en: '![Figure 13.10 – Rewards settings ](img/B17928_13_10.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10 – 奖励设置](img/B17928_13_10.jpg)'
- en: Figure 13.10 – Rewards settings
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 奖励设置
- en: In the preceding figure, we can also select the aggregation function for rewards
    collected on the same event during the reward wait time. The possible options
    are **Earliest** and **Sum** – hence, using only the first reward or a sum of
    all rewards in the reward period.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们还可以选择在奖励等待时间内收集的同一事件的奖励聚合函数。可能的选项是**最早**和**总和**——因此，只使用奖励周期内的第一个奖励或所有奖励的总和。
- en: 'The **Exploration** setting makes the algorithm explore alternative patterns
    over time, which is very helpful in discovering a diverse set of items through
    exploration. It can be set through the percentage of rank calls used for exploration,
    as shown in *Figure 13.11*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**探索**设置使算法随着时间的推移探索替代模式，这在通过探索发现一系列多样化的项目时非常有帮助。这可以通过探索所使用的排名调用百分比来设置，如图 *图
    13.11* 所示：'
- en: '![Figure 13.11 – Exploration settings ](img/B17928_13_11.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11 – 探索设置](img/B17928_13_11.jpg)'
- en: Figure 13.11 – Exploration settings
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 探索设置
- en: Hence, in 20% of the calls, the model won't return the highest ranked item but
    will randomly explore new items and their rewards. It sounds reasonable that the
    value for exploration should be greater than 0% to let the reinforcement algorithm
    try variations of items over time and set lower than 100% to avoid making the
    algorithm completely random.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在20%的调用中，模型不会返回最高排名的项目，而是会随机探索新的项目和它们的奖励。探索的值应该大于0%以让强化算法尝试随时间变化的物品变体，并设置低于100%以避免使算法完全随机。
- en: 'Let''s embed a recommendation engine in your application using Python:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在您的应用程序中使用Python嵌入一个推荐引擎：
- en: 'Let''s grab your resource key, open a Python environment, and start implementing
    the rank and reward calls. First, we define the API URLs for both calls:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取您的资源密钥，打开一个Python环境，并开始实现排名和奖励调用。首先，我们定义这两个调用的API URL：
- en: '[PRE13]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we create a unique `eventid` function and an object containing the user
    features of the current user and the item features of all possible actions. Once
    the request is constructed, we can send it to the rank API:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个独特的`eventid`函数和一个包含当前用户特征和所有可能操作的项目特征的对象。一旦请求构建完成，我们就可以将其发送到排名API：
- en: '[PRE14]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The response contains the ranking of the possible items/actions and a probability
    value, as well as the winning item under the `rewardActionId` property:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应包含可能的物品/操作的排名以及一个概率值，以及位于`rewardActionId`属性下的获胜项目：
- en: '[PRE15]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s parse `rewardActionId` from `response` – this contains the winning item
    and, hence, the recommended action for the user:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`response`中解析`rewardActionId`——这包含获胜的项目，因此是用户的推荐操作：
- en: '[PRE16]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using this ranking, we can return the winning item to the user based on `rewardActionId`.
    We now give the user some time to interact with the item. Finally, we use this
    ID to return the tracked implicit feedback as a reward value to the reward API:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个排名，我们可以根据`rewardActionId`将获胜的项目返回给用户。我们现在给用户一些时间来与项目互动。最后，我们使用这个ID将跟踪的隐式反馈作为奖励值返回给奖励API：
- en: '[PRE17]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's all you need to embed a fully online self-training recommendation engine
    in your application using Python and Azure Personalizer. It's that simple. As
    previously mentioned, other SDKs that wrap the API calls are available for many
    other languages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要使用Python和Azure Personalizer在您的应用程序中嵌入一个完全在线的自训练推荐引擎的全部内容。就这么简单。如前所述，还有许多其他语言的SDK可以包装API调用。
- en: Important Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A demo of Personalizer to test the reward function, as well as the request and
    response of the service, can be found at [https://personalizationdemo.azurewebsites.net/](https://personalizationdemo.azurewebsites.net/).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://personalizationdemo.azurewebsites.net/](https://personalizationdemo.azurewebsites.net/)找到Personalizer的演示，用于测试奖励函数以及服务的请求和响应。
- en: Detailed up-to-date examples for other languages are provided on GitHub at [https://github.com/Azure-Samples/cognitive-services-personalizer-samples](https://github.com/Azure-Samples/cognitive-services-personalizer-samples).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上提供了其他语言的详细最新示例，网址为[https://github.com/Azure-Samples/cognitive-services-personalizer-samples](https://github.com/Azure-Samples/cognitive-services-personalizer-samples)。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the need for different types of recommendation
    engines, from non-personalized ones to rating- and content-based ones, as well
    as hybrid models.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了不同类型推荐引擎的需求，从非个性化推荐引擎到基于评分和内容的推荐引擎，以及混合模型。
- en: We learned that content-based recommendation engines use feature vectors and
    cosine similarity to compute similar items and users based on content alone. This
    allows us to make recommendations via *k-means clustering* or *tree-based regression*
    models. One important consideration is the embedding of categorical data, which,
    if possible, should use semantic embedding to avoid confusing similarities based
    on one-hot or label encodings.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到基于内容的推荐引擎使用特征向量和余弦相似度来仅基于内容计算相似的项目和用户。这使我们能够通过*k-means聚类*或*基于树的回归*模型进行推荐。一个重要的考虑因素是分类数据的嵌入，如果可能的话，应使用语义嵌入来避免基于one-hot或标签编码的相似性混淆。
- en: Rating-based recommendations or collaborative filtering methods rely on user-item
    interactions, so-called ratings, or feedback. While explicit feedback is the most
    obvious possibility for collecting user ratings through ordinal or binary scales,
    we need to make sure that those ratings are properly normalized.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基于评分的推荐或协同过滤方法依赖于用户-项目交互，即所谓的评分或反馈。虽然显式反馈是通过序数或二进制尺度收集用户评分的最明显可能性，但我们需要确保这些评分得到适当的归一化。
- en: Another possibility is to directly observe the feedback through implicit ratings
    – for example, a user bought a product, clicked on an article, scrolled a page
    until the end, or watched a whole video until the end. However, these ratings
    will also be affected by user preference drift over time, as well as item popularity
    over time. To avoid this, you can use exponential time decay to decrease ratings
    over time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是直接通过隐式评分观察反馈——例如，用户购买了一个产品，点击了一篇文章，滚动到页面底部，或者观看了一个完整的视频直到结束。然而，这些评分也会受到用户偏好随时间漂移以及项目随时间流行度的影响。为了避免这种情况，可以使用指数时间衰减来随时间降低评分。
- en: Rating-based methods are great for providing diverse recommendations but require
    a lot of existing ratings for a good performance. Hence, they are often combined
    with content-based recommendations to fight this cold-start problem. Therefore,
    popular state-of-the-art recommendation models often combine both methods in a
    single hybrid model, of which the *Matchbox recommender* is one such example.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 基于评分的方法非常适合提供多样化的推荐，但需要大量的现有评分才能有良好的性能。因此，它们通常与基于内容的推荐相结合，以解决冷启动问题。因此，流行的最先进推荐模型通常在单个混合模型中结合这两种方法，其中*Matchbox推荐器*就是一个例子。
- en: Finally, you learned about the possibility of using reinforcement learning to
    optimize the recommender's feedback function on the fly. *Azure Personalizer*
    is a service that can be used to create hybrid online recommenders.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解了使用强化学习实时优化推荐器反馈函数的可能性。*Azure Personalizer*是一个可以用来创建混合在线推荐器的服务。
- en: In the next chapter, we will look into deploying our trained models as batch
    or real-time scoring systems directly from the Azure Machine Learning service.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将我们的训练模型作为批量或实时评分系统直接从Azure机器学习服务部署。
