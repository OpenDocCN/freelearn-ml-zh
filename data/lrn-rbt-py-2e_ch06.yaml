- en: Interfacing Actuators and Sensors to the Robot Controller
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将执行器和传感器连接到机器人控制器
- en: In the previous chapter, we discussed the selection of the hardware components
    needed to build our robot. The important components in a robot are actuators and
    sensors. Actuators provide mobility to the robot and sensors provide information
    about the robot environment. In this chapter, we will concentrate on the different
    types of actuators and sensors that we are going to use in this robot and how
    they can be interfaced with Tiva C LaunchPad, which is a 32 bit ARM micro controller
    board from Texas Instruments, working at 80 MHz. We will start by discussing actuators.
    The actuator that we are going to discuss first is a DC-geared motor with an encoder.
    A DC-geared motor works using direct current and has gear reduction to reduce
    the shaft speed and increase the torque of the final shaft. These kinds of motors
    are very economical and satisfy our robot design requirement. We will use this
    motor in our robot prototype.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了构建我们的机器人所需的硬件组件的选择。机器人中的重要组件是执行器和传感器。执行器为机器人提供移动性，传感器提供有关机器人环境的信息。在本章中，我们将专注于我们将要使用的不同类型的执行器和传感器，以及它们如何与德州仪器的32位ARM微控制器板Tiva
    C LaunchPad连接，该板以80 MHz运行。我们将首先讨论执行器。我们将首先讨论的执行器是带编码器的直流齿轮电机。直流齿轮电机使用直流电工作，并具有齿轮减速以降低轴速度并增加最终轴的扭矩。这类电机非常经济，满足我们的机器人设计要求。我们将在我们的机器人原型中使用这种电机。
- en: In the first section of this chapter, we will deal with the design of our robot
    drive system. The **drive system** of our robot is a differential drive and consists
    of two DC-geared motors with encoders and a motor driver. The motor driver is
    controlled by Tiva C LaunchPad. We will look at the interfacing of the motor driver
    and quadrature encoder with Tiva C Launchpad. After that, we will look at some
    of the latest actuators that can replace the existing DC-geared motor with an
    encoder. If the desired robot needs more payload and accuracy, we have to switch
    to these kinds of actuators. Finally, we will look at some different sensors that
    are commonly used for robots.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一节中，我们将处理我们机器人驱动系统的设计。我们的机器人**驱动系统**是差速驱动，由两个带编码器的直流齿轮电机和电机驱动器组成。电机驱动器由Tiva
    C LaunchPad控制。我们将查看电机驱动器和四倍频编码器与Tiva C Launchpad的接口。之后，我们将查看一些可以替换现有带编码器的直流齿轮电机的最新执行器。如果所需的机器人需要更多的负载和精度，我们必须切换到这类执行器。最后，我们将查看一些常用于机器人的不同传感器。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Interfacing a DC-geared motor with Tiva C LaunchPad
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将直流齿轮电机与Tiva C LaunchPad连接
- en: Interfacing a quadrature encoder with Tiva C LaunchPad
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将四倍频编码器与Tiva C LaunchPad连接
- en: An explanation of interfacing code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口代码的解释
- en: Interfacing Dynamixel actuators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接Dynamixel执行器
- en: Interfacing ultrasonic sensors and IR proximity sensors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口超声波传感器和红外接近传感器
- en: Interfacing inertial measurement units (IMUs)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口惯性测量单元（IMU）
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need the necessary robot hardware component and Energia IDE set up
    in Ubuntu 16.04 LTS.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要必要的机器人硬件组件和已在Ubuntu 16.04 LTS上设置的Energia IDE。
- en: Interfacing DC geared motor to Tiva C LaunchPad
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将直流齿轮电机连接到Tiva C LaunchPad
- en: 'In the previous chapter, we selected a DC-geared motor with an encoder from
    Pololu and an embedded board from Texas Instruments, called Tiva C LaunchPad.
    We need the following components to interface the motor with LaunchPad:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们选择了Pololu的带编码器的直流齿轮电机和德州仪器的嵌入式板，称为Tiva C LaunchPad。为了将电机与LaunchPad连接，我们需要以下组件：
- en: Two Pololu metal gear motors, 37Dx73L mm with 64 counts per revolution encoder
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个Pololu金属齿轮电机，37Dx73L毫米，每转64个脉冲编码器
- en: Pololu wheel, 90x10 mm and a matching hub
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pololu轮子，90x10毫米和匹配的轮毂
- en: Pololu dual VNH2SP30 motor driver carrier, MD03A
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pololu双VNH2SP30电机驱动器模块，MD03A
- en: A sealed lead acid/lithium ion battery of 12V
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12V的密封铅酸/锂离子电池
- en: A logic level convertor of 3.3V to 5V; visit [https://www.sparkfun.com/products/11978](https://www.sparkfun.com/products/11978).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个3.3V到5V的逻辑电平转换器；访问[https://www.sparkfun.com/products/11978](https://www.sparkfun.com/products/11978)。
- en: A Tiva C LaunchPad and its compatible interfacing wires
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tiva C LaunchPad及其兼容的接口线
- en: 'The following diagram shows the interfacing circuit of two motors using Pololu
    H-Bridge:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了使用Pololu H-Bridge的两个电机的接口电路：
- en: '![](img/5ce9e995-90df-474d-a082-35bceab88334.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ce9e995-90df-474d-a082-35bceab88334.png)'
- en: Motor interfacing circuit
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 电机接口电路
- en: 'To interface with Launchpad, we have to connect a level shifter board in between
    these two motors. The motor driver works in 5V but the Launchpad works in 3.3V,
    so we have to connect a level shifter, as shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Launchpad接口，我们必须在这两个电机之间连接一个电平转换器板。电机驱动器工作在5V，而Launchpad工作在3.3V，因此我们必须连接一个电平转换器，如下所示：
- en: '![](img/62074ed0-c097-4073-b041-9cb8cc46deb7.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62074ed0-c097-4073-b041-9cb8cc46deb7.png)'
- en: Level shifter circuit
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 电平转换器电路
- en: The two geared DC motors are connected to **OUT1A**, **OUT1B**, and **OUT2A**,
    **OUT2B** of the motor driver. **VIN (+)** and **GND (-)** are the supply voltage
    of the motor. These DC motors can work with a 12V supply, so we give 12V as the
    input voltage. The motor driver will support an input voltage ranging from 5.5V
    to 16V.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 两个齿轮式直流电机连接到电机驱动器的**OUT1A**、**OUT1B**和**OUT2A**、**OUT2B**。**VIN (+)**和**GND
    (-)**是电机的供电电压。这些直流电机可以使用12V的电源，因此我们提供12V作为输入电压。电机驱动器将支持5.5V至16V的输入电压范围。
- en: The control signals/input pins of the motor drivers are on the left side of
    the driver. The first pin is **1DIAG/EN**; in most cases, we leave this pin disconnected.
    These pins are externally pulled high in the driver board itself. The main use
    of this pin is to enable or disable the H-bridge chip. It is also used to monitor
    the faulty condition of the H-Bridge IC. Pins **1INA** and **1INB** control the
    direction of the rotation of the motor. The **1PWM** pin will switch the motor
    to the ON and OFF state. We achieve speed control using **PWM** pins. The **CS**
    pin will sense the output current. It will output 0.13V per Ampere of the output
    current. The **VIN** and **GND** pins give the same input voltage that we supplied
    for the motor. We are not using these pins here. The **+5V(IN)** and **GND** pins
    are the supply for the motor driver IC. The supply to the motor driver and motors
    are different.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 电机驱动器的控制信号/输入引脚位于驱动器的左侧。第一个引脚是**1DIAG/EN**；在大多数情况下，我们让这个引脚处于断开状态。这些引脚在驱动板本身中被外部拉高。这个引脚的主要用途是启用或禁用H桥芯片。它还用于监控H-Bridge
    IC的故障状态。引脚**1INA**和**1INB**控制电机的旋转方向。**1PWM**引脚将电机切换到开启和关闭状态。我们使用**PWM**引脚来实现速度控制。**CS**引脚将检测输出电流。它将输出每安培0.13V的输出电流。**VIN**和**GND**引脚提供与为电机提供的相同输入电压。我们在这里不使用这些引脚。**+5V(IN)**和**GND**引脚是电机驱动IC的电源。电机驱动器和电机的电源是不同的。
- en: 'The following table shows the truth table of the input and output combinations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了输入和输出组合的真值表：
- en: '| INA | INB | DIAGA/ENA | DIAGB/ENB | OUTA | OUTB | CS | Operating mode |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| INA | INB | DIAGA/ENA | DIAGB/ENB | OUTA | OUTB | CS | 操作模式 |'
- en: '| 1 | 1 | 1 | 1 | H | H | High Imp | Brake to Vcc |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | H | H | 高阻抗 | 制动到Vcc |'
- en: '| 1 | 0 | 1 | 1 | H | L | Isense = Iout / K | Clockwise (CW) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 | H | L | Isense = Iout / K | 顺时针（CW） |'
- en: '| 0 | 1 | 1 | 1 | L | H | Isense = Iout / K | Counterclockwise (CCW) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 | L | H | Isense = Iout / K | 逆时针（CCW） |'
- en: '| 0 | 0 | 1 | 1 | L | L | High Imp | Breaker to GND |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | L | L | 高阻抗 | 断路器到GND |'
- en: The value **DIAG/EN** pins are always high because these pins are externally
    pulled high in the driver board itself. Using the aforementioned signal combinations,
    we can move the robot in any direction and by adjusting the PWM signal, we can
    adjust the speed of the motor too. This is the basic logic behind controlling
    a DC motor using an H-Bridge circuit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**DIAG/EN**引脚的值始终为高，因为这些引脚在驱动板本身中被外部拉高。使用上述信号组合，我们可以使机器人向任何方向移动，并通过调整PWM信号，我们还可以调整电机的速度。这是使用H桥电路控制直流电机的基本逻辑。'
- en: While interfacing motors to Launchpad, we may require a level shifter. This
    is because the output pins of Launchpad can only supply 3.3V but the motor driver
    needs 5V to trigger; so, we have to connect 3.3V to the 5V logic level convertor
    to start working.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在将电机连接到Launchpad时，我们可能需要一个电平转换器。这是因为Launchpad的输出引脚只能提供3.3V，但电机驱动器需要5V来触发；因此，我们必须将3.3V连接到5V逻辑电平转换器以开始工作。
- en: The two motors work in a differential drive mechanism. The following section
    discusses the differential drive and its operation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 两个电机以差动驱动机制工作。以下部分将讨论差动驱动及其操作。
- en: Differential wheeled robot
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 差动轮式机器人
- en: 'The robot we have designed is a differential wheeled/drive robot. In a differential
    wheeled robot, the movement is based on two separately driven wheels placed on
    either side of the robot''s body. It can change its direction by changing the
    relative rate of rotation of its wheels, and hence, doesn''t require additional
    steering motion. To balance the robot, a free turning wheel or caster wheels may
    be added. The following diagram shows a typical representation of a differential
    drive:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的机器人是一个差速轮式/驱动机器人。在差速轮式机器人中，运动基于放置在机器人身体两侧的两个单独驱动的轮子。它可以通过改变轮子的相对转速来改变方向，因此不需要额外的转向运动。为了平衡机器人，可以添加一个自由旋转的轮子或万向轮。以下图显示了差速驱动的典型表示：
- en: '![](img/96923b01-7cc8-446a-914d-97042a6273cc.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96923b01-7cc8-446a-914d-97042a6273cc.png)'
- en: Differential wheeled robot
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 差速轮式机器人
- en: 'If the two motors are in the same direction, the robot will move forward or
    backward. If one motor has more speed than the other, then the robot turns to
    the slower motor side; so, to turn left, stop the left motor and move the right
    motor. The following diagram shows how we connect the two motors in our robot.
    The two motors are mounted on the opposite sides of the base plate and we put
    two casters in the front and back of the robot for balancing:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个电机方向相同，机器人将向前或向后移动。如果一个电机的速度比另一个电机快，那么机器人将转向较慢的电机一侧；因此，要向左转，停止左侧电机并移动右侧电机。以下图显示了我们在机器人中连接两个电机的方式。两个电机安装在底板相对两侧，我们在机器人的前后放置两个万向轮以平衡：
- en: '![](img/1cd00226-487c-45e0-8698-6154eb64ce0c.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cd00226-487c-45e0-8698-6154eb64ce0c.png)'
- en: Top view of robot base
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人底部的俯视图
- en: Next, we can program the motor controller using Launchpad according to the truth
    table data. Programming is done using an IDE called **Energia** ([http://energia.nu/](http://energia.nu/)).
    We are programming Launchpad using the C++ language, very similar to Arduino boards
    ([http://energia.nu/Reference_Index.html](http://energia.nu/Reference_Index.html)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以根据真值表数据使用 Launchpad 编程电机控制器。编程使用一个名为 **Energia** 的 IDE 完成 ([http://energia.nu/](http://energia.nu/))。我们使用
    C++ 语言编程 Launchpad，这与 Arduino 板非常相似 ([http://energia.nu/Reference_Index.html](http://energia.nu/Reference_Index.html))。
- en: Installing Energia IDE
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Energia IDE
- en: 'We can download the latest version of Energia from the following link:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接下载 Energia 的最新版本：
- en: '[http://energia.nu/download/](http://energia.nu/download/)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://energia.nu/download/](http://energia.nu/download/)'
- en: 'We will discuss the installation procedure mainly on Ubuntu 16.04 LTS, 64-bit.
    The Energia version that we will use is 0101E0018:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要在 Ubuntu 16.04 LTS，64位系统上讨论安装过程。我们将使用的 Energia 版本是 0101E0018：
- en: Download Energia for Linux 64-bit from the preceding link.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的链接下载 Linux 64位 Energia。
- en: Extract the Energia compressed file into the Home folder of the user.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Energia 压缩文件解压缩到用户的 Home 文件夹中。
- en: 'The instructions for setting the Tiva C Launchpad boards are given in the following
    link: [http://energia.nu/guide/guide_linux/](http://energia.nu/guide/guide_linux/)'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Tiva C Launchpad 板的说明在以下链接中给出：[http://energia.nu/guide/guide_linux/](http://energia.nu/guide/guide_linux/)
- en: 'You have to download the `71-ti-permissions.rules` file from the following
    link: [http://energia.nu/files/71-ti-permissions.rules](http://energia.nu/files/71-ti-permissions.rules)'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须从以下链接下载 `71-ti-permissions.rules` 文件：[http://energia.nu/files/71-ti-permissions.rules](http://energia.nu/files/71-ti-permissions.rules)
- en: 'The rules file will give permission to the user for reading and writing to
    the Launchpad board. You have to save the file as 71-ti-permissions.rules and
    execute the following command from the current path to copy the rules files into
    a system folder to get the permission:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规则文件将授予用户对 Launchpad 板的读写权限。您必须将文件保存为 71-ti-permissions.rules，并从当前路径执行以下命令以将规则文件复制到系统文件夹以获取权限：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After copying the file, execute the following command to activate the rules:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复制文件后，执行以下命令以激活规则：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can plug the Tiva C Launchpad to your PC now and execute the `dmesg` command
    in the Linux Terminal to see the Linux kernel log. If it is created, a serial
    port device will show at the end of the messages, as shown in the following screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以将 Tiva C Launchpad 连接到您的 PC，并在 Linux 终端中执行 `dmesg` 命令以查看 Linux 内核日志。如果已创建，则串行端口设备将显示在消息的末尾，如下面的截图所示：
- en: '![](img/543ba969-e43e-4869-ae48-3c8cc61aadb2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/543ba969-e43e-4869-ae48-3c8cc61aadb2.png)'
- en: Top view of robot base
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人底部的俯视图
- en: 'If you can see the serial port device, then start Energia using the following
    command inside the folder:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您可以看到串行端口设备，则可以在文件夹内使用以下命令启动 Energia：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the Energia IDE:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Energia IDE：
- en: '![](img/a9a39ae5-9f7b-48e3-82ad-b20bb3d685f9.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9a39ae5-9f7b-48e3-82ad-b20bb3d685f9.png)'
- en: Energia IDE
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Energia集成开发环境
- en: Now, we have to select the board tm4c123 in the IDE for compiling the code specific
    for this board. To do so, we have to install the packages of this board. You can
    select the option Tools | Boards | Boards Manager to install the packages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在IDE中选择tm4c123板来编译针对该板的特定代码。为此，我们必须安装该板的包。你可以选择工具 | 板 | 板管理器来安装包。
- en: '![](img/d4fd0270-51aa-4ab5-92c4-4a38a0f1a753.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4fd0270-51aa-4ab5-92c4-4a38a0f1a753.png)'
- en: Board Manager of Energia
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Energia板管理器
- en: 'After installing the packages, you can select the board by navigating to Tools
    | Boards | Launchpad (Tiva C) w/tm4c123 (80MHz), as shown in the following screenshot:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完包之后，你可以通过导航到工具 | 板 | Launchpad (Tiva C) w/tm4c123 (80MHz) 来选择板，如下面的截图所示：
- en: '![](img/87043600-18d4-40bb-8b8a-3f866ca0b4ae.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87043600-18d4-40bb-8b8a-3f866ca0b4ae.png)'
- en: Energia board selection
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Energia板选择
- en: 'Then, select the serial port by navigating to Tools | Serial Port | /dev/ttyACM0,
    as shown in the following screenshot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过导航到工具 | 串行端口 | /dev/ttyACM0 来选择串行端口，如下面的截图所示：
- en: '![](img/ac0c8dfc-a033-455b-9863-3c00eac17947.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac0c8dfc-a033-455b-9863-3c00eac17947.png)'
- en: Energia serial port selection
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Energia串行端口选择
- en: 'Compile and upload the code by using the Upload button. The Upload button will
    do both the processes. The following screenshot illustrates a successful upload:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用上传按钮来编译和上传代码。上传按钮将执行这两个过程。以下截图展示了成功上传的情况：
- en: '![](img/6d41d768-e211-4e1a-a33d-103dcb5d7216.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d41d768-e211-4e1a-a33d-103dcb5d7216.png)'
- en: Energia serial port selection
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Energia串行端口选择
- en: 'Visit the following links to install Energia on Linux, macOS X, and Windows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下链接以在Linux、macOS X和Windows上安装Energia：
- en: Refer to [http://energia.nu/guide/guide_linux/](http://energia.nu/guide/guide_linux/)
    for Linux
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[http://energia.nu/guide/guide_linux/](http://energia.nu/guide/guide_linux/)获取Linux的指南。
- en: Refer to [http://energia.nu/Guide_MacOSX.html](http://energia.nu/Guide_MacOSX.html)
    for macOS X
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[http://energia.nu/Guide_MacOSX.html](http://energia.nu/Guide_MacOSX.html)获取macOS
    X的指南。
- en: Refer to [http://energia.nu/Guide_Windows.html](http://energia.nu/Guide_Windows.html)
    for Windows
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[http://energia.nu/Guide_Windows.html](http://energia.nu/Guide_Windows.html)获取Windows的指南。
- en: Motor interfacing code
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电机接口代码
- en: The following code in Energia can be used to test the two motors in the differential
    drive configuration. This code can move the robot forward for 5 seconds and backward
    for 5 seconds. Then, it moves the robot to the left for 5 seconds and right for
    5 seconds. After each movement, the robot will stop for 1 second.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Energia代码可以用来测试差动驱动配置中的两个电机。此代码可以使机器人向前移动5秒，然后向后移动5秒。然后，机器人向左移动5秒，向右移动5秒。每次移动后，机器人将停止1秒。
- en: 'At the start of the code, we define pins for INA, INB, and PWM of the two motors,
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开始部分，我们定义了两个电机的INA、INB和PWM引脚，如下所示：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The pinout for Launchpad is given at: [http://energia.nu/pin-maps/guide_tm4c123launchpad/](http://energia.nu/pin-maps/guide_tm4c123launchpad/)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Launchpad的引脚布局信息可在以下链接找到：[http://energia.nu/pin-maps/guide_tm4c123launchpad/](http://energia.nu/pin-maps/guide_tm4c123launchpad/)
- en: 'The following code shows the five functions to move the robot forward, backward,
    left, and right. The fifth function is to stop the robot. We will use the `digitalWrite()`
    function to write a digital value to a pin. The first argument of `digitalWrite()`
    is the pin number and the second argument is the value to be written to the pin.
    The value can be `HIGH` or `LOW`. We will use the `analogWrite()` function to
    write a PWM value to a pin. The first argument of this function is the pin number
    and the second is the PWM value. The range of this value is from 0-255\. At high
    PWM, the motor driver will switch fast and have more speed. At low PWM, switching
    inside the motor driver will be slow, so the motor will also be slow. Currently,
    we are running at full speed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了移动机器人向前、向后、向左和向右的五个函数。第五个函数是停止机器人。我们将使用`digitalWrite()`函数将数字值写入引脚。`digitalWrite()`的第一个参数是引脚号，第二个参数是要写入引脚的值。该值可以是`HIGH`或`LOW`。我们将使用`analogWrite()`函数将PWM值写入引脚。该函数的第一个参数是引脚号，第二个是PWM值。此值的范围是0-255。在高PWM下，电机驱动器将快速切换，速度更快。在低PWM下，电机驱动器内部的切换将较慢，因此电机也会较慢。目前，我们正在全速运行：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We first set the `INA` and `INB` pins of the two motors to the `OUTPUT` mode,
    so that we can write `HIGH` or `LOW` values to these pins. The `pinMode()` function
    is used to set the mode of the I/O pin. The first argument of `pinMode()` is the
    pin number and the second argument is the mode. We can set a pin as input or output.
    To set a pin as output, give the `OUTPUT` argument as the second argument; to
    set it as input, give `INPUT` as the second argument, as shown in following code.
    There is no need to set the PWM pin as the output because `analogWrite()` writes
    the PWM signal without setting `pinMode()`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将两个电机的`INA`和`INB`引脚设置为`OUTPUT`模式，这样我们就可以向这些引脚写入`HIGH`或`LOW`值。`pinMode()`函数用于设置I/O引脚的模式。`pinMode()`的第一个参数是引脚号，第二个参数是模式。我们可以将引脚设置为输入或输出。要将引脚设置为输出，将`OUTPUT`作为第二个参数；要将其设置为输入，将`INPUT`作为第二个参数，如下面的代码所示。不需要将PWM引脚设置为输出，因为`analogWrite()`在写入PWM信号时不需要设置`pinMode()`：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following snippet is the main loop of the code. It will call each function,
    such as `move forward()`, `move_backward()`, `move_left()`, and `move_right(),`for
    `5` seconds. After calling each function, the robot stops for `1` second:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是代码的主循环。它将在`5`秒内调用每个函数，例如`前进()`、`后退()`、`向左移动()`和`向右移动()`。调用每个函数后，机器人将停止`1`秒：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Interfacing quadrature encoder with Tiva C Launchpad
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将正交编码器与Tiva C Launchpad连接
- en: The wheel encoder is a sensor attached to the motor to sense the number of rotations
    of the wheel. If we know the number of rotations, we can compute the velocity
    and displacement of the wheel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 轮编码器是附着在电机上以感应轮子旋转次数的传感器。如果我们知道旋转次数，我们可以计算出轮子的速度和位移。
- en: 'For this robot, we have chosen a motor with an in-built encoder. This encoder
    is a quadrature type, which can sense both the direction and speed of the motor.
    Encoders use different types of sensors, such as optical and hall sensors, to
    detect these parameters. This encoder uses the hall effect to sense the rotation.
    The quadrature encoder has two channels, namely **Channel A** and **Channel B**.
    Each channel will generate digital signals with a 90-degree phase shift. The following
    diagram shows the wave form of a typical quadrature encoder:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个机器人，我们选择了一个内置编码器的电机。这个编码器是正交类型，可以感应电机的方向和速度。编码器使用不同类型的传感器，如光传感器和霍尔传感器，来检测这些参数。这个编码器使用霍尔效应来感应旋转。正交编码器有两个通道，即**通道A**和**通道B**。每个通道将生成带有90度相位差的数字信号。以下图显示了典型正交编码器的波形：
- en: '![](img/7969c070-2911-431d-a5dc-916a8fbd6335.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7969c070-2911-431d-a5dc-916a8fbd6335.png)'
- en: Quadrature encoder waveforms
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正交编码器波形
- en: If the motor rotates in a clockwise direction, **Channel A** will lead **Channel
    B,** and if the motor rotates counterclockwise, **Channel B** will lead **Channel
    A**. This reading will be useful to sense the direction of rotation of the motor.
    The following section discusses how we can translate the encoder output to useful
    measurements, such as displacement and velocity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电机按顺时针方向旋转，**通道A**将领先**通道B**，如果电机按逆时针方向旋转，**通道B**将领先**通道A**。这个读数将有助于感应电机的旋转方向。以下部分讨论了如何将编码器输出转换为有用的测量，例如位移和速度。
- en: Processing encoder data
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理编码器数据
- en: Encoder data is a two-channel pulse out with 90 degrees out of phase. Using
    this data, we can find the direction of rotation and how many times the motor
    has rotated, and thereby find the displacement and velocity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器数据是两个通道的脉冲输出，相位差为90度。使用这些数据，我们可以找到旋转方向和电机旋转了多少次，从而找到位移和速度。
- en: Some of the terms that specify encoder resolution are **pulses per revolution**
    (**PPR**) or **lines per revolution** (**LPR**) and **counts per revolution**
    (**CPR**). PPR specifies how many electrical pulses (0 to 1 transitions) there
    will be during one revolution of the motor final shaft. Some manufactures use
    the name CPR instead of PPR, because each pulse will contain two edges (rising
    and falling) and there are two pulse channels (A and B) with 90-degree phase shift;
    the total number of edges will be four times the number of PPR. Most quadrature
    receivers use the so-called 4X decoding to count all the edges from encoder A
    and B channels yielding 4X resolution compared to the raw PPR value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 指定编码器分辨率的某些术语是**每转脉冲数**（**PPR**）或**每转线数**（**LPR**）和**每转计数**（**CPR**）。PPR指定在电机最终轴的一转中会有多少个电脉冲（0到1的转换）。一些制造商使用CPR而不是PPR的名称，因为每个脉冲将包含两个边沿（上升和下降）并且有两个脉冲通道（A和B）具有90度的相位差；总边沿数将是PPR数量的四倍。大多数四倍频接收器使用所谓的4X解码来计算来自编码器A和B通道的所有边沿，从而提供比原始PPR值高4倍的分辨率。
- en: 'In our motor, Pololu specifies that the CPR is 64 for the motor shaft, which
    corresponds to 8,400 CPR of the gearbox''s output shaft. In effect, we get 8,400
    counts from the gearbox output shaft when the motor''s final shaft completes one
    revolution. The following diagram shows how we can compute the count from the
    encoder pulses:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电机中，Pololu指定电机轴的CPR为64，这对应于变速箱输出轴的8,400 CPR。实际上，当电机的最终轴完成一次旋转时，我们从变速箱输出轴获得8,400个计数。以下图表显示了我们可以如何从编码器脉冲计算计数：
- en: '![](img/d6324108-5123-4d55-b66a-56716c982163.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6324108-5123-4d55-b66a-56716c982163.png)'
- en: Encoder pulses with count value
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 带计数值的编码器脉冲
- en: 'In this encoder specification, the count per revolution is given; it is calculated
    by the encoder channel edge transitions. One pulse of an encoder channel corresponds
    to four counts. So, to get 8,400 counts in our motor, the PPR will be *8,400 /
    4 = 2,100*. From the preceding diagram, we will be able to calculate the number
    of counts in one revolution, but we also need to sense the direction of movement.
    This is because irrespective of whether the robot moves forward or backward, the
    counts that we get will be same; so, sensing the direction is important in order
    to decode the signal. The following diagram shows how we can decode the encoder
    pulses:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个编码器规范中，给出了每转的计数；它是通过编码器通道边沿转换计算得出的。编码器通道的一个脉冲对应于四个计数。因此，为了在我们的电机中获得8,400个计数，PPR将是*8,400
    / 4 = 2,100*。从前面的图表中，我们将能够计算出每转的计数数，但我们还需要检测运动方向。这是因为无论机器人是向前还是向后移动，我们得到的计数都将相同；因此，检测方向对于解码信号非常重要。以下图表显示了我们可以如何解码编码器脉冲：
- en: '![](img/bf1151a7-310f-42dc-80c0-bd5357fd5e0d.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf1151a7-310f-42dc-80c0-bd5357fd5e0d.png)'
- en: Detecting motor direction from encoder pulses
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从编码器脉冲检测电机方向
- en: If we observe the code pattern, we can understand that it follows the 2-bit
    Gray code. A Gray code is the encoding of numbers, so that adjacent numbers have
    a single digit differing by 1\. Gray code ([http://en.wikipedia.org/wiki/Gray_code](http://en.wikipedia.org/wiki/Gray_code))
    is commonly used in rotary encoders for efficient coding.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察代码模式，我们可以理解它遵循2位格雷码。格雷码是数字的编码，使得相邻的数字只有一个数字不同，差值为1。格雷码([http://en.wikipedia.org/wiki/Gray_code](http://en.wikipedia.org/wiki/Gray_code))在旋转编码器中常用于高效的编码。
- en: 'We can predict the direction of rotation of a motor by state transitions. The
    state transition table is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过状态转换预测电机的旋转方向。状态转换表如下：
- en: '| State | Clockwise transition | Counterclockwise transition |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 顺时针转换 | 逆时针转换 |'
- en: '| 0,0 | 0,1 to 0,0 | 1,0 to 0,0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 0,0 | 0,1 到 0,0 | 1,0 到 0,0 |'
- en: '| 1,0 | 0,0 to 1,0 | 1,1 to 1,0 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 1,0 | 0,0 到 1,0 | 1,1 到 1,0 |'
- en: '| 1,1 | 1,0 to 1,1 | 0,1 to 1,1 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 1,1 | 1,0 到 1,1 | 0,1 到 1,1 |'
- en: '| 0,1 | 1,1 to 0,1 | 0,0 to 0,1 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 0,1 | 1,1 到 0,1 | 0,0 到 0,1 |'
- en: 'It will be more convenient if we represent it in a state transition diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用状态转换图来表示它，将会更方便：
- en: '![](img/ced2e452-275e-43f7-b313-231d8549f634.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ced2e452-275e-43f7-b313-231d8549f634.png)'
- en: State transition diagram of encoders
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器的状态转换图
- en: After getting this Gray code, we can process the pulses using a microcontroller.
    The channel pins of the motor have to be connected to the interrupt pins of the
    microcontroller. So, when the channel has edge transitions, it will generate an
    interrupt or trigger in the pins, and if any interrupts arrives in that pin, an
    interrupt service routine, or simply a function, will be executed inside the microcontroller
    program. It can read the current state of the two pins. According to the current
    state of the pins and previous values, we can determine the direction of rotation
    and can decide whether we have to increment or decrement the count. This is the
    basic logic for encoder handling.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取这个格雷码后，我们可以使用微控制器处理脉冲。电机通道引脚必须连接到微控制器的中断引脚。因此，当通道有边缘转换时，它将在引脚上生成中断或触发，如果该引脚上有任何中断到达，微控制器程序中将执行一个中断服务例程，或者简单地是一个函数。它可以读取两个引脚的当前状态。根据引脚的当前状态和先前值，我们可以确定旋转方向，并决定是否需要增加或减少计数。这是编码器处理的基本逻辑。
- en: After getting the count, we can calculate the angle of rotation (in degrees)
    using *Angle = (Count Value / CPR) * 360*. Here, if we substitute CPR with 8,400,
    the equation becomes *Angle = 0.04285 * Count Value*; that is, for turning one
    degree, 24 counts have to be received or six encoded channel pulses have to come.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取计数后，我们可以使用*Angle = (Count Value / CPR) * 360*来计算旋转角度（以度为单位）。在这里，如果我们用8,400代替CPR，方程变为*Angle
    = 0.04285 * Count Value*；也就是说，为了转动一度，需要接收24个计数或六个编码通道脉冲。
- en: 'The following diagram shows the interfacing circuit of one motor encoder with
    Tiva C LaunchPad:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了单个电机编码器与Tiva C LaunchPad的接口电路：
- en: '![](img/617798bd-cbd8-45c5-8d3f-a24f53b9e415.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/617798bd-cbd8-45c5-8d3f-a24f53b9e415.png)'
- en: Interfacing encoder to Launchpad
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将编码器连接到Launchpad
- en: From the above diagram, you can find motor pins CH A and CH B which are the
    output from the motor encoders. These pins are interfaced to PB2 and PB7 pins
    of the Tiva C Launchpad. The pins ENC VCC and ENC GND are the power pins of the
    encoder,  so we have to provide +5V and GND to these pins.  The next set of pins
    are for powering the motors. The MOTOR VCC  and MOTOR GND are marked as OUTA and
    OUTB which is directly going to Motor driver in order to control the motor speed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图中，你可以找到电机引脚CH A和CH B，它们是电机编码器的输出。这些引脚连接到Tiva C Launchpad的PB2和PB7引脚。引脚ENC
    VCC和ENC GND是编码器的电源引脚，因此我们必须为这些引脚提供+5V和GND。下一组引脚用于为电机供电。MOTOR VCC和MOTOR GND标记为OUTA和OUTB，它们直接连接到电机驱动器，以控制电机速度。
- en: The maximum voltage level of output pulse is in between 0V to 5V from the encoder.
    In this case, we can directly interface the encoder with Launchpad because it
    can receive input up to 5V, or we can use a 3.3V to 5V level shifter like we used
    for motor driver interfacing earlier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器输出脉冲的最大电压等级在0V到5V之间。在这种情况下，我们可以直接将编码器与Launchpad接口，因为它可以接收高达5V的输入，或者我们可以使用一个3.3V到5V的电平转换器，就像我们之前用于电机驱动器接口时使用的那样。
- en: In the next section, we will upload code in Energia to test the quadrature encoder
    signal. We need to check whether we get a proper count from the encoder.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将上传代码到Energia以测试四倍频编码器信号。我们需要检查是否从编码器获得了正确的计数。
- en: Quadrature encoder interfacing code
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四倍频编码器接口代码
- en: 'This code will print the count of the left and right motor encoder via a serial
    port. The two encoders are in a 2X decoding scheme, so we will get 4,200 CPR.
    In the first section of the code, we are defining pins for two channel outputs
    of two encoders and we are declaring the count variable for two encoders. The
    encoder variable uses a volatile keyword before the variable data type. The main
    use of `volatile` is that the variable with the `volatile` keyword will store
    in RAM memory, whereas normal variables are in CPU registers. Encoder values will
    change very quickly, so using an ordinary variable will not be accurate. In order
    to get accuracy, we will use `volatile` for encoder variables, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将通过串行端口打印左右电机编码器的计数。这两个编码器采用2X解码方案，因此我们将获得4,200 CPR。在代码的第一部分，我们定义了两个编码器的两个通道输出引脚，并声明了两个编码器的计数变量。编码器变量在数据类型之前使用了一个`volatile`关键字。`volatile`的主要用途是带有`volatile`关键字的变量将存储在RAM内存中，而普通变量存储在CPU寄存器中。编码器值会非常快地变化，因此使用普通变量将不会准确。为了获得准确性，我们将使用`volatile`来声明编码器变量，如下所示：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code snippet is the definition of the `setup()` function. In
    Energia, `setup()` is a built-in function used for initialization and for one-time
    execution of variables and functions. Inside `setup()`, we initialize the serial
    data communication with a baud rate of `115200` and call a user-defined `SetupEncoders()`
    function to initialize pins of the encoders. The serial data communication is
    mainly done to check the encoder count via the serial terminal:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是`setup()`函数的定义。在Energia中，`setup()`是一个用于初始化和执行变量和函数的一次性执行的内置函数。在`setup()`内部，我们使用波特率为`115200`初始化串行数据通信，并调用用户定义的`SetupEncoders()`函数来初始化编码器引脚。串行数据通信主要用于通过串行终端检查编码器计数：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The definition of `SetupEncoders()` is given in the code that follows. To receive
    the encoder pulse, we need two pins in Launchpad as the input. Configure the encoder
    pins to Launchpad as the input and activate its pull-up resistor. The `attachInterrupt
    ()` function will configure one of the encoder pins as an interrupt. The `attachInterrupt
    ()` function has three arguments. The first argument is the pin number, the second
    argument is the **interrupt service routine** (**ISR**), and the third argument
    is the interrupt condition, that is, the condition in which the interrupt has
    to fire ISR. In this code, we are configuring `PinA` of the left and right encoder
    pins as the interrupt; it calls the ISR when there is a rise in the pulse:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupEncoders()`的定义在下面的代码中给出。为了接收编码器脉冲，我们需要在Launchpad上使用两个引脚作为输入。将编码器引脚配置为Launchpad的输入并激活其上拉电阻。`attachInterrupt()`函数将配置编码器引脚之一为中断。`attachInterrupt()`函数有三个参数。第一个参数是引脚号，第二个参数是**中断服务例程**（**ISR**），第三个参数是中断条件，即中断必须触发ISR的条件。在这段代码中，我们正在配置左右编码器引脚的`PinA`作为中断；当脉冲上升时，它将调用ISR：'
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following code is the built-in `loop()` function in Energia. The `loop()`
    function is an infinite loop where we put our main code. In this code, we call
    the `Update_Encoders()` function to print the encoder value continuously through
    the serial Terminal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是Energia中的内置`loop()`函数。`loop()`函数是一个无限循环，我们将主要代码放在其中。在这段代码中，我们调用`Update_Encoders()`函数通过串行终端连续打印编码器值：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code is the function definition of the `Update_Encoders()` function.
    It prints two encoder values in a line with a starting character `e` and the values
    are separated by tab spaces. The `Serial.print()` function is a built-in function
    that will print the character/string given as the argument:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`Update_Encoders()`函数的定义。它在一行中打印两个编码器值，以字符`e`开头，值之间用制表符分隔。`Serial.print()`函数是一个内置函数，它将打印作为参数给出的字符/字符串：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code is the ISR definition of the left and right encoders. When
    a rising edge is detected on each of the pins, one of the ISRs will be called.
    The current interrupt pins are `PinA` of each of the encoders. After getting the
    interrupt, we can assume that the rising `PinA` has a higher value state, so there
    is no need to read that pin. Read `PinB` of both the encoders and store the pin
    state to `LeftEncoderBSet` or `RightEncoderBSet`. The current state is compared
    to the previous state of `PinB` and can detect the direction and decide whether
    the count has to be incremented or decremented according to the state transition
    table:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是左右编码器的ISR定义。当检测到每个引脚上的上升沿时，将调用其中一个ISR。当前的中断引脚是每个编码器的`PinA`。在获取中断后，我们可以假设上升的`PinA`处于较高值状态，因此不需要读取该引脚。读取两个编码器的`PinB`并将引脚状态存储到`LeftEncoderBSet`或`RightEncoderBSet`中。将当前状态与`PinB`的先前状态进行比较，可以检测方向并根据状态转换表决定计数是否需要增加或减少：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Upload the sketch and view the output using the serial monitor in Energia.
    Navigate to Tools | Serial monitor. Move the two motors manually and you will
    see the count changing. Set the baud rate in the serial monitor, which is the
    same as that initialized in the code; in this case, it is **115200**. The output
    will look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Energia中上传草图并使用串行监视器查看输出。转到工具 | 串行监视器。手动移动两个电机，你会看到计数在变化。在串行监视器中设置波特率，它与代码中初始化的波特率相同；在这种情况下，为**115200**。输出将如下所示：
- en: '![](img/2718f894-08de-4d89-b453-c6e701eeab4f.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2718f894-08de-4d89-b453-c6e701eeab4f.png)'
- en: Interfacing encoder to Launchpad
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将编码器连接到Launchpad
- en: If we want to upgrade the robot to high accuracy and payload, we have to consider
    high quality actuators, such as Dynamixel. Dynamixel servos are intelligent actuators,
    which have in-built PID control and monitoring of the servo and encoder parameters,
    such as torque, position, and so on. In this robot, we are not using Dynamixel.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将机器人升级为高精度和高负载，我们必须考虑高质量的执行器，如Dynamixel。Dynamixel伺服电机是智能执行器，具有内置的PID控制和监控伺服电机和编码器参数，如扭矩、位置等。在这个机器人中，我们没有使用Dynamixel。
- en: Working with Dynamixel actuators
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Dynamixel执行器一起工作
- en: '**Dynamixel** is a kind of networked actuator for robots developed by the Korean
    manufacture, ROBOTIS. It is widely used by companies, universities, and hobbyists
    due to its versatile expansion capability, power feedback function, position,
    speed, internal temperature, input voltage, and so on.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dynamixel**是韩国制造商ROBOTIS开发的一种用于机器人的网络化执行器。由于其多功能扩展能力、功率反馈功能、位置、速度、内部温度、输入电压等，它被公司、大学和爱好者广泛使用。'
- en: The Dynamixel servos can be connected in a daisy chain; it is a method of connecting
    devices in a serial fashion, connecting one device to another through the connected
    devices, and can control all the connected servos from one controller. Dynamixel
    servos communicate via RS485 or TTL. The list of available Dynamixel servos is
    given at [http://www.robotis.com/xe/dynamixel_en](http://www.robotis.com/xe/dynamixel_en).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Dynamixel伺服电机可以串联连接；这是一种以串行方式连接设备的方法，通过连接的设备将一个设备连接到另一个设备，并可以从一个控制器控制所有连接的伺服电机。Dynamixel伺服电机通过RS485或TTL通信。可用的Dynamixel伺服电机列表可在[http://www.robotis.com/xe/dynamixel_en](http://www.robotis.com/xe/dynamixel_en)找到。
- en: 'The interfacing of Dynamixel is very easy. Dynamixel comes with a controller
    called USB2Dyanmixel, which will convert a USB to Dynamixel compatible TTL/RS485
    levels. The following diagram shows the interfacing diagram of Dynamixel:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Dynamixel的接口非常简单。Dynamixel附带一个名为USB2Dyanmixel的控制器，它将USB转换为与Dynamixel兼容的TTL/RS485电平。以下图显示了Dynamixel的接口图：
- en: '![](img/49479e5f-e31f-43b8-8a35-ce370c301094.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49479e5f-e31f-43b8-8a35-ce370c301094.png)'
- en: Interfacing Dynamixel actuators to a PC
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将Dynamixel执行器连接到PC
- en: ROBOTIS provides Dynamixel SDK for accessing motor registers; we can read and
    write values to Dynamixel registers and retrieve data, such as position, temperature,
    voltage, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ROBOTIS提供了Dynamixel SDK以访问电机寄存器；我们可以读取和写入Dynamixel寄存器的值并检索数据，例如位置、温度、电压等。
- en: The instructions to set USB2Dynamixel and Dynamixel SDK are given at [support.robotis.com/en/](http://support.robotis.com/en/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 设置USB2Dynamixel和Dynamixel SDK的说明可在[support.robotis.com/en/](http://support.robotis.com/en/)找到。
- en: Dynamixel can be programed using Python libraries. One of the Python libraries
    for handling Dynamixel servos is **pydynamixel**. This package is available for
    Windows and Linux. Pydynamixel will support RX, MX, and EX series servos.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Dynamixel可以使用Python库进行编程。用于处理Dynamixel伺服电机的Python库之一是**pydynamixel**。此包适用于Windows和Linux。Pydynamixel将支持RX、MX和EX系列伺服电机。
- en: We can download the the pydynamixel Python package from [https://pypi.python.org/pypi/dynamixel/](https://pypi.python.org/pypi/dynamixel/).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从[https://pypi.python.org/pypi/dynamixel/](https://pypi.python.org/pypi/dynamixel/)下载pydynamixel
    Python包。
- en: 'Download the package and extract it to the `home` folder. Open a terminal/DOS
    prompt and execute the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下载包并将其解压到`home`文件夹。打开终端/DOS提示符并执行以下命令：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After installing the package, we can try the following Python example, which
    will detect the servo attached to the USB2Dynamixel and write some random position
    to the servo. This example will work with RX and MX servos:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包后，我们可以尝试以下Python示例，该示例将检测连接到USB2Dynamixel的伺服电机，并将一些随机位置写入伺服电机。此示例适用于RX和MX伺服电机：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following code will import the necessary Python modules required for this
    example. This includes Dynamixel Python modules too:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将导入此示例所需的必要Python模块。这包括Dynamixel Python模块：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code defines the main parameters needed for Dynamixel communication
    parameters. The `nServos` variable denotes the number of Dynamixel servos connected
    to the bus. The `portName` variable indicates the serial port of USB2Dynamixel
    to which Dynamixel servos are connected. The `baudRate` variable is the communication
    speed of USB2Dynamixel and Dynamixel:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了Dynamixel通信参数所需的主要参数。`nServos`变量表示连接到总线的Dynamixel伺服电机的数量。`portName`变量指示连接到USB2Dynamixel的串行端口。`baudRate`变量是USB2Dynamixel和Dynamixel的通信速度：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following code is the Dynamixel Python function to connect to Dynamixel
    servos. If it is connected, the program will print it and scan the communication
    bus to find the number of servos starting from ID `1` to `255`. The servo ID is
    the identification of each servo. We are given `nServos` as `1`, so it will stop
    scanning after getting one servo on the bus:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是Dynamixel Python函数，用于连接到Dynamixel伺服电机。如果连接成功，程序将打印它并扫描通信总线，从ID `1`到`255`查找伺服电机的数量。伺服ID是每个伺服电机的标识。我们给定的`nServos`为`1`，因此在一台伺服电机连接到总线后，扫描将停止：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code will append the Dynamixel ID and the servo object to the
    `myActutors` list. We can write servo values to each servo using the servo ID
    and servo object. We can use the `myActutors` list for further processing:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将Dynamixel ID和伺服对象追加到`myActutors`列表中。我们可以使用伺服ID和伺服对象将伺服值写入每个伺服电机。我们可以使用`myActutors`列表进行进一步处理：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code will write random positions from 450 to 600 to each Dynamixel
    actuator that is available on the bus. The range of positions in Dynamixel is
    0 to 1,023\. This will set the servo parameters, such as `speed`, `torque,torque_limt`,
    `max_torque`, and so on:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将随机将450到600之间的位置写入总线上的每个Dynamixel执行器。Dynamixel的位置范围是0到1,023。这将设置伺服参数，如`速度`、`扭矩`、`扭矩限制`、`最大扭矩`等：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code will print the current position of the current actuator:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印当前执行器的当前位置：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following code will read all data from the actuators:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将读取执行器的所有数据：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Working with ultrasonic distance sensors
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超声波距离传感器
- en: One of the important capabilities of a mobile robot is navigation. An ideal
    navigation means a robot can plan its path from its current position to the destination
    and can move without any obstacles. We use ultrasonic distance sensors in this
    robot for detecting near objects that can't be detected using the Kinect sensor.
    A combination of Kinect and ultrasonic sound sensors provides ideal collision
    avoidance on this robot.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 移动机器人的一项重要能力是导航。理想的导航意味着机器人可以从当前位置规划路径到目的地，并且可以无障碍物地移动。在这个机器人中，我们使用超声波距离传感器来检测使用Kinect传感器无法检测到的近处物体。Kinect和超声波声传感器的组合为这个机器人提供了理想的碰撞避免功能。
- en: 'Ultrasonic distance sensors work in the following manner. The transmitter will
    send an ultrasonic sound that is not audible to human ears. After sending an ultrasonic
    wave, it will wait for an echo of the transmitted wave. If there is no echo, it
    means there are no obstacles in front of the robot. If the receiving sensor receives
    any echo, a pulse will be generated on the receiver, and it can calculate the
    total time the wave will take to travel to the object and return to the receiver
    sensors. If we get this time, we can compute the distance to the obstacle using
    the following formula:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波距离传感器以以下方式工作。发射器将发送一种人类耳朵无法听到的超声波。在发送超声波后，它将等待发射波的回声。如果没有回声，这意味着机器人的前方没有障碍物。如果接收传感器接收到任何回声，接收器上会产生一个脉冲，它可以计算出波到达物体并返回接收传感器的总时间。如果我们得到这个时间，我们可以使用以下公式计算出障碍物的距离：
- en: '*Speed of Sound * Time Passed /2 = Distance from Object*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*声音速度 * 时间经过 / 2 = 物体距离*。'
- en: Here, the speed of sound can be taken as 340 m/s.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，声音速度可以取为340 m/s。
- en: Most of the ultrasonic range sensors have a distance range from 2 cm to 400
    cm. In this robot, we use a sensor module called HC-SR04\. We look at how to interface
    HC-SR04 with Tiva C LaunchPad to get the distance from the obstacles.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数超声波距离传感器的距离范围从2厘米到400厘米。在这个机器人中，我们使用一个名为HC-SR04的传感器模块。我们来看看如何将HC-SR04与Tiva
    C LaunchPad接口，以获取障碍物的距离。
- en: Interfacing HC-SR04 to Tiva C LaunchPad
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HC-SR04接口到Tiva C LaunchPad
- en: 'The following diagram illustrates the interfacing circuit of the HC-SR04 ultrasonic
    sound sensor with Tiva C LaunchPad:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了HC-SR04超声波声传感器与Tiva C LaunchPad的接口电路：
- en: '![](img/0ef11ee4-03be-46e4-bcd2-6b6e13c39834.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ef11ee4-03be-46e4-bcd2-6b6e13c39834.png)'
- en: Interfacing ultrasonic sound sensors to Launchpad
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将超声波声传感器接口到Launchpad
- en: The working voltage of the ultrasonic sensor is 5V and the input/output of this
    sensor is also 5V, so we need a level shifter on the **Trig** and **Echo** pins
    for interfacing into the **3.3V** level Launchpad. In the level shifter, we need
    to apply high voltage, that is, 5V, and low voltage, that is, 3.3V, as shown in
    the preceding diagram, to switch from one level to another level. **Trig** and
    **Echo** pins are connected on the high voltage side of the level shifter and
    the low voltage side pins are connected to Launchpad. The **Trig** pin and **Echo**
    are connected to the 10th and 9th pins of Launchpad. After interfacing the sensor,
    we can see how to program the two I/O pins.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波传感器的工作电压为5V，该传感器的输入/输出也是5V，因此我们需要在**Trig**和**Echo**引脚上使用电平转换器以与**3.3V**级别的Launchpad接口。在电平转换器中，我们需要应用高电压，即5V，和低电压，即3.3V，如图所示，以在两个电平之间切换。**Trig**和**Echo**引脚连接在电平转换器的高电压侧，而低电压侧的引脚连接到Launchpad。**Trig**引脚和**Echo**连接到Launchpad的第10和第9引脚。接口传感器后，我们可以看到如何编程这两个I/O引脚。
- en: Working of HC-SR04
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HC-SR04的工作原理
- en: 'The timing of the waveform on each pin is shown in the following diagram. We
    need to apply a short 10 µs pulse to the trigger input to start the ranging and
    then the module will send out an eight-cycle burst of ultrasound at 40 KHz and
    raise its echo. The echo is a distance object that is the pulse width and the
    range in proportion. You can calculate the range through the time interval between
    sending trigger signals and receiving echo signals using the following formula:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每个引脚上波形的时间如图所示。我们需要向触发输入应用一个短暂的10 µs脉冲以开始测距，然后模块将发送一个40 KHz的八周期超声波脉冲并提升其回声。回声是一个距离对象，其脉冲宽度和范围成比例。你可以通过以下公式计算范围，即使用发送触发信号和接收回声信号之间的时间间隔：
- en: '*Range = high level time of echo pin output * velocity (340 M/S) / 2*.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*距离 = 回声引脚输出高电平时间 * 速度（340 M/S）/ 2*。'
- en: 'It will be better to use a delay of 60 ms before each trigger to avoid overlapping
    between trigger and echo:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个触发之前使用60毫秒的延迟将更好地避免触发和回声之间的重叠：
- en: '![](img/c24f5ba9-eef8-422d-a8ef-e32675e839cc.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c24f5ba9-eef8-422d-a8ef-e32675e839cc.png)'
- en: Input and output waveform of ultrasound sensor
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波传感器的输入和输出波形
- en: Interfacing Code of Tiva C Launchpad
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tiva C Launchpad的接口代码
- en: The following Energia code for Launchpad reads values from the ultrasound sensor
    and monitors the values through a serial port.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为Launchpad的Energia代码读取超声波传感器的值，并通过串行端口监控这些值。
- en: 'The following code defines the pins in Launchpad to handle ultrasonic echo
    and trigger pins and also defines variables for the duration of the pulse and
    the distance in centimeters:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了用于处理超声波回声和触发引脚的Launchpad引脚，并定义了脉冲持续时间和距离（厘米）的变量：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The following code snippet is the `setup()` function. The `setup()` function
    is called when the program starts. Use this to initialize variables, pin modes,
    to start using libraries, and so on. The setup function will only run once, after
    each power up or reset of the Launchpad board. Inside `setup()`, we initialize
    serial communication with a baud rate of 115200 and set up the mode of ultrasonic
    handling pins by calling a `SetupUltrasonic();function:`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是`setup()`函数。当程序启动时，会调用`setup()`函数。使用这个函数来初始化变量、设置引脚模式、开始使用库等。`setup()`函数将在每次上电或重置Launchpad板后只运行一次。在`setup()`函数内部，我们使用115200波特率初始化串行通信，并通过调用`SetupUltrasonic();function:`来设置超声波处理引脚的模式：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the setup function for the ultrasonic sensor; it will configure
    the `Trigger` pin as `OUTPUT` and the `Echo` pin as `INPUT`. The `pinMode()` function
    is used to set the pin as `INPUT` or `OUTPUT`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为超声波传感器设置的setup函数；它将`Trigger`引脚配置为`OUTPUT`，将`Echo`引脚配置为`INPUT`。使用`pinMode()`函数将引脚设置为`INPUT`或`OUTPUT`：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After creating a `setup()` function, which initializes and sets the initial
    values, the `loop()` function does precisely what its name suggests, and loops
    consecutively, allowing your program to change and respond. Use it to actively
    control the Launchpad board.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`setup()`函数后，初始化并设置初始值，`loop()`函数将精确地执行其名称所暗示的操作，并连续循环，允许你的程序进行更改和响应。使用它来主动控制Launchpad板。
- en: 'The main loop of this is in the following code. This function is an infinite
    loop and calls the `Update_Ultra_Sonic()` function to update and print the ultrasonic
    readings through a serial port:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是该主循环。这个函数是一个无限循环，并调用`Update_Ultra_Sonic()`函数来更新并通过串行端口打印超声波读数：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The following code is the definition of the `Update_Ultra_Sonic()` function.
    This function will do the following operations. First it will take the trigger
    pin to the `LOW` state for `2` microseconds and `HIGH` for `10` microseconds.
    After `10` microseconds, it will again return the pin to the `LOW` state. This
    is according to the timing diagram. We already saw that 10 µs is the trigger pulse
    width.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`Update_Ultra_Sonic()`函数的定义。此函数将执行以下操作。首先，它将触发引脚设置为`LOW`状态2微秒，然后设置为`HIGH`状态10微秒。在10微秒后，它将再次将引脚返回到`LOW`状态。这是根据时序图的。我们已经看到10
    µs是触发脉冲宽度。
- en: 'After triggering with 10 µs, we have to read the time duration from the Echo
    pin. The time duration is the time taken for the sound to travel from the sensor
    to the object and from the object to the sensor receiver. We can read the pulse
    duration by using the `pulseIn()` function. After getting the time duration, we
    can convert the time into centimeters by using the `microsecondsToCentimeters()`
    function, as shown in the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在触发10 µs后，我们必须从Echo引脚读取时间持续时间。时间持续时间是声音从传感器到物体再从物体到传感器接收器传播的时间。我们可以通过使用`pulseIn()`函数来读取脉冲持续时间。在获得时间持续时间后，我们可以使用`microsecondsToCentimeters()`函数将其转换为厘米，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code is the conversion function from microseconds to distance
    in centimeters. The speed of sound is 340 m/s, that is, 29 microseconds per centimeter.
    So, we get the total distance by diving the total microseconds by 29/2:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是将微秒转换为厘米距离的转换函数。声速是340 m/s，即每厘米29微秒。因此，我们通过将总微秒数除以29/2来得到总距离：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After uploading the code, open the serial monitor from the Energia menu under
    Tools | Serial Monitor and change the baud rate to 115200\. The values from the
    ultrasonic sensor are shown in the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传代码后，从Tools | Serial Monitor下的Energia菜单打开串行监视器，并将波特率更改为115200。超声波传感器的值在以下屏幕截图中显示：
- en: '![](img/3f4f56c0-8820-4164-b093-96609d030585.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f4f56c0-8820-4164-b093-96609d030585.png)'
- en: Output of the ultrasonic distance sensor in Energia serial monitor
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波距离传感器在Energia串行监视器中的输出
- en: Interfacing Tiva C LaunchPad with Python
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Tiva C LaunchPad与Python接口
- en: In this section, we will look at how to connect Tiva C LaunchPad with Python
    to receive data from Launchpad in a PC.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何将Tiva C LaunchPad与Python连接，以便在PC上接收来自Launchpad的数据。
- en: The **PySerial** module can be used for interfacing Launchpad to Python. The
    detailed documentation of PySerial and its installation procedure for Windows,
    Linux, and OS X can be found here : [http://pyserial.sourceforge.net/pyserial.html](http://pyserial.sourceforge.net/pyserial.html)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**PySerial**模块可用于将Launchpad与Python接口。PySerial的详细文档及其在Windows、Linux和OS X上的安装过程可以在此找到：[http://pyserial.sourceforge.net/pyserial.html](http://pyserial.sourceforge.net/pyserial.html)'
- en: '[](http://pyserial.sourceforge.net/pyserial.html)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[](http://pyserial.sourceforge.net/pyserial.html)'
- en: 'PySerial is available in the Ubuntu package manager and it can be easily installed
    in Ubuntu using the following command in the Terminal:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: PySerial可在Ubuntu包管理器中找到，并且可以使用以下命令在Ubuntu中轻松安装：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After installing the `python-serial` package, we can write Python code to interface
    Launchpad. The interfacing code is given in the following section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`python-serial`包后，我们可以编写Python代码来与Launchpad进行接口。接口代码将在下一节给出。
- en: 'The following code imports the Python `serial` module and the `sys` module.
    The `serial` module handles the serial ports of Launchpad and performs operations
    such as reading, writing, and so on. The `sys` module provides access to some
    variables used or maintained by the interpreter and to functions that interact
    strongly with the interpreter. It is always available:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码导入了Python的`serial`模块和`sys`模块。`serial`模块处理Launchpad的串行端口，执行读取、写入等操作。`sys`模块提供了访问由解释器使用或维护的一些变量以及与解释器强交互的函数。它始终可用：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we plug Launchpad to the computer, the device registers on the OS as a
    virtual serial port. In Ubuntu, the device name looks like `/dev/ttyACMx`. Here,
    x can be a number; if there is only one device, it will probably be 0\. To interact
    with Launchpad, we need to handle this device file only.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Launchpad连接到计算机时，该设备在操作系统上注册为虚拟串行端口。在Ubuntu中，设备名称看起来像`/dev/ttyACMx`。在这里，x可以是数字；如果只有一个设备，它可能就是0。要与Launchpad交互，我们只需要处理这个设备文件即可。
- en: 'The following code will try to open the serial port `/dev/ttyACM0` of Launchpad
    with a baud rate of `115200`. If it fails, it will print `Unable to open serial
    port`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将尝试以`115200`波特率打开Launchpad的串行端口`/dev/ttyACM0`。如果失败，它将打印`Unable to open serial
    port`：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code will read the serial data until the serial character becomes
    a new line (`''n''`) and prints it on the Terminal. If we press Ctrl + C on the
    keyboard, to quit the program, it will exit by calling `sys.exit(0)`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将读取串行数据，直到串行字符变为新行（`'n'`），并在终端上打印出来。如果我们按下键盘上的Ctrl + C以退出程序，它将通过调用`sys.exit(0)`退出：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After saving the file, change the permission of the file to executable using
    the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，使用以下命令更改文件的权限为可执行：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the script will look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出将如下所示：
- en: '![](img/8883a773-2d2e-4bf9-b7ef-1cddc170630e.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8883a773-2d2e-4bf9-b7ef-1cddc170630e.png)'
- en: Output of the ultrasonic distance sensor in Energia serial monitor
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Energia串行监视器中超声波距离传感器的输出
- en: Working with the IR proximity sensor
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与红外接近传感器一起工作
- en: Infrared sensors are another method to find obstacles and the distance from
    the robot. The principle of infrared distance sensors is based on the infrared
    light that is reflected from a surface when hitting an obstacle. An IR receiver
    will capture the reflected light and the voltage is measured based on the amount
    of light received.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 红外传感器是另一种寻找障碍物和机器人距离的方法。红外距离传感器的原理基于当红外光击中障碍物时从表面反射回来的红外光。一个红外接收器将捕获反射光，并根据接收到的光量测量电压。
- en: One of the popular IR range sensors is Sharp GP2D12\. The product link can be
    found here: [http://www.robotshop.com/en/sharp-gp2y0a21yk0f-ir-range-sensor.html](http://www.robotshop.com/en/sharp-gp2y0a21yk0f-ir-range-sensor.html)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种流行的红外距离传感器是Sharp GP2D12。产品链接可在此找到：[http://www.robotshop.com/en/sharp-gp2y0a21yk0f-ir-range-sensor.html](http://www.robotshop.com/en/sharp-gp2y0a21yk0f-ir-range-sensor.html)
- en: 'The following image shows the Sharp GP2D12 sensor:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了Sharp GP2D12传感器：
- en: '![](img/b860054a-dc96-4bbc-adb2-1b64eec7fbd9.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b860054a-dc96-4bbc-adb2-1b64eec7fbd9.png)'
- en: 'The sensor sends out a beam of IR light and uses triangulation to measure the
    distance. The detection range of the GP2D12 is between 10 cm and 80 cm. The beam
    is 6 cm wide at a distance of 80 cm. The transmission and reflection of the IR
    light sensor is illustrated in the following diagram:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器发出一束红外光，并使用三角测量法来测量距离。GP2D12的检测范围在10厘米到80厘米之间。在80厘米的距离上，光束宽度为6厘米。以下图示了红外光传感器的传输和反射：
- en: '![](img/08cd0547-f099-46c0-a2b1-6f56d60a8e2a.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08cd0547-f099-46c0-a2b1-6f56d60a8e2a.png)'
- en: Obstacle sensing using IR light sensor
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用红外光传感器进行障碍物感应
- en: 'On the left of the sensor is an IR transmitter, which continuously sends IR
    radiation. After hitting into some objects, the IR light will reflect and it will
    be received by the IR receiver. The interfacing circuit of the IR sensor is shown
    here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在传感器的左侧是红外发射器，它持续发送红外辐射。在击中一些物体后，红外光将反射，并被红外接收器接收。以下是红外传感器的接口电路图：
- en: '![](img/4ac903e7-cd5f-4439-9768-00e2ada402f1.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac903e7-cd5f-4439-9768-00e2ada402f1.png)'
- en: Pinout of Sharp IR sensor
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Sharp红外传感器的引脚图
- en: 'The analog out pin **Vo** can be connected to the ADC pin of Launchpad. The
    interfacing code of the Sharp distance sensor with the Tiva C Launchpad is discussed
    further in this section. In this code, we select the 18th pin of Launchpad and
    set it to the ADC mode and read the voltage levels from the Sharp distance sensor.
    The range equation of the GP2D12 IR sensor is given as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟输出引脚**Vo**可以连接到Launchpad的ADC引脚。本节进一步讨论了Sharp距离传感器与Tiva C Launchpad的接口代码。在此代码中，我们选择Launchpad的18号引脚，并将其设置为ADC模式，从Sharp距离传感器读取电压等级。GP2D12红外传感器的范围方程如下：
- en: '*Range = (6,787 / (Volt - 3)) - 4*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围 = (6,787 / (伏特 - 3)) - 4*'
- en: Here, *Volt* is the analog voltage value from the ADC of the Volt pin.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*Volt*是从伏特引脚的ADC获取的模拟电压值。
- en: 'In this first section of the code, we set the 18th pin of Tiva C LaunchPad
    as the input pin and start a serial communication at a baud rate of 115200:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一个部分，我们将Tiva C LaunchPad的18号引脚设置为输入引脚，并以115200波特率启动串行通信：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the following section of code, the controller continuously reads the analog
    pin and converts it to the distance value in centimeters:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码部分，控制器持续读取模拟引脚，并将其转换为厘米距离值：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is the basic code to interface a sharp distance sensor. There are some
    drawbacks with IR sensors. Some of them are as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是连接sharp距离传感器的基本代码。红外传感器有一些缺点。以下是一些：
- en: We can't use them in direct or indirect sunlight, so it's difficult to use them
    in an outdoor robot
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在直接或间接的阳光下使用它们，因此在户外机器人中很难使用它们
- en: They may not work if the object is not reflective
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果物体不是反光的，它们可能无法工作
- en: The range equation only works within the range
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围方程仅在范围内有效
- en: In the next section, we will discuss the IMU and its interfacing with Tiva C
    LaunchPad. An IMU can give the odometry data and it can be used as the input to
    navigation algorithms.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论IMU及其与Tiva C LaunchPad的接口。IMU可以提供里程计数据，并可作为导航算法的输入。
- en: Working with Inertial Measurement Units
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与惯性测量单元（IMU）一起工作
- en: An **inertial measurement unit** (**IMU**) is an electronic device that measures
    velocity, orientation, and gravitational forces using a combination of accelerometers,
    gyroscopes, and magnetometers. IMUs have a lot of applications in robotics; some
    of the applications are applied in balancing of **unmanned aerial vehicles** (**UAVs**)
    and robot navigation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**惯性测量单元**（**IMU**）是一种电子设备，它通过加速度计、陀螺仪和磁力计的组合来测量速度、方向和重力。IMU在机器人技术中有许多应用；其中一些应用用于**无人机**（**UAVs**）的平衡和机器人导航。'
- en: In this section, we will discuss the role of IMUs in mobile robot navigation
    and some of the latest IMUs on the market and their interfacing with Launchpad.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论IMU在移动机器人导航中的作用，以及市场上的一些最新IMU及其与Launchpad的接口。
- en: Inertial navigation
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惯性导航
- en: An IMU provides acceleration and orientation relative to inertial space. If
    you know the initial position, velocity, and orientation, you can calculate the
    velocity by integrating the sensed acceleration and the second integration gives
    the position. To get the correct direction of the robot, the orientation of the
    robot is required; this can be obtained by integrating sensed angular velocity
    from a gyroscope.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 惯性测量单元（IMU）提供相对于惯性空间的加速度和方向。如果你知道初始位置、速度和方向，你可以通过积分感知到的加速度来计算速度，第二次积分给出位置。为了获得机器人的正确方向，需要知道机器人的方向；这可以通过从陀螺仪积分感知到的角速度来获得。
- en: 'The following diagram illustrates an inertial navigation system, which will
    convert IMU values to odometry data:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了惯性导航系统，它将IMU值转换为里程计数据：
- en: '![](img/96725089-cfd4-4614-9161-c6e5ea42f5b2.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96725089-cfd4-4614-9161-c6e5ea42f5b2.png)'
- en: Block diagram of IMU
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: IMU的框图
- en: 'The values we get from the IMU are converted into navigational information
    using navigation equations and feeding them into estimation filters, such as the
    Kalman filter. The **Kalman** filter is an algorithm that estimates the state
    of a system from the measured data ([http://en.wikipedia.org/wiki/Kalman_filter](http://en.wikipedia.org/wiki/Kalman_filter)).
    The data from an **inertial navigation system** (**INS**) will have some drift
    because of the error from the accelerometer and gyroscope. To limit the drift,
    an INS is usually aided by other sensors that provide direct measurements of the
    integrated quantities. Based on the measurements and sensor error models, the
    Kalman filter estimates errors in the navigation equations and all the colored
    sensors'' errors. The following diagram illustrates an aided inertial navigation
    system using the Kalman filter:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从IMU获得的数据通过使用导航方程转换为导航信息，并将它们输入到估计滤波器中，如卡尔曼滤波器。**卡尔曼**滤波器是一种从测量数据估计系统状态的算法（[http://en.wikipedia.org/wiki/Kalman_filter](http://en.wikipedia.org/wiki/Kalman_filter)）。由于加速度计和陀螺仪的误差，惯性导航系统（**INS**）的数据将会有一些漂移。为了限制漂移，惯性导航系统通常由提供直接测量积分量的其他传感器辅助。基于测量和传感器误差模型，卡尔曼滤波器估计导航方程中的误差以及所有彩色传感器的误差。以下图示说明了使用卡尔曼滤波器的辅助惯性导航系统：
- en: '![](img/eac139d5-1f99-4cfd-9e7c-2a8975f60b91.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eac139d5-1f99-4cfd-9e7c-2a8975f60b91.png)'
- en: IMU with inertial navigation system
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 带有惯性导航系统的IMU
- en: Along with the motor encoders, the value from the IMU can be taken as the odometer
    value and it can be used for **dead reckoning**, the process of finding the current
    position of a moving object by using a previously determined position.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了电机编码器外，IMU的值可以被视为里程计值，并可用于**推算导航**，即通过使用先前确定的当前位置来找到移动物体的当前位置的过程。
- en: In the next section, we are going to look at one of the most popular IMUs from
    InvenSense, called **MPU 6050**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨InvenSense公司最受欢迎的惯性测量单元（IMU）之一，称为**MPU 6050**。
- en: Interfacing MPU 6050 with Tiva C LaunchPad
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将MPU 6050与Tiva C LaunchPad接口
- en: The MPU-6000/MPU-6050 family of parts is the world's first and only six-axis
    motion tracking devices designed for the low power, low cost, and high-performance
    requirements of smartphones, tablets, wearable sensors, and robotics.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: MPU-6000/MPU-6050系列部件是全球首款也是唯一一款专为智能手机、平板电脑、可穿戴传感器和机器人等低功耗、低成本和高性能需求设计的六轴运动跟踪设备。
- en: 'The MPU-6000/6050 devices combine a three-axis gyroscope and three-axis accelerometer
    on the silicon die together with an onboard digital motion processor capable of
    processing complex nine-axis motion fusion algorithms. The following diagram shows
    the system diagram of MPU 6050 and break out of MPU 6050:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: MPU-6000/6050设备将三轴陀螺仪和三轴加速度计集成在硅芯片上，并配备了一个能够处理复杂九轴运动融合算法的板载数字运动处理器。以下图示展示了MPU
    6050的系统图和引脚分布：
- en: '![](img/d3155f85-5dea-4496-b7e4-e43717a72ef1.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3155f85-5dea-4496-b7e4-e43717a72ef1.png)'
- en: Block diagram of MPU 6050
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: MPU 6050的框图
- en: 'The breakout board of MPU 6050 is shown in the following diagram and it can
    be purchased from here [http://a.co/7C3yL96](http://a.co/7C3yL96):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了MPU 6050的扩展板，并且可以从这里购买[http://a.co/7C3yL96](http://a.co/7C3yL96)：
- en: '![](img/f9d921ce-0ffe-4c31-a559-8eff293c3c11.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9d921ce-0ffe-4c31-a559-8eff293c3c11.png)'
- en: MPU 6050 breakout board
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: MPU 6050扩展板
- en: 'The connection from Launchpad to MPU 6050 is given in the following table.
    The remaining pins can be left disconnected:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格给出了Launchpad到MPU 6050的连接方式。其余引脚可以保持未连接状态：
- en: '| Launchpad pins | MPU6050 pins |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| Launchpad引脚 | MPU6050引脚 |'
- en: '| +3.3V | VCC/VDD |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| +3.3V | VCC/VDD |'
- en: '| GND | GND |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| GND | GND |'
- en: '| PD0 | SCL |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| PD0 | SCL |'
- en: '| PD1 | SDA |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| PD1 | SDA |'
- en: 'The following diagram shows the interfacing of MPU 6050 and Tiva C Launchpad:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了MPU 6050和Tiva C Launchpad的接口：
- en: '![](img/f91bf3ea-20e4-4715-9754-9882297e09b9.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f91bf3ea-20e4-4715-9754-9882297e09b9.png)'
- en: Interfacing MPU 6050 breakout board to Launchpad
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将MPU 6050扩展板连接到Launchpad
- en: MPU 6050 and Launchpad communicate using the I2C protocol. The supply voltage
    is 3.3V and it is taken from Launchpad.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: MPU 6050和Launchpad使用I2C协议进行通信。供电电压为3.3V，由Launchpad提供。
- en: Setting the MPU 6050 library in Energia
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Energia中设置MPU 6050库
- en: The interfacing code of Energia is discussed in this section. The interfacing
    code uses the [https://github.com/jrowberg/i2cdevlib/zipball/master](https://github.com/jrowberg/i2cdevlib/zipball/master)
    library for interfacing MPU 6050.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了Energia的接口代码。接口代码使用了[https://github.com/jrowberg/i2cdevlib/zipball/master](https://github.com/jrowberg/i2cdevlib/zipball/master)库来连接MPU
    6050。
- en: 'Download the ZIP file from the preceding link and navigate to Preference from
    File | Preference in Energia, as shown in the following screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述链接下载ZIP文件，并在Energia中从文件菜单选择“首选项”，如图所示：
- en: '![](img/b88d717b-08da-41dc-b6bd-fdbe7b916eda.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b88d717b-08da-41dc-b6bd-fdbe7b916eda.png)'
- en: Interfacing MPU 6050 breakout board to Launchpad
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将MPU 6050扩展板连接到Launchpad
- en: Go to Sketchbook location under Preferences, as seen in the preceding screenshot,
    and create a folder called `libraries`. Extract the files inside the Arduino folder
    inside the ZIP file to the `sketchbook/libraries` location. The Arduino packages
    in this repository are also compatible with Launchpad. The extracted files contain
    the `I2Cdev`, `Wire`, and `MPU6050` packages that are required for the interfacing
    of the MPU 6050 sensor. There are other sensor packages that are present in the
    `libraries` folder but we are not using them now.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在“首选项”下的Sketchbook位置，如图所示，创建一个名为`libraries`的文件夹。将ZIP文件中Arduino文件夹内的文件提取到`sketchbook/libraries`位置。此存储库中的Arduino包也兼容Launchpad。提取的文件包含用于MPU
    6050传感器接口的`I2Cdev`、`Wire`和`MPU6050`包。`libraries`文件夹中还有其他传感器包，但我们现在没有使用它们。
- en: The preceding procedure is done in Ubuntu, but it is the same for Windows and
    macOS X.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤在Ubuntu上执行，但对于Windows和macOS X也是相同的。
- en: Interfacing code of Energia
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Energia的接口代码
- en: This code is used to read the raw value from MPU 6050 to Launchpad. It uses
    an MPU 6050 third-party library compatible with Energia IDE. The following are
    the explanations of each block of the code.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码用于从MPU 6050读取原始值到Launchpad。它使用与Energia IDE兼容的第三方MPU 6050库。以下是代码每个块的说明。
- en: 'In this first section of code, we include the necessary headers for interfacing
    MPU 6050 to Launchpad, such as `12C`, `Wire` and the `MPU6050` library, and create
    an object of `MPU6050` with the name `accelgyro`. The `MPU6050.h` library contains
    a class named `MPU6050` to send and receive data to and from the sensor:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本代码的第一部分，我们包含了将 MPU 6050 连接到 Launchpad 所需的必要头文件，例如 `12C`、`Wire` 和 `MPU6050`
    库，并创建了一个名为 `accelgyro` 的 `MPU6050` 对象。`MPU6050.h` 库包含一个名为 `MPU6050` 的类，用于向传感器发送和接收数据：
- en: '[PRE35]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the following section, we start the I2C and serial communication to communicate
    with MPU 6050 and print sensor values through the serial port. The serial communication
    baud rate is `115200` and `Setup_MPU6050()` is the custom function to initialize
    the MPU 6050 communication:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们开始 I2C 和串行通信以与 MPU 6050 通信并通过串行端口打印传感器值。串行通信波特率为 `115200`，`Setup_MPU6050()`
    是用于初始化 MPU 6050 通信的自定义函数：
- en: '[PRE36]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following section is the definition of the `Setup_MPU6050()` function.
    The `Wire` library allows you to communicate with the I2C devices. MPU 6050 can
    communicate using I2C. The `Wire.begin()` function will start the I2C communication
    between MPU 6050 and Launchpad; also, it will initialize the MPU 6050 device using
    the `initialize()` method defined in the `MPU6050` class. If everything is successful,
    it will print connection successful; otherwise, it will print connection failed:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分是 `Setup_MPU6050()` 函数的定义。`Wire` 库允许您与 I2C 设备通信。MPU 6050 可以使用 I2C 进行通信。`Wire.begin()`
    函数将启动 MPU 6050 和 Launchpad 之间的 I2C 通信；同时，它将使用 `MPU6050` 类中定义的 `initialize()` 方法初始化
    MPU 6050 设备。如果一切顺利，它将打印连接成功；否则，它将打印连接失败：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following code is the `loop()` function, which continuously reads the sensor
    value and prints its values through the serial port: The `Update_MPU6050()` custom
    function is responsible for printing the updated value from MPU 6050:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `loop()` 函数，它持续读取传感器值并通过串行端口打印其值：`Update_MPU6050()` 自定义函数负责打印来自 MPU 6050
    的更新值：
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The definition of `Update_MPU6050()` is given as follows. It declares six variables
    to handle the accelerometer and gyroscope value in three-axis. The `getMotion6()`
    function in the MPU 6050 class is responsible for reading the new values from
    the sensor. After reading them, it will print via the serial port:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update_MPU6050()` 函数的定义如下。它声明了六个变量来处理三轴加速度计和陀螺仪的值。MPU 6050 类中的 `getMotion6()`
    函数负责从传感器读取新值。读取后，它将通过串行端口打印：'
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output from the serial monitor is shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从串行监视器输出的内容：
- en: '![](img/43c41c23-6657-4d2b-8332-ab2ea0c1341e.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43c41c23-6657-4d2b-8332-ab2ea0c1341e.png)'
- en: Output from MPU 6050 in the serial monitor
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 串行监视器中 MPU 6050 的输出
- en: 'We can read these values using the Python code that we used for ultrasonic.
    The following is the screenshot of the Terminal when we run the Python script:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用用于超声波的 Python 代码读取这些值。以下是我们运行 Python 脚本时的终端截图：
- en: '![](img/1731f2d5-8b4a-4609-94fb-c55811f65a8b.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1731f2d5-8b4a-4609-94fb-c55811f65a8b.png)'
- en: Output from MPU 6050 in the Linux Terminal
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 终端中 MPU 6050 的输出
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed the interfacing of the motors that we are
    using in our robot. We have looked at motor and encoder interfacing with a controller
    board called Tiva C Launchpad. We have discussed the controller code for interfacing
    motors and encoders. In the future, if the robot requires high accuracy and torque,
    we have looked at Dynamixel servos that can substitute current DC motors. We have
    also looked at the robotic sensors that can be used in our robot. The sensors
    we discussed are ultrasonic distance sensors, IR proximity sensors, and IMUs.
    These three sensors help in the navigation of the robot. We also discussed the
    basic code to interface these sensors to Tiva C LaunchPad. We will discuss the
    vision sensors used in this robot further in the next chapter.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了我们用于机器人的电机接口。我们研究了电机和编码器与名为 Tiva C Launchpad 的控制器板的接口。我们讨论了电机和编码器接口的控制器代码。在未来，如果机器人需要高精度和高扭矩，我们研究了可以替代当前直流电机的
    Dynamixel 伺服电机。我们还研究了可以用于我们机器人的机器人传感器。我们讨论的传感器是超声波距离传感器、红外接近传感器和 IMU。这三个传感器有助于机器人的导航。我们还讨论了将这些传感器接口到
    Tiva C LaunchPad 的基本代码。我们将在下一章进一步讨论该机器人使用的视觉传感器。
- en: Questions
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the H-Bridge circuit?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: H-桥电路是什么？
- en: What is a quadrature encoder?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是四倍数编码器？
- en: What is the 4X encoding scheme?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4X 编码方案是什么？
- en: How do we calculate displacement from encoder data?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从编码器数据计算位移？
- en: What are the features of the Dynamixel actuator?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dynamixel执行器的特点有哪些？
- en: What are ultrasonic sensors and how do they work?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超声波传感器是什么以及它们是如何工作的？
- en: How do you calculate distance from the ultrasonic sensor?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是如何从超声波传感器计算距离的？
- en: What is the IR proximity sensor and how does it work?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是红外接近传感器以及它是如何工作的？
- en: Further reading
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Read more about Energia programming at the following link:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中了解更多关于Energia编程的信息：
- en: '[http://energia.nu/guide/](http://energia.nu/guide/)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://energia.nu/guide/](http://energia.nu/guide/)'
