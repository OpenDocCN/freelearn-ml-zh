- en: <st c="0">9</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">9</st>
- en: <st c="2">Extracting Features from Relational Data with Featuretools</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">使用Featuretools从关系数据中提取特征</st>
- en: <st c="60">In previous chapters, we worked with data organized in rows and columns,
    where the columns are the variables, the rows are the observations, and each observation
    is independent.</st> <st c="239">In this chapter, we will focus on creating features
    from relational datasets.</st> <st c="317">In relational datasets, data is structured
    across various tables, which can be joined together via unique identifiers.</st>
    <st c="436">These unique identifiers indicate relationships that exist between
    the</st> <st c="507">different tables.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60">在前几章中，我们处理的是以行和列组织的数据，其中列是变量，行是观测值，每个观测值都是独立的。</st> <st c="239">在本章中，我们将专注于从关系型数据集中创建特征。</st>
    <st c="317">在关系型数据集中，数据被结构化在不同的表中，这些表可以通过唯一标识符进行连接。</st> <st c="436">这些唯一标识符表示不同表之间存在的关联。</st>
    <st c="507">不同表之间的关联。</st>
- en: <st c="524">A classic example of relational data is that held by retail companies.</st>
    <st c="596">One table contains information about customers, such as names and
    addresses.</st> <st c="673">A second table has information about the purchases
    made by the customers, such as the type and number of items bought per purchase.</st>
    <st c="805">A third table contains information about the customers’ interactions
    with the company’s website, variables such as session duration, the mobile device
    used, and pages visited.</st> <st c="981">Customers, purchases, and sessions are
    identified with unique identifiers.</st> <st c="1056">These unique identifiers
    allow us to put these tables together, and in this way, we can get information
    about customers’ purchases</st> <st c="1187">or sessions.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="524">关系数据的经典例子是零售公司持有的数据。</st> <st c="596">一个表包含有关客户的信息，例如姓名和地址。</st>
    <st c="673">第二个表包含有关客户购买的信息，例如每次购买购买的商品类型和数量。</st> <st c="805">第三个表包含有关客户与公司网站互动的信息，例如会话持续时间、使用的移动设备和访问的页面。</st>
    <st c="981">客户、购买和会话都使用唯一标识符进行标识。</st> <st c="1056">这些唯一标识符使我们能够将这些表组合起来，这样我们就可以获取有关客户购买或会话的信息。</st>
    <st c="1187">或会话。</st>
- en: <st c="1199">If we want to know more about the types of customers we have (that
    is, customer segmentation) or make predictions about whether they would buy a
    product, we can create features that aggregate or summarize information across
    different tables at the customer level.</st> <st c="1464">For example, we can
    create features that capture the maximum amount spent by a customer on a purchase,
    the number of purchases they have made, the time between sessions, or the average
    session duration.</st> <st c="1667">The number of features we can create and the
    various ways we can aggregate data across tables are abundant.</st> <st c="1775">In
    this chapter, we will discuss some common ways of creating aggregated views of
    relational data utilizing the</st> `<st c="1887">featuretools</st>` <st c="1899">Python
    library.</st> <st c="1916">We will begin by setting up various data tables and
    their relationships and automatically creating features, and next, we will follow
    up with more detail on the different features we</st> <st c="2099">can create.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1199">如果我们想了解更多关于我们拥有的客户类型（即客户细分）或者预测他们是否会购买产品，我们可以在客户层面创建汇总或总结不同表信息的特征。</st>
    <st c="1464">例如，我们可以创建捕捉客户在购买中花费的最大金额、他们购买的商品数量、会话之间的时间或平均会话持续时间的特征。</st> <st
    c="1667">我们可以创建的特征数量以及我们在表中聚合数据的不同方式是丰富的。</st> <st c="1775">在本章中，我们将讨论一些使用`<st
    c="1887">featuretools</st>` `<st c="1899">Python库</st>`创建关系数据聚合视图的常见方法。</st> <st
    c="1916">我们将从设置各种数据表及其关系并自动创建特征开始，然后我们将详细介绍我们可以创建的不同特征。</st> <st c="2099">我们可以创建的不同特征。</st>
- en: <st c="2110">In this chapter, we will cover the</st> <st c="2146">following
    recipes:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2110">在本章中，我们将介绍以下食谱：</st> <st c="2146">以下食谱：</st>
- en: <st c="2164">Setting up an entity set and creating</st> <st c="2203">features
    automatically</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2164">设置实体集并自动创建特征</st> <st c="2203">自动创建特征</st>
- en: <st c="2225">Creating features with general and</st> <st c="2261">cumulative
    operations</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2225">使用通用和累积操作创建特征</st> <st c="2261">累积操作创建特征</st>
- en: <st c="2282">Combining</st> <st c="2293">numerical features</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2282">结合</st> <st c="2293">数值特征</st>
- en: <st c="2311">Extracting features from date</st> <st c="2342">and time</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2311">从日期和时间中提取特征</st> <st c="2342">和特征</st>
- en: <st c="2350">Extracting features</st> <st c="2371">from text</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2350">从文本中提取特征</st> <st c="2371">从文本中提取特征</st>
- en: <st c="2380">Creating features with</st> <st c="2404">aggregation primitives</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2380">使用聚合原语创建特征</st>
- en: <st c="2426">Technical requirements</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2426">技术要求</st>
- en: <st c="2449">In this chapter, we will use</st> `<st c="2479">pandas</st>`<st
    c="2485">,</st> `<st c="2487">matplotlib</st>`<st c="2497">, and</st> `<st c="2503">featuretools</st>`
    <st c="2515">open source Python libraries.</st> <st c="2546">You can install</st>
    `<st c="2562">featuretools</st>` <st c="2574">with</st> `<st c="2580">pip</st>`<st
    c="2583">:</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2449">在本章中，我们将使用</st> `<st c="2479">pandas</st>`<st c="2485">,</st> `<st
    c="2487">matplotlib</st>`<st c="2497">, 和</st> `<st c="2503">featuretools</st>`
    <st c="2515">开源Python库。</st> <st c="2546">您可以使用</st> `<st c="2562">featuretools</st>`
    <st c="2574">通过</st> `<st c="2580">pip</st>`<st c="2583">进行安装：</st>
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="2610">Additionally, you can do so</st> <st c="2639">with</st> `<st c="2644">conda</st>`<st
    c="2649">:</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2610">此外，您还可以使用</st> <st c="2639">conda</st><st c="2649">来完成此操作：</st>
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="2693">These commands install the basic</st> `<st c="2727">featuretools</st>`
    <st c="2739">functionality, but we can install add-ons for</st> <st c="2786">creating
    features with</st> `<st c="2857">dask</st>` <st c="2861">as the backend instead
    of</st> `<st c="2888">pandas</st>`<st c="2894">. For more information on how to
    install</st> `<st c="2935">featuretools</st>` <st c="2947">add-ons, including</st>
    `<st c="2967">graphviz</st>`<st c="2975">, check out their documentation</st>
    <st c="3007">here:</st> [<st c="3013">https://docs.featuretools.com/en/v0.16.0/getting_started/install.html</st>](https://docs.featuretools.com/en/v0.16.0/getting_started/install.html)<st
    c="3082">.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2693">这些命令安装了基本的</st> `<st c="2727">featuretools</st>` <st c="2739">功能，但我们也可以安装用于使用</st>
    `<st c="2786">dask</st>` <st c="2857">作为后端而不是</st> `<st c="2888">pandas</st>`<st
    c="2894">来创建特征的附加组件。有关如何安装</st> `<st c="2935">featuretools</st>` <st c="2947">附加组件的更多信息，包括</st>
    `<st c="2967">graphviz</st>`<st c="2975">，请参阅他们的文档：</st> [<st c="3007">https://docs.featuretools.com/en/v0.16.0/getting_started/install.html</st>](https://docs.featuretools.com/en/v0.16.0/getting_started/install.html)<st
    c="3082">。</st>
- en: <st c="3083">We</st> <st c="3087">wil</st><st c="3090">l work with the</st>
    *<st c="3107">Online Retail II</st>* <st c="3123">dataset from the UCI Machine
    Learning Repository, which is available at</st> [<st c="3196">https://archive.ics.uci.edu/ml/datasets/Online+Retail+II</st>](https://archive.ics.uci.edu/ml/datasets/Online+Retail+II)
    <st c="3252">and licensed under a</st> **<st c="3274">Creative Commons Attribution
    4.0 International</st>** <st c="3320">(</st>**<st c="3322">CC BY 4.0</st>**<st
    c="3331">) license:</st> [<st c="3343">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)<st
    c="3396">. The corresponding citation for this data is provided here:</st> *<st
    c="3457">Chen, Daqing</st>* <st c="3469">(</st>*<st c="3471">2019</st>*<st c="3475">).</st>
    *<st c="3479">Online Retail II</st>*<st c="3495">.</st> *<st c="3497">UCI Machine
    Learning</st>* *<st c="3518">Repository</st>* <st c="3528">(</st>[<st c="3530">https://doi.org/10.24432/C5CG6D</st>](https://doi.org/10.24432/C5CG6D)<st
    c="3561">)</st><st c="3563">.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3083">我们将</st> <st c="3087">与</st><st c="3090">来自UCI机器学习仓库的</st> *<st
    c="3107">在线零售II</st>* <st c="3123">数据集</st>进行工作，该数据集可在[<st c="3196">https://archive.ics.uci.edu/ml/datasets/Online+Retail+II</st>](https://archive.ics.uci.edu/ml/datasets/Online+Retail+II)
    <st c="3252">找到，并受</st> **<st c="3274">Creative Commons Attribution 4.0 International</st>**
    <st c="3320">(</st>**<st c="3322">CC BY 4.0</st>**<st c="3331">)许可协议的约束：</st>
    [<st c="3343">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)<st
    c="3396">。此数据的相应引用如下：</st> *<st c="3457">陈，大清</st>* <st c="3469">(</st>*<st c="3471">2019</st>*<st
    c="3475">).</st> *<st c="3479">在线零售II</st>*<st c="3495">.</st> *<st c="3497">UCI机器学习</st>*
    *<st c="3518">仓库</st>* <st c="3528">(</st>[<st c="3530">https://doi.org/10.24432/C5CG6D</st>](https://doi.org/10.24432/C5CG6D)<st
    c="3561">)</st><st c="3563">.</st>
- en: <st c="3564">I downloaded and modified the data as shown in this</st> <st c="3617">notebook:</st>
    [<st c="3627">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3564">我下载并修改了如下</st> <st c="3617">笔记本</st>中的数据：[<st c="3627">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb)
- en: <st c="3768">You’ll find a copy of the modified dataset in the accompanying
    GitHub</st> <st c="3839">repository:</st> [<st c="3851">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3768">你可以在附带的GitHub</st> <st c="3839">仓库中找到修改后的数据集：</st> [<st c="3851">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv)
- en: <st c="3974">Setting up an entity set and creating features automatically</st>
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3974">设置实体集和自动创建特征</st>
- en: <st c="4035">Relationa</st><st c="4045">l datasets or databases contain data
    spread across multiple tables</st><st c="4112">, and the relationships</st> <st
    c="4136">between tables are dictated by a unique identifier</st> <st c="4187">that
    tells us how we can join those tables.</st> <st c="4231">To automate feature creation
    with</st> `<st c="4265">featuretools</st>`<st c="4277">, we first need to enter
    the different data tables and establish their relationships within what is called
    an</st> `<st c="4427">featuretools</st>` <st c="4439">how these tables are connected
    so that the library can automatically create features based on</st> <st c="4534">those
    relationships.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4035">关系型数据集或数据库包含分散在多个表中的数据</st><st c="4045">，表之间的关系由一个唯一标识符决定，它告诉我们如何连接这些表。</st>
    <st c="4136">为了使用`<st c="4265">featuretools</st>`<st c="4277">自动创建特征，我们首先需要输入不同的数据表，并在所谓的</st>
    `<st c="4427">featuretools</st>`<st c="4439">中建立它们之间的关系，以便库可以自动根据这些关系创建特征。</st>
- en: <st c="4554">We will w</st><st c="4564">ork with a dataset containing information
    about customers, invoices, and products.</st> <st c="4648">First, we will set
    up an entity set highlighting the relationsh</st><st c="4711">ips between these
    three items.</st> <st c="4743">This entity set will be the starting point for
    the remaining recipes in this chapter.</st> <st c="4829">Next, we will create
    features automatically by aggregating the data at the customer, invoice, and product
    levels, utilizing the default parameters</st> <st c="4976">from</st> `<st c="4981">featuretools</st>`<st
    c="4993">.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4554">我们将使用一个包含客户、发票和产品信息的</st><st c="4564">数据集进行工作。</st> <st c="4648">首先，我们将设置一个实体集，突出这三个项目之间的关系。</st><st
    c="4711">这个实体集将是本章剩余菜谱的起点。</st> <st c="4743">接下来，我们将通过聚合客户、发票和产品层次的数据来自动创建特征，利用来自`<st
    c="4981">featuretools</st>`<st c="4993">的默认参数。</st>
- en: <st c="4994">In this recipe, you will learn how to correctly set up an entity
    set and extract a bunch of features automatically for each entity.</st> <st c="5127">In
    the upcoming recipes, we will dig deeper into the different types of features
    that we can create</st> <st c="5227">with</st> `<st c="5232">featuretoo</st><st
    c="5242">ls</st>`<st c="5245">.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4994">在本菜谱中，你将学习如何正确设置实体集并为每个实体自动提取一系列特征。</st> <st c="5127">在接下来的菜谱中，我们将深入了解我们可以使用`<st
    c="5232">featuretoo</st><st c="5242">ls</st>`<st c="5245">创建的不同类型的特征。</st>
- en: <st c="5246">Getting ready</st>
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5246">准备工作</st>
- en: <st c="5260">In this recipe, we will use the</st> *<st c="5293">Online Retail
    II</st>* <st c="5309">dataset from the UCI Machine Learning Repository.</st> <st
    c="5360">In this table, there are customers, which are businesses that buy in
    bulk from the retail company.</st> <st c="5459">Customers are identified with
    a</st> `<st c="5491">customer_id</st>` <st c="5502">unique identifier.</st> <st
    c="5522">Each customer makes one or more purchases, which are flagged by an</st>
    `<st c="5589">invoice</st>` <st c="5596">unique identifier, containing the invoice
    number.</st> <st c="5647">In each invoice, there are one or more items that have
    been bought by the customer.</st> <st c="5731">Each item or product sold by the
    company is also identified with a unique</st> <st c="5805">stock code.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5260">在本菜谱中，我们将使用来自UCI机器学习仓库的</st> *<st c="5293">Online Retail II</st>*
    <st c="5309">数据集。</st> <st c="5360">在这个表中，有客户，他们是向零售公司大批量购买的企业。</st> <st c="5459">客户通过一个</st>
    `<st c="5491">customer_id</st>` <st c="5502">唯一标识符来识别。</st> <st c="5522">每个客户会进行一次或多次购买，这些购买通过一个</st>
    `<st c="5589">invoice</st>` <st c="5596">唯一标识符标记，包含发票号码。</st> <st c="5647">在每一张发票中，都有客户购买的一个或多个项目。</st>
    <st c="5731">公司销售的产品或每个项目也通过一个唯一的</st> `<st c="5805">stock code</st>` <st c="5806">来识别。</st>
- en: <st c="5816">Thus, the data has the</st> <st c="5840">following relation</st><st
    c="5858">s:</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5816">因此，数据有以下</st> <st c="5840">关系</st><st c="5858">：</st>
- en: '![Figure 9.1 – Diagram showing the relationships in the data](img/B22396_09_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 显示数据关系的图](img/B22396_09_01.jpg)'
- en: <st c="5960">Figure 9.1 – Diagram showing the relationships in the data</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5960">图9.1 – 显示数据关系的图</st>
- en: <st c="6018">Ea</st><st c="6021">ch customer made one or more purchases, identified
    by the invoice number.</st> <st c="6096">Each invoice contains one or more items,
    identifi</st><st c="6145">ed by the stock code.</st> <st c="6168">Each item can
    be bought by one or more customers and is therefore present in several invoices.</st>
    <st c="6263">With these relationships in mind, let’s proceed to</st> <st c="6314">the
    recip</st><st c="6323">e.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6018">每位客户都进行了一笔或多笔购买，这些购买通过发票号来识别。</st> <st c="6096">每张发票包含一个或多个项目，这些项目通过库存代码来识别。</st>
    <st c="6145">每个项目可以被一个或多个客户购买，因此出现在多张发票中。</st> <st c="6168">考虑到这些关系，让我们继续进行</st>
    <st c="6314">下一步。</st>
- en: <st c="6326">How to do it...</st>
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6326">如何操作...</st>
- en: <st c="6342">In this recipe, we will</st> <st c="6367">set up an entity set
    with the data, and then</st> <st c="6412">highlight the different relationships
    in the dataset.</st> <st c="6466">Finally, we will create features by aggregating
    information in the dataset at the customer, invoice, and</st> <st c="6571">product
    levels:</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6342">在这个菜谱中，我们将</st> <st c="6367">使用数据设置一个实体集，然后</st> <st c="6412">突出显示数据集中的不同关系。</st>
    <st c="6466">最后，我们将通过在客户、发票和</st> <st c="6571">产品级别上汇总数据集中的信息来创建特征：</st>
- en: <st c="6586">Let’s import the</st> <st c="6604">required libraries:</st>
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6586">让我们导入所需的库：</st>
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="6716">Let’s load the retail dataset described in the</st> *<st c="6764">Getting
    ready</st>* <st c="6777">section and display its first</st> <st c="6808">five
    rows:</st>
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6716">让我们加载在“准备”<st c="6764">部分中描述的零售数据集，并显示其前五行：</st>
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="6890">In the</st> <st c="6898">following screenshot, we see the unique
    identifiers</st> <st c="6950">for customers (</st>`<st c="6965">customer_id</st>`<st
    c="6977">) and invoices (</st>`<st c="6994">invoice</st>`<st c="7002">), and additional
    information about the</st> <st c="7042">items bought in each invoice, s</st><st
    c="7074">uch as the item’s code (</st>`<st c="7099">stock_code</st>`<st c="7110">),
    description, quantity, and unit price, as well as the date of</st> <st c="7176">the
    inv</st><st c="7183">oice:</st>
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="6890">在下面的屏幕截图中，我们可以看到客户（</st>`<st c="6965">customer_id</st>`<st c="6977">）和发票（</st>`<st
    c="6994">invoice</st>`<st c="7002">）的唯一标识符，以及关于每张发票中购买的商品的附加信息，例如商品的代码（</st>`<st
    c="7099">stock_code</st>`<st c="7110">）、描述、数量、单价，以及发票的日期：</st>
- en: '![Figure 9.2 – Online Retail II dataset](img/B22396_09_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 在线零售II数据集](img/B22396_09_02.jpg)'
- en: <st c="7652">Figure 9.2 – Online Retail II dataset</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7652">图9.2 – 在线零售II数据集</st>
- en: <st c="7689">Note</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7689">注意</st>
- en: <st c="7694">Use</st> `<st c="7699">pandas</st>`<st c="7705">’</st> `<st c="7708">unique()</st>`
    <st c="7716">function</st> <st c="7726">to identify the number of unique items,
    customers, and invoices – for example, by</st> <st c="7808">executing</st> `<st
    c="7818">df["customer_id"].nunique()</st>`<st c="7845">.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7694">使用</st> `<st c="7699">pandas</st>`<st c="7705">’</st> `<st c="7708">unique()</st>`
    <st c="7716">函数</st> <st c="7726">来识别独特项目、客户和发票的数量 – 例如，通过</st> <st c="7808">执行</st>
    `<st c="7818">df["customer_id"].nunique()</st>`<st c="7845">.</st>
- en: <st c="7846">Let’s initialize an entity set with an arbitrary name, such</st>
    <st c="7907">as</st> `<st c="7910">data</st>`<st c="7914">:</st>
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7846">让我们用一个任意的名称初始化一个实体集，例如</st> <st c="7907">如下</st> `<st c="7910">data</st>`<st
    c="7914">:</st>
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="7945">Let’s add a DataFrame to the entity set; we give the DataFrame
    a name (</st>`<st c="8017">data</st>`<st c="8022">).</st> <st c="8026">We need
    to add a unique identifier for each row, which we call</st> `<st c="8089">rows</st>`<st
    c="8093">, and since we do not have a unique row identifier in this dataset, we
    will create it as an additional column by setting</st> `<st c="8214">make_index=True</st>`<st
    c="8229">. Finally, we indicate that</st> `<st c="8257">invoice_date</st>` <st
    c="8269">is of the</st> `<st c="8280">datetime</st>` <st c="8288">type and</st>
    `<st c="8298">customer_id</st>` <st c="8309">should be handled</st> <st c="8328">as</st>
    `<st c="8331">Categorical</st>`<st c="8342">:</st>
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7945">让我们向实体集添加一个 DataFrame；我们给 DataFrame 起个名字（</st>`<st c="8017">data</st>`<st
    c="8022">）。</st> <st c="8026">我们需要为每一行添加一个唯一标识符，我们称之为</st> `<st c="8089">rows</st>`<st
    c="8093">，由于在这个数据集中我们没有唯一的行标识符，我们将通过设置</st> `<st c="8214">make_index=True</st>`<st
    c="8229">创建它作为额外的列。最后，我们指出</st> `<st c="8257">invoice_date</st>` <st c="8269">是</st>
    `<st c="8280">datetime</st>` <st c="8288">类型，并且</st> `<st c="8298">customer_id</st>`
    <st c="8309">应该被处理</st> <st c="8328">为</st> `<st c="8331">Categorical</st>`<st
    c="8342">类型：</st>
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="8509">Ne</st><st c="8512">xt, we add</st> <st c="8524">the relationship
    between the original</st> `<st c="8562">data</st>` <st c="8566">DataFrame</st>
    <st c="8577">and</st> `<st c="8581">invoices</st>`<st c="8589">. To do this, we
    indicate the original or base DataFram</st><st c="8644">e, which we called</st>
    `<st c="8664">data</st>` <st c="8668">in</st> *<st c="8672">step 4</st>*<st c="8678">,
    we give the new DataFrame a name,</st> `<st c="8714">invoices</st>`<st c="8722">,
    we add the unique identifier for invoices, and we add the column containing</st>
    `<st c="8800">customer_id</st>` <st c="8811">to</st> <st c="8815">this DataFrame:</st>
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8509">接下来，我们添加原始</st><st c="8512">数据</st> <st c="8516">DataFrame</st>
    <st c="8521">和</st> `<st c="8562">invoices</st>`<st c="8566">之间的关系。为此，我们指出原始或基础
    DataFrame，我们在</st> *<st c="8672">步骤 4</st>*<st c="8678">中称之为</st> `<st c="8664">data</st>`
    <st c="8668">，我们给新的 DataFrame 起个名字，</st> `<st c="8714">invoices</st>`<st c="8722">，我们添加发票的唯一标识符，并将包含</st>
    `<st c="8800">customer_id</st>` <st c="8811">的列添加到这个 DataFrame 中：</st>
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="8962">Note</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8962">注意</st>
- en: <st c="8967">We copy the</st> `<st c="8980">customer_id</st>` <st c="8991">variable
    to the</st> `<st c="9008">invoices</st>` <st c="9016">data because we want to
    create a subsequent relationship between customers</st> <st c="9092">and invoices.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8967">我们将</st> `<st c="8980">customer_id</st>` <st c="8991">变量复制到</st>
    `<st c="9008">invoices</st>` <st c="9016">数据中，因为我们想创建客户和发票之间的后续关系。</st> <st c="9092">。</st>
- en: <st c="9105">Now, we add a second relationship, which is between customers and
    invoices.</st> <st c="9182">To do this, we indicate the base DataFrame, which
    we named</st> `<st c="9241">invoices</st>` <st c="9249">in</st> *<st c="9253">step
    5</st>*<st c="9259">, then we give the new DataFrame a name,</st> `<st c="9300">customers</st>`<st
    c="9309">, and add the unique</st> <st c="9330">customer identifier:</st>
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9105">现在，我们添加第二个关系，即客户和发票之间的关系。</st> <st c="9182">为此，我们指出基础 DataFrame，我们在</st>
    *<st c="9253">步骤 5</st>*<st c="9259">中称之为</st> `<st c="9241">invoices</st>` <st
    c="9249">，然后我们给新的 DataFrame 起个名字，</st> `<st c="9300">customers</st>`<st c="9309">，并添加唯一的</st>
    <st c="9330">客户标识符：</st>
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="9461">We can</st> <st c="9468">add a third rel</st><st c="9483">ationship
    between the original</st> <st c="9515">data and</st> <st c="9524">the products:</st>
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9461">我们可以</st> <st c="9468">添加一个第三种关系，在原始</st><st c="9483">数据</st> <st
    c="9515">和</st> <st c="9524">产品</st> <st c="9529">之间：</st>
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="9639">Let’s display the information in the</st> <st c="9677">entity set:</st>
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9639">让我们显示实体集中的信息：</st> <st c="9677">实体集：</st>
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<st c="9691">In the following output, we see that the entity set contains four
    DataFrames: the original data, the</st> `<st c="9793">invoices</st>` <st c="9801">DataFrame,
    the</st> `<st c="9817">customers</st>` <st c="9826">DataFrame, and the product
    or</st> `<st c="9857">items</st>` <st c="9862">DataFrame.</st> <st c="9874">The
    entity also contains the relationships between invoices or items with the original
    data, as well as between customers</st> <st c="9996">and invoices:</st>'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="9691">在以下输出中，我们看到实体集包含四个 DataFrame：原始数据，</st> `<st c="9793">invoices</st>`
    <st c="9801">DataFrame，</st> `<st c="9817">customers</st>` <st c="9826">DataFrame，以及产品或</st>
    `<st c="9857">items</st>` <st c="9862">DataFrame。</st> <st c="9874">实体还包含发票或项目与原始数据之间的关系，以及客户</st>
    <st c="9996">和发票</st> <st c="9999">之间的关系：</st>
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: es["invoices"].head()
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: es["invoices"].head()
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Figure 9.3 – DataFrame with information at the invoice level](img/B22396_09_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 发票级别的信息 DataFrame](img/B22396_09_03.jpg)'
- en: <st c="10830">Figure 9.3 – DataFrame with information at the invoice level</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10830">图 9.3 – 发票级别的信息 DataFrame</st>
- en: <st c="10890">Let’s now display the</st> `<st c="10913">customers</st>` <st
    c="10922">DataFrame:</st>
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10890">现在让我们显示</st> `<st c="10913">客户</st>` <st c="10922">DataFrame：</st>
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="10956">We can see in the following output that</st> `<st c="10997">featuretools</st>`
    <st c="11009">automatically created a DataFrame containing the customer’s unique
    identifier, followed by the date of the first invoice for</st> <st c="11135">this</st>
    <st c="11139">customer:</st>
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10956">在以下输出中，我们可以看到</st> `<st c="10997">featuretools</st>` <st c="11009">自动创建了一个包含客户唯一标识符的DataFrame，随后是此客户的首次发票日期：</st>
- en: '![Figure 9.4 – DataFrame with information at the customer level](img/B22396_09_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 客户级别的信息DataFrame](img/B22396_09_04.jpg)'
- en: <st c="11362">Figure 9.4 – DataFrame with information at the customer level</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11362">图9.4 – 客户级别的信息DataFrame</st>
- en: <st c="11423">Note</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11423">注意</st>
- en: <st c="11428">Go ahead and display the DataFrame containing the products by
    executing</st> `<st c="11501">es["items"].head()</st>`<st c="11519">. You can
    also evaluate the size of the different DataFrames using</st> `<st c="11586">pandas</st>`<st
    c="11592">’</st> `<st c="11595">shape</st>` <st c="11600">function.</st> <st c="11611">You
    will notice that the number of rows in each DataFrame coincides with the number
    of unique invoices, customers,</st> <st c="11726">and produc</st><st c="11736">ts.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11428">执行</st> `<st c="11501">es["items"].head()</st>` <st c="11519">来显示包含产品的DataFrame。您还可以使用</st>
    `<st c="11586">pandas</st>` <st c="11592">的</st> `<st c="11595">shape</st>` <st
    c="11600">函数来评估不同DataFrame的大小。</st> <st c="11611">您将注意到每个DataFrame中的行数与唯一发票、客户和产品的数量相匹配。</st>
- en: <st c="11740">We can</st> <st c="11748">also display the re</st><st c="11767">lationships
    between these data</st> <st c="11799">tables</st> <st c="11806">as follows:</st>
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11740">我们还可以以下方式显示这些数据表之间的</st> <st c="11748">关系：</st>
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="11827">Note</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11827">注意</st>
- en: <st c="11832">To visualize the data relationships, you need to have</st> `<st
    c="11887">graphviz</st>` <st c="11895">installed.</st> <st c="11907">If you don’t,
    follow the</st> <st c="11932">instructions in the</st> `<st c="11952">featuretools</st>`
    <st c="11964">documentation to install</st> <st c="11990">it:</st> [<st c="11994">https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz</st>](https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz)<st
    c="12069">.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11832">为了可视化数据关系，您需要安装</st> `<st c="11887">graphviz</st>` <st c="11895">。如果您还没有安装，请按照</st>
    <st c="11907">featuretools</st> <st c="11964">文档中的说明进行安装：</st> [<st c="11994">https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz</st>](https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz)<st
    c="12069">。</st>
- en: <st c="12070">In the following output, we can see the relational datasets and</st>
    <st c="12135">their re</st><st c="12143">lationships:</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12070">在以下输出中，我们可以看到关系数据集及其</st> <st c="12135">关系：</st>
- en: '![Figure 9.5 – Relationships between the tables containing invoices, customers,
    and products](img/B22396_09_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 包含发票、客户和产品表的表之间的关系](img/B22396_09_05.jpg)'
- en: <st c="12733">Figure 9.5 – Relationships between the tables containing invoices,
    customers, and products</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12733">图9.5 – 包含发票、客户和产品表的表之间的关系</st>
- en: <st c="12823">Af</st><st c="12826">ter entering</st> <st c="12840">the data
    and their relationships,</st> <st c="12873">we can start</st> <st c="12887">automatically
    creating features for each one of our new DataFrames – that is, customers, invoices,
    and products – using the default parameters</st> <st c="13030">from</st> `<st
    c="13035">featuretools</st>`<st c="13047">.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12823">在输入</st> <st c="12826">数据和它们的关系</st> <st c="12840">后，我们可以开始</st>
    <st c="12873">自动为我们的新DataFrame中的每一个创建特征——即客户、发票和产品——使用来自</st> `<st c="13035">featuretools</st>`
    <st c="13047">的默认参数。</st>
- en: <st c="13048">Let’s create</st> <st c="13062">features by aggregating the data
    at the customer level.</st> <st c="13118">To do this, we set up the</st> `<st
    c="13185">featuretools</st>`<st c="13197">, indicating</st> `<st c="13210">customers</st>`
    <st c="13219">as the target DataFrame.</st> <st c="13245">When creating features,
    we want to ignore the two columns with</st> <st c="13308">unique identifiers:</st>
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13048">让我们通过聚合客户级别的数据来创建特征。</st> <st c="13062">为此，我们设置了</st> `<st c="13185">featuretools</st>`
    <st c="13197">，将</st> `<st c="13210">客户</st>` <st c="13219">指定为目标DataFrame。</st>
    <st c="13245">在创建特征时，我们希望忽略具有唯一标识符的两个列：</st>
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="13488">Note</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13488">注意</st>
- en: <st c="13493">The command from</st> *<st c="13511">step 12</st>* <st c="13518">triggered
    the creation of 114 features with different aggregations of data at the customer
    level.</st> <st c="13617">The</st> `<st c="13621">feature_matrix</st>` <st c="13635">variable
    is a DataFrame with the feature values, and</st> `<st c="13689">feature_defs</st>`
    <st c="13701">is a list with the names of the new features.</st> <st c="13748">Go
    ahead and execute</st> `<st c="13769">feature_defs</st>` <st c="13781">or visit
    our accompanying GitHub repository (</st>[<st c="13827">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb)<st
    c="13981">) to check the names of the created features.</st> <st c="14028">You
    will find more details about these features in the</st> *<st c="14083">How it</st>*
    *<st c="14090">works…</st>* <st c="14096">section.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13493">来自</st><st c="13511">*<st c="13518">步骤12</st>* <st c="13518">的命令触发了在客户级别对数据进行不同聚合的114个特征的创建。</st><st
    c="13617">`<st c="13621">feature_matrix</st>` <st c="13635">变量是一个包含特征值的DataFrame，而`<st
    c="13689">feature_defs</st>` <st c="13701">是一个包含新特征名称的列表。</st><st c="13748">请继续执行`<st
    c="13769">feature_defs</st>` <st c="13781">或访问我们的配套GitHub仓库（</st>[<st c="13827">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb)<st
    c="13981">）以检查创建的特征名称。</st><st c="14028">您将在*<st c="14083">它如何工作…</st>* <st c="14090">部分中找到更多关于这些特征的信息。</st>
- en: <st c="14105">For reasons</st> <st c="14118">of space, we can’t print out all
    the features</st> <st c="14164">in the</st> <st c="14171">book, so instead, let’s
    display the nam</st><st c="14210">es of five of the</st> <st c="14229">created
    features:</st>
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14105">由于篇幅原因，我们无法在书中打印出所有特征</st><st c="14118">，因此，让我们显示五个</st><st c="14210">创建特征的</st><st
    c="14229">名称：</st>
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="14265">In the following output, we see 5 of the 114 features created</st>
    <st c="14328">by</st> `<st c="14331">featuretools</st>`<st c="14343">:</st>
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="14265">在以下输出中，我们看到由</st><st c="14328">`<st c="14331">featuretools</st>`<st
    c="14343">`</st><st c="14328">创建的114个特征中的5个</st>：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="14511">Note</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14511">注意</st>
- en: <st c="14516">The</st> `<st c="14521">featuretools</st>` <st c="14533">library
    names the new features with the function used to create them, followed by the
    DataFrame that was used to perform the aggregation, followed by the aggregated
    variable name.</st> <st c="14714">Thus,</st> `<st c="14720">MIN(data.quantity)</st>`
    <st c="14738">is equivalent to</st> `<st c="14756">df.groupby(["customer_id"])["quantity"].min()</st>`<st
    c="14801">, if you are familiar with</st> `<st c="14828">pandas</st>`<st c="14834">.
    We will give more details in the</st> *<st c="14869">How it</st>* *<st c="14876">works…</st>*
    <st c="14882">secti</st><st c="14888">on.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14516">`<st c="14521">featuretools</st>` <st c="14533">库使用创建它们的函数来命名新特征，然后是用于执行聚合的DataFrame，最后是聚合变量的名称。</st><st
    c="14714">因此，`<st c="14720">MIN(data.quantity)</st>` <st c="14738">与`<st c="14756">df.groupby(["customer_id"])["quantity"].min()</st>`<st
    c="14801">等价，如果您熟悉`<st c="14828">pandas</st>`<st c="14834">。我们将在*<st c="14869">它如何工作…</st>*
    <st c="14876">部分中提供更多详细信息。</st>
- en: <st c="14892">Let’s display the first five rows of the Dat</st><st c="14937">aFrame
    containing five of the</st> <st c="14968">created features:</st>
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14892">让我们显示包含五个</st><st c="14937">创建特征的</st><st c="14968">DataFrame的前五行：</st>
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="15037">In the</st> <st c="15045">following output, we can see the first
    five rows</st> <st c="15094">containing the values of the</st> <st c="15123">five</st>
    <st c="15128">new features:</st>
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15037">在以下输出中，我们可以看到包含五个</st><st c="15094">新特征值的</st><st c="15123">五个</st><st
    c="15128">新特征的前五行：</st>
- en: '![Figure 9.6 – DataFrame with five features created by aggregating the data
    at the customer level](img/B22396_09_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 通过在客户级别聚合数据创建的具有五个特征的DataFrame](img/B22396_09_06.jpg)'
- en: <st c="15542">Figure 9.6 – DataFrame with five features created by aggregating
    the data at the customer level</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15542">图9.6 – 通过在客户级别聚合数据创建的具有五个特征的DataFrame</st>
- en: <st c="15637">Similarly, we can create features automatically by aggregating
    information at the</st> <st c="15720">invoice level:</st>
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="15637">同样，我们可以通过在</st><st c="15720">发票级别聚合信息来自动创建特征：</st>
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="15882">The previous step returns 24 features – let’s display</st> <st
    c="15937">their names:</st>
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="15882">上一步返回了24个特征 - 让我们显示它们的名称：</st>
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="15962">We can see the names of the features in the</st> <st c="16007">following
    output:</st>
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15962">我们可以在以下输出中看到特征的名称：</st> <st c="16007">如下：</st>
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="16700">Note</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16700">注意</st>
- en: <st c="16705">Go ahead and display the DataFrame containing the new features
    by executing</st> `<st c="16782">feature_matrix.head()</st>` <st c="16803">or
    check our accompanying GitHub repository for</st> <st c="16852">the result.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16705">通过执行`<st c="16782">feature_matrix.head()</st>` <st c="16803">来显示包含新特征的DataFrame，或者检查我们附带的GitHub仓库以查看结果。</st>
- en: <st c="16863">To</st> <st c="16866">wrap up, by using the code from</st> *<st
    c="16899">step 1</st><st c="16905">6</st>* <st c="16907">and changing the target
    DataFrame name from</st> `<st c="16952">invoices</st>` <st c="16960">to</st> `<st
    c="16964">items</st>`<st c="16969">, go ahead and create features automatically
    at</st> <st c="17017">the</st> <st c="17021">product level.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16863">总结一下，通过使用*<st c="16899">步骤 1</st><st c="16905">6</st>* <st c="16907">中的代码，并将目标DataFrame的名称从`<st
    c="16952">invoices</st>` <st c="16960">更改为`<st c="16964">items</st>`<st c="16969">，然后在产品级别自动创建特征。</st>
- en: <st c="17035">How it works...</st>
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17035">它是如何工作的...</st>
- en: <st c="17051">In this recipe, we set up an entity set containing the data and
    the relationships between some of</st> <st c="17150">its variables (unique identifiers).</st>
    <st c="17186">After that, we automatically</st> <st c="17215">created features
    by aggregating the information in the dataset for each of the unique identifiers.</st>
    <st c="17314">We used two main classes from</st> `<st c="17344">featuretools</st>`<st
    c="17356">,</st> `<st c="17358">EntitySet</st>` <st c="17367">and</st> `<st c="17372">dfs</st>`<st
    c="17375">, to create the features.</st> <st c="17401">Let’s discuss each of these
    in</st> <st c="17432">more detail.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17051">在这个菜谱中，我们设置了一个包含数据和某些变量（唯一标识符）之间关系的实体集。</st> <st c="17150">之后，我们通过聚合每个唯一标识符的数据集中的信息来自动创建特征。</st>
    <st c="17186">我们使用了`<st c="17344">featuretools</st>`<st c="17356">中的两个主要类，`<st
    c="17358">EntitySet</st>` <st c="17367">和`<st c="17372">dfs</st>`<st c="17375">，来创建特征。</st>
    <st c="17401">让我们更详细地讨论这些。</st>
- en: <st c="17444">The</st> `<st c="17449">EntitySet</st>` <st c="17458">class stores</st>
    <st c="17472">the data, the logical types of the variables, and the relationships
    between the variables.</st> <st c="17563">The variable types (whether numeric
    or categorical) are automatically assigned by</st> `<st c="17645">featuretools</st>`<st
    c="17657">. We can also set up specific variable types when adding a DataFrame
    to the entity set.</st> <st c="17745">In</st> *<st c="17748">step 4</st>*<st c="17754">,
    we added the data to the entity set and set the logical type of</st> `<st c="17820">customer_id</st>`
    <st c="17831">to</st> `<st c="17835">Categorical</st>`<st c="17846">.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17444">`<st c="17449">EntitySet</st>` <st c="17458">类存储了数据，变量的逻辑类型以及变量之间的关系。</st>
    <st c="17563">变量类型（是否为数值或分类）由`<st c="17645">featuretools</st>`<st c="17657">自动分配。我们也可以在将DataFrame添加到实体集时设置特定的变量类型。</st>
    <st c="17745">在*<st c="17748">步骤 4</st>*<st c="17754">中，我们将数据添加到实体集，并将`<st c="17820">customer_id</st>`
    <st c="17831">的逻辑类型设置为`<st c="17835">Categorical</st>`<st c="17846">。</st>
- en: <st c="17847">Note</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17847">注意</st>
- en: <st c="17852">To inspect the datatypes inferred by</st> `<st c="17890">featuretools</st>`<st
    c="17902">, you can execute</st> `<st c="17920">es["data"].ww</st>`<st c="17933">,
    where</st> `<st c="17941">es</st>` <st c="17943">is the entity set and</st> `<st
    c="17966">data</st>` <st c="17970">is the name of</st> <st c="17986">the DataFrame.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17852">要检查`<st c="17890">featuretools</st>`<st c="17902">推断的数据类型，可以执行`<st
    c="17920">es["data"].ww</st>`<st c="17933">，其中`<st c="17941">es</st>` <st c="17943">是实体集，`<st
    c="17966">data</st>` <st c="17970">是DataFrame的名称。</st>
- en: <st c="18000">The</st> `<st c="18005">EntitySet</st>` <st c="18014">class has
    the</st> `<st c="18029">add_dataframe</st>` <st c="18042">method, which we used
    in</st> *<st c="18068">step 4</st>* <st c="18074">to add a new DataFrame.</st>
    <st c="18099">When using this method, we need to specify the unique identifier,
    and if there is none, then we need to create one, as we did in</st> *<st c="18228">step
    4</st>*<st c="18234">, by setting</st> `<st c="18247">make_index</st>` <st c="18257">to</st>
    `<st c="18261">True</st>`<st c="18265">. Note that in the</st> `<st c="18284">index</st>`
    <st c="18289">parameter from</st> `<st c="18305">add_dataframe</st>`<st c="18318">,
    we passed the</st> `<st c="18334">"rows"</st>` <st c="18340">string.</st> <st
    c="18349">With this configuration,</st> `<st c="18374">EntitySet</st>` <st c="18383">added
    a</st> `<st c="18392">rows</st>` <st c="18396">column containing the unique identifier
    for each row to the DataFrame, which is a new sequence of integers starting</st>
    <st c="18513">at 0.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18000">The</st>` `<st c="18005">EntitySet</st>` `<st c="18014">类具有</st>`
    `<st c="18029">add_dataframe</st>` `<st c="18042">方法，我们在</st> *<st c="18068">步骤
    4</st>* `<st c="18074">中使用了该方法来添加一个新的 DataFrame。</st> `<st c="18099">在使用此方法时，我们需要指定唯一标识符，如果没有，则需要创建一个，就像我们在</st>
    *<st c="18228">步骤 4</st>* `<st c="18234">中做的那样，通过将</st> `<st c="18247">make_index</st>`
    `<st c="18257">设置为</st> `<st c="18261">True</st>` `<st c="18265">。</st>` `<st
    c="18284">注意</st>` 在 `<st c="18289">index</st>` `<st c="18294">参数中，从</st> `<st
    c="18305">add_dataframe</st>` `<st c="18318">传递了</st> `<st c="18334">"rows"</st>`
    `<st c="18340">字符串。</st>` `<st c="18349">使用此配置，</st>` `<st c="18374">EntitySet</st>`
    `<st c="18383">向 DataFrame 添加了一个</st> `<st c="18392">rows</st>` `<st c="18396">列，其中包含每行的唯一标识符，这是一个从
    0 开始的新整数序列。</st>`'
- en: <st c="18518">Note</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18518">注意</st>`'
- en: <st c="18523">Instead of using the</st> `<st c="18545">add_dataframe</st>` <st
    c="18558">method to add a DataFrame to an entity set, we can add it by executing</st>
    `<st c="18630">es["df_name"]=df</st>`<st c="18646">, where</st> `<st c="18654">"df_name"</st>`
    <st c="18663">is the name we want to give to the DataFrame and</st> `<st c="18713">df</st>`
    <st c="18715">is the DataFrame we want</st> <st c="18741">to add.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18523">而不是使用</st>` `<st c="18545">add_dataframe</st>` `<st c="18558">方法将
    DataFrame 添加到实体集中，我们可以通过执行</st>` `<st c="18630">es["df_name"]=df</st>` `<st c="18646">来添加，其中</st>`
    `<st c="18654">"df_name"</st>` `<st c="18663">是我们想要给 DataFrame 的名字，</st>` `<st
    c="18713">df</st>` `<st c="18715">是我们想要</st>` `<st c="18741">添加的 DataFrame。</st>`'
- en: <st c="18748">The</st> `<st c="18753">EntitySet</st>` <st c="18762">class has
    the</st> `<st c="18777">normalize_dataframe</st>` <st c="18796">method, which
    is used to create a new DataFrame and relationship from the unique values of an
    existing column.</st> <st c="18907">The method takes the name of the DataFrame
    to which the new DataFrame will be related and</st> <st c="18998">a name for the
    new DataFrame.</st> <st c="19028">We</st> <st c="19030">also need to indicate
    the</st> <st c="19057">unique identifier for the new DataFrame in the</st> `<st
    c="19104">index</st>` <st c="19109">parameter.</st> <st c="19121">By default,
    this method creates a new DataFrame containing the unique identifier, followed
    by a</st> `<st c="19217">datetime</st>` <st c="19225">column containing the first
    date each unique identifier was registered.</st> <st c="19298">We can add more
    columns to this DataFrame by using the</st> `<st c="19353">copy_columns</st>`
    <st c="19365">parameters, as we did in</st> *<st c="19391">step 5</st>*<st c="19397">.
    Adding more columns to the new DataFrame is useful if we want to follow up with
    relationships to this new DataFrame, as we did in</st> *<st c="19529">step 6</st>*<st
    c="19535">.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18748">EntitySet</st>` `<st c="18753">类具有</st>` `<st c="18777">normalize_dataframe</st>`
    `<st c="18796">方法，该方法用于从现有列的唯一值创建一个新的 DataFrame 和关系。</st>` `<st c="18907">该方法接受新
    DataFrame 将关联的 DataFrame 的名称以及</st>` `<st c="18998">新 DataFrame 的名称。</st>` `<st
    c="19028">我们</st>` `<st c="19030">还需要在</st>` `<st c="19057">index</st>` `<st c="19062">参数中指示新
    DataFrame 的唯一标识符。</st>` `<st c="19121">默认情况下，此方法创建一个包含唯一标识符的新 DataFrame，后面跟着一个</st>`
    `<st c="19217">datetime</st>` `<st c="19225">列，包含每个唯一标识符首次注册的日期。</st>` `<st c="19298">我们可以通过使用</st>`
    `<st c="19353">copy_columns</st>` `<st c="19365">参数来向此 DataFrame 添加更多列，就像我们在</st>`
    *<st c="19391">步骤 5</st>* `<st c="19397">中做的那样。</st>` `<st c="19391">添加更多列到新 DataFrame
    对于我们想要跟踪与此新 DataFrame 的关系是有用的，就像我们在</st>` *<st c="19529">步骤 6</st>* `<st c="19535">中做的那样。</st>`'
- en: <st c="19536">The</st> `<st c="19541">EntitySet</st>` <st c="19550">class also
    has the</st> `<st c="19570">plot()</st>` <st c="19576">method, which displays
    existing relationships in the entity set.</st> <st c="19642">In</st> *<st c="19645">Figure
    9</st>**<st c="19653">.5</st>*<st c="19655">, we saw the relationships between
    our data tables; the</st> `<st c="19711">invoices</st>` <st c="19719">and</st>
    `<st c="19724">items</st>` <st c="19729">(products) tables were related to the
    original data, whereas the</st> `<st c="19795">customers</st>` <st c="19804">table
    was related to the</st> `<st c="19830">invoices</st>` <st c="19838">table, which
    was, in turn, related to the</st> <st c="19881">original data.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19536">`<st c="19541">实体集</st>` <st c="19550">类还具有</st> `<st c="19570">plot()</st>`
    <st c="19576">方法，该方法显示实体集中的现有关系。</st> <st c="19642">在</st> *<st c="19645">图9.5</st>**<st
    c="19653">中，</st> `<st c="19655">我们看到了我们的数据表之间的关系；</st> `<st c="19711">发票</st>`
    <st c="19719">和</st> `<st c="19724">项目</st>` <st c="19729">(产品) 表与原始数据相关，而</st>
    `<st c="19795">客户</st>` <st c="19804">表与</st> `<st c="19830">发票</st>` <st c="19838">表相关，该表反过来又与</st>
    <st c="19881">原始数据</st> <st c="19881">相关。</st>
- en: <st c="19895">Note</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19895">注意</st>
- en: <st c="19900">The relationship between the tables dictates how features will
    be created.</st> <st c="19976">The</st> `<st c="19980">invoices</st>` <st c="19988">and</st>
    `<st c="19993">items</st>` <st c="19998">tables are related to the original data.</st>
    <st c="20040">Thus, we can only create features with depth 1\.</st> <st c="20088">The</st>
    `<st c="20092">customers</st>` <st c="20101">table is, on the other hand, related
    to invoices, which is related to data.</st> <st c="20178">Thus, we can create
    features with depth 2\.</st> <st c="20221">That means that new features will consist
    of aggregations from the entire dataset or aggregations for invoices first, which
    will then be subsequently aggregated for customers.</st> <st c="20397">We can
    regulate the features to create with the</st> `<st c="20445">max_depth</st>` <st
    c="20454">parameter</st> <st c="20465">in</st> `<st c="20468">dfs</st>`<st c="20471">.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19900">表之间的关系决定了如何创建特征。</st> <st c="19976">《</st> `<st c="19980">发票</st>`
    <st c="19988">和</st> `<st c="19993">项目</st>` <st c="19998">表与原始数据相关。</st> <st
    c="20040">因此，我们只能创建深度为1的特征。</st> <st c="20088">另一方面，</st> `<st c="20092">客户</st>`
    <st c="20101">表与发票相关，而发票与数据相关。</st> <st c="20178">因此，我们可以创建深度为2的特征。</st> <st c="20221">这意味着新特征将包括整个数据集的聚合或首先对发票进行聚合，然后对客户进行后续聚合。</st>
    <st c="20397">我们可以使用</st> `<st c="20445">max_depth</st>` <st c="20454">参数</st>
    <st c="20465">在</st> `<st c="20468">dfs</st>`<st c="20471">中</st>来调整要创建的特征。</st>
- en: <st c="20472">After setting up the data and the relationships, we used</st>
    `<st c="20530">dfs</st>` <st c="20533">from</st> `<st c="20539">featuretools</st>`
    <st c="20551">to automatically create features.</st> <st c="20586">When creating
    features with</st> `<st c="20614">dfs</st>`<st c="20617">, we need to set the
    target DataFrame – that is, the data table for which the features should be created.</st>
    <st c="20723">The</st> `<st c="20727">dfs</st>` <st c="20730">class creates features
    by</st> *<st c="20757">transforming</st>* <st c="20769">and</st> *<st c="20774">aggregating</st>*
    <st c="20785">existing variables, through what are called</st> **<st c="20830">transform</st>**
    <st c="20839">and</st> **<st c="20844">aggregate</st> <st c="20854">primitives</st>**<st
    c="20864">.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20472">在设置数据和关系之后，我们使用了</st> `<st c="20530">dfs</st>` <st c="20533">从</st>
    `<st c="20539">featuretools</st>` <st c="20551">来自动创建特征。</st> <st c="20586">在创建特征时使用</st>
    `<st c="20614">dfs</st>`<st c="20617">，我们需要设置目标DataFrame - 即为创建特征的数据表。</st> <st
    c="20723">`<st c="20727">dfs</st>` <st c="20730">类通过</st> *<st c="20757">转换</st>*
    <st c="20769">和</st> *<st c="20774">聚合</st> <st c="20785">现有变量，通过所谓的</st> **<st
    c="20830">转换</st>** <st c="20839">和</st> **<st c="20844">聚合</st> <st c="20854">原始操作</st>**<st
    c="20864">来创建特征。</st>
- en: <st c="20865">A transform</st> <st c="20878">primitive transforms variables.</st>
    <st c="20910">For example, from datetime variables, using a transform primitive,</st>
    `<st c="20977">dfs</st>` <st c="20980">extracts the</st> `<st c="20994">month</st>`<st
    c="20999">,</st> `<st c="21001">year</st>`<st c="21005">,</st> `<st c="21007">day</st>`<st
    c="21010">, and</st> `<st c="21016">week</st>` <st c="21020">values</st><st c="21027">.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20865">一个转换</st> <st c="20878">原始转换变量。</st> <st c="20910">例如，从日期时间变量，使用转换原始操作，</st>
    `<st c="20977">dfs</st>` <st c="20980">提取</st> `<st c="20994">月份</st>`<st c="20999">，</st>
    `<st c="21001">年份</st>`<st c="21005">，</st> `<st c="21007">日</st>`<st c="21010">，和</st>
    `<st c="21016">周</st>` <st c="21020">值</st><st c="21027">。</st>
- en: <st c="21028">An aggregate</st> <st c="21042">primitive aggregates information
    for a unique identifier.</st> <st c="21100">It uses mathematical operations such
    as the mean, standard deviation, maximum and minimum values, the sum, and the
    skew coefficient for numerical variables.</st> <st c="21257">For categorical variables,
    aggregate primitives u</st><st c="21306">se the mode and the count of</st> <st
    c="21335">unique items.</st> <st c="21350">For unique identifiers, they count
    the number</st> <st c="21396">of occurrences.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21028">聚合原语</st> <st c="21042">用于对唯一标识符的信息进行聚合。</st> <st c="21100">它使用数学运算，如均值、标准差、最大值和最小值、总和以及偏度系数来处理数值变量。</st>
    <st c="21257">对于分类变量，聚合原语使用众数和唯一项的计数。</st> <st c="21306">对于唯一标识符，它们计算出现的次数。</st>
- en: <st c="21411">With the functionality of transform and aggregate primitives in
    mind, let’s try to understand the features that we created in this recipe.</st>
    <st c="21551">We used the default parameters of</st> `<st c="21585">dfs</st>`
    <st c="21588">to create the</st> <st c="21603">default features.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到转换和聚合原语的功能，让我们尝试理解在这个菜谱中创建的特性。<st c="21551">我们使用了</st> `<st c="21585">dfs</st>`
    <st c="21588">的默认参数来创建</st> `<st c="21603">默认特性</st>。</st>
- en: <st c="21620">Note</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21620">注意</st>
- en: <st c="21625">For more details on the default features returned by</st> `<st
    c="21679">featuretools</st>`<st c="21691">,</st> <st c="21693">visit</st> [<st
    c="21699">https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs</st>](https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs)<st
    c="21790">.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21625">有关</st> `<st c="21679">featuretools</st>` <st c="21691">返回的默认特性的更多详细信息，请访问</st>
    [<st c="21699">https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs</st>](https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs)<st
    c="21790">。</st>
- en: <st c="21791">We first</st> <st c="21801">created features for each customer.</st>
    `<st c="21837">featuretools</st>` <st c="21849">returned 114 features for each
    customer.</st> <st c="21891">Because the</st> `<st c="21903">customers</st>` <st
    c="21912">data is related to the</st> `<st c="21936">invoices</st>` <st c="21944">data,
    which is related to the entire dataset, the</st> <st c="21995">features were created
    by aggregating data at two levels.</st> <st c="22052">First, the data was aggregated
    for each customer using the entire dataset.</st> <st c="22127">Next, it was aggregated
    for each invoice first, and then the pre-aggregated data was aggregated again
    for</st> <st c="22233">each customer.</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21791">首先</st> <st c="21801">为每个客户创建了特性。</st> `<st c="21837">featuretools</st>`
    <st c="21849">为每个客户返回了114个特性。</st> <st c="21891">由于</st> `<st c="21903">客户</st>`
    <st c="21912">数据与</st> `<st c="21936">发票</st>` <st c="21944">数据相关，而发票数据又与整个数据集相关，因此</st>
    `<st c="21995">特性是通过在两个级别上聚合数据创建的。</st> <st c="22052">首先，使用整个数据集对每个客户的数据进行了聚合。</st>
    <st c="22127">接下来，首先对每个发票的数据进行了聚合，然后对预聚合的数据再次进行聚合以生成</st> `<st c="22233">每个客户的特性</st>。</st>
- en: <st c="22247">The</st> `<st c="22252">featuretools</st>` <st c="22264">library
    names the new features with the function used to aggregate the data – for example,</st>
    `<st c="22356">COUNT</st>`<st c="22361">,</st> `<st c="22363">MEAN</st>`<st c="22367">,</st>
    `<st c="22369">STD</st>`<st c="22372">, and</st> `<st c="22378">SKEW</st>`<st
    c="22382">, among others.</st> <st c="22398">Next, it uses the data that was used
    for the aggregation and follows it with the variable that was aggregated.</st>
    <st c="22509">For example, the</st> `<st c="22526">MEAN(data.quantity)</st>` <st
    c="22545">feature contains the mean quantity of items bought by the customer calculated
    from the entire dataset, which is the equivalent of</st> `<st c="22676">df.groupby("customer_id"])["quantity"].mean()</st>`<st
    c="22721">, if you are familiar with</st> `<st c="22748">pandas</st>`<st c="22754">.
    On the other hand, the</st> `<st c="22779">MEAN(invoices.MEAN(data.quantity))</st>`
    <st c="22813">feature first takes the mean quantity of items for each invoice
    – that is,</st> `<st c="22889">df.groupby("invoice"])["quantity"].mean()</st>`
    <st c="22930">– and from the resulting series, it takes the mean value, considering
    the invoices for a</st> <st c="23020">particular customer.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22247">The</st> `<st c="22252">featuretools</st>` <st c="22264">库使用用于聚合数据的函数来命名新特征
    – 例如，</st> `<st c="22356">COUNT</st>`<st c="22361">,</st> `<st c="22363">MEAN</st>`<st
    c="22367">,</st> `<st c="22369">STD</st>`<st c="22372">, 和</st> `<st c="22378">SKEW</st>`<st
    c="22382">, 等等。</st> <st c="22398">接下来，它使用用于聚合的数据，并跟随聚合的变量。</st> <st c="22509">例如，</st>
    `<st c="22526">MEAN(data.quantity)</st>` <st c="22545">特征包含从整个数据集中计算出的客户购买物品的平均数量，这相当于</st>
    `<st c="22676">df.groupby("customer_id"])["quantity"].mean()</st>`<st c="22721">，如果你熟悉</st>
    `<st c="22748">pandas</st>`<st c="22754">。另一方面，</st> `<st c="22779">MEAN(invoices.MEAN(data.quantity))</st>`
    <st c="22813">特征首先获取每个发票的物品平均数量 – 即，</st> `<st c="22889">df.groupby("invoice"])["quantity"].mean()</st>`
    <st c="22930"> – 然后从结果序列中获取平均值，考虑特定客户的发票。</st>
- en: <st c="23040">For categorical</st> <st c="23057">features,</st> `<st c="23067">featuretools</st>`
    <st c="23079">determines the mode and</st> <st c="23104">the unique values.</st>
    <st c="23123">For example, from the</st> `<st c="23145">description</st>` <st
    c="23156">variable, we’ve got the</st> `<st c="23181">NUM_UNIQUE(data.description)</st>`
    <st c="23209">and</st> `<st c="23214">MODE(data.descripti</st><st c="23233">on)</st>`
    <st c="23237">features.</st> <st c="23248">The description is just the name of
    the item.</st> <st c="23294">Thus, these features highlight the number of unique
    item</st><st c="23350">s the customer bought and the item the customer bought
    the</st> <st c="23410">most times.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23040">对于分类</st> <st c="23057">特征，</st> `<st c="23067">featuretools</st>`
    <st c="23079">确定众数和</st> <st c="23104">唯一值。</st> <st c="23123">例如，从</st> `<st
    c="23145">description</st>` <st c="23156">变量中，我们得到了</st> `<st c="23181">NUM_UNIQUE(data.description)</st>`
    <st c="23209">和</st> `<st c="23214">MODE(data.descripti</st><st c="23233">on)</st>`
    <st c="23237">特征。</st> <st c="23248">描述只是物品的名称。</st> <st c="23294">因此，这些特征突出了客户购买的独特物品数量和客户购买次数最多的物品。</st>
- en: <st c="23421">Note something interesting</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23421">注意一些有趣的事情</st>
- en: <st c="23448">The</st> `<st c="23453">NUM_UNIQUE(data.description)</st>` <st
    c="23481">and</st> `<st c="23486">MODE(data.description)</st>` <st c="23508">variables
    are numeric after the aggregation of the categorical features.</st> <st c="23582">The</st>
    `<st c="23586">featuretools</st>` <st c="23598">library creates more features
    by using numerical aggregations of these newly created variables.</st> <st c="23695">In
    this way, the</st> `<st c="23712">MAX(invoices.NUM_UNIQUE(data.description)</st>`
    <st c="23753">feature first finds the number of unique items per invoice and then
    returns the maximum from those values for a particular customer, considering all
    the</st> <st c="23907">customer’s invoices.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23448">The</st> `<st c="23453">NUM_UNIQUE(data.description)</st>` <st
    c="23481">和</st> `<st c="23486">MODE(data.description)</st>` <st c="23508">变量在分类特征聚合后是数值型的。</st>
    <st c="23582">The</st> `<st c="23586">featuretools</st>` <st c="23598">库通过使用这些新创建变量的数值聚合来创建更多特征。</st>
    <st c="23695">In this way, the</st> `<st c="23712">MAX(invoices.NUM_UNIQUE(data.description)</st>`
    <st c="23753">feature first finds the number of unique items per invoice and then
    returns the maximum from those values for a particular customer, considering all
    the</st> <st c="23907">customer’s invoices.</st>
- en: <st c="23927">From datetime features,</st> `<st c="23952">featuretools</st>`
    <st c="23964">extracts date components by default.</st> <st c="24002">Remember
    that the</st> `<st c="24020">customers</st>` <st c="24029">DataFrame contains
    the</st> `<st c="24053">customer_id</st>` <st c="24064">variable and the date
    of the first invoice for each customer, as we saw in the output of</st> *<st c="24154">step
    10</st>*<st c="24161">. From this datetime feature,</st> `<st c="24191">featuretools</st>`
    <st c="24203">created</st> `<st c="24212">DAY(first_invoices_time)</st>`<st c="24236">,</st>
    `<st c="24238">MONTH(first_invoices_time)</st>`<st c="24264">,</st> `<st c="24266">WEEKDAY(first_invoices_time)</st>`<st
    c="24294">, and</st> `<st c="24300">YEAR(first_invoices_time)</st>` <st c="24325">features
    containing the different</st> <st c="24360">date parts.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23927">从日期时间特征中，</st> `<st c="23952">featuretools</st>` <st c="23964">默认提取日期组成部分。</st>
    <st c="24002">请记住，</st> `<st c="24020">customers</st>` <st c="24029">DataFrame
    包含了</st> `<st c="24053">customer_id</st>` <st c="24064">变量以及每个客户的首次发票日期，正如我们在</st>
    *<st c="24154">步骤10</st>*<st c="24161">的输出中看到的。</st> 从这个日期时间特征中，</st> `<st c="24191">featuretools</st>`
    <st c="24203">创建了</st> `<st c="24212">DAY(first_invoices_time)</st>`<st c="24236">,</st>
    `<st c="24238">MONTH(first_invoices_time)</st>`<st c="24264">,</st> `<st c="24266">WEEKDAY(first_invoices_time)</st>`<st
    c="24294">, 和</st> `<st c="24300">YEAR(first_invoices_time)</st>` <st c="24325">特征，它们包含了不同的</st>
    <st c="24360">日期部分。</st>
- en: <st c="24371">Finally,</st> `<st c="24381">featuretools</st>` <st c="24393">also
    returned the total number of invoices per customer (</st>`<st c="24451">COUNT(invoices)</st>`<st
    c="24467">) and the total number of row</st><st c="24497">s (</st>`<st c="24501">COUNT(data)</st>`<st
    c="24513">)</st> <st c="24516">per customer.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24371">最后，</st> `<st c="24381">featuretools</st>` <st c="24393">还返回了每个客户的发票总数（</st>`<st
    c="24451">COUNT(invoices)</st>`<st c="24467">)和每客户的行总数（</st>`<st c="24497">COUNT(data)</st>`<st
    c="24501">)</st> <st c="24516">。</st>
- en: <st c="24529">See also</st>
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24529">另请参阅</st>
- en: '<st c="24538">For more details into what inspired</st> `<st c="24575">featuretools</st>`<st
    c="24587">, check the original article</st> *<st c="24616">Deep Feature Synthesis:
    Towards Automating Data Science Endeavors</st>* <st c="24681">by Kanter and Veeramachaneni</st>
    <st c="24711">at</st> [<st c="24714">https://www.jmaxkanter.</st><st c="24737">com/papers/DSAA_DSM_2015.pdf</st>](https://www.jmaxkanter.com/papers/DSAA_DSM_2015.pdf)<st
    c="24766">.</st>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24538">要了解更多关于什么启发了</st> `<st c="24575">featuretools</st>`<st c="24587">的信息，请查看原文</st>
    *<st c="24616">深度特征合成：自动化数据科学努力的途径</st>* <st c="24681">由Kanter和Veeramachaneni所著</st>
    <st c="24711">在</st> [<st c="24714">https://www.jmaxkanter.</st><st c="24737">com/papers/DSAA_DSM_2015.pdf</st>](https://www.jmaxkanter.com/papers/DSAA_DSM_2015.pdf)<st
    c="24766">。</st>
- en: <st c="24767">Creating features with general and cumulative operations</st>
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="24767">使用通用和累积操作创建特征</st>
- en: <st c="24824">The</st> `<st c="24829">f</st><st c="24830">eaturetools</st>`
    <st c="24841">library uses</st> <st c="24855">what are called</st> **<st c="24871">transform
    primitives</st>** <st c="24891">to create features.</st> <st c="24912">Transform
    primitives take one or more columns</st> <st c="24958">i</st><st c="24959">n a
    dataset as input and</st> <st c="24984">return one or more columns as output.</st>
    <st c="25022">They are applied to a</st> *<st c="25044">single</st>* <st c="25050">DataFrame.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24824">The</st> `<st c="24829">f</st><st c="24830">eaturetools</st>`
    <st c="24841">库使用所谓的</st> **<st c="24871">转换原语</st>** <st c="24891">来创建特征。</st>
    <st c="24912">转换原语接受一个或多个数据集的列作为输入，并</st> <st c="24958">i</st><st c="24959">n</st>
    <st c="24984">返回一个或多个列作为输出。</st> <st c="25022">它们应用于一个</st> *<st c="25044">单个</st>
    <st c="25050">DataFrame。</st>
- en: <st c="25061">The</st> `<st c="25066">featuretools</st>` <st c="25078">library
    divides its transform primitives into various categories de</st><st c="25146">pending</st>
    <st c="25155">on the type of operation they perform or the type of variable they
    modify.</st> <st c="25230">For example,</st> **<st c="25243">general transform
    primitives</st>** <st c="25271">apply mathematical operations, such as the square
    root, the sine, and the cosine.</st> **<st c="25354">Cumul</st><st c="25359">ative
    transform primitives</st>** <st c="25386">create new features by comparing a row’s
    value to the</st> <st c="25441">previous row’s value.</st> <st c="25463">For example,
    the cumulative sum, cumulative mean, and cumulative minimum and maximum values
    belong to this category, as well as the difference between row v</st><st c="25619">alues.</st>
    <st c="25627">There is another cumulative transformation that can be applied to
    datetime variables, which is the</st> **<st c="25726">time since previous</st>**
    <st c="25745">transformation, which determines the time passed between two</st>
    <st c="25807">consecutive timestamps.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25061">The</st> `<st c="25066">featuretools</st>` <st c="25078">库根据它们执行的操作类型或修改的变量类型将它的变换原语分为各种类别。</st><st
    c="25146">例如，</st> **<st c="25243">通用变换原语</st>** <st c="25271">应用数学运算，如平方根、正弦和余弦。</st>
    **<st c="25354">累积变换原语</st>** <st c="25386">通过比较一行值与上一行值来创建新特征。</st> <st c="25441">例如，累积总和、累积平均值、累积最小值和最大值以及行值之间的差异都属于这一类别。</st>
    <st c="25463">还有一个可以应用于日期时间变量的累积变换，即</st> **<st c="25726">自上次以来</st>** <st c="25745">变换，它确定两个连续时间戳之间的时间流逝。</st>
- en: <st c="25830">In this recipe, we will create features using the general and
    cumulative trans</st><st c="25909">form primitives</st> <st c="25926">from</st>
    `<st c="25931">featuretools</st>`<st c="25943">.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25830">在这个食谱中，我们将使用来自</st> `<st c="25931">featuretools</st>`<st c="25943">的通用和累积变换原语来创建特征。</st>
- en: <st c="25944">Getting ready</st>
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="25944">准备就绪</st>
- en: <st c="25958">Variable transformations such as the square root or the logarithm
    are useful when we want to change the distribution of a variable, as we saw in</st>
    [*<st c="26104">Chapter 3</st>*](B22396_03.xhtml#_idTextAnchor351)<st c="26113">,</st>
    *<st c="26115">Transforming Numerical Variables</st>*<st c="26147">. Other mathematical
    derivations such as the sine and cosine help to capture underlying data patterns,
    as we described in the</st> *<st c="26273">Creating periodic features from cyclical
    variables</st>* <st c="26323">recipe in</st> [*<st c="26334">Chapter 8</st>*](B22396_08.xhtml#_idTextAnchor987)<st
    c="26343">,</st> *<st c="26345">Creating New Features</st>*<st c="26366">. From
    the transformations described in those chapters,</st> `<st c="26422">featuretools</st>`
    <st c="26434">supports the square root and the logarithm transformation and the
    sine and cosine (but without the normalization between 0</st> <st c="26558">and
    2π).</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25958">变量变换，如平方根或对数变换，在我们想要改变变量的分布时很有用，正如我们在</st> [*<st c="26104">第3章</st>*](B22396_03.xhtml#_idTextAnchor351)<st
    c="26113">,</st> *<st c="26115">变换数值变量</st>*<st c="26147">中看到的。其他数学推导，如正弦和余弦，有助于捕捉潜在的数据模式，正如我们在</st>
    *<st c="26273">从周期性变量创建周期特征</st>* <st c="26323">食谱</st> [*<st c="26334">第8章</st>*](B22396_08.xhtml#_idTextAnchor987)<st
    c="26343">,</st> *<st c="26345">创建新特征</st>*<st c="26366">中描述的。从这些章节中描述的变换中，</st>
    `<st c="26422">featuretools</st>` <st c="26434">支持平方根和对数变换以及正弦和余弦（但不包括在0</st>
    <st c="26558">和2π之间的归一化）。</st>
- en: <st c="26566">With a cumulative transformation, we can, for example, get the
    total number of items bought per invoice by adding up the item’s quantity on each
    row at the invoice level.</st> <st c="26738">To understand the features that we
    will create in this recipe, let’s create them with</st> `<st c="26824">pandas</st>`
    <st c="26830">first:</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26566">使用累积变换，例如，我们可以通过将发票级别的每一行的项目数量加起来来获取每张发票购买的项目总数。</st> <st c="26738">为了理解我们将在这个食谱中创建的特征，让我们先用</st>
    `<st c="26824">pandas</st>` <st c="26830">创建它们：</st>
- en: <st c="26837">Let’s import</st> `<st c="26851">pandas</st>` <st c="26857">and</st>
    `<st c="26862">numpy</st>`<st c="26867">:</st>
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26837">让我们导入</st> `<st c="26851">pandas</st>` <st c="26857">和</st> `<st
    c="26862">numpy</st>`<st c="26867">:</st>
- en: '[PRE21]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="26908">Let’s load the retail dataset described in the</st> *<st c="26956">Technical</st>*
    *<st c="26966">requirements</st>* <st c="26978">section:</st>
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26908">让我们加载在</st> *<st c="26956">技术</st>* *<st c="26966">要求</st>* <st
    c="26978">部分中描述的零售数据集：</st>
- en: '[PRE22]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="27049">Let’s</st> <st c="27056">capture the two numerical variables,</st>
    `<st c="27093">price</st>` <st c="27098">and</st> `<st c="27103">quantity</st>`<st
    c="27111">, in</st> <st c="27116">a list:</st>
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27049">让我们</st> <st c="27056">将两个数值变量，</st> `<st c="27093">价格</st>` <st
    c="27098">和</st> `<st c="27103">数量</st>`<st c="27111">，捕获到一个列表中：</st>
- en: '[PRE23]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="27160">Let’s</st> <st c="27167">capture the names of the cumulative functions
    in</st> <st c="27216">a list:</st>
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27160">让我们</st> <st c="27167">将累积函数的名称捕获到一个列表中：</st>
- en: '[PRE24]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="27260">Let’s create a list with new names for the variables that we</st>
    <st c="27322">will create:</st>
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27260">让我们创建一个包含我们将要创建的变量的新名称的列表：</st>
- en: '[PRE25]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="27414">Let’s create new variables using the cumulative functions from</st>
    *<st c="27478">step 4</st>*<st c="27484">, applied to the variables from</st>
    *<st c="27516">step 3</st>*<st c="27522">, and add them to</st> <st c="27540">the
    DataFrame:</st>
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27414">让我们使用第4步中的累积函数创建新变量，并将其应用到第3步中的变量上，然后将它们添加到DataFrame中：</st>
- en: '[PRE26]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="27617">The previous step returns the cumulative sum, cumulative maximum
    value, and the difference between rows, within each invoice.</st> <st c="27744">As
    soon as it encounters a new invoice number, it</st> <st c="27794">starts afresh.</st>
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27617">上一步返回了每个发票内的累积和、累积最大值以及行之间的差异。</st> <st c="27744">一旦遇到新的发票号码，它</st>
    <st c="27794">就重新开始。</st>
- en: <st c="27808">Let’s display the original and new features for one</st> <st c="27861">particular
    invoice:</st>
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27808">让我们显示一个特定发票的原始和新特征：</st> <st c="27861">：</st>
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="27938">In the following output, we can see that</st> `<st c="27980">quantity_cumsum</st>`
    <st c="27995">is the cumulative sum for the variable quantity and</st> `<st c="28048">price_diff</st>`
    <st c="28058">is the price difference row</st> <st c="28087">after row:</st>
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27938">在以下输出中，我们可以看到</st> `<st c="27980">quantity_cumsum</st>` <st c="27995">是数量变量的累积和，而</st>
    `<st c="28048">price_diff</st>` <st c="28058">是行</st> <st c="28087">之后的行价格差异：</st>
- en: '![Figure 9.7 – DataFrame showing cumulative functions applied to numerical
    features in a single entity (invoice)](img/B22396_09_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 显示对单个实体（发票）中的数值特征应用累积函数的DataFrame](img/B22396_09_07.jpg)'
- en: <st c="28371">Figure 9.7 – DataFrame showing cumulative functions applied to
    numerical features in a single entity (invoice)</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28371">图9.7 – 显示对单个实体（发票）中的数值特征应用累积函数的DataFrame</st>
- en: <st c="28481">Let’s now</st> <st c="28492">apply the sine</st> <st c="28507">and
    cosine transformation to the</st> <st c="28540">entire DataFrame.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28481">现在</st> <st c="28492">将正弦</st> <st c="28507">和余弦变换应用到整个DataFrame。</st>
- en: <st c="28557">Let’s create a list with names for the</st> <st c="28597">new
    variables:</st>
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28557">让我们创建一个包含新变量名称的列表：</st>
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="28701">Let’s transform the price and quantity with the sine</st> <st
    c="28755">and cosine:</st>
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28701">让我们使用正弦</st> <st c="28755">和余弦将价格和数量进行转换：</st>
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="28822">The transformation in</st> *<st c="28845">step 9</st>* <st c="28851">was
    applied to the entire dataset, irrespective of the invoice number, which is fine
    because it maps from o</st><st c="28959">ne row to the same row, as opposed to
    from one row to the next, as with cumulative functions.</st> <st c="29054">You
    can inspect the result by</st> <st c="29084">executing</st> `<st c="29094">df[new_names].head()</st>`<st
    c="29114">.</st>
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28822">第9步中的转换已应用于整个数据集，无论发票号码如何，这是可以的，因为它将一行映射到同一行，而不是像累积函数那样从一行映射到下一行。</st>
    <st c="28959">您可以通过执行`<st c="29094">df[new_names].head()</st>`<st c="29114">来检查结果。</st>
- en: <st c="29115">Now that we understand the types of features we want to create,
    let’s au</st><st c="29188">tomate the process</st> <st c="29208">with</st> `<st
    c="29213">featuretools</st>`<st c="29225">.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29115">现在我们了解了我们想要创建的特征类型，让我们使用`<st c="29213">featuretools</st>`<st c="29225">`来自动化这个过程。</st>
- en: <st c="29226">How to do it...</st>
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="29226">如何做...</st>
- en: <st c="29242">We</st> <st c="29246">will</st> <st c="29251">apply cumulative
    transformations</st> <st c="29284">for each invoice and general transformations
    to the</st> <st c="29336">entire dataset:</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29242">我们将</st> <st c="29246">对每个发票应用累积变换</st> <st c="29284">并对整个数据集应用一般变换：</st>
- en: <st c="29351">First, we’ll import</st> `<st c="29372">pandas</st>`<st c="29378">,</st>
    `<st c="29380">featuretools</st>`<st c="29392">, and the</st> `<st c="29402">Categorical</st>`
    <st c="29413">logical type:</st>
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29351">首先，我们将导入</st> `<st c="29372">pandas</st>`<st c="29378">,</st>
    `<st c="29380">featuretools</st>`<st c="29392">, 以及</st> `<st c="29402">Categorical</st>`
    <st c="29413">逻辑类型：</st>
- en: '[PRE30]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="29520">Let’s load the dataset described in the</st> *<st c="29561">Technical</st>*
    *<st c="29571">requirements</st>* <st c="29583">section:</st>
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29520">让我们加载在技术</st> *<st c="29561">要求</st>* *<st c="29571">部分</st>*
    <st c="29583">中描述的数据集：</st>
- en: '[PRE31]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="29654">Let’s set up an</st> <st c="29671">entity set:</st>
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29654">让我们设置一个</st> <st c="29671">实体集：</st>
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="29711">Let’s add the DataFrame to the</st> <st c="29743">entity set:</st>
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29711">让我们将 DataFrame 添加到</st> <st c="29743">实体集：</st>
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="29944">Note</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29944">注意</st>
- en: <st c="29949">By default,</st> `<st c="29962">featuretools</st>` <st c="29974">only
    retains categorical, numeric, and Boolean features in the feature matrix that
    is generated</st> *<st c="30071">after</st>* <st c="30076">creating new features.</st>
    <st c="30100">The type of the</st> `<st c="30116">invoice</st>` <st c="30123">variable
    is not accurately inferred, so we need to enforce it as categorical by setting
    its logical type as we do in</st> *<st c="30241">step 4</st>*<st c="30247">, if
    we want</st> `<st c="30260">featuretools</st>` <st c="30272">to retain it in the
    dataset containing the new features.</st> <st c="30330">To learn the datatypes
    inferred by</st> `<st c="30365">featuretools</st>`<st c="30377">, you</st> <st
    c="30383">can</st> <st c="30387">execute</st> `<st c="30395">es["data"].</st><st
    c="30406">ww</st>`<st c="30409">.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29949">默认情况下，</st> `<st c="29962">featuretools</st>` <st c="29974">仅保留在创建新特征后生成的特征矩阵中的分类、数值和布尔特征。</st>
    <st c="30071">发票</st> <st c="30116">变量的类型无法准确推断，因此我们需要通过将其逻辑类型设置为我们在步骤 4 中所做的，来强制将其作为分类变量，如果我们希望</st>
    `<st c="30260">featuretools</st>` <st c="30272">将其保留在新特征数据集中。</st> <st c="30330">要了解</st>
    `<st c="30365">featuretools</st>`<st c="30377">推断的数据类型，您可以执行</st> `<st c="30387">es["data"].</st><st
    c="30406">ww</st>`<st c="30409">。</st>
- en: <st c="30410">Let’s create</st> <st c="30424">a new DataFrame with</st> <st
    c="30445">a relationship to the DataFrame from</st> *<st c="30482">step 4</st>*<st
    c="30488">:</st>
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30410">让我们创建一个与步骤 4 的 DataFrame 相关的新 DataFrame：</st>
- en: '[PRE34]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="30622">Note</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30622">注意</st>
- en: <st c="30627">For more details about</st> *<st c="30651">steps 4</st>* <st c="30658">and</st>
    *<st c="30663">5</st>*<st c="30664">, visit the</st> *<st c="30676">Setting up
    an entity set and creating features</st>* *<st c="30723">automatically</st>* <st
    c="30736">recipe.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30627">有关步骤 4 和</st> *<st c="30651">步骤 5</st>* <st c="30658">的更多详细信息，请访问</st>
    *<st c="30676">设置实体集和自动创建特征</st>* *<st c="30723">的食谱。</st>
- en: <st c="30744">Let’s make a list with the cumulative transformations that we’ll
    use to</st> <st c="30817">create features:</st>
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30744">让我们列出我们将用于创建特征的累积转换：</st>
- en: '[PRE35]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="30905">Note</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30905">注意</st>
- en: <st c="30910">You can find</st> `<st c="30924">featuretools</st>`<st c="30936">-supported
    cumulative transformations at this</st> <st c="30983">link:</st> [<st c="30989">https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30910">您可以在以下链接找到</st> `<st c="30924">featuretools</st>`<st c="30936">支持的累积转换：</st>
    [<st c="30989">https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives)
- en: <st c="31082">Let’s make</st> <st c="31094">a list of the general transformations
    to</st> <st c="31135">carry out:</st>
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31082">让我们列出要执行的一般转换：</st> <st c="31135">：</st>
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="31188">Note</st>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31188">注意</st>
- en: <st c="31193">You can find</st> `<st c="31207">featuretools</st>`<st c="31219">-supported
    general transformations at this</st> <st c="31263">link:</st> [<st c="31269">https://featuretools.alteryx.com/en/stable/api_reference.html#g</st><st
    c="31332">eneral-transform-primiti</st><st c="31357">ves</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#general-transform-primitives)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31193">您可以在以下链接找到</st> `<st c="31207">featuretools</st>`<st c="31219">支持的一般转换：</st>
    [<st c="31269">https://featuretools.alteryx.com/en/stable/api_reference.html#g</st><st
    c="31332">eneral-transform-primiti</st><st c="31357">ves</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#general-transform-primitives)
- en: <st c="31361">Finally, let’s</st> <st c="31377">create the features.</st> <st
    c="31398">We use the</st> `<st c="31409">dfs</st>` <st c="31412">class, setting
    the original DataFrame as the target DataFrame – that is, the one whose variables
    we’ll use as a template for the new features.</st> <st c="31556">Note that we
    pass an empty list to the</st> `<st c="31595">agg_primitives</st>` <st c="31609">parameter;
    this is to avoid returning the default aggregation primitives.</st> <st c="31684">We
    pass the general primitives from</st> *<st c="31720">step 7</st>* <st c="31726">to
    the</st> `<st c="31734">trans_primitives</st>` <st c="31750">parameter and the
    cumulative primitives from</st> *<st c="31796">step 6</st>* <st c="31802">to the</st>
    `<st c="31810">groupby_trans_primitives</st>` <st c="31834">parameter:</st>
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31361">最后，让我们</st> <st c="31377">创建特征。</st> <st c="31398">我们使用</st> `<st
    c="31409">dfs</st>` <st c="31412">类，将原始 DataFrame 设置为目标 DataFrame – 即，我们将使用其变量作为新特征的模板。</st>
    <st c="31556">请注意，我们向</st> `<st c="31595">agg_primitives</st>` <st c="31609">参数传递一个空列表；这是为了避免返回默认的聚合原语。</st>
    <st c="31684">我们从</st> *<st c="31720">步骤 7</st>* <st c="31726">将通用原语传递到</st> `<st
    c="31734">trans_primitives</st>` <st c="31750">参数，并将累积原语从</st> *<st c="31796">步骤
    6</st>* <st c="31802">传递到</st> `<st c="31810">groupby_trans_primitives</st>` <st
    c="31834">参数：</st>
- en: '[PRE37]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="32063">Note</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32063">注意</st>
- en: '*<st c="32068">Step 8</st>* <st c="32075">triggers the creation of features,
    which may take some time depending on how big the data is, how many aggregation
    levels it has, and the number of features to create.</st> <st c="32244">You can
    check out the output features</st> *<st c="32282">before</st>* <st c="32288">creating
    them, by setting the</st> `<st c="32319">features_only</st>` <st c="32332">parameter
    to</st> `<st c="32346">True</st>`<st c="32350">. This will return just the feature
    names; you can check them out, make sure they show what you need, and only then
    trigger the feature synthesis by setting that parameter back</st> <st c="32527">to</st>
    `<st c="32530">False</st>`<st c="32535">.</st>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="32068">步骤 8</st>* <st c="32075">触发特征的创建，这可能会花费一些时间，具体取决于数据的大小、聚合级别以及要创建的特征数量。</st>
    <st c="32244">您可以通过将</st> *<st c="32282">在创建它们之前</st> <st c="32288">检查输出特征，通过设置</st>
    `<st c="32319">features_only</st>` <st c="32332">参数为</st> `<st c="32346">True</st>`<st
    c="32350">。这将仅返回特征名称；您可以检查它们，确保它们显示您需要的内容，然后通过将该参数重新设置为</st> `<st c="32527">False</st>`<st
    c="32535">来触发特征合成。</st>'
- en: <st c="32536">Let’s now</st> <st c="32547">display the names</st> <st c="32565">of
    the</st> <st c="32572">created features:</st>
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32536">现在让我们</st> <st c="32547">显示</st> <st c="32565">创建的特征</st> <st
    c="32572">名称：</st>
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="32603">In the following output, we see the names of the features that
    we created, including the sine and cosine of the price and quantity, and the cumulative
    transformations of these variables after grouping them by</st> <st c="32813">invoice
    number:</st>
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32603">在以下输出中，我们可以看到我们创建的特征名称，包括价格和数量的正弦和余弦，以及将这些变量按发票号分组后的累积变换：</st>
    <st c="32813">：</st>
- en: '[PRE39]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="33338">Note</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33338">注意</st>
- en: <st c="33343">The sine</st> <st c="33353">and cosine transformation of price
    and quantity will probably</st> <st c="33415">not add much value because these
    are not cyclical features.</st> <st c="33475">I kept these transformations in
    the recipe to show you how to apply transformation primitives in general, if you
    ever</st> <st c="33593">need them.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33343">价格和数量的正弦和余弦变换可能不会增加太多价值，因为这些不是周期性特征。</st> <st c="33415">我保留了这些变换在配方中，以向您展示如何一般地应用变换原语，如果您需要的话。</st>
- en: <st c="33603">As you</st> <st c="33611">can see from the</st> <st c="33628">previous
    list, the new features were appended as new colum</st><st c="33686">ns to the
    original DataFrame.</st> <st c="33717">You can display the fin</st><st c="33740">al
    DataFrame by</st> <st c="33757">executing</st> `<st c="33767">feature_matrix.head()</st>`<st
    c="33788">:</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33603">如您从</st> <st c="33611">前面的列表中看到，新特征被附加为新的列到原始 DataFrame 中。</st>
    <st c="33686">您可以通过执行</st><st c="33686">`feature_matrix.head()`</st> <st c="33717">来显示</st>
    <st c="33740">最终的 DataFrame：</st>
- en: "![Figure 9.8 – DataFrame resulting from the deep feature synthesis, containing\
    \ the \uFEFForiginal variables and the new features](img/B22396_09_08.jpg)"
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 深度特征合成得到的 DataFrame，包含原始变量和新特征](img/B22396_09_08.jpg)'
- en: <st c="34802">Figure 9.8 – DataFrame resulting from the deep feature synthesis,
    containing the</st> <st c="34883">original variables and the new features</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34802">图 9.8 – 深度特征合成得到的 DataFrame，包含</st> <st c="34883">原始变量和新特征</st>
- en: <st c="34922">For more details about the cr</st><st c="34952">eated features,
    check the</st> *<st c="34979">How it</st>* *<st c="34986">works…</st>* <st c="34992">section.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建功能的更多详细信息，请查看 *<st c="34979">如何工作…</st>* *<st c="34986">部分。</st>
- en: <st c="35001">How it works...</st>
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*<st c="35001">如何工作…</st>*'
- en: <st c="35017">To create</st> <st c="35028">features using general and</st> <st
    c="35055">cumulative transformations with</st> `<st c="35087">featuretools</st>`<st
    c="35099">, we first need to set up an entity set with the data and define the
    relationships between its variables.</st> <st c="35205">We described how to set
    up an entity set in the</st> *<st c="35253">Setting up an entity set and creating
    features</st>* *<st c="35300">automatically</st>* <st c="35313">recipe.</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `<st c="35087">featuretools</st>`<st c="35099">创建一般和累积转换的功能，我们首先需要设置一个包含数据的实体集并定义其变量之间的关系。</st>
    <st c="35205">我们在 *<st c="35253">设置实体集和自动创建功能</st>* *<st c="35300">配方</st> 中描述了如何设置实体集。</st>
- en: <st c="35321">To apply cumulative and general transforms, we used the</st> `<st
    c="35378">dfs</st>` <st c="35381">class from</st> `<st c="35393">featuretools</st>`<st
    c="35405">. General transformations are applied to the entire DataFrame without
    grouping by a specific variable.</st> <st c="35508">To perform general transformations,
    we passed a list of strings with the transformation names to t</st><st c="35606">he</st>
    `<st c="35610">trans_primitives</st>` <st c="35626">parameter</st> <st c="35637">fr</st><st
    c="35639">om</st> `<st c="35643">dfs</st>`<st c="35646">.</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用累积和一般转换，我们使用了 `<st c="35378">dfs</st>` <st c="35381">类</st> 从 `<st c="35393">featuretools</st>`<st
    c="35405">。一般转换应用于整个 DataFrame，而不按特定变量进行分组。</st> <st c="35508">为了执行一般转换，我们将包含转换名称的字符串列表传递给
    `<st c="35610">trans_primitives</st>` <st c="35626">参数</st> <st c="35637">fr</st><st
    c="35639">om</st> `<st c="35643">dfs</st>`<st c="35646">。</st>
- en: <st c="35647">We applied cumulative transformation after grouping by</st> `<st
    c="35703">invoice</st>`<st c="35710">. To do this, we passed a list of strings
    with the names of the cumulative transformation to the</st> `<st c="35807">groupby_trans_primitives</st>`
    <st c="35831">parameter from</st> `<st c="35847">dfs</st>`<st c="35850">. The</st>
    `<st c="35856">featuretools</st>` <st c="35868">library knows it should group
    by invoice because we established this unique identifier by using the</st> `<st
    c="35969">normalize_dataframe</st>` <st c="35988">method from</st> `<st c="36001">EntitySet</st>`
    <st c="36010">in</st> *<st c="36014">step 5</st>*<st c="36020">.</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在按 `<st c="35703">invoice</st>`<st c="35710">分组后应用累积转换。为此，我们将包含累积转换名称的字符串列表传递给
    `<st c="35807">groupby_trans_primitives</st>` <st c="35831">参数</st> 从 `<st c="35847">dfs</st>`<st
    c="35850">。*<st c="35856">featuretools</st>* <st c="35868">库知道应该按发票分组，因为我们通过使用
    `<st c="35969">normalize_dataframe</st>` <st c="35988">方法从 `<st c="36001">EntitySet</st>`
    <st c="36010">在 *<st c="36014">步骤 5</st>*<st c="36020">中建立了这个唯一标识符。</st>
- en: <st c="36021">Finally, we did not want features created from the variables in
    the</st> `<st c="36090">invoices</st>` <st c="36098">DataFrame; thus, we set</st>
    `<st c="36123">dfs</st>` <st c="36126">to ignore this DataFrame by setting</st>
    `<st c="36163">ignore_dataframes = ["</st>``<st c="36185">invoices"]</st>`<st
    c="36196">.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不想从 `<st c="36090">invoices</st>` <st c="36098">DataFrame 中的变量创建功能；因此，我们将
    `<st c="36123">dfs</st>` <st c="36126">设置为通过设置 `<st c="36163">ignore_dataframes
    = ["</st>``<st c="36185">invoices"]</st>`<st c="36196">。</st>
- en: <st c="36197">The</st> `<st c="36202">dfs</st>` <st c="36205">class returned
    two variables, the DataFrame with the original and new features, and the name
    of the features in a list.</st> <st c="36326">The new features are named with
    the operations</st> <st c="36373">applied to create them, such as</st> `<st c="36405">SINE</st>`<st
    c="36409">,</st> `<st c="36411">COSINE</st>`<st c="36417">,</st> `<st c="36419">CUM_MAX</st>`<st
    c="36426">, or</st> `<st c="36431">DIFF</st>`<st c="36435">, followed by the variable
    to which the</st> <st c="36475">transformation was applied and, when corresponding,
    the variable that was used</st> <st c="36554">for grouping.</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="36197">dfs</st>` <st c="36202">类返回了两个变量，包含原始和新的 DataFrame 以及特征名称的列表。</st>
    <st c="36326">新特征以创建它们的操作命名，例如</st> `<st c="36405">SINE</st>`<st c="36409">,</st>
    `<st c="36411">COSINE</st>`<st c="36417">,</st> `<st c="36419">CUM_MAX</st>`<st
    c="36426">, 或</st> `<st c="36431">DIFF</st>`<st c="36435">，后跟应用转换的变量，以及当对应时，用于分组的变量。</st>'
- en: <st c="36567">Note that</st> `<st c="36578">featuretools</st>` <st c="36590">automatically
    recognizes and selects the variables over which the transformations should be
    applied.</st> <st c="36692">The sine, cosine, cumulative sum, maximum, and difference
    were applied to numerical variables, whereas the</st> `<st c="36799">time_since_previous</st>`
    <st c="36818">transformation was applied to the</st> <st c="36853">datetime variable.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36567">请注意</st> `<st c="36578">featuretools</st>` <st c="36590">会自动识别并选择应用转换的变量。</st>
    `<st c="36692">正弦、余弦、累计总和、最大值和差值被应用于数值变量，而</st> `<st c="36799">time_since_previous</st>`
    <st c="36818">转换被应用于</st> `<st c="36853">datetime变量</st>`。</st>
- en: <st c="36871">Combining numerical features</st>
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="36871">结合数值特征</st>
- en: <st c="36900">In</st> [*<st c="36904">Chapter 8</st>*](B22396_08.xhtml#_idTextAnchor987)<st
    c="36913">,</st> *<st c="36915">Creating New Features</st>*<st c="36936">, we
    saw th</st><st c="36947">at we can create new features by combining</st> <st c="36991">variables
    with mathematical operations.</st> <st c="37031">The</st> `<st c="37035">featuretools</st>`
    <st c="37047">library supports several operations for combining variables, including
    addition, division, modulo, and multiplication.</st> <st c="37167">In this recipe,
    we will l</st><st c="37192">earn how to combine these features</st> <st c="37228">with</st>
    `<st c="37233">featuretools</st>`<st c="37245">.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36900">在第</st> [*<st c="36904">第8章</st>*](B22396_08.xhtml#_idTextAnchor987)<st
    c="36913">中</st>，*<st c="36915">创建新特征</st>*<st c="36936">，我们了解到我们可以通过结合</st> <st
    c="36991">变量和数学运算来创建新特征。</st> `<st c="37035">featuretools</st>` <st c="37047">库支持多种组合变量的操作，包括加法、除法、取模和乘法。</st>
    <st c="37167">在本例中</st><st c="37192">，我们将学习如何使用</st> `<st c="37233">featuretools</st>`<st
    c="37245">来组合这些特征。</st>
- en: <st c="37246">How to do it...</st>
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="37246">如何操作...</st>
- en: <st c="37262">Let’s begin by importing the libraries and getting the</st> <st
    c="37318">dataset ready:</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37262">让我们首先导入库并准备数据集：</st>
- en: <st c="37332">First, we’ll import</st> `<st c="37353">pandas</st>`<st c="37359">,</st>
    `<st c="37361">featuretools</st>`<st c="37373">, and the</st> `<st c="37383">Categorical</st>`
    <st c="37394">logical type:</st>
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37332">首先，我们将导入</st> `<st c="37353">pandas</st>`<st c="37359">，`<st c="37361">featuretools</st>`<st
    c="37373">，以及</st> `<st c="37383">Categorical</st>` <st c="37394">逻辑类型：</st>
- en: '[PRE40]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="37501">Let’s load the dataset that described in the</st> *<st c="37547">Technical</st>*
    *<st c="37557">requirements</st>* <st c="37569">section:</st>
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37501">让我们加载在</st> *<st c="37547">技术</st> * *<st c="37557">要求</st> *
    <st c="37569">部分中描述的数据集：</st>
- en: '[PRE41]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="37640">Let’s set up an</st> <st c="37657">entity set:</st>
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37640">让我们设置一个</st> `<st c="37657">实体集</st>`：</st>
- en: '[PRE42]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <st c="37697">Let’s add</st> <st c="37708">the DataFrame to the</st> <st c="37729">entity
    set:</st>
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37697">让我们将DataFrame添加到</st> <st c="37729">实体集：</st>
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="37904">Let’s create a new DataFrame with a relationship to the DataFrame
    from</st> *<st c="37976">step 4</st>*<st c="37982">:</st>
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37904">让我们创建一个新的DataFrame，它与从</st> *<st c="37976">步骤4</st>*<st c="37982">中的DataFrame相关：</st>
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="38116">Note</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38116">注意</st>
- en: <st c="38121">For more details about</st> *<st c="38145">steps 4</st>* <st c="38152">and</st>
    *<st c="38157">5</st>*<st c="38158">, visit the</st> *<st c="38170">Setting up
    an entity set and creating features</st>* *<st c="38217">automatically</st>* <st
    c="38230">recipe.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38121">有关</st> *<st c="38145">步骤4</st> * <st c="38152">和</st> *<st c="38157">步骤5</st>*<st
    c="38158">的更多详细信息，请访问</st> *<st c="38170">设置实体集和自动创建特征</st> * *<st c="38217">食谱</st>
    *。</st>
- en: <st c="38238">We will multiply the</st> `<st c="38260">quantity</st>` <st c="38268">and</st>
    `<st c="38273">price</st>` <st c="38278">variables, which reflect the number of
    items bought and the unit price, respectively, to obtain the total</st> <st c="38385">amount
    paid:</st>
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38238">我们将乘以</st> `<st c="38260">数量</st>` <st c="38268">和</st> `<st c="38273">价格</st>`
    <st c="38278">变量，分别反映购买的商品数量和单价，以获得总</st> <st c="38385">支付金额：</st>
- en: '[PRE45]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="38674">Note</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38674">注意</st>
- en: <st c="38679">We set</st> `<st c="38687">agg_primitives</st>` <st c="38701">to
    an empty list to avoid the creation of</st> <st c="38744">default primitives.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38679">我们将</st> `<st c="38687">agg_primitives</st>` <st c="38701">设置为空列表，以避免创建</st>
    `<st c="38744">默认原语</st>`。</st>
- en: <st c="38763">Let’s now</st> <st c="38774">display the name of the</st> <st
    c="38798">new features:</st>
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38763">现在</st> <st c="38774">让我们显示新特征的名称：</st>
- en: '[PRE46]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="38824">In the following output, we see the feature names, the last one
    of which corresponds to the combination of the</st> `<st c="38936">price</st>`
    <st c="38941">and</st> `<st c="38946">quantity</st>` <st c="38954">variables:</st>
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39199">在以下输出中，我们看到特征名称，其中最后一个对应于</st> `<st c="38936">价格</st>` <st c="38941">和</st>
    `<st c="38946">数量</st>` <st c="38954">变量的组合：</st>
- en: '[PRE47]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <st c="39101">To finish off, let’s inspect the new Da</st><st c="39141">taFrame
    created in</st> *<st c="39161">step 6</st>*<st c="39167">:</st>
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39101">最后，让我们检查在</st> *<st c="39161">步骤 6</st>*<st c="39167">中创建的新 DataFrame：</st>
- en: '[PRE48]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <st c="39191">In the</st> <st c="39199">following output, we can see that the
    new featu</st><st c="39246">re was appended to the right of the</st> <st c="39283">original
    DataFrame:</st>
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39191">在以下输出中，我们可以看到新特征被附加到原始 DataFrame 的右侧：</st>
- en: '![Figure 9.9 – DataFrame with the new feature resulting from the product of
    price with quantity](img/B22396_09_09.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 由价格与数量的乘积产生的新特征的 DataFrame](img/B22396_09_09.jpg)'
- en: <st c="39658">Figure 9.9 – DataFrame with the new feature resulting from the
    product of price with quantity</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39658">图 9.9 – 由价格与数量的乘积产生的新特征的 DataFrame</st>
- en: <st c="39751">Combining features with</st> `<st c="39776">featuretools</st>`
    <st c="39788">may seem like a lot of work compared to the</st> `<st c="39833">df["price"].mul(df["quantity"])</st>`
    `<st c="39864">pandas</st>` <st c="39871">functionality.</st> <st c="39887">The
    real power comes in when we create new features in this way and follow it up with
    aggregations at the invoice or customer level.</st> <st c="40020">We will discuss
    aggregation functions in th</st><st c="40063">e</st> *<st c="40066">Creating features
    with aggregation</st>* *<st c="40101">primitives</st>* <st c="40111">recipe.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39751">与</st> `<st c="39776">featuretools</st>` <st c="39788">结合特征可能比</st>
    `<st c="39833">df["price"].mul(df["quantity"])</st>` <st c="39864">pandas</st>
    <st c="39871">函数更复杂。</st> <st c="39887">真正的力量在于我们以这种方式创建新特征并随后在发票或客户级别进行聚合时。</st>
    <st c="40020">我们将在</st> *<st c="40066">使用聚合原始操作创建特征</st>* *<st c="40101">食谱</st>*
    <st c="40111">中讨论聚合函数。</st>
- en: <st c="40119">How it works...</st>
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="40119">接下来...</st>
- en: <st c="40135">To multiply features, we used the</st> `<st c="40170">MultiplyNumeric</st>`
    <st c="40185">primitive from</st> `<st c="40201">featuretools</st>`<st c="40213">,
    which can be accessed from</st> `<st c="40242">dfs</st>` <st c="40245">using the</st>
    `<st c="40256">multiply_numeric</st>` <st c="40272">string.</st> <st c="40281">We
    passed the former string to the</st> `<st c="40316">trans_primitive</st>` <st
    c="40331">parameter and then used the</st> `<st c="40360">primitive_options</st>`
    <st c="40377">parameter to specify which variables to multiply.</st> <st c="40428">Note
    that in addition, we passed an empty list to the</st> `<st c="40482">agg_primitives</st>`
    <st c="40496">parameter to avoid returning the default aggregation primitives,
    and we ignored the features coming from the</st> `<st c="40606">invoices</st>`
    <st c="40614">DataFrame.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40135">要乘积特征，我们使用了来自</st> `<st c="40201">featuretools</st>`<st c="40213">的</st>
    `<st c="40170">MultiplyNumeric</st>` <st c="40185">原始操作</st>，它可以通过</st> `<st c="40242">dfs</st>`
    <st c="40245">使用</st> `<st c="40256">multiply_numeric</st>` <st c="40272">字符串访问。</st>
    <st c="40281">我们将前面的字符串传递给</st> `<st c="40316">trans_primitive</st>` <st c="40331">参数，然后使用</st>
    `<st c="40360">primitive_options</st>` <st c="40377">参数指定要乘积的变量。</st> <st c="40428">请注意，此外，我们还向</st>
    `<st c="40482">agg_primitives</st>` <st c="40496">参数传递了一个空列表，以避免返回默认的聚合原始操作，并且我们忽略了来自</st>
    `<st c="40606">invoices</st>` <st c="40614">DataFrame 的特征。</st>
- en: <st c="40625">To check out other functions that allow you to combine variables,
    visit</st> [<st c="40698">https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives)<st
    c="40787">. At the time of writing, I noticed that</st> `<st c="40828">MultiplyNumeric</st>`
    <st c="40843">and</st> `<st c="40848">DivideNumeric</st>` <st c="40861">are not
    in the documentation.</st> <st c="40892">You can always double-check which functions
    are supported by inspecting the source code:</st> [<st c="40981">https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary</st>](https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary)<st
    c="41080">. You can</st> <st c="41090">also check out which operations you can
    perform on your data by running the following command after you set up the entity
    set and its relationships:</st> `<st c="41239">ft.get_valid_primitives(es, target_dataframe_name="data",
    max_dep</st><st c="41304">th=2)</st>`<st c="41310">. Here,</st> `<st c="41318">es</st>`
    <st c="41320">is the entity set resulting from</st> *<st c="41354">step 5</st>*<st
    c="41360">.</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40625">要查看其他允许您组合变量的函数，请访问</st> [<st c="40698">https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives)<st
    c="40787">。在撰写本文时，我发现</st> `<st c="40828">MultiplyNumeric</st>` <st c="40843">和</st>
    `<st c="40848">DivideNumeric</st>` <st c="40861">未在文档中列出。</st> <st c="40892">您可以通过检查源代码始终双重检查哪些函数受支持：</st>
    [<st c="40981">https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary</st>](https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary)<st
    c="41080">。您还可以通过在设置实体集及其关系后运行以下命令来检查您可以在数据上执行哪些操作：</st> `<st c="41239">ft.get_valid_primitives(es,
    target_dataframe_name="data", max_dep</st><st c="41304">th=2)</st>`<st c="41310">。在这里，<st
    c="41318">es</st> <st c="41320">是第 *<st c="41354">步骤5</st>*<st c="41360">产生的实体集。</st>
- en: <st c="41361">Extracting features from date and time</st>
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="41361">从日期和时间中提取特征</st>
- en: <st c="41400">In</st> [*<st c="41404">Chapter 6</st>*](B22396_06.xhtml#_idTextAnchor748)<st
    c="41413">,</st> *<st c="41415">Extracting Features from Date and Time</st>* *<st
    c="41453">Variables</st>*<st c="41463">, we discussed how we</st> <st c="41484">can
    enrich our</st> <st c="41500">datasets by extracting features from the date and
    time parts of datetime variables, such as the year, the month, the day of the
    week, the hour, and much more.</st> <st c="41659">We can extract those features
    automatically</st> <st c="41703">u</st><st c="41704">tilizing</st> `<st c="41713">featuretools</st>`<st
    c="41725">.</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41400">在第</st> [*<st c="41404">第6章</st>*](B22396_06.xhtml#_idTextAnchor748)<st
    c="41413">中</st>，*<st c="41415">从日期和时间中提取特征</st>* *<st c="41453">变量</st>*<st c="41463">，我们讨论了如何通过从日期和时间变量（如年份、月份、星期几、小时等）中提取特征来丰富我们的</st>
    <st c="41500">数据集</st>。我们可以利用 `<st c="41713">featuretools</st>`<st c="41725">
    自动提取这些特征。</st>
- en: <st c="41726">The</st> `<st c="41731">featuretools</st>` <st c="41743">library
    supports the creation of various features from datetime variables</st> <st c="41818">using
    its</st> **<st c="41828">datetime transform primitives</st>**<st c="41857">. These
    primitives include common variables such as year, month, and day, and other features
    such as</st> *<st c="41958">is it lunch time</st>* <st c="41974">or</st> *<st
    c="41978">is it weekday</st>*<st c="41991">. In addition, we can extract features
    indicating if the date was a federal or bank holiday (as they call it in the UK)
    or features that determine the distance in time to a certain date.</st> <st c="42178">For
    a retail company, the proximity to dates such as Boxing Day, Black Fridays, or
    Christmas normally signals an increase in sales, and if they are forecasting demand,
    these will make</st> <st c="42362">useful variables.</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41726">`featuretools` <st c="41731">库</st> 支持使用其 **<st c="41828">日期时间转换原语</st>**<st
    c="41857">创建来自日期时间变量的各种特征</st>。这些原语包括常见的变量，如年份、月份和日期，以及其他特征，如 *<st c="41958">是否是午餐时间</st>*
    <st c="41974">或</st> *<st c="41978">是否是工作日</st>*<st c="41991">。此外，我们可以提取表示日期是否为联邦假日或银行假日（如英国所称）的特征，或者确定到特定日期的时间距离的特征。</st>
    <st c="42178">对于一家零售公司来说，圣诞节、黑色星期五或节礼日等日期的邻近性通常预示着销售额的增加，如果他们正在预测需求，这些将是有用的变量。</st>
- en: <st c="42379">Note</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42379">注意</st>
- en: <st c="42384">For more details on the features that can be created from datetime
    variables,</st> <st c="42463">visit</st> [<st c="42469">https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives)<st
    c="42560">.</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42384">有关从 datetime 变量创建的特征的更多详细信息，请访问</st> [<st c="42469">https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives)<st
    c="42560">。</st>
- en: <st c="42561">In this recipe, we will automatically create mul</st><st c="42610">tiple
    features from a datetime variable</st> <st c="42651">with</st> `<st c="42656">featuretools</st>`<st
    c="42668">.</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42561">在这个配方中，我们将使用 `<st c="42656">featuretools</st>`<st c="42668">自动从
    datetime 变量创建多个特征：</st>
- en: <st c="42669">How to do it...</st>
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="42669">如何做到这一点...</st>
- en: <st c="42685">Let’s begin</st> <st c="42698">by importing the libraries and
    getting the</st> <st c="42741">dataset ready:</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42685">让我们开始</st> <st c="42698">通过导入库并准备</st> <st c="42741">数据集：</st>
- en: <st c="42755">First, we’ll import</st> `<st c="42776">pandas</st>`<st c="42782">,</st>
    `<st c="42784">featuretools</st>`<st c="42796">, and some special</st> <st c="42815">datetime
    primitives:</st>
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="42755">首先，我们将导入</st> `<st c="42776">pandas</st>`<st c="42782">，`<st c="42784">featuretools</st>`<st
    c="42796">，以及一些特殊的</st> <st c="42815">datetime 原始设置：</st>
- en: '[PRE49]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <st c="43003">Let’s load the dataset described in the</st> *<st c="43044">Technical</st>*
    *<st c="43054">requirements</st>* <st c="43066">section:</st>
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="43003">让我们加载</st> *<st c="43044">技术</st>* *<st c="43054">要求</st>* <st
    c="43066">部分中描述的数据集：</st>
- en: '[PRE50]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: <st c="43137">Let</st><st c="43141">’s set up an</st> <st c="43155">entity set:</st>
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="43137">让我们设置一个</st><st c="43141">实体集：</st>
- en: '[PRE51]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <st c="43195">Let’s add the DataFrame to the</st> <st c="43227">entity set:</st>
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="43195">让我们将 DataFrame 添加到</st> <st c="43227">实体集：</st>
- en: '[PRE52]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <st c="43402">Let’s create a new DataFrame with a relationship to the DataFrame
    from</st> *<st c="43474">step 4</st>*<st c="43480">:</st>
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="43402">让我们创建一个新的 DataFrame，它与</st> *<st c="43474">步骤 4</st>*<st c="43480">中的
    DataFrame 有关系：</st>
- en: '[PRE53]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <st c="43614">Note</st>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43614">注意</st>
- en: <st c="43619">For more details about</st> *<st c="43643">steps 4</st>* <st c="43650">and</st>
    *<st c="43655">5</st>*<st c="43656">, visit the</st> *<st c="43668">Setting up
    an entity set and creating features</st>* *<st c="43715">automatically</st>* <st
    c="43728">recipe.</st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43619">有关</st> *<st c="43643">步骤 4</st>* <st c="43650">和</st> *<st c="43655">步骤
    5</st>*<st c="43656">的更多详细信息，请访问</st> *<st c="43668">设置实体集和自动创建特征</st>* *<st c="43715">的配方。</st>
- en: <st c="43736">Let’s create</st> <st c="43750">a primitive that returns a Boolean
    vector indicating if the date coincides with a UK bank holiday (that is, a</st>
    <st c="43860">non-working day):</st>
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="43736">让我们创建一个</st> <st c="43750">返回一个布尔向量，指示日期是否与英国的银行假日（即非工作日）相符的原始设置：</st>
    <st c="43860">：</st>
- en: '[PRE54]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: <st c="43922">Note</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43922">注意</st>
- en: <st c="43927">When setting up the primitive to determine bank holidays, it is
    important to choose the right country.</st> <st c="44031">For a list of supported
    countries,</st> <st c="44066">visit</st> [<st c="44072">https://github.com/dr-prodigy/python-holidays#available-countries</st>](https://github.com/dr-prodigy/python-holidays#available-countries)<st
    c="44137">.</st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43927">在设置用于确定银行假日的原始设置时，选择正确的国家非常重要。</st> <st c="44031">有关支持国家的列表，</st>
    <st c="44066">请访问</st> [<st c="44072">https://github.com/dr-prodigy/python-holidays#available-countries</st>](https://github.com/dr-prodigy/python-holidays#available-countries)<st
    c="44137">。</st>
- en: <st c="44138">Let’s check out which bank holidays are included in</st> <st c="44191">this
    primitive:</st>
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44138">让我们检查这个原始设置中包含哪些银行假日：</st>
- en: '[PRE55]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <st c="44296">If we</st> <st c="44303">execute</st> `<st c="44311">available_hols</st>`<st
    c="44325">, we’ll see a list of bank holidays supported for</st> <st c="44375">the
    UK:</st>
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44296">如果我们</st> <st c="44303">执行</st> `<st c="44311">available_hols</st>`<st
    c="44325">`，我们将看到支持英国银行假日的列表：</st>
- en: '[PRE56]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <st c="44865">Let’s create another primitive that determines the days to a certain
    date – in this case, the distance to</st> <st c="44972">Boxing Day:</st>
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44865">让我们创建另一个原始设置，用于确定到特定日期的天数——在这种情况下，到节礼日的距离：</st>
- en: '[PRE57]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <st c="45055">Now, let’s make a list containing strings that identify common
    features that we can get from</st> `<st c="45149">datetime</st>` <st c="45157">and
    include the primitives from</st> *<st c="45190">steps 6</st>* <st c="45197">and</st>
    *<st c="45202">8</st>*<st c="45203">:</st>
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45055">现在，让我们创建一个包含字符串的列表，这些字符串可以识别我们从</st> `<st c="45149">datetime</st>`
    <st c="45157">和包括从</st> *<st c="45190">步骤 6</st>* <st c="45197">和</st> *<st c="45202">步骤
    8</st>*<st c="45203">中获取的原始设置：</st>
- en: '[PRE58]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <st c="45340">Let’s now</st> <st c="45351">create date and time features from</st>
    *<st c="45386">step 9</st>* <st c="45392">based on the</st> `<st c="45406">invoice_date</st>`
    <st c="45418">date variable:</st>
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45340">现在让我们</st> <st c="45351">从</st> *<st c="45386">第9步</st>* <st c="45392">创建基于</st>
    `<st c="45406">invoice_date</st>` <st c="45418">日期变量的</st>日期和时间特征：</st>
- en: '[PRE59]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <st c="45575">Note</st>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45575">注意</st>
- en: <st c="45580">In</st> *<st c="45584">step 4</st>*<st c="45590">, we entered
    the</st> `<st c="45607">invoice_date</st>` <st c="45619">variable as a time variable.</st>
    <st c="45649">Thus,</st> `<st c="45655">featuretools</st>` <st c="45667">will
    use this variable to create date- and</st> <st c="45711">time-related features.</st>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45580">在第</st> *<st c="45584">4步</st>*<st c="45590">中，我们输入了</st> `<st
    c="45607">invoice_date</st>` <st c="45619">变量作为时间变量。</st> <st c="45649">因此，</st>
    `<st c="45655">featuretools</st>` <st c="45667">将使用此变量来创建日期和</st> <st c="45711">时间相关的特征。</st>
- en: <st c="45733">Let’s display the names of the</st> <st c="45765">created features:</st>
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="45733">让我们显示创建的</st> <st c="45765">特征名称：</st>
- en: '[PRE60]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <st c="45795">In the following output, we see the names of the original and</st>
    <st c="45858">time features:</st>
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="45795">在以下输出中，我们看到原始特征和</st> <st c="45858">时间特征的名称：</st>
- en: '[PRE61]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: <st c="46561">Let’s display the resulting DataFrame containing three of the</st>
    <st c="46624">new features:</st>
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="46561">让我们显示包含三个新特征的</st> <st c="46624">结果DataFrame：</st>
- en: '[PRE62]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <st c="46830">In the</st> <st c="46837">following output, we see the DataFrame
    with the</st> <st c="46886">new features:</st>
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46830">在以下输出中，我们看到包含新特征的DataFrame：</st>
- en: "![Figure 9.10 – DataF\uFEFFrame with some of the features derived from datetime](img/B22396_09_10.jpg)"
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: "![图9.10 – 包含从datetime派生的一些特征的DataF\uFEFFrame](img/B22396_09_10.jpg)"
- en: <st c="47148">Figure 9.10 – DataF</st><st c="47167">rame with some of the features
    derived from datetime</st>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47148">图9.10 – 包含从datetime派生的一些特征的DataF</st><st c="47167">rame</st>
- en: <st c="47220">Note that</st> <st c="47231">some of the created features are
    numeric, such as</st> `<st c="47281">HOUR</st>` <st c="47285">or</st> `<st c="47289">DAY</st>`<st
    c="47292">, some are Booleans, such as</st> `<st c="47321">IS_FEDERAL_HOLIDAY</st>`<st
    c="47339">, and some are categorical, such as</st> `<st c="47375">PART_OF_DAY</st>`<st
    c="47386">. To take a look at the values of</st> `<st c="47420">PART_OF_DAY</st>`<st
    c="47431">,</st> <st c="47433">e</st><st c="47434">xecute</st> `<st c="47441">feature_matrix["PAR</st><st
    c="47460">T_OF_DAY(first_data_time)"].unique()</st>`<st c="47497">.</st>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47220">请注意，</st> <st c="47231">一些创建的特征是数值型的，例如</st> `<st c="47281">HOUR</st>`
    <st c="47285">或</st> `<st c="47289">DAY</st>`<st c="47292">，一些是布尔型的，例如</st> `<st
    c="47321">IS_FEDERAL_HOLIDAY</st>`<st c="47339">，还有一些是分类型的，例如</st> `<st c="47375">PART_OF_DAY</st>`<st
    c="47386">。要查看</st> `<st c="47420">PART_OF_DAY</st>`<st c="47431">的值，</st> <st
    c="47433">执</st><st c="47434">行</st> `<st c="47441">feature_matrix["PAR</st><st
    c="47460">T_OF_DAY(first_data_time)"].unique()</st>`<st c="47497">。</st>
- en: <st c="47498">How it works...</st>
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="47498">它是如何工作的...</st>
- en: <st c="47514">To create features from datetime variables, we used datetime transform
    primitives from</st> `<st c="47602">featuretools</st>` <st c="47615">(</st>[<st
    c="47616">https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives)<st
    c="47707">).</st> <st c="47711">These primitives can be accessed from</st> `<st
    c="47749">dfs</st>` <st c="47752">using the strings and functions we specified
    in</st> *<st c="47801">steps 6</st>* <st c="47808">to</st> *<st c="47811">9</st>*
    <st c="47813">through the</st> `<st c="47826">trans_primitive</st>` <st c="47841">parameter.</st>
    <st c="47853">Note that in addition, we passed an empty list to the</st> `<st
    c="47907">agg_primitives</st>` <st c="47921">parameter not to return the default
    aggregation primitives that would have been otherwise applied to our datetime
    features.</st> <st c="48046">We also ignored the features coming from the</st>
    `<st c="48091">invoices</st>` <st c="48099">DataFrame.</st>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47514">要从datetime变量创建特征，我们使用了来自</st> `<st c="47602">featuretools</st>`
    <st c="47615">(</st>[<st c="47616">https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives)<st
    c="47707">)的datetime转换原语。</st> <st c="47711">这些原语可以通过</st> `<st c="47749">dfs</st>`
    <st c="47752">使用我们在</st> *<st c="47801">第6步</st>* <st c="47808">到</st> *<st c="47811">第9步</st>*
    <st c="47813">中指定的字符串和函数通过</st> `<st c="47826">trans_primitive</st>` <st c="47841">参数访问。</st>
    <st c="47853">注意，此外，我们还向</st> `<st c="47907">agg_primitives</st>` <st c="47921">参数传递了一个空列表，以避免返回应用于我们的datetime特征的默认聚合原语。</st>
    <st c="48046">我们还忽略了来自</st> `<st c="48091">invoices</st>` <st c="48099">DataFrame的特征。</st>
- en: <st c="48110">Note</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48110">注意</st>
- en: <st c="48115">We set</st> `<st c="48123">agg_primitives</st>` <st c="48137">to
    an empty list and ignored the</st> `<st c="48171">invoices</st>` <st c="48179">DataFrame
    to keep the outputs simple and be able to focus on datetime features.</st> <st
    c="48260">However, note that the real power of</st> `<st c="48297">featuretools</st>`
    <st c="48309">consists in creating primitives from</st> `<st c="48347">datetim</st><st
    c="48354">e</st>` <st c="48356">and then aggregating them further at different</st>
    <st c="48404">entity levels.</st>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`agg_primitives`设置为一个空列表，并忽略了`invoices` DataFrame，以保持输出简单并能够专注于日期时间特征。然而，请注意，`featuretools`的真正威力在于从`datetim`中创建原始数据，然后在不同实体级别进一步聚合它们。
- en: <st c="48418">Extracting features from text</st>
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文本中提取特征
- en: <st c="48448">In</st> [*<st c="48452">Chapter 11</st>*](B22396_11.xhtml#_idTextAnchor1459)<st
    c="48462">,</st> *<st c="48464">Extracting Feat</st><st c="48479">ures from Text
    Variables</st>*<st c="48504">, we will discuss various features that</st> <st
    c="48544">we can extract from text pieces utilizing</st> `<st c="48586">pandas</st>`
    <st c="48592">and</st> `<st c="48597">scikit-learn</st>`<st c="48609">. We can
    also extract multiple features from text automatically by</st> <st c="48676">utilizing</st>
    `<st c="48686">featuretools</st>`<st c="48698">.</st>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](B22396_11.xhtml#_idTextAnchor1459)中，*从文本变量中提取特征*，我们将讨论我们可以从文本片段中利用`pandas`和`scikit-learn`提取的各种特征。我们还可以通过利用`featuretools`自动从文本中提取多个特征。
- en: <st c="48699">The</st> `<st c="48704">featuretools</st>` <st c="48716">library
    supports the creation of several basic features from text as part of its default
    functionality, such as the number of characters, the number of words, the mean
    character count per word, and the median word length in a piece of text,</st>
    <st c="48958">among others.</st>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="48704">featuretools</st>`库支持创建几个基本特征作为其默认功能的一部分，例如文本中的字符数、单词数、每个单词的平均字符数以及文本中的中位词长等。'
- en: <st c="48971">Note</st>
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: <st c="48976">For a full list</st> <st c="48993">of the default text primitives,</st>
    <st c="49025">visit</st> [<st c="49031">https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives)<st
    c="49129">.</st>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取默认文本原始数据的完整列表，请访问[https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives)。
- en: <st c="49130">In addition, there is an accompanying Python library,</st> `<st
    c="49185">nlp_primitives</st>`<st c="49199">, which contains additional primitives
    to create more advanced features based on NLP.</st> <st c="49285">Among these
    functions, we find primitives for determining the diversity score, the polarity
    score, or the count of</st> <st c="49400">stop words.</st>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个配套的Python库`nlp_primitives`，它包含额外的原始数据，用于创建基于NLP的更高级特征。在这些函数中，我们发现了一些用于确定多样性得分、极性得分或停用词计数的原始数据。
- en: <st c="49411">Note</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: <st c="49416">There is no documentation at the time of writing to learn more
    about the primitives supported</st> <st c="49511">by the</st> `<st c="49518">nlp_primitives</st>`
    <st c="49532">library, so to find out more, you need to check the source</st>
    <st c="49592">code:</st> [<st c="49598">https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives</st>](https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives)<st
    c="49700">.</st>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文时，没有关于`nlp_primitives`库支持的原始数据的文档，因此要了解更多信息，您需要检查源代码：[https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives](https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives)。
- en: <st c="49701">In this recipe, we will first create multiple features from a
    text variable utilizing</st> `<st c="49788">featuretools</st>`<st c="49800">’
    default functionality and the</st><st c="49832">n highlight how to use p</st><st
    c="49857">rimitives from the</st> `<st c="49877">nlp_primitives</st>` <st c="49891">library.</st>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49701">在这个食谱中，我们将首先利用`<st c="49788">featuretools</st>`<st c="49800">的默认功能以及</st><st
    c="49832">n</st>突出显示如何使用来自`<st c="49877">nlp_primitives</st>` <st c="49891">库的</st>
    `<st c="49857">p</st>`原语。</st>
- en: <st c="49900">Getting ready</st>
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="49900">准备就绪</st>
- en: <st c="49914">To follow along with this recipe, you need to install the</st>
    `<st c="49973">nlp_primitives</st>` <st c="49987">library, which you can do</st>
    <st c="50014">with</st> `<st c="50019">pip</st>`<st c="50022">:</st>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49914">为了跟随这个食谱，您需要安装`<st c="49973">nlp_primitives</st>` <st c="49987">库，您可以使用`<st
    c="50014">pip</st>`<st c="50022">来完成此操作：</st>
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: <st c="50051">Otherwise, you can</st> <st c="50071">use</st> `<st c="50075">conda</st>`<st
    c="50080">:</st>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50051">否则，您可以使用</st> <st c="50071">conda</st>`<st c="50080">:</st>
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: <st c="50126">Note</st>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50126">注意</st>
- en: <st c="50131">For more details, visit the</st> `<st c="50160">nlp_primi</st><st
    c="50169">tives</st>` <st c="50175">GitHub</st> <st c="50183">repository:</st>
    [<st c="50195">https://github.com/alteryx/nlp_primitives</st>](https://github.com/alteryx/nlp_primitives)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50131">有关更多详细信息，请访问`<st c="50160">nlp_primi</st><st c="50169">tives</st>`
    <st c="50175">GitHub</st> <st c="50183">存储库：</st> [<st c="50195">https://github.com/alteryx/nlp_primitives</st>](https://github.com/alteryx/nlp_primitives)
- en: <st c="50236">How to do it...</st>
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="50236">如何操作...</st>
- en: <st c="50252">Let’s begin</st> <st c="50265">by importing the libraries and
    getting the</st> <st c="50308">dataset ready:</st>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50252">让我们首先导入库并准备数据集：</st>
- en: <st c="50322">First, we’ll import</st> `<st c="50343">pandas</st>`<st c="50349">,</st>
    `<st c="50351">featuretools</st>`<st c="50363">, and the</st> <st c="50373">logical
    types:</st>
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="50322">首先，我们将导入</st> `<st c="50343">pandas</st>`<st c="50349">，`<st c="50351">featuretools</st>`<st
    c="50363">，以及</st> <st c="50373">逻辑类型：</st>
- en: '[PRE65]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: <st c="50500">Let’s load the dataset described in the</st> *<st c="50541">Technical</st>*
    *<st c="50551">requirements</st>* <st c="50563">section:</st>
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="50500">让我们加载在`<st c="50541">技术</st>` *<st c="50551">要求</st> * <st c="50563">部分中描述的数据集：</st>
- en: '[PRE66]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: <st c="50634">Let’s set up an</st> <st c="50651">entity set:</st>
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="50634">让我们设置一个</st> <st c="50651">实体集：</st>
- en: '[PRE67]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: <st c="50691">Let’s add the DataFrame to the entity set, highlighting that the</st>
    `<st c="50757">description</st>` <st c="50768">variable is a</st> <st c="50783">text
    variable:</st>
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="50691">让我们将 DataFrame 添加到实体集中，突出显示</st> `<st c="50757">描述</st>` <st c="50768">变量是一个</st>
    <st c="50783">文本变量：</st>
- en: '[PRE68]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <st c="51019">Note</st>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51019">注意</st>
- en: <st c="51024">For the</st> `<st c="51033">featuretools</st>` <st c="51045">library‘s
    text primitives to work, we need to indicate which variables are text by using
    the</st> `<st c="51139">NaturalLanguage</st>` <st c="51154">logical type.</st>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51024">为了使`<st c="51033">featuretools</st>` <st c="51045">库的文本原语正常工作，我们需要使用`<st
    c="51139">NaturalLanguage</st>` <st c="51154">逻辑类型</st>来指示哪些变量是文本。</st>
- en: <st c="51168">Let’s create</st> <st c="51182">a new DataFrame with a relationship
    to the DataFrame from</st> *<st c="51240">step 4</st>*<st c="51246">:</st>
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51168">让我们创建</st> <st c="51182">一个新的 DataFrame，它与`<st c="51240">步骤 4</st>`<st
    c="51246">中的 DataFrame 有关系：</st>
- en: '[PRE69]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: <st c="51380">Note</st>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51380">注意</st>
- en: <st c="51385">For more details about</st> *<st c="51409">steps 4</st>* <st c="51416">and</st>
    *<st c="51421">5</st>*<st c="51422">, visit the</st> *<st c="51434">Setting up</st>
    <st c="51445">an entity set and creating features</st>* *<st c="51481">automatically</st>*
    <st c="51494">recipe.</st>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51385">有关</st> *<st c="51409">步骤 4</st> * <st c="51416">和</st> *<st c="51421">步骤
    5</st>*<st c="51422">的更多详细信息，请访问</st> *<st c="51434">设置实体集并创建特征</st> * *<st c="51481">自动</st>
    * <st c="51494">食谱。</st>
- en: <st c="51502">Let’s make a list with strings corresponding to the text features
    we want</st> <st c="51577">to create:</st>
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51502">让我们创建一个与我们要创建的文本特征对应的字符串列表：</st>
- en: '[PRE70]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: <st c="51684">Let’s now</st> <st c="51695">extract the text features from the</st>
    `<st c="51730">description</st>` <st c="51741">variable:</st>
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51684">现在让我们</st> <st c="51695">从`<st c="51730">描述</st>` <st c="51741">变量中提取文本特征：</st>
- en: '[PRE71]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: <st c="51921">Let’s display the names of the</st> <st c="51953">created features:</st>
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51921">让我们显示已创建的特征的名称：</st>
- en: '[PRE72]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <st c="51983">In the following output, we see the names of the original features,
    followed by those created from the</st> `<st c="52087">description</st>` <st c="52098">variable:</st>
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="51983">在以下输出中，我们看到原始特征的名称，然后是来自</st> `<st c="52087">description</st>`
    <st c="52098">变量的特征：</st>
- en: '[PRE73]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: <st c="52444">Let’s display</st> <st c="52459">a slice of the DataFrame containing
    the</st> <st c="52499">text-derived features:</st>
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52444">让我们显示包含从文本派生特征的 DataFrame 的一个片段：</st>
- en: '[PRE74]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: <st c="52654">In the followin</st><st c="52670">g output, we see a DataFrame
    with the features created from</st> <st c="52731">the text:</st>
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52654">在以下输出中，我们看到一个从</st><st c="52670">文本中创建的特征 DataFrame：</st>
- en: '![Figure 9.11 – DataFrame with the features created from text](img/B22396_09_11.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 从文本创建的特征 DataFrame](img/B22396_09_11.jpg)'
- en: <st c="52874">Figure 9.11 – DataFrame with the features created from text</st>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52874">图 9.11 – 从文本创建的特征 DataFrame</st>
- en: <st c="52933">Note</st>
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52933">注意</st>
- en: <st c="52938">The</st> `<st c="52943">featuretools</st>` <st c="52955">library
    removes the original text variable,</st> `<st c="53000">description</st>`<st c="53011">,
    and in its place, it returns the</st> <st c="53046">new features.</st>
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52938">`<st c="52943">featuretools</st>` <st c="52955">库移除了原始文本变量</st>
    `<st c="53000">description</st>`<st c="53011">，并返回了</st> <st c="53046">新的特征。</st>
- en: <st c="53059">To create features using the primitives from the</st> `<st c="53109">nlp_primitives</st>`
    <st c="53123">package, you need to import them first – for example, by executing
    from</st> `<st c="53196">nlp_primitives import DiversityScore</st>` <st c="53232">–
    and then add the primitives to the text primitive list that we created in</st>
    *<st c="53309">step 6</st>*<st c="53315">. Note that these are</st> <st c="53336">complex
    functions, so they</st> <st c="53363">may take some time to create</st> <st c="53393">the
    features.</st>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53059">要使用来自</st> `<st c="53109">nlp_primitives</st>` <st c="53123">包的原始函数创建特征，您首先需要导入它们
    – 例如，通过执行</st> `<st c="53196">from nlp_primitives import DiversityScore</st>`
    <st c="53232">– 然后将原始函数添加到我们在</st> *<st c="53309">步骤 6</st>*<st c="53315">中创建的文本原始函数列表中。请注意，这些是</st>
    <st c="53336">复杂函数，因此创建特征可能需要一些时间。</st>
- en: <st c="53406">How it works...</st>
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="53406">它是如何工作的...</st>
- en: <st c="53422">To create</st> <st c="53433">features from text variables, we
    used the default text primitives from</st> `<st c="53504">featuretools</st>`<st
    c="53516">. These primitives can be accessed from</st> `<st c="53556">dfs</st>`
    <st c="53559">by passing a list with strings corresponding to the primitive names,
    such as those from</st> *<st c="53648">step 6</st>*<st c="53654">, to the</st>
    `<st c="53663">trans_primitives</st>` <st c="53679">parameter.</st>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53422">要从文本变量创建特征，我们使用了来自</st> `<st c="53504">featuretools</st>`<st c="53516">的默认文本原始函数。这些原始函数可以通过传递一个包含与原始函数名称对应的字符串列表到</st>
    `<st c="53663">trans_primitives</st>` <st c="53679">参数中从</st> `<st c="53556">dfs</st>`
    <st c="53559">访问，例如来自</st> *<st c="53648">步骤 6</st>*<st c="53654">的，到</st> `<st
    c="53663">trans_primitives</st>` <st c="53679">参数。</st>
- en: <st c="53690">For more advanced primitives, you need to import the primitive
    functions from the</st> `<st c="53773">nlp_primitives</st>` <st c="53787">library
    and then pass them on to the</st> `<st c="53825">trans_primitives</st>` <st c="53841">parameter
    from</st> `<st c="53857">dfs</st>`<st c="53860">. With this,</st> `<st c="53873">dfs</st>`
    <st c="53876">can tap into the functionality of these primitives to create new
    features from the text.</st> <st c="53966">T</st><st c="53967">he</st> `<st c="53970">nlp_primitives</st>`
    <st c="53984">library uses the</st> `<st c="54002">nltk</st>` <st c="54006">Python
    library un</st><st c="54024">der</st> <st c="54029">the hood.</st>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53690">对于更高级的原始函数，您需要从</st> `<st c="53773">nlp_primitives</st>` <st c="53787">库中导入原始函数，然后将它们传递给来自</st>
    `<st c="53857">dfs</st>`<st c="53860">的</st> `<st c="53825">trans_primitives</st>`
    <st c="53841">参数。有了这个，</st> `<st c="53873">dfs</st>` <st c="53876">就可以利用这些原始函数的功能从文本中创建新的特征。</st>
    `<st c="53966">nlp_primitives</st>` <st c="53984">库在底层使用</st> `<st c="54002">nltk</st>`
    <st c="54006">Python 库。</st>
- en: <st c="54038">Creating features with aggregation primitives</st>
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="54038">使用聚合原始函数创建特征</st>
- en: <st c="54084">Throughout this chapter, we’ve created features automatically
    by mapping existing variables into</st> <st c="54182">new features through various
    functions.</st> <st c="54222">For example, we extracted date and time parts from
    datetime variables, counted the number of words,</st> <st c="54321">characters,
    and punctuation in texts, combined numerical features into new variables, and
    transformed features with functions such as sine and cosine.</st> <st c="54473">To
    create these features, we worked with</st> <st c="54514">transform primitives.</st>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54084">在本章中，我们通过将现有变量映射到</st> <st c="54182">新特征中，通过各种函数自动创建了特征。</st>
    <st c="54222">例如，我们从日期时间变量中提取日期和时间部分，计算文本中的单词、</st> <st c="54321">字符和标点符号的数量，将数值特征组合成新变量，并使用正弦和余弦等函数转换特征。</st>
    <st c="54473">为了创建这些特征，我们使用了</st> <st c="54514">转换原语。</st>
- en: <st c="54535">The</st> `<st c="54540">featuretools</st>` <st c="54552">library
    also</st> <st c="54566">supports</st> `<st c="54773">price</st>`<st c="54778">,
    related to an invoice, an aggregation primitive would take all the price observations
    for a single invoice and return a single value, such as the mean price or the
    sum (that is, the total amount paid), for</st> <st c="54986">that invoice.</st>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54535">`<st c="54540">featuretools</st>` <st c="54552">库还</st> <st c="54566">支持</st>
    `<st c="54773">价格</st>`<st c="54778">，与发票相关，聚合原语将取单个发票的所有价格观测值并返回单个值，例如平均价格或总和（即支付的总金额），对于</st>
    <st c="54986">该发票。</st>
- en: <st c="54999">Note</st>
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54999">注意</st>
- en: <st c="55004">The</st> `<st c="55009">featuretools</st>` <st c="55021">aggregation
    functionality is the equivalent of</st> `<st c="55069">groupby</st>` <st c="55076">in</st>
    `<st c="55080">pandas</st>`<st c="55086">, followed by</st> `<st c="55100">pandas</st>`
    <st c="55106">fun</st><st c="55110">ctions such as</st> `<st c="55126">mean</st>`<st
    c="55130">,</st> `<st c="55132">sum</st>`<st c="55135">,</st> `<st c="55137">std</st>`<st
    c="55140">, and</st> `<st c="55146">count</st>`<st c="55151">,</st> <st c="55153">among
    others.</st>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55004">`<st c="55009">featuretools</st>` <st c="55021">的聚合功能相当于</st>
    `<st c="55069">groupby</st>` <st c="55076">在</st> `<st c="55080">pandas</st>`<st
    c="55086">中，随后是</st> `<st c="55100">pandas</st>` <st c="55106">fun</st><st c="55110">ctions</st>，如</st>
    `<st c="55126">mean</st>`<st c="55130">，</st> `<st c="55132">sum</st>`<st c="55135">，</st>
    `<st c="55137">std</st>`<st c="55140">，和</st> `<st c="55146">count</st>`<st c="55151">，以及其他函数。</st>
- en: <st c="55166">Some aggregation primitives work with numerical variables, such
    as the mean, sum, or maximum</st> <st c="55260">and minimum values.</st> <st c="55280">Other
    aggregation primitives are specific to categorical variables, such as the number</st>
    <st c="55366">of unique values and the most frequent</st> <st c="55406">value
    (mode).</st>
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55166">一些聚合原语与数值变量一起工作，例如平均值、总和或最大值</st> <st c="55260">和最小值。</st> <st
    c="55280">其他聚合原语特定于分类变量，例如唯一值的数量和最频繁的</st> <st c="55366">值（众数）。</st>
- en: <st c="55419">Note</st>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55419">注意</st>
- en: <st c="55424">For a</st> <st c="55431">complete list of supported aggregation
    primitives,</st> <st c="55482">visit</st> [<st c="55488">https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives)<st
    c="55572">.</st>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55424">要获取</st> <st c="55431">支持的聚合原语的完整列表，</st> <st c="55482">请访问</st>
    [<st c="55488">https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives</st>](https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives)<st
    c="55572">。</st>
- en: <st c="55573">In this recipe, we will first create multiple features by aggregating
    existing variables.</st> <st c="55664">After that, we will combine the use of
    transfo</st><st c="55710">rm and aggregation primitives to highlight the true
    power</st> <st c="55769">of</st> `<st c="55772">featuretools</st>`<st c="55784">.</st>
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55573">在本菜谱中，我们将首先通过聚合现有变量来创建多个特征。</st> <st c="55664">之后，我们将结合使用转换和聚合原语，以突出`<st
    c="55772">featuretools</st>`<st c="55784">的真正威力。</st>
- en: <st c="55785">Getting ready</st>
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="55785">准备就绪</st>
- en: <st c="55799">In this recipe, we will use the</st> *<st c="55832">Online Retail
    II</st>* <st c="55848">dataset from the UCI Machine Learning Repository.</st>
    <st c="55899">This dataset has information about products (items), invoices, and
    customers.</st> <st c="55977">To follow along with this recipe, it is important
    to understand the nature of and the relationships between these entities and how
    to correctly set up an entity set with</st> `<st c="56147">featuretools</st>`<st
    c="56159">, which we described in the</st> *<st c="56187">Setting up an entity
    set and creating features automatically</st>* <st c="56247">recipe.</st> <st c="56256">Make</st>
    <st c="56260">sure you checked that recip</st><st c="56288">e out before proceeding
    with the</st> <st c="56322">next section.</st>
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55799">在这个菜谱中，我们将使用来自 UCI 机器学习仓库的</st> *<st c="55832">在线零售 II</st>* <st
    c="55848">数据集。</st> <st c="55899">这个数据集包含有关产品（项目）、发票和客户的信息。</st> <st c="55977">为了跟随这个菜谱，了解这些实体的性质和它们之间的关系，以及如何使用</st>
    `<st c="56147">featuretools</st>`<st c="56159">正确设置实体集非常重要，我们在</st> *<st c="56187">设置实体集和自动创建特征</st>*
    <st c="56247">菜谱中描述了这一点。</st> <st c="56256">在继续下一节之前，请确保您已经检查了该菜谱。</st>
- en: <st c="56335">How to do it...</st>
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="56335">如何做到...</st>
- en: <st c="56351">Let’s begin by importing the libraries and getting the</st> <st
    c="56407">dataset ready:</st>
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56351">让我们首先导入库并准备好</st> <st c="56407">数据集：</st>
- en: <st c="56421">First, we’ll import</st> `<st c="56442">pandas</st>`<st c="56448">,</st>
    `<st c="56450">featuretools</st>`<st c="56462">, and the</st> <st c="56472">logical
    types:</st>
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56421">首先，我们将导入</st> `<st c="56442">pandas</st>`<st c="56448">，</st>
    `<st c="56450">featuretools</st>`<st c="56462">，以及逻辑类型：</st>
- en: '[PRE75]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: <st c="56599">Let’s load</st> <st c="56611">the dataset described in the</st>
    *<st c="56640">Technical</st>* *<st c="56650">requirements</st>* <st c="56662">section:</st>
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56599">让我们加载</st> <st c="56611">在</st> *<st c="56640">技术</st>* *<st c="56650">要求</st>*
    <st c="56662">部分中描述的</st>数据集：</st>
- en: '[PRE76]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: <st c="56733">Let’s set up an</st> <st c="56750">entity set:</st>
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56733">让我们设置一个</st> <st c="56750">实体集：</st>
- en: '[PRE77]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: <st c="56790">Let’s add the DataFrame to the entity set, highlighting that the</st>
    `<st c="56856">description</st>` <st c="56867">variable is a text variable,</st>
    `<st c="56897">customer_id</st>` <st c="56908">is categorical, and</st> `<st c="56929">invoice_date</st>`
    <st c="56941">is a</st> <st c="56947">datetime feature:</st>
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56790">让我们将 DataFrame 添加到实体集中，并强调以下内容：</st> `<st c="56856">描述</st>` <st
    c="56867">变量是一个文本变量，</st> `<st c="56897">customer_id</st>` <st c="56908">是分类变量，</st>
    `<st c="56929">invoice_date</st>` <st c="56941">是一个</st> <st c="56947">日期时间特征：</st>
- en: '[PRE78]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: <st c="57162">Let’s create a new DataFrame with a relationship to the DataFrame
    from</st> *<st c="57234">step 4</st>*<st c="57240">:</st>
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57162">让我们创建一个新的 DataFrame，它与来自</st> *<st c="57234">步骤 4</st>*<st c="57240">的
    DataFrame 有关系：</st>
- en: '[PRE79]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: <st c="57375">Now, we add</st> <st c="57388">the second relationship, which
    is between customers and invoices.</st> <st c="57454">To do this, we indicate
    the base DataFrame, which we called</st> `<st c="57514">invoices</st>` <st c="57522">in</st>
    *<st c="57526">step 5</st>*<st c="57532">, we give the new DataFrame a name,</st>
    `<st c="57568">customers</st>`<st c="57577">, and we add a unique</st> <st c="57599">customer
    identifier:</st>
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57375">现在，我们添加第二个关系，即客户与发票之间的关系。</st> <st c="57454">为此，我们指示基础 DataFrame，我们在</st>
    *<st c="57526">步骤 5</st>*<st c="57532">中将其称为</st> `<st c="57514">invoices</st>`
    <st c="57522">，我们给新的 DataFrame 起名，</st> `<st c="57568">customers</st>`<st c="57577">，并添加一个唯一的</st>
    <st c="57599">客户标识符：</st>
- en: '[PRE80]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: <st c="57730">Note</st>
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57730">注意</st>
- en: <st c="57735">For more details about</st> *<st c="57759">steps 4</st>* <st c="57766">to</st>
    *<st c="57770">5</st>*<st c="57771">, visit the</st> *<st c="57783">Setting up
    an entity set and creating features</st>* *<st c="57830">automatically</st>* <st
    c="57843">recipe.</st>
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57735">有关</st> *<st c="57759">步骤 4</st>* <st c="57766">到</st> *<st c="57770">5</st>*<st
    c="57771">的更多详细信息，请访问</st> *<st c="57783">设置实体集和自动创建特征</st>* *<st c="57830">自动</st>*
    <st c="57843">菜谱。</st>
- en: <st c="57851">Let’s make a list with string names that identify the aggregation
    primitives we want</st> <st c="57937">to use:</st>
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57851">让我们创建一个包含字符串名称的列表，这些名称标识了我们想要使用的聚合原语：</st> <st c="57937">要使用：</st>
- en: '[PRE81]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: <st c="57991">Let’s create features by aggregating the data at the customer
    level.</st> <st c="58061">To do this, we set up the</st> `<st c="58087">dfs</st>`
    <st c="58090">class from</st> `<st c="58102">featuretools</st>`<st c="58114">,
    indicating</st> `<st c="58127">customers</st>` <st c="58136">as the target DataFrame
    and passing the aggregation primitives from</st> *<st c="58205">step 7</st>* <st
    c="58211">and an empty list to the</st> `<st c="58237">trans_primitives</st>`
    <st c="58253">parameter to prevent</st> `<st c="58275">dfs</st>` <st c="58278">from
    returning the</st> <st c="58298">default transformations:</st>
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57991">让我们通过在客户级别聚合数据来创建特征。</st> <st c="58061">为此，我们设置了</st> `<st c="58087">dfs</st>`
    <st c="58090">类从</st> `<st c="58102">featuretools</st>`<st c="58114">，表示</st>
    `<st c="58127">customers</st>` <st c="58136">作为目标 DataFrame，并将来自</st> *<st c="58205">步骤
    7</st>* <st c="58211">的聚合原语传递给</st> `<st c="58237">trans_primitives</st>` <st
    c="58253">参数，以防止</st> `<st c="58275">dfs</st>` <st c="58278">返回默认转换：</st>
- en: '[PRE82]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: <st c="58465">Let’s display</st> <st c="58480">the names of the</st> <st c="58497">created
    features:</st>
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="58465">让我们显示</st> <st c="58480">创建的特征的</st> 名称：</st>
- en: '[PRE83]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: <st c="58527">In the following output, we see the name features that were aggregated
    at the</st> <st c="58606">customer level:</st>
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="58527">在以下输出中，我们看到在</st> <st c="58606">客户级别</st> 聚合的名称特征：</st>
- en: '[PRE84]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: <st c="59975">Note</st>
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59975">注意</st>
- en: <st c="59980">Remember that</st> `<st c="59995">featuretools</st>` <st c="60007">names
    features with the function used to create them, followed by the DataFrame that
    was used in the computation, followed by the variable that was used in the computation.</st>
    <st c="60181">Thus,</st> `<st c="60187">MAX(data.price)</st>` <st c="60202">is
    the maximum price seen in the dataset for each customer.</st> <st c="60263">On
    the other hand,</st> `<st c="60282">MEAN(invoices.MAX(data.price))</st>` <st c="60312">is
    the mean value of all maximum prices observed in each invoice for a particular
    customer.</st> <st c="60405">That is, if a customer has six invoices, we first
    find the maximum price for</st> <st c="60482">each of the six invoices and then
    take the average of</st> <st c="60536">those values.</st>
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59980">请记住，</st> `<st c="59995">featuretools</st>` <st c="60007">使用创建它们的函数命名特征，然后是用于计算的
    DataFrame，最后是用于计算的变量。</st> <st c="60181">因此，</st> `<st c="60187">MAX(data.price)</st>`
    <st c="60202">是每个客户在数据集中看到的最高价格。</st> <st c="60263">另一方面，</st> `<st c="60282">MEAN(invoices.MAX(data.price))</st>`
    <st c="60312">是特定客户在每张发票中观察到的所有最大价格的均值。</st> <st c="60405">也就是说，如果一个客户有六张发票，我们首先找到六张发票中的每张发票的最高价格，然后取这些值的平均值。</st>
- en: <st c="60549">Let’s now</st> <st c="60560">display the resulting DataFrame containing
    the original data and</st> <st c="60625">new features:</st>
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60549">现在让我们</st> <st c="60560">显示包含原始数据和</st> <st c="60625">新特征的</st>
    结果 DataFrame：</st>
- en: '[PRE85]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: <st c="60660">In the fol</st><st c="60671">lowing output, we see</st> *<st c="60694">some</st>*
    <st c="60698">of the variables in the DataFrame returned</st> <st c="60742">by</st>
    `<st c="60745">dfs</st>`<st c="60748">:</st>
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="60660">在以下输出中，我们看到</st> *<st c="60694">一些</st>* <st c="60698">由</st>
    `<st c="60742">dfs</st>`<st c="60745"> 返回的 DataFrame 中的变量：</st>
- en: '![Figure 9.12 – DataFrame with some of the features resulting from aggregations
    at the customer level](img/B22396_09_12.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 包含客户级别聚合的一些特征的 DataFrame](img/B22396_09_12.jpg)'
- en: <st c="61524">Figure 9.12 – DataFrame with some of the features resulting from
    aggregations at the customer level</st>
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61524">图 9.12 – 包含客户级别聚合的一些特征的 DataFrame</st>
- en: <st c="61623">Due to space limitations, we can’t display the entire output of</st>
    *<st c="61688">step 10</st>*<st c="61695">, so make sure you execute it on your
    computer or visit our accompanying GitHub repository for more</st> <st c="61795">details:</st>
    [<st c="61804">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb)<st
    c="61976">.</st>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61623">由于空间限制，我们无法显示</st> *<st c="61688">步骤 10</st>*<st c="61695"> 的全部输出，所以请确保您在自己的计算机上执行它或访问我们的配套
    GitHub 仓库以获取更多</st> <st c="61795">详细信息：</st> [<st c="61804">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb)<st
    c="61976">。</st>
- en: <st c="61977">To follow up, let’s combine what we learned from the recipes using
    transform primitives with the aggregation</st> <st c="62086">functions from this
    recipe.</st> <st c="62115">First, we will create new features from existing datetime
    and text variables; then, we will aggregate those features along with the numerical
    variables, at the</st> <st c="62275">customer level.</st>
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61977">为了跟进，让我们将使用转换原语从菜谱中学到的知识与这个菜谱中的聚合</st> <st c="62086">函数结合起来。</st>
    <st c="62115">首先，我们将从现有的日期时间和文本变量中创建新特征；然后，我们将在</st> <st c="62275">客户级别对这些特征以及数值变量进行聚合。</st>
- en: <st c="62290">Let’s make lists with date and</st> <st c="62322">text primitives:</st>
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="62290">让我们使用日期和</st> <st c="62322">文本原语来创建列表：</st>
- en: '[PRE86]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: <st c="62391">Let’s make a list with an</st> <st c="62418">aggregation primitive:</st>
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="62391">让我们使用聚合原语创建一个列表：</st>
- en: '[PRE87]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: <st c="62466">Let’s now</st> <st c="62477">automatically create features by
    transforming and then</st> <st c="62532">aggregating variables:</st>
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="62466">现在让我们通过转换然后</st> <st c="62477">自动创建特征，并聚合变量：</st>
- en: '[PRE88]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: <st c="62723">The code from</st> *<st c="62738">step 13</st>* <st c="62745">triggers
    the creation of the features and their subsequent aggregation at the</st> <st
    c="62824">customer level.</st>
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="62723">从</st> *<st c="62738">步骤 13</st>* <st c="62745">触发的代码会创建功能，并在</st>
    <st c="62824">客户级别进行后续聚合。</st>
- en: <st c="62839">Let’s display the names of the</st> <st c="62871">new features:</st>
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="62839">让我们显示新功能的</st> <st c="62871">名称：</st>
- en: '[PRE89]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: <st c="62897">In the following output, we see the names of the</st> <st c="62947">created
    variables:</st>
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="62897">在以下输出中，我们可以看到创建的变量的</st> <st c="62947">名称：</st>
- en: '[PRE90]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: <st c="63324">Note that in our recipes, we keep the creation of features to
    a minimum due to space limitations, but you can create as many features as you
    want and enr</st><st c="63478">ich your datasets dramatically with the functionality
    built</st> <st c="63539">into</st> `<st c="63544">featuretools</st>`<st c="63556">.</st>
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63324">请注意，由于空间限制，在我们的菜谱中我们将特征的创建保持到最小，但你可以创建尽可能多的特征，并使用</st> <st c="63478">内置</st>
    <st c="63539">于</st> `<st c="63544">featuretools</st>`<st c="63556">的功能显著丰富你的数据集。</st>
- en: <st c="63557">How it works...</st>
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="63557">它的工作原理...</st>
- en: <st c="63573">In this recipe, we brought together the creation of features using
    transform primitives, which we</st> <st c="63672">discussed throughout the chapter,
    with the creation of features using</st> <st c="63742">aggregation primitives.</st>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63573">在这个菜谱中，我们将使用转换原语创建功能的方法，这是我们</st> <st c="63672">在本章中讨论的，与使用</st>
    <st c="63742">聚合原语创建功能的方法结合起来。</st>
- en: <st c="63765">To create features with</st> `<st c="63790">featuretools</st>`
    <st c="63802">automatically, we first need to enter the data into an entity set
    and establish the relationships between the data.</st> <st c="63919">We discussed
    how to set up an entity set in the</st> *<st c="63967">Setting up an entity set
    and creating features</st>* *<st c="64014">automatically</st>* <st c="64027">recipe.</st>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63765">要使用</st> `<st c="63790">featuretools</st>` <st c="63802">自动创建特征，我们首先需要将数据输入到实体集中，并建立数据之间的关系。</st>
    <st c="63919">我们在</st> *<st c="63967">设置实体集和自动创建特征</st>* *<st c="64014">菜谱</st>*
    <st c="64027">中讨论了如何设置实体集。</st>
- en: <st c="64035">To aggregate existing features, we used the</st> `<st c="64080">dfs</st>`
    <st c="64083">class.</st> <st c="64091">We created a list with a string corresponding
    to the aggregation primitives and passed it to the</st> `<st c="64188">agg_primitives</st>`
    <st c="64202">parameter from</st> `<st c="64218">dfs</st>`<st c="64221">. To aggregate
    existing variables without creating new features, we passed an empty list to the</st>
    `<st c="64317">trans_primitives</st>` <st c="64333">parameter</st> <st c="64344">of</st>
    `<st c="64347">dfs</st>`<st c="64350">.</st>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64035">为了聚合现有的特征，我们使用了</st> `<st c="64080">dfs</st>` <st c="64083">类。</st>
    <st c="64091">我们创建了一个包含对应聚合原语的字符串的列表，并将其传递给</st> `<st c="64188">agg_primitives</st>`
    <st c="64202">参数，来自</st> `<st c="64218">dfs</st>`<st c="64221">。为了在不创建新特征的情况下聚合现有变量，我们将一个空列表传递给</st>
    `<st c="64317">trans_primitives</st>` <st c="64333">参数，来自</st> `<st c="64347">dfs</st>`<st
    c="64350">。</st>
- en: <st c="64351">The</st> `<st c="64356">customers</st>` <st c="64365">DataFrame
    is the child of the</st> `<st c="64396">invoice</st>` <st c="64403">DataFrame,
    which is, in turn, the child of the original data.</st> <st c="64466">Thus,</st>
    `<st c="64472">dfs</st>` <st c="64475">created aggregations from the original
    data and the pre-aggregated data for each invoice.</st> <st c="64566">Thus, the</st>
    `<st c="64576">MEAN(data.price)</st>` <st c="64592">feature consists of the mean
    price for an item bought by a customer calculated from the entire data, whereas</st>
    `<st c="64702">MEAN(invoices.MEAN(data.price))</st>` <st c="64733">calculates
    the mean price per invoice first and then takes the mean of those values for a
    customer.</st> <st c="64834">Thus, if a customer has five invoices,</st> `<st
    c="64873">featuretools</st>` <st c="64885">first calculates the mean price paid
    for each of those invoices and then takes the mean of those values.</st> <st c="64991">As
    such,</st> `<st c="65000">MEAN(data.price)</st>` <st c="65016">and</st> `<st c="65021">MEAN(invoices.MEAN(data.price))</st>`
    <st c="65052">are not the</st> <st c="65065">same feature.</st>
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64351">《</st> `<st c="64356">customers</st>` <st c="64365">DataFrame</st>
    是</st> `<st c="64396">invoice</st>` <st c="64403">DataFrame</st> 的子集，而</st> `<st
    c="64396">invoice</st>` <st c="64403">DataFrame</st> 又是原始数据的子集。</st> <st c="64466">因此，</st>
    `<st c="64472">dfs</st>` <st c="64475">从原始数据和每个发票的预聚合数据中创建了聚合。</st> <st c="64566">因此，</st>
    `<st c="64576">MEAN(data.price)</st>` <st c="64592">特征由客户购买的商品的总数据的均值组成，而</st>
    `<st c="64702">MEAN(invoices.MEAN(data.price))</st>` <st c="64733">首先计算每张发票的平均价格，然后取这些值的均值。</st>
    <st c="64834">因此，如果一个客户有五张发票，</st> `<st c="64873">featuretools</st>` <st c="64885">首先计算每张发票支付的平均价格，然后取这些值的均值。</st>
    <st c="64991">因此，</st> `<st c="65000">MEAN(data.price)</st>` <st c="65016">和</st>
    `<st c="65021">MEAN(invoices.MEAN(data.price))</st>` <st c="65052">不是同一个特征。</st>
- en: <st c="65078">Note</st>
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65078">注意</st>
- en: <st c="65083">An aggregate primitive aggregates information for a unique identifier.</st>
    <st c="65155">Aggregate primitives use mathematical operations such as the mean,
    standard deviation, maximum and minimum values, the sum, and the skew coefficient
    for numerical variables.</st> <st c="65329">For categorical variables, aggregate
    primitives use the mode and the count of unique items.</st> <st c="65421">For
    unique ident</st><st c="65437">ifiers, aggregate primitives count the number</st>
    <st c="65484">of occurrences.</st>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65083">聚合原语对唯一标识符的信息进行聚合。</st> <st c="65155">聚合原语使用数学运算，如均值、标准差、最大值和最小值、总和以及偏度系数来处理数值变量。</st>
    <st c="65329">对于分类变量，聚合原语使用众数和唯一项的数量。</st> <st c="65421">对于唯一标识符，聚合原语计算出现的次数。</st>
- en: <st c="65499">Next, we combined</st> <st c="65518">the creation of new features
    from date and text variables with aggregation.</st> <st c="65594">To do this,
    we passed a list of strings corresponding to the transform primitives to the</st>
    `<st c="65683">trans_primitives</st>` <st c="65699">parameter, and another list
    of strings corresponding to the aggregation primitives to the</st> `<st c="65790">agg_primitives</st>`
    <st c="65804">parameter</st> <st c="65815">of</st> `<st c="65818">dfs</st>`<st
    c="65821">.</st>
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65499">接下来，我们将</st> <st c="65518">从日期和文本变量中创建新特征与聚合相结合。</st> <st c="65594">为此，我们将对应于转换原语的一组字符串传递给</st>
    `<st c="65683">trans_primitives</st>` <st c="65699">参数，并将对应于聚合原语的一组字符串传递给</st>
    `<st c="65790">agg_primitives</st>` <st c="65804">参数</st> <st c="65815">的</st>
    `<st c="65818">dfs</st>`<st c="65821">。</st>
- en: <st c="65822">One of the outputs of</st> *<st c="65845">step 13</st>* <st c="65852">is
    a list of the new features.</st> <st c="65884">From these, we can identify features
    created from the first invoice date for each customer, such as</st> `<st c="65984">MONTH(first_invoices_time)</st>`
    <st c="66010">and</st> `<st c="66015">WEEKDAY(first_invoices_time)</st>`<st c="66043">.
    We can also see features that were aggregated from features created from text,
    such as</st> `<st c="66132">MEAN(data.NUM_WORDS(description))</st>` <st c="66165">and</st>
    `<st c="66170">MEAN(invoices.MEAN(data.NUM_WORDS(description)))</st>`<st c="66218">.
    Finally, we can see the aggregations of existing n</st><st c="66270">umerical
    variables, such as</st> `<st c="66299">MEAN(data.price)</st>` <st c="66315">and</st>
    `<st c="66320">MEAN(invoices.MEAN(data.price))</st>`<st c="66351">.</st>
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65822">步骤13</st> *<st c="65845">的输出之一</st>* <st c="65852">是一个新特征列表。</st>
    <st c="65884">从这些特征中，我们可以识别出由每个客户的首次发票日期创建的特征，例如</st> `<st c="65984">MONTH(first_invoices_time)</st>`
    <st c="66010">和</st> `<st c="66015">WEEKDAY(first_invoices_time)</st>`<st c="66043">。我们还可以看到从文本特征创建的聚合特征，例如</st>
    `<st c="66132">MEAN(data.NUM_WORDS(description))</st>` <st c="66165">和</st> `<st
    c="66170">MEAN(invoices.MEAN(data.NUM_WORDS(description)))</st>`<st c="66218">。最后，我们还可以看到现有数值变量的聚合，例如</st>
    `<st c="66299">MEAN(data.price)</st>` <st c="66315">和</st> `<st c="66320">MEAN(invoices.MEAN(data.price))</st>`<st
    c="66351">。</st>
- en: <st c="66352">Note</st>
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66352">注意</st>
- en: <st c="66357">If you want to apply transform and aggregation primitives to specific
    variables, you can do so by specifying the primitive options as discussed</st>
    <st c="66502">here:</st> [<st c="66508">https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html</st>](https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html)<st
    c="66588">.</st>
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66357">如果您想将转换和聚合原语应用于特定变量，您可以通过指定原语选项来实现，具体讨论如下</st> <st c="66502">此处：</st>
    [<st c="66508">https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html</st>](https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html)<st
    c="66588">。</st>
