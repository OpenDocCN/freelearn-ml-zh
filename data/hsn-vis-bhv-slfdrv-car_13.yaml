- en: '*Chapter 10*: Steering, Throttle, and Brake Control'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：转向、油门和制动控制'
- en: In this chapter, you will learn about more methods for controlling the steering,
    throttle, and brake using techniques from the field of control systems. If you
    recall [*Chapter 8*](B16322_08_Final_NM_ePUB.xhtml#_idTextAnchor182), *Behavioral
    Cloning*, you learned how to steer a car using a neural network and camera images.
    While this most closely mimics how a human drives a car, it can be resource-intensive
    due to the computational needs of neural networks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解更多使用控制理论领域技术来控制转向、油门和制动的方法。如果你还记得[*第8章*](B16322_08_Final_NM_ePUB.xhtml#_idTextAnchor182)，*行为克隆*，你学习了如何使用神经网络和摄像头图像来控制汽车。虽然这最接近人类驾驶汽车的方式，但由于神经网络的计算需求，它可能非常消耗资源。
- en: There are more traditional and less resource-intensive methods for controlling
    a vehicle. The most widely used of these is the **PID** (short for **Proportional,
    Integral, Derivative**) controller, which you will implement in CARLA to drive
    your car around the simulated town.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 存在更多传统且资源消耗较少的车辆控制方法。其中最广泛使用的是**PID**（即**比例、积分、微分**）控制器，你将在CARLA中实现它来驾驶你的汽车在模拟城镇中行驶。
- en: There is also another method that is widely used in self-driving cars, called
    the **MPC** (short for **Model Predictive Controller**). The MPC focuses on simulating
    trajectories, calculating the cost of each trajectory, and selecting the trajectory
    with the minimum cost. We will walk through some example code that you could implement
    in place of the PID you will learn.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一种在自动驾驶汽车中广泛使用的方法，称为**MPC**（即**模型预测控制器**）。MPC专注于模拟轨迹，计算每个轨迹的成本，并选择成本最低的轨迹。我们将通过一些示例代码，展示你可以用这些代码替代你将要学习的PID控制器。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Why do you need controls?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你需要控制？
- en: Types of controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器的类型
- en: Implementing a PID in CARLA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CARLA中实现PID控制器
- en: An example MPC in C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的MPC示例
- en: By the end of the chapter, you will have gained knowledge of why we need controls,
    and the skills to select a controller for a given application. You will also know
    how to implement a PID controller in Python and get exposure to an MPC controller
    example written in C++.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解为什么我们需要控制，以及如何为特定应用选择控制器。你还将知道如何在Python中实现PID控制器，并接触到用C++编写的MPC控制器示例。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will require the following software and libraries:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将需要以下软件和库：
- en: Python 3.7, available at [https://www.python.org/downloads/](https://www.python.org/downloads/).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.7，可在[https://www.python.org/downloads/](https://www.python.org/downloads/)下载。
- en: CARLA Simulator 0.9.9, available at [https://carla.readthedocs.io/en/latest/start_quickstart/#carla-installation](https://carla.readthedocs.io/en/latest/start_quickstart/#carla-installation).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CARLA模拟器0.9.9，可在[https://carla.readthedocs.io/en/latest/start_quickstart/#carla-installation](https://carla.readthedocs.io/en/latest/start_quickstart/#carla-installation)下载。
- en: The NumPy module, which can be installed with the `pip3 install numpy` command.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`pip3 install numpy`命令安装的NumPy模块。
- en: A GPU is highly recommended.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度推荐使用GPU。
- en: 'The code for the chapter can be found here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter10)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter10)'
- en: 'The Code in Action videos for this chapter can be found here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码实战”视频可以在以下位置找到：
- en: '[https://bit.ly/2T7WnKo](https://bit.ly/2T7WnKo)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/2T7WnKo](https://bit.ly/2T7WnKo)'
- en: Why do you need controls?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你需要控制？
- en: This may seem completely obvious since you are trying to build a self-driving
    car, but let's cover it quickly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来非常明显，因为你正在尝试构建自动驾驶汽车，但让我们快速了解一下。
- en: When you build a self-driving car, what are you trying to achieve? The ultimate
    goal is to get the vehicle to move from a start position to a destination by commanding
    actuators such as the steering, throttle, and brakes. Historically, the commands
    to these actuators have been provided by you, the human driver, via the steering
    wheel, and the throttle and brake pedals. Now you are trying to remove yourself
    as the thing responsible for primary driving tasks. So, what do you put in place
    of yourself? A controller!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一辆自动驾驶汽车时，你试图实现什么？最终目标是通过控制执行器（如转向、油门和刹车）来指挥车辆从起始位置移动到目的地。历史上，这些执行器的命令是由你，即人类驾驶员，通过方向盘和油门及刹车踏板提供的。现在你试图将自己从主要负责驾驶任务的角色中移除。那么，你将什么放在自己的位置？一个控制器！
- en: What is a controller?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器是什么？
- en: 'A controller is simply an algorithm that takes some type of error signal and
    transforms it into an actuation signal to achieve a desired setpoint for a given
    process. Let''s define some of these terms as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器简单来说是一个算法，它接收某种类型的误差信号并将其转换成执行信号，以实现给定过程的期望设定点。以下是对这些术语的定义：
- en: The **Control Variable** (**CV**) or process variable is the variable that you
    would like to control.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制变量**（**CV**）或过程变量是你想要控制的变量。'
- en: The **setpoint** is the desired value of the CV.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设定点**是CV的期望值。'
- en: The **error** is the difference between the current state of the CV and the
    **setpoint**.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**误差**是CV当前状态与**设定点**之间的差异。'
- en: The **actuation** is the signal sent to the process to influence the reduction
    of the error.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**是发送到过程以影响误差减少的信号。'
- en: The **process** is the system being controlled.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程**是被控制的系统。'
- en: You may see the **process** sometimes called the *plant* or the *transfer function*.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有时可能会看到**过程**被称为*植物*或*传递函数*。
- en: For example, let's say that you are trying to maintain your self-driving car
    within the bounds of the lane it is driving in. The center of the lane would be
    the **setpoint**. You first need to know the **error**, or how far you are away
    from the lane center – let's call this your **Cross-Track Error** (**CTE**). You
    then need to determine what **actuation** command you need to safely return the
    car (aka the **process**) to the center of the lane, thereby minimizing the car's
    CTE. Ultimately, think of the controller as a function that is continually trying
    to minimize the car's **error** for a given CV relative to the **setpoint** of
    that variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你试图保持你的自动驾驶汽车在其行驶车道内。车道的中心点将是**设定点**。首先，你需要知道**误差**，即你距离车道中心的距离——让我们称这个为你的**横穿误差**（**CTE**）。然后，你需要确定你需要什么**执行**命令来安全地将汽车（即**过程**）返回到车道中心，从而最小化汽车的CTE。最终，将控制器视为一个函数，它不断地试图最小化给定CV相对于该变量的**设定点**的**误差**。
- en: So to achieve this, let's review the types of controllers available.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，让我们回顾一下可用的控制器类型。
- en: Types of controllers
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器类型
- en: 'There is a vast multitude of controllers that have been invented and implemented
    in control systems. The following is a sample of the different types of controllers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 已经发明并在控制系统中得到实施的控制器种类繁多。以下是一些不同类型控制器的示例：
- en: The PID controller and its offshoots
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PID控制器及其衍生品
- en: Optimal control
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最优控制
- en: Robust control
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲁棒控制
- en: State-space control
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态空间控制
- en: Vector control
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量控制
- en: The MPC
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MPC
- en: Linear-quadratic control
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性-二次控制
- en: 'Controllers can also be categorized by the types of systems they are used in,
    such as the following examples:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器也可以根据它们所使用的系统类型进行分类，以下是一些示例：
- en: Linear versus nonlinear
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性与非线性
- en: Analog (continuous) versus digital (discrete)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟（连续）与数字（离散）
- en: '**Single Input, Single Output** (**SISO**) versus **Multiple Input, Multiple
    Output** (**MIMO**)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单输入单输出**（**SISO**）与**多输入多输出**（**MIMO**）'
- en: By far the most common and widely used controllers in self-driving cars are
    the PID and MPC. PID controllers are used in SISO systems, while MPCs can be used
    in MIMO systems. This will be useful to remember when you consider which type
    of controller to select for your self-driving car. For example, if you only want
    to control the speed of the vehicle by implementing cruise control, you may want
    to select a SISO controller such as the PID. Conversely, if you want to control
    multiple outputs, such as the steering angle and speed in a single controller,
    you may choose to implement a MIMO controller such as the MPC.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在自动驾驶汽车中最常见和广泛使用的控制器是PID和MPC。PID控制器用于SISO系统，而MPC可以用于MIMO系统。当你考虑为你的自动驾驶汽车选择哪种类型的控制器时，这将是有用的。例如，如果你只想通过实施定速巡航来控制车辆的速度，你可能想选择一个SISO控制器，如PID。相反，如果你想在单个控制器中控制多个输出，如转向角度和速度，你可能选择实现一个MIMO控制器，如MPC。
- en: In the following section, you will be introduced to the basics of PIDs in preparation
    to understand the code you will learn.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解PID的基础知识，以便理解你将要学习的代码。
- en: PID
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PID
- en: 'The PID controller is the most ubiquitous form of control system, and has more
    than a century of research and implementation behind it. It has many flavors and
    subtle tweaks that can be made for specific applications. Here you will focus
    on learning the basics and implementing a simple controller for both the lateral
    and longitudinal control of your self-driving car. You will need both longitudinal
    and lateral PID controllers since PID is a SISO controller. Refer to the following
    figure which shows a typical PID block diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: PID控制器是最普遍的控制系统的形式，它背后有超过一个世纪的研究和实施。它有许多不同的版本和针对特定应用的细微调整。在这里，你将专注于学习基础知识并实现一个简单的控制器，用于自动驾驶汽车的横向和纵向控制。由于PID是SISO控制器，你需要纵向和横向PID控制器。参考以下典型的PID模块图：
- en: '![Figure 10.1 – PID block diagram](img/Figure_10.1_B16322.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – PID模块图](img/Figure_10.1_B16322.jpg)'
- en: Figure 10.1 – PID block diagram
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – PID模块图
- en: Let's look at a simple example of controlling the temperature in your home using
    *Figure 10.1*. Your home likely has a thermostat that allows you to set the temperature
    you would like. We will call the temperature you have chosen the **setpoint**
    or *r(t)*. The instantaneous temperature in your home is the **CV** or *y(t)*.
    Now your thermostat's job is to use the heater/cooler in your home to drive the
    temperature (the CV) in your home to the **setpoint**. The CV, *y(t)*, is fed
    back to a subtraction block to determine the **error**, *e(t) = r(t) - y(t)*,
    between the temperature you want in the home and the current temperature. The
    **error** is then passed to the P, I, and D control terms, which will each be
    multiplied by a **gain** value (usually represented by *K*), which are in turn
    summed together to produce the control input into your heater/cooler. Your heater/cooler
    has a certain power capacity, and your home has a certain volume of air. The combination
    of the heater/cooler capacity and the volume of your home determines how quickly
    your home will heat up or cool down when a new **setpoint** is chosen. This is
    known as the **process**, plant, or *transfer function* of your home. The process
    represents how a system's CV will respond to a change in **setpoint**, also known
    as the *step response*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过*图10.1*来观察一个简单的例子，即使用它来控制你家的温度。你家可能有一个允许你设定所需温度的恒温器。我们将你选择的温度称为**设定点**或*r(t)*。你家中的瞬时温度是**CV**或*y(t)*。现在恒温器的工作就是利用你家的加热器/冷却器来驱动家中的温度（CV）达到**设定点**。CV，*y(t)*，被反馈到减法模块以确定**误差**，*e(t)
    = r(t) - y(t)*，即家中的期望温度和当前温度之间的差异。然后**误差**被传递到P、I和D控制项，这些项各自乘以一个**增益**值（通常用*K*表示），然后相加以产生输入到加热器/冷却器的控制信号。你的加热器/冷却器有一定的功率容量，你的家有一定的空气体积。加热器/冷却器容量和家中的空气体积的组合决定了当你选择一个新的**设定点**时，家会多快加热或冷却。这被称为家的**过程**、**设备**或*传递函数*。这个过程代表了系统CV对**设定点**变化的响应，也称为*阶跃响应*。
- en: 'The following graph shows an example step response for a system. At time *t=0*,
    the **setpoint** (shown by the dotted line) is stepped from 0 to 0.95\. The response
    of the system is illustrated in the following figure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了一个系统的阶跃响应示例。在时间*t=0*时，**设定点**（由虚线表示）从0阶跃到0.95。系统的响应在以下图中展示：
- en: '![Figure 10.2 – Step response example](img/Figure_10.2_B16322.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 步响应示例](img/Figure_10.2_B16322.jpg)'
- en: Figure 10.2 – Step response example
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 步进响应示例
- en: We can see that this system and controller combined have created a response
    that will overshoot the setpoint and oscillate around it unil the response eventually
    settles on the setpoint value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个系统和控制器组合产生了一个响应，它将超过设定点并在其周围振荡，直到响应最终稳定在设定点值。
- en: Another example of a control system that is more relevant to this book would
    be the cruise control system in a self-driving car. In this case, the car's current
    speed is the CV, the desired speed is the setpoint, and the physical dynamics
    of the car and motor are the process. You will see later how to implement a cruise
    controller as well as a steering controller.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与本书更相关的控制系统示例将是自动驾驶汽车的巡航控制系统。在这种情况下，汽车当前的速度是CV，期望的速度是设定点，汽车和电机的物理动力学是过程。你将看到如何实现巡航控制器以及转向控制器。
- en: For now, let's understand what the proportional, integral, and derivative control
    terms of PID mean.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解PID控制中的比例、积分和微分控制术语的含义。
- en: Pedal to the metal!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 全油门加速！
- en: Have you ever thought about how you decide how much to press the throttle pedal
    when you are driving?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过在驾驶时如何决定踩油门踏板的力度？
- en: What factors determine how much you mash the pedal?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些因素决定了你踩油门的力度？
- en: –Is it how fast you are going versus how much faster you want to go?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: –这是你的速度与你想更快速度的对比吗？
- en: –Does it have to do with how quickly you are approaching your target speed?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: –这和您接近目标速度的速度有多快有关吗？
- en: –Do you continually check your speed to make sure you haven't drifted from your
    target speed?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: –你是否不断检查你的速度以确保你没有偏离目标速度？
- en: Think about all of these as we race through the next few sections.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们快速浏览接下来的几节内容时，考虑所有这些。
- en: Before we start discussing the P, I, and D control terms, we need to define
    what the **gain** is.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论P、I和D控制术语之前，我们需要定义**增益**是什么。
- en: The **gain** is a scaling factor used to weight a control term more or less
    heavily in the total control input to the **process**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**增益**是一个缩放因子，用于在总控制输入中对控制项进行加权或减权。'
- en: Understanding what proportional means
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解比例的含义
- en: 'In the cruise control example, you are trying to match your car''s speed to
    a setpoint speed. The difference between the setpoint speed and your car''s current
    speed is called the **error**. When the car''s speed is below the setpoint, the
    error is positive, and when it is above the setpoint, the error is negative:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在巡航控制示例中，你试图匹配你的汽车速度到一个设定点速度。设定点速度和你的汽车当前速度之间的差异被称为**误差**。当汽车速度低于设定点时，误差为正，当它高于设定点时，误差为负：
- en: '![](img/Formula_10_001.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_10_001.png)'
- en: 'The proportional control term simply takes ![](img/Formula_10_002.png) and
    multiplies it by a scaling factor known as the proportional **gain**:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 比例控制项只是将 ![](img/Formula_10_002.png) 乘以一个称为比例**增益**的缩放因子：
- en: '![](img/Formula_10_003.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_10_003.png)'
- en: What this means is that the larger the **error**, the larger the control input
    to the process, or in the case of cruise control, the larger the throttle input.
    This makes sense, right?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着误差越大，对过程的控制输入就越大，或者在这种情况下，油门输入就越大。这说得通，对吧？
- en: Let's check this with some actual numbers. First, let's define the throttle
    as going from 0 to 100%. Next, let's map that to the acceleration of a car, say,
    that of the Tesla Model X, at 37 m/s2\. *Ludicrous Mode*! So, 100% of the throttle
    gives an acceleration of 37 m/ s2.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些实际数字来验证这一点。首先，让我们定义油门从0到100%的变化。接下来，让我们将其映射到一辆汽车的加速度上，比如特斯拉Model X的加速度，为37
    m/s²。*疯狂模式*！所以，100%的油门提供了37 m/s²的加速度。
- en: 'If your setpoint speed is 100 km/h and you start from 0 km/h, then your current
    error is 100 km/h. Then, if you want maximum acceleration with an error of 100
    km/h, you could set your proportional gain to be 1:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设定点速度是100 km/h，而你从0 km/h开始，那么你当前的误差是100 km/h。然后，如果你想以100 km/h的误差实现最大加速度，你可以将你的比例增益设置为1：
- en: '![](img/Formula_10_004.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_10_004.png)'
- en: As your error in speed decreases, the throttle would also decrease until you
    reach a throttle input of zero at the point when the error is zero.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 随着速度误差的减小，油门也会减小，直到你达到误差为零时的零油门输入。
- en: 'Wait! Zero throttle means we are coasting. This would work great if there was
    no friction, air resistance, and so on, but we all know that isn''t the case.
    This means that you would never really stay at the target speed and would rather
    oscillate just below our target speed, leaving us with a steady-state bias:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！零油门意味着我们在滑行。如果没有摩擦、空气阻力等情况，这将非常有效，但我们都知道情况并非如此。这意味着你永远不会真正保持在目标速度，而会振荡在目标速度以下，给我们留下一个稳态偏差：
- en: '![Figure 10.3 – Steady-state bias in a proportional controller](img/Figure_10.3_B16322.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 比例控制器中的稳态偏差](img/Figure_10.3_B16322.jpg)'
- en: Figure 10.3 – Steady-state bias in a proportional controller
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 比例控制器中的稳态偏差
- en: Oh no – how do we maintain our target speed? No fear, we have the mighty integrator
    that can help bring us up to speed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不——我们如何保持目标速度？别担心，我们有一个强大的积分器可以帮助我们提高速度。
- en: Understanding the integral term
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解积分项
- en: 'Introducing the mighty integrator! The integrator term in PID seeks to address
    any steady-state bias in the system. It does this by integrating all the past
    errors in the system. Really, this just means that it is summing up all the errors
    we have seen at each time step:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍强大的积分器！PID中的积分器项旨在解决系统中的任何稳态偏差。它是通过整合系统中的所有过去误差来做到这一点的。实际上，这意味着它在每个时间步长上累加我们看到的所有误差：
- en: '![](img/Formula_10_005.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![公式 10_005](img/Formula_10_005.png)'
- en: 'We then take the total error and scale it with a gain, *K*I, like we did with
    the proportional term. Then, we use this result as a control input to the system
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用增益 *K*I 缩放总误差，就像我们处理比例项时做的那样。然后，我们将这个结果作为控制输入到系统中，如下所示：
- en: '![](img/Formula_10_006.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![公式 10_006](img/Formula_10_006.png)'
- en: In your cruise control example, the Model X's speed only briefly achieved the
    setpoint speed and then quickly dipped back down below as the proportional input
    became zero and the air resistance slowed it down. This means that if you summed
    up all the errors over time you would find that they are always positive and continue
    to grow.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的定速巡航控制示例中，Model X的速度只是短暂地达到了设定点速度，然后迅速下降到以下，因为比例输入变为零，空气阻力减慢了它的速度。这意味着如果你在时间上累加所有误差，你会发现它们始终是正的，并且继续增长。
- en: 'So, the further we go in time, the larger the integrator term, `total_error`speed,
    becomes. This means that if you choose `K`I appropriately, the throttle commanded
    will be greater than zero even when the instantaneous error is zero. Remember,
    we sum all the control terms to get the total throttle input. So far, we have
    the P and I terms, which give us the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着时间的推移，积分器项，`total_error`速度，变得越大。这意味着如果你选择 `K`I 适当，即使瞬时误差为零，油门命令也会大于零。记住，我们累加所有控制项以获得总油门输入。到目前为止，我们有P和I项，它们给我们以下结果：
- en: '![](img/Formula_10_007.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![公式 10_007](img/Formula_10_007.png)'
- en: Nice! Now you are oscillating around the setpoint instead of being biased below
    it. But you may ask, *how can we prevent the constant overshooting and undershooting
    of the speed setpoint, and instead stabilize at a nice smooth throttle application?*
    I thought you would never ask!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在你正在围绕设定点振荡，而不是低于它。但你可能会问，*我们如何防止速度设定点的持续超调和欠调，并稳定在平滑的油门应用上？* 我想你永远不会问这个问题！
- en: Derivative control to the rescue!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 导数控制来救命！
- en: Derivative term
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导数项
- en: 'The last trouble you must overcome is adjusting your throttle as you approach
    the setpoint without overshooting it. The derivative term helps with this by adjusting
    the throttle based on how quickly you are approaching the setpoint. In terms of
    the error, this means the rate of change of the error, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须克服的最后难题是在接近设定点时调整油门，而不会超过它。导数项通过根据你接近设定点的速度调整油门来帮助解决这个问题。从误差的角度来看，这意味着误差的变化率，如下所示：
- en: '![](img/Formula_10_008.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![公式 10_008](img/Formula_10_008.png)'
- en: 'When the preceding formula is simplified, we get the following, where `d` denotes
    change:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当先前的公式简化后，我们得到以下公式，其中 `d` 表示变化：
- en: '![](img/Formula_10_009.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![公式 10_009](img/Formula_10_009.png)'
- en: 'If the error is decreasing – meaning you are approaching the setpoint – the
    derivative term will be negative. This means that the derivative term will aim
    to reduce your total throttle since the throttle is now given by the sum of all
    the P, I, and D control terms. The following equation shows this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果误差在减小——这意味着你正在接近设定点——导数项将是负的。这意味着导数项将试图减少你的总油门，因为油门现在由所有P、I和D控制项的总和给出。以下方程展示了这一点：
- en: '![](img/Formula_10_010.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![公式 10_010](img/Formula_10_010.png)'
- en: Okay, you now know what each part of PID means in real terms. The real trick
    is tuning your `K`P, `K`I, and `K`D gains to make the car's speed and acceleration
    act as you want them to. That is beyond the scope of this book, but there are
    some great references at the end of the chapter for learning more about this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你现在知道PID的每个部分在实际情况中的含义了。真正的技巧是调整你的`K`P、`K`I和`K`D增益，使汽车的速度和加速度按照你的意愿行动。这超出了本书的范围，但本章末尾有一些很好的参考资料，可以了解更多关于这方面的内容。
- en: Next, you will learn about a more modern form of controller that is very popular
    in self-driving cars today – the MPC.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将了解一种更现代的控制形式，这种形式在今天的自动驾驶汽车中非常流行——MPC。
- en: Pump the brakes!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 刹车！
- en: What would you call a negative throttle?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你会称负油门为什么？
- en: MPC
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MPC
- en: The **MPC** is a modern and very versatile controller that is used in MIMO systems.
    This is perfect for your self-driving car, since you have multiple inputs such
    as the throttle, brake, and steering torque. You also have multiple outputs such
    as the lateral position relative to the lane and the car's speed. As you learned
    previously, PID would require two separate controllers (lateral and longitudinal)
    to control the car. With MPC you can do this all in one beautiful controller.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**MPC**是一种现代且非常通用的控制器，用于MIMO系统。这对于你的自动驾驶汽车来说非常完美，因为你有多达油门、刹车和转向扭矩等多个输入。你也有多个输出，如相对于车道的横向位置和汽车的速度。正如你之前所学的，PID需要两个单独的控制器（横向和纵向）来控制汽车。有了MPC，你可以在一个漂亮的控制器中完成所有这些。'
- en: MPC has become popular in recent years due to the increase in computing speed,
    which allows for the *online* optimization that is required to perform real-time
    driving tasks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算速度的提高，MPC近年来变得流行，这允许进行所需的*在线*优化，以执行实时驾驶任务。
- en: 'Before you can learn what the MPC does, let''s first contemplate what your
    magical brain does when you drive a car:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在你学习MPC做什么之前，让我们首先思考一下当你开车时，你的神奇大脑都在做什么：
- en: You select a destination.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你选择一个目的地。
- en: You plan your route (waypoints).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你规划你的路线（航点）。
- en: You execute your route within the bounds of the traffic laws, your car's dynamics
    and performance (*Ludicrous Mode, engage!*), your time constraints (*I'm late
    for a life-changing interview!*), and the traffic around you.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在遵守交通法规、你的车辆动力学和性能（*疯狂的驾驶模式，启动！*）、你的时间限制（*我迟到了一个改变一生的面试！*）以及你周围的交通状况的范围内执行你的路线。
- en: MPC works like you
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MPC工作方式就像你
- en: If you really think about how you drive, you are continually assessing the state
    of the cars around you, your car, the time until your destination, your position
    in the lane, your distance from the car in front of yours, the traffic signs and
    signals, your speed, your throttle position, your steering torque, your brake
    position, and so much more! At the same time, you are continually simulating various
    maneuvers you can execute based on the current state of traffic – for instance,
    *there is a car in the lane to my left so I can't go there*, *the car in front
    of me is going really slow*, *there isn't a car in the lane to my right but one
    is approaching quickly*, and *I need to get to this interview and I am running
    late*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真正思考一下你是如何驾驶的，你不断地评估你周围车辆的状态、你的车辆、到达目的地的时间、你在车道中的位置、你与前车之间的距离、交通标志和信号、你的速度、你的油门位置、你的转向扭矩、你的刹车位置，以及更多！同时，你也在不断地模拟基于当前交通状况你可以执行的多种操作——例如，*我的左边车道有辆车，所以我不能去那里*，*我前面的车开得很慢*，*我的右边车道没有车，但有一辆车正在快速接近*，*我需要赶到这个面试，我迟到了*。
- en: 'You are also constantly weighing the cost of each maneuver if executed, based
    on the following cost considerations:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也在不断地权衡如果执行任何操作的成本，基于以下成本考虑：
- en: 'The cost of being late to the interview: high!'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迟到面试的成本：高！
- en: 'The cost of breaking the law: high!'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 违反法律的成本：高！
- en: 'The cost of causing an accident: unfathomable!'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事故的成本：难以想象！
- en: 'The cost of using Ludicrous Mode: medium!'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用疯狂的驾驶模式的成本：中等！
- en: 'The cost of damaging your car: *is there something higher than infinity? Let''s
    pick that!*'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 损坏你的车的成本：*有什么比无限大还高？让我们选择那个！*
- en: 'You then quickly estimate the cost of any of your possible maneuvers:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你迅速估算任何可能的操作的成本：
- en: '*Passing in the left lane means I could crash into the car next to me and potentially
    cause an accident or damage my car, and still probably miss my interview.* The
    cost: astronomical!'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在左边车道超车意味着我可能会撞到旁边的车，可能引发事故或损坏我的车，而且可能还错过我的面试。成本：天文数字！*'
- en: '*I could continue in my lane behind this sloth of a car. This will make me
    late*. The cost: high!'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*我可以继续在这辆迟钝的汽车后面行驶。这将使我迟到*。成本：高！'
- en: '*Passing in the right lane will require Ludicrous Mode acceleration to make
    sure the approaching car doesn''t hit me*. The cost: medium!'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在右车道超车需要疯狂的加速，以确保接近的车辆不会撞到我*。成本：中等！'
- en: You choose the last of the preceding options, since it has the lowest cost of
    the simulated maneuvers based on the costs you have ascribed to each consideration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择上述选项中的最后一个，因为它基于你对每个考虑因素所赋予的成本，具有最低的模拟机动成本。
- en: Great, you have chosen a maneuver! Now you need to execute it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，你已经选择了机动！现在你需要执行它。
- en: You smash the Ludicrous Mode button for 5 seconds while you cinch your seatbelt
    until it feels like a boa constrictor and you chop your blinker on as if you were
    the *Karate Kid*! You grip the steering wheel with white-knuckle fury and then
    put the pedal to the metal as you visualize the power and majesty of the extra
    35 horses that thrust you back into your seat. You simultaneously crank the steering
    wheel to rail you into the right lane and fly by the sloth with adrenaline and
    a smug grin plastered on your face as you watch the previously approaching car
    fading into oblivion behind you!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你按下疯狂的按钮5秒钟，同时系紧安全带，直到感觉像一条响尾蛇，然后像《空手道小子》一样切换你的转向灯！你用白手紧握方向盘，然后全油门加速，想象着额外35匹马的力量把你推回座位。你同时转动方向盘，进入右车道，用肾上腺素和自信的笑容飞驰而过，看着之前接近的车辆在你身后消失在虚无中！
- en: Now that you are blissfully satisfied with your maneuver, you start the entire
    process over for the next maneuver and repeat until you arrive safely and on time
    for your interview! You did it!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对自己的机动感到无比满意，你开始整个过程，为下一个机动重复，直到你安全准时到达面试！你做到了！
- en: MPC pipeline
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MPC管道
- en: MPC takes a similar approach to dynamic driving tasks that humans do. MPC simply
    formalizes the driving tasks into mathematics and physics (with less thrill and
    excitement). The steps are very similar.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: MPC采用与人类动态驾驶任务相似的方法。MPC只是将驾驶任务形式化为数学和物理（少了些刺激和兴奋）。步骤非常相似。
- en: 'Establish constraints such as the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 建立如下约束：
- en: 'The vehicle''s dynamic model for estimating its state in the next time step:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 车辆的动态模型，用于估计下一个时间步的状态：
- en: The minimum turn radius
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小转弯半径
- en: The maximum steering angle
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大转向角度
- en: The maximum throttle
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大油门
- en: The maximum brake
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大制动
- en: The maximum lateral jerk (a derivative of acceleration)
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大横向急动（加速度的导数）
- en: The maximum longitudinal acceleration
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大纵向加速度
- en: 'Establish the cost functions, including the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立成本函数，包括以下内容：
- en: The cost of not being at the desired state
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不在期望状态的成本
- en: The cost of using actuators
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行器的成本
- en: The cost of sequential actuations
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序激活的成本
- en: The cost of using the throttle with steering
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用油门和转向的成本
- en: The cost of crossing lane lines
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 横穿车道线的成本
- en: The cost of collisions
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞的成本
- en: Next, simulate possible trajectories and the associated control inputs that
    obey the mathematical cost and constraints for the next *N* time steps.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，模拟可能的轨迹和相关的控制输入，这些输入在下一个 *N* 个时间步遵守数学成本和约束。
- en: Use an optimization algorithm to select the simulated trajectory with the lowest
    cost.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用优化算法选择具有最低成本的模拟轨迹。
- en: Execute the control inputs for one time step.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个时间步的控制输入。
- en: Measure the state of the system at the new time step.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新时间步测量系统的状态。
- en: Repeat *steps 3–6*.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *步骤3–6*。
- en: There is a lot more detail in each of these steps and you are encouraged to
    learn more by following the links in the *Further reading* section at the end
    of the chapter. For now, here are some quick guidelines to think about.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都有很多细节，你被鼓励通过查看章节末尾的“进一步阅读”部分中的链接来了解更多。现在，这里有几点快速指南供你思考。
- en: '**Sample time, TS**:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**样本时间，TS**：'
- en: This is the discrete time step at which you repeat *steps* *3–7* of the MPC
    pipeline.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是重复MPC管道 *步骤3–7* 的离散时间步。
- en: Usually, TS is selected so that there are at least 10 time steps in the open-loop
    rise time.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，TS被选择，以确保在开环上升时间中至少有10个时间步。
- en: '**Prediction horizon, N**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**预测范围，N**：'
- en: This is the number of time steps into the future for which you will simulate
    the car state and control inputs.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是你将模拟汽车状态和控制输入的未来时间步数。
- en: Usually, 20 time steps are used to cover the open-loop response of the car.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，使用20个时间步来覆盖汽车的开环响应。
- en: 'You can also examine the following figure, which illustrates many of the concepts
    and parameters you''ve learned that constitute the MPC problem:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看以下图表，它说明了构成MPC问题的许多你已学到的概念和参数：
- en: '![Figure 10.4 – Concepts and parameters that constitute the MPC problem](img/Figure_10.4_B16322.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 构成MPC问题的概念和参数](img/Figure_10.4_B16322.jpg)'
- en: Figure 10.4 – Concepts and parameters that constitute the MPC problem
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 构成MPC问题的概念和参数
- en: 'Here is a quick description of each of the parameters shown in the preceding
    graph:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对前面图表中显示的每个参数的简要描述：
- en: The **Reference Trajectory** is the desired trajectory of the controlled variable;
    for example, the lateral position of the vehicle in the lane.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参考轨迹**是受控变量的期望轨迹；例如，车辆在车道中的横向位置。'
- en: The **Predicted Output** is the prediction of the controlled variable state
    after the predicted control input has been applied. It is informed by the dynamic
    model of the system, the constraints, and the previously measured output.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测输出**是在应用预测控制输入后对受控变量状态的预测。它由系统的动态模型、约束和先前测量的输出所指导。'
- en: The **Measured Output** is the measured past state of the controlled variable.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量输出**是受控变量的过去测量状态。'
- en: The **Predicted Control Input** is the system's prediction of the control actuations
    that must be performed to achieve the predicted output.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测控制输入**是系统对必须执行以实现预测输出的控制动作的预测。'
- en: The **Past Control Input** is the actual control actuations that were performed
    in the past, leading up to the current state.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过去控制输入**是在当前状态之前实际执行的控制动作。'
- en: MPC is a powerful though resource-intensive control algorithm that can sometimes
    simplify your architecture by allowing MIMO to fit into a single module.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: MPC是一种强大但资源密集的控制算法，有时可以通过允许MIMO适应单个模块来简化你的架构。
- en: This is a lot to take in at once, but if you have made it this far, you are
    in luck! In the next section, we will dive into the real code that you can use
    to control your self-driving car in CARLA using PID!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次需要吸收的内容很多，但如果你已经走到这一步，你很幸运！在下一节中，我们将深入探讨你可以用来在CARLA中使用PID控制自动驾驶汽车的真正代码！
- en: Implementing PID in CARLA
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CARLA中实现PID
- en: Congratulations on making it to the truly fun and hands-on portion of this chapter.
    You have learned a lot so far about PIDs and MPCs. Now it is time to put that
    knowledge to use!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你来到了本章真正有趣且实用的部分。到目前为止，你已经学到了很多关于PID和MPC的知识。现在是时候将所学知识付诸实践了！
- en: 'In this section, we will walk through all the relevant code that is available
    on GitHub for this chapter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将遍历GitHub上本章可用的所有相关代码：
- en: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars)'
- en: You will learn how to apply the equations and concepts of PID in Python and
    then interface with CARLA.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何在Python中应用PID的方程和概念，然后与CARLA进行接口。
- en: First, you will need to install CARLA.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装CARLA。
- en: Installing CARLA
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装CARLA
- en: The CARLA project has a Linux and Windows Quick Start guide available at [https://carla.readthedocs.io/en/latest/start_quickstart/](https://carla.readthedocs.io/en/latest/start_quickstart/).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: CARLA项目在[https://carla.readthedocs.io/en/latest/start_quickstart/](https://carla.readthedocs.io/en/latest/start_quickstart/)提供了Linux和Windows快速入门指南。
- en: 'For Linux, the CARLA files will be located here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，CARLA文件将位于这里：
- en: '[PRE0]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside this folder you will find a `/bin/` folder that contains the executable
    simulator script, which you can run with the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，你可以找到一个`/bin/`文件夹，其中包含可执行的模拟器脚本，你可以使用以下命令运行它：
- en: '[PRE1]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `–opengl` tag runs the simulator using OpenGL instead of Vulkan. Depending
    on your system setup and GPU, you may drop `–opengl`. You should see a simulator
    environment window pop up that looks like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`–opengl`标签使用OpenGL而不是Vulkan来运行模拟器。根据你的系统设置和GPU，你可能需要省略`–opengl`。你应该会看到一个看起来像这样的模拟器环境窗口弹出：'
- en: '![Figure 10.5 – CARLA simulator environment opening](img/Figure_10.5_B16322.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – CARLA模拟器环境打开](img/Figure_10.5_B16322.jpg)'
- en: Figure 10.5 – CARLA simulator environment opening
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – CARLA模拟器环境打开
- en: 'For this chapter, you will be primarily working from the `examples` folders
    located at the following destinations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将主要从以下位置的 `examples` 文件夹中工作：
- en: 'Linux: `/opt/carla-simulator/PythonAPI/examples`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: `/opt/carla-simulator/PythonAPI/examples`'
- en: 'Windows: `WindowsNoEditor\PythonAPI\examples`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `WindowsNoEditor\PythonAPI\examples`'
- en: This folder contains all the example CARLA scripts that teach you the basics
    of the CARLA API. In this folder, you will find a script called `automatic_control.py`,
    which is the basis of the script you will be working with throughout the rest
    of this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包含所有示例 CARLA 脚本，这些脚本教您 CARLA API 的基础知识。在这个文件夹中，您将找到一个名为 `automatic_control.py`
    的脚本，这是本章其余部分您将使用的脚本的基础。
- en: Now that you have installed and successfully run the simulator, you will clone
    the `Packt-Town04-PID.py` script that contains the PID controller.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装并成功运行了模拟器，您将克隆包含 PID 控制器的 `Packt-Town04-PID.py` 脚本。
- en: Cloning Packt-Town04-PID.py
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆 Packt-Town04-PID.py
- en: You can find the repository for this chapter under `Chapter10` at [https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `Chapter10` 下的 [https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars)
    找到本章的代码库。
- en: You can clone the entire repo to any location on your machine.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将整个仓库克隆到您机器上的任何位置。
- en: 'You will then need to link the `Packt-Town04-PID.py` script into the `examples`
    folder previously discussed. You can use this command in Linux:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要将 `Packt-Town04-PID.py` 脚本链接到之前讨论过的 `examples` 文件夹中。您可以在 Linux 中使用以下命令：
- en: '[PRE2]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that you have the script and have linked it to the correct location within
    CARLA, let's walk through the code and what it does.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了脚本，并且已经将其链接到 CARLA 中的正确位置，让我们来浏览一下代码以及它所做的工作。
- en: Walking through your Packt-Town04-PID.py control script
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览您的 Packt-Town04-PID.py 控制脚本
- en: 'Your `Packt-Town04-PID.py` code is based on the `automatic_control.py` example
    script and is pieced together from the relevant snippets of code located in the
    `/opt/carla-simulator/PythonAPI/carla/agents` subfolders, namely, the following
    scripts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `Packt-Town04-PID.py` 代码基于 `automatic_control.py` 示例脚本，并从 `/opt/carla-simulator/PythonAPI/carla/agents`
    子文件夹中的相关代码片段拼接而成，具体包括以下脚本：
- en: '`behavior_agent.py`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`behavior_agent.py`'
- en: '`local_planner.py`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_planner.py`'
- en: '`controller.py`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controller.py`'
- en: '`agent.py`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agent.py`'
- en: This is a very good way to learn how to interact with the CARLA simulator and
    learn the API without having to write everything from scratch.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常好的学习如何与 CARLA 模拟器交互以及学习 API 的方法，而无需从头开始编写所有内容。
- en: Finding the CARLA module
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找 CARLA 模块
- en: 'If you now look at `Packt-Town04-PID.py`, the first thing that you might notice
    after the usual imports is this block of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看 `Packt-Town04-PID.py`，您可能会注意到在常规导入之后，这个代码块：
- en: '[PRE3]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This block loads an egg file containing the code for CARLA, which is in the
    `/opt/carla-simulator/PythonAPI/carla/dist/` folder.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块加载了一个包含 CARLA 代码的 egg 文件，该文件位于 `/opt/carla-simulator/PythonAPI/carla/dist/`
    文件夹中。
- en: Classes of interest
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关类
- en: 'After this, you will probably notice that the code is organized into the following
    classes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可能会注意到代码被组织成以下类：
- en: '`World`: The virtual world where our vehicle moves, including the map and all
    the actors (such as vehicles, pedestrians, and sensors).'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`World`：我们的车辆移动的虚拟世界，包括地图和所有演员（如车辆、行人和传感器）。'
- en: '`KeyboardControl`: This reacts to the keys pressed by the user and has some
    logic to convert the binary on/off keys for steering, braking, and accelerating
    to a wider range of values, based on how much time they are pressed, making the
    car much easier to control.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyboardControl`：这个类响应用户按下的键，并有一些逻辑将转向、制动和加速的二进制开/关键转换为更广泛的值范围，这取决于它们被按下的时间长短，从而使汽车更容易控制。'
- en: '`HUD`: This renders all the information related to the simulation including
    the speed, steering, and throttle. It manages the notifications that can show
    some information to the user for a few seconds.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HUD`：这个类渲染与模拟相关的所有信息，包括速度、转向和油门。它管理可以显示几秒钟信息的通知。'
- en: '`FadingText`: This class is used by the `HUD` class to show notifications that
    disappear after a few seconds.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FadingText`：这个类被 `HUD` 类用来显示几秒钟后消失的通知。'
- en: '`HelpText`: This class displays some text using `pygame`, a gaming library
    used by CARLA.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelpText`：这个类使用 CARLA 使用的游戏库 `pygame` 显示一些文本。'
- en: '`CollisionSensor`: This is a sensor that can detect collisions.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionSensor`：这是一个可以检测碰撞的传感器。'
- en: '`LaneInvasionSensor`: This is a sensor that can detect that you crossed a lane
    line.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LaneInvasionSensor`: 这是一个可以检测到你跨越车道线的传感器。'
- en: '`GnssSensor`: This is a GPS/GNSS sensor that provides the GNSS position inside
    the OpenDRIVE map.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GnssSensor`: 这是一个提供OpenDRIVE地图内GNSS位置的GPS/GNSS传感器。'
- en: '`CameraManager`: This is a class that manages the camera and prints it.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CameraManager`: 这是一个管理相机并打印相机的类。'
- en: '`Agent`: This is the base class to define an agent in the game.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent`: 这是定义游戏中的代理的基类。'
- en: '`AgentState`: This is a class to represent the possible states of the agent.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AgentState`: 这是一个表示代理可能状态的类。'
- en: '`BehaviorAgent`: This class implements an agent that navigates the world to
    reach a destination by computing the shortest possible path to it.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorAgent`: 这个类实现了一个通过计算到达目的地的最短路径来导航世界的代理。'
- en: '`LocalPlanner`: This class implements a trajectory to follow by generating
    waypoints on the fly. It also calls the `VehiclePIDController` class with the
    appropriate gains. This is where the magic happens for this chapter.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalPlanner`: 这个类通过动态生成航点来实现一个要跟随的轨迹。它还调用带有适当增益的`VehiclePIDController`类。这就是本章魔法发生的地方。'
- en: '`VehiclePIDController`: This class calls the lateral and longitudinal controllers.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VehiclePIDController`: 这个类调用横向和纵向控制器。'
- en: '`PIDLongitudinalController`: This class holds the PID math that you have been
    learning about for cruise control.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PIDLongitudinalController`: 这个类包含了你一直在学习的用于定速巡航的PID数学。'
- en: '`PIDLateralController`: This class holds the PID math for steering control
    to keep your car following the waypoints generated by the `LocalPlanner` class.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PIDLateralController`: 这个类包含了用于转向控制的PID数学，以保持你的车辆跟随由`LocalPlanner`类生成的航点。'
- en: 'There are also a couple of other notable methods:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些其他值得注意的方法：
- en: '`main()`: This is mostly dedicated to parsing the arguments received by the
    OS.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`: 这主要致力于解析操作系统接收到的参数。'
- en: '`game_loop()`: This mostly initializes `pygame`, the CARLA client, and all
    the related objects. It also implements the game loop where, 60 times per second,
    the keys are analyzed and the most updated image is shown on the screen.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game_loop()`: 这主要初始化`pygame`、CARLA客户端以及所有相关对象。它还实现了游戏循环，每秒60次分析按键并显示最新的图像在屏幕上。'
- en: Setting the world
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置世界
- en: 'Inside the `game_loop()` method you will find where to set the world map. It
    is currently set to `Town04`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`game_loop()`方法中，你可以找到设置世界地图的位置。它目前设置为`Town04`：
- en: '[PRE4]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Car personalization
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 车辆个性化
- en: 'If you are a car enthusiast who would like to choose your car model and color,
    you can do so with this code inside the `World()` class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个想要选择你的车型和颜色的汽车爱好者，你可以通过在`World()`类内的代码中这样做：
- en: '[PRE5]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Spawn point
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成点
- en: 'The next thing you may want to change is the spawn point of the vehicle in
    the map. You can do this by picking a different index for `spawn_points[0]`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要更改的下一个东西是地图中车辆的生成点。你可以通过为`spawn_points[0]`选择不同的索引来完成此操作：
- en: '[PRE6]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you have gone through your customization and understand the layout
    of the classes and what they do, we will now dive into the meat of this chapter's
    code – the PID controllers!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了自定义并了解了类及其功能，我们将深入本章代码的核心——PID控制器！
- en: PIDLongitudinalController
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PIDLongitudinalController
- en: This is your cruise control and is responsible for actuating the throttle and
    brake. Do you remember earlier when we tickled your brain and asked what a negative
    throttle would be called? Well, the answer here is the brake. So any time the
    controller calculates a negative throttle input, it will actuate the brake with
    the control value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的定速巡航，负责操作油门和刹车。你还记得我们之前刺激你的大脑并问一个负油门会被叫什么吗？好吧，这里的答案是刹车。所以每当控制器计算出一个负油门输入时，它将使用控制值激活刹车。
- en: Gains
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收益
- en: 'This gains class is initialized with the PID gains that have been tuned by
    the CARLA team:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个增益类使用CARLA团队调整过的PID增益初始化：
- en: '[PRE7]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The values are set back in the `LocalPlanner` class in the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值在以下代码中的`LocalPlanner`类中设置回：
- en: '[PRE8]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Gain scheduling
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增益调度
- en: 'Notice that there are different gains based on highway versus city driving.
    The gains are scheduled in `LocalPlanner` based on the current speed of the car:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根据高速公路和城市驾驶的不同，有不同的增益。增益根据汽车当前的速度在`LocalPlanner`中进行调度：
- en: '[PRE9]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: PID math
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PID数学
- en: 'And now for the PID implementation math you have been waiting for! The `_pid_control()`
    method contains the heart of the PID controller and the calculations that you
    learned in the *PID* subsection of the *Types of controllers* section:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候展示你一直等待的PID实现数学了！`_pid_control()` 方法包含了PID控制器的核心以及你在“控制器类型”部分的“PID”子部分中学到的计算：
- en: 'First, we calculate the error in the speed:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们计算速度误差：
- en: '[PRE10]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we add the current error to the error buffer so we can use it later to
    calculate the integral and derivative terms:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将当前误差添加到误差缓冲区中，以便稍后用于计算积分和导数项：
- en: '[PRE11]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, if the error buffer has at least two values in it, we calculate the integral
    and derivative terms:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果误差缓冲区中至少有两个值，我们计算积分和导数项：
- en: '[PRE12]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we calculate the derivative term by subtracting the previous error value
    from the current error value and divide that by the **sampling time**:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过从当前误差值中减去前一个误差值并除以**采样时间**来计算导数项：
- en: '[PRE13]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we calculate the integral term by summing all the errors we have seen
    and multiplying by the **sampling time**:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过将所有观察到的误差求和并乘以**采样时间**来计算积分项：
- en: '[PRE14]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we don''t have enough in the buffer, we simply set our integral and derivative
    terms to zero:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果缓冲区中没有足够的内容，我们只需将积分和导数项设置为零：
- en: '[PRE15]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we calculate the control input by summing all the gain-weighted PID
    terms and returning the value clipped to ±1.0\. Recall the math for this is as
    follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过将所有增益加权的PID项相加并返回值裁剪到±1.0来计算控制输入。回想一下，这个数学计算如下：
- en: '![](img/Formula_10_011.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_10_011.png)'
- en: 'The throttle is commanded if the value is positive, otherwise, the brake is
    commanded:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值是正的，则命令油门，否则命令刹车：
- en: '[PRE16]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that you know the basic math for a PID, you will now see how to implement
    this in the lateral PID controller.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了PID的基本数学，接下来我们将看到如何在横向PID控制器中实现这一点。
- en: PIDLateralController
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PIDLateralController
- en: This is your steering control and is responsible for actuating the steering
    angle.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的转向控制，负责执行转向角度。
- en: Gains
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增益
- en: 'This class is initialized with the PID gains that have been tuned by the CARLA
    team:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用CARLA团队调校的PID增益进行初始化：
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The values set back in the `LocalPlanner` class are in the following code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LocalPlanner` 类中设置的值如下所示：
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Gain scheduling
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增益调度
- en: 'Notice that there are different gains based on highway versus city driving
    just as there were for the longitudinal control. The gains are scheduled in `LocalPlanner`
    based on the current speed of the car:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与纵向控制一样，根据高速公路和城市驾驶的不同，存在不同的增益。增益在 `LocalPlanner` 中根据当前车速进行调度：
- en: '[PRE19]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: PID math
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PID数学
- en: 'The math for the lateral control is a little different but has the same basic
    principle. Again, the math is in the `_pid_control()` method. Let''s see how to
    go about it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 横向控制的数学计算略有不同，但基本原理相同。再次强调，数学计算在 `_pid_control()` 方法中。让我们看看如何进行：
- en: 'First, we find the starting point of our vehicle vector in global coordinates:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在全局坐标系中找到车辆向量的起点：
- en: '[PRE20]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we find the end of our vehicle vector in global coordinates using the
    yaw angle of the vehicle:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用车辆的偏航角在全局坐标系中找到车辆向量的终点：
- en: '[PRE21]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we create the vehicle vector, which is the direction our vehicle is pointing
    in global coordinates:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建车辆向量，这是车辆在全局坐标系中的指向：
- en: '[PRE22]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we calculate the vector from the vehicle''s position to the next waypoint:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们计算从车辆位置到下一个航点的向量：
- en: '[PRE23]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we find the angle between the vehicle vector and the vector pointing
    from the vehicle location to the waypoint. This is essentially our steering error:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们找到车辆向量和从车辆位置指向航点的向量之间的角度。这本质上就是我们的转向误差：
- en: '[PRE24]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we find the cross product of the two vectors to determine which side
    of the waypoint we are on:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们找到两个向量的叉积以确定我们位于航点的哪一侧：
- en: '[PRE25]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we adjust the angle `_dot` value to be negative if the cross product
    was negative:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果叉积是负的，我们调整 `_dot` 值使其为负：
- en: '[PRE26]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we append the current steering error to our error buffer:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将当前的转向误差追加到我们的误差缓冲区中：
- en: '[PRE27]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, if the error buffer has at least two values in it, we calculate the integral
    and derivative terms:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果误差缓冲区中至少有两个值，我们计算积分和导数项：
- en: '[PRE28]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we calculate the derivative term by subtracting the previous error value
    from the current error value and divide by the **sampling time**:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过从当前误差值中减去前一个误差值并除以**采样时间**来计算导数项：
- en: '[PRE29]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we calculate the integral term by summing all the errors we have seen
    and multiplying by the sampling time:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过求和所有已看到的误差并乘以采样时间来计算积分项：
- en: '[PRE30]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we don''t have enough in the buffer, we simply set our integral and derivative
    terms to zero:'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果缓冲区中不足够，我们只需将积分和导数项设置为0：
- en: '[PRE31]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we calculate the control input by summing all the gain-weighted PID
    terms and returning the value clipped to ±1.0\. We haven''t seen this yet for
    steering, but it works the same as for speed:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过求和所有增益加权的PID项，并返回值裁剪到±1.0来计算控制输入。我们还没有看到转向的情况，但它与速度的工作方式相同：
- en: '![](img/Formula_10_012.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_10_012.png)'
- en: 'A negative steering angle simply means *turn left* while positive means *turn
    right*:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 负的转向角度简单意味着*向左转*，而正的则意味着*向右转*：
- en: '[PRE32]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that you have learned how to implement the PID control in Python, it is
    time to see it working!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何在Python中实现PID控制，是时候看看它的工作效果了！
- en: Running the script
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'You should first ensure that you have started the CARLA simulator by running
    the following code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该确保已经通过运行以下代码启动了CARLA模拟器：
- en: '[PRE33]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then in a new Terminal window, you can run the `Packt-Town04-PID.py` script
    and watch the magic unfold. The command to run the script is as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在新的终端窗口中，你可以运行`Packt-Town04-PID.py`脚本，并观看魔法展开。运行脚本的命令如下：
- en: '[PRE34]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see a new window pop up that looks like the following screenshot:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个新窗口弹出，其外观如下截图所示：
- en: '![Figure 10.6 – Packt-Town04-PID.py runtime window](img/Figure_10.6_B16322.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – Packt-Town04-PID.py运行窗口](img/Figure_10.6_B16322.jpg)'
- en: Figure 10.6 – Packt-Town04-PID.py runtime window
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – Packt-Town04-PID.py运行窗口
- en: Congratulations! You made a car steer and accelerate itself using nothing but
    a keyboard and your newfound knowledge! In the next section, you will learn how
    to apply an MPC controller using C++.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你只用键盘和你的新知识就成功地让一辆车自己转向和加速！在下一节中，你将学习如何使用C++应用MPC控制器。
- en: An example MPC in C++
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个C++中的MPC示例
- en: A full implementation of MPC is beyond the scope of this chapter but you can
    review this example implementation written in C++ at [https://github.com/Krishtof-Korda/CarND-MPC-Project-Submission/blob/master/src/MPC.cpp](https://github.com/Krishtof-Korda/CarND-MPC-Project-Submission/blob/master/src/MPC.cpp).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: MPC的完整实现超出了本章的范围，但你可以查看这个用C++编写的示例实现[https://github.com/Krishtof-Korda/CarND-MPC-Project-Submission/blob/master/src/MPC.cpp](https://github.com/Krishtof-Korda/CarND-MPC-Project-Submission/blob/master/src/MPC.cpp)。
- en: The following example will walk you through the implementation of an MPC module
    that you can use in place of a PID controller for both lateral and longitudinal
    control. Recall that MPC is a MIMO system, meaning you can control multiple outputs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将指导你实现一个MPC模块，你可以用它来替代PID控制器进行横向和纵向控制。回想一下，MPC是一个MIMO系统，这意味着你可以控制多个输出。
- en: 'The following example shows all the basic components and code you''ll need
    to build an MPC controller:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了构建MPC控制器所需的所有基本组件和代码：
- en: 'First, use the following code to fit a polynomial to your **prediction horizon**
    waypoints:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下代码将多项式拟合到你的**预测范围**航点上：
- en: '[PRE35]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use the following code to calculate cross-tracking errors:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码来计算交叉跟踪误差：
- en: '[PRE36]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the following code to calculate orientation errors:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码来计算方向误差：
- en: '[PRE37]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we use `MPC.cpp` to structure the vector so that it can be passed to an
    optimizer. The optimizer takes all the state and actuator variables in a single
    vector. So, here, you will establish the start index of each variable in the vector:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`MPC.cpp`来构建向量，以便将其传递给优化器。优化器将所有状态和执行器变量放在一个单一的向量中。因此，在这里，你将确定向量中每个变量的起始索引：
- en: '[PRE38]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, assign all the adjustable weights for your costs:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，分配你成本的所有可调整权重：
- en: '[PRE39]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After that, you can establish your cost functions based on those weights.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你可以根据这些权重建立你的成本函数。
- en: 'For this, you must add a cost, if you are at the relative state compared to
    the reference state. In other words, add a cost for not being on the desired path,
    heading, or velocity, as follows:'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个，你必须添加一个成本，如果你相对于参考状态处于相对状态。换句话说，添加一个成本，以表示不在期望路径、航向或速度上，如下所示：
- en: '[PRE40]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, you need to add a cost for the use of actuators. This helps minimize
    the actuations if they are not needed. Think of this as the car likes to be lazy
    and will only command an actuation if the cost is low enough:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你需要为执行器的使用添加一个成本。这有助于在不需要时最小化执行器的激活。想象一下，这辆车喜欢偷懒，只有当成本足够低时才会发出执行命令：
- en: '[PRE41]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, you need to add a cost for sequential use of the actuators. This will
    help minimize oscillatory use of the actuators, such as when a new driver jumps
    between the throttle and the brake clumsily:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要为执行器的顺序使用添加成本。这将有助于最小化执行器的振荡使用，例如当新驾驶员笨拙地在油门和刹车之间跳跃时：
- en: '[PRE42]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, it''s a good idea to add a cost for using the throttle while at high
    steering angles. You don''t want to mash the throttle in the middle of a turn
    and spin out of control:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个在高速转向角度时使用油门的成本是个好主意。你不想在转弯中猛踩油门而失控：
- en: '[PRE43]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, establish the initial constraints:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，建立初始约束：
- en: '[PRE44]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we''ve done this, we can establish the vehicle model constraints based
    on the state variable and the `t+1`; that is, the current time step:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经做了这些，我们可以根据状态变量和`t+1`；即当前时间步，建立车辆模型约束：
- en: '[PRE45]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, create the variables for the state at time `t`; that is, the previous
    time step:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建时间`t`的状态变量；即前一个时间步：
- en: '[PRE46]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you need to ensure you only consider the actuation at time `t`. So, here,
    we only consider the steering (`delta0`) and the acceleration (`a0`) at time `t`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要确保你只考虑时间`t`的驱动。因此，在这里，我们只考虑时间`t`的转向（`delta0`）和加速度（`a0`）：
- en: '[PRE47]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, you need the constraint of the waypoint line you are trying to follow.
    This is done by creating a polynomial that''s fitted to the waypoints. This is
    dependent on the number of coefficients. For example, a second-order polynomial
    will have three coefficients:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要添加你试图跟随的航点线的约束。这是通过创建一个拟合航点的多项式来完成的。这取决于系数的数量。例如，一个二阶多项式将有三项系数：
- en: '[PRE48]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Using the same coefficients, you can establish the constraint for the desired
    heading of the car:'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用相同的系数，你可以为汽车期望的航向建立约束：
- en: '[PRE49]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, you need to create constraints for the vehicle model. In this case,
    a simplified vehicle model known as the bicycle model can be used:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要为车辆模型创建约束。在这种情况下，可以使用一个简化的车辆模型，称为自行车模型：
- en: '[PRE50]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Great! You now have at least an example of how to code an MPC in C++. You can
    take this basic example and translate it to any language that you need for your
    control application. You have another weapon in your arsenal of control knowledge!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你现在至少有一个如何在C++中编码MPC的例子。你可以将这个基本示例转换为你的控制应用所需的任何语言。你在控制知识库中又多了一件武器！
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! You now have a lateral and longitudinal controller for a self-driving
    car! You should be proud of what you have learned and applied in this chapter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经拥有了一个自动驾驶汽车的横向和纵向控制器！你应该为你在本章中学到并应用的知识感到自豪。
- en: You have learned about the two most ubiquitous controllers, namely, the PID
    and MPC. You learned that PIDs are well suited for SISO systems and are very efficient,
    but require several controllers to control multiple outputs. Meanwhile, you also
    learned that MPCs are suited for MIMO systems with enough resources to continually
    optimize in real time at each time step.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了两种最普遍的控制器，即PID和MPC。你了解到PID非常适合SISO系统，并且非常高效，但需要多个控制器来控制多个输出。同时，你也了解到MPC适合具有足够资源在每一步实时不断优化的MIMO系统。
- en: With this, you have trudged through the minutia of the mathematics and models
    and emerged with your very own PID controller implemented in CARLA and Python.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你已经艰难地穿越了数学和模型的细节，并实现了你自己的PID控制器，在CARLA和Python中实现。
- en: In the next chapter, you are going to learn how to build maps and localize your
    self-driving car so you always know where you are in the world!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何构建地图并定位你的自动驾驶汽车，这样你就可以始终知道你在世界中的位置！
- en: Questions
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Having read this chapter, you should be able to answer the following questions:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 读完这一章后，你应该能够回答以下问题：
- en: What controller type is best suited for a vehicle with lower computing resources?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么控制器类型最适合计算资源较低的车辆？
- en: What does the integral term of a PID controller correct for?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PID控制器的积分项是用来纠正什么的？
- en: What does the derivative term of a PID controller correct for?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PID控制器的导数项是用来纠正什么的？
- en: What is the difference between a cost and a constraint in an MPC?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MPC中的成本和约束有什么区别？
- en: Further reading
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Control theory: [https://en.wikipedia.org/wiki/Control_theory#Main_control_strategies](https://en.wikipedia.org/wiki/Control_theory#Main_control_strategies)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制理论：[https://en.wikipedia.org/wiki/Control_theory#Main_control_strategies](https://en.wikipedia.org/wiki/Control_theory#Main_control_strategies)
- en: '*Self-Tuning PID Controller for Autonomous Car Tracking in Urban Traffic*:
    [http://oa.upm.es/30015/1/INVE_MEM_2013_165545.pdf](http://oa.upm.es/30015/1/INVE_MEM_2013_165545.pdf)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*城市交通中自动驾驶汽车跟踪的自调PID控制器*: [http://oa.upm.es/30015/1/INVE_MEM_2013_165545.pdf](http://oa.upm.es/30015/1/INVE_MEM_2013_165545.pdf)'
- en: 'The Twiddle algorithm for tuning PID controllers: [https://martin-thoma.com/twiddle/](https://martin-thoma.com/twiddle/)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '调节PID控制器的Twiddle算法: [https://martin-thoma.com/twiddle/](https://martin-thoma.com/twiddle/)'
- en: '*Lateral Tracking Control for the Intelligent Vehicle Based on Adaptive PID
    Neural Network*: [https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492364/](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492364/)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于自适应PID神经网络的智能车辆横向跟踪控制*: [https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492364/](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5492364/)'
- en: '*MPC-Based Approach to Active Steering for Autonomous Vehicle Systems*: [https://borrelli.me.berkeley.edu/pdfpub/pub-6.pdf](https://borrelli.me.berkeley.edu/pdfpub/pub-6.pdf)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于MPC的主动转向方法，用于自动驾驶车辆系统*: [https://borrelli.me.berkeley.edu/pdfpub/pub-6.pdf](https://borrelli.me.berkeley.edu/pdfpub/pub-6.pdf)'
- en: '*Kinematic and Dynamic Vehicle Models for Autonomous Driving Control Design*:
    [https://borrelli.me.berkeley.edu/pdfpub/IV_KinematicMPC_jason.pdf](https://borrelli.me.berkeley.edu/pdfpub/IV_KinematicMPC_jason.pdf)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用于自动驾驶控制设计的运动学和动力学车辆模型*: [https://borrelli.me.berkeley.edu/pdfpub/IV_KinematicMPC_jason.pdf](https://borrelli.me.berkeley.edu/pdfpub/IV_KinematicMPC_jason.pdf)'
