- en: Video Surveillance, Background Modeling, and Morphological Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频监控、背景建模和形态学操作
- en: In this chapter, we are going to learn how to detect a moving object in a video
    taken from a static camera. This is used extensively in video surveillance systems.
    We will discuss the different characteristics that can be used to build this system.
    We will learn about background modeling and see how we can use it to build a model
    of the background in a live video. Once we do this, we will combine all the blocks
    to detect the object of interest in the video.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何检测从静态摄像机拍摄的视频中的移动对象。这在视频监控系统中被广泛使用。我们将讨论可以用来构建此系统的不同特性。我们将了解背景建模，并了解我们如何使用它来构建实时视频中的背景模型。一旦我们这样做，我们将结合所有模块来检测视频中的感兴趣对象。
- en: 'By the end of this chapter, you should be able to answer the following questions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够回答以下问题：
- en: What is naive background subtraction?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是朴素背景减法？
- en: What is frame differencing?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是帧差分？
- en: How do we build a background model?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何构建背景模型？
- en: How do we identify a new object in a static video?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何识别静态视频中的新对象？
- en: What is morphological image processing and how is it related to background modeling?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形态学图像处理是什么，它与背景建模有何关系？
- en: How do we achieve different effects using morphological operators?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用形态学算子实现不同的效果？
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires familiarity with the basics of the C++ programming language.
    All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_08](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_08).
    The code can be executed on any operating system, though it is only tested on
    Ubuntu.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要熟悉C++编程语言的基础知识。本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_08](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_08)。代码可以在任何操作系统上执行，尽管它只在Ubuntu上进行了测试。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：
- en: '[http://bit.ly/2SfqzRo](http://bit.ly/2SfqzRo)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2SfqzRo](http://bit.ly/2SfqzRo)'
- en: Understanding background subtraction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解背景减法
- en: Background subtraction is very useful in video surveillance. Basically, the
    background subtraction technique performs really well in cases where we have to
    detect moving objects in a static scene. How is this useful for video surveillance?
    The process of video surveillance involves dealing with constant data flow. The
    data stream keeps coming in and we need to analyze it to recognize any suspicious
    activity. Let's consider the example of a hotel lobby. All the walls and furniture
    have a fixed location. If we build a background model, we can use it to identify
    suspicious activity in the lobby. We are taking advantage of the fact that the
    background scene remains static (which happens to be true in this case). This
    helps us avoid any unnecessary computational overhead. As the name indicates,
    this algorithm works by detecting and assigning each pixel of an image to two
    classes, either the background (assumed static and stable) or the foreground,
    and subtracting it from the current frame to obtain the foreground image part,
    which includes moving objects such as persons, cars, and so on. With the static
    assumption, the foreground objects will naturally correspond to objects or people
    moving in front of the background.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 背景减法在视频监控中非常有用。基本上，背景减法技术在需要检测静态场景中移动对象的情况下表现得很出色。这对视频监控有什么用？视频监控的过程涉及处理持续的数据流。数据流不断涌入，我们需要分析它以识别任何可疑活动。让我们以酒店大堂为例。所有墙壁和家具都有固定的位置。如果我们构建一个背景模型，我们可以用它来识别大堂中的可疑活动。我们正在利用背景场景保持静态的事实（在这个例子中恰好是真实的）。这有助于我们避免任何不必要的计算开销。正如其名称所示，该算法通过检测和将图像的每个像素分配到两个类别之一，即背景（假设为静态和稳定）或前景，并将其从当前帧中减去以获得前景图像部分，包括移动对象，如人、汽车等。在静态假设下，前景对象将自然对应于在背景前移动的对象或人。
- en: In order to detect moving objects, we need to build a model of the background.
    This is not the same as direct frame differencing, because we are actually modeling
    the background and using this model to detect moving objects. When we say that
    we are modeling the background, we are basically building a mathematical formula
    that can be used to represent the background. This is much better than the simple
    frame-differencing technique. This technique tries to detect static parts of the
    scene and then include small updates in the build statistic formula of the background
    model. This background model is then used to detect background pixels. So, it's
    an adaptive technique that can adjust according to the scene.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测移动的物体，我们需要建立一个背景模型。这不同于直接帧差分，因为我们实际上是在建模背景并使用这个模型来检测移动的物体。当我们说我们在建模背景时，我们基本上是在构建一个可以用来表示背景的数学公式。这比简单的帧差分技术要好得多。这种技术试图检测场景中的静态部分，然后在背景模型的构建统计公式中包含小的更新。这个背景模型随后用于检测背景像素。因此，它是一种自适应技术，可以根据场景进行调整。
- en: Naive background subtraction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 天真背景减法
- en: 'Let''s start the discussion from the beginning. What does a background subtraction
    process look like? Consider the following image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开始讨论。背景减法过程是什么样的？考虑以下图片：
- en: '![](img/3cbf0d44-4e2a-4214-a7ab-899166d16f4c.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cbf0d44-4e2a-4214-a7ab-899166d16f4c.png)'
- en: 'The previous image represents the background scene. Now, let''s introduce a
    new object into this scene:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片表示的是背景场景。现在，让我们向这个场景中引入一个新的物体：
- en: '![](img/86da43cc-6484-44cc-b145-0e022c5da798.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86da43cc-6484-44cc-b145-0e022c5da798.png)'
- en: 'As we can see, there is a new object in the scene. So, if we compute the difference
    between this image and our background model, you should be able to identify the
    location of the TV remote:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，场景中有一个新的物体。因此，如果我们计算这张图片和我们的背景模型之间的差异，你应该能够识别电视遥控器的位置：
- en: '![](img/f5c47d1f-cfbd-4860-a7fa-e1ed8ccf8e22.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5c47d1f-cfbd-4860-a7fa-e1ed8ccf8e22.png)'
- en: 'The overall process looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程看起来像这样：
- en: '![](img/e067d24c-4808-41e4-bead-526939174095.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e067d24c-4808-41e4-bead-526939174095.png)'
- en: Does it work well?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它工作得怎么样？
- en: There's a reason we call it the **naive** approach! It works under ideal conditions
    and, as we know, nothing is ideal in the real world. It does a reasonably good
    job of computing the shape of the given object, but it does so under some constraints.
    One of the main requirements of this approach is that the color and intensity
    of the object should be sufficiently different from that of the background. Some
    of the factors that affect this kind of algorithm are image noise, lighting conditions,
    and autofocus in cameras.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以称之为**天真**的方法，是有原因的！它在理想条件下工作得很好，而且正如我们所知，现实世界中没有什么是理想的。它对计算给定物体的形状做得相当不错，但它在某些约束条件下这样做。这种方法的主要要求之一是物体的颜色和强度应该与背景有足够的差异。影响这类算法的一些因素包括图像噪声、光照条件和相机的自动对焦。
- en: 'Once a new object enters our scene and stays there, it will be difficult to
    detect new objects that are in front of it. This is because we are not updating
    our background model, and the new object is now a part of our background. Consider
    the following image:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个新的物体进入我们的场景并停留下来，就很难检测到它前面的新物体。这是因为我们没有更新我们的背景模型，而新的物体现在已经成为我们背景的一部分。考虑以下图片：
- en: '![](img/93f3155d-4cf6-4c86-86f9-fd03569dbfb2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93f3155d-4cf6-4c86-86f9-fd03569dbfb2.png)'
- en: 'Now, let''s say a new object enters our scene:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个新的物体进入我们的场景：
- en: '![](img/948d01ff-ce36-45ff-842f-bfd3c6c61f82.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/948d01ff-ce36-45ff-842f-bfd3c6c61f82.png)'
- en: 'We detect this to be a new object, which is fine! Let''s say another object
    comes into the scene:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其检测为一个新的物体，这是可以的！假设另一个物体进入场景：
- en: '![](img/0665a410-2e58-4614-9565-c1682e249b9e.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0665a410-2e58-4614-9565-c1682e249b9e.png)'
- en: 'It will be difficult to identify the location of these two different objects
    because their locations are overlapping. Here''s what we get after subtracting
    the background and applying the threshold:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个不同物体的位置重叠，将很难识别它们的位置。以下是减去背景并应用阈值后得到的结果：
- en: '![](img/33e38517-b173-4bcb-8a68-0c38527fab88.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33e38517-b173-4bcb-8a68-0c38527fab88.png)'
- en: In this approach, we assume that the background is static. If some parts of
    our background start moving, those parts will start getting detected as new objects.
    So, even movements that are minor, say a waving flag, will cause problems in our
    detection algorithm. This approach is also sensitive to changes in illumination
    and it cannot handle any camera movement. Needless to say, it's a delicate approach!
    We need something that can handle all these things in the real world.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们假设背景是静态的。如果背景的某些部分开始移动，这些部分将开始被检测为新物体。因此，即使是微小的移动，比如挥动的旗帜，也会在我们的检测算法中引起问题。这种方法对光照变化也很敏感，并且无法处理任何相机移动。不用说，这是一个很微妙的方法！我们需要能够在现实世界中处理所有这些事情的东西。
- en: Frame differencing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧差分
- en: We know that we cannot keep a static background image pattern that can be used
    to detect objects. One of the ways to fix this would be by using frame differencing.
    It is one of the simplest techniques we can use to see what parts of the video
    are moving. When we consider a live video stream, the difference between successive
    frames gives a lot of information. The concept is fairly straightforward! We just
    take the difference between successive frames and display the differences between
    them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，我们不能保持一个静态的背景图像模式，这种模式可以用来检测物体。解决这个问题的一种方法是通过使用帧差分。这是我们能够使用的最简单技术之一，用来查看视频中的哪些部分在移动。当我们考虑实时视频流时，连续帧之间的差异提供了大量信息。这个概念相当直接！我们只需计算连续帧之间的差异，并显示它们之间的差异。
- en: 'If I move my laptop rapidly, we can see something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我快速移动我的笔记本电脑，我们可以看到类似这样的情况：
- en: '![](img/d1bfa52d-7bf1-44bb-a853-2f9678f49599.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1bfa52d-7bf1-44bb-a853-2f9678f49599.png)'
- en: 'Instead of the laptop, let''s move the object and see what happens. If I rapidly
    shake my head, it will look something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是移动笔记本电脑，而是移动物体，看看会发生什么。如果我快速摇头，它看起来会是这样：
- en: '![](img/a604d5b7-cb16-4cdd-833f-a498254df1df.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a604d5b7-cb16-4cdd-833f-a498254df1df.png)'
- en: 'As you can see from the previous images, only the moving parts of the video
    get highlighted. This gives us a good starting point to see what areas are moving
    in the video. Let''s look at the function to compute the frame differences:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从之前的图像中可以看到，只有视频中的移动部分被突出显示。这为我们提供了一个很好的起点，可以看到视频中的哪些区域在移动。让我们看看计算帧差异的函数：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Frame differencing is fairly straightforward! You compute the absolute differences
    between the current frame and the previous frame, and between the current frame
    and the next frame. We then take these frame differences and apply a bitwise **AND**
    operator. This will highlight the moving parts in the image. If you just compute
    the difference between the current frame and the previous frame, it tends to be
    noisy. Hence, we need to use the bitwise AND operator between successive frame
    differences to get some stability when we see the moving objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 帧差分相当直接！你计算当前帧和前一帧，以及当前帧和下一帧之间的绝对差异。然后我们应用这些帧差异的位运算**AND**操作符。这将突出显示图像中的移动部分。如果你只是计算当前帧和前一帧之间的差异，它往往会很嘈杂。因此，我们需要在连续帧差异之间使用位运算AND操作符，以便在看到移动物体时获得一些稳定性。
- en: 'Let''s look at the function that can extract and return a frame from the webcam:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可以从网络摄像头中提取并返回一帧的函数：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, it''s pretty straightforward. We just need to resize the frame
    and convert it to grayscale. Now that we have the helper functions ready, let''s
    look at the main function and see how it all comes together:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，这相当直接。我们只需要调整帧的大小并将其转换为灰度图。现在我们有了辅助函数，让我们看看主函数，看看它是如何整合在一起的：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How well does it work?
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的效果如何？
- en: 'As we can see, frame differencing addresses a couple of important problems
    we faced earlier. It can quickly adapt to lighting changes or camera movement.
    If an object comes in to the frame and stays there, it will not be detected in
    future frames. One of the main concerns of this approach is about detecting uniformly
    colored objects. It can only detect the edges of a uniformly colored object. The
    reason is that a large portion of this object will result in very low pixel differences:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，帧差分解决了我们之前遇到的一些重要问题。它可以快速适应光照变化或相机移动。如果一个物体进入画面并停留在那里，它将不会在未来的帧中被检测到。这种方法的主要担忧之一是检测均匀着色的物体。它只能检测均匀着色物体的边缘。原因是这个物体的很大一部分会导致非常低的像素差异：
- en: '![](img/2f8d809a-d3a8-4829-ad24-ef555b51ccb0.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f8d809a-d3a8-4829-ad24-ef555b51ccb0.png)'
- en: 'Let''s say this object moved slightly. If we compare this with the previous
    frame, it will look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个物体稍微移动了一下。如果我们将其与前一帧进行比较，它将看起来像这样：
- en: '![](img/e8abbc81-a938-4c4c-b582-c1547bf10bb7.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8abbc81-a938-4c4c-b582-c1547bf10bb7.png)'
- en: Hence, we have very few pixels that are labeled on that object. Another concern
    is that it is difficult to detect whether an object moving toward the camera or
    away from it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这个物体上标记的像素非常少。另一个问题是，很难检测物体是朝向相机移动还是远离相机。
- en: The Mixture of Gaussians approach
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高斯混合方法
- en: 'Before we talk about **Mixture of Gaussians** (**MOG**), let''s see what a
    **mixture model** is. A mixture model is just a statistical model that can be
    used to represent the presence of subpopulations within our data. We don''t really
    care about what category each data point belongs to. All we need to do is identify
    that the data has multiple groups inside it. If we represent each subpopulation
    using the Gaussian function, then it''s called Mixture of Gaussians. Let''s consider
    the following photograph:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论**高斯混合**（**MOG**）之前，让我们看看什么是**混合模型**。混合模型只是一个可以用来表示数据中存在子群体的统计模型。我们并不真正关心每个数据点属于哪个类别。我们只需要识别数据内部存在多个组。如果我们用高斯函数来表示每个子群体，那么它就被称为高斯混合。让我们考虑以下照片：
- en: '![](img/8ceed2f7-c122-4df1-804e-7803c4343330.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ceed2f7-c122-4df1-804e-7803c4343330.png)'
- en: Now, as we gather more frames in this scene, every part of the image will gradually
    become a part of the background model. This is what we discussed earlier in the
    *Frame differencing* section as well. If a scene is static, the model adapts itself
    to make sure the background model is updated. The foreground mask, which is supposed
    to represent the foreground object, looks like a black image at this point because
    every pixel is part of the background model.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们在这个场景中收集更多的帧，图像的每一部分都将逐渐成为背景模型的一部分。这就是我们在*帧差分*部分之前讨论的内容。如果场景是静态的，模型会自动调整以确保背景模型得到更新。前景掩码，本应代表前景物体，此时看起来像一张黑图，因为每个像素都是背景模型的一部分。
- en: 'OpenCV has multiple algorithms implemented for the Mixture of Gaussians approach.
    One of them is called **MOG** and the other is called **MOG2:** refer to this
    link for a detailed explanation: [http://docs.opencv.org/master/db/d5c/tutorial_py_bg_subtraction.html#gsc.tab=0](http://docs.opencv.org/master/db/d5c/tutorial_py_bg_subtraction.html#gsc.tab=0).
    You will also be able check out the original research papers that were used to
    implement these algorithms.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV实现了多种高斯混合方法算法。其中之一被称为**MOG**，另一个被称为**MOG2**：有关详细解释，请参阅此链接：[http://docs.opencv.org/master/db/d5c/tutorial_py_bg_subtraction.html#gsc.tab=0](http://docs.opencv.org/master/db/d5c/tutorial_py_bg_subtraction.html#gsc.tab=0)。您还可以查看用于实现这些算法的原始研究论文。
- en: 'Let''s wait for some time and then introduce a new object into the scene. Let''s
    look at what the new foreground mask looks like, using the MOG2 approach:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们等待一段时间，然后向场景中引入一个新物体。让我们看看使用MOG2方法的新前景掩码是什么样的：
- en: '![](img/5ee38a6f-6e03-4193-9f5d-3ced8ffc8ead.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ee38a6f-6e03-4193-9f5d-3ced8ffc8ead.png)'
- en: 'As you can see, the new objects are being identified correctly. Let''s look
    at the interesting part of the code (you can get the full code in the `.cpp` files):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，新物体被正确识别。让我们看看代码的有趣部分（您可以在`.cpp`文件中获取完整代码）：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What happened in the code?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码中发生了什么？
- en: 'Let''s quickly go through the code and see what''s happening there. We use
    the Mixture of Gaussians model to create a background subtractor object. This
    object represents the model that will be updated as and when we encounter new
    frames from the webcam. We initialized two background subtraction models—`BackgroundSubtractorMOG`
    and `BackgroundSubtractorMOG2`. They represent two different algorithms that are
    used for background subtraction. The first one refers to the paper by *P*. *KadewTraKuPong*
    and *R*. *Bowden,* titled *An Improved Adaptive Background Mixture Model for Real-time
    Tracking with Shadow Detection*. You can check it out at [http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf](http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf).
    The second one refers to the paper by *Z*. *Zivkovic,* titled *Improved Adaptive
    Gaussian Mixture Model for Background Subtraction*. You can check it out here:
    [http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf](http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下代码，看看那里发生了什么。我们使用高斯混合模型来创建一个背景减法对象。这个对象代表了一个模型，当我们遇到来自网络摄像头的新的帧时，它将随时更新。我们初始化了两个背景减法模型——`BackgroundSubtractorMOG`和`BackgroundSubtractorMOG2`。它们代表了用于背景减法的两种不同算法。第一个指的是P.
    *KadewTraKuPong*和R. *Bowden*的论文，标题为《用于带有阴影检测的实时跟踪的改进自适应背景混合模型》。您可以在[http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf](http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf)查看。第二个指的是Z.
    *Zivkovic*的论文，标题为《用于背景减法的改进自适应高斯混合模型》。您可以在[http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf](http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf)查看。
- en: 'We start an infinite `while` loop and continuously read the input frames from
    the webcam. With each frame, we update the background model, as indicated in the
    following lines:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动一个无限`while`循环，并持续从网络摄像头读取输入帧。随着每个帧，我们更新背景模型，如下所示：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The background model gets updated in these steps. Now, if a new object enters
    the scene and stays there, it will become part of the background model. This helps
    us overcome one of the biggest shortcomings of the **naive** background subtraction
    model.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 背景模型在这些步骤中会得到更新。现在，如果一个新物体进入场景并停留，它将成为背景模型的一部分。这有助于我们克服**朴素**背景减法模型的最大缺点之一。
- en: Morphological image processing
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态学图像处理
- en: As we discussed earlier, background subtraction methods are affected by many
    factors. Their accuracy depends on how we capture the data and how it's processed.
    One of the biggest factors that affects these algorithms is the noise level. When
    we say **noise**, we are talking about things such as graininess in an image and
    isolated black/white pixels. These issues tend to affect the quality of our algorithms.
    This is where morphological image processing comes into play. Morphological image
    processing is used extensively in a lot of real-time systems to ensure the quality
    of the output. Morphological image processing refers to processing the shapes
    of features in the image; for example, you can make a shape thicker or thinner.
    Morphological operators rely not on how the pixels are ordered in an image, but
    on their values. This is why they are really well suited to manipulating shapes
    in binary images. Morphological image processing can be applied to grayscale images
    as well, but the pixel values will not matter much.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，背景减法方法受许多因素影响。它们的准确性取决于我们如何捕获数据以及如何处理数据。影响这些算法的最大因素之一是噪声水平。当我们说**噪声**时，我们指的是图像中的颗粒状和孤立的黑/白像素等问题。这些问题往往会影响我们算法的质量。这就是形态学图像处理发挥作用的地方。形态学图像处理在许多实时系统中被广泛使用，以确保输出质量。形态学图像处理是指处理图像中特征形状的过程；例如，你可以使形状变厚或变薄。形态学算子不依赖于图像中像素的顺序，而是依赖于它们的值。这就是为什么它们非常适合在二值图像中操作形状。形态学图像处理也可以应用于灰度图像，但像素值不会很重要。
- en: What's the underlying principle?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本原理是什么？
- en: Morphological operators use a structuring element to modify an image. What is
    a structuring element? A structuring element is basically a small shape that can
    be used to inspect a small region in the image. It is positioned at all the pixel
    locations in the image so that it can inspect that neighborhood. We basically
    take a small window and overlay it on a pixel. Depending on the response, we take
    appropriate action at that pixel location.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 形态学算子使用结构元素来修改图像。什么是结构元素？结构元素基本上是一个可以用来检查图像中小区域的形状。它被放置在图像的所有像素位置，以便它可以检查该邻域。我们基本上取一个小窗口并将其叠加在像素上。根据响应，我们在该像素位置采取适当的行动。
- en: 'Let''s consider the following input image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下输入图像：
- en: '![](img/7f6ac4ba-93be-4e3f-8517-4b5968ced5d9.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f6ac4ba-93be-4e3f-8517-4b5968ced5d9.png)'
- en: We are going to apply a bunch of morphological operations to this image to see
    how the shape changes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对这张图像应用一系列形态学运算，以观察形状的变化。
- en: Slimming the shapes
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精简形状
- en: 'We achieve this effect using an operation called **erosion**. This is the operation
    that makes a shape thinner by peeling the boundary layers of all the shapes in
    the image:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个称为**腐蚀**的操作来实现这种效果。这是通过剥离图像中所有形状的边界层来使形状变薄的运算：
- en: '![](img/2ec264b3-8600-4f74-99fb-308208b2475f.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ec264b3-8600-4f74-99fb-308208b2475f.png)'
- en: 'Let''s look at the function that performs morphological erosion:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行形态学腐蚀的函数：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can check out the full code in the `.cpp` files to understand how to use
    this function. We basically build a structuring element using a built-in OpenCV
    function. This object is used as a probe to modify each pixel based on certain
    conditions. These conditions refer to what's happening around that particular
    pixel in the image. For example, is it surrounded by white pixels? Or is it surround
    by black pixels? Once we have an answer, we take the appropriate action.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`.cpp`文件中查看完整的代码，以了解如何使用此函数。我们基本上使用一个内置的OpenCV函数构建一个结构元素。此对象用作探针，根据某些条件修改每个像素。这些条件指的是图像中特定像素周围发生的事情。例如，它是被白色像素包围的吗？或者它是被黑色像素包围的吗？一旦我们得到答案，我们就采取适当的行动。
- en: Thickening the shapes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加厚形状
- en: 'We use an operation called **dilation** to achieve thickening. This is the
    operation that makes a shape thicker by adding boundary layers to all the shapes
    in the image:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个称为**膨胀**的操作来实现加厚。这是通过向图像中的所有形状添加边界层来使形状变厚的操作：
- en: '![](img/d747f0d4-9b2d-4ed4-b07e-f7b8ebe05435.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d747f0d4-9b2d-4ed4-b07e-f7b8ebe05435.png)'
- en: 'Here is the code to do it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行此操作的代码：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Other morphological operators
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他形态学算子
- en: Here are some other interesting morphological operators. Let's look at the output
    image first. We can look at the code at the end of this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他有趣的形态学算子。让我们先看看输出图像。我们可以在本节末尾查看代码。
- en: Morphological opening
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态学开运算
- en: 'This is the operation that **opens** a shape. This operator is frequently used
    for noise removal in images. It''s basically erosion followed by dilation. Morphological
    opening removes small objects from the foreground in the image by placing them
    in the background:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**打开**形状的操作。这个算子常用于图像中的噪声去除。它基本上是腐蚀后跟膨胀。形态学开运算通过将小物体放置在背景中来从图像前景中移除它们：
- en: '![](img/33df80c3-af99-436a-ac63-dec98b9d9492.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33df80c3-af99-436a-ac63-dec98b9d9492.png)'
- en: 'Here is the function to perform morphological opening:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行形态学开运算的函数：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see here, we apply **erosion** and **dilation** on the image to perform
    morphological opening.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们通过对图像进行**腐蚀**和**膨胀**来执行形态学开运算。
- en: Morphological closing
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形态学闭合
- en: 'This is the operation that **closes** a shape by filling the gaps, as shown
    in the following screenshot. This operation is also used for noise removal. It''s
    basically dilation followed by erosion. This operation removes tiny holes in the
    foreground by changing small objects in the background into the foreground:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过填充间隙来**闭合**形状的操作，如下面的截图所示。这个操作也用于噪声去除。它基本上是膨胀后跟腐蚀。这个操作通过将背景中的小物体变成前景来移除前景中的微小孔洞：
- en: '![](img/e089e366-df33-45b3-a766-5bdd5b8194c3.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e089e366-df33-45b3-a766-5bdd5b8194c3.png)'
- en: 'Let''s quickly look at the function to perform morphological closing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看执行形态学闭合的函数：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Drawing the boundary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制边界
- en: 'We achieve this using a morphological gradient. This is the operation that
    draws the boundary around a shape by taking the difference between the dilation
    and erosion of an image:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用形态学梯度来实现这一点。这是通过取图像膨胀和腐蚀之间的差值来绘制形状边界的操作：
- en: '![](img/6c644866-9615-48d3-83a2-e7a56e5c51b7.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c644866-9615-48d3-83a2-e7a56e5c51b7.png)'
- en: 'Let''s look at the function to perform morphological gradient:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行形态学梯度的函数：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Top Hat transform
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶帽变换
- en: 'This transform extracts finer details from the images. This is the difference
    between the input image and its morphological opening. This gives us the objects
    in the image that are smaller than the structuring element and brighter than the
    surroundings. Depending on the size of the structuring element, we can extract
    various objects in the given image:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变换从图像中提取更细的细节。这是输入图像与其形态学开运算之间的差异。这使我们能够识别出图像中比结构元素小且比周围环境亮的物体。根据结构元素的大小，我们可以从给定图像中提取各种物体：
- en: '![](img/bc19cfb9-b944-406d-8c56-1f397c02d459.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc19cfb9-b944-406d-8c56-1f397c02d459.png)'
- en: 'If you look at the output image carefully, you can see those black rectangles.
    It means that the structuring element was able to fit in there, and so those regions
    are blackened out. Here is the function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察输出图像，你可以看到那些黑色矩形。这意味着结构元素能够适应那里，因此这些区域被涂成了黑色。以下是该函数：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Black Hat transform
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑帽变换
- en: 'This transform extract finer details from the image as well. This is the difference
    between the morphological closing of an image and the image itself. This gives
    us the objects in the image that are smaller than the structuring element and
    darker than its surroundings:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变换同样从图像中提取更细的细节。这是图像的形态学闭运算与图像本身的差异。这使我们能够识别出图像中比结构元素小且比周围环境暗的物体：
- en: '![](img/aad1cad8-45b7-4ece-8b18-10f973bc1d45.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aad1cad8-45b7-4ece-8b18-10f973bc1d45.png)'
- en: 'Let''s look at the function to perform a Black Hat transform:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行黑帽变换的函数：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the algorithms that are used for background
    modeling and morphological image processing. We discussed naive background subtraction
    and its limitations. We looked at how to get motion information using frame differencing
    and how it can be limiting when we want to track different types of objects. This
    led to our discussion about the Mixture of Gaussians. We discussed the formula
    and how we can implement it. We then discussed morphological image processing,
    which can be used for various purposes, and different operations were covered
    to show the use cases.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了用于背景建模和形态学图像处理的算法。我们讨论了简单的背景减法和其局限性。我们探讨了如何使用帧差分来获取运动信息，以及当我们想要跟踪不同类型的物体时，它可能存在的局限性。这导致了我们对高斯混合模型的讨论。我们讨论了公式以及如何实现它。然后我们讨论了形态学图像处理，它可以用于各种目的，并介绍了不同的操作以展示用例。
- en: In the next chapter, we are going to discuss object tracking and the various
    techniques that can be used to do it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论目标跟踪以及可以用来实现这一目标的多种技术。
