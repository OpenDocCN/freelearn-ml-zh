- en: Chapter 10. Advanced Model Monitoring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 高级模型监控
- en: Even though this is the last chapter of the book, it can hardly be an afterthought
    even though monitoring in general often is in practical situations, quite unfortunately.
    Monitoring is a vital deployment component for any long execution cycle component
    and thus is part of the finished product. Monitoring can significantly enhance
    product experience and define future success as it improves problem diagnostic
    and is essential to determine the improvement path.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是本书的最后一章，但在实际情况下，监控通常往往被忽视，这实在是不幸。监控是任何长时间执行周期组件的关键部署组件，因此它是最终产品的组成部分。监控可以显著提升产品体验并定义未来的成功，因为它可以改善问题诊断并对于确定改进路径至关重要。
- en: One of the primary rules of successful software engineering is to create systems
    as if they were targeted for personal use when possible, which fully applies to
    monitoring, diagnostic, and debugging—quite hapless name for fixing existing issues
    in software products. Diagnostic and debugging of complex systems, particularly
    distributed systems, is hard, as the events often can be arbitrary interleaved
    and program executions subject to race conditions. While there is a lot of research
    going in the area of distributed system devops and maintainability, this chapter
    will scratch the service and provide guiding principle to design a maintainable
    complex distributed system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 成功软件工程的一个基本原则是，当可能时，创建系统就像是为个人使用而设计一样，这完全适用于监控、诊断和调试——一个不幸的名字，用于修复软件产品中的现有问题。复杂系统，尤其是分布式系统的诊断和调试很困难，因为事件往往可以任意交织，程序执行可能受到竞争条件的影响。尽管在分布式系统devops和可维护性领域有很多研究，但本章将探讨服务并提供一个指导原则，以设计可维护的复杂分布式系统。
- en: To start with, a pure functional approach, which Scala claims to follow, spends
    a lot of time avoiding side effects. While this idea is useful in a number of
    aspects, it is hard to imagine a useful program that has no effect on the outside
    world, the whole idea of a data-driven application is to have a positive effect
    on the way the business is conducted, a well-defined side effect.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个纯函数式方法，Scala声称遵循这种方法，花费大量时间避免副作用。虽然这个想法在许多方面都有用，但很难想象一个对现实世界没有任何影响的有用程序，数据驱动应用程序的整个理念就是以积极的方式影响业务运营，一个明确定义的副作用。
- en: Monitoring clearly falls in the side effect category. Execution needs to leave
    a trace that the user can later parse in order to understand where the design
    or implementation went awry. The trace of the execution can be left by either
    writing something on a console or into a file, usually called a log, or returning
    an object that contains the trace of the program execution, and the intermediate
    results. The latter approach, which is actually more in line with functional programming
    and monadic philosophy, is actually more appropriate for the distributed programming
    but often overlooked. This would have been an interesting topic for research,
    but unfortunately the space is limited and I have to discuss the practical aspects
    of monitoring in contemporary systems that is almost always done by logging. Having
    the monadic approach of carrying an object with the execution trace on each call
    can certainly increase the overhead of the interprocess or inter-machine communication,
    but saves a lot of time in stitching different pieces of information together.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 监控显然属于副作用类别。执行需要留下用户可以稍后解析的痕迹，以了解设计或实现出了什么问题。执行的痕迹可以通过在控制台或文件上写入某些内容（通常称为日志）或返回一个包含程序执行痕迹和中间结果的对象来留下。后一种方法实际上更符合函数式编程和单子哲学，但对于分布式编程来说实际上更合适，但往往被忽视。这本来可以是一个有趣的研究课题，但遗憾的是空间有限，我必须讨论当代系统中监控的实用方面，这种监控几乎总是通过日志来完成的。在每个调用中携带带有执行痕迹的对象的单子方法当然会增加进程间或机器间通信的开销，但可以节省大量时间来拼接不同的信息片段。
- en: 'Let''s list the naive approaches to debugging that everyone who needed to find
    a bug in the code tried:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出一些尝试过寻找代码中bug的人所采用的简单调试方法：
- en: Analyzing program output, particularly logs produced by simple print statements
    or built-in logback, java.util.logging, log4j, or the slf4j façade
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析程序输出，尤其是由简单的打印语句或内置的logback、java.util.logging、log4j或slf4j外观产生的日志
- en: Attaching a (remote) debugger
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接（远程）调试器
- en: Monitoring CPU, disk I/O, memory (to resolve higher level resource-utilization
    issues)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控CPU、磁盘I/O、内存（以解决高级资源利用率问题）
- en: More or less, all these approaches fail if we have a multithreaded or distributed
    system—and Scala is inherently multithreaded as Spark is inherently distributed.
    Collecting logs over a set of nodes is not scalable (even though a few successful
    commercial systems exist that do this). Attaching a remote debugger is not always
    possible due to security and network restrictions. Remote debugging can also induce
    substantial overhead and interfere with the program execution, particularly for
    ones that use synchronization. Setting the debug level to the `DEBUG` or `TRACE`
    level helps sometimes, but leaves you at the mercy of the developer who may or
    may not have thought of a particular corner case you are dealing with right at
    the moment. The approach we take in this book is to open a servlet with enough
    information to glean into program execution and application methods real-time,
    as much as it is possible with the current state of Scala and Scalatra.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，如果我们有一个多线程或分布式系统——而Scala本身是天生多线程的，Spark本身是天生分布式的——那么所有这些方法都可能会失败。在多个节点上收集日志是不可扩展的（尽管存在一些成功的商业系统确实这样做）。由于安全和网络限制，远程调试并不总是可能的。远程调试也可能导致大量的开销并干扰程序执行，尤其是对于使用同步的程序。将调试级别设置为`DEBUG`或`TRACE`有时会有所帮助，但将你置于可能或可能没有考虑到你当前正在处理的特定角落情况的开发者的
    mercy。我们在本书中采取的方法是打开一个足够信息的servlet，以便实时了解程序执行和应用程序方法，尽可能多地在Scala和Scalatra当前状态下做到这一点。
- en: 'Enough about the overall issues of debugging the program execution. Monitoring
    is somewhat different, as it is concerned with only high-level issue identification.
    Intersection with issue investigation or resolution happens, but usually is outside
    of monitoring. In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于调试程序执行的整体问题已经说得够多了。监控则有所不同，因为它只关注于高级问题识别。与问题调查或解决相交的情况会发生，但通常是在监控之外。在本章中，我们将涵盖以下主题：
- en: Understanding major areas for monitoring and monitoring goals
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解监控的主要领域和监控目标
- en: Learning OS tools for Scala/Java monitoring to support issue identification
    and debugging
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Scala/Java监控工具以支持问题识别和调试
- en: Learning about MBeans and MXBeans
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习MBeans和MXBeans
- en: Understanding model performance drift
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模型性能漂移
- en: Understanding A/B testing
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解A/B测试
- en: System monitoring
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统监控
- en: 'While there are other types of monitoring dealing specifically with ML-targeted
    tasks, such as monitoring the performance of the models, let me start with basic
    system monitoring. Traditionally, system monitoring is a subject of operating
    system maintenance, but it is becoming a vital component of any complex application,
    specifically running over a set of distributed workstations. The primary components
    of the OS are CPU, disk, memory, network, and energy on battery-powered machines.
    The traditional OS-like tools for monitoring system performance are provided in
    the following table. We limit them to Linux tools as this is the platform for
    most Scala applications, even though other OS vendors provide OS monitoring tools
    such as **Activity Monitor**. As Scala runs in Java JVM, I also added Java-specific
    monitoring tools that are specific to JVMs:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有其他类型的监控专门针对ML目标任务，例如监控模型的性能，但让我先从基本的系统监控开始。传统上，系统监控是操作系统维护的一个主题，但它正成为任何复杂应用的一个关键组成部分，特别是运行在分布式工作站上。操作系统的核心组件包括CPU、磁盘、内存、网络以及电池供电机器上的能源。以下表格中提供了传统的操作系统监控工具。我们将它们限制在Linux工具，因为这是大多数Scala应用程序的平台，尽管其他操作系统供应商提供了诸如**活动监视器**之类的操作系统监控工具。由于Scala运行在Java
    JVM上，我还添加了针对JVM的特定Java监控工具：
- en: '| Area | Programs | Comments |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 区域 | 程序 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CPU | `htop,` `top`, `sar-u` | `top` has been the most often used performance
    diagnostic tool, as CPU and memory have been the most constraint resources. With
    the advent of distributed programming, network and disk tend to be the most constraint.
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| CPU | `htop`、`top`、`sar-u` | `top`一直是使用最频繁的性能诊断工具，因为CPU和内存一直是限制性资源。随着分布式编程的出现，网络和磁盘往往成为限制性资源。
    |'
- en: '| Disk | `iostat`, `sar -d`, `lsof` | The number of open files, provided by
    `lsof`, is often a constraining resource as many big data applications and daemons
    tend to keep multiple files open. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 磁盘 | `iostat`、`sar -d`、`lsof` | `lsof`提供的打开文件数量通常是一个限制性资源，因为许多大数据应用程序和守护进程倾向于保持多个文件打开。
    |'
- en: '| Memory | `top`, `free`, `vmstat`, `sar -r` | Memory is used by OS in multiple
    ways, for example to maintain disk I/O buffers so that having extra buffered and
    cached memory helps performance. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | `top`, `free`, `vmstat`, `sar -r` | 内存以多种方式被操作系统使用，例如维护磁盘I/O缓冲区，因此额外的缓冲和缓存内存有助于性能。|'
- en: '| Network | `ifconfig`, `netstat`, `tcpdump`, `nettop`, `iftop`, `nmap` | Network
    is how the distributed systems talk and is an important OS component. From the
    application point of view, watch for errors, collisions, and dropped packets as
    an indicator of problems. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 网络 | `ifconfig`, `netstat`, `tcpdump`, `nettop`, `iftop`, `nmap` | 网络是分布式系统之间通信的方式，是重要的操作系统组件。从应用的角度来看，关注错误、冲突和丢失的数据包，作为问题的指示。|'
- en: '| Energy | `powerstat` | While power consumption is traditionally not a part
    of OS monitoring, it is nevertheless a shared resource, which recently became
    one of the major costs for maintaining a working system. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 能源 | `powerstat` | 虽然功耗传统上不是操作系统监控的一部分，但它仍然是一种共享资源，最近已成为维护工作系统的主要成本之一。|'
- en: '| Java | `jconsole`, `jinfo`, `jcmd`, `jmc` | All these tools allow you to
    examine configuration and run-time properties of an application. **Java Mission
    Control** (**JMC**) is shipped with JDK starting with version 7u40. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Java | `jconsole`, `jinfo`, `jcmd`, `jmc` | 所有这些工具都允许您检查应用程序的配置和运行时属性。**Java
    Mission Control**（**JMC**）从JDK 7u40版本开始随JDK一起提供。|'
- en: Table 10.1\. Common Linux OS monitoring tools
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表10.1. 常见的Linux操作系统监控工具|
- en: In many cases, the tools are redundant. For example, the CPU and memory information
    can be obtained with `top`, `sar`, and `jmc` commands.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，工具是冗余的。例如，可以使用`top`、`sar`和`jmc`命令获取CPU和内存信息。|
- en: There are a few tools for collecting this information over a set of distributed
    nodes. Ganglia is a BSD-licensed scalable distributed monitoring system ([http://ganglia.info](http://ganglia.info)).
    It is based on a hierarchical design and is very careful about data structure
    and algorithm designs. It is known to scale to 10,000s of nodes. It consists of
    a gmetad daemon that is collects information from multiple hosts and presents
    it in a web interface, and gmond daemons running on each individual host. The
    communication happens on the 8649 port by default, which spells Unix. By default,
    gmond sends information about CPU, memory, and network, but multiple plugins exist
    for other metrics (or can be created). Gmetad can aggregate the information and
    pass it up the hierarchy chain to another gmetad daemon. Finally, the data is
    presented in a Ganglia web interface.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以收集一组分布式节点上的这些信息。Ganglia是一个BSD许可的可扩展分布式监控系统（[http://ganglia.info](http://ganglia.info)）。它基于分层设计，非常注重数据结构和算法设计。它已知可以扩展到10,000多个节点。它由一个gmetad守护进程组成，该守护进程从多个主机收集信息并在Web界面中展示，以及在每个单独的主机上运行的gmond守护进程。默认情况下，通信发生在8649端口，这代表Unix。默认情况下，gmond发送有关CPU、内存和网络的信息，但存在多个插件用于其他指标（或可以创建）。Gmetad可以聚合信息并将其传递到层次链中的另一个gmetad守护进程。最后，数据在Ganglia
    Web界面中展示。|
- en: Graphite is another monitoring tool that stores numeric time-series data and
    renders graphs of this data on demand. The web app provides a /render endpoint
    to generate graphs and retrieve raw data via a RESTful API. Graphite has a pluggable
    backend (although it has it's own default implementation). Most of the modern
    metrics implementations, including scala-metrics used in this chapter, support
    sending data to Graphite.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Graphite是另一个监控工具，它存储数值时间序列数据，并在需要时渲染这些数据的图表。Web应用程序提供了一个/render端点来生成图表，并通过RESTful
    API检索原始数据。Graphite具有可插拔的后端（尽管它有自己的默认实现）。大多数现代指标实现，包括本章中使用的scala-metrics，都支持向Graphite发送数据。|
- en: Process monitoring
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程监控|
- en: The tools described in the previous section are not application-specific. For
    a long-running process, it often necessary to provide information about the internal
    state to either a monitoring a graphing solution such as Ganglia or Graphite,
    or just display it in a servlet. Most of these solutions are read-only, but in
    some cases, the commands give the control to the users to modify the state, such
    as log levels, or to trigger garbage collection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节中描述的工具不是特定于应用的。对于长时间运行的过程，通常需要提供有关内部状态的信息，以便于监控或图形解决方案，如Ganglia或Graphite，或者直接在servlet中显示。这些解决方案大多数是只读的，但在某些情况下，命令允许用户修改状态，例如日志级别，或者触发垃圾回收。|
- en: 'Monitoring, in general is supposed to do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 监控通常应该执行以下操作：|
- en: Provide high-level information about program execution and application-specific
    metrics
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于程序执行和特定于应用的指标的高级信息|
- en: Potentially, perform health-checks for critical components
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能执行关键组件的健康检查
- en: Might incorporate alerting and thresholding on some critical metrics
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会在一些关键指标上集成警报和阈值
- en: I have also seen monitoring to include update operations to either update the
    logging parameters or test components, such as trigger model scoring with predefined
    parameters. The latter can be considered as a part of parameterized health check.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我还看到监控包括更新操作，以更新日志参数或测试组件，例如使用预定义参数触发模型评分。后者可以被视为参数化健康检查的一部分。
- en: 'Let''s see how it works on the example of a simple `Hello World` web application
    that accepts REST-like requests and assigns a unique ID for different users written
    in the Scalatra framework ([http://scalatra.org](http://scalatra.org)), a lightweight
    web-application development framework in Scala. The application is supposed to
    respond to CRUD HTTP requests to create a unique numeric ID for a user. To implement
    the service in Scalatra, we need just to provide a `Scalate` template. The full
    documentation can be found at [http://scalatra.org/2.4/guides/views/scalate.html](http://scalatra.org/2.4/guides/views/scalate.html),
    the source code is provided with the book and can be found in `chapter10` subdirectory:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的`Hello World` web应用程序的例子来看看它是如何工作的，该应用程序接受类似REST的请求并为不同的用户分配唯一的ID，该应用程序是用Scala框架Scalatra编写的([http://scalatra.org](http://scalatra.org))，Scala中的轻量级Web应用程序开发框架。该应用程序应该对创建用户唯一数字ID的CRUD
    HTTP请求做出响应。要在Scalatra中实现此服务，我们只需要提供一个`Scalate`模板。完整的文档可以在[http://scalatra.org/2.4/guides/views/scalate.html](http://scalatra.org/2.4/guides/views/scalate.html)找到，源代码与本书一起提供，可在`chapter10`子目录中找到：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, the code gets the `name` parameter from the request (REST-like parameter
    parsing is also supported). Then, it checks the internal HashMap for existing
    entries, and if the entry does not exist, it creates a new index using a synchronized
    call to increment `hwCounter` (in a real-world application, this information should
    be persistent in a database such as HBase, but I''ll skip this layer in this section
    for the purpose of simplicity). To run the application, one needs to download
    the code, start `sbt`, and type `~;jetty:stop;jetty:start` to enable continuous
    run/compilation as in [Chapter 7](ch07.xhtml "Chapter 7. Working with Graph Algorithms"),
    *Working with Graph Algorithms*. The modifications to the file will be immediately
    picked up by the build tool and the jetty server will restart:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码从请求中获取`name`参数（也支持类似REST的参数解析）。然后，它检查内部HashMap中是否存在条目，如果不存在，则使用对`hwCounter`的同步调用创建一个新的索引（在实际应用中，这些信息应该在数据库（如HBase）中持久化，但为了简化，本节将跳过这一层）。要运行应用程序，需要下载代码，启动`sbt`，并输入`~;jetty:stop;jetty:start`以启用连续运行/编译，如[第7章](ch07.xhtml
    "第7章。使用图算法")中所述，*使用图算法*。对文件的修改将立即被构建工具捕获，jetty服务器将重新启动：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the servlet is started on port 8080, issue a browser request:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当servlet在8080端口启动时，发出浏览器请求：
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I pre-created the project for this book, but if you want to create a Scalatra
    project from scratch, there is a `gitter` command in `chapter10/bin/create_project.sh`.
    Gitter will create a `project/build.scala` file with a Scala object, extending
    build that will set project parameters and enable the Jetty plugin for the SBT.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这本书预先创建了项目，但如果你想要从头开始创建Scalatra项目，`chapter10/bin/create_project.sh`中有一个`gitter`命令。Gitter将创建一个`project/build.scala`文件，其中包含一个Scala对象，扩展了构建，这将设置项目参数并启用SBT的Jetty插件。
- en: '`http://localhost:8080/hw/Joe`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/hw/Joe`。'
- en: 'The output should look similar to the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于以下截图：
- en: '![Process monitoring](img/B04935_10_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![流程监控](img/B04935_10_01.jpg)'
- en: 'Figure 10-1: The servlet web page.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：servlet网页。
- en: If you call the servlet with a different name, it will assign a distinct ID,
    which will be persistent across the lifetime of the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用不同的名称调用servlet，它将分配一个不同的ID，该ID将在应用程序的生命周期内保持持久。
- en: 'As we also enabled console logging, you will also see something similar to
    the following command on the console:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们也启用了控制台日志记录，你将在控制台上看到类似以下命令的内容：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While retrieving and analyzing logs, which can be redirected to a file, is an
    option and there are multiple systems to collect, search, and analyze logs from
    a set of distributed servers, it is often also important to have a simple way
    to introspect the running code. One way to accomplish this is to create a separate
    template with metrics, however, Scalatra provides metrics and health support to
    enable basic implementations for counts, histograms, rates, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在检索和分析日志时，可以将日志重定向到文件，并且有多个系统可以收集、搜索和分析来自一组分布式服务器的日志，但通常还需要一种简单的方法来检查运行中的代码。实现这一目标的一种方法是为度量创建一个单独的模板，然而，Scalatra
    提供了度量和支持健康检查，以实现计数、直方图、速率等基本实现。
- en: I will use the Scalatra metrics support. The `ScalatraBootstrap` class has to
    implement the `MetricsBootstrap` trait. The `org.scalatra.metrics.MetricsSupport`
    and `org.scalatra.metrics.HealthChecksSupport` traits provide templating similar
    to the Scalate templates, as shown in the following code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 Scalatra 度量支持。`ScalatraBootstrap` 类必须实现 `MetricsBootstrap` 特质。`org.scalatra.metrics.MetricsSupport`
    和 `org.scalatra.metrics.HealthChecksSupport` 特质提供了类似于 Scalate 模板的模板功能，如下面的代码所示。
- en: 'The following is the content of the `ScalatraTemplate.scala` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `ScalatraTemplate.scala` 文件的内容：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the content of the `ServletWithMetrics.scala` file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为 `ServletWithMetrics.scala` 文件的内容：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run the server again, the `http://localhost:8080/admin` page will show
    a set of links for operational information, as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次运行服务器，`http://localhost:8080/admin` 页面将显示一组用于操作信息的链接，如下面的截图所示：
- en: '![Process monitoring](img/B04935_10_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![进程监控](img/B04935_10_02.jpg)'
- en: 'Figure 10-2: The admin servlet web page'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2：管理员 servlet 网页
- en: 'The **Metrics** link will lead to the metrics servlet depicted in *Figure 10-3*.
    The `org.akozlov.exampes.ServletWithMetrics.counter` will have a global count
    of requests, and `org.akozlov.exampes.ServletWithMetrics.histogram` will show
    the distribution of accumulated values, in this case, the name lengths. More importantly,
    it will compute `50`, `75`, `95`, `98`, `99`, and `99.9` percentiles. The meter
    counter will show rates for the last `1`, `5`, and `15` minutes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**度量**链接将引导到 *图 10-3* 中所示的度量 servlet。`org.akozlov.exampes.ServletWithMetrics.counter`
    将有一个全局请求数量，而 `org.akozlov.exampes.ServletWithMetrics.histogram` 将显示累积值的分布，在这种情况下，是名称长度。更重要的是，它将计算
    `50`、`75`、`95`、`98`、`99` 和 `99.9` 分位数。计量计数器将显示过去 `1`、`5` 和 `15` 分钟的速率：'
- en: '![Process monitoring](img/B04935_10_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![进程监控](img/B04935_10_03.jpg)'
- en: 'Figure 10-3: The metrics servlet web page'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：度量 servlet 网页
- en: 'Finally, one can write health checks. In this case, I will just check whether
    the result of the response function contains the string that it has been passed
    as a parameter. Refer to the following *Figure 10.4*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以编写健康检查。在这种情况下，我将只检查响应函数的结果是否包含已传递的字符串。请参考以下 *图 10.4*：
- en: '![Process monitoring](img/B04935_10_04.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![进程监控](img/B04935_10_04.jpg)'
- en: 'Figure 10-4: The health check servlet web page.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：健康检查 servlet 网页。
- en: The metrics can be configured to report to Ganglia or Graphite data collection
    servers or periodically dump information into a log file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 度量可以配置为向 Ganglia 或 Graphite 数据收集服务器报告，或者定期将信息输出到日志文件中。
- en: 'Endpoints do not have to be read-only. One of the pre-configured components
    is the timer, which measures the time to complete a task—which can be used for
    measuring scoring performance. Let''s put the code in the `ServletWithMetrics`
    class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 端点不必是只读的。预配置的组件之一是计时器，它测量完成任务所需的时间——这可以用于测量评分性能。让我们将代码放入 `ServletWithMetrics`
    类中：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Accessing `http://localhost:8080/time` will trigger code execution, which will
    be timed with a timer in metrics.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:8080/time` 将触发代码执行，该执行将使用度量中的计时器进行计时。
- en: Analogously, the put operation, which can be created with the `put()` template,
    can be used to either adjust the run-time parameters or execute the code in-situ—which,
    depending on the code, might need to be secured in production environments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以使用 `put()` 模板创建的 put 操作，既可以调整运行时参数，也可以就地执行代码——这取决于代码，可能在生产环境中需要安全措施。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**JSR 110**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSR 110**'
- en: JSR 110 is another **Java Specification Request** (**JSR**), commonly known
    as **Java Management Extensions** (**JMX**). JSR 110 specifies a number of APIs
    and protocols in order to be able to monitor the JVM executions remotely. A common
    way to access JMX Services is via the `jconsole` command that will connect to
    one of the local processes by default. To connect to a remote host, you need to
    provide the `-Dcom.sun.management.jmxremote.port=portNum` property on the Java
    command line. It is also advisable to enable security (SSL or password-based authentication).
    In practice, other monitoring tools use JMX for monitoring, as well as managing
    the JVM, as JMX allows callbacks to manage the system state.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JSR 110 是另一个 **Java 规范请求** (**JSR**)，通常被称为 **Java 管理扩展** (**JMX**)。JSR 110 规定了一系列
    API 和协议，以便能够远程监控 JVM 执行。访问 JMX 服务的一种常见方式是通过默认连接到本地进程之一的 `jconsole` 命令。要连接到远程主机，您需要在
    Java 命令行上提供 `-Dcom.sun.management.jmxremote.port=portNum` 属性。还建议启用安全性（SSL 或基于密码的认证）。在实践中，其他监控工具也使用
    JMX 进行监控，以及管理 JVM，因为 JMX 允许回调来管理系统状态。
- en: You can provide your own metrics that are exposed via JMX. While Scala runs
    in JVM, the implementation of JMX (via MBeans) is very Java-specific, and it is
    not clear how well the mechanism will play with Scala. JMX Beans can certainly
    be exposed as a servlet in Scala though.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 JMX 提供自己的指标。虽然 Scala 在 JVM 中运行，但 JMX 的实现（通过 MBeans）非常特定于 Java，不清楚这种机制与
    Scala 的兼容性如何。尽管如此，JMX Beans 可以在 Scala 中作为 servlet 暴露。
- en: The JMX MBeans can usually be examined in JConsole, but we can also expose it
    as `/jmx servlet`, the code provided in the book repository ([https://github.com/alexvk/ml-in-scala](https://github.com/alexvk/ml-in-scala)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JMX MBeans 通常可以在 JConsole 中检查，但我们也可以将其暴露为 `/jmx servlet`，书中提供的代码在代码库中（[https://github.com/alexvk/ml-in-scala](https://github.com/alexvk/ml-in-scala)）。
- en: Model monitoring
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型监控
- en: 'We have covered basic system and application metrics. Lately, a new direction
    evolved for using monitoring components to monitor statistical model performance.
    The statistical model performance covers the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了基本系统和应用程序指标。最近，使用监控组件来监控统计模型性能的新方向已经出现。统计模型性能包括以下内容：
- en: How the model performance evolved over time
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型性能随时间的变化
- en: When is the time to retire the model
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时是退役模型的时候
- en: Model health check
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型健康检查
- en: Performance over time
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随时间推移的性能
- en: 'ML models deteriorate with time, or ''age'': While this process is not still
    well understood, the model performance tends to change with time, if even due
    to concept drift, where the definition of the attributes change, or the changes
    in the underlying dependencies. Unfortunately, model performance rarely improves,
    at least in my practice. Thus, it is imperative to keep track of models. One way
    to do this is by monitoring the metrics that the model is intended to optimize,
    as in many cases, we do not have a ready-labeled set of data.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型会随着时间的推移而退化，或者说“老化”：尽管这个过程还没有被充分理解，但模型性能往往会随时间变化，即使是因为概念漂移，即属性的定义发生变化，或者底层依赖关系的变化。不幸的是，模型性能很少会改善，至少在我的实践中是这样。因此，跟踪模型至关重要。一种方法是通过监控模型旨在优化的指标，因为在许多情况下，我们没有现成的标记数据集。
- en: In many cases, the model performance deterioration is not related directly to
    the quality of the statistical modeling, even though simpler models such as linear
    and logistic regression tend to be more stable than more complex models such as
    decision trees. Schema evolution or unnoticed renaming of attributes may cause
    the model to not perform well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，模型性能的下降并不直接与统计建模的质量相关，尽管像线性回归和逻辑回归这样的简单模型通常比决策树等更复杂的模型更稳定。模式演变或未注意到的属性重命名可能导致模型表现不佳。
- en: Part of model monitoring should be running the health check, where a model periodically
    scores either a few records or a known scored set of data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 模型监控的一部分应该是运行健康检查，其中模型定期对一些记录或已知评分的数据集进行评分。
- en: Criteria for model retiring
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退役模型的准则
- en: A very common case in practical deployments is that data scientists come with
    better sets of models every few weeks. However, if this does not happen, one needs
    come up with a set of criteria to retire a model. As real-world traffic rarely
    comes with the scored data, for example, the data that is already scored, the
    usual way to measure model performance is via a proxy, which is the metric that
    the model is supposed to improve.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际部署中，一个非常常见的案例是数据科学家每隔几周就会带来更好的模型集。然而，如果这种情况没有发生，就需要制定一套标准来淘汰模型。由于现实世界的流量很少附带评分数据，例如，已经评分的数据，衡量模型性能的通常方式是通过代理，即模型应该改进的指标。
- en: A/B testing
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A/B 测试
- en: 'A/B testing is a specific case of controlled experiment in e-commerce setting.
    A/B testing is usually applied to versions of a web page where we direct completely
    independent subset of users to each of the versions. The dependent variable to
    test is usually the response rate. Unless any specific information is available
    about users, and in many cases, it is not unless a cookie is placed in the computer,
    the split is random. Often the split is based on unique userID, but this is known
    not to work too well across multiple devices. A/B testing is subject to the same
    assumptions the controlled experiments are subject to: the tests should be completely
    independent and the distribution of the dependent variable should be `i.i.d.`.
    Even though it is hard to imagine that all people are truly `i.i.d.`, the A/B
    test has been shown to work for practical problems.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: A/B 测试是电子商务环境中控制实验的一个特定案例。A/B 测试通常应用于网页的不同版本，我们将完全独立的用户子集引导到每个版本。要测试的因变量通常是响应率。除非有关于用户的特定信息可用，而且在很多情况下，除非在计算机上放置了cookie，否则这种分割是随机的。通常，分割是基于唯一的userID，但已知这种方法在多个设备上效果不佳。A/B
    测试受到与控制实验相同的假设的影响：测试应该是完全独立的，因变量的分布应该是`i.i.d.`。尽管很难想象所有人都是真正的`i.i.d.`，但A/B 测试已被证明适用于实际问题。
- en: In modeling, we split the traffic to be scored into two or multiple channels
    to be scored by two or multiple models. Further, we need to measure the cumulative
    performance metric for each of the channels together with estimated variance.
    Usually, one of the models is treated as a baseline and is associated with the
    null hypothesis, and for the rest of the models, we run a t-test, comparing the
    ratio of the difference to the standard deviation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模中，我们将要评分的流量分割成两个或多个通道，由两个或多个模型进行评分。进一步，我们需要测量每个通道的累积性能指标以及估计的方差。通常，其中一个模型被视为基线，与零假设相关联，而对于其他模型，我们运行t检验，比较差异与标准差的比例。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter described system, application, and model monitoring goals together
    with the existing monitoring solutions for Scala, and specifically Scalatra. Many
    metrics overlap with standard OS or Java monitoring, but we also discussed how
    to create application-specific metrics and health checks. We talked about a new
    emerging field of model monitoring in an ML application, where statistical models
    are subject to deterioration, health, and performance monitoring. I also touched
    on monitoring distributed systems, a topic that really deserves much more space,
    which unfortunately, I did not have.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了系统、应用和模型监控目标，以及Scala和Scalatra现有的监控解决方案。许多指标与标准操作系统或Java监控重叠，但我们还讨论了如何创建特定于应用的指标和健康检查。我们讨论了机器学习应用中新兴的模型监控领域，其中统计模型受到退化、健康和性能监控的影响。我还简要提到了分布式系统的监控，这是一个真正值得更多篇幅讨论的话题，但遗憾的是，我没有足够的空间来展开。
- en: This is the end of the book, but in no way is it the end of the journey. I am
    sure, new frameworks and applications are being written as we speak. Scala has
    been a pretty awesome and succinct development tool in my practice, with which
    I've been able to achieve results in hours instead of days, which is the case
    with more traditional tools, but it is yet to win the popular support, which I
    am pretty sure it. We just need to emphasize its advantages in the modern world
    of interactive analysis, complex data, and distributed processing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的结尾，但绝对不是旅程的终点。我相信，当我们说话的时候，新的框架和应用正在被编写。Scala在我的实践中已经是一个非常出色且简洁的开发工具，我能够用几个小时而不是几天的时间实现结果，这在更传统的工具中是常见的情况，但它尚未赢得广泛的认可，我非常确信它会。我们只需要强调它在现代交互式分析、复杂数据和分布式处理世界中的优势。
