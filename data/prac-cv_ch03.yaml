- en: Image Filtering and Transformations in OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV中的图像滤波和变换
- en: In this chapter, you will learn the basic building blocks for computer vision
    applications. We are already familiar with digital cameras and smartphone devices
    with auto image enhancement or color adjustments to make our photographs more
    pleasing. The techniques behind these originated long ago and have come through
    several iterations to become better and faster. Many of the techniques explained
    in this chapter also become major preprocessing techniques for object detection
    and object classification tasks introduced later. Hence, it is very important
    to study these techniques and understand their applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习计算机视觉应用的基本构建块。我们已经熟悉带有自动图像增强或颜色调整功能的数码相机和智能手机设备，以使我们的照片更加令人愉悦。这些技术背后的原理很久以前就出现了，经过多次迭代变得更好更快。本章中解释的许多技术也成为了后来介绍的对象检测和对象分类任务的主要预处理技术。因此，研究这些技术并理解其应用非常重要。
- en: You will study the basis for these applications with several techniques for
    filtering an image linearly as well as non-linearly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习这些应用的基础，包括线性以及非线性滤波图像的几种技术。
- en: Later in the chapter, you will also study transformation techniques and downsampling
    techniques. A code is provided together with explanations and sample output. Readers
    are encouraged to write the code and experiment with changing parameters to understand
    several concepts. There are several colored image results in this chapter, for
    an effective understanding download the images from book's website.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你还将学习变换技术和下采样技术。这里提供了一个代码示例，包括解释和示例输出。鼓励读者编写代码并尝试更改参数以理解几个概念。本章中包含几个彩色图像结果，为了有效理解，请从本书的网站上下载图像。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Datasets and libraries required
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的数据集和库
- en: Image manipulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理
- en: Introduction to filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滤波器简介
- en: Transformations on an image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像上的变换
- en: Image pyramids
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像金字塔
- en: Datasets and libraries required
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要的数据集和库
- en: 'We will be using a sample image for most of this task. However, you can try
    the code with any other image or also use a webcam to see live results. The libraries
    used in this chapter are `OpenCV`, `NumPy`, and `matplotlib`. Even if you are
    not acquainted with libraries, you can still understand the code and implement
    them. There are also remarks for special cases when using a Jupyter notebook for
    the code written here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务的大部分过程中，我们将使用一个示例图像。然而，你也可以尝试使用任何其他图像，或者使用摄像头查看实时结果。本章使用的库有`OpenCV`、`NumPy`和`matplotlib`。即使你不熟悉这些库，你仍然可以理解代码并实现它们。对于这里编写的代码，还有一些关于特殊情况的备注，当使用Jupyter笔记本时：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The sample image used in this chapter can be loaded as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的示例图像可以按以下方式加载：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This image can be plotted either using `OpenCV` or `matplotlib` libraries.
    We will be using `matplotlib` for the majority of plots as this will be beneficial
    in plotting other kinds of data as well in later chapters. A plotting function
    for a colored image read in `OpenCV` is defined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像可以使用`OpenCV`或`matplotlib`库进行绘制。我们将主要使用`matplotlib`进行绘图，因为这将有助于在后面的章节中绘制其他类型的数据。以下是一个读取`OpenCV`中的彩色图像的绘图函数：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The previously read image can be plotted as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之前读取的图像可以按以下方式绘制：
- en: '![](img/f28cc829-37ea-4a73-b5bb-4a0074939687.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f28cc829-37ea-4a73-b5bb-4a0074939687.png)'
- en: 'The image in Python is a NumPy array, so all of the array operations are still
    valid in the image. For example, you can crop an image by using array slicing:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，图像是一个NumPy数组，因此所有数组操作在图像中仍然有效。例如，你可以通过数组切片来裁剪图像：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](img/3dfa0d43-e7b1-4684-8701-ab22ab36d5ef.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dfa0d43-e7b1-4684-8701-ab22ab36d5ef.png)'
- en: Image manipulation
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像处理
- en: As explained in previous chapters, an image in the digital domain, such as on
    a computer, is made up of a grid-like structure with each grid cell termed a **pixel**.
    These pixels store a value representing information about the image. For a simple
    grayscale image, these pixels store an integer with range [0, 255]. Changing these
    pixel values also changes the image. One of the basic image manipulation techniques
    is modifying pixel values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，在数字域中，例如在计算机上，图像由一个网格状结构组成，每个网格单元被称为**像素**。这些像素存储一个表示图像信息的值。对于简单的灰度图像，这些像素存储一个范围在[0,
    255]的整数。改变这些像素值也会改变图像。基本图像处理技术之一就是修改像素值。
- en: 'Let''s start by displaying what is inside an image at pixel level. For simplicity,
    we will do analysis on a grayscale image:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从显示图像在像素级别的内部内容开始。为了简单起见，我们将对灰度图像进行分析：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The earlier code reads a grayscale image from a file, in this case the image
    is in PNG format. We can also convert from one type of image color format to another.
    In this case, to convert a colored image to grayscale, `OpenCV` provides functions
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的代码从文件中读取灰度图像，在这种情况下，图像是 PNG 格式。我们也可以将一种图像颜色格式转换为另一种格式。在这种情况下，要将彩色图像转换为灰度，`OpenCV`
    提供了以下函数：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previously shown code for displaying an image takes only a colored image
    as input, so to display a grayscale image there needs to be some modification:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示图像的代码只接受彩色图像作为输入，因此要显示灰度图像需要进行一些修改：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the previous code is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '![](img/ddb8d425-b42f-4561-886a-0918e0a1e6f9.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddb8d425-b42f-4561-886a-0918e0a1e6f9.png)'
- en: 'We can display a small patch from this image as follows, that shows pixel values:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下显示图像的一个小区域，显示像素值：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will produce an image of the patch and prints out the value extracted
    in that patch:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个图像块，并打印出在该图像块中提取的值：
- en: '![](img/32168a89-43ce-44a6-81bc-0dda59da5563.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32168a89-43ce-44a6-81bc-0dda59da5563.png)'
- en: 'Corresponding values are as follows, the lower values represent more darker
    regions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的值如下，较低的值表示较暗的区域：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are the intensities for a pixel and is represented as a two-dimensional
    array. The range of each pixel value is 0-255\. In order to modify image, we change
    these pixel values. A simple filtering for images is applying point operation
    targeted to multiply and add constants to each pixel values. We will see this
    type of filters in detail in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是像素的强度，表示为二维数组。每个像素值的范围是 0-255。为了修改图像，我们改变这些像素值。对图像进行简单过滤的方法是对每个像素值应用点操作，乘以常数并加到每个像素值上。我们将在下一节中详细看到这种类型的过滤器。
- en: In this section, we saw basic IO extending our discussion from [Chapter 1](prac-cv_ch01.html), *A
    Fast Introduction to Computer Vision*. In further section, we will see how to
    modify these using filters which are used in image editing applications on smartphones,
    desktops and even on social media applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了基本输入输出，扩展了从[第 1 章](prac-cv_ch01.html)，《快速入门计算机视觉》的讨论。在下一节中，我们将看到如何使用过滤器修改这些内容，这些过滤器用于智能手机、桌面甚至社交媒体应用程序上的图像编辑应用。
- en: Introduction to filters
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器简介
- en: Filters are operations on an image to modify them so that they are usable for
    other computer vision tasks or to give us required information. These perform
    various functions such as removing noise from an image, extracting edges in an
    image, blurring an image, removing unwanted objects etc. We will see their implementations
    and understand the results.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是对图像进行操作以修改它们，以便它们可用于其他计算机视觉任务或为我们提供所需信息。这些执行各种功能，如从图像中去除噪声、提取图像中的边缘、模糊图像、去除不需要的对象等。我们将看到它们的实现并理解结果。
- en: Filtering techniques are necessary because there are several factors that may
    lead to noise in an image or undesired information in an image. Taking a picture
    in sunlight, induces lots of bright and dark areas in the image or an improper
    environment like night time, the image captured by a camera may contain a lot
    of noise. Also, in cases of unwanted objects or colors in an image, these are
    also considered noise.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤技术是必要的，因为有几个因素可能导致图像中存在噪声或不需要的信息。在阳光下拍照，会在图像中产生很多明亮和暗淡的区域，或者在夜间等不适当的环境中，相机捕获的图像可能包含大量噪声。此外，在图像中存在不需要的对象或颜色的情况下，这些也被认为是噪声。
- en: 'An example of salt and pepper noise looks like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 盐和胡椒噪声的例子如下所示：
- en: '![](img/832dbbce-3b05-4208-9746-619c5d1d7f35.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/832dbbce-3b05-4208-9746-619c5d1d7f35.png)'
- en: 'The preceding image can be easily generated using OpenCV as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以很容易地使用 OpenCV 以下列方式生成前面的图像：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s add weighted noise to a grayscale image (on the left) so the resulting
    image will look like the one on the right:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在灰度图像（左侧）上添加加权噪声，以便生成的图像将看起来像右侧的图像：
- en: '![](img/2e1e664e-4a85-47ec-8455-00cab6441e06.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e1e664e-4a85-47ec-8455-00cab6441e06.png)'
- en: 'The code for this is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `0.2` is used as parameter, increase or decrease the value to create different
    intensity noise.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`0.2` 被用作参数，增加或减少该值以创建不同强度的噪声。
- en: In several applications, noise plays an important role in improving a system's
    capabilities, especially when we will use Deep Learning based models in the upcoming
    chapters. It is quite crucial for several applications, to know how robust the
    application is against noise becomes very important. As an example, we would want
    the model designed for applications like image classification to work with noisy
    images as well, hence noise is deliberately added in the images to test the application
    precision.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个应用中，噪声在提高系统能力方面起着重要作用，尤其是在我们将在接下来的章节中使用基于深度学习的模型时。对于几个应用来说，了解应用对噪声的鲁棒性变得非常重要。例如，我们希望为图像分类等应用设计的模型也能处理带噪声的图像，因此故意在图像中添加噪声以测试应用的精度。
- en: Linear filters
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性过滤器
- en: 'To begin with, the simplest kind of filter is a point operator, where each
    pixel value is multiplied by a scalar value. This operation can be written as
    follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最简单的过滤器类型是点操作符，其中每个像素值乘以一个标量值。这个操作可以写成如下：
- en: '![](img/acf011fc-6afd-45e3-8d9c-5a9ba99c771f.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acf011fc-6afd-45e3-8d9c-5a9ba99c771f.png)'
- en: 'Here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里：
- en: The input image is F and the value of pixel at *(i,j)* is denoted as *f(i,j)*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入图像是 F，像素在 *(i,j)* 的值表示为 *f(i,j)*
- en: The output image is G and the value of pixel at *(i,j) *is denoted as *g(i,j)*
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出图像是 G，像素在 *(i,j)* 的值表示为 *g(i,j)*
- en: '*K* is scalar constant'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*K* 是标量常数'
- en: 'Such an operation on an image is termed a **linear** **filter**. There are
    many more kinds of linear filters which you will be reading about further in this
    section. In addition to multiplication by a scalar value, each pixel can also
    be increased or decreased by a constant value. So overall point operation can
    be written as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对图像进行的这种操作被称为 **线性** **过滤器**。在本节中，你将了解到更多种类的线性过滤器。除了乘以标量值之外，每个像素也可以通过一个常数值增加或减少。因此，整体点操作可以写成如下：
- en: '![](img/60552f1f-9e00-47fc-823f-a5057422b8e4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60552f1f-9e00-47fc-823f-a5057422b8e4.png)'
- en: 'This operation can be applied both to grayscale images and RGB images. For
    RGB images, each channel will be modified with this operation separately. The
    following is the result of varying both *K* and *L*. The first image is input
    on the left. In the second image, `*K*=0.5` and `*L*=0.0`, while in the third
    image, *K* is set to `1.0` and *L* is `10`. For the final image on the right,
    `*K*=0.7` and `*L*=25`. As you can see, varying *K* changes the brightness of
    the image and varying *L* changes the contrast of the image:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作可以应用于灰度图像和RGB图像。对于RGB图像，每个通道将分别使用此操作进行修改。以下是在改变 *K* 和 *L* 时的结果。左边的第一幅图像是输入图像。在第二幅图像中，`*K*=0.5`
    且 `*L*=0.0`，而在第三幅图像中，*K* 设置为 `1.0` 且 *L* 为 `10`。对于右边的最终图像，`*K*=0.7` 且 `*L*=25`。正如你所见，改变
    *K* 会改变图像的亮度，而改变 *L* 会改变图像的对比度：
- en: '![](img/3550feb8-129d-42f3-94a1-27361f68de4d.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3550feb8-129d-42f3-94a1-27361f68de4d.png)'
- en: 'This image can be generated with the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像可以用以下代码生成：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 2D linear filters
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D 线性过滤器
- en: While the preceding filter is a point-based filter, image pixels have information
    around the pixel as well. In the previous image of the flower, the pixel values
    in the petal are all yellow. If we choose a pixel of the petal and move around,
    the values will be quite close. This gives some more information about the image.
    To extract this information in filtering, there are several neighborhood filters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的过滤器是一个基于点的过滤器，但图像像素周围也有信息。在之前的花朵图像中，花瓣中的像素值都是黄色。如果我们选择花瓣中的一个像素并移动，这些值将非常接近。这为图像提供了一些更多信息。为了在过滤中提取这些信息，有几种邻域过滤器。
- en: 'In neighborhood filters, there is a kernel matrix which captures local region
    information around a pixel. To explain these filters, let''s start with an input
    image, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在邻域过滤器中，有一个核矩阵，它捕捉像素周围的局部区域信息。为了解释这些过滤器，让我们从一个输入图像开始，如下所示：
- en: '![](img/eef640fc-0d99-4136-bd18-bce5b1f26cc9.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eef640fc-0d99-4136-bd18-bce5b1f26cc9.png)'
- en: 'This is a simple binary image of the number 2\. To get certain information
    from this image, we can directly use all the pixel values. But instead, to simplify,
    we can apply filters on this. We define a matrix smaller than the given image
    which operates in the neighborhood of a target pixel. This matrix is termed **kernel**; an
    example is given as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的二值图像，数字为 2。要从这个图像中获取某些信息，我们可以直接使用所有像素值。但为了简化，我们可以应用过滤器。我们定义一个比给定图像小的矩阵，它在目标像素的邻域内操作。这个矩阵被称为
    **核**；以下是一个示例：
- en: '![](img/2b892f25-b7e8-40cb-a8ad-18db2bf256fe.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b892f25-b7e8-40cb-a8ad-18db2bf256fe.png)'
- en: 'The operation is defined first by superimposing the kernel matrix on the original
    image, then taking the product of the corresponding pixels and returning a summation
    of all the products. In the following figure, the lower 3 x 3 area in the original
    image is superimposed with the given kernel matrix and the corresponding pixel
    values from the kernel and image are multiplied. The resulting image is shown
    on the right and is the summation of all the previous pixel products:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作首先通过将核矩阵叠加到原始图像上，然后取对应像素的乘积并返回所有乘积的总和来定义。在以下图中，原始图像下方的3 x 3区域与给定的核矩阵叠加，并且核和图像中的对应像素值相乘。结果图像显示在右侧，是所有先前像素乘积的总和：
- en: '![](img/66b04090-921d-488b-b5c6-37f1fa8e8e7c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66b04090-921d-488b-b5c6-37f1fa8e8e7c.png)'
- en: 'This operation is repeated by sliding the kernel along image rows and then
    image columns. This can be implemented as in following code. We will see the effects
    of applying this on an image in coming sections:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作通过沿图像行和列滑动核来重复进行。这可以像以下代码那样实现。我们将在接下来的章节中看到应用此操作在图像上的效果：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, as you can see previously, the corner pixel will have a drastic impact
    and results in a smaller image because the kernel, while overlapping, will be
    outside the image region. This causes a black region, or holes, along with the
    boundary of an image. To rectify this, there are some common techniques used:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如之前所看到的，角落像素将产生巨大影响，并导致图像尺寸减小，因为核在重叠时将超出图像区域。这会在图像边界处产生黑色区域或空洞。为了纠正这一点，有一些常用的技术：
- en: Padding the corners with constant values maybe 0 or 255, by default `OpenCV`
    will use this.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用常数值（可能是0或255）填充角落，默认情况下`OpenCV`将使用此值。
- en: Mirroring the pixel along the edge to the external area
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿边缘将像素镜像到外部区域
- en: Creating a pattern of pixels around the image
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像周围创建像素模式
- en: The choice of these will depend on the task at hand. In common cases, padding
    will be able to generate satisfactory results.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择将取决于手头的任务。在常见情况下，填充能够生成令人满意的结果。
- en: The effect of the kernel is most crucial as changing these values changes the
    output significantly. We will first see simple kernel-based filters and also see
    their effects on the output when changing the size.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 核的效果最为关键，因为这些值的改变会显著改变输出。我们将首先看到简单的基于核的过滤器，并看到在改变大小时的输出效果。
- en: Box filters
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盒式滤波器
- en: 'This filter averages out the pixel value as the kernel matrix is denoted as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此过滤器将像素值平均化，如核矩阵如下所示：
- en: '![](img/a69e58ed-7853-40df-b3e2-5d7f5ce62526.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a69e58ed-7853-40df-b3e2-5d7f5ce62526.png)'
- en: 'Applying this filter results in blurring the image. The results are as shown
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此过滤器会导致图像模糊。结果如下所示：
- en: '![](img/1454f664-20c7-49a1-b53b-ac0a35a0153f.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1454f664-20c7-49a1-b53b-ac0a35a0153f.png)'
- en: 'In frequency domain analysis of the image, this filter is a low pass filter.
    The frequency domain analysis is done using Fourier transformation of the image,
    which is beyond the scope of this introduction. We can see on changing the kernel
    size, the image gets more and more blurred:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像的频域分析中，此过滤器是一个低通滤波器。频域分析是通过图像的傅里叶变换来完成的，这超出了本介绍的范畴。我们可以看到，随着核大小的改变，图像变得越来越模糊：
- en: '![](img/f2c49b04-1730-40ea-b3a4-ef664ec4eaec.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2c49b04-1730-40ea-b3a4-ef664ec4eaec.png)'
- en: 'As we increase the size of the kernel, we can observe that resulting image
    gets more blurred. This is due to averaging out of peak values in the small neighborhood
    where the kernel is applied. The result for applying kernel of size 20 x 20 can
    be seen in the following image:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 随着核大小的增加，我们可以观察到结果图像变得越来越模糊。这是由于在应用核的小邻域内平均峰值值。应用20 x 20大小核的结果可以在以下图像中看到：
- en: '![](img/7d799059-e43e-4a7c-bded-a7f40456a585.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d799059-e43e-4a7c-bded-a7f40456a585.png)'
- en: 'However, if we use a very small filter of size (3, 3) there is negligible effect
    on the output, due to the fact that the kernel size is quite small compared to
    the photo size. In most applications, kernel size is heuristically set according
    to image size:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用一个非常小的（3, 3）大小的过滤器，由于核大小与照片大小相比相当小，因此对输出几乎没有影响。在大多数应用中，核大小是根据图像大小进行启发式设置的：
- en: '![](img/524cdf06-249f-425f-b360-aaa7e1cd0e85.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/524cdf06-249f-425f-b360-aaa7e1cd0e85.png)'
- en: 'The complete code to generate box filtered photos is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 生成盒式滤波图像的完整代码如下：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Properties of linear filters
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性滤波器的属性
- en: 'Several computer vision applications are composed of step by step transformations
    of an input photo to output. This is easily done due to several properties associated
    with a common type of filters, that is, linear filters:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 几个计算机视觉应用是由输入照片到输出的逐步转换组成的。这很容易做到，因为与常见类型的过滤器（即线性过滤器）相关联的几个属性：线性过滤器：
- en: 'The linear filters are commutative such that we can perform multiplication
    operations on filters in any order and the result still remains the same:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性过滤器是可交换的，这意味着我们可以以任何顺序对过滤器执行乘法运算，结果仍然相同：
- en: '*a * b = b * a*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*a * b = b * a*'
- en: 'They are associative in nature, which means the order of applying the filter
    does not effect the outcome:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在本质上具有关联性，这意味着应用过滤器的顺序不会影响结果：
- en: '*(a * b) * c = a * (b * c)*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*(a * b) * c = a * (b * c)*'
- en: 'Even in cases of summing two filters, we can perform the first summation and
    then apply the filter, or we can also individually apply the filter and then sum
    the results. The overall outcome still remains the same:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在两个过滤器求和的情况下，我们也可以先进行求和然后应用过滤器，或者我们也可以分别应用过滤器然后求和结果。整体结果仍然相同：
- en: '*b = (k+l) * a*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*b = (k+l) * a*'
- en: Applying a scaling factor to one filter and multiplying to another filter is
    equivalent to first multiplying both filters and then applying scaling factor
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将缩放因子应用于一个过滤器并将其乘以另一个过滤器等同于首先将两个过滤器相乘，然后应用缩放因子
- en: These properties play a significant role later, when we look at computer vision
    tasks such as object detection, segmentation, and so on. A suitable combination
    of these filters enhances the quality of information extraction and as a result,
    improves the accuracy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性在后续处理计算机视觉任务，如目标检测、分割等时起着重要作用。这些过滤器的适当组合可以增强信息提取的质量，从而提高准确性。
- en: Non-linear filters
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非线性过滤器
- en: While in many cases linear filters are sufficient to get the required results,
    in several other use cases performance can be significantly increased with the
    use of non-linear filters. As the name suggests, these filters are composed of
    more complex operations, have some kind of non-linearity, and as a result these
    filters do not follow some or all of the properties of linear filters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在许多情况下线性过滤器足以获得所需的结果，但在几个其他用例中，使用非线性过滤器可以显著提高性能。正如其名所示，这些过滤器由更复杂的操作组成，具有某种非线性，因此这些过滤器不遵循线性过滤器的某些或所有属性。
- en: We will understand these filters with implementations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过实现来理解这些过滤器。
- en: Smoothing a photo
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平滑照片
- en: Applying a box filter with hard edges doesn't result in a smooth blur on the
    output photo.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用具有硬边缘的盒式过滤器不会在输出照片上产生平滑的模糊效果。
- en: 'To improve this, the filter can be made smoother around the edges. One of the
    popular such filters is a **Gaussian filter**. This is a non-linear filter which
    enhances the effect of the center pixel and gradually reduces the effects as the
    pixel gets farther from the center. Mathematically, a Gaussian function is given
    as:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这一点，过滤器可以在边缘处变得更加平滑。这类流行的过滤器之一是**高斯过滤器**。这是一个非线性过滤器，它增强了中心像素的效果，并随着像素远离中心而逐渐减少效果。数学上，高斯函数如下所示：
- en: '![](img/3c1a20e0-6024-4028-9d72-f812f13151ff.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c1a20e0-6024-4028-9d72-f812f13151ff.png)'
- en: where μ is mean and σ is variance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 μ 是均值，σ 是方差。
- en: 'An example kernel matrix for this kind of filter in a two-dimensional discrete
    domain is given as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维离散域中，此类过滤器的一个示例核矩阵如下所示：
- en: '![](img/fa06aa76-4958-476d-836d-aab5b7801689.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa06aa76-4958-476d-836d-aab5b7801689.png)'
- en: 'This two-dimensional array is used in normalized form and effect of this filter
    also depends on its width by changing the kernel width has varying effects on
    the output as discussed in further section. Applying Gaussian kernel as filter
    removes high-frequency components which results in removing strong edges and hence
    a blurred photo:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二维数组以归一化形式使用，并且该滤波器的影响也取决于其宽度，通过改变核宽度，在后续章节中讨论的输出效果会有所不同。应用高斯核作为过滤器可以去除高频成分，从而去除强烈的边缘，因此照片变得模糊：
- en: '![](img/560325e5-14f4-44f4-ac22-76439f27394b.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/560325e5-14f4-44f4-ac22-76439f27394b.png)'
- en: 'While this filter performs better blurring than a box filter, the implementation
    is also quite simple with OpenCV:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个过滤器比盒式过滤器具有更好的模糊效果，但使用OpenCV的实现也非常简单：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Histogram equalization
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: 'The basic point operations, to change the brightness and contrast, help in
    improving photo quality but require manual tuning. Using histogram equalization
    technique, these can be found algorithmically and create a better-looking photo.
    Intuitively, this method tries to set the brightest pixels to white and the darker
    pixels to black. The remaining pixel values are similarly rescaled. This rescaling
    is performed by transforming original intensity distribution to capture all intensity
    distribution. An example of this equalization is as following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基本点操作，如改变亮度和对比度，有助于提高照片质量，但需要手动调整。使用直方图均衡化技术，这些可以通过算法找到，并创建出更好看的照片。直观上，这种方法试图将最亮的像素设置为白色，将较暗的像素设置为黑色。其余像素值相应缩放。这种缩放是通过将原始强度分布转换为捕获所有强度分布来执行的。以下是一个均衡化的示例：
- en: '![](img/a2e536d1-f279-4e31-94bd-d14d78cbb990.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2e536d1-f279-4e31-94bd-d14d78cbb990.png)'
- en: 'The preceding image is an example of histogram equalization. On the right is
    the output and, as you can see, the contrast is increased significantly. The input
    histogram is shown in the bottom figure on the left and it can be observed that
    not all the colors are observed in the image. After applying equalization, resulting
    histogram plot is as shown on the right bottom figure. To visualize the results
    of equalization in the image, the input and results are stacked together in following
    figure:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像是直方图均衡化的一个示例。在右侧是输出，如图所示，对比度显著增加。输入直方图显示在左侧底部图中的底部图，可以观察到并非所有颜色都在图像中。应用均衡化后，结果直方图如图右侧底部图所示。为了在图像中可视化均衡化的结果，输入和结果在以下图中堆叠在一起：
- en: '![](img/310afc41-7651-464e-aa2e-0e8d4b2bd65e.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/310afc41-7651-464e-aa2e-0e8d4b2bd65e.png)'
- en: 'Code for the preceding photos is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面照片的代码如下：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Median filter
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中值滤波
- en: This filter uses the same technique of neighborhood filtering; the key technique
    in this is the use of a median value. As such, the filter is non-linear. It is
    quite useful in removing sharp noise such as salt and pepper.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此滤波器使用与邻域滤波相同的技巧；关键技巧是使用中值值。因此，该滤波器是非线性的。它在去除如盐和胡椒等尖锐噪声方面非常有用。
- en: Instead of using a product or sum of neighborhood pixel values, this filter
    computes a median value of the region. This results in the removal of random peak
    values in the region, which can be due to noise like salt and pepper noise. This
    is further shown in the following figure with different kernel size used to create
    output.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用邻域像素值的乘积或和不同，此滤波器计算该区域的中间值。这导致区域中随机峰值值的移除，这可能是由于盐和胡椒噪声等噪声引起的。以下图示展示了使用不同内核大小创建输出时的进一步说明。
- en: 'In this image first input is added with channel wise random noise as:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图像中，首先输入加上通道随机噪声如下：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The created noisy image is used for median filtering as:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的噪声图像用于中值滤波如下：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the following photo, you can see the resulting photo after varying the kernel
    size (indicated in brackets). The rightmost photo is the smoothest of them all:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下照片中，你可以看到通过改变内核大小（括号中所示）得到的结果照片。最右边的是其中最平滑的：
- en: '![](img/9e6b982a-c653-4e59-9017-302280a84143.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e6b982a-c653-4e59-9017-302280a84143.png)'
- en: The most common application for median blur is in smartphone application which
    filters input image and adds additional artifacts to add artistic effects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 中值模糊的最常见应用是在智能手机应用程序中，它过滤输入图像并添加额外的伪影以添加艺术效果。
- en: 'The code to generate the preceding photograph is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 生成前面照片的代码如下：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Image gradients
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像梯度
- en: These are more *edge detectors* or sharp changes in a photograph. Image gradients
    widely used in object detection and segmentation tasks. In this section, we will
    look at how to compute image gradients. First, the image derivative is applying
    the kernel matrix which computes the change in a direction.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是更 *边缘检测器* 或照片中的急剧变化。图像梯度在目标检测和分割任务中广泛使用。在本节中，我们将探讨如何计算图像梯度。首先，图像导数是应用内核矩阵，该矩阵计算方向上的变化。
- en: 'The Sobel filter is one such filter and kernel in the *x *direction is given
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 索贝尔滤波器就是这样一种滤波器和内核，*x* 方向的内核如下所示：
- en: '![](img/5a5dd501-0ded-40c5-8978-38357785667b.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a5dd501-0ded-40c5-8978-38357785667b.png)'
- en: 'Here, in the *y *direction:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在 *y* 方向上：
- en: '![](img/b51855e0-69c3-4f41-a6a6-c6cff1f279b1.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b51855e0-69c3-4f41-a6a6-c6cff1f279b1.png)'
- en: 'This is applied in a similar fashion to the linear box filter by computing
    values on a superimposed kernel with the photo. The filter is then shifted along
    the image to compute all values. Following is some example results, where *X*
    and *Y* denote the direction of the Sobel kernel:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这与线性盒式滤波器以类似的方式应用，通过在叠加的核上计算与照片的值。然后滤波器沿着图像移动以计算所有值。以下是一些示例结果，其中 *X* 和 *Y* 表示
    Sobel 核的方向：
- en: '![](img/ec732c3c-95a0-4d6f-b690-9ef80b6f877f.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec732c3c-95a0-4d6f-b690-9ef80b6f877f.png)'
- en: This is also termed as an image derivative with respect to given direction(here
    X or Y). The lighter resulting photographs (middle and right) are positive gradients,
    while the darker regions denote negative and gray is zero.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为相对于给定方向（此处为 X 或 Y）的图像导数。较亮的生成照片（中间和右侧）是正梯度，而较暗的区域表示负梯度，灰色为零。
- en: 'While Sobel filters correspond to first order derivatives of a photo, the Laplacian
    filter gives a second-order derivative of a photo. The Laplacian filter is also
    applied in a similar way to Sobel:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Sobel 滤波器对应于照片的一阶导数，但拉普拉斯滤波器给出照片的二阶导数。拉普拉斯滤波器也以类似的方式应用于 Sobel：
- en: '![](img/bbbbf462-e1ab-419c-8a1f-1c8d9f2933df.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbbbf462-e1ab-419c-8a1f-1c8d9f2933df.png)'
- en: 'The code to get Sobel and Laplacian filters is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Sobel 和拉普拉斯滤波器的代码如下：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Transformation of an image
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像的变换
- en: Transformation operations on an image are usually referred to as geometric transformations,
    applied on a photo. There are several other kinds of transformations as well but
    in this section we will refer to geometric transformations. These consist of,
    but are not limited to, shifting an image, rotating an image along an axis, or
    projecting it onto different planes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图像上的变换通常被称为几何变换，应用于照片。还有其他几种变换，但在这个部分我们将讨论几何变换。这些包括但不限于移动图像、沿轴旋转图像或将其投影到不同的平面上。
- en: At the core of transformation is a matrix multiplication of our image. We will
    look at different components of this matrix and the resulting image.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 变换的核心是我们图像的矩阵乘法。我们将查看这个矩阵的不同组成部分以及生成的图像。
- en: Translation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平移
- en: 'Displacement of an image in any direction can be done by creating a transformation
    matrix and applying the transformation to our image. The transformation matrix
    for translation only is given as:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何方向上移动图像可以通过创建一个变换矩阵并将变换应用于我们的图像来完成。仅平移的变换矩阵如下：
- en: '![](img/c1d16c6a-71f3-4e89-b5a3-259913998bb3.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d16c6a-71f3-4e89-b5a3-259913998bb3.png)'
- en: 'where *t[x]* is translation in *x* direction and *t[y]* in *y* direction in
    image reference. On choosing different values of translation matrix, results are
    shown as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *t[x]* 是图像中 *x* 方向的平移，*t[y]* 是图像中 *y* 方向的平移。选择不同的平移矩阵值，结果如下所示：
- en: '![](img/eb52c7e8-32e0-42db-aa93-ef25e6449def.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb52c7e8-32e0-42db-aa93-ef25e6449def.png)'
- en: In the previous figure, output is images are larger than the input image to
    show the effects of translation otherwise only visible region of images which
    are inside the original image size will be shown.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，输出图像比输入图像大，以显示平移的效果，否则只有图像的可见区域（位于原始图像大小内）将被显示。
- en: 'Code for creating this translation is given as follows, here change the values
    of `tx` and `ty` to generate different translations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此平移的代码如下，在此处更改 `tx` 和 `ty` 的值以生成不同的平移：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Rotation
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转
- en: 'Similar to translation, rotating an image is also possible by creating a transformation
    matrix. Instead of creating translation matrix, in `OpenCV`, given a rotation
    angle θ, a rotation matrix is created of the form:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与平移类似，通过创建一个变换矩阵也可以旋转图像。在 `OpenCV` 中，给定一个旋转角度 θ，创建一个以下形式的旋转矩阵：
- en: '![](img/587e03b9-ffdb-4b57-9be5-50036accd864.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/587e03b9-ffdb-4b57-9be5-50036accd864.png)'
- en: where,
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，
- en: '![](img/41e76660-f4cb-4a31-b01e-e55cf7a96bdf.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41e76660-f4cb-4a31-b01e-e55cf7a96bdf.png)'
- en: 'An example of applying result is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 应用结果的示例如下：
- en: '![](img/8018b5d3-c2c3-45e1-9843-cf02e1c30336.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8018b5d3-c2c3-45e1-9843-cf02e1c30336.png)'
- en: 'For the previous screenshot, the code is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的截图，代码如下：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Similarly, transformations also can be done by combining both rotation and translation
    with scaling and as a result, the angle between the lines will be preserved.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，也可以通过结合旋转和变换以及缩放来完成变换，从而保持线条之间的角度。
- en: Affine transform
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斜变换
- en: 'With an Affine transform, only parallel lines will be preserved in the output.
    An example output image is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仿射变换，输出中只保留平行线。以下是一个示例输出图像：
- en: '![](img/65de58b3-1166-42a6-b0c2-087721d67790.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65de58b3-1166-42a6-b0c2-087721d67790.png)'
- en: 'The code for the preceding image is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图像的代码如下：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Image pyramids
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像金字塔
- en: Pyramids refer to rescaling a photograph either increasing the resolution or
    decreasing it. These are often used to increase the computation efficiency of
    computer vision algorithms such as image matching in a huge database. In such
    cases, image matching is computed on a downsampled image and later on the search
    is iteratively refined for a higher resolution of the image.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 塔形结构指的是对照片进行缩放，要么增加分辨率，要么降低分辨率。这些通常用于提高计算机视觉算法的计算效率，例如在大型数据库中进行图像匹配。在这种情况下，图像匹配是在下采样图像上计算的，然后对图像的搜索会迭代地细化以获得更高分辨率的图像。
- en: 'The downsampling and upsampling often depend on the pixel selection process.
    One of the simplest processes is selecting alternative rows and column pixel values
    to create a downsampled version of the photo as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下采样和上采样通常取决于像素选择过程。其中最简单的过程是选择交替的行和列像素值，以创建照片的下采样版本，如下所示：
- en: '![](img/1f47cd63-6f43-4d7a-852a-60856e46c764.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f47cd63-6f43-4d7a-852a-60856e46c764.png)'
- en: 'However, if we try to upsample from the rightmost picture in the previous figure,
    the results look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试从上一图最右侧的图片上采样，结果看起来如下：
- en: '![](img/c6bdefdf-a24f-4d3d-87a6-4954af6b19ff.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6bdefdf-a24f-4d3d-87a6-4954af6b19ff.png)'
- en: It can easily be seen that the rightmost picture above is not the same as the
    original one that we started with. This is due to the fact that we lose information
    during downsampling and hence the image cannot be recreated in the same way as
    the original one. In `OpenCV`, there is also blurring of input image before downsampling
    or upsampling. This also further makes it harder to keep the resolution intact.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，上图最右侧的图片与最初的原始图片不同。这是因为我们在下采样过程中丢失了信息，因此图像不能以与原始图像相同的方式重建。在`OpenCV`中，在下采样或上采样之前，也会对输入图像进行模糊处理。这也进一步使得保持分辨率完整变得更加困难。
- en: 'The codes for downsampling is as follow:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下采样代码如下：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And for upsampling an image to twice its height and width sizes as:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将图像上采样到其高度和宽度的两倍，如下所示：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with initial image analysis by applying various
    manipulation. We began discussion with point filters and extending to more complex
    linear as well as non linear filters. We saw the visualization of results on varying
    parameters like kernel size, and so on. The non-linear filters, like histogram
    equalization, can further tune images which are difficult to do with linear filters.
    Image gradients, introduced in this chapter, are quite common in complex tasks
    of object detection, image segmentation, and so on. We also saw various transformation
    methods like translation, rotation and affine transformation with visualization
    of the output given different choice of parameters. The various transformations
    can applied in cascaded fashion to create combined transformed results. Lastly,
    image downsampling and upsampling method is introduced which has crucial role
    in making computation faster or extracting more richer information respectively.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过应用各种操作开始了初始图像分析。我们从点滤波开始讨论，并扩展到更复杂的线性以及非线性滤波。我们看到了结果的可视化，例如在核大小等参数上的变化。非线性滤波器，如直方图均衡化，可以进一步调整那些用线性滤波器难以处理的图像。本章引入的图像梯度在复杂任务中非常常见，如目标检测、图像分割等。我们还看到了各种变换方法，如平移、旋转和仿射变换，以及不同参数选择下的输出可视化。这些变换可以以级联方式应用，以创建组合变换结果。最后，介绍了图像下采样和上采样方法，这在使计算更快或提取更丰富信息方面起着关键作用。
- en: In the next chapter, we will be going through different features and feature
    extraction methods with the importance for each.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论不同的特征和特征提取方法，并介绍每个方法的重要性。
