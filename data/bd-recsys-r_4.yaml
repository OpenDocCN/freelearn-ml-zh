- en: Chapter 4. Evaluating the Recommender Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 评估推荐系统
- en: The previous chapter showed you how to build recommender systems. There are
    a few options, and some of them can be developed using the `recommenderlab` package.
    In addition, each technique has some parameters. After we build the models, how
    can we decide which one to use? How can we determine its parameters? We can first
    test the performance of some models and/or parameter configurations and then choose
    the one that performs best.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您展示了如何构建推荐系统。有几个选项，其中一些可以使用`recommenderlab`包开发。此外，每种技术都有一些参数。在构建模型后，我们如何决定使用哪一个？如何确定其参数？我们可以首先测试一些模型和/或参数配置的性能，然后选择表现最好的一个。
- en: 'This chapter will show you how to evaluate recommender models, compare their
    performances, and choose the most appropriate model. In this chapter, we will
    cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何评估推荐模型，比较它们的性能，并选择最合适的模型。在本章中，我们将涵盖以下主题：
- en: Preparing the data to evaluate performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备数据以评估性能
- en: Evaluating the performance of some models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估某些模型的性能
- en: Choosing the best performing models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择表现最佳的模型
- en: Optimizing model parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化模型参数
- en: Preparing the data to evaluate the models
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据以评估模型
- en: To evaluate models, you need to build them with some data and test them on some
    other data. This chapter will show you how to prepare the two sets of data. The
    `recommenderlab` package contains prebuilt tools that help in this task.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估模型，你需要用一些数据构建它们，并在其他数据上测试它们。本章将向您展示如何准备这两组数据。`recommenderlab`包包含预构建的工具，有助于这项任务。
- en: 'The target is to define two datasets, which are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是定义两个数据集，如下所示：
- en: '**Training set**: These are the models from which users learn'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**训练集**：这些是从中用户学习的模型'
- en: '**Testing set**: These are the models that users apply and test'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试集**：这些是用户应用和测试的模型'
- en: 'In order to evaluate the models, we need to compare the recommendations with
    the user preferences. In order to do so, we need to forget about some user preferences
    in the test set and see whether the techniques are able to identify them. For
    each user in the test set, we ignore some purchases and build the recommendations
    based on the others. Let''s load the packages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估模型，我们需要将它们与用户偏好进行比较。为了做到这一点，我们需要忘记测试集中的某些用户偏好，看看技术是否能够识别它们。对于测试集中的每个用户，我们忽略一些购买，并根据其他购买构建推荐。让我们加载包：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The data-set that we will use is called `MovieLense`. Let''s define `ratings_movies`
    containing only the most relevant users and movies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的数据集被称为`MovieLense`。让我们定义只包含最相关用户和电影的`ratings_movies`：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are now ready to prepare the data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好准备数据。
- en: Splitting the data
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割数据
- en: 'The easiest way to build a training and test set is to split the data in two
    parts. First, we need to decide how many users to put into each part. For instance,
    we can put 80 percent of the users into the training set. We can define `percentage_training`
    by specifying the percentage of the training set:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构建训练集和测试集最简单的方法是将数据分成两部分。首先，我们需要决定将多少用户放入每一部分。例如，我们可以将80%的用户放入训练集。我们可以通过指定训练集的百分比来定义`percentage_training`：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For each user in the test set, we need to define how many items to use to generate
    recommendations. The remaining items will be used to test the model accuracy.
    It''s better that this parameter is lower than the minimum number of items purchased
    by any user so that we don''t have users without items to test the models:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试集中的每个用户，我们需要定义使用多少个项目来生成推荐。剩余的项目将用于测试模型精度。最好这个参数低于任何用户购买的最少项目数，这样我们就不需要没有项目来测试模型的用户：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For instance, we can keep `15` items:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以保留`15`个项目：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Evaluating a model consists of comparing the recommendations with the unknown
    purchases. The ratings are between 1 and 5, and we need to define what constitutes
    good and bad items. For this purpose, we will define a threshold with the minimum
    rating that is considered good:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 评估一个模型包括将推荐与未知购买进行比较。评分在1到5之间，我们需要定义什么构成好项目和坏项目。为此，我们将定义一个阈值，即被认为是好的最低评分：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is an additional parameter defining how many times we want to run the
    evaluation. For the moment, let''s set it to `1`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个额外的参数定义了我们想要运行评估的次数。目前，让我们将其设置为`1`：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are ready to split the data. The `recommenderlab` function is `evaluationScheme`
    and its parameters are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好分割数据。`recommenderlab`函数是`evaluationScheme`，其参数如下：
- en: '`data`: This is the initial dataset'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`: 这是初始数据集'
- en: '`method`: This is the way to split the data. In this case, it''s `split`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`: 这是分割数据的方式。在这种情况下，它是`split`'
- en: '`train`: This is the percentage of data in the training set'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train`: 这是训练集中数据的百分比'
- en: '`given`: This is the number of items to keep'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`given`: 这是需要保留的物品数量'
- en: '`goodRating`: This is the rating threshold'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goodRating`: 这是评分阈值'
- en: '`k`: This is the number of times to run the evaluation'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k`: 这是运行评估的次数'
- en: 'Let''s build `eval_sets` containing the sets:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建包含这些集的`eval_sets`：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to extract the sets, we need to use `getData`. There are three sets:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取这些集，我们需要使用`getData`。有三个集：
- en: '`train`: This is the training set'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train`: 这是训练集'
- en: '`known`: This is the test set, with the item used to build the recommendations'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`known`: 这是测试集，用于构建推荐的物品'
- en: '`unknown`: This is the test set, with the item used to test the recommendations'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unknown`: 这是测试集，用于测试推荐物品'
- en: 'Let''s take a look at the training set:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看训练集：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It''s a `realRatingMatrix` object, so we can apply methods such as `nrow` and
    `rowCounts` to it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个`realRatingMatrix`对象，因此我们可以对其应用如`nrow`和`rowCounts`等方法：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As expected, about 80 percent of the users are in the training set. Let''s
    take a look at the two test sets:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，大约80%的用户在训练集中。让我们看看两个测试集：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'They both have the same number of users. There should be about 20 percent of
    data in the test set:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有相同数量的用户。测试集中应该有大约20%的数据：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Everything is as expected. Let''s see how many items we have for each user
    in the `known` set. It should be equal to `items_to_keep`, that is, `15`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一切如预期。让我们看看`known`集中每个用户有多少物品。它应该等于`items_to_keep`，即`15`：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The same is not true for the users in the test set, since the number of remaining
    items depends on the initial number of purchases:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试集中的用户来说，情况并非如此，因为剩余物品的数量取决于初始购买数量：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following image displays the unknown items by the users:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了用户未知的物品：
- en: '![Splitting the data](img/B03888_04_01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![分割数据](img/B03888_04_01.jpg)'
- en: As expected, the number of items by users varies a lot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，用户拥有的物品数量差异很大。
- en: Bootstrapping data
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bootstrapping数据
- en: 'In the previous subsection, we split the data into two parts, and the training
    set contained 80 percent of the rows. What if, instead, we sample the rows with
    replacement? The same user can be sampled more than once and, if the training
    set has the same size as it did earlier, there will be more users in the test
    set. This approach is called bootstrapping, and it''s supported by `recommenderlab`.
    The parameters are the same as the previous approach. The only difference is that
    we specify `method = "bootstrap"` instead of `method = "split"`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的子节中，我们将数据分为两部分，训练集包含了80%的行。如果我们改用带替换的行采样呢？同一个用户可以被采样多次，如果训练集的大小与之前相同，测试集中将有更多的用户。这种方法被称为自助法（bootstrapping），并且由`recommenderlab`支持。参数与之前的方法相同。唯一的区别是我们指定`method
    = "bootstrap"`而不是`method = "split"`：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The number of users in the training set is still equal to 80 percent of the
    total:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 训练集中的用户数量仍然等于总用户数的80%：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, the same is not true for the items in the test set:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于测试集中的物品来说，情况并非如此：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The test set is more than twice as big as the previous set.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集比之前的集大两倍以上。
- en: 'We can extract the unique users in the training set:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提取训练集中的独特用户：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The percentage of unique users in the training set should be complementary
    to the percentage of users in the test set, which is shown as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 训练集中独特用户的百分比应该与测试集中用户的百分比互补，如下所示：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can count how many times each user is repeated in the training set:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算每个用户在训练集中重复的次数：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following image displays the number of repetitions in the training set:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了训练集中的重复次数：
- en: '![Bootstrapping data](img/B03888_04_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![自助数据](img/B03888_04_02.jpg)'
- en: Most of the users have been sampled fewer than four times.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户被采样少于四次。
- en: Using k-fold to validate models
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用k-fold来验证模型
- en: The two previous approaches tested the recommender on part of the users. If,
    instead, we test the recommendation on each user, we could measure the performances
    much more accurately. We can split the data into some chunks, take a chunk out
    as the test set, and evaluate the accuracy. Then, we can do the same with each
    other chunk and compute the average accuracy. This approach is called k-fold and
    it's supported by `recommenderlab`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法在用户的一部分上测试了推荐器。如果我们相反，对每个用户的推荐进行测试，我们可以更准确地衡量性能。我们可以将数据分成一些块，取出一个块作为测试集，并评估准确性。然后，我们可以对其他每个块做同样的事情，并计算平均准确性。这种方法称为k折，并且由`recommenderlab`支持。
- en: 'We can use `evaluationScheme` and the difference is that, instead of specifying
    the percentage of data to put in the training set, we will define how many chunks
    we want. The argument is *k*, like the number of repetitions in the previous examples.
    Clearly, we don''t need to specify `train` anymore:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`evaluationScheme`，与之前的区别在于，我们不是指定放入训练集的数据百分比，而是定义我们想要多少个块。参数是*k*，就像前例中的重复次数一样。显然，我们不再需要指定`train`：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can count how many items we have in each set:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算每个集合中有多少个物品：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As expected, all the sets have the same size.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，所有集合的大小都相同。
- en: This approach is the most accurate one, although it's computationally heavier.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是最准确的，尽管它计算量更大。
- en: In this chapter, we've seen different approaches to prepare the training and
    the test set. In the next chapter, we will start with the evaluation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了不同的方法来准备训练集和测试集。在下一章，我们将从评估开始。
- en: Evaluating recommender techniques
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估推荐技术
- en: This chapter will show you two popular approaches to evaluate recommendations.
    They are both based on the cross-validation framework described in the previous
    section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示两种评估推荐的流行方法。它们都基于上一节中描述的交叉验证框架。
- en: The first approach is to evaluate the ratings estimated by the algorithm. The
    other approach is to evaluate the recommendations directly. There is a subsection
    for each approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是评估算法估计的评分。另一种方法是直接评估推荐。每种方法都有一个子节。
- en: Evaluating the ratings
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估评分
- en: In order to recommend items to new users, collaborative filtering estimates
    the ratings of items that are not yet purchased. Then, it recommends the top-rated
    items. At the moment, let's forget about the last step. We can evaluate the model
    by comparing the estimated ratings with the real ones.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向新用户推荐物品，协同过滤估计尚未购买的物品的评分。然后，它推荐评分最高的物品。目前，让我们忘记最后一步。我们可以通过比较估计评分与实际评分来评估模型。
- en: 'First, let''s prepare the data for validation, as shown in the previous section.
    Since the *k*-fold is the most accurate approach, we will use it here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们准备验证数据，如前节所示。由于k折是最准确的方法，我们将在这里使用它：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to define the model to evaluate. For instance, we can evaluate an item-based
    collaborative filtering recommender. Let''s build it using the Recommender function.
    We need to specify the name of the model and the list of its parameters. If we
    use their defaults, then it''s NULL:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义要评估的模型。例如，我们可以评估一个基于物品的协同过滤推荐器。让我们使用推荐器函数来构建它。我们需要指定模型名称及其参数列表。如果我们使用默认值，那么它就是NULL：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We are now ready to build the model, using the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好构建模型，使用以下代码：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The IBCF can recommend new items and predict their ratings. In order to build
    the model, we need to specify how many items we want to recommend, for example,
    `10`, even if we don''t need to use this parameter in the evaluation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: IBCF可以推荐新物品并预测它们的评分。为了构建模型，我们需要指定我们想要推荐多少个物品，例如`10`，即使我们不需要在评估中使用此参数：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can build the matrix with the predicted ratings using the `predict` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`predict`函数使用预测评分来构建矩阵：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `eval_prediction` object is a rating matrix. Let''s see how many movies
    we are recommending to each user. For this purpose, we can visualize the distribution
    of the number of movies per user:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval_prediction`对象是一个评分矩阵。让我们看看我们为每个用户推荐了多少部电影。为此，我们可以可视化每个用户观看电影数量的分布：'
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following image displays the distribution of movies per user:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像显示了每个用户观看电影的分布：
- en: '![Evaluating the ratings](img/B03888_04_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![评估评分](img/B03888_04_03.jpg)'
- en: The number of movies per user is roughly between 150 and 300.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户观看的电影数量大约在150到300部之间。
- en: 'The function to measure the accuracy is `calcPredictionAccuracy` and it computes
    the following aspects:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 测量准确性的函数是`calcPredictionAccuracy`，它计算以下方面：
- en: '**Root mean square error (RMSE)**: This is the standard deviation of the difference
    between the real and predicted ratings.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均方根误差 (RMSE)**: 这是真实评分与预测评分之间差异的标准差。'
- en: '**Mean squared error (MSE)**: This is the mean of the squared difference between
    the real and predicted ratings. It''s the square of RMSE, so it contains the same
    information.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均平方误差 (MSE)**: 这是真实评分与预测评分之间平方差值的平均值。它是RMSE的平方，因此包含相同的信息。'
- en: '**Mean absolute error (MAE)**: This is the mean of the absolute difference
    between the real and predicted ratings.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均绝对误差 (MAE)**: 这是真实评分与预测评分之间绝对差值的平均值。'
- en: 'We can compute these measures about each user by specifying `byUser = TRUE`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定`byUser = TRUE`来计算每个用户的这些指标：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|   | RMSE | MSE | MAE |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|   | RMSE | MSE | MAE |'
- en: '| --- | --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **1** | `1.217` | `1.481` | `0.8205` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **1** | `1.217` | `1.481` | `0.8205` |'
- en: '| **2** | `0.908` | `0.8244` | `0.727` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **2** | `0.908` | `0.8244` | `0.727` |'
- en: '| **6** | `1.172` | `1.374` | `0.903` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **6** | `1.172` | `1.374` | `0.903` |'
- en: '| **14** | `1.405` | `1.973` | `1.027` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **14** | `1.405` | `1.973` | `1.027` |'
- en: '| **15** | `1.601` | `2.562` | `1.243` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **15** | `1.601` | `2.562` | `1.243` |'
- en: '| **18** | `0.8787` | `0.7721` | `0.633` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **18** | `0.8787` | `0.7721` | `0.633` |'
- en: 'Let''s take a look at the RMSE by a user:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个用户的RMSE：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following image displays the distribution of the RSME by user:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了用户RSME的分布：
- en: '![Evaluating the ratings](img/B03888_04_04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![评估评分](img/B03888_04_04.jpg)'
- en: 'Most of the RMSEs are in the range of 0.8 to 1.4\. We evaluated the model for
    each user. In order to have a performance index of the whole model, we need to
    compute the average indices, specifying `byUser = FALSE`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的RMSE值在0.8到1.4之间。我们对每个用户的模型进行了评估。为了得到整个模型的表现指数，我们需要计算平均指数，指定`byUser = FALSE`：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These measures are useful to compare the performance of different models on
    the same data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标有助于比较不同模型在相同数据上的性能。
- en: Evaluating the recommendations
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估推荐
- en: 'Another way to measure accuracies is by comparing the recommendations with
    the purchases having a positive rating. For this purpose, we can use the prebuilt
    `evaluate` function. Its inputs are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种衡量准确性的方法是，通过比较具有正面评分的推荐与购买来衡量。为此，我们可以使用预构建的`evaluate`函数。其输入如下：
- en: '`x`: This is the object containing the evaluation scheme.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`: 这是一个包含评估方案的对象。'
- en: '`method`: This is the recommendation technique.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`: 这是推荐技术。'
- en: '`n`: This is the number of items to recommend to each user. If we can specify
    a vector of `n`, the function will evaluate the recommender performance depending
    on `n`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`: 这是为每个用户推荐的物品数量。如果我们指定一个`n`的向量，该函数将根据`n`评估推荐器的性能。'
- en: 'We have already defined a threshold, `rating_threshold <- 3`, for positive
    ratings, and this parameter is already stored inside `eval_sets`. The `progress
    = FALSE` argument suppresses a progress report:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个阈值，`rating_threshold <- 3`，用于正面评分，并且这个参数已经存储在`eval_sets`中。`progress
    = FALSE`参数抑制了进度报告：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `results` object is an `evaluationResults` object containing the results
    of the evaluation. Using `getConfusionMatrix`, we can extract a list of confusion
    matrices. Each element of the list corresponds to a different split of the *k*-fold.
    Let''s take a look at the first element:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`results`对象是一个包含评估结果的`evaluationResults`对象。使用`getConfusionMatrix`，我们可以提取一个混淆矩阵的列表。列表中的每个元素对应于*k*-fold的不同分割。让我们看看第一个元素：'
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|   | TP | FP | FN | TN | precision | recall | TPR | FPR |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|   | TP | FP | FN | TN | 精确度 | 召回率 | TPR | FPR |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **10** | `3.443` | `6.557` | `70.61` | `236.4` | `0.3443` | `0.04642` | `0.04642`
    | `0.02625` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **10** | `3.443` | `6.557` | `70.61` | `236.4` | `0.3443` | `0.04642` | `0.04642`
    | `0.02625` |'
- en: '| **20** | `6.686` | `13.31` | `67.36` | `229.6` | `0.3343` | `0.09175` | `0.09175`
    | `0.05363` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **20** | `6.686` | `13.31` | `67.36` | `229.6` | `0.3343` | `0.09175` | `0.09175`
    | `0.05363` |'
- en: '| **30** | `10.02` | `19.98` | `64.03` | `223` | `0.334` | `0.1393` | `0.1393`
    | `0.08075` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **30** | `10.02` | `19.98` | `64.03` | `223` | `0.334` | `0.1393` | `0.1393`
    | `0.08075` |'
- en: '| **40** | `13.29` | `26.71` | `60.76` | `216.2` | `0.3323` | `0.1849` | `0.1849`
    | `0.1081` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **40** | `13.29` | `26.71` | `60.76` | `216.2` | `0.3323` | `0.1849` | `0.1849`
    | `0.1081` |'
- en: '| **50** | `16.43` | `33.57` | `57.62` | `209.4` | `0.3286` | `0.2308` | `0.2308`
    | `0.1362` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **50** | `16.43` | `33.57` | `57.62` | `209.4` | `0.3286` | `0.2308` | `0.2308`
    | `0.1362` |'
- en: '| **60** | `19.61` | `40.39` | `54.44` | `202.6` | `0.3268` | `0.2759` | `0.2759`
    | `0.164` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **60** | `19.61` | `40.39` | `54.44` | `202.6` | `0.3268` | `0.2759` | `0.2759`
    | `0.164` |'
- en: 'The first four columns contain the true-false positives/negatives, and they
    are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前四列包含真-假阳性/阴性，如下所示：
- en: '**True Positives (TP)**: These are recommended items that have been purchased'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真阳性 (TP)**：这些是被推荐并购买的物品'
- en: '**False Positives (FP)**: These are recommended items that haven''t been purchased'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假阳性 (FP)**：这些是被推荐但没有购买的物品'
- en: '**False Negatives(FN)**: These are not recommended items that have been purchased'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假阴性 (FN)**：这些是没有被推荐但已购买的物品'
- en: '**True Negatives (TN)**: These are not recommended items that haven''t been
    purchased'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真阴性 (TN)**：这些是没有被推荐但没有购买的物品'
- en: A perfect (or overfitted) model would have only TP and TN.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美（或过度拟合）的模型将只有TP和TN。
- en: 'If we want to take account of all the splits at the same time, we can just
    sum up the indices:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想同时考虑所有分割，我们只需将指标相加：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|   | TP | FP | FN | TN |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|   | TP | FP | FN | TN |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **10** | `13.05` | `26.95` | `279.3` | `948.7` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **10** | `13.05` | `26.95` | `279.3` | `948.7` |'
- en: '| **20** | `25.4` | `54.6` | `267` | `921` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **20** | `25.4` | `54.6` | `267` | `921` |'
- en: '| **30** | `37.74` | `82.26` | `254.7` | `893.4` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **30** | `37.74` | `82.26` | `254.7` | `893.4` |'
- en: '| **40** | `50.58` | `109.4` | `241.8` | `866.2` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **40** | `50.58` | `109.4` | `241.8` | `866.2` |'
- en: '| **50** | `62.35` | `137.7` | `230` | `838` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **50** | `62.35` | `137.7` | `230` | `838` |'
- en: '| **60** | `74.88` | `165.1` | `217.5` | `810.5` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **60** | `74.88` | `165.1` | `217.5` | `810.5` |'
- en: Note that we could have used `avg(results)` instead.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们本可以使用`avg(results)`。
- en: The other four columns contain performance indices, and it's harder to summarize
    them across all the folds. However, we can visualize them by building some charts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 其他四列包含性能指标，跨所有折叠总结它们比较困难。然而，我们可以通过构建一些图表来可视化它们。
- en: 'First, let''s build the ROC curve. It displays these factors:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建ROC曲线。它显示了以下因素：
- en: '**True Positive Rate (TPR)**: This is the percentage of purchased items that
    have been recommended. It''s the number of TP divided by the number of purchased
    items (TP + FN).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真阳性率 (TPR)**：这是被推荐购买的物品的百分比。它是TP数量除以购买物品的数量（TP + FN）。'
- en: '**False Positive Rate (FPR)**: This is the percentage of not purchased items
    that have been recommended. It''s the number of FP divided by the number of not
    purchased items (FP + TN).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假阳性率 (FPR)**：这是被推荐但没有购买的物品的百分比。它是假阳性 (FP) 数量除以未购买物品的数量（FP + TN）。'
- en: 'The `plot` method will build a chart with the `ROC curve`. In order to visualize
    the labels, we add the `annotate = TRUE` input:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot`方法将构建一个包含`ROC曲线`的图表。为了可视化标签，我们添加了`annotate = TRUE`输入：'
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following image displays the ROC curve:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了ROC曲线：
- en: '![Evaluating the recommendations](img/B03888_04_05.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![评估推荐](img/B03888_04_05.jpg)'
- en: 'Two accuracy metrics are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个准确度指标如下：
- en: '**Precision**: This is the percentage of recommended items that have been purchased.
    It''s the number of FP divided by the total number of positives (TP + FP).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确度**：这是被推荐并购买的物品的百分比。它是FP数量除以总正数（TP + FP）。'
- en: '**Recall**: This is the percentage of purchased items that have been recommended.
    It''s the number of TP divided by the total number of purchases (TP + FN). It''s
    also equal to the True Positive Rate.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**召回率**：这是被推荐购买的物品的百分比。它是TP数量除以总购买数量（TP + FN）。它也等于真阳性率。'
- en: 'If a small percentage of purchased items are recommended, the precision usually
    decreases. On the other hand, a higher percentage of purchased items will be recommended
    so that the recall increases:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果推荐的购买物品比例很小，通常精度会降低。另一方面，如果推荐的购买物品比例更高，召回率会增加：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following image displays the precision-recall:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了精确度-召回率曲线：
- en: '![Evaluating the recommendations](img/B03888_04_06.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![评估推荐](img/B03888_04_06.jpg)'
- en: This chart reflects the tradeoff between precision and recall. Even if the curve
    is not perfectly monotonic, the trends are as expected.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表反映了精确度和召回率之间的权衡。即使曲线不是完美的单调递增，趋势也是预期的。
- en: In this section, we've seen how to evaluate a model. In the next section, we
    will see how to compare two or more models.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何评估一个模型。在下一节中，我们将看到如何比较两个或更多模型。
- en: Identifying the most suitable model
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别最合适的模型
- en: The previous chapter showed you how to evaluate a model. The performance indices
    are useful to compare different models and/or parameters. Applying different techniques
    on the same data, we can compare a performance index to pick the most appropriate
    recommender. Since there are different evaluation metrics, there is no objective
    way to do it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您展示了如何评估一个模型。性能指标对于比较不同的模型和/或参数很有用。在相同的数据上应用不同的技术，我们可以比较性能指标以选择最合适的推荐器。由于有不同的评估指标，没有客观的方法来做这件事。
- en: The starting point is the k-fold evaluation framework that we defined in the
    previous section. It is stored inside `eval_sets`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点是我们在上一节中定义的k折评估框架。它存储在`eval_sets`中。
- en: Comparing models
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较模型
- en: 'In order to compare different models, we first need to define them. Each model
    is stored in a list with its name and parameters. The components of the list are
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较不同的模型，我们首先需要定义它们。每个模型存储在一个列表中，包含其名称和参数。列表的组成部分如下：
- en: '`name`: This is the model name.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是模型名称。'
- en: '`param`: This is a list with its parameters. It can be NULL, if all the parameters
    are left at their defaults.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`param`: 这是一个包含其参数的列表。如果所有参数都保留为默认值，则可以是NULL。'
- en: 'For instance, that''s how we can define an item-based collaborative filtering
    by setting the `k` parameter to `20`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这就是我们如何通过将`k`参数设置为`20`来定义基于物品的协同过滤：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In order to evaluate different models, we can define a list with them. We can
    build the following filtering:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估不同的模型，我们可以定义一个包含它们的列表。我们可以构建以下过滤：
- en: Item-based collaborative filtering, using the Cosine as the distance function
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤，使用余弦作为距离函数
- en: Item-based collaborative filtering, using the Pearson correlation as the distance
    function
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤，使用皮尔逊相关系数作为距离函数
- en: User-based collaborative filtering, using the Cosine as the distance function
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤，使用余弦作为距离函数
- en: User-based collaborative filtering, using the Pearson correlation as the distance
    function
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤，使用皮尔逊相关系数作为距离函数
- en: Random recommendations to have a base line
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机推荐以获得基准
- en: 'The preceding points are defined in the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的点在以下代码中定义：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order to evaluate the models properly, we need to test them, varying the
    number of items. For instance, we might want to recommend up to 100 movies to
    each user. Since 100 is already a big number of recommendations, we don''t need
    to include higher values:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确评估模型，我们需要测试它们，并改变物品的数量。例如，我们可能希望为每个用户推荐多达100部电影。由于100已经是一个很大的推荐数量，我们不需要包括更高的值：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are ready to run and evaluate the models. Like in the previous chapter,
    the function is `evaluate`. The only difference is that now the input method is
    a list of models:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好运行和评估模型。像上一章一样，函数是`evaluate`。唯一的区别是现在输入方法是一个模型列表：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `list_results` object is an `evaluationResultList` object and it can be
    treated as a list. Let''s take a look at its first element:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_results`对象是一个`evaluationResultList`对象，它可以被视为一个列表。让我们看看它的第一个元素：'
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first element of `list_results` is an `evaluationResults` object, and this
    object is the same as the output of evaluate with a single model. We can check
    whether the same is true for all its elements:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_results`的第一个元素是一个`evaluationResults`对象，这个对象与使用单个模型的`evaluate`输出的对象相同。我们可以检查所有元素是否都相同：'
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Each element of `list_results` is an `evaluationResults` object. We can extract
    the related average confusion matrices using `avg`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_results`的每个元素都是一个`evaluationResults`对象。我们可以使用`avg`提取相关的平均混淆矩阵：'
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can use `avg_matrices` to explore the performance evaluation. For instance,
    let''s take a look at the IBCF with Cosine distance:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`avg_matrices`来探索性能评估。例如，让我们看看使用余弦距离的IBCF：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|   | precision | recall | TPR | FPR |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|   | 精确率 | 召回率 | TPR | FPR |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **1** | `0.3589` | `0.004883` | `0.004883` | `0.002546` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **1** | `0.3589` | `0.004883` | `0.004883` | `0.002546` |'
- en: '| **5** | `0.3371` | `0.02211` | `0.02211` | `0.01318` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **5** | `0.3371` | `0.02211` | `0.02211` | `0.01318` |'
- en: '| **10** | `0.3262` | `0.0436` | `0.0436` | `0.02692` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **10** | `0.3262` | `0.0436` | `0.0436` | `0.02692` |'
- en: '| **20** | `0.3175` | `0.08552` | `0.08552` | `0.0548` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **20** | `0.3175` | `0.08552` | `0.08552` | `0.0548` |'
- en: '| **30** | `0.3145` | `0.1296` | `0.1296` | `0.08277` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **30** | `0.3145` | `0.1296` | `0.1296` | `0.08277` |'
- en: '| **40** | `0.3161` | `0.1773` | `0.1773` | `0.1103` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **40** | `0.3161` | `0.1773` | `0.1773` | `0.1103` |'
- en: We have all the metrics of the previous chapter. In the next section, we will
    explore these metrics to identify the best performing model.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了上一章的所有指标。在下一节中，我们将探索这些指标以确定表现最佳的模型。
- en: Identifying the most suitable model
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别最合适的模型
- en: 'We can compare the models by building a chart displaying their ROC curves.
    Like the previous section, we can use `plot`. The annotate argument specifies
    which curves will contain the labels. For instance, the first and second curves
    are labeled by defining `annotate = c(1, 2)`. In our case, we will label only
    the first curve:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构建显示其ROC曲线的图表来比较模型。就像上一节一样，我们可以使用`plot`。`annotate`参数指定了哪些曲线将包含标签。例如，第一和第二曲线通过定义`annotate
    = c(1, 2)`进行标记。在我们的情况下，我们将只标记第一条曲线：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Identifying the most suitable model](img/B03888_04_07.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![识别最合适的模型](img/B03888_04_07.jpg)'
- en: A good performance index is the **area under the curve** (**AUC**), that is,
    the area under the ROC curve. Even without computing it, we can notice that the
    highest is UBCF with cosine distance, so it's the best-performing technique.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的性能指标是曲线下的面积（**AUC**），即ROC曲线下的面积。即使没有计算它，我们也可以注意到最高的AUC是使用余弦距离的UBCF，所以它是表现最好的技术。
- en: 'Like we did in the previous section, we can build the precision-recall chart:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一节所做的那样，我们可以构建精确率-召回率图：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following image shows the precision-recall:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了精确率-召回率：
- en: '![Identifying the most suitable model](img/B03888_04_08.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![识别最合适的模型](img/B03888_04_08.jpg)'
- en: The UBCF with cosine distance is still the top model. Depending on what we want
    to achieve, we can set an appropriate number of items to recommend.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用余弦距离的UBCF仍然是最佳模型。根据我们想要实现的目标，我们可以设置一个合适的推荐项目数量。
- en: Optimizing a numeric parameter
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化数值参数
- en: Recommendation models often contain some numeric parameters. For instance, IBCF
    takes account of the *k*-closest items. How can we optimize *k*?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐模型通常包含一些数值参数。例如，IBCF考虑了*最近的k个*项目。我们如何优化*k*？
- en: In a similar way to categoric parameters, we can test different values of a
    numeric parameter. In this case, we also need to define which values we want to
    test.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与分类参数类似，我们可以测试一个数值参数的不同值。在这种情况下，我们还需要定义我们想要测试的值。
- en: 'So far, we left *k* to its default value: `30`. Now, we can explore more values,
    ranging between `5` and `40`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将*k*保留为其默认值：`30`。现在，我们可以探索更多值，范围在`5`到`40`之间：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using `lapply`, we can define a list of models to evaluate. The distance metric
    is the cosine:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lapply`，我们可以定义一个要评估的模型列表。距离度量是余弦：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Building a chart with the ROC curve, we should be able to identify the best-performing
    *k*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建ROC曲线的图表，我们应该能够识别表现最佳的*k*：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![Optimizing a numeric parameter](img/B03888_04_09.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![优化数值参数](img/B03888_04_09.jpg)'
- en: The *k* having the biggest AUC is 10\. Another good candidate is 5, but it can
    never have a high TPR. This means that, even if we set a very high n value, the
    algorithm won't be able to recommend a big percentage of items that the user liked.
    The IBCF with `k = 5` recommends only a few items similar to the purchases. Therefore,
    it can't be used to recommend many items.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最大AUC的*k*是10。另一个好的候选值是5，但它永远不会有一个高的TPR。这意味着，即使我们设置一个非常高的n值，算法也无法推荐大量用户喜欢的项目。`k
    = 5`的IBCF只推荐少量与购买相似的项目。因此，它不能用来推荐许多项目。
- en: 'Let''s take a look at the precision-recall chart:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看精确率-召回率图：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following image displays the precision-recall:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了精确率-召回率：
- en: '![Optimizing a numeric parameter](img/B03888_04_10.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![优化数值参数](img/B03888_04_10.jpg)'
- en: To achieve the highest recall, we need to set `k = 10`. If we are more interested
    in the precision, we set `k = 5`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现最高的召回率，我们需要将`k`设置为`10`。如果我们更关注精确率，我们将`k`设置为`5`。
- en: This section evaluated four techniques using different methods. Then, it optimized
    a numeric parameter of one of them. Depending on what we want to achieve, the
    choice of parameters might be slightly different.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用不同的方法评估了四种技术。然后，它优化了其中之一的一个数值参数。根据我们想要实现的目标，参数的选择可能会有所不同。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showed you how to evaluate the performance of different models
    in order to choose the most accurate one. There are different ways to evaluate
    performances that might potentially lead to different choices. Depending on the
    business target, the evaluation metric is different. This is an example of how
    business and data should be combined to achieve the final result.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了如何评估不同模型的表现，以便选择最准确的一个。评估性能的方法有很多，可能会导致不同的选择。根据业务目标，评估指标也不同。这是如何将业务和数据结合以实现最终结果的例子。
- en: The next chapter will explain a complete use case in which we will prepare the
    data, build different models, and test them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释一个完整的使用案例，其中我们将准备数据，构建不同的模型，并对它们进行测试。
