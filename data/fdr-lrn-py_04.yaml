- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Federated Learning Server Implementation with Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python实现联邦学习服务器
- en: The server-side implementation of a **federated learning** (**FL**) system is
    critical for realizing authentic FL-enabled applications. We have discussed the
    basic system architecture and flow in the previous chapter. In this chapter, more
    hands-on implementation will be discussed so that you can create a simple server
    and aggregator of the FL system that various **machine learning** (**ML**) applications
    can be connected to and tested on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦学习（**federated learning**，**FL**）系统的服务器端实现对于实现真正的FL启用应用至关重要。我们在前一章中讨论了基本系统架构和流程。在本章中，我们将讨论更多实际实现，以便您可以创建一个简单的FL系统服务器和聚合器，各种**机器学习**（**ML**）应用可以连接并在此测试。
- en: This chapter describes an actual implementation aspect of FL server-side components
    discussed in [*Chapter 3*](B18369_03.xhtml#_idTextAnchor058), *Workings of the
    Federated Learning System*. Based on the understanding of how the entire process
    of the FL system works, you will be able to go one step further to make it happen
    with example code provided here and on GitHub. Once you understand the basic implementation
    principles using the example code, it is a fun aspect to be able enhance the FL
    server functionalities based on your own design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了在[*第3章*](B18369_03.xhtml#_idTextAnchor058)“联邦学习系统的工作原理”中讨论的FL服务器端组件的实际实现方面。基于对FL系统整个工作流程的理解，您将能够进一步使用这里和GitHub上提供的示例代码来实现。一旦您理解了使用示例代码的基本实现原则，根据您自己的设计增强FL服务器功能将是一个有趣的部分。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Main software components of the aggregator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合器的主要软件组件
- en: Implementing FL server-side functionalities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现FL服务器端功能
- en: Maintaining models for aggregation with the state manager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态管理维护聚合模型
- en: Aggregating local models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合本地模型
- en: Running the FL server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行FL服务器
- en: Implementing and running the database server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和运行数据库服务器
- en: Potential enhancements to the FL server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FL服务器的潜在增强
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code files introduced in this chapter can be found on GitHub here:
    [https://github.com/tie-set/simple-fl](https://github.com/tie-set/simple-fl).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的所有代码文件都可以在GitHub上找到：[https://github.com/tie-set/simple-fl](https://github.com/tie-set/simple-fl)。
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can use the code files for personal or educational purposes. However, please
    note that we will not support deployments for commercial use and will not be responsible
    for any errors, issues, or damages caused by using the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用代码文件用于个人或教育目的。然而，请注意，我们不会支持商业部署，并且不会对使用代码造成的任何错误、问题或损害负责。
- en: "Main software components of the aggregator \Land database"
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合器和数据库的主要软件组件
- en: 'The architecture of an aggregator with the FL server was introduced in the
    previous chapter. Here, we will introduce the code that realizes the basic functionalities
    of an FL system. The aggregator and database-side Python-based software components
    are listed in the `aggregator` directory of `fl_main`, as well as `lib/util` and
    `pseudodb` folders, as in *Figure 4.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中介绍了具有FL服务器的聚合器架构。在这里，我们将介绍实现FL系统基本功能的代码。聚合器和数据库端的Python软件组件列在`fl_main`的`aggregator`目录中，以及`lib/util`和`pseudodb`文件夹中，如*图4.1*所示：
- en: '![Figure 4.1 – Python software components for the aggregator as well as internal
    libraries and pseudo database'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – 聚合器的Python软件组件以及内部库和伪数据库]'
- en: '](img/B18369_04_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18369_04_01.jpg)'
- en: Figure 4.1 – Python software components for the aggregator as well as internal
    libraries and pseudo database
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 聚合器的Python软件组件以及内部库和伪数据库
- en: The following is a brief description of the Python code files in the aggregator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对聚合器中Python代码文件的简要描述。
- en: Aggregator-side codes
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合器端代码
- en: In this section, we will touch on the main Python files of the aggregator-side
    related to the FL server thread, FL state manager, and model aggregation itself.
    These aggregator-side code files are found in the `aggregator` folder. The code
    in the repo only captures the model aggregation perspective, not the entire engineering
    aspects of creating a thorough FL platform.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涉及与FL服务器线程、FL状态管理以及模型聚合本身相关的聚合器端的主要Python文件。这些聚合器端的代码文件位于`aggregator`文件夹中。仓库中的代码仅捕获模型聚合的视角，而不是创建全面FL平台的整个工程方面。
- en: FL server code (server_th.py)
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FL服务器代码（server_th.py）
- en: This is the main code that realizes the whole basic flow of the FL process from
    the communication processes between an aggregator itself, agents, and a database
    to coordinating agent participation and the aggregation of the ML models. It also
    initializes the global cluster model sent from the first connected agent. It manages
    receiving local models and the cluster model synthesis routine in which the cluster
    global model is formed after collecting enough local models.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现联邦学习过程整个基本流程的主要代码，包括聚合器本身、代理和数据库之间的通信过程，以及协调代理参与和ML模型的聚合。它还初始化从第一个连接的代理发送的全球集群模型。它管理接收本地模型和集群模型合成例程，在收集足够的本地模型后形成集群全局模型。
- en: FL state manager (state_manager.py)
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联邦学习状态管理器（state_manager.py）
- en: The state manager buffers the local model and cluster model data that is needed
    for aggregation processes. The buffers will be filled out when the aggregator
    receives local models from the agents and cleared when proceeding to the next
    round of the FL process. The checking function of the aggregation criteria is
    also defined in this file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理器缓冲本地模型和集群模型数据，这些数据对于聚合过程是必需的。当聚合器从代理接收本地模型时，缓冲区将被填充，在进入联邦学习过程的下一轮时将被清除。聚合标准检查函数也定义在此文件中。
- en: Aggregation code (aggregation.py)
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合代码（aggregation.py）
- en: The aggregation Python code will list the basic algorithms for aggregating the
    model. In the code example used here in this chapter, we will only introduce the
    averaging method called **federated averaging** (**FedAvg**), which averages the
    weights of the collected local models considering local dataset sizes to generate
    a cluster global model.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合Python代码将列出聚合模型的基本算法。在本章中使用的代码示例中，我们只介绍称为**联邦平均**（**FedAvg**）的平均方法，它考虑了本地数据集的大小来平均收集的本地模型的权重，从而生成集群全局模型。
- en: lib/util codes
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lib/util代码
- en: The Python files for the internal libraries (`communication_handler.py`, `data_struc.py`,
    `helpers.py`, `messengers.py`, and `states.py`) will be explained in the *Appendix*,
    *Exploring Internal Libraries*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 内部库的Python文件（`communication_handler.py`、`data_struc.py`、`helpers.py`、`messengers.py`和`states.py`）将在*附录*、*探索内部库*中进行解释。
- en: Database-side code
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库端代码
- en: Database-side code consists of the pseudo database and the SQLite database Python
    code files that can be found in the `pseudodb` folder. The pseudo database code
    is hosting a server to receive messages from the aggregator and purse them to
    process as the ML model data that can be utilized for the FL process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库端代码包括伪数据库和位于`pseudodb`文件夹中的SQLite数据库Python代码文件。伪数据库代码运行一个服务器以接收来自聚合器的消息，并将它们处理为可用于联邦学习过程的ML模型数据。
- en: Pseudo database code (pseudo_db.py)
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪数据库代码（pseudo_db.py）
- en: The function of pseudo database Python code is to accept the messages related
    to the local and global cluster models from the aggregator and push the information
    to the database. It also saves the ML model binary files in the local file system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 伪数据库Python代码的功能是接受来自聚合器与本地和全球集群模型相关的消息，并将信息推送到数据库。它还将在本地文件系统中保存ML模型二进制文件。
- en: SQLite database code (sqlite_db.py)
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite数据库代码（sqlite_db.py）
- en: The SQLite database Python code creates an actual SQLite database at the specified
    path. It also has the function to insert data entries related to the local and
    global cluster models into the database.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库Python代码在指定的路径创建实际的SQLite数据库。它还具有将有关本地和全球集群模型的数据条目插入数据库的功能。
- en: Now that the aggregator and database-side software components are defined, let's
    move on to the configuration of the aggregator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在聚合器和数据库端软件组件已经定义好了，让我们继续进行聚合器的配置。
- en: Toward the configuration of the aggregator
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向聚合器的配置
- en: 'The following code is an example of the aggregator-side configuration parameters
    defined in the `config_aggregator.json` file, which can be found in the `setups`
    folder:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是聚合器端配置参数的示例，这些参数定义在`config_aggregator.json`文件中，该文件位于`setups`文件夹中：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The parameters include the aggregator’s IP (the FL server’s IP), the database
    server’s IP, and the various port numbers of the database and agents. The round
    interval is the time of the interval at which the criteria of aggregation are
    checked and the aggregation threshold defines the percentage of collected local
    ML models needed to start the aggregation process. The polling flag is related
    to whether to utilize the `polling` method for communications between the aggregator
    and agents or not.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包括聚合器的IP（FL服务器的IP）、数据库服务器的IP以及数据库和代理的各种端口号。轮询间隔是检查聚合标准的时间间隔，聚合阈值定义了开始聚合过程所需的收集的本地ML模型的百分比。轮询标志与是否利用`polling`方法进行聚合器和代理之间的通信有关。
- en: Now that we have covered the concept of the configuration file for the aggregator
    side, let’s move on to how the code is designed and implemented.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了聚合器侧的配置文件的概念，让我们继续了解代码的设计和实现。
- en: Implementing FL server-side functionalities
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现FL服务器端功能
- en: In this section, we will explain how you can implement the very first version
    of an aggregator with an FL server system using the actual code examples, which
    are in `server_th.py` in the `aggregator` directory. In this way, you will understand
    the core functionalities of the FL server system and how they are implemented
    so that you can further enhance a lot more functionalities on your own. Therefore,
    we will only cover the important and core functionalities that are critical to
    conducting a simple FL process. The potential enhancements will be listed in the
    later section of this chapter, *Potential enhancements to the FL server*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过实际的代码示例来解释如何使用FL服务器系统实现聚合器的第一个版本，这些示例代码位于`aggregator`目录下的`server_th.py`文件中。通过这种方式，您将了解FL服务器系统的核心功能以及它们的实现方式，以便您能够进一步扩展更多功能。因此，我们只涵盖进行简单FL过程所必需的重要和核心功能。潜在的提升将在本章后面的部分列出，即*FL服务器的潜在提升*。
- en: '`server_th.py` handles all the aspects of basic functionalities related to
    the FL server side, so let’s look into that in the following section.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`server_th.py`处理与FL服务器端相关的所有基本功能方面，所以让我们在下一节中看看。'
- en: Importing libraries for the FL server
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入FL服务器的库
- en: The FL server-side code starts with importing the necessary libraries. In particular,
    `lib.util` handles the basic supporting functionalities to make the implementation
    of FL easy. The details of the code can be found in the GitHub repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: FL服务器端的代码从导入必要的库开始。特别是，`lib.util`处理使FL实现变得容易的基本支持功能。代码的详细信息可以在GitHub仓库中找到。
- en: The server code imports `StateManager` and `Aggregator` for the FL processes.
    The code about the state manager and aggregation will be discussed in later sections
    in this chapter about *Maintaining models for aggregation with the state manager*
    and *Aggregating local models.*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器代码导入`StateManager`和`Aggregator`用于FL过程。关于状态管理器和聚合的代码将在本章后面的部分讨论，即*使用状态管理器维护聚合模型*和*聚合本地模型*。
- en: 'Here is the code for importing the necessary libraries:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是导入必要库的代码：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After we import the necessary libraries, let us move on to designing an FL `Server`
    class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们导入必要的库之后，让我们继续设计一个FL `Server`类。
- en: Defining the FL Server class
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义FL服务器类
- en: 'In practice, it is wise to define the `Server` class, using which you can create
    an instance of the FL server that has the functionalities discussed in [*Chapter
    3*](B18369_03.xhtml#_idTextAnchor058), *Workings of the Federated Learning System*,
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，定义`Server`类是明智的，使用它可以创建一个具有在[*第3章*](B18369_03.xhtml#_idTextAnchor058)，*联邦学习系统的工作原理*中讨论的功能的FL服务器实例，如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, the `server` class primarily provides the functionalities of agent registration
    and global model synthesis and handles the mechanisms of uploaded local models
    and polling messages sent from agents. It also serves as the interface between
    the aggregator and database and between the aggregator and agents.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`server`类主要提供代理注册和全局模型合成的功能，并处理上传的本地模型和来自代理的轮询消息的机制。它还充当聚合器和数据库以及聚合器和代理之间的接口。
- en: The FL server class functionality is now clear – next is initializing and configuring
    the server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: FL服务器类的功能现在很清晰——接下来是初始化和配置服务器。
- en: Initializing the FL server
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化FL服务器
- en: 'The following code inside the `__init__` constructor is an example of the initialization
    process of the `Server` instance:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__init__` 构造函数内部的以下代码是 `Server` 实例初始化过程的示例。
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then, `self.config` stores the information from the `config_aggregator.json`
    file discussed in the preceding code block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`self.config` 存储了前面代码块中讨论的 `config_aggregator.json` 文件中的信息。
- en: '`self.sm` and `self.agg` have instances of the state manager class and aggregator
    class discussed as follows, respectively.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.sm` 和 `self.agg` 分别是下面讨论的状态管理类和聚合类实例。'
- en: '`self.aggr_ip` reads an IP address from the aggregator’s configuration file.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.aggr_ip` 从聚合器的配置文件中读取一个 IP 地址。'
- en: Then, `reg_socket` and `recv_socket` will be set up, where `reg_socket` is used
    for agents to register themselves together with an aggregator IP address stored
    as `self.aggr_ip`, and `recv_socket` is used for receiving local models from agents,
    together with an aggregator IP address stored as `self.aggr_ip`. Both `reg_socket`
    and `recv_socket` in this example code can be read from the aggregator’s configuration
    file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将设置 `reg_socket` 和 `recv_socket`，其中 `reg_socket` 用于代理注册自身以及存储为 `self.aggr_ip`
    的聚合器 IP 地址，而 `recv_socket` 用于从代理接收本地模型，以及存储为 `self.aggr_ip` 的聚合器 IP 地址。在这个示例代码中，`reg_socket`
    和 `recv_socket` 都可以读取自聚合器的配置文件。
- en: The `exch_socket` is the port number used to send the global model back to the
    agent together with the agent IP address, which is initialized with the configuration
    parameter in the initialization process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`exch_socket` 是用于将全局模型连同代理的 IP 地址一起发送回代理的端口号，该端口号在初始化过程中通过配置参数进行初始化。'
- en: The information to get connected to the database server will then be configured,
    where `dp_ip` and `db_socket` will be the IP address and the port number of the
    database server, respectively, all read from the `config_aggregator.json` file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，将配置连接到数据库服务器的信息，其中 `dp_ip` 和 `db_socket` 分别是数据库服务器的 IP 地址和端口号，所有这些信息都是从 `config_aggregator.json`
    文件中读取的。
- en: '`round_interval` is an interval time to check whether the aggregation criteria
    for starting the model aggregation process are met or not.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`round_interval` 是一个检查是否满足启动模型聚合过程聚合标准的时间间隔。'
- en: The `is_polling` flag is related to whether to use the `polling` method from
    the agents or not. The polling flag must be the same as the one used in the agent-side
    configuration file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_polling` 标志与是否使用代理端的 `polling` 方法有关。轮询标志必须与代理端配置文件中使用的标志相同。'
- en: '`agg_threshold` is also the percentage over the number of collected local models
    that is used in the `ready_for_local_aggregation` function where if the percentage
    of the collected models is equal to or more than `agg_threshold`, the FL server
    starts the aggregation process of the local models.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`agg_threshold` 也是在 `ready_for_local_aggregation` 函数中使用的超过收集到的本地模型数量的百分比，如果收集到的模型百分比等于或超过
    `agg_threshold`，则 FL 服务器开始本地模型的聚合过程。'
- en: Both `self.round_interval` and `self.agg_threshold` are read from the configuration
    file in this example code too.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码中，`self.round_interval` 和 `self.agg_threshold` 都是从配置文件中读取的。
- en: Now that the configuration has been set up, we will talk about how to register
    agents that are trying to participate in the FL process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置已经设置好了，我们将讨论如何注册尝试参与联邦学习（FL）过程的代理。
- en: Registration function of agents
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理注册函数
- en: In this section, the simplified and asynchronous `register` function is described
    to receive the participation message specifying the model structures and return
    socket information for future model exchanges. It also sends the welcome message
    back to the agent as a response.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，描述了简化和异步的 `register` 函数，用于接收指定模型结构的参与消息，并返回用于未来模型交换的套接字信息。它还向代理发送欢迎消息作为响应。
- en: 'The registration process of agents is described in the following example code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的注册过程在下面的示例代码中进行了描述：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example code, the received message from an agent, defined here as `msg`,
    is decoded by the `receive` function imported from the `communication_handler`
    code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码中，从代理接收到的消息，在此定义为 `msg`，是通过从 `communication_handler` 代码导入的 `receive`
    函数进行解码的。
- en: In particular, the `self.sm.add_agent(agent_name, agent_id, addr, es)` function
    takes the agent name, agent ID, agent IP address, and the `exch_socket` number
    included in the `msg` message in order to accept the messages from this agent,
    even if the agent is temporarily disconnected and then connected again.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`self.sm.add_agent(agent_name, agent_id, addr, es)` 函数接收代理名称、代理 ID、代理 IP
    地址以及包含在 `msg` 消息中的 `exch_socket` 号码，以便接受来自该代理的消息，即使代理暂时断开连接然后再次连接。
- en: After that, the registration function checks whether it should move on to the
    process of initial models or not, depending on the FL round that is tracked with
    `self.sm.round`. If the FL process is not happening yet, that is, if `self.sm.round`
    is `0`, it calls the `_initialize_fl(msg)` function in order to initialize the
    FL process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，注册函数检查是否应该根据 `self.sm.round` 追踪的 FL 轮次继续到初始化模型的过程。如果 FL 进程尚未开始，即 `self.sm.round`
    为 `0`，它将调用 `_initialize_fl(msg)` 函数以初始化 FL 进程。
- en: Then, the FL server sends the updated global model back to the agent by calling
    the `_send_updated_global_model(websocket, id, es)` function. The function takes
    the WebSocket, agent ID, and `exch_socket` as parameters and creates a reply message
    to the agent to notify it whether the participation message has been accepted
    or not.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，FL 服务器通过调用 `_send_updated_global_model(websocket, id, es)` 函数将更新的全局模型发送回代理。该函数接受
    WebSocket、代理 ID 和 `exch_socket` 作为参数，并向代理创建一个回复消息以通知其参与消息是否已被接受。
- en: The registration process of agents with the FL server is simplified in this
    example code here. In a production environment, all the system information from
    the agent will be pushed to the database so that an agent that loses the connection
    to the FL server can be recovered anytime by reconnecting to the FL server.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例代码中，简化了代理与 FL 服务器的注册过程。在生产环境中，所有来自代理的系统信息都将推送到数据库，以便任何失去与 FL 服务器连接的代理都可以通过重新连接到
    FL 服务器来随时恢复。
- en: Usually, if the FL server is installed in the cloud and agents are connected
    to the FL server from their local environment, this push-back mechanism from the
    aggregator to agents will not work because of security settings such as firewalls.
    We do not discuss the topic of security issues in this book in detail, so you
    are encouraged to use the `polling` method implemented in the `simple-fl` code
    to communicate between the cloud-based aggregator and local agents.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果 FL 服务器安装在云端，并且代理从其本地环境连接到 FL 服务器，由于安全设置（如防火墙）等原因，聚合器到代理的这种回推机制将不会工作。本书中我们不详细讨论安全问题，因此鼓励您使用
    `simple-fl` 代码中实现的 `polling` 方法在基于云的聚合器和本地代理之间进行通信。
- en: Getting socket information to push the global model back to agents
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取套接字信息以将全局模型推回代理
- en: 'The following function called `_get_exch_socket` takes a participation message
    from the agent and decides which port to use to reach out to the agent depending
    on the simulation flag in the message:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `_get_exch_socket` 函数从代理接收参与消息，并根据消息中的模拟标志决定使用哪个端口来联系代理：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We support a simulation run in this implementation exercise by which you can
    run all the FL system components of a database, aggregator, and multiple agents
    in one machine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现练习中，我们支持进行模拟运行，通过这种方式，你可以在一台机器上运行数据库、聚合器和多个代理的所有 FL 系统组件。
- en: Initializing the FL process if necessary
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如有必要，初始化 FL 进程
- en: 'The asynchronous `_initialize_fl` function is for initializing an FL process
    that is only called when the round of FL is `0`. The following is the code to
    do so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 异步的 `_initialize_fl` 函数用于初始化一个 FL 进程，该进程仅在 FL 轮次为 `0` 时被调用。以下是其代码实现：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After extracting the agent ID (`agent_id`), the model ID (`model_id`), local
    models from an agent (`lmodels`), the generated time of the model (`gene_time`),
    the performance data (`perf_val`), and the value of `init_flag` from the received
    message, the `initialize_model_info` function of the state manager code is called,
    which is explained in a later section of this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从接收到的消息中提取代理 ID (`agent_id`)、模型 ID (`model_id`)、来自代理的本地模型 (`lmodels`)、模型的生成时间
    (`gene_time`)、性能数据 (`perf_val`) 和 `init_flag` 的值后，调用状态管理器代码中的 `initialize_model_info`
    函数，该函数将在本章后面的部分进行解释。
- en: This function then pushes the local model to the database by calling the `_push_local_models`
    function, which is also described in this section. You can refer to the *Functions
    to push the local and global models to the database* section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数随后通过调用本节中描述的`_push_local_models`函数将本地模型推送到数据库。您可以参考*将本地和全局模型推送到数据库的函数*部分。
- en: After that, the round is incremented to proceed to the first round in FL.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，轮次增加以进入FL的第一轮。
- en: Confirming agent participation with an updated global model
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用更新的全局模型确认代理参与
- en: 'After initializing the (cluster) global model, the global models need to be
    sent to the agent connected to the aggregator through this registration process.
    The asynchronous `_send_updated_global_model` function as follows handles the
    process of sending the global models to the agent by taking the WebSocket information,
    agent ID, and the port to use to reach out to the agent as parameters. The following
    code block describes the procedure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化（集群）全局模型后，需要通过此注册过程将全局模型发送到连接到聚合器的代理。以下异步的`_send_updated_global_model`函数处理将全局模型发送到代理的过程，它以WebSocket信息、代理ID和用于联系代理的端口号作为参数。以下代码块描述了该过程：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the FL process has already started, that is, the `self.sm.round` is more
    than 0 already, we get the cluster models from their buffer and convert them into
    a dictionary format with the `convert_LDict_to_Dict` library function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果FL过程已经启动，即`self.sm.round`已经大于0，我们将从它们的缓冲区获取集群模型，并使用`convert_LDict_to_Dict`库函数将它们转换为字典格式。
- en: Then, the reply message is packaged using the `generate_` `agent_participation_confirm_message`
    function and sent to the agent that just connected or reconnected to the aggregator
    by calling the `send_websocket(reply, websocket)` function. Please also refer
    to the *Functions to send the global models to the agents* section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`generate_` `agent_participation_confirm_message`函数包装回复消息，并通过调用`send_websocket(reply,
    websocket)`函数将其发送给刚刚连接或重新连接到聚合器的代理。请参阅*将全局模型发送到代理的函数*部分。
- en: Now that we understand the agents’ registration process, let’s move on to the
    implementation of handling the local ML models and polling messages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了代理的注册过程，让我们继续到处理本地机器学习模型和轮询消息的实现。
- en: The server for handling messages from local agents
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理来自本地代理的消息的服务器
- en: 'The asynchronous `receive_msg_from_agent` process at the FL server is constantly
    running to receive local model updates and to push them to the database and the
    memory buffer temporally saving local models. It also responds to the polling
    messages from the local agents. The following code explains this functionality:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: FL服务器上的异步`receive_msg_from_agent`过程持续运行，以接收本地模型更新并将它们推送到数据库和内存缓冲区，临时保存本地模型。它还响应来自本地代理的轮询消息。以下代码解释了这一功能：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will then look into the two functions called by the `receive_msg_from_agent`
    function as shown in the preceding code blocks, which are the `_process_lmodel_upload`
    and `_process_polling` functions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看由`receive_msg_from_agent`函数调用的两个函数，如前述代码块所示，它们是`_process_lmodel_upload`和`_process_polling`函数。
- en: Processing a model upload by local agents
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理本地代理的模型上传
- en: 'The asynchronous `_process_lmodel_upload` function deals with the `AgentMsgType.update`
    message. The following code block is about the function related to receiving the
    local ML models and putting them into the buffer in the state manager:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 异步的`_process_lmodel_upload`函数处理`AgentMsgType.update`消息。以下代码块是关于接收本地机器学习模型并将它们放入状态管理器缓冲区的函数：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, it extracts the agent ID (`agent_id`), the model ID (`model_id`), local
    models from an agent (`lmodels`), the generated time of the model (`gene_time`),
    and the performance data (`perf_val`) from the received message, and then calls
    the `_push_local_models` function to push the local models to the database.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它从接收到的消息中提取代理ID（`agent_id`）、模型ID（`model_id`）、来自代理的本地模型（`lmodels`）、模型的生成时间（`gene_time`）和性能数据（`perf_val`），然后调用`_push_local_models`函数将本地模型推送到数据库。
- en: The `buffer_local_models` function is then called to save the local models (`lmodels`)
    in the memory buffer. The `buffer_local_models` function is described in the *Maintaining
    models for aggregation with the state manager* section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`buffer_local_models`函数以将本地模型（`lmodels`）保存在内存缓冲区中。`buffer_local_models`函数在*使用状态管理器维护聚合模型*部分中描述。
- en: Processing polling by agents
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理代理的轮询
- en: 'The following asynchronous `_process_polling` function deals with the `AgentMsgType.polling`
    message:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下异步的`_process_polling`函数处理`AgentMsgType.polling`消息：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the FL round (`self.sm.round`) is greater than the local FL round included
    in the received message that is maintained by the local agent itself, it means
    that the model aggregation is done during the period between the time when the
    agent polled to the aggregator last time and now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果FL轮次（`self.sm.round`）大于本地FL轮次，该轮次包含在本地代理自身维护的接收消息中，这意味着模型聚合是在代理上次向聚合器轮询的时间和现在之间的期间完成的。
- en: In this case, `cluster_models` that are converted into a dictionary format are
    packaged into a response message by `generate_cluster_model_dist_message` and
    sent back to the agent via the `send_websocket` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，通过`generate_cluster_model_dist_message`函数将`cluster_models`转换为字典格式后，通过`send_websocket`函数打包成响应消息并回传给代理。
- en: Otherwise, the aggregator just returns the *ACK* message to the agent, generated
    by the `generate_ack_message` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，聚合器将仅通过`generate_ack_message`函数生成的*ACK*消息返回给代理。
- en: Now we are ready to aggregate the local models received from the agents, so
    let us look into the model aggregation routine.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好聚合从代理接收到的本地模型，让我们来看看模型聚合例程。
- en: The global model synthesis routine
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局模型合成例程
- en: The global model synthesis routine process designed in `async def model_synthesis_routine(self)`
    in the FL server periodically checks the number of stored models and executes
    global model synthesis if there are enough local models collected to meet the
    aggregation threshold.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在FL服务器中设计的`async def model_synthesis_routine(self)`过程通过定期检查存储的模型数量，并在收集到足够多的本地模型以满足聚合阈值时执行全局模型合成。
- en: 'The following code describes the model synthesis routine process that periodically
    checks the aggregation criteria and executes model synthesis:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了模型合成例程过程，该过程定期检查聚合标准并执行模型合成：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This process is asynchronous, running with a `while` loop.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程是异步的，使用`while`循环运行。
- en: In particular, once the criteria set by `ready_for_local_aggregation` (explained
    in the *Maintaining models for aggregation with the state manager* section) are
    met, the `aggregate_local_models` function imported from the `aggregator.py` file
    is called, where this function averages the weights of the collected local models
    based on `FedAvg`. Further explanation of the `aggregate_local_models` function
    can be found in the *Aggregating local models* section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，一旦满足`ready_for_local_aggregation`（在*使用状态管理器维护聚合模型*部分中解释）设定的条件，就会调用从`aggregator.py`文件导入的`aggregate_local_models`函数，该函数基于`FedAvg`对收集到的本地模型权重进行平均。关于`aggregate_local_models`函数的进一步解释可以在*聚合本地模型*部分找到。
- en: Then, `await self._push_cluster_models()` is called to push the aggregated cluster
    global model to the database.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用`await self._push_cluster_models()`以将聚合的集群全局模型推送到数据库。
- en: '`await self._send_cluster_models_to_all()` is for sending the updated global
    model to all the agents connected to the aggregator if the `polling` method is
    not used.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`await self._send_cluster_models_to_all()`用于在未使用`polling`方法的情况下，将更新的全局模型发送给连接到聚合器的所有代理。'
- en: Last but not least, the FL round is incremented by `self.sm.increment_round()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，FL轮次通过`self.sm.increment_round()`递增。
- en: Once the cluster global model is generated, the models need to be sent to the
    connected agents with the functions described in the following section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成集群全局模型，就需要使用以下章节中描述的函数将模型发送到连接的代理。
- en: Functions to send the global models to the agents
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于将全局模型发送到代理的函数
- en: 'The functionality of sending global models to the connected agents is dealt
    with by the `_send_cluster_models_to_all` function. This is an asynchronous function
    to send out cluster global models to all agents under this aggregator as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将全局模型发送到连接的代理的功能由`_send_cluster_models_to_all`函数处理。这是一个异步函数，用于将集群全局模型发送到本聚合器下的所有代理，如下所示：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After getting the cluster models’ information, it creates the message including
    the cluster models, round, model ID, and aggregator ID information using the `generate_cluster_model_dist_message`
    function and calls the `send` function from the `communication_handler` libraries
    to send the global models to all the agents in the `agent_set` registered through
    the agent participation process.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取集群模型信息后，它使用`generate_cluster_model_dist_message`函数创建包含集群模型、轮次、模型ID和聚合器ID信息的消息，并调用`communication_handler`库中的`send`函数，将全局模型发送到通过代理参与过程注册的`agent_set`中的所有代理。
- en: Sending the cluster global models to the connected agents has now been explained.
    Next, we explain how to push the local and cluster models to the database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 已经解释了将集群全局模型发送到连接的代理。接下来，我们将解释如何将本地和集群模型推送到数据库。
- en: Functions to push the local and global models to the database
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将本地和全局模型推送到数据库的函数
- en: The `_push_local_models` and `_push_cluster_models` functions are both called
    internally to push and send the local models and cluster global models to the
    database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`_push_local_models`和`_push_cluster_models`函数都内部调用以将本地模型和集群全局模型推送到数据库。'
- en: Pushing local models to the database
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将本地模型推送到数据库
- en: 'Here is the `_push_local_models` function for pushing a given set of local
    models to the database:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将一组本地模型推送到数据库的`_push_local_models`函数：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `_push_local_models` function takes parameters such as the agent ID, local
    models, the model ID, the generated time of the model, and the performance data,
    and returns a response message if there is one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`_push_local_models`函数接受诸如代理ID、本地模型、模型ID、模型的生成时间以及性能数据等参数，如果有响应消息则返回。'
- en: Pushing cluster models to the database
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将集群模型推送到数据库
- en: 'The following `_push_cluster_models` function is for pushing the cluster global
    models to the database:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将集群全局模型推送到数据库的`_push_cluster_models`函数：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`_push_cluster_models` in this code does not take any parameters, as those
    parameters can be obtained from the instance information and buffered memory data
    of the state manager. For example, `self.sm.cluster_model_ids[-1]` obtains the
    ID of the latest cluster model, and `self.sm.cluster_models` stores the latest
    cluster model itself, which is converted into `models` with a dictionary format
    to be sent to the database. It also creates `mata_dict` to store the number of
    samples.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`_push_cluster_models`函数不接收任何参数，因为这些参数可以从状态管理器的实例信息和缓冲内存数据中获取。例如，`self.sm.cluster_model_ids[-1]`获取最新集群模型的ID，而`self.sm.cluster_models`存储最新的集群模型本身，并将其转换为字典格式的`models`以发送到数据库。它还创建`mata_dict`来存储样本数量。
- en: Pushing ML models to the database
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将机器学习模型推送到数据库
- en: 'Both the preceding functions call the `_push_models` function as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个函数都按照如下方式调用`_push_models`函数：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code example, the `_push_models` function takes parameters such as `component_id`
    (the ID of the aggregator or agent), `model_type`, such as local or cluster model,
    `models` themselves, `model_id`, `gene_time` (the time the model is created),
    and `performance_dict` as the performance metrics of the models. Then, the message
    to be sent to the database (using the `send` function) is created by the `generate_db_push_message`
    function, taking these parameters together with the FL round information. It returns
    a response message from the database.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，`_push_models`函数接受诸如`component_id`（聚合器或代理的ID）、`model_type`（如本地或集群模型）、`models`本身、`model_id`、`gene_time`（模型创建的时间）以及`performance_dict`（作为模型的性能指标）等参数。然后，通过`generate_db_push_message`函数创建要发送到数据库的消息（使用`send`函数），这些参数包括FL轮次信息。它从数据库返回响应消息。
- en: Now that we have explained all the core functionalities related to the FL server,
    let us look into the role of the state manager, which maintains all the models
    needed for the aggregation process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了与FL服务器相关的所有核心功能，让我们来看看状态管理器的角色，它维护聚合过程所需的全部模型。
- en: "Maintaining models for aggregation with the \Lstate manager"
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态管理器维护聚合所需的模型
- en: In this section, we will explain `state_manager.py,` which handles maintaining
    the models and necessary volatile information related to the aggregation of local
    models.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释`state_manager.py`，该文件处理维护模型以及与本地模型聚合相关的必要易失性信息。
- en: Importing the libraries of the state manager
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入状态管理器的库
- en: 'This code imports the following. The internal libraries for `data_struc`, `helpers`,
    and `states` are introduced in the *Appendix*, *Exploring Internal Libraries*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码导入了以下内容。`data_struc`、`helpers` 和 `states` 的内部库在 *附录*、*探索内部库* 中介绍：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After importing the necessary libraries, let’s define the state manager class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入必要的库之后，让我们定义状态管理器类。
- en: Defining the state manager class
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义状态管理器类
- en: 'The state manager class (`Class StateManager`), as seen in `state_manager.py`,
    is defined in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理器类（`Class StateManager`），如 `state_manager.py` 中所见，在以下代码中定义：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This keeps track of the state information of an aggregator. The volatile state
    of an aggregator and agents should also be stored, such as local models, agents’
    info connected to the aggregator, cluster models generated by the aggregation
    process, and the current round number.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这跟踪聚合器的状态信息。聚合器和代理的易变状态也应存储，例如本地模型、连接到聚合器的代理信息、聚合过程生成的聚类模型以及当前轮次编号。
- en: After defining the state manager, let us move on to initializing the state manager.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了状态管理器之后，让我们继续初始化状态管理器。
- en: Initializing the state manager
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化状态管理器
- en: 'In the `__init__` constructor, the information related to the FL process is
    configured. The following code is an example of how to construct the state manager:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__init__` 构造函数中，配置了与联邦学习过程相关的信息。以下代码是构建状态管理器的一个示例：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The ID of the `self.id` aggregator can be generated randomly using the `generate_id()`
    function from the `util.helpers` library.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.id` 聚合器的ID可以使用来自 `util.helpers` 库的 `generate_id()` 函数随机生成。'
- en: '`self.agent_set` is a set of agents connected to the aggregator where the format
    of the set is a collection of dictionary information, related to agents in this
    case.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.agent_set` 是连接到聚合器的代理集合，其中集合的格式是字典信息的集合，在这种情况下与代理相关。'
- en: '`self.mnames` stores the names of each layer of the ML models to be aggregated
    in a list format.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.mnames` 以列表格式存储要聚合的ML模型中每一层的名称。'
- en: '`self.round` is initialized to be `0` so that the round of FL is initialized.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.round` 被初始化为 `0` 以初始化联邦学习的轮次。'
- en: '`local_model_buffers` is a list of local models collected by agents stored
    in the memory space. `local_model_buffers` accepts the local models sent from
    the agents for each FL round, and once the round is completed by the aggregation
    process, this buffer is cleared and starts accepting the next round’s local models.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_model_buffers` 是由代理收集并存储在内存空间中的本地模型列表。`local_model_buffers` 接受来自代理的每个联邦学习轮次的本地模型，一旦聚合过程完成该轮次，此缓冲区将被清除并开始接受下一轮的本地模型。'
- en: '`self.local_model_num_samples` is a list that stores the number of data samples
    for the models that are collected in the buffer.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.local_model_num_samples` 是一个列表，用于存储收集在缓冲区中的模型的样本数量。'
- en: '`self.cluster_models` is a collection of global cluster models in the `LimitedDict`
    format, and `self.cluster_model_ids` is a list of IDs of cluster models.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.cluster_models` 是以 `LimitedDict` 格式存储的全局聚类模型集合，而 `self.cluster_model_ids`
    是聚类模型ID的列表。'
- en: '`self.initialized` becomes `True` once the initial global model is set and
    is `False` otherwise.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了初始全局模型，`self.initialized` 变为 `True`，否则为 `False`。
- en: '`self.agg_threshold` is initialized to be `1.0`, which is overwritten by the
    value specified in the `config_aggregator.json` file.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.agg_threshold` 被初始化为 `1.0`，该值会被 `config_aggregator.json` 文件中指定的值覆盖。'
- en: After initializing the state manager, let us investigate initializing a global
    model next.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化状态管理器之后，让我们接下来调查初始化全局模型。
- en: Initializing a global model
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化全局模型
- en: 'The following `initialize_model_info` function sets up the initial global model
    to be used by the other agents:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `initialize_model_info` 函数设置了其他代理将使用的初始全局模型：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It fills up the model names (`self.mnames`) extracted from the local models
    (`lmodels`) sent from an initial agent. Together with the model names, `local_model_buffers`
    and `cluster_models` are re-initialized too. After clearing the local model buffers,
    it calls the `initialize_models` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它填充了从初始代理发送的本地模型（`lmodels`）中提取的模型名称（`self.mnames`）。与模型名称一起，`local_model_buffers`
    和 `cluster_models` 也被重新初始化。在清除本地模型缓冲区后，它调用 `initialize_models` 函数。
- en: 'The following `initialize_models` function initializes the structure of neural
    networks (`numpy.array`) based on the initial base models received as parameters
    of models with a dictionary format (`str` or `np.array`):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `initialize_models` 函数根据作为模型参数接收的初始基础模型（以字典格式 `str` 或 `np.array`）初始化神经网络的结构（`numpy.array`）：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For each layer of the model, defined here as model names, this function fills
    out the model parameters. Depending on the `weight_keep` flag, the model is initialized
    with zeros or parameters that are received. This way, the initial cluster global
    model is constructed together with the randomized model ID. If an agent sends
    a different ML model than the model architecture defined here, the aggregator
    rejects the acceptance of the model or gives an error message to the agent. Nothing
    is returned.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型的每一层，这里定义为模型名称，此函数填写模型参数。根据`weight_keep`标志，模型以零或接收到的参数初始化。这样，初始的集群全局模型与随机模型ID一起构建。如果代理发送的ML模型与这里定义的模型架构不同，聚合器将拒绝接受该模型或向代理发送错误信息。不返回任何内容。
- en: So, we have covered initializing the global model. In the following section,
    we will explain the core part of the FL process, which is checking aggregation
    criteria.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经涵盖了全局模型的初始化。在下一节中，我们将解释FL过程的主体部分，即检查聚合标准。
- en: Checking the aggregation criteria
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查聚合标准
- en: 'The following code, called `ready_for_local_aggregation`, is for checking the
    aggregation criteria:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下名为`ready_for_local_aggregation`的代码用于检查聚合标准：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This `ready_for_local_aggregation` function returns a `bool` value to identify
    whether the aggregator can start the aggregation process. It returns `True` if
    it satisfies the aggregation criteria (such as collecting enough local models
    to aggregate) and `False` otherwise. The aggregation threshold, `agg_threshold`,
    is configured in the `config_aggregator.json` file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此`ready_for_local_aggregation`函数返回一个`bool`值，以标识聚合器是否可以开始聚合过程。如果满足聚合标准（例如收集足够的本地模型以进行聚合），则返回`True`，否则返回`False`。聚合阈值`agg_threshold`在`config_aggregator.json`文件中配置。
- en: The following section is about buffering the local models that are used for
    the aggregation process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节是关于缓存用于聚合过程的本地模型。
- en: Buffering the local models
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存本地模型
- en: 'The following code on `buffer_local_models` stores local models from an agent
    in the local model buffer:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下在`buffer_local_models`上的代码将代理的本地模型存储在本地模型缓冲区中：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The parameters include the local `models` formatted as a dictionary as well
    as meta-information such as the number of samples.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包括以字典格式表示的本地`models`以及如样本数量等元信息。
- en: First, this function checks whether the local model sent from an agent is either
    the initial model or not by checking the participation flag. If it is an initial
    model, it calls the `initialize_model` function, as shown in the preceding code
    block.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，此函数通过检查参与标志来确定从代理发送的本地模型是初始模型还是不是。如果是初始模型，它将调用`initialize_model`函数，如前述代码块所示。
- en: Otherwise, for each layer of the model defined with model names, it stores the
    `numpy` array in the `self.local_model_buffers`. The `key` is the model name and
    `model` mentioned in the preceding code are the actual parameters of the model.
    Optionally, it can accept the number of samples or data sources that the agent
    has used for the retraining process and push it to the `self.` `local_model_num_samples`
    buffer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对于用模型名称定义的模型的每一层，它将`numpy`数组存储在`self.local_model_buffers`中。`key`是模型名称，前述代码中提到的`model`是模型的实际参数。可选地，它可以接受代理用于重新训练过程的样本数量或数据源，并将其推送到`self.`
    `local_model_num_samples`缓冲区。
- en: This function is called when the FL server receives the local models from an
    agent during the `receive_msg_from_agent` routine.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当FL服务器在`receive_msg_from_agent`过程中从代理接收本地模型时，会调用此函数。
- en: With that, the local model buffer has been explained. Next, we will explain
    how to clear the saved models so that aggregation can continue without having
    to store unnecessary models in the buffer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，本地模型缓冲区已经解释完毕。接下来，我们将解释如何清除已保存的模型，以便聚合可以继续进行，而无需在缓冲区中存储不必要的模型。
- en: Clearing the saved models
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除已保存的模型
- en: 'The following `clear_saved_models` function clears all cluster models stored
    in this round:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`clear_saved_models`函数清除本轮存储的所有集群模型：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function is called when initializing the FL process at the very beginning
    and the cluster global model is emptied to start a fresh FL round again.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在初始化FL过程之初被调用，集群全局模型被清空，以便再次开始新一轮的FL。
- en: 'The following function, the `clear_lmodel_buffers` function, clears all the
    buffered local models to prepare for the next FL round:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数，`clear_lmodel_buffers`函数，清除所有缓存的本地模型，为下一轮FL做准备：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Clearing the local models in `local_model_buffers` is critical when proceeding
    to the next FL round. Without this process, the models to be aggregated are mixed
    up with the non-relevant models from other rounds, and eventually, the performance
    of the FL is sometimes degraded.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一轮FL之前清除`local_model_buffers`中的本地模型是至关重要的。如果没有这个过程，要聚合的模型将与来自其他轮次的非相关模型混合，最终FL的性能有时会下降。
- en: Next, we will explain the basic framework of adding agents during the FL process.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解释在FL过程中添加代理的基本框架。
- en: Adding agents
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加代理
- en: 'This `add_agent` function deals with brief agent registration using system
    memory:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`add_agent`函数处理使用系统内存进行简短的代理注册：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function just adds agent-related information to the `self.agent_set` list.
    The agent information includes the agent name, agent ID, agent IP address, and
    the `socket` number to reach out to the agent. The `socket` number can be used
    when sending the cluster global model to the agent connected to the aggregator
    and when the `push` method is used for communication between an aggregator and
    an agent. This function is only called during the agent registration process and
    returns the agent ID and the `socket` number.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅向`self.agent_set`列表添加与代理相关的信息。代理信息包括代理名称、代理ID、代理IP地址以及用于联系代理的`socket`编号。`socket`编号可以在将集群全局模型发送到连接到聚合器的代理时使用，以及在聚合器和代理之间使用`push`方法进行通信时使用。此函数仅在代理注册过程中调用，并返回代理ID和`socket`编号。
- en: If the agent is already registered, which means there is already an agent with
    the same name in `agent_set`, it returns the agent ID and the `socket` number
    of the existing agent.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代理已经注册，这意味着`agent_set`中已经存在具有相同名称的代理，它将返回现有代理的代理ID和`socket`编号。
- en: Again, this `push` communication method from an aggregator to agents does not
    work under certain security circumstances. It is recommended to use the `polling`
    method that the agents use to constantly check whether the aggregator has an updated
    global model or not.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，从聚合器到代理的此`push`通信方法在特定安全情况下不起作用。建议使用代理使用的`polling`方法，以不断检查聚合器是否有更新的全局模型。
- en: The agent registration mechanism can be expanded using a database, which will
    give you better management of the distributed systems.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用数据库扩展代理注册机制，这将为您提供更好的分布式系统管理。
- en: Next, we will touch on incrementing the FL round.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将涉及FL轮次的增加。
- en: Incrementing the FL round
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加FL轮次
- en: 'The `increment_round` function just increments the round number precisely managed
    by the state manager:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`increment_round`函数仅精确增加由状态管理器管理的轮次编号：'
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Incrementing rounds is a critical part of the FL process for supporting the
    continuous learning operation. This function is only called after registering
    the initial global model or after each model aggregation process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 增加轮次是FL过程中支持连续学习操作的关键部分。此函数仅在注册初始全局模型或每次模型聚合过程之后调用。
- en: Now that we understand how the FL works with the state manager, in the following
    section, we will talk about the model aggregation framework.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了FL如何与状态管理器协同工作，在接下来的部分，我们将讨论模型聚合框架。
- en: Aggregating local models
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合本地模型
- en: The `aggregation.py` code handles aggregating local models with a bunch of aggregation
    algorithms. In the code example, we only support **FedAvg**, as discussed in the
    following sections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`aggregation.py`代码处理使用一系列聚合算法对本地模型进行聚合。在代码示例中，我们只支持在以下章节中讨论的**FedAvg**。'
- en: Importing the libraries for the aggregator
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入聚合器的库
- en: 'The `aggregation.py` code imports the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`aggregation.py`代码导入以下内容：'
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The imported state manager’s role and functionalities are discussed in the *Maintaining
    models for aggregation with the state manager* section, and the `helpers` and
    `states` libraries are introduced in the *Appendix*, *Exploring Internal Libraries.*
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用状态管理器维护聚合模型*部分中讨论了导入的状态管理器的角色和功能，并在*附录*、*探索内部库*中介绍了`helpers`和`states`库。
- en: After importing the necessary libraries, let’s define the aggregator class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入必要的库之后，让我们定义聚合器类。
- en: Defining and initializing the aggregator class
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和初始化聚合器类
- en: 'The following code for `class Aggregator` defines the core process of the aggregator,
    which provides a set of mathematical functions for computing the aggregated models:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`class Aggregator`的代码定义了聚合器的核心过程，它提供了一套数学函数用于计算聚合模型：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following `__init__` function just sets up the state manager of the aggregator
    to access the model buffers:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `__init__` 函数只是设置聚合器的状态管理器以访问模型缓冲区：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once the aggregator class is defined and initialized, let’s look at the actual
    FedAvg algorithm implementation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦聚合器类被定义和初始化，让我们看看实际的 FedAvg 算法实现。
- en: Defining the aggregate_local_models function
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 aggregate_local_models 函数
- en: 'The following `aggregate_local_models` function is the code for aggregating
    the local models:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `aggregate_local_models` 函数是聚合本地模型的代码：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function can be called after the aggregation criteria are satisfied, such
    as the aggregation threshold defined in the `config_aggregator.json` file. The
    aggregation process uses local ML models buffered in the memory of the state manager.
    Those local ML models are sent from the registered agents. For each layer of the
    models defined by `mname`, the weights of the model are averaged by the `_average_aggregate`
    function as follows to realize FedAvg. After averaging the model parameters of
    all the layers, `cluster_models` is updated, which is sent to all the agents.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以在聚合标准满足后调用，例如在 `config_aggregator.json` 文件中定义的聚合阈值。聚合过程使用状态管理器内存中缓存的本地
    ML 模型。这些本地 ML 模型来自注册的代理。对于由 `mname` 定义的模型的每一层，模型权重由 `_average_aggregate` 函数如下平均，以实现
    FedAvg。在平均所有层的模型参数后，`cluster_models` 被更新，并发送给所有代理。
- en: Then, the local model buffer is cleared to be ready for the next round of the
    FL process.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，清除本地模型缓冲区，为下一轮 FL 流程做好准备。
- en: The FedAvg function
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FedAvg 函数
- en: 'The following function, `_average_aggregate`, called by the preceding `aggregate_local_models`
    function, is the code that realizes the `FedAvg` aggregation method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数 `_average_aggregate`，由前面的 `aggregate_local_models` 函数调用，是实现 `FedAvg` 聚合方法的代码：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the `_average_aggregate` function, the computation is simple enough that,
    for each buffer of the given list of ML models, it takes averaged parameters for
    the models. The basics of model aggregation are discussed in [*Chapter 3*](B18369_03.xhtml#_idTextAnchor058),
    *Workings of the Federated Learning System*. It returns the weighted aggregated
    models with `np.array`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_average_aggregate` 函数中，计算足够简单，对于给定的 ML 模型列表的每个缓冲区，它为模型取平均参数。模型聚合的基本原理在 [*第
    3 章*](B18369_03.xhtml#_idTextAnchor058)，*联邦学习系统的工作原理* 中讨论。它使用 `np.array` 返回加权聚合模型。
- en: Now that we have covered all the essential functionalities of the FL server
    and aggregator, next, we will talk about how to run the FL server itself.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 FL 服务器和聚合器的所有基本功能，接下来，我们将讨论如何运行 FL 服务器本身。
- en: Running the FL server
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 FL 服务器
- en: 'Here is an example of running the FL server. In order to run the FL server,
    you will just execute the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个运行 FL 服务器的示例。为了运行 FL 服务器，你只需执行以下代码：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `register`, `receive_msg_from_agnet`, and `model_synthesis_routine` functions
    of the instance of the FL server are for starting the registration process of
    the agents, receiving messages from the agents, and starting the model synthesis
    process to create a global model, which are all started using the `init_fl_server`
    function from the `communication_handler` libraries.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: FL 服务器实例的 `register`、`receive_msg_from_agent` 和 `model_synthesis_routine` 函数用于启动代理的注册过程、接收代理的消息以及启动模型合成过程以创建全局模型，所有这些都是使用
    `communication_handler` 库中的 `init_fl_server` 函数启动的。
- en: We have covered all the core modules of the aggregator with the FL server. They
    can work with the database server, which will be discussed in the following section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 FL 服务器涵盖了聚合器的所有核心模块。它们可以与数据库服务器一起工作，这将在下一节中讨论。
- en: Implementing and running the database server
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现和运行数据库服务器
- en: The database server can be hosted either on the same machine as the aggregator
    server or separately from the aggregator server. Whether the database server is
    hosted on the same machine or not, the code introduced here is still applicable
    to both cases. The database-related code is found in the `fl_main/pseudodb` folder
    of the GitHub repository provided alongside this book.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务器可以托管在聚合器服务器所在的同一台机器上，也可以与聚合器服务器分开。无论数据库服务器是否托管在同一台机器上，这里引入的代码都适用于这两种情况。数据库相关的代码可以在本书提供的
    GitHub 仓库的 `fl_main/pseudodb` 文件夹中找到。
- en: Toward the configuration of the database
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向数据库的配置
- en: 'The following code is an example of the database-side configuration parameters
    saved as `config_db.json`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是作为 `config_db.json` 保存的数据库端配置参数的示例：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In particular, `db_data_path` is the location of the SQLite database and `db_model_path`
    is the location of the ML model binary files. The `config_db.json` file can be
    found in the `setup` folder.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，`db_data_path`是SQLite数据库的位置，`db_model_path`是ML模型二进制文件的位置。`config_db.json`文件可以在`setup`文件夹中找到。
- en: Next, let’s define the database server and import the necessary libraries.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义数据库服务器并导入必要的库。
- en: Defining the database server
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据库服务器
- en: The main functionality of the `pseudo_db.py` code is accepting messages that
    contain local and cluster global models.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`pseudo_db.py`代码的主要功能是接收包含本地和集群全局模型的包含消息。'
- en: Importing the libraries for the pseudo database
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入伪数据库所需的库
- en: 'First, the `pseudo_db.py` code imports the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`pseudo_db.py`代码导入了以下内容：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It imports the basic general libraries as well as `SQLiteDBHandler` (discussed
    later in the *Defining the database with SQLite* section) and the functions from
    the `lib/util` libraries that are discussed in the *Appendix*, *Exploring Internal
    Libraries*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它导入了基本通用库以及`SQLiteDBHandler`（在*使用SQLite定义数据库*部分中讨论）和来自`lib/util`库的函数，这些函数在*附录*、*探索内部库*中讨论。
- en: Defining the PseudoDB class
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义PseudoDB类
- en: 'The `PseudoDB` class is then defined to create an instance that receives models
    and their data from an aggregator and pushes them to an actual database (SQLite,
    in this case):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义了`PseudoDB`类以创建一个实例，该实例从聚合器接收模型及其数据并将其推送到实际的数据库（在这个例子中是SQLite）：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, let us move on to initializing the instance of `PseudoDB`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续初始化`PseudoDB`的实例。
- en: Initializing PseudoDB
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化PseudoDB
- en: 'Then, the initialization process, `__init__`, is defined as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，初始化过程`__init__`被定义为以下内容：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The initialization process generates the ID of the instance and sets up various
    parameters such as the database socket (`db_socket`), the database IP address
    (`db_ip`), the path to the database (`data_path`), and the database file (`db_file`),
    all configured from `config_db.json`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化过程生成实例ID并设置各种参数，如数据库套接字（`db_socket`）、数据库IP地址（`db_ip`）、数据库路径（`data_path`）和数据库文件（`db_file`），所有这些均从`config_db.json`配置。
- en: '`dbhandler` stores the instance of `SQLiteDBHandler` and calls the `initialize_DB`
    function to create an SQLite database.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbhandler`存储`SQLiteDBHandler`的实例并调用`initialize_DB`函数来创建SQLite数据库。'
- en: Folders for `data_path` and `db_model_path` are created if they do not already
    exist.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，则创建`data_path`和`db_model_path`的文件夹。
- en: After the initialization process of `PseudoDB`, we need to design the communication
    module that accepts the messages from the aggregators. We again use WebSocket
    for communicating with an aggregator and start this module as a server to accept
    and respond to messages from an aggregator. In this design, we do not push messages
    from the database server to an aggregator or agents in order to make the FL mechanism
    simpler.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PseudoDB`的初始化过程之后，我们需要设计通信模块以接收来自聚合器的消息。我们再次使用WebSocket与聚合器进行通信，并将此模块作为服务器启动以接收和响应来自聚合器的消息。在这个设计中，我们不将来自数据库服务器的消息推送到聚合器或代理，以简化FL机制。
- en: Handling messages from the aggregator
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理来自聚合器的消息
- en: 'The following code for the `async def handler` function, which takes `websocket`
    as a parameter, receives messages from the aggregator and returns the requested
    information:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`async def handler`函数的代码，该函数以`websocket`作为参数，接收来自聚合器的消息并返回所需的信息：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the `handler` function, once it decodes the received message from an aggregator,
    the `handler` function checks whether the message type is `push` or not. If so,
    it tries to push the local or cluster models to the database by calling the _`push_all_data_to_db`
    function. Otherwise, it will show an error message. The confirmation message about
    pushing the models to the database can then be sent back to the aggregator.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handler`函数中，一旦它解码了从聚合器接收到的消息，`handler`函数会检查消息类型是否为`push`。如果是，它将尝试通过调用`_push_all_data_to_db`函数将本地或集群模型推送到数据库。否则，它将显示错误消息。然后可以将确认消息发送回聚合器。
- en: Here, we only defined the type of the `push` message, but you can define as
    many types as possible, together with the enhancement of the database schema and
    design.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只定义了`push`消息的类型，但你可以定义尽可能多的类型，同时增强数据库模式设计。
- en: Pushing all the data to the database
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有数据推送到数据库
- en: 'The following code for `_push_all_data_to_db` pushes the models’ information
    to the database:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`_push_all_data_to_db`代码将模型信息推送到数据库：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The models’ information is extracted by the `_parse_message` function and passed
    to the `_insert_an_entry` function. Then, the actual models are saved in the local
    server filesystems, where the filename of the models and the path are defined
    by `db_model_path` and `fname` here.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的信息通过`_parse_message`函数提取，并传递给`_insert_an_entry`函数。然后，实际的模型保存在本地服务器文件系统中，其中模型的文件名和路径由这里的`db_model_path`和`fname`定义。
- en: Parsing the message
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析消息
- en: 'The `_parse_message` function just extracts the parameters from the received
    message:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`_parse_message`函数仅从接收到的消息中提取参数：'
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function parses the received message into parameters related to agent ID
    or aggregator ID (`component_id`), round number (`r`), message type (`mt`), `model_id`,
    time of generation of the models (`gene_time`), and performance data as a dictionary
    format (`meta_data`). The local performance data, `local_prfmc`, is extracted
    when the model type is local. The amount of sample data used at the local device
    is also extracted from `meta_dect`. All these extracted parameters are returned
    at the end.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将接收到的消息解析为与代理ID或聚合器ID（`component_id`）、轮数（`r`）、消息类型（`mt`）、`model_id`、模型生成时间（`gene_time`）以及以字典格式（`meta_data`）的性能数据相关的参数。当模型类型为本地时，提取本地性能数据`local_prfmc`。从`meta_dect`中提取在本地设备上使用的样本数据量。所有这些提取的参数在最后返回。
- en: In the following section, we will explain the database implementation using
    the SQLite framework.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将解释使用SQLite框架实现的数据库。
- en: efining the database with SQLite
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQLite定义数据库
- en: The `sqlite_db.py` code creates the SQLite database and deals with storing and
    retrieving data from the database.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite_db.py`代码创建SQLite数据库并处理从数据库中存储和检索数据。'
- en: Importing libraries for the SQLite database
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入SQLite数据库的库
- en: '`sqlite_db.py` imports the basic general libraries and `ModelType` as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite_db.py`按照如下方式导入基本通用库和`ModelType`：'
- en: '[PRE40]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ModelType` from `lib/util` defines the type of the models: local models
    and (global) cluster models.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib/util`中的`ModelType`定义了模型类型：本地模型和（全局）集群模型。'
- en: Defining and initializing the SQLiteDBHandler class
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和初始化SQLiteDBHandler类
- en: 'Then, the following code related to the `SQLiteDBHandler` class creates and
    initializes the SQLite database and inserts models into the SQLite database:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下与`SQLiteDBHandler`类相关的代码创建并初始化SQLite数据库，并将模型插入SQLite数据库：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The initialization is very simple – just setting the `db_file` parameter passed
    from the `PseudoDB` instance to `self.db_file`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化非常简单——只需将`PseudoDB`实例传递的`db_file`参数设置为`self.db_file`：
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Initializing the database
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化数据库
- en: 'In the following `initialize_DB` function, the database tables are defined
    with local and cluster models using SQLite (`sqlite3`):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的`initialize_DB`函数中，使用SQLite（`sqlite3`）定义了本地和集群模型的数据库表：
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The tables are simplified in this example so that you can easily follow the
    uploaded local models and their performance as well as the global models created
    by an aggregator.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，表被简化了，这样你可以轻松地跟踪上传的本地模型及其性能，以及由聚合器创建的全局模型。
- en: The `local_models` table has a model ID (`model_id`), the time the model is
    generated (`generation_time`), an agent ID uploaded of the local model (`agent_id`),
    round information (`round`), the performance data of the local model (`performance`),
    and the number of samples used for FedAvg aggregation (`num_samples`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`local_models`表具有模型ID（`model_id`）、模型生成时间（`generation_time`）、上传的本地模型代理ID（`agent_id`）、轮次信息（`round`）、本地模型的性能数据（`performance`）以及用于FedAvg聚合使用的样本数量（`num_samples`）。'
- en: '`cluster_models` has a model ID (`model_id`), the time the model is generated
    (`generation_time`), an aggregator ID (`aggregator_id`), round information (`round`),
    and the number of samples (`num_samples`).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster_models`具有模型ID（`model_id`）、模型生成时间（`generation_time`）、聚合器ID（`aggregator_id`）、轮次信息（`round`）和样本数量（`num_samples`）。'
- en: Inserting an entry into the database
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将条目插入数据库
- en: 'The following code for `insert_an_entry` inserts the data received as parameters
    using `sqlite3` libraries:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于`insert_an_entry`，使用`sqlite3`库将接收到的参数数据插入：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This function takes the parameters of `component_id` (agent ID or aggregator
    ID), round number (`r`), message type (`mt`), model ID (`model_id`), the time
    the model is generated (`gtime`), the local model’s performance data (`local_prfmc`),
    and the number of samples (`num_samples`) to insert an entry with the `execute`
    function of the SQLite library.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受`component_id`（代理ID或聚合器ID）、轮数（`r`）、消息类型（`mt`）、模型ID（`model_id`）、模型生成时间（`gtime`）、本地模型性能数据（`local_prfmc`）和要插入的样本数量（`num_samples`）作为参数，使用SQLite库的`execute`函数插入条目。
- en: If the model type is *local*, the information of the models is inserted into
    the `local_models` table. If the model type is *cluster*, the information of the
    models is inserted into the `cluster_models` table.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型类型是*本地*，则将模型信息插入到`local_models`表中。如果模型类型是*集群*，则将模型信息插入到`cluster_models`表中。
- en: Other functions, such as updating and deleting data from the database, are not
    implemented in this example code and it’s up to you to write those additional
    functions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 其他功能，例如更新和删除数据库中的数据，在此示例代码中未实现，您需要自行编写这些附加功能。
- en: In the following section, we will explain how to run the database server.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何运行数据库服务器。
- en: Running the database server
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行数据库服务器
- en: 'Here is the code for running the database server with the SQLite database:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用SQLite数据库运行数据库服务器的代码：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The instance of `PseudoDB` class is created as `pdb`. The `pdb.handler`, the
    database’s IP address (`pdb.db_ip`), and the database socket (`pdb.db_socket`)
    are used to start the process of receiving local and cluster models from an aggregator
    enabled by `init_db_server` from the `communication_handler` library in the `util/lib`
    folder.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`PseudoDB`类的实例被创建为`pdb`。`pdb.handler`、数据库的IP地址（`pdb.db_ip`）和数据库套接字（`pdb.db_socket`）用于启动从`init_db_server`函数中启用并由`communication_handler`库在`util/lib`文件夹中提供的聚合器接收本地和集群模型的过程。'
- en: Now, we understand how to implement and run the database server. The database
    tables and schema discussed here are minimally designed so that we can understand
    the fundamentals of the FL server’s procedure. In the following section, we will
    discuss potential enhancements to the FL server.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们了解了如何实现和运行数据库服务器。本章中讨论的数据库表和模式设计得尽可能简单，以便我们理解FL服务器流程的基本原理。在下一节中，我们将讨论FL服务器的潜在增强功能。
- en: Potential enhancements to the FL server
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FL服务器的潜在增强功能
- en: Here are some of the key potential enhancements to the FL server discussed in
    this chapter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中讨论了FL服务器的一些关键潜在增强功能。
- en: Redesigning the database
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新设计数据库
- en: The database was intentionally designed with minimal table information in this
    book and needs to be extended, such as by having tables of the aggregator itself,
    agents, the initial base model, and the project info, among other things, in the
    database. For example, the FL system described here in this chapter does not support
    the termination and restart of the server and agent processes. Thus, the FL server
    implementation is not complete, as it loses most of the information when any of
    the systems is stopped or failed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，数据库有意设计为包含最少的表信息，需要扩展，例如通过在数据库中添加聚合器本身、代理、初始基础模型和项目信息等表。例如，本章中描述的FL系统不支持服务器和代理进程的终止和重启。因此，FL服务器的实现并不完整，因为它在系统停止或失败时丢失了大部分信息。
- en: Automating the registry of an initial model
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动注册初始模型
- en: In order to simplify the explanation of the process of registering the initial
    model, we defined the layers of the ML models using model names. This registration
    of the model in the system can be automated so that just loading a certain ML
    model, such as PyTorch or Keras models, with file extensions such as `.pt/.pth`
    and `.h5`, will be enough for the users of the FL systems to start the process.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化注册初始模型的过程的解释，我们使用模型名称定义了ML模型的层。在系统中注册此模型可以自动化，这样只需加载具有`.pt/.pth`和`.h5`等文件扩展名的特定ML模型（如PyTorch或Keras模型），FL系统的用户就可以开始这个过程。
- en: Performance metrics for local and global models
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地模型和全局模型性能指标
- en: Again, to simplify the explanation of the FL server and the database-side functionalities,
    an accuracy value is just used as one of the performance criteria of the models.
    Usually, ML applications have many more metrics to keep track of as performance
    data and they needs to be enhanced together with the database and communications
    protocol design.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了简化对FL服务器和数据库端功能的解释，准确度值仅被用作模型性能标准之一。通常，机器学习应用有更多指标需要跟踪作为性能数据，并且它们需要与数据库和通信协议设计一起增强。
- en: Fine-tuned aggregation
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微调聚合
- en: In order to simplify the process of aggregating the local models, we just used
    FedAvg, a weighted averaging method. The number of samples can dynamically change
    depending on the local environment, and that aspect is enhanced by you. There
    are also a variety of model aggregation methods, which will be explained in [*Chapter
    7*](B18369_07.xhtml#_idTextAnchor176), *Model Aggregation*, of this book so that
    you can accommodate the best aggregation method depending on the ML applications
    to be created and integrated into the FL system.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化聚合本地模型的过程，我们仅使用了FedAvg，这是一种加权平均方法。样本数量可以根据本地环境动态变化，这一方面由你增强。还有各种模型聚合方法，这些方法将在本书的[*第7章*](B18369_07.xhtml#_idTextAnchor176)“模型聚合”中解释，以便你可以根据要创建和集成到FL系统中的ML应用选择最佳的聚合方法。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, the basics and principles of FL server-side implementation
    were explained with actual code examples. Having followed the contents of this
    chapter, you should now be able to construct the FL server-side functionalities
    with model aggregation mechanisms.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，通过实际的代码示例解释了FL服务器端实现的基本原理和原则。跟随本章内容后，你现在应该能够使用模型聚合机制构建FL服务器端功能。
- en: The server-side components that were introduced here involve basic communications
    and the registration of the agents and initial models, managing state information
    used for the aggregation, and the aggregation mechanisms for creating the global
    cluster models. In addition, we discussed the implementation of the database to
    just store the information of the ML models. The code was simplified so that you
    were able to understand the principles of server-side functionalities. Further
    enhancements to many other aspects of constructing a more sustainable, resilient,
    and scalable FL system are up to you.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的服务器端组件包括基本的通信、代理和初始模型的注册、用于聚合的状态信息管理，以及创建全局集群模型的聚合机制。此外，我们还讨论了仅存储ML模型信息的数据库实现。代码被简化，以便你能够理解服务器端功能的原则。构建更可持续、弹性、可扩展的FL系统的许多其他方面的进一步改进取决于你。
- en: In the next chapter, we will discuss the principle of implementing the functionalities
    of the FL client and agent. The client side needs to provide some well-designed
    APIs for the ML applications for plugin use. Therefore, the chapter will discuss
    the FL client's core functionalities and libraries as well as the library integration
    into the very simple ML applications to enable the whole FL process.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论实现FL客户端和代理功能的原则。客户端需要为机器学习应用提供一些精心设计的API以供插件使用。因此，本章将讨论FL客户端的核心功能库以及库集成到非常简单的ML应用中，以实现整个FL过程。
