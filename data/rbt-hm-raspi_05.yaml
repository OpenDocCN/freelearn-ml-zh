- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Driving Motors with Raspberry Pi Pico
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Raspberry Pi Pico驱动电机
- en: Our robot is looking ready to run. The first real test of a robot chassis is
    getting its motors to drive. This chapter will bring the robot to life, testing
    the wiring and motors, using **CircuitPython** on Raspberry Pi Pico. We will start
    with simple tests for each motor and then use them together to make movements.
    Finally, we will learn more sophisticated code to control their speed and end
    the chapter by making a path.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人看起来已经准备好运行了。机器人底盘的第一个实际测试是让它的电机开始驱动。本章将使机器人复活，测试线路和电机，使用Raspberry Pi Pico上的**CircuitPython**。我们将从每个电机的简单测试开始，然后一起使用它们来制造动作。最后，我们将学习更复杂的代码来控制它们的速度，并在本章结束时制作一条路径。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Driving forward and back
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前进和后退驾驶
- en: Steering with two motors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个电机转向
- en: An introduction to PWM speed control
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PWM速度控制简介
- en: Driving along a planned path
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着规划好的路径驾驶
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: First is the built robot, as made in the previous chapters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是之前章节中制作的机器人
- en: 6 x fresh AA batteries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6节新的AA电池
- en: A PC or laptop with a USB micro cable
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台带有USB微型电缆的PC或笔记本电脑
- en: Mu software to write our code and upload it
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mu软件用于编写代码和上传
- en: Clear floor space with a meter or so in each direction to test the robot
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理地面空间，每个方向大约一米，以测试机器人
- en: All code examples are on GitHub at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-05](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-05).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例都在GitHub上，网址为[https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-05](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-05)。
- en: Driving forward and back
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前进和后退驾驶
- en: Our motors are attached, and the robot is looking ready to power up. First,
    we’ll use CircuitPython to make test code to try each motor in turn. Then, when
    we have demonstrated the motors running, we’ll make simple code to drive the motors
    straight forward and then back.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 电机已经安装，机器人看起来已经准备好供电。首先，我们将使用CircuitPython来制作测试代码，依次尝试每个电机。然后，当我们证明了电机可以运行时，我们将编写简单的代码来使电机直线前进和后退。
- en: Testing each motor with CircuitPython
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CircuitPython测试每个电机
- en: 'We will start driving our robot by looking at how we connected our Raspberry
    Pi Pico to our motors in the following figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下图中的连接来开始驾驶我们的机器人：
- en: '![Figure 5.1 – Motor connections from Raspberry Pi Pico ](img/Figure_5.01_B18001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – Raspberry Pi Pico的电机连接](img/Figure_5.01_B18001.jpg)'
- en: Figure 5.1 – Motor connections from Raspberry Pi Pico
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – Raspberry Pi Pico的电机连接
- en: '*Figure 5**.1* shows a closer look at the robot motor connections. On the left
    is Raspberry Pi Pico with four connections to the motor controller. They are on
    GPIO 16, 17, 18, and 19\. These connections result in the motor controller powering
    the motor via one of the motor wires. Testing each of the Pico pins should cause
    a motor to do something.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5*.1展示了机器人电机连接的更详细视图。在左边是Raspberry Pi Pico，它与电机控制器有四个连接。它们位于GPIO 16、17、18和19。这些连接导致电机控制器通过电机线中的一根线为电机供电。测试Pico的每个引脚应该会导致电机做出某种动作。'
- en: 'Let’s try this with some code, setting up one motor, and making it drive in
    a single direction. This example is called `motors_test_1_pin.py`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些代码来尝试，设置一个电机，并使其单向行驶。这个例子叫做 `motors_test_1_pin.py`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code looks very similar to the LED code from [*Chapter 2*](B18001_02.xhtml#_idTextAnchor041),
    *Preparing Raspberry Pi Pico*. We set `board.GP17`, connected to the `AIN1` pin
    on the motor controller, to a digital output.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来与[*第2章*](B18001_02.xhtml#_idTextAnchor041)中的LED代码非常相似，*准备Raspberry Pi
    Pico*。我们将`board.GP17`，连接到电机控制器上的`AIN1`引脚，设置为数字输出。
- en: The code sets `GP17` to `True`, turning it on, then waits for 0.3 seconds, and
    sets the motor pin to `False` to turn it off.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将`GP17`设置为`True`，打开它，然后等待0.3秒，将电机引脚设置为`False`来关闭它。
- en: 'Type this code into `Mu` and save it to `CIRCUITPY`. For this test, prop the
    robot up so that the wheels do not contact anything. To start this file, create
    a `code.py` module too:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码输入到`Mu`中，并保存到`CIRCUITPY`。为此测试，将机器人支撑起来，使车轮不接触任何东西。要启动此文件，还需要创建一个`code.py`模块：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you recall from [*Chapter 2*](B18001_02.xhtml#_idTextAnchor041), *Preparing
    Raspberry Pi Pico*, Raspberry Pi Pico will run the content of `code.py` when the
    robot starts or when you change a file on `CIRCUITPY`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得从[*第2章*](B18001_02.xhtml#_idTextAnchor041)，*准备Raspberry Pi Pico*，当机器人启动或你在`CIRCUITPY`上更改文件时，Raspberry
    Pi Pico将运行`code.py`中的内容。
- en: When you start this code, a motor moves for a short time and stops. The motor
    should run forward. If not, swap the motor output pins on this side. Repeat this
    exercise with `GP18` and check whether the other motor runs forward too.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动此代码时，一个电机短暂移动然后停止。电机应该向前运行。如果不是，请交换这侧的电机输出引脚。用`GP18`重复此练习并检查另一个电机是否也向前运行。
- en: How do you test this?
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你该如何测试这个？
- en: 'For all the remaining examples in the chapter, use the following procedure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中剩余的所有示例，请使用以下步骤：
- en: On the Pico (the `CIRCUITPY` drive), ensure the `code.py` file is empty; otherwise,
    it will rerun the old program until you update it.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Pico（`CIRCUITPY`驱动器）上，确保`code.py`文件为空；否则，它将重新运行旧程序，直到你更新它。
- en: Write your program and save it on your computer. You don’t want to lose it!
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的电脑上编写程序并保存。你不想丢失它！
- en: Copy the program (and supporting files that have changed; we will be adding
    `robot.py` soon) onto the Pico.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将程序（以及已更改的辅助文件；我们很快将添加`robot.py`）复制到Pico上。
- en: Ensure the power switch is on and batteries are installed.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保电源开关开启且已安装电池。
- en: Have the robot propped up on something so that the wheels don’t contact anything.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让机器人靠在某个东西上，这样轮子就不会接触到任何东西。
- en: Update `code.py` to import the name of your program without the `.``py` extension.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`code.py`以导入你的程序名称，不包含`.py`扩展名。
- en: The first test of the code is seeing it run this way.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的第一个测试是看到它以这种方式运行。
- en: To run it for real, disconnect the Pico and turn off the power.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实际运行它，请断开Pico并关闭电源。
- en: Then, put the robot in a clear space (the carpet or floor) and power it on.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将机器人放在一个开阔的空间（地毯或地板上）并开启电源。
- en: Be prepared to pick it up and turn it off if it does something unexpected –
    the robot can damage itself if it drives into an obstacle without stopping.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好如果它做了意想不到的事情就捡起来并关闭它——如果机器人没有停止就撞到障碍物，它可能会损坏自己。
- en: You can also press *Ctrl* + *C* from the REPL at any time to stop a program
    running.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以在任何时候从REPL中按*Ctrl* + *C*来停止一个正在运行的程序。
- en: Troubleshooting
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'There are some ways this could go wrong. Let’s check a few here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能出错的方式有很多。让我们在这里检查几个：
- en: If the `import` in `code.py` and your `motors_test_1_pin` filename do not match,
    you’ll likely get an error in the REPL and nothing will happen.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`code.py`中的`import`和你的`motors_test_1_pin`文件名不匹配，你很可能会在REPL中遇到错误，什么都不会发生。
- en: If the robot’s UBEC is connected but the batteries are powered down, the robot
    may try to take too much power from the USB port. If you intend to test the motors,
    ensure the robot is powered on. If not, it may be good to disconnect the UBEC.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人的UBEC连接了但电池未供电，机器人可能会从USB端口获取过多的电流。如果你打算测试电机，确保机器人已开启电源。如果不是，可能最好断开UBEC。
- en: If nothing still happens, disconnect the robot, turn it off, and check the wiring
    thoroughly – there should be no hot parts in the robot.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果仍然没有任何动作，请断开机器人连接，关闭它，并彻底检查线路——机器人中不应该有任何过热的部件。
- en: Now that you know how to test your code and make a simple example work, you
    are ready for more complicated examples.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何测试你的代码并使一个简单的示例工作，你就可以准备更复杂的示例了。
- en: Testing multiple pins
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试多个引脚
- en: 'Let’s extend this code to test all the motor pins in `motors_test_all_pins.py`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此代码扩展到测试`motors_test_all_pins.py`中的所有电机引脚：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code extends the first code example to test all the motor pins. Update
    `code.py` to import this instead, and you should see each wheel turn one way and
    then the other. If you do not see movement like this, please turn off the power/disconnect
    the robot and go back to [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080), *Building
    a Robot around Pico*, to carefully check the wiring.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码扩展了第一个代码示例以测试所有电机引脚。更新`code.py`以导入此代码，你应该看到每个轮子先朝一个方向转动，然后朝另一个方向转动。如果你没有看到这样的动作，请关闭电源/断开机器人连接，并返回到[*第4章*](B18001_04.xhtml#_idTextAnchor080)，*围绕Pico构建机器人*，仔细检查线路。
- en: 'We will use these motors a lot. To save us from copying all the setup code
    each time, we can put it in a new file called `robot.py`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大量使用这些电机。为了节省我们每次都复制所有设置代码的时间，我们可以将其放入一个名为`robot.py`的新文件中：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, you won’t have to type that again. We can rewrite `motors_test_1_pin.py`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不必再输入它了。我们可以重写`motors_test_1_pin.py`：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can run this (remember to change `code.py`) and apply the same change to
    `motors_test_all_pins.py`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行这个（记得更改`code.py`）并将相同的更改应用到`motors_test_all_pins.py`。
- en: This code demonstrates that we can move the motors, but how do we use them together?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了我们可以移动电机，但我们如何一起使用它们呢？
- en: Driving wheels in a straight line
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直线行驶的驱动轮
- en: 'In terms of motor direction, each motor pin controls this. Look at the following
    diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在电机方向方面，每个电机引脚控制这一点。看看下面的图：
- en: '![Figure 5.2 – Controlling motor direction ](img/Figure_5.02_B18001.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 控制电机方向](img/Figure_5.02_B18001.jpg)'
- en: Figure 5.2 – Controlling motor direction
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 控制电机方向
- en: The preceding diagram shows a box representing the connection to the motor and
    its pins. Beside each is **True** or **False**, signifying the state of the controlling
    pin on a Raspberry Pi Pico. The arrows show the conventional current direction
    of power to the motor. With one pin high, current flows from this pin; if it is
    low, current flows back. When we set motor pins to opposite values, current will
    flow between the motor controller outputs and a motor turns. If the motor pins
    are both low, there is no current, and the motor is turned off and can coast.
    If they are both high, the motor will stop, like brakes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了一个代表电机及其引脚的方框。每个旁边都有**True**或**False**，表示在Raspberry Pi Pico上控制引脚的状态。箭头显示了电力的传统电流方向。当一个引脚为高时，电流从该引脚流出；如果它是低的，电流回流。当我们设置电机引脚为相反值时，电流将在电机控制器输出和电机之间流动，电机转动。如果电机引脚都是低的，则没有电流，电机关闭并可以滑行。如果它们都是高的，电机将停止，就像刹车一样。
- en: Important note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In electronics, we describe current in two ways. **Conventional current** describes
    electricity flowing from the positive terminal of a power source to the negative
    terminal. However, the actual physics shows that negatively charged electrons
    flow the other way. We will stick to using conventional current to avoid confusion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子学中，我们以两种方式描述电流。**传统电流**描述的是从电源的正极流向负极的电流。然而，实际的物理现象显示负电荷的电子是相反方向流动的。我们将坚持使用传统电流以避免混淆。
- en: 'We can put this to use driving in a straight line. When we drive both motors
    together, a robot drives in a line forward or back. For example, look at the following
    figure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点来直线行驶。当我们同时驱动两个电机时，机器人可以向前或向后直线行驶。例如，看看下面的图：
- en: '![Figure 5.3 – Driving in a straight line ](img/Figure_5.03_B18001.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 直线行驶](img/Figure_5.03_B18001.jpg)'
- en: Figure 5.3 – Driving in a straight line
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 直线行驶
- en: '*Figure 5**.3* shows a forward arrow from each wheel showing the motors are
    going forward. The combined wheel movement results in the robot driving forward
    – shown by the wide arrow in front of the robot.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.3*显示了每个轮子都有一个指向前的箭头，表示电机正在向前行驶。轮子的组合运动导致机器人向前行驶——由机器人前面的宽箭头所示。'
- en: The lines aren’t quite straight as motors are slightly different, and it goes
    off slightly; we call this **veer**. We’ll see how to correct this later in the
    book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 线条并不完全笔直，因为电机略有不同，所以会有轻微的偏离；我们称这为**偏航**。我们将在本书的后面部分看到如何纠正这一点。
- en: 'Let’s make code to drive forward – `motors_forward.py`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码来驱动前进——`motors_forward.py`：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code sets both motors forward by enabling (setting to `True`) the `A1`
    and `B1` pins. It waits for 0.3 seconds (300 ms) and then stops both motors. To
    drive for longer, you can increase the time. Using time to approximately control
    distance is not very accurate though.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过启用（设置为`True`）`A1`和`B1`引脚来使两个电机向前。它等待0.3秒（300毫秒），然后停止两个电机。如果要行驶更长的时间，可以增加时间。不过，使用时间来大致控制距离并不非常准确。
- en: 'Going backward means using the `A2` and `B2` pins instead (`motors_backward.py`):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 向后行驶意味着使用`A2`和`B2`引脚代替（`motors_backward.py`）：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Other than changing the pins, this code is identical.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改引脚外，此代码与之前相同。
- en: We can now drive forward and backward, but how do we make turns?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以前进和后退，但我们如何转弯呢？
- en: Steering with two motors
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用两个电机转向
- en: 'If we move one motor and not the other, the robot turns toward the wheel that
    isn’t moving. For example, look at the following diagram:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移动一个电机而不移动另一个，机器人会转向不动的轮子。例如，看看下面的图示：
- en: '![Figure 5.4 – Steering a robot with motors ](img/Figure_5.04_B18001.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 使用电机转向机器人](img/Figure_5.04_B18001.jpg)'
- en: Figure 5.4 – Steering a robot with motors
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 使用电机转向机器人
- en: '*Figure 5**.4* shows two turning robots. There is a forward arrow above the
    left wheel in the first panel, showing the wheel is driving forward. The right
    wheel is stopped. A transparent arrow superimposed on this shows the turn direction
    and that this turn pivots on the right wheel. The right robot shows an opposite
    turn. A robot can turn backward in the same way by reversing a single motor instead.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.4* 展示了两个转弯机器人。在第一个面板中，左轮上方有一个向前箭头，表示该轮子正在驱动前进。右轮停止。一个透明的箭头叠加在这个箭头上，显示了转弯方向以及这次转弯以右轮为支点。右边的机器人显示了相反的转弯。机器人可以通过反转单个电机以相同的方式向后转弯。'
- en: 'As we will do more with motors, we’ll extend `robot.py` so that we can stop
    them all. Add this code at the end of `robot.py`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将更多地使用电机，我们将扩展 `robot.py` 以便我们可以停止它们。在 `robot.py` 的末尾添加此代码：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ensure you copy this new version onto the Pico.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将此新版本复制到 Pico 上。
- en: 'We can now use our turn principle in some code – `motors_1_motor_turn.py`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在一些代码中使用我们的转弯原理——`motors_1_motor_turn.py`：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code example is very similar to the one-pin motor test. Only the `stop()`
    command is new. We roughly control the angle of turn by timing. It is tricky but
    possible to get 90-degree turns, but they won’t be exact. Using different pins,
    we can turn using the motor on the other side, or reverse the current motor using
    the same principle.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例与单引脚电机测试非常相似。只有 `stop()` 命令是新的。我们通过计时大致控制转动的角度。虽然很棘手，但可以实现 90 度的转弯，但它们不会非常精确。使用不同的引脚，我们可以使用另一侧的电机进行转弯，或者使用相同的原则反转当前电机的电流。
- en: 'What about using two motors? If we drive one motor forward and the other back,
    we can make a faster tighter turn and spin on the spot. Look at the following
    figure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 那么使用两个电机呢？如果我们驱动一个电机向前，另一个电机向后，我们可以进行更快、更紧密的转弯，并在原地旋转。看看下面的图：
- en: '![Figure 5.5 – Spinning with two motors ](img/Figure_5.05_B18001.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 使用两个电机旋转](img/Figure_5.05_B18001.jpg)'
- en: Figure 5.5 – Spinning with two motors
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 使用两个电机旋转
- en: '*Figure 5**.5* shows the robot with an arrow going forward from one motor and
    back from the other. I’ve included a rotation arrow between the two wheels, showing
    the pivot for this turn. Let’s see this in code; I suggest calling it `motors_2_motor_turn.py`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.5* 展示了机器人，一个箭头从一个电机向前，另一个电机向后。我在两个轮子之间包含了一个旋转箭头，显示了这次转弯的支点。让我们看看代码实现；我建议将其命名为
    `motors_2_motor_turn.py`：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code sets two pins high, `A1` and `B2` – you could say, diagonally opposite
    pairs. Driving `A2` and `B1` would spin the other way. Again, the timing controls
    the angle, and then we stop all the motors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将两个引脚设置为高电平，`A1` 和 `B2` ——你可以说是对角线相对的配对。驱动 `A2` 和 `B1` 将会以相反方向旋转。同样，时间控制角度，然后我们停止所有电机。
- en: We can now move our motors, but they are on or off. However, we aren’t controlling
    the speed, and we seem to be able to do one motor turn or full spin – what about
    gentler sweeping turns? The following section will get into pulse width modulation
    and how this controls motor speeds.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以移动我们的电机，但它们只是开或关。然而，我们并没有控制速度，我们似乎只能进行一次电机转动或完整旋转——那么柔和的扫转呢？下一节将介绍脉冲宽度调制以及它是如何控制电机速度的。
- en: An introduction to pulse width modulation speed control
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脉冲宽度调制速度控制简介
- en: '**Pulse Width Modulation** (**PWM**) is how we control motor speeds from a
    digital control system. Instead of varying the voltage supplied to a motor, we
    use pulses to control it. The pulses are usually at a fixed rate, but the ratio
    of time-on to time-off changes. We call this the **duty cycle**. Controlling how
    much time per cycle the signal is on versus off will control the power getting
    to a motor. If the pulse is on for longer, the motor will go faster. The motor
    will go slower if the pulse is on for less time. So, at 50% time-on, the motor
    will be about 50% of its maximum speed.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**脉冲宽度调制**（**PWM**）是我们从数字控制系统控制电机速度的方式。我们不是改变供给电机的电压，而是使用脉冲来控制它。脉冲通常是固定频率的，但开启时间和关闭时间的比例会变化。我们称之为**占空比**。控制信号在每个周期内开启和关闭的时间将控制到达电机的功率。如果脉冲开启时间更长，电机将运行得更快。如果脉冲开启时间更短，电机将运行得更慢。因此，在
    50% 的开启时间内，电机将大约是其最大速度的 50%。'
- en: 'The following diagram shows visual examples of this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这一点的视觉示例：
- en: '![Figure 5.6 – PWM signals ](img/Figure_5.06_B18001.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – PWM 信号](img/Figure_5.06_B18001.jpg)'
- en: Figure 5.6 – PWM signals
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – PWM 信号
- en: The preceding diagram shows graphs of PWM signals. The top is a signal for driving
    a motor at half speed. The pulses on and off time are the same. The *X* axis is
    the level, and the *Y* axis is for time, with a solid line for the PWM signal
    and a dashed line for the power going to the motor. This panel shows a signal
    at half speed, with the duty cycle on for half the cycle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了PWM信号的图形。顶部是驱动电机以半速的信号。开关脉冲的持续时间相同。*X*轴是级别，*Y*轴是时间，实线是PWM信号，虚线是电机接收的功率。这个面板显示了半速的信号，占空比在周期的一半时开启。
- en: The second graph shows control signals, ranging from 0 to completely on. When
    there are no pulses, this is equivalent to 0\. When it is entirely on with no
    break, this is equivalent to 100%.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图表显示了控制信号，范围从0到完全开启。当没有脉冲时，这相当于0。当它完全开启且没有中断时，这相当于100%。
- en: PWM can be fine-grained, with the bottom graph showing a sine wave along with
    the equivalent PWM signal for this. However, it’s not smooth, as it can only change
    when there is a new pulse, and the levels also have a resolution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: PWM可以是细粒度的，底部图表显示了正弦波以及相应的PWM信号。然而，它并不平滑，因为它只能在有新脉冲时改变，并且级别也有分辨率。
- en: Driving fast and slow
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱动快和慢
- en: 'We can take advantage of this PWM system to drive the robot at different speeds.
    Let’s see how this works on a single wheel in `motors_pwm_drive_slower.py`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个PWM系统来驱动机器人以不同的速度运行。让我们看看在`motors_pwm_drive_slower.py`中的单个轮子上是如何工作的：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we’ve gone back to setting up a pin from the board, but this
    time using `pwmio.PWMOut` instead of `DigitalIO`. We are using the motor `A1`
    pin.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们回到了设置板上的引脚，但这次使用`pwmio.PWMOut`而不是`DigitalIO`。我们正在使用电机`A1`引脚。
- en: We then set `duty_cycle`, the amount of on-time to its highest value. It is
    a 16-bit value, so we use 2 to the power of 16 and subtract 1 – we don’t need
    to do this calculation ourselves and can let the computer do it. This value will
    cause the motor to drive, as before, at full speed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`duty_cycle`设置为最高值。它是一个16位值，所以我们使用2的16次方减去1——我们不需要自己进行这个计算，可以让计算机来做。这个值将使电机以前的速度运行。
- en: The code sleeps and then sets the duty cycle to 2 to the power of 15, half of
    our previous value. The motor will go at 50% speed here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码暂停，然后将`duty_cycle`设置为2的15次方，这是我们之前值的一半。在这里，电机将以50%的速度运行。
- en: We let it run for 0.3 seconds and then set the `duty_cycle` to 0, which will
    turn off the motor. You can experiment with different values, but you may find
    the motor stalls (doesn’t move) and beeps at values lower than half speed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让它运行了0.3秒，然后将`duty_cycle`设置为0，这将关闭电机。你可以尝试不同的值，但可能会发现电机在低于半速的值时会出现卡住（不移动）并发出蜂鸣声。
- en: Adjusting the robot library
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整机器人库
- en: 'We will need to apply changes to our robot library, where we set up motor pins
    as `DigitalIO` pins. We now need to use `PWMOut` to set the pins up. Here is a
    new `robot.py`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将更改应用到我们的机器人库中，其中我们将电机引脚设置为`DigitalIO`引脚。我们现在需要使用`PWMOut`来设置引脚。下面是新的`robot.py`：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code swaps the `Digital IO` setup we used before and uses `PWMOut` instead.
    The `stop` function now sets the pins `duty_cycle` to zero to stop all motor pins.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码交换了我们之前使用的`Digital IO`设置，并使用`PWMOut`。现在，`stop`函数将引脚的`duty_cycle`设置为零以停止所有电机引脚。
- en: 'We can now use this to demonstrate the robot moving in `motors_convert_speed.py`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个来在`motors_convert_speed.py`中演示机器人移动：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use our refreshed `robot` class to set things up in this demonstration. First,
    we set a `max_speed` variable to hold the maximum value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们使用我们更新的`robot`类来设置一些东西。首先，我们设置一个`max_speed`变量来保存最大值。
- en: Having `max_speed` makes things more convenient, as we can then multiply it
    by a fraction between 0 and 1 to get a duty cycle value – here, we set the motor
    to 80% speed for 0.3 seconds and stop. We must use the `int()` function to convert
    the result to an integer (whole number).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有`max_speed`会使事情更加方便，因为我们可以将其乘以介于0和1之间的分数来得到一个占空比值——在这里，我们将电机设置为80%的速度运行0.3秒然后停止。我们必须使用`int()`函数将结果转换为整数（整数）。
- en: 'We can move this multiplication up into the robot library. Add this code after
    the motor pins in `robot.py`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个乘法提升到机器人库中。在`robot.py`中的电机引脚之后添加此代码：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, there is max speed, as seen before, and then two variables to group
    our pins as respective motors. It means we can use pairs of pins, as shown next:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有最大速度，就像之前看到的那样，然后有两个变量来分组我们的引脚作为相应的电机。这意味着我们可以使用下一页所示的引脚对：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function will accept a motor (or pair of pins) as defined previously and
    then a speed between `-1` (going in reverse) and `1` (going forward).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将接受之前定义的电机（或一对引脚）以及一个介于`-1`（反向行驶）和`1`（正向行驶）之间的速度。
- en: It checks whether the speed is negative and, if so, sets a `direction` variable
    with the motor pins swapped and makes the speed positive; otherwise, it just stores
    the current motor pins as a pair in `direction`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查速度是否为负数，如果是，则将电机引脚交换并设置`direction`变量为正速度；否则，它只是将当前的电机引脚作为一对存储在`direction`中。
- en: The next line uses the `min()` function, which returns the minimum of two values.
    Putting in `speed` and `1` will limit the speed to no more than `1.0`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条线使用`min()`函数，该函数返回两个值中的最小值。将`speed`和`1`放入其中将限制速度不超过`1.0`。
- en: We then use the pins stored in the `direction` variable, setting the first pin’s
    `duty_cycle` to the converted speed and the other pin to `0`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用存储在`direction`变量中的引脚，将第一个引脚的`duty_cycle`设置为转换后的速度，而另一个引脚设置为`0`。
- en: 'We can add two more functions on `robot.py` to make this more convenient:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`robot.py`上添加两个更多函数，使其更加方便：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These wrap the `set_speed` function, and they can now be used in your code with
    calls such as `robot.set_left(1.0)` and `robot.set_right(0.8)`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数封装了`set_speed`函数，现在你可以使用如`robot.set_left(1.0)`和`robot.set_right(0.8)`这样的调用在你的代码中使用。
- en: 'Let’s use these and try a few different speeds in `motors_pwm_multispeed.py`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些功能，并在`motors_pwm_multispeed.py`中尝试几种不同的速度：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous example uses a `for` loop, looping over the numbers 5 to 10\. This
    means we get a `speed` variable in each loop. We divide this by 10, so we now
    get 0.5 to 1.0 and use the `robot.set_...` methods to set both motors to this
    `speed`. The program then sleeps for 0.3 seconds and loops to the next item.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用了一个`for`循环，循环遍历5到10的数字。这意味着我们得到每个循环中的`speed`变量。我们将其除以10，因此现在我们得到0.5到1.0，并使用`robot.set_...`方法将两个电机都设置为这个`speed`。然后程序暂停0.3秒，并循环到下一个项目。
- en: It is wrapped in `try…finally` so that the program will always call `robot.stop()`,
    even if something fails in our loop; this ensures that the motors don’t keep driving.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它被`try…finally`结构包裹，这样即使我们的循环中发生错误，程序也会始终调用`robot.stop()`；这确保了电机不会持续驱动。
- en: The robot will start slowly and then speed up and stop when you run this example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个示例时，机器人会慢慢启动，然后加速，最后停止。
- en: We can use the variable motor speeds to make gentle sweeping turns too. Let’s
    see how in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用可变电机速度来做出柔和的、大范围的转向。让我们在下一节中看看如何实现。
- en: Turning while moving
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在移动中转向
- en: 'We can make gentle, sweeping turns by sending different speeds to each motor
    using PWM. For example, look at the following figure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向每个电机发送不同的PWM速度来做出柔和的、大范围的转向。例如，看看下面的图示：
- en: '![Figure 5.7 – Robots making sweeping turns ](img/Figure_5.07_B18001.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 – 机器人进行大范围转向](img/Figure_5.07_B18001.jpg)'
- en: Figure 5.7 – Robots making sweeping turns
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 机器人进行大范围转向
- en: '*Figure 5**.7* shows robots making gentle sweeping turns to the right and the
    left. The speed difference between the motor’s controls where the turn’s pivot
    is. The closer the speeds are, the wider the turn radius is. This is demonstrated
    in `motors_pwm_gentle_turn.py`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.7*显示了机器人向右和向左做出柔和的、大范围的转向。转向轴的电机控制速度之间的差异。速度越接近，转向半径越宽。这可以在`motors_pwm_gentle_turn.py`中演示：'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example uses the same `try…finally` construct as before. It sets the left
    motor to full speed and the right to half speed, making a wide arc to the right
    for half a second. The robot then stops.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用与之前相同的`try…finally`结构。它将左电机设置为全速，右电机设置为半速，向右画出一个宽弧，持续半秒钟。然后机器人停止。
- en: We’ve now seen how to control a robot’s motor speeds with PWM and make different
    turns. Finally, we are ready to put some of this together to make the robot drive
    in a pre-determined path on the floor.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用PWM控制机器人的电机速度并做出不同的转向。最后，我们准备将这些结合起来，使机器人在地板上按照预定的路径行驶。
- en: Driving along a planned path
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿预定路径行驶
- en: We can use our straight-line driving motions and curved turns to make an almost
    square path on the floor. We can use the helper functions we’ve made to keep this
    short.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的直线行驶动作和曲线转向，在地板上形成一个几乎正方形的路径。我们可以使用我们制作的辅助函数来简化这个过程。
- en: Putting line and turn moves together
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将直线和转向动作结合起来
- en: 'We are going to put some of our learning together to make a simple square pattern,
    as the following diagram shows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的学习成果结合起来，制作一个简单的正方形图案，如下面的图示所示：
- en: '![Figure 5.8 – Driving a square path ](img/Figure_5.08_B18001.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 驾驶正方形路径](img/Figure_5.08_B18001.jpg)'
- en: Figure 5.8 – Driving a square path
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 驾驶正方形路径
- en: The figure shows a square made up of four straight lines and four turns. These
    eight instructions are four repeating sets of a straight line and then a turn.
    We will have to adjust the timing of the turn to make it close to 90 degrees.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了一个由四条直线和四个转弯组成的正方形。这八条指令是直线和转弯的四组重复。我们将必须调整转弯的时间，使其接近90度。
- en: 'We start this code with some helpers for our motions – in `pwm_drive_square.py`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`pwm_drive_square.py`中的运动辅助代码开始：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `straight()` function just puts both motors going forward (or back) for
    the duration. The `left()` function stops one motor and drives the other at speed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`straight()`函数只是让两个电机在指定时间内向前（或向后）行驶。`left()`函数停止一个电机，并以速度驱动另一个电机。'
- en: 'We can then use these in a main `for` loop to get the four turns:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这些在主`for`循环中获取四个转弯：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our loop counts four times using the `range()` function. We then use the `straight`
    and `left` functions with speed and duration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`range()`函数计数四次。然后我们使用带有速度和持续时间的`straight`和`left`函数。
- en: Note that the performance of this will vary greatly, depending on how fresh
    the batteries are and which surface you drive on – friction will slow motors down.
    You will likely need to adjust the relative times of the `straight` and `left`
    function uses to try and get a square.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个性能会因电池的新鲜程度和所驾驶的表面而大不相同——摩擦会减慢电机的速度。你可能需要调整`straight`和`left`函数使用的相对时间，以尝试获得一个正方形。
- en: The flaw with driving this way
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这种驾驶方式的缺陷
- en: 'You’ll notice that the path we planned is not quite the plan we got. Even after
    some time adjusting it, you probably got a path like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现我们计划的路径并不完全是我们得到的计划。即使调整了一段时间，你可能得到的路径如下：
- en: '![Figure 5.9 – What your path might look like ](img/Figure_5.09_B18001.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 你的路径可能看起来](img/Figure_5.09_B18001.jpg)'
- en: Figure 5.9 – What your path might look like
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 你的路径可能看起来
- en: '*Figure 5**.9* shows an exaggerated version of what you may have got. Even
    after much tweaking, the robot may have made turns slightly above or below 90
    degrees. The robot may also have veered slightly while making the straight lines.
    In the next chapter, we will pick up our first sensor, the encoders, which can
    be used for more accurate turning and to correct for veer.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.9* 显示了你可能得到的夸张版本。即使经过很多调整，机器人可能仍然会在90度以上或以下轻微转弯。机器人也可能在绘制直线时稍微偏离。在下一章中，我们将选择我们的第一个传感器，编码器，它可以用于更精确的转向和纠正偏离。'
- en: The moment you change surfaces or the batteries degrade, the robot will go off
    course further. Drawing a path like this is a start, but later in the book, we’ll
    see how to use sensors to improve the accuracy of such motion.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你改变表面或电池退化时，机器人会偏离路线更远。绘制这样的路径是一个开始，但在本书的后面，我们将看到如何使用传感器来提高这种运动的精度。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how a controller such as Raspberry Pi Pico uses
    a motor controller to drive motors. We saw how to control motor directions to
    drive in a straight(ish) line or make a robot turn.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用像Raspberry Pi Pico这样的控制器使用电机控制器来驱动电机。我们看到了如何控制电机方向以直线（大致）行驶或使机器人转向。
- en: We then learned about PWM control and how to vary motor speeds, creating a handy
    `robot` Python library for our robot in the process. Next, we used this to make
    sweeping curves and build a multi-step path example with our robot. This path
    code did, however, show up some accuracy shortcomings.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了PWM控制以及如何调整电机速度，在这个过程中创建了一个方便的`robot` Python库，用于我们的机器人。接下来，我们使用这个库制作了扫帚曲线，并使用我们的机器人构建了一个多步骤路径示例。然而，这段路径代码确实暴露了一些精度不足的问题。
- en: We have used time to estimate how much we move our motors. However, motors don’t
    start immediately, and they can sometimes stick. In addition, some motors are
    slower than others. Therefore, we are working only with approximates. In the next
    chapter, we will look at how to measure how much the motors have turned to get
    a more accurate estimation of the robot’s movement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用时间来估计我们移动电机多少。然而，电机不会立即启动，有时它们可能会卡住。此外，一些电机的速度比其他电机慢。因此，我们只使用近似值。在下一章中，我们将探讨如何测量电机的转动量以获得对机器人运动的更准确估计。
- en: Exercises
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Now you’ve had a taste of driving the robot motors, perhaps you can practice
    your skills with the following challenges:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经尝试了驾驶机器人电机，也许你可以通过以下挑战来练习你的技能：
- en: Can you make other shapes with this method, such as a triangle, or, by using
    gentle turns, drive in a circle?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能用这种方法制作其他形状吗，比如三角形，或者通过轻微转弯，在圆形中行驶？
- en: What is the lowest PWM value before the robot stalls on two motors?
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个电机上，机器人卡住之前最低的 PWM 值是多少？
- en: Does the preceding value change on one motor?
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的值是否在一个电机上改变？
- en: How does the robot’s driving behave on a different surface, such as carpet or
    wood?
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人在不同表面上的行驶行为如何，例如地毯或木头？
- en: Further reading
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These additional resources will help you learn more about the concepts covered
    in this chapter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的资源将帮助您了解本章涵盖的概念：
- en: 'A great YouTube video by Afrotechmods shows more about PWM: [https://www.youtube.com/watch?v=YmPziPfaByw](https://www.youtube.com/watch?v=YmPziPfaByw).'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Afrotechmods 制作的一个优秀的 YouTube 视频展示了更多关于 PWM 的内容：[https://www.youtube.com/watch?v=YmPziPfaByw](https://www.youtube.com/watch?v=YmPziPfaByw)。
- en: Sparkfun has an explanation of PWM at [https://learn.sparkfun.com/tutorials/pulse-width-modulation/all](https://learn.sparkfun.com/tutorials/pulse-width-modulation/all)
    where, in addition to its use of motors and servo motors, it shows how you can
    use the technique to control LED brightness.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sparkfun 在 [https://learn.sparkfun.com/tutorials/pulse-width-modulation/all](https://learn.sparkfun.com/tutorials/pulse-width-modulation/all)
    提供了 PWM 的解释，其中除了介绍其在电机和伺服电机中的应用外，还展示了如何使用这项技术来控制 LED 亮度。
- en: Adafruit, the team that created CircuitPython, has a PWM programming tutorial
    at [https://learn.adafruit.com/circuitpython-essentials/circuitpython-pwm](https://learn.adafruit.com/circuitpython-essentials/circuitpython-pwm).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了 CircuitPython 的 Adafruit 团队提供了一个 PWM 编程教程，链接为 [https://learn.adafruit.com/circuitpython-essentials/circuitpython-pwm](https://learn.adafruit.com/circuitpython-essentials/circuitpython-pwm)。
- en: My book *Learn Robotics Programming, Second Edition*, also published by Packt,
    has a chapter covering motor steering mechanisms, including the one seen here,
    with Python code for Raspberry Pi.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的书 *《学习机器人编程，第二版》*，由 Packt 出版，其中有一章涵盖了电机转向机制，包括这里看到的，以及用于 Raspberry Pi 的 Python
    代码。
- en: 'Part 2: Interfacing Raspberry Pi Pico with Simple Sensors and Outputs'
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：使用简单传感器和输出与 Raspberry Pi Pico 接口
- en: In this part, we will build upon the basic Raspberry Pi Pico knowledge, adding
    more complicated devices and code to interface them. We will see how sensors can
    interface our robot more with the real world. We will add Bluetooth LE to link
    with a computer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将基于基本的 Raspberry Pi Pico 知识，添加更复杂的设备和代码来与之接口。我们将看到传感器如何使我们的机器人与真实世界更加紧密地连接。我们将添加蓝牙低功耗（BLE）来与电脑连接。
- en: 'This part contains the following chapters:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), *Measuring Movement with Encoders
    on Raspberry Pi Pico*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18001_06.xhtml#_idTextAnchor115)，*使用 Raspberry Pi Pico 上的编码器测量运动*'
- en: '[*Chapter 7*](B18001_07.xhtml#_idTextAnchor139), *Planning and Shopping for
    More Devices*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18001_07.xhtml#_idTextAnchor139)，*规划和采购更多设备*'
- en: '[*Chapter 8*](B18001_08.xhtml#_idTextAnchor166), *Sensing Distances to Detect
    Objects with Pico*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18001_08.xhtml#_idTextAnchor166)，*使用 Pico 检测距离以检测物体*'
- en: '[*Chapter 9*](B18001_09.xhtml#_idTextAnchor189), *Teleoperating a Raspberry
    Pi Pico Robot with Bluetooth LE*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18001_09.xhtml#_idTextAnchor189)，*使用蓝牙低功耗（BLE）远程控制 Raspberry Pi Pico
    机器人*'
