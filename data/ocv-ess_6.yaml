- en: Chapter 6. Where's Wally? Object Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。沃尔在哪里？目标检测
- en: This chapter explains how to use the different options included in the OpenCV
    object detection module. With the sample code included, it is possible to use
    Cascade and Latent SVM detectors as well as create custom cascade detectors for
    a specific object detection application. Additionally, the new Scene Text Detector
    included in OpenCV 3 is explained in the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何使用OpenCV目标检测模块中包含的不同选项。通过包含的示例代码，可以使用级联和潜在SVM检测器，以及为特定目标检测应用创建自定义级联检测器。此外，本章还解释了OpenCV
    3中包含的新场景文本检测器。
- en: Object detection
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标检测
- en: Object detection deals with the process of locating instances of a certain class
    of real-world objects, such as faces, cars, pedestrians, and buildings in images
    or videos. Detection algorithms typically start by extracting features from two
    sets of images. One of these sets contains images from the desired object and
    the other one contains background images where the searched object is not present.
    Then, the detector is trained based on these features to recognize future instances
    of the object class.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目标检测处理的是在图像或视频中定位现实世界对象某一类实例的过程，例如人脸、汽车、行人和建筑物。检测算法通常首先从两组图像中提取特征。其中一组包含目标图像，另一组包含背景图像，其中搜索的对象不存在。然后，基于这些特征对这些检测器进行训练，以识别对象类未来的实例。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Fingerprint recognition, now included in some laptops and smartphones, or face
    detection, seen in most digital cameras, are everyday examples of object detection
    applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 指纹识别，现在被集成在一些笔记本电脑和智能手机中，或者大多数数码相机中常见的面部检测，都是目标检测应用的日常例子。
- en: Detecting objects with OpenCV
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV进行对象检测
- en: OpenCV has a number of object detection algorithms implemented in its `objdetect`
    module. In this module, Cascade and Latent SVM detectors are implemented together
    with the new Scene Text Detector added in OpenCV 3\. All of these algorithms are
    relatively efficient and obtain accurate results.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV在其`objdetect`模块中实现了多种目标检测算法。在这个模块中，实现了级联和潜在SVM检测器，以及OpenCV 3中新增的场景文本检测器。所有这些算法都相对高效，并能获得准确的结果。
- en: Cascades are beautiful
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级联很美
- en: Most objects' detection problems, such as face/person detection or lesion detection
    in medicine, require searching for the object in many image patches. However,
    examining all image zones and computing the feature set for each zone are time-consuming
    tasks. Cascade detectors are widely used because of their high efficiency in doing
    this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数目标检测问题，如人脸/人体检测或医学中的病变检测，都需要在许多图像块中搜索目标。然而，检查所有图像区域并为每个区域计算特征集都是耗时的任务。级联检测器因其在此方面的效率高而得到广泛应用。
- en: Cascade detectors consist of various boosting stages. The boosting algorithm
    selects the best feature set to create and combine a number of weak tree classifiers.
    Thus, boosting is not only a detector but also a feature selection method. Each
    stage is usually trained to detect nearly 100 percent of objects correctly and
    discard at least 50 percent of the background images. Therefore, background images,
    which represent a larger number of images, need less processing time as they are
    discarded at the early stages of the cascade. Moreover, the concluding cascade
    stages use more features than earlier stages, and even then only objects and difficult
    background images require more time to be evaluated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 级联检测器由各种提升阶段组成。提升算法选择最佳特征集来创建和组合多个弱树分类器。因此，提升不仅是一个检测器，也是一种特征选择方法。每个阶段通常训练以正确检测近100%的对象并丢弃至少50%的背景图像。因此，背景图像，代表更多的图像，在级联的早期阶段被丢弃时需要更少的时间处理。此外，最终的级联阶段使用比早期阶段更多的特征，即使如此，只有目标和难以识别的背景图像需要更多的时间来评估。
- en: Discrete AdaBoost (Adaptive Boosting), Real AdaBoost, Gentle AdaBoost, and LogitBoost
    are all implemented in OpenCV as boosting stages. On the other hand, it is possible
    to use Haar-like, **Local Binary Patterns** (**LBP**) and **Histograms of Oriented
    Gradients** (**HOG**) features together with the different boosting algorithms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 离散AdaBoost（自适应提升）、真实AdaBoost、温和AdaBoost和LogitBoost都在OpenCV中作为提升阶段实现。另一方面，可以使用Haar-like、**局部二值模式**（**LBP**）和**方向梯度直方图**（**HOG**）特征与不同的提升算法一起使用。
- en: All these advantages and available techniques make cascades very useful for
    building practical detection applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些优点和可用技术使级联在构建实用检测应用方面非常有用。
- en: Object detection using cascades
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用级联进行目标检测
- en: 'OpenCV comes with several pretrained cascade detectors for the most common
    detection problems. They are located under the `OPENCV_SOURCE\data` directory.
    The following is a list of some of them and their corresponding subdirectories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV附带了一些预训练的级联检测器，用于最常见的检测问题。它们位于`OPENCV_SOURCE\data`目录下。以下是一些及其对应的子目录列表：
- en: 'Subdirectory `haarcascades`:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '子目录 `haarcascades`:'
- en: '`haarcascade_frontalface_default.xml`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haarcascade_frontalface_default.xml`'
- en: '`haarcascade_eye.xml`'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haarcascade_eye.xml`'
- en: '`haarcascade_mcs_nose.xml`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haarcascade_mcs_nose.xml`'
- en: '`haarcascade_mcs_mouth.xml`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haarcascade_mcs_mouth.xml`'
- en: '`haarcascade_upperbody.xml`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haarcascade_upperbody.xml`'
- en: '`haarcascade_lowerbody.xml`'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haarcascade_lowerbody.xml`'
- en: '`haarcascade_fullbody.xml`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haarcascade_fullbody.xml`'
- en: 'Subdirectory `lbpcascades`:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '子目录 `lbpcascades`:'
- en: '`lbpcascade_frontalface.xml`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lbpcascade_frontalface.xml`'
- en: '`lbpcascade_profileface.xml`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lbpcascade_profileface.xml`'
- en: '`lbpcascade_silverware.xml`'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lbpcascade_silverware.xml`'
- en: 'Subdirectory `hogcascades`:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '子目录 `hogcascades`:'
- en: '`hogcascade_pedestrians.xml`'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hogcascade_pedestrians.xml`'
- en: 'The following `pedestrianDetection` example serves to illustrate how to use
    a cascade detector and localize pedestrians in a video file with OpenCV:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`pedestrianDetection`示例用于说明如何使用级联检测器并在OpenCV的视频文件中定位行人：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code explanation is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码说明如下：
- en: '`CascadeClassifier`: This class provides all the methods needed when working
    with cascades. An object from this class represents a trained cascade detector.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CascadeClassifier`: 此类提供在处理级联时所需的所有方法。此类的一个对象代表一个训练好的级联检测器。'
- en: '`constructor CascadeClassifier:: CascadeClassifier(const string& filename)`:
    This class initializes the object instance and loads the information of the cascade
    detector stored in the system file indicated by the variable `filename`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor CascadeClassifier:: CascadeClassifier(const string& filename)`:
    此类初始化对象实例并加载存储在系统文件中由变量`filename`指示的级联检测器的信息。'
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the method `bool CascadeClassifier::load(const string& filename)`
    is actually called implicitly after the constructor.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，方法 `bool CascadeClassifier::load(const string& filename)` 实际上在构造函数之后隐式调用。
- en: '`bool CascadeClassifier:: empty()`: This method checks if a cascade detector
    has been loaded.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool CascadeClassifier:: empty()`: 此方法检查级联检测器是否已加载。'
- en: '`cvtColor` and `equalizeHist`: These methods are required for image grayscale
    conversion and equalization. Since the cascade detector is trained with grayscale
    images and input images can be in different formats, it is necessary to convert
    them to the correct color space and equalize their histograms in order to obtain
    better results. This is done by the following code that uses the `cvtColor` and
    `equalizeHist` functions:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cvtColor`和`equalizeHist`：这些方法用于图像灰度转换和直方图均衡。由于级联检测器是用灰度图像训练的，而输入图像可以有不同的格式，因此需要将它们转换为正确的颜色空间并均衡它们的直方图，以获得更好的结果。这是通过以下使用`cvtColor`和`equalizeHist`函数的代码完成的：'
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`void CascadeClassifier::detectMultiScale(const Mat& image, vector<Rect>& objects,
    double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(),
    Size maxSize=Size())`: This method examines the image in the `image` variable
    applying the loaded cascade and insert all detected objects in `objects`. Detections
    are stored in a vector of rectangles of type `Rect`. The parameters `scaleFactor`
    and `minNeighbors` indicates how much the image size is reduced at each image
    scale considered and the minimum number of neighbors that indicate a positive
    detection. Detections are bound by the minimum and maximum sizes, indicated by
    `minSize` and `maxSize`. Finally, the parameter `flags` is not used when using
    cascades created with `opencv_traincascade`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void CascadeClassifier::detectMultiScale(const Mat& image, vector<Rect>& objects,
    double scaleFactor=1.1, int minNeighbors=3, int flags=0, Size minSize=Size(),
    Size maxSize=Size())`: 此方法检查`image`变量中的图像，应用加载的级联，并将所有检测到的对象插入到`objects`中。检测结果存储在类型为`Rect`的矩形向量中。参数`scaleFactor`和`minNeighbors`表示在考虑的每个图像缩放级别中图像大小减少的程度以及指示正检测的最小邻居数。检测受`minSize`和`maxSize`指示的最小和最大尺寸限制。最后，当使用用`opencv_traincascade`创建的级联时，参数`flags`不使用。'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: After obtaining the vector that stores the detected objects, it is easy to show
    them over the original images by reading the coordinates of each rectangle, represented
    by objects of the class `Rect`, and drawing a polygon in the indicated zones.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在获得存储检测对象的向量后，通过读取每个矩形（由`Rect`类的对象表示）的坐标，很容易在原始图像上显示它们，并在指定的区域绘制多边形。
- en: The following screenshot shows the result of applying the `hogcascade_pedestrians.xml`
    pretrained HOG-based pedestrian detector over the frames of the `768x576.avi`
    video, which is stored in the `OPENCV_SCR/samples` folder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了将基于HOG的预训练行人检测器`hogcascade_pedestrians.xml`应用于`768x576.avi`视频帧的结果，该视频存储在`OPENCV_SCR/samples`文件夹中。
- en: '![Object detection using cascades](img/00038.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![使用级联进行目标检测](img/00038.jpeg)'
- en: Pedestrian detection using the OpenCV-trained HOG cascade detector
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV训练的HOG级联检测器进行行人检测
- en: There are several projects and contributions to the OpenCV community that solve
    other detection-related problems that involve not only detecting the object but
    also distinguishing its state. One example of this type of detectors is the smile
    detector included in OpenCV since Version 2.4.4\. The code can be found in the
    file `OPENCV_SCR/samples/c/smiledetect.cpp`, and the XML that stores the cascade
    detector, `haarcascade_smile.xml`, can be found in `OPENCV_SCR/data/haarcascades`.
    This code first detects the frontal face using the pretrained cascade stored in
    `haarcascade_frontalface_alt.xml` and then detects the smiling mouth pattern at
    the bottom part of the image. Finally, the intensity of the smile is calculated
    based on the number of neighbors detected.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个项目和贡献解决了OpenCV社区中的其他检测相关的问题，这些问题不仅涉及检测对象，还包括区分其状态。这类检测器的一个例子是自版本2.4.4以来包含在OpenCV中的微笑检测器。代码可以在文件`OPENCV_SCR/samples/c/smiledetect.cpp`中找到，存储级联检测器的XML文件`haarcascade_smile.xml`可以在`OPENCV_SCR/data/haarcascades`中找到。此代码首先使用存储在`haarcascade_frontalface_alt.xml`中的预训练级联检测正面人脸，然后检测图像底部部分的微笑嘴部模式。最后，根据检测到的邻居数量计算微笑的强度。
- en: Training your own cascade
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练自己的级联
- en: 'Although OpenCV provides pretrained cascades, in some cases it is necessary
    to train a cascade detector to look for a specific object. For these cases, OpenCV
    comes with tools to help train a cascade, generating all the data needed during
    the training process and the final files with the detector information. These
    are usually stored in the `OPENCV_BUILD\install\x64\mingw\bin` directory. Some
    of the applications are listed as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OpenCV提供了预训练的级联，但在某些情况下，有必要训练一个级联检测器来寻找特定的对象。对于这些情况，OpenCV附带了一些工具来帮助训练级联，生成训练过程中所需的所有数据以及包含检测器信息的最终文件。这些文件通常存储在`OPENCV_BUILD\install\x64\mingw\bin`目录中。以下是一些应用程序的列表：
- en: '`opencv_haartraining`: This application is historically the first version of
    the application for creating cascades.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opencv_haartraining`：这个应用程序在历史上是创建级联的第一个版本。'
- en: '`opencv_traincascade`: This application is the latest version of the application
    for creating cascades.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opencv_traincascade`：这个应用程序是创建级联应用程序的最新版本。'
- en: '`opencv_createsamples`: This application is used to create the `.vec` file
    with the images that contain instances of the object. The file generated is accepted
    by both the preceding training executables.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opencv_createsamples`：这个应用程序用于创建包含对象实例的图像的`.vec`文件。生成的文件被前面的训练可执行文件接受。'
- en: '`opencv_performance`: This application may be used to evaluate a cascade trained
    with the `opencv_haartraining` tool. It uses a set of marked images to obtain
    information about the evaluation, for example, the false alarm or the detection
    rates.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opencv_performance`：这个应用程序可以用来评估使用`opencv_haartraining`工具训练的级联。它使用一组标记的图像来获取评估信息，例如误报或检测率。'
- en: Since `opencv_haartraining` is the older version of the program and it comes
    with fewer features than `opencv_traincascade`, only the latter will be described
    here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`opencv_haartraining`是较老版本的程序，并且它比`opencv_traincascade`具有更少的功能，因此这里只描述后者。
- en: 'Here, the cascade training process is explained using the MIT CBCL face database.
    This database contains face and background images of 19 x 19 pixels arranged as
    shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用MIT CBCL人脸数据库解释级联训练过程。该数据库包含19 x 19像素的人脸和背景图像，排列方式如以下截图所示：
- en: '![Training your own cascade](img/00039.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![训练自己的级联](img/00039.jpeg)'
- en: Image file organization
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图片文件组织
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This section explains the training process on Windows. For Linux and Mac OS
    X, the process is similar but takes into account the specific aspects of the operating
    system. More information on training cascade detectors in Linux and Mac OS X can
    be found at [http://opencvuser.blogspot.co.uk/2011/08/creating-haar-cascade-classifier-aka.html](http://opencvuser.blogspot.co.uk/2011/08/creating-haar-cascade-classifier-aka.html)
    and [http://kaflurbaleen.blogspot.co.uk/2012/11/how-to-train-your-classifier-on-mac.html](http://kaflurbaleen.blogspot.co.uk/2012/11/how-to-train-your-classifier-on-mac.html)
    respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了在 Windows 上的训练过程。对于 Linux 和 Mac OS X，过程类似，但会考虑操作系统的特定方面。有关在 Linux 和 Mac
    OS X 上训练级联检测器的更多信息，请参阅 [http://opencvuser.blogspot.co.uk/2011/08/creating-haar-cascade-classifier-aka.html](http://opencvuser.blogspot.co.uk/2011/08/creating-haar-cascade-classifier-aka.html)
    和 [http://kaflurbaleen.blogspot.co.uk/2012/11/how-to-train-your-classifier-on-mac.html](http://kaflurbaleen.blogspot.co.uk/2012/11/how-to-train-your-classifier-on-mac.html)。
- en: 'The training process involves the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 训练过程包括以下步骤：
- en: '**Setting the current directory**: In the **Command Prompt** window, set the
    current directory to the directory in which training images are stored. For example,
    if the directory is `C:\chapter6\images`, use the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置当前目录**：在 **命令提示符** 窗口中，将当前目录设置为存储训练图像的目录。例如，如果目录是 `C:\chapter6\images`，则使用以下命令：'
- en: '[PRE2]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Creating the background images information text file**: If background images
    are stored in `C:\chapter6\images\train\non-face` and their format is `.pgm`,
    it is possible to create the text file required by OpenCV using the following
    command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建背景图像信息文本文件**：如果背景图像存储在 `C:\chapter6\images\train\non-face` 且其格式为 `.pgm`，则可以使用以下命令创建
    OpenCV 所需的文本文件：'
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the contents of the background image information
    file. This file contains the path of the background images:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了背景图像信息文件的内容。此文件包含背景图像的路径：
- en: '![Training your own cascade](img/00040.jpeg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![训练自己的级联](img/00040.jpeg)'
- en: Background images information file
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 背景图像信息文件
- en: '**Creating the object images file:** This involves the following two steps:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建目标图像文件**：这涉及以下两个步骤：'
- en: Creating the `.dat` file with the object coordinates. In this particular database,
    object images only contain one instance of the object and it is located in the
    center of the image and scaled to occupy the entire image. Therefore, the number
    of objects per image is 1 and the object coordinates are `0 0 19 19`, which are
    the initial point and the width and height of the rectangle that contains the
    object.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含目标坐标的 `.dat` 文件。在此特定数据库中，目标图像仅包含一个目标实例，且位于图像中心，并缩放以占据整个图像。因此，每张图像中的目标数量为
    1，目标坐标为 `0 0 19 19`，这是包含目标的矩形的初始点以及宽度和高度。
- en: 'If object images are stored in `C:\chapter6\images\train\face`, it is possible
    to use the following command to generate the file:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果目标图像存储在 `C:\chapter6\images\train\face`，则可以使用以下命令生成文件：
- en: '[PRE4]'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The content of the `.dat` file can be seen in the following screenshot:'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.dat` 文件的内容可以在以下截图中看到：'
- en: '![Training your own cascade](img/00041.jpeg)'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![训练自己的级联](img/00041.jpeg)'
- en: Object images file
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标图像文件
- en: 'After creating the `.dat` file with the object coordinates, it is necessary
    to create the `.vec` file that is needed by OpenCV. This step can be performed
    using the `opencv_createsamples` program with the arguments `–info` (`.dat` file);
    `-vec` (`.vec` output file name); `-num` (number of images); `-w` and `–h` (output
    image width and height); and `–maxxangle`, `-maxyangle`, and `-maxzangle` (image
    rotation angles). To see more options, execute `opencv_createsamples` without
    arguments. In this case, the command used is:'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建包含目标坐标的 `.dat` 文件后，需要创建 OpenCV 所需的 `.vec` 文件。此步骤可以使用 `opencv_createsamples`
    程序执行，并使用以下参数：`–info`（`.dat` 文件）；`-vec`（`.vec` 输出文件名）；`-num`（图像数量）；`-w` 和 `–h`（输出图像宽度和高度）；以及
    `–maxxangle`、`-maxyangle` 和 `-maxzangle`（图像旋转角度）。要查看更多选项，请不带参数执行 `opencv_createsamples`。在这种情况下，使用的命令如下：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: OpenCV includes a sample `.vec` file with facial images of size 24 x 24 pixels.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenCV 包含一个大小为 24 x 24 像素的样本 `.vec` 文件，包含面部图像。
- en: '**Training the cascade**: Finally, use the `opencv_traincascade` executable
    and train the cascade detector. The command used in this case is:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**训练级联**：最后，使用 `opencv_traincascade` 可执行文件并训练级联检测器。在这种情况下使用的命令如下：'
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The arguments indicate the output directory (`-data`), the `.vec` file (`-vec`),
    the background information file (`-bg`), the number of positive and negative images
    to train each stage (`-numPos` and `–numNeg`), the maximum number of stages (`-numStages`),
    and the width and height of the images (`-w` and `–h`).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数表示输出目录（`-data`）、`.vec` 文件（`-vec`）、背景信息文件（`-bg`）、每个阶段训练的正负图像数量（`-numPos` 和
    `–numNeg`）、最大阶段数（`-numStages`）以及图像的宽度和高度（`-w` 和 `–h`）。
- en: 'The output of the training process is:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 训练过程的输出如下：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, the XML files of the cascade are stored in the output directory. These
    files are `cascade.xml`, `params.xml`, and a set of `stageX.xml` files where `X`
    is the stage number.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，级联的 XML 文件存储在输出目录中。这些文件是 `cascade.xml`、`params.xml` 和一系列 `stageX.xml` 文件，其中
    `X` 是阶段号。
- en: Latent SVM
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Latent SVM
- en: Latent SVM is a detector that uses HOG features and a star-structured, part-based
    model consisting of a root filter and a set of part filters to represent an object
    category. HOGs are feature descriptors that are obtained by counting the occurrences
    of gradient orientations in localized portions of an image. On the other hand,
    a variant of **support vector machines** (**SVM**) classifiers are used in this
    detector to train models using partially labeled data. The basic idea of an SVM
    is constructing a hyperplane or set of hyperplanes in high-dimensional space.
    These hyperplanes are obtained to have the largest distance to the nearest training
    data point (functional margin in order to achieve low generalization errors).
    Like cascade detectors, Latent SVM uses a sliding window with different initial
    positions and scales where the algorithm is applied in order to detect if there
    is an object inside.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Latent SVM 是一种使用 HOG 特征和由根滤波器以及一系列部分滤波器组成的星形结构、基于部分模型的检测器，用于表示一个对象类别。HOGs 是通过计算图像局部区域中梯度方向出现的频率而获得的特征描述符。另一方面，在这个检测器中使用了
    **支持向量机**（**SVM**）分类器的变体，用于使用部分标记的数据训练模型。SVM 的基本思想是在高维空间中构建一个或多个超平面。这些超平面被用来具有最大的距离到最近的训练数据点（功能间隔以实现低泛化误差）。像级联检测器一样，Latent
    SVM 使用一个滑动窗口，具有不同的初始位置和尺度，算法应用于检测窗口内是否存在对象。
- en: One of the advantages of the OpenCV Latent SVM implementation is that it allows
    the detection of multiple object categories by combining several simple pretrained
    detectors within the same multiobject detector instance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV Latent SVM 实现的一个优点是它允许通过在同一多对象检测器实例中结合几个简单的预训练检测器来检测多个对象类别。
- en: 'The following `latentDetection` example illustrates how to use a Latent SVM
    detector for localizing objects from a category in an image:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `latentDetection` 示例说明了如何使用 Latent SVM 检测器从图像中定位某一类别的对象：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code explanation is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解释如下：
- en: '`LatentSvmDetector`: This class has an object that represents a Latent SVM
    detector composed of one or more pretrained detectors.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LatentSvmDetector`: 此类有一个对象，代表由一个或多个预训练检测器组成的 Latent SVM 检测器。'
- en: '`constructor LatentSvmDetector::LatentSvmDetector(const vector<String>& filenames,
    const vector<string>& classNames=vector<String>())`: This class initializes the
    object instance and loads the information of the detectors stored in the system
    paths indicated by the vector `filenames`. The second parameter, the vector `classNames`,
    contains the category names. The method `bool LatentSvmDetector::load(const vector<string>&
    filenames, const vector<string>& classNames=vector<string>())` is called implicitly
    after the constructor.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor LatentSvmDetector::LatentSvmDetector(const vector<String>& filenames,
    const vector<string>& classNames=vector<String>())`: 此类初始化对象实例并加载存储在系统路径中由向量 `filenames`
    指示的检测器信息。第二个参数，向量 `classNames` 包含类别名称。构造函数之后隐式调用方法 `bool LatentSvmDetector::load(const
    vector<string>& filenames, const vector<string>& classNames=vector<string>())`。'
- en: '`void LatentSvmDetector::detect(const Mat& image, vector<ObjectDetection>&
    objectDetections, float overlapThreshold = 0.5f, int numThreads = -1)`: This method
    examines the image in the variable `image` by applying the simple or combined
    detector on it and puts all detected objects in `objectDetections`. All detections
    are stored in a vector of the `ObjectDetection` struct. This structure has the
    following three variables:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void LatentSvmDetector::detect(const Mat& image, vector<ObjectDetection>&
    objectDetections, float overlapThreshold = 0.5f, int numThreads = -1)`: 此方法通过在变量
    `image` 上应用简单或组合检测器来检查图像，并将所有检测到的对象放入 `objectDetections`。所有检测都存储在 `ObjectDetection`
    结构体的向量中。此结构体有以下三个变量：'
- en: The bounding box of the detection (`rect`)
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测到的边界框（`rect`）
- en: The confidence level (`score`)
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信度水平（`score`）
- en: The category ID (`classID`)
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别ID（`classID`）
- en: The parameter `overlapThreshold` is the threshold for the non-maximum suppression
    algorithm for eliminating overlapped detections. Finally, `numThreads` is the
    number of threads used in the parallel version of the algorithm.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数`overlapThreshold`是非最大值抑制算法用于消除重叠检测的阈值。最后，`numThreads`是算法并行版本中使用的线程数。
- en: 'The following screenshot shows a cat detected using the previous code and the
    files `cat.xml` and `cat.png`, and cars detected using `car.xml` and `cars.png`.
    These files are included in the OpenCV extra data that can be found in the official
    repository. Thus, it is possible to run the program using the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用之前的代码和文件`cat.xml`和`cat.png`检测到的猫，以及使用`car.xml`和`cars.png`检测到的汽车。这些文件包含在OpenCV额外数据中，可以在官方仓库中找到。因此，可以使用以下命令运行程序：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous command, `xmlfile` is the Latent SVM detector and `imagefile`
    is the image that has to be examined.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，`xmlfile`是潜在SVM检测器，`imagefile`是要检查的图像。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenCV extra data provides more samples and test files that can be used by users
    to create and test their own projects while saving time. It can be found at [https://github.com/Itseez/opencv_extra](https://github.com/Itseez/opencv_extra).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV额外数据提供了更多样本和测试文件，用户可以使用这些文件创建和测试自己的项目，同时节省时间。可以在[https://github.com/Itseez/opencv_extra](https://github.com/Itseez/opencv_extra)找到。
- en: 'In addition to the car and cat detectors, OpenCV provides pretrained detectors
    for the rest of the classes defined in *The PASCAL Visual Object Classes Challenge
    2007* ([http://pascallin.ecs.soton.ac.uk/challenges/VOC/voc2007](http://pascallin.ecs.soton.ac.uk/challenges/VOC/voc2007)).
    These detectors are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了汽车和猫检测器之外，OpenCV还为*2007年PASCAL视觉对象类别挑战赛*中定义的其他类别提供了预训练的检测器([http://pascallin.ecs.soton.ac.uk/challenges/VOC/voc2007](http://pascallin.ecs.soton.ac.uk/challenges/VOC/voc2007))。以下是一些检测器：
- en: '`aeroplane.xml`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aeroplane.xml`'
- en: '`bicycle.xml`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bicycle.xml`'
- en: '`bird.xml`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bird.xml`'
- en: '`boat.xml`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boat.xml`'
- en: '`bottle.xml`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottle.xml`'
- en: '`bus.xml`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bus.xml`'
- en: '`car.xml`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`car.xml`'
- en: '`cat.xml`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat.xml`'
- en: '`chair.xml`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chair.xml`'
- en: '`cow.xml`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cow.xml`'
- en: '`diningtable.xml`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`diningtable.xml`'
- en: '`dog.xml`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dog.xml`'
- en: '`horse.xml`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horse.xml`'
- en: '`motorbike.xml`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motorbike.xml`'
- en: '`person.xml`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person.xml`'
- en: '`pottedplant.xml`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pottedplant.xml`'
- en: '`sheep.xml`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sheep.xml`'
- en: '`sofa.xml`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sofa.xml`'
- en: '`train.xml`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train.xml`'
- en: '`tvmonitor.xml`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tvmonitor.xml`'
- en: '![Latent SVM](img/00042.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![潜在SVM](img/00042.jpeg)'
- en: The detection of a cat and some cars using Latent SVM
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用潜在SVM检测到的猫和一些汽车
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The false positive rate can be adjusted by changing the value of the `overlapThreshold`
    parameter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过更改`overlapThreshold`参数的值来调整误报率。
- en: Scene text detection
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景文本检测
- en: 'The scene text detection algorithm builds a component tree of an image by thresholding
    it step-by-step from 0 to 255\. To enhance the results, this process is done for
    each color channel, intensity, and gradient magnitude images. After that, the
    connected components obtained from successive levels are hierarchically organized
    depending on their inclusion relationship as shown in the following diagram. This
    tree organization may contain a huge number of regions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 场景文本检测算法通过逐步从0到255对图像进行阈值处理来构建图像的组件树。为了增强结果，这个过程对每个颜色通道、强度和梯度幅度图像都进行了处理。之后，从连续级别获得的连通组件根据它们的包含关系进行分层组织，如下所示图所示。这种树状组织可能包含大量的区域：
- en: '![Scene text detection](img/00043.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![场景文本检测](img/00043.jpeg)'
- en: Tree organization example
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 树状组织示例
- en: Thus, the algorithm selects some regions following two stages. Firstly, area,
    perimeter, bounding box, and Euler number descriptors are computed for each region
    and used in order to estimate the class-condition probability. External regions
    with local maximum probabilities are selected if their values are above a global
    limit and the difference between their local maximum and minimum is also above
    a specified limit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，算法在两个阶段之后选择了一些区域。首先，为每个区域计算面积、周长、边界框和欧拉数描述符，并按顺序使用它们来估计类条件概率。如果外部区域的局部最大概率值高于全局限制，并且它们的局部最大值和最小值之间的差异也高于指定的限制，则选择具有局部最大概率的外部区域。
- en: The second stage consists of classifying the external regions selected in the
    first stage into character and non-character classes using whole area ratio, convex
    hull ratio, and the number of outer boundary inflexion points as features.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段包括将第一阶段选定的外部区域根据整个区域比率、凸包比率和外边界拐点数量作为特征分类为字符和非字符类别。
- en: Finally, the external regions selected are grouped to obtain words, lines, or
    paragraphs. This part of the algorithm uses a perceptual-organization-based clustering
    analysis.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，选定的外部区域被分组以获得单词、行或段落。算法的这一部分使用基于感知组织的聚类分析。
- en: 'The following `textDetection` example illustrates how to use the Scene Text
    Detection algorithm and localize text in an image:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `textDetection` 示例说明了如何使用场景文本检测算法并在图像中定位文本：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code explanation is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码说明如下：
- en: '`void computeNMChannels(InputArray _src, OutputArrayOfArrays _channels, int
    _mode=ERFILTER_NM_RGBLGrad)`: This function computes different channels from the
    image in `_src` to be processed independently in order to obtain high localization
    recall. These channels are red (`R`), green (`G`), blue (`B`), lightness (`L`),
    and gradient magnitude (∇) by default (`_mode=ERFILTER_NM_RGBLGrad`), it is intensity
    (I), hue (H), saturation (S), and gradient magnitude (∇) if `_mode=ERFILTER_NM_IHSGrad`.
    Finally, the computed channels are saved in the `_channels` parameter.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void computeNMChannels(InputArray _src, OutputArrayOfArrays _channels, int
    _mode=ERFILTER_NM_RGBLGrad)`: 这个函数从 `_src` 图像中计算不同的通道，以便独立处理以获得高定位召回率。默认情况下（`_mode=ERFILTER_NM_RGBLGrad`），这些通道是红色（`R`）、绿色（`G`）、蓝色（`B`）、亮度（`L`）和梯度幅度（∇），如果
    `_mode=ERFILTER_NM_IHSGrad`，则是强度（I）、色调（H）、饱和度（S）和梯度幅度（∇）。最后，计算出的通道保存在 `_channels`
    参数中。'
- en: '`Ptr<ERFilter> createERFilterNM1(const Ptr<ERFilter::Callback>& cb, int thresholdDelta
    = 1, float minArea = 0.00025, float maxArea = 0.13, float minProbability = 0.4,
    bool nonMaxSuppression = true, float minProbabilityDiff = 0.1)`: This function
    creates an Extremal Region Filter for the classifier of the first stage defined
    by the algorithm. The first parameter loads the classifier by means of the function
    `loadClassifierNM1(const std::string& filename)`. The `thresholdDelta` variable
    indicates the threshold step during the component tree obtaining process. The
    parameters `minArea` and `maxArea` establish the percentages of the image size
    between which external regions are retrieved. The value of the `bool` parameter
    `nonMaxSuppression` is `true` when non-maximum suppression is applied over the
    branch probabilities, and `false` otherwise. Finally, the `minProbability` and
    `minProbabilityDiff` parameters control the minimum probability value and the
    minimum probability difference between local maxima and minima values allowed
    for retrieving an external region.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ptr<ERFilter> createERFilterNM1(const Ptr<ERFilter::Callback>& cb, int thresholdDelta
    = 1, float minArea = 0.00025, float maxArea = 0.13, float minProbability = 0.4,
    bool nonMaxSuppression = true, float minProbabilityDiff = 0.1)`: 这个函数创建了一个用于算法定义的第一阶段分类器的极值区域过滤器。第一个参数通过函数
    `loadClassifierNM1(const std::string& filename)` 加载分类器。`thresholdDelta` 变量指示在组件树获取过程中的阈值步长。参数
    `minArea` 和 `maxArea` 建立了外部区域检索的图像大小百分比。当在分支概率上应用非最大值抑制时，布尔参数 `nonMaxSuppression`
    的值为 `true`，否则为 `false`。最后，`minProbability` 和 `minProbabilityDiff` 参数控制检索外部区域允许的最小概率值和最大值与最小值之间的最小概率差异。'
- en: '`Ptr<ERFilter> createERFilterNM2(const Ptr<ERFilter::Callback>& cb, float minProbability
    = 0.3)`: This function creates an External Region Filter for the classifier of
    the second stage defined by the algorithm. The first parameter loads the classifier
    by means of the function `loadClassifierNM2(const std::string& filename)`. The
    other parameter, `minProbability`, is the minimum probability allowed for retrieved
    external regions.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ptr<ERFilter> createERFilterNM2(const Ptr<ERFilter::Callback>& cb, float minProbability
    = 0.3)`: 这个函数创建了一个用于算法定义的第二阶段分类器的外部区域过滤器。第一个参数通过函数 `loadClassifierNM2(const std::string&
    filename)` 加载分类器。其他参数 `minProbability` 是允许检索外部区域的最小概率。'
- en: '`void ERFilter::run( InputArray image, std::vector<ERStat>& regions)`: This
    method applies the cascade classifier loaded by the filter to obtain the external
    regions either in the first or the second level. The `image` parameter is the
    channel that has to be examined and `regions` is a vector with the output of the
    first stage and also the input/output of the second one.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void ERFilter::run( InputArray image, std::vector<ERStat>& regions)`: 这个方法将过滤器加载的级联分类器应用于获取第一级或第二级的外部区域。`image`
    参数是需要检查的通道，`regions` 是第一阶段的输出以及第二阶段的输入/输出。'
- en: '`void erGrouping(InputArrayOfArrays src, std::vector<std::vector<ERStat>>&
    regions, const std::string& filename, float minProbability, std::vector<Rect>&
    groups)`: This function groups the external regions obtained. It uses the extracted
    channels (`src`), the obtained external regions by each channel (`regions`), the
    path to the grouping classifier, and the minimum probability for accepting a group
    (`minProbability`). Final groups, which are rectangles from `Rect`, are stored
    in the vector `groups`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void erGrouping(InputArrayOfArrays src, std::vector<std::vector<ERStat>>&
    regions, const std::string& filename, float minProbability, std::vector<Rect>&
    groups)`: 此函数将获取的外部区域分组。它使用提取的通道 (`src`)、每个通道获取的外部区域 (`regions`)、分组分类器的路径以及接受一个组的最低概率
    (`minProbability`)。最终组，即来自 `Rect` 的矩形，存储在 `groups` 向量中。'
- en: 'The following group of screenshots shows the obtained image channels. These
    are red (`R`), green (`G`), blue (`B`), intensity (`I`), gradient magnitude (∇),
    inverted red (`iR`), inverted green (`iG`), inverted blue (`iB`), and inverted
    intensity (`iI`). In the first row, the `R`, `G`, and `B` channels are shown.
    The second row shows the I, ∇, and iR channels. Finally, in the third row, the
    iG, iB, and iI channels are shown:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列截图显示了获取的图像通道。这些是红色 (`R`)、绿色 (`G`)、蓝色 (`B`)、强度 (`I`)、梯度幅度 (∇)、反转红色 (`iR`)、反转绿色
    (`iG`)、反转蓝色 (`iB`) 和反转强度 (`iI`)。在第一行中，显示了 `R`、`G` 和 `B` 通道。第二行显示了 I、∇ 和 iR 通道。最后，在第三行中，显示了
    iG、iB 和 iI 通道：
- en: '![Scene text detection](img/00044.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![场景文本检测](img/00044.jpeg)'
- en: Extracted image channels
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的图像通道
- en: 'The following group of screenshots shows it is possible to see the external
    regions extracted from each channel. Channels `R`, `G`, `B`, `L`, and ∇ produce
    more accurate results. In the first row, external regions from the `R`, `G`, and
    `B` channels are shown. The second row shows the external regions extracted from
    the I, ∇, and iR channels. Finally, in the third row, the `iG`, `iB`, and `iI`
    channels are shown:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列截图显示了可以查看从每个通道提取的外部区域。通道 `R`、`G`、`B`、`L` 和 ∇ 产生更准确的结果。在第一行中，显示了 `R`、`G`
    和 `B` 通道的外部区域。第二行显示了从 I、∇ 和 iR 通道提取的外部区域。最后，在第三行中，显示了 `iG`、`iB` 和 `iI` 通道：
- en: '![Scene text detection](img/00045.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![场景文本检测](img/00045.jpeg)'
- en: External regions obtained from each channel
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从每个通道获取的外部区域
- en: 'Finally, the following screenshot shows the input image with the text areas
    grouped into lines and paragraphs:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下截图显示了将文本区域分组为行和段落的输入图像：
- en: '![Scene text detection](img/00046.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![场景文本检测](img/00046.jpeg)'
- en: Groups obtained
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的组
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To reproduce these results or use the OpenCV Scene Text Detector, it is possible
    to use this code with the sample files provided by the library. The input image
    and classifier can be found in the `OPENCV_SCR/samples/cpp` directory. The image
    used here is `cenetext01.jpg`. The first and second level classifiers are `trained_classifierNM1.xml`
    and `trained_classifierNM2.xml`. Finally, the grouping classifier provided by
    OpenCV is `trained_classifier_erGrouping.xml`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要重现这些结果或使用 OpenCV 场景文本检测器，可以使用库提供的示例文件运行此代码。输入图像和分类器可以在 `OPENCV_SCR/samples/cpp`
    目录中找到。这里使用的图像是 `cenetext01.jpg`。第一级和第二级分类器是 `trained_classifierNM1.xml` 和 `trained_classifierNM2.xml`。最后，OpenCV
    提供的分组分类器是 `trained_classifier_erGrouping.xml`。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covers the OpenCV `objdetect` module. It explains how to use and
    train the Cascade detectors as well as how to use Latent SVM detectors. Moreover,
    the new Scene Text Detector included in OpenCV 3 has been explained in this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 OpenCV 的 `objdetect` 模块。它解释了如何使用和训练级联检测器以及如何使用潜在 SVM 检测器。此外，本章还解释了 OpenCV
    3 中包含的新场景文本检测器。
- en: Methods for detecting and tracking objects in motion are explained in the next
    chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释检测和跟踪运动对象的方法。
- en: What else?
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有什么？
- en: Cascade detectors have been widely used in several applications such as face
    recognition and pedestrian detection because they are fast and provide good results.
    Soft cascades are a variant of the classic cascade detectors. This new type of
    cascades is implemented in OpenCV 3 in the `softcascade` module. Soft cascade
    is trained with AdaBoost but the resulting detector is composed of only one stage.
    This stage has several weak classifiers that are evaluated in sequence. After
    evaluating each weak classifier, the result is compared with the corresponding
    threshold. Similar to the evaluation process carried out in multistage cascades,
    negative non-object instances are discarded as soon as possible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 级联检测器已在多个应用中得到了广泛应用，例如人脸识别和行人检测，因为它们速度快且提供良好的结果。软级联是经典级联检测器的一种变体。这种新型级联在OpenCV
    3的`softcascade`模块中实现。软级联使用AdaBoost进行训练，但生成的检测器仅由一个阶段组成。这个阶段有几个弱分类器，它们按顺序进行评估。在评估每个弱分类器后，结果将与相应的阈值进行比较。与多阶段级联中进行的评估过程类似，一旦评估出负的非目标实例，就会尽快将其丢弃。
