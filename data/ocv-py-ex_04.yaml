- en: Chapter 4. Detecting and Tracking Different Body Parts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 检测和跟踪不同身体部位
- en: In this chapter, we are going to learn how to detect and track different body
    parts in a live video stream. We will start by discussing the face detection pipeline
    and how it's built from the ground up. We will learn how to use this framework
    to detect and track other body parts, such as eyes, ears, mouth, and nose.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在实时视频流中检测和跟踪不同的身体部位。我们将从讨论人脸检测流程及其从头开始构建的方式开始。我们将学习如何使用这个框架来检测和跟踪其他身体部位，例如眼睛、耳朵、嘴巴和鼻子。
- en: 'By the end of this chapter, you will know:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道：
- en: How to use Haar cascades
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Haar级联
- en: What are integral images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是积分图像
- en: What is adaptive boosting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是自适应提升
- en: How to detect and track faces in a live video stream
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在实时视频流中检测和跟踪人脸
- en: How to detect and track eyes in a live video stream
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在实时视频流中检测和跟踪眼睛
- en: How to automatically overlay sunglasses on top of a person's face
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何自动在人脸上叠加太阳镜
- en: How to detect ears, nose, and mouth
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测耳朵、鼻子和嘴巴
- en: How to detect pupils using shape analysis
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过形状分析检测瞳孔
- en: Using Haar cascades to detect things
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Haar级联检测物体
- en: When we say Haar cascades, we are actually talking about cascade classifiers
    based on Haar features. To understand what this means, we need to take a step
    back and understand why we need this in the first place. Back in 2001, Paul Viola
    and Michael Jones came up with a very effective object detection method in their
    seminal paper. It has become one of the major landmarks in the field of machine
    learning.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到Haar级联时，我们实际上是在谈论基于Haar特征的级联分类器。为了理解这意味着什么，我们需要退一步，了解为什么我们最初需要这个。回到2001年，保罗·维奥拉和迈克尔·琼斯在他们开创性的论文中提出了一种非常有效的目标检测方法。这已经成为机器学习领域的一个主要里程碑。
- en: In their paper, they have described a machine learning technique where a boosted
    cascade of simple classifiers is used to get an overall classifier that performs
    really well. This way, we can circumvent the process of building a single complex
    classifier that performs with high accuracy. The reason this is so amazing is
    because building a robust single-step classifier is a computationally intensive
    process. Besides, we need a lot of training data to build such a classifier. The
    model ends up becoming complex and the performance might not be up to the mark.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的论文中，他们描述了一种机器学习技术，其中使用简单分类器的提升级联来获得一个表现非常出色的整体分类器。这样，我们可以绕过构建单个复杂分类器以实现高精度的过程。之所以这如此令人惊叹，是因为构建一个健壮的单步分类器是一个计算密集型的过程。此外，我们需要大量的训练数据来构建这样的分类器。模型最终变得复杂，性能可能无法达到预期标准。
- en: Let's say we want to detect an object like, say, a pineapple. To solve this,
    we need to build a machine learning system that will learn what a pineapple looks
    like. It should be able to tell us if an unknown image contains a pineapple or
    not. To achieve something like this, we need to train our system. In the realm
    of machine learning, we have a lot of methods available to train a system. It's
    a lot like training a dog, except that it won't fetch the ball for you! To train
    our system, we take a lot of pineapple and non-pineapple images, and then feed
    them into the system. Here, pineapple images are called positive images and the
    non-pineapple images are called negative images.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要检测一个物体，比如，菠萝。为了解决这个问题，我们需要构建一个机器学习系统，该系统能够学习菠萝的外观。它应该能够告诉我们未知图像中是否包含菠萝。为了实现类似的功能，我们需要训练我们的系统。在机器学习的领域，我们有大量的方法可以用来训练一个系统。这很像训练一只狗，只不过它不会帮你捡球！为了训练我们的系统，我们使用大量的菠萝和非菠萝图像，并将它们输入到系统中。在这里，菠萝图像被称为正图像，而非菠萝图像被称为负图像。
- en: As far as the training is concerned, there are a lot of routes available. But
    all the traditional techniques are computationally intensive and result in complex
    models. We cannot use these models to build a real time system. Hence, we need
    to keep the classifier simple. But if we keep the classifier simple, it will not
    be accurate. The trade off between speed and accuracy is common in machine learning.
    We overcome this problem by building a set of simple classifiers and then cascading
    them together to form a unified classifier that's robust. To make sure that the
    overall classifier works well, we need to get creative in the cascading step.
    This is one of the main reasons why the **Viola-Jones** method is so effective.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就训练而言，有众多路线可供选择。但所有传统技术都是计算密集型的，并导致复杂的模型。我们不能使用这些模型来构建实时系统。因此，我们需要保持分类器简单。但是，如果我们保持分类器简单，它将不会很准确。速度和准确度之间的权衡在机器学习中很常见。我们通过构建一系列简单的分类器并将它们级联起来形成一个鲁棒的统一分类器来克服这个问题。为了确保整体分类器工作良好，我们需要在级联步骤中发挥创意。这就是为什么**Viola-Jones**方法如此有效的主要原因之一。
- en: Coming to the topic of face detection, let's see how to train a system to detect
    faces. If we want to build a machine learning system, we first need to extract
    features from all the images. In our case, the machine learning algorithms will
    use these features to learn what a face looks like. We use Haar features to build
    our feature vectors. Haar features are simple summations and differences of patches
    across the image. We do this at multiple image sizes to make sure our system is
    scale invariant.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 说到面部检测的话题，让我们看看如何训练一个系统来检测面部。如果我们想构建一个机器学习系统，我们首先需要从所有图像中提取特征。在我们的情况下，机器学习算法将使用这些特征来学习面部的外观。我们使用Haar特征来构建我们的特征向量。Haar特征是图像中块片的简单求和和差分。我们在多个图像大小上进行此操作，以确保我们的系统是尺度不变的。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are curious, you can learn more about the formulation at [http://www.cs.ubc.ca/~lowe/425/slides/13-ViolaJones.pdf](http://www.cs.ubc.ca/~lowe/425/slides/13-ViolaJones.pdf)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此好奇，你可以在[http://www.cs.ubc.ca/~lowe/425/slides/13-ViolaJones.pdf](http://www.cs.ubc.ca/~lowe/425/slides/13-ViolaJones.pdf)上了解更多关于公式的信息。
- en: Once we extract these features, we pass it through a cascade of classifiers.
    We just check all the different rectangular sub-regions and keep discarding the
    ones that don't have faces in them. This way, we arrive at the final answer quickly
    to see if a given rectangle contains a face or not.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提取了这些特征，我们就将其通过一系列分类器。我们只是检查所有不同的矩形子区域，并丢弃其中没有面部的那些。这样，我们就能快速得出结论，看给定的矩形是否包含面部。
- en: What are integral images?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分图像是什么？
- en: If we want to compute Haar features, we will have to compute the summations
    of many different rectangular regions within the image. If we want to effectively
    build the feature set, we need to compute these summations at multiple scales.
    This is a very expensive process! If we want to build a real time system, we cannot
    spend so many cycles in computing these sums. So we use something called integral
    images.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要计算Haar特征，我们将在图像内计算许多不同矩形区域的求和。如果我们想有效地构建特征集，我们需要在多个尺度上计算这些求和。这是一个非常昂贵的进程！如果我们想构建一个实时系统，我们不能在计算这些和上花费这么多周期。所以，我们使用一种叫做积分图像的东西。
- en: '![What are integral images?](img/B04554_04_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像是什么？](img/B04554_04_01.jpg)'
- en: 'To compute the sum of any rectangle in the image, we don''t need to go through
    all the elements in that rectangular area. Let''s say AP indicates the sum of
    all the elements in the rectangle formed by the top left point and the point P
    in the image as the two diagonally opposite corners. So now, if we want to compute
    the area of the rectangle ABCD, we can use the following formula:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算图像中任何矩形的和，我们不需要遍历该矩形区域的所有元素。假设AP表示由图像中左上角点和点P（作为两个对角线相对的顶点）形成的矩形的所有元素的和。所以现在，如果我们想计算矩形ABCD的面积，我们可以使用以下公式：
- en: '*Area of the rectangle ABCD = AC – (AB + AD - AA)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩形ABCD的面积 = AC – (AB + AD - AA)*'
- en: Why do we care about this particular formula? As we discussed earlier, extracting
    Haar features includes computing the areas of a large number of rectangles in
    the image at multiple scales. A lot of those computations are repetitive and the
    overall process is very slow. In fact, it is so slow that we cannot afford to
    run anything in real time. That's the reason we use this formulation! The good
    thing about this approach is that we don't have to recalculate anything. All the
    values for the areas on the right hand side of this equation are already available.
    So we just use them to compute the area of any given rectangle and extract the
    features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们关心这个特定的公式？正如我们之前讨论的，提取Haar特征包括在多个尺度上计算图像中大量矩形的面积。其中许多计算是重复的，整个过程非常慢。事实上，它如此之慢，以至于我们无法承担实时运行任何东西的费用。这就是我们使用这个公式的理由！这个方法的好处是，我们不必重新计算任何东西。这个方程式右侧的所有面积值都已经可用。所以我们只需使用它们来计算任何给定矩形的面积并提取特征。
- en: Detecting and tracking faces
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部检测与跟踪
- en: 'OpenCV provides a nice face detection framework. We just need to load the cascade
    file and use it to detect the faces in an image. Let''s see how to do it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个不错的面部检测框架。我们只需要加载级联文件并使用它来检测图像中的面部。让我们看看如何做到这一点：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run the above code, it will look something like the following image:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行上述代码，它看起来可能像以下图像：
- en: '![Detecting and tracking faces](img/B04554_04_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![面部检测与跟踪](img/B04554_04_02.jpg)'
- en: Understanding it better
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好地理解它
- en: We need a classifier model that can be used to detect the faces in an image.
    OpenCV provides an xml file that can be used for this purpose. We use the function
    `CascadeClassifier` to load the xml file. Once we start capturing the input frames
    from the webcam, we convert it to grayscale and use the function `detectMultiScale`
    to get the bounding boxes for all the faces in the current image. The second argument
    in this function specifies the jump in the scaling factor. As in, if we don't
    find an image in the current scale, the next size to check will be, in our case,
    1.3 times bigger than the current size. The last parameter is a threshold that
    specifies the number of adjacent rectangles needed to keep the current rectangle.
    It can be used to increase the robustness of the face detector.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个分类器模型，可以用来检测图像中的面部。OpenCV提供了一个用于此目的的xml文件。我们使用`CascadeClassifier`函数来加载xml文件。一旦我们开始从摄像头捕获输入帧，我们就将其转换为灰度图，并使用`detectMultiScale`函数获取当前图像中所有面部的边界框。这个函数的第二个参数指定了缩放因子的跳跃。也就是说，如果我们当前尺度下找不到图像，下一个要检查的尺寸将是当前尺寸的1.3倍。最后一个参数是一个阈值，指定了需要保留当前矩形的相邻矩形数量。它可以用来增加面部检测器的鲁棒性。
- en: Fun with faces
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部游戏
- en: 'Now that we know how to detect and track faces, let''s have some fun with it.
    When we capture a video stream from the webcam, we can overlay funny masks on
    top of our faces. It will look something like this next image:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何检测和跟踪面部，让我们来点乐趣。当我们从摄像头捕获视频流时，我们可以在我们的面部上叠加有趣的口罩。它看起来可能像下面这张图像：
- en: '![Fun with faces](img/B04554_04_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![面部游戏](img/B04554_04_03.jpg)'
- en: 'If you are a fan of Hannibal, you can try this next one:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢汉尼拔，你可以尝试下一个：
- en: '![Fun with faces](img/B04554_04_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![面部游戏](img/B04554_04_04.jpg)'
- en: 'Let''s look at the code to see how to overlay the skull mask on top of the
    face in the input video stream:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，看看如何将颅骨面具叠加到输入视频流中的面部上：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Under the hood
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部机制
- en: 'Just like before, we first load the face cascade classifier xml file. The face
    detection steps work as usual. We start the infinite loop and keep detecting the
    face in every frame. Once we know where the face is, we need to modify the coordinates
    a bit to make sure the mask fits properly. This manipulation process is subjective
    and depends on the mask in question. Different masks require different levels
    of adjustments to make it look more natural. We extract the region-of-interest
    from the input frame in the following line:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，我们首先加载面部级联分类器xml文件。面部检测步骤按常规进行。我们启动无限循环并持续检测每一帧中的面部。一旦我们知道面部在哪里，我们需要稍微修改坐标以确保面具合适地贴合。这个操作过程是主观的，取决于所讨论的面具。不同的面具需要不同级别的调整以使其看起来更自然。我们在以下行中从输入帧中提取感兴趣区域：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have the required region-of-interest, we need to overlay the mask
    on top of this. So we resize the input mask to make sure it fits in this region-of-interest.
    The input mask has a white background. So if we just overlay this on top of the
    region-of-interest, it will look unnatural because of the white background. We
    need to overlay only the skull-mask pixels and the remaining area should be transparent.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的感兴趣区域，我们需要在这个区域上方叠加掩码。所以我们将输入掩码调整大小，确保它适合这个感兴趣区域。输入掩码有一个白色背景。所以如果我们直接将其叠加在感兴趣区域上，由于白色背景，它看起来会不自然。我们需要叠加的只有颅骨掩码像素，其余区域应该是透明的。
- en: So in the next step, we create a mask by thresholding the skull image. Since
    the background is white, we threshold the image so that any pixel with an intensity
    value greater than 180 becomes 0, and everything else becomes 255\. As far as
    the frame region-of-interest is concerned, we need to black out everything in
    this mask region. We can do that by simply using the inverse of the mask we just
    created. Once we have the masked versions of the skull image and the input region-of-interest,
    we just add them up to get the final image.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在下一步，我们通过阈值化颅骨图像来创建一个掩码。由于背景是白色的，我们将图像阈值化，使得任何强度值大于180的像素变为0，其余所有像素变为255。至于感兴趣区域，我们需要在这个掩码区域内将所有内容变黑。我们可以通过简单地使用我们刚刚创建的掩码的逆来做到这一点。一旦我们有了颅骨图像的掩码版本和输入感兴趣区域，我们只需将它们相加即可得到最终图像。
- en: Detecting eyes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测眼睛
- en: Now that we understand how to detect faces, we can generalize the concept to
    detect other body parts too. It's important to understand that Viola-Jones framework
    can be applied to any object. The accuracy and robustness will depend on the uniqueness
    of the object. For example, a human face has very unique characteristics, so it's
    easy to train our system to be robust. On the other hand, an object like towel
    is too generic, and there are no distinguishing characteristics as such; so it's
    more difficult to build a robust towel detector.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何检测人脸，我们可以将这个概念推广到检测其他身体部位。重要的是要理解Viola-Jones框架可以应用于任何对象。准确性和鲁棒性将取决于对象的独特性。例如，人脸具有非常独特的特征，因此训练我们的系统变得鲁棒是很容易的。另一方面，像毛巾这样的物体太通用了，没有这样的区分特征；因此，构建一个鲁棒的毛巾检测器会更困难。
- en: 'Let''s see how to build an eye detector:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何构建一个眼睛检测器：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you run this program, the output will look something like the following
    image:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，输出将类似于以下图像：
- en: '![Detecting eyes](img/B04554_04_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![检测眼睛](img/B04554_04_05.jpg)'
- en: Afterthought
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反思
- en: If you notice, the program looks very similar to the face detection program.
    Along with loading the face detection cascade classifier, we load the eye detection
    cascade classifier as well. Technically, we don't need to use the face detector.
    But we know that eyes are always on somebody's face. We use this information and
    search for eyes only in the relevant region of interest, that is the face. We
    first detect the face, and then run the eye detector on this sub-image. This way,
    it's faster and more efficient.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意的话，程序看起来非常类似于人脸检测程序。除了加载人脸检测级联分类器外，我们还加载了眼睛检测级联分类器。技术上，我们不需要使用人脸检测器。但我们知道眼睛总是在某人的脸上。我们使用这个信息，只在相关感兴趣区域内搜索眼睛，即脸部。我们首先检测脸部，然后在子图像上运行眼睛检测器。这样，它更快更高效。
- en: Fun with eyes
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 眼睛的乐趣
- en: 'Now that we know how to detect eyes in an image, let''s see if we can do something
    fun with it. We can do something like what is shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在图像中检测眼睛，让我们看看我们能否用它来做些有趣的事情。我们可以做类似以下截图所示的事情：
- en: '![Fun with eyes](img/B04554_04_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![眼睛的乐趣](img/B04554_04_06.jpg)'
- en: 'Let''s look at the code to see how to do something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码，看看如何做到这一点：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Positioning the sunglasses
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放置太阳镜
- en: Just like we did earlier, we load the image and detect the eyes. Once we detect
    the eyes, we resize the sunglasses image to fit the current region of interest.
    To create the region of interest, we consider the distance between the eyes. We
    resize the image accordingly and then go ahead to create a mask. This is similar
    to what we did with the skull mask earlier. The positioning of the sunglasses
    on the face is subjective. So you will have to tinker with the weights if you
    want to use a different pair of sunglasses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们加载图像并检测眼睛。一旦我们检测到眼睛，我们就调整太阳镜图像的大小以适应当前感兴趣的区域。为了创建感兴趣的区域，我们考虑眼睛之间的距离。我们相应地调整图像大小，然后继续创建一个掩模。这与我们之前创建头骨掩模的方法类似。太阳镜在脸上的位置是主观的。所以如果你想使用不同的太阳镜，你可能需要调整权重。
- en: Detecting ears
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测耳朵
- en: 'Since we know how the pipeline works, let''s just jump into the code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道了工作流程的工作原理，让我们直接进入代码：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run the above code on an image, you should see something like the following
    screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个图像上运行上面的代码，你应该会看到如下所示的截图：
- en: '![Detecting ears](img/B04554_04_07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![检测耳朵](img/B04554_04_07.jpg)'
- en: Detecting a mouth
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测嘴巴
- en: 'Following is the code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要用到的代码：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Following is what the output looks like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将呈现的输出：
- en: '![Detecting a mouth](img/B04554_04_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![检测嘴巴](img/B04554_04_08.jpg)'
- en: It's time for a moustache
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候画胡子了
- en: 'Let''s overlay a moustache on top:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在上面叠加一个胡子：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s what it looks like:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是这样的：
- en: '![It''s time for a moustache](img/B04554_04_09.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![是时候画胡子了](img/B04554_04_09.jpg)'
- en: Detecting a nose
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测鼻子
- en: 'The following program shows how you detect a nose:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序展示了如何检测鼻子：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output looks something like the following image:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像以下图像：
- en: '![Detecting a nose](img/B04554_04_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![检测鼻子](img/B04554_04_10.jpg)'
- en: Detecting pupils
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测瞳孔
- en: 'We are going to take a different approach here. Pupils are too generic to take
    the Haar cascade approach. We will also get a sense of how to detect things based
    on their shape. Following is what the output will look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取不同的方法。瞳孔太通用，不适合使用Haar级联方法。我们还将了解如何根据形状检测事物。以下是将呈现的输出：
- en: '![Detecting pupils](img/B04554_04_11.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![检测瞳孔](img/B04554_04_11.jpg)'
- en: 'Let''s see how to build the pupil detector:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何构建瞳孔检测器：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you run this program, you will see the output as shown earlier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你将看到之前展示的输出。
- en: Deconstructing the code
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码分解
- en: 'As we discussed earlier, we are not going to use Haar cascade to detect pupils.
    If we can''t use a pre-trained classifier, then how are we going to detect the
    pupils? Well, we can use shape analysis to detect the pupils. We know that pupils
    are circular, so we can use this information to detect them in the image. We invert
    the input image and then convert it into grayscale image as shown in the following
    line:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，我们不会使用Haar级联来检测瞳孔。如果我们不能使用预训练的分类器，那么我们该如何检测瞳孔呢？嗯，我们可以使用形状分析来检测瞳孔。我们知道瞳孔是圆形的，因此我们可以利用这一信息在图像中检测它们。我们反转输入图像，然后将其转换为灰度图像，如下所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see here, we can invert an image using the tilde operator. Inverting
    the image is helpful in our case because the pupil is black in color, and black
    corresponds to a low pixel value. We then threshold the image to make sure that
    there are only black and white pixels. Now, we have to find out the boundaries
    of all the shapes. OpenCV provides a nice function to achieve this, that is `findContours`.
    We will discuss more about this in the upcoming chapters. But for now, all we
    need to know is that this function returns the set of boundaries of all the shapes
    that are found in the image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以使用波浪号运算符来反转图像。在我们的情况下，反转图像是有帮助的，因为瞳孔是黑色的，而黑色对应于低像素值。然后我们对图像进行阈值处理，以确保只有黑白像素。现在，我们必须找出所有形状的边界。OpenCV提供了一个很好的函数来实现这一点，那就是`findContours`。我们将在接下来的章节中对此进行更多讨论。但就目前而言，我们只需要知道这个函数返回图像中找到的所有形状的边界集合。
- en: The next step is to identify the shape of the pupil and discard the rest. We
    will use certain properties of the circle to zero-in on this shape. Let's consider
    the ratio of width to height of the bounding rectangle. If the shape is a circle,
    this ratio will be 1\. We can use the function `boundingRect` to obtain the coordinates
    of the bounding rectangle. Let's consider the area of this shape. If we roughly
    compute the radius of this shape and use the formula for the area of the circle,
    then it should be close to the area of this contour. We can use the function `contourArea`
    to compute the area of any contour in the image. So we can use these conditions
    and filter out the shapes. After we do that, we are left with two pupils in the
    image. We can refine it further by limiting the search region to the face or the
    eyes. Since you know how to detect faces and eyes, you can give it a try and see
    if you can get it working for a live video stream.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是识别瞳孔的形状并丢弃其余部分。我们将利用圆的一些特性来精确地定位这个形状。让我们考虑边界矩形的宽高比。如果形状是圆形，这个比例将是 1。我们可以使用
    `boundingRect` 函数来获取边界矩形的坐标。让我们考虑这个形状的面积。如果我们大致计算这个形状的半径并使用圆面积公式，那么它应该接近这个轮廓的面积。我们可以使用
    `contourArea` 函数来计算图像中任何轮廓的面积。因此，我们可以使用这些条件来过滤形状。在这样做之后，图像中剩下两个瞳孔。我们可以通过限制搜索区域为面部或眼睛来进一步细化。由于你知道如何检测面部和眼睛，你可以尝试一下，看看你是否能使其在实时视频流中工作。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed Haar cascades and integral images. We understood
    how the face detection pipeline is built. We learnt how to detect and track faces
    in a live video stream. We discussed how to use the face detection pipeline to
    detect various body parts like eyes, ears, nose, and mouth. We learnt how to overlay
    masks on top on the input image using the results of body parts detection. We
    used the principles of shape analysis to detect the pupils.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Haar级联和积分图像。我们了解了面部检测流程是如何构建的。我们学习了如何在实时视频流中检测和跟踪面部。我们讨论了如何使用面部检测流程来检测各种身体部位，如眼睛、耳朵、鼻子和嘴巴。我们学习了如何使用身体部位检测的结果在输入图像上叠加掩码。我们使用了形状分析原理来检测瞳孔。
- en: In the next chapter, we are going to discuss feature detection and how it can
    be used to understand the image content.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论特征检测及其如何被用来理解图像内容。
