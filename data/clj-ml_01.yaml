- en: Chapter 1. Working with Matrices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 矩阵操作
- en: In this chapter, we will explore an elementary yet elegant mathematical data
    structure—the **matrix**. Most computer science and mathematics graduates would
    already be familiar with matrices and their applications. In the context of machine
    learning, matrices are used to implement several types of machine-learning techniques,
    such as linear regression and classification. We will study more about these techniques
    in the later chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个基本而优雅的数学数据结构——**矩阵**。大多数计算机科学和数学毕业生已经熟悉矩阵及其应用。在机器学习的背景下，矩阵用于实现多种机器学习技术，如线性回归和分类。我们将在后面的章节中更深入地研究这些技术。
- en: Although this chapter may seem mostly theoretical at first, we will soon see
    that matrices are a very useful abstraction for quickly organizing and indexing
    data with multiple dimensions. The data used by machine-learning techniques contains
    a large number of sample values in several dimensions. Thus, matrices can be used
    to store and manipulate this sample data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个章节一开始可能看起来主要是理论性的，但很快我们会看到矩阵是快速组织和索引多维度数据的非常有用的抽象。机器学习技术使用的数据包含多个维度的大量样本值。因此，矩阵可以用来存储和处理这些样本数据。
- en: An interesting application that uses matrices is Google Search, which is built
    on the **PageRank** algorithm. Although a detailed explanation of this algorithm
    is beyond the scope of this book, it's worth knowing that Google Search essentially
    finds the *eigen-vector* of an extremely massive matrix of data (for more information,
    refer to *The Anatomy of a Large-Scale Hypertextual Web Search Engine*). Matrices
    are used for a variety of applications in computing. Although we do not discuss
    the eigen-vector matrix operation used by Google Search in this book, we will
    encounter a variety of matrix operations while implementing machine-learning algorithms.
    In this chapter, we will describe the useful operations that we can perform on
    matrices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵的一个有趣应用是谷歌搜索，它建立在**PageRank**算法之上。尽管这个算法的详细解释超出了本书的范围，但值得知道的是，谷歌搜索本质上是在寻找一个极其庞大的数据矩阵的**特征向量**（更多信息，请参阅《大规模超文本搜索引擎的解剖结构》）。矩阵在计算机科学中有各种应用。尽管我们在这本书中不讨论谷歌搜索使用的特征向量矩阵运算，但在实现机器学习算法的过程中，我们会遇到各种矩阵运算。在本章中，我们将描述我们可以对矩阵执行的有用操作。
- en: Introducing Leiningen
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Leiningen
- en: Over the course of this book, we will use Leiningen ([http://leiningen.org/](http://leiningen.org/))
    to manage third-party libraries and dependencies. Leiningen, or `lein`, is the
    standard Clojure package management and automation tool, and has several powerful
    features used to manage Clojure projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将使用Leiningen([http://leiningen.org/](http://leiningen.org/))来管理第三方库和依赖项。Leiningen，或`lein`，是标准的Clojure包管理和自动化工具，具有用于管理Clojure项目的几个强大功能。
- en: 'To get instructions on how to install Leiningen, visit the project site at
    [http://leiningen.org/](http://leiningen.org/). The first run of the `lein` program
    could take a while, as it downloads and installs the Leiningen binaries when it''s
    run for the first time. We can create a new Leiningen project using the `new`
    subcommand of `lein`, as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取如何安装Leiningen的说明，请访问项目网站[http://leiningen.org/](http://leiningen.org/)。`lein`程序的第一次运行可能需要一段时间，因为它在第一次运行时会下载和安装Leiningen的二进制文件。我们可以使用`lein`的`new`子命令创建一个新的Leiningen项目，如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command creates a new directory, `my-project`, which will contain
    all source and configuration files for a Clojure project. This folder contains
    the source files in the `src` subdirectory and a single `project.clj` file. In
    this command, `default` is the type of project template to be used for the new
    project. All the examples in this book use the preceding `default` project template.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令创建了一个新的目录，`my-project`，它将包含Clojure项目的所有源文件和配置文件。这个文件夹包含`src`子目录中的源文件和一个单独的`project.clj`文件。在这个命令中，`default`是新项目要使用的项目模板的类型。本书中的所有示例都使用上述`default`项目模板。
- en: 'The `project.clj` file contains all the configuration associated with the project
    and will have the following structure:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`project.clj`文件包含与项目相关的所有配置，并将具有以下结构：'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: 'Third-party Clojure libraries can be included in a project by adding the declarations
    to the vector with the `:dependencies` key. For example, the core.matrix Clojure
    library package on Clojars ([https://clojars.org/net.mikera/core.matrix](https://clojars.org/net.mikera/core.matrix))
    gives us the package declaration `[net.mikera/core.matrix "0.20.0"]`. We simply
    paste this declaration into the `:dependencies` vector to add the core.matrix
    library package as a dependency for our Clojure project, as shown in the following
    code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方Clojure库可以通过向带有`:dependencies`键的向量中添加声明来包含在项目中。例如，Clojars上的core.matrix Clojure库包（[https://clojars.org/net.mikera/core.matrix](https://clojars.org/net.mikera/core.matrix)）为我们提供了包声明`[net.mikera/core.matrix
    "0.20.0"]`。我们只需将此声明粘贴到`:dependencies`向量中，即可将core.matrix库包作为依赖项添加到我们的Clojure项目中，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To download all the dependencies declared in the `project.clj` file, simply
    run the following `deps` subcommand:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载`project.clj`文件中声明的所有依赖项，只需运行以下`deps`子命令：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Leiningen also provides an **REPL** (**read-evaluate-print-loop**), which is
    simply an interactive interpreter that contains all the dependencies declared
    in the `project.clj` file. This REPL will also reference all the Clojure namespaces
    that we have defined in our project. We can start the REPL using the following
    `repl` subcommand of `lein`. This will start a new REPL session:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen还提供了一个**REPL**（**读取-评估-打印循环**），它简单来说是一个包含在`project.clj`文件中声明的所有依赖项的交互式解释器。此REPL还将引用我们在项目中定义的所有Clojure命名空间。我们可以使用以下`lein`的`repl`子命令来启动REPL。这将启动一个新的REPL会话：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Representing matrices
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵表示
- en: A matrix is simply a rectangular array of data arranged in rows and columns.
    Most programming languages, such as C# and Java, have direct support for rectangular
    arrays, while others, such as Clojure, use the heterogeneous array-of-arrays representation
    for rectangular arrays. Keep in mind that Clojure has no direct support for handling
    arrays, and an idiomatic Clojure code uses *vectors* to store and index an array
    of elements. As we will see later, a matrix is represented as a vector whose elements
    are the other vectors in Clojure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵简单来说就是按行和列排列的数据矩形数组。大多数编程语言，如C#和Java，都直接支持矩形数组，而其他语言，如Clojure，则使用异构的数组-数组表示法来表示矩形数组。请注意，Clojure没有直接支持处理数组，并且惯用的Clojure代码使用*向量*来存储和索引元素数组。正如我们稍后将会看到的，矩阵在Clojure中表示为一个向量，其元素是其他向量。
- en: Matrices also support several arithmetic operations, such as addition and multiplication,
    which constitute an important field of mathematics known as **Linear Algebra**.
    Almost every popular programming language has at least one linear algebra library.
    Clojure takes this a step ahead by letting us choose from several such libraries,
    all of which have a single standardized API interface that works with matrices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵支持多种算术运算，如加法和乘法，这些构成了数学中一个重要的领域，称为**线性代数**。几乎每种流行的编程语言至少有一个线性代数库。Clojure通过让我们从多个此类库中选择，并且所有这些库都有一个与矩阵一起工作的单一标准化API接口，从而更进一步。
- en: The *core.matrix* library is a versatile Clojure library used to work with matrices.
    Core.matrix also contains a specification to handle matrices. An interesting fact
    about core.matrix is that while it provides a default implementation of this specification,
    it also supports multiple implementations. The core.matrix library is hosted and
    developed on GitHub at [http://github.com/mikera/core.matrix](http://github.com/mikera/core.matrix).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*core.matrix*库是一个多功能的Clojure库，用于处理矩阵。Core.matrix还包含处理矩阵的规范。关于core.matrix的一个有趣的事实是，虽然它提供了此规范的默认实现，但它还支持多个实现。core.matrix库托管和开发在GitHub上[http://github.com/mikera/core.matrix](http://github.com/mikera/core.matrix)。'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The core.matrix library can be added to a Leiningen project by adding the following
    dependency to the `project.clj` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`project.clj`文件中添加以下依赖项将core.matrix库添加到Leiningen项目中：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the upcoming example, the namespace declaration should look similar to
    the following declaration:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于即将到来的示例，命名空间声明应类似于以下声明：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the use of `:import` to include library namespaces in Clojure is generally
    discouraged. Instead, aliased namespaces with the `:require` form are preferred.
    However, for the examples in the following section, we will use the preceding
    namespace declaration.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Clojure 中使用 `:import` 来包含库命名空间通常是不推荐的。相反，使用 `:require` 形式进行别名命名空间是首选的。然而，对于下一节中的示例，我们将使用前面的命名空间声明。
- en: In Clojure, a matrix is simply a vector of vectors. This means that a matrix
    is represented as a vector whose elements are other vectors. A vector is an array
    of elements that takes near-constant time to retrieve an element, unlike a list
    that has linear lookup time. However, in the mathematical context of matrices,
    vectors are simply matrices with a single row or column.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，一个矩阵简单地说就是一个向量的向量。这意味着矩阵被表示为一个其元素是其他向量的向量。向量是一个元素数组，检索元素的时间几乎恒定，与具有线性查找时间的列表不同。然而，在矩阵的数学上下文中，向量仅仅是具有单行或单列的矩阵。
- en: To create a matrix from a vector of vectors, we use the following `matrix` function
    and pass a vector of vectors or a quoted list to it. Note that all the elements
    of the matrix are internally represented as a `double` data type (`java.lang.Double`)
    for added precision.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个向量的向量创建一个矩阵，我们使用以下 `matrix` 函数，并将一个向量的向量或一个引用列表传递给它。请注意，矩阵的所有元素都内部表示为 `double`
    数据类型（`java.lang.Double`），以增加精度。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the matrix has two rows and three columns, or is a
    2 x 3 matrix to be more concise. It should be noted that when a matrix is represented
    by a vector of vectors, all the vectors that represent the individual rows of
    the matrix should have the same length.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，矩阵有两行三列，或者更简洁地说是一个 2 x 3 矩阵。应注意，当矩阵由向量的向量表示时，表示矩阵各个行的所有向量应该具有相同的长度。
- en: 'The matrix that is created is printed as a vector, which is not the best way
    to visually represent it. We can use the `pm` function to print the matrix as
    follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的矩阵以向量的形式打印出来，这不是最佳的可视化表示方法。我们可以使用 `pm` 函数如下打印矩阵：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we define a matrix *A*, which is mathematically represented as follows.
    Note that the use of uppercase variable names is for illustration only, as all
    the Clojure variables are conventionally written in lowercase.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个矩阵 *A*，它用以下方式在数学上表示。请注意，使用大写变量名只是为了说明，因为所有 Clojure 变量都按照惯例以小写形式书写。
- en: '![Representing matrices](img/4351OS_01_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![表示矩阵](img/4351OS_01_04.jpg)'
- en: 'The matrix *A* is composed of elements a[i,j] where *i* is the row index and
    *j* is the column index of the matrix. We can mathematically represent a matrix
    *A* using brackets as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 *A* 由元素 a[i,j] 组成，其中 *i* 是矩阵的行索引，*j* 是列索引。我们可以用以下方式用括号表示数学上的矩阵 *A*：
- en: '![Representing matrices](img/4351OS_01_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![表示矩阵](img/4351OS_01_05.jpg)'
- en: We can use the `matrix?` function to check whether a symbol or variable is,
    in fact, a matrix. The `matrix?` function will return `true` for all the matrices
    that implement the core.matrix specification. Interestingly, the `matrix?` function
    will also return `true` for an ordinary vector of vectors.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `matrix?` 函数来检查一个符号或变量是否实际上是一个矩阵。`matrix?` 函数将对实现 core.matrix 规范的所有矩阵返回
    `true`。有趣的是，`matrix?` 函数也会对普通向量的向量返回 `true`。
- en: The default implementation of core.matrix is written in pure Clojure, which
    does affect performance when handling large matrices. The core.matrix specification
    has two popular contrib implementations, namely **vectorz-clj** ([http://github.com/mikera/vectorz-clj](http://github.com/mikera/vectorz-clj))
    that is implemented using pure Java and **clatrix** ([http://github.com/tel/clatrix](http://github.com/tel/clatrix))
    that is implemented through native libraries. While there are several other libraries
    that implement the core.matrix specification, these two libraries are seen as
    the most mature ones.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: core.matrix 的默认实现是用纯 Clojure 编写的，这会影响处理大型矩阵时的性能。core.matrix 规范有两个流行的贡献实现，即使用纯
    Java 实现的 **vectorz-clj** ([http://github.com/mikera/vectorz-clj](http://github.com/mikera/vectorz-clj))
    和通过本地库实现的 **clatrix** ([http://github.com/tel/clatrix](http://github.com/tel/clatrix))。虽然还有其他几个库实现了
    core.matrix 规范，但这两个库被视为最成熟的。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Clojure has three kinds of libraries, namely core, contrib, and third-party
    libraries. Core and contrib libraries are part of the standard Clojure library.
    The documentation for both the core and contrib libraries can be found at [http://clojure.github.io/](http://clojure.github.io/).
    The only difference between the core and contrib libraries is that the contrib
    libraries are not shipped with the Clojure language and have to be downloaded
    separately.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有三种类型的库，即 core、contrib 和第三方库。core 和 contrib 库是标准 Clojure 库的一部分。core
    和 contrib 库的文档可以在 [http://clojure.github.io/](http://clojure.github.io/) 找到。core
    和 contrib 库之间的唯一区别是，contrib 库不是与 Clojure 语言一起分发的，必须单独下载。
- en: Third-party libraries can be developed by anyone and are made available via
    Clojars ([https://clojars.org/](https://clojars.org/)). Leiningen supports all
    of the previous libraries and doesn't make much of a distinction between them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可开发第三方库，并通过 Clojars ([https://clojars.org/](https://clojars.org/)) 提供这些库。Leiningen
    支持所有这些库，并且在这些库之间没有太大的区别。
- en: The contrib libraries are often originally developed as third-party libraries.
    Interestingly, core.matrix was first developed as a third-party library and was
    later promoted to a contrib library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: contrib 库通常最初是作为第三方库开发的。有趣的是，core.matrix 首先作为一个第三方库开发，后来被提升为 contrib 库。
- en: The clatrix library uses the **Basic Linear Algebra Subprograms** (**BLAS**)
    specification to interface the native libraries that it uses. BLAS is also a stable
    specification of the linear algebra operations on matrices and vectors that are
    mostly used by native languages. In practice, clatrix performs significantly better
    than other implementations of core.matrix, and defines several utility functions
    used to work with matrices as well. You should note that matrices are treated
    as mutable objects by the clatrix library, as opposed to other implementations
    of the core.matrix specification that idiomatically treat a matrix as an immutable
    type.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: clatrix 库使用 **基本线性代数子程序**（**BLAS**）规范来接口它所使用的本地库。BLAS 也是矩阵和向量线性代数操作的稳定规范，这些操作主要被本地语言使用。在实践中，clatrix
    的性能显著优于 core.matrix 的其他实现，并定义了几个用于处理矩阵的实用函数。你应该注意，clatrix 库将矩阵视为可变对象，而 core.matrix
    规范的其他实现则习惯上将矩阵视为不可变类型。
- en: For most of this chapter, we will use clatrix to represent and manipulate matrices.
    However, we can effectively reuse functions from core.matrix that perform matrix
    operations (such as addition and multiplication) on the matrices created through
    clatrix. The only difference is that instead of using the `matrix` function from
    the `core.matrix` namespace to create matrices, we should use the one defined
    in the clatrix library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的大部分内容中，我们将使用 clatrix 来表示和操作矩阵。然而，我们可以有效地重用 core.matrix 中的函数，这些函数在通过 clatrix
    创建的矩阵上执行矩阵操作（如加法和乘法）。唯一的区别是，我们不应该使用 `core.matrix` 命名空间中的 `matrix` 函数来创建矩阵，而应该使用
    clatrix 库中定义的函数。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The clatrix library can be added to a Leiningen project by adding the following
    dependency to the `project.clj` file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `project.clj` 文件中添加以下依赖项将 clatrix 库添加到 Leiningen 项目中：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the upcoming example, the namespace declaration should look similar to
    the following declaration:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于即将到来的示例，命名空间声明应类似于以下声明：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Keep in mind that we can use both the `clatrix.core` and `clojure.core.matrix`
    namespaces in the same source file, but a good practice would be to import both
    these namespaces into aliased namespaces to prevent naming conflicts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们可以在同一个源文件中使用 `clatrix.core` 和 `clojure.core.matrix` 命名空间，但一个好的做法是将这两个命名空间导入到别名命名空间中，以防止命名冲突。
- en: 'We can create a matrix from the clatrix library using the following `cl/matrix`
    function. Note that clatrix produces a slightly different, yet more informative
    representation of the matrix than core.matrix. As mentioned earlier, the `pm`
    function can be used to print the matrix as a vector of vectors:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 `cl/matrix` 函数从 clatrix 库创建矩阵。请注意，clatrix 产生的矩阵表示与 core.matrix 略有不同，但更具有信息量。如前所述，可以使用
    `pm` 函数将矩阵打印为向量向量：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can also use an overloaded version of the `matrix` function, which takes
    a matrix implementation name as the first parameter, and is followed by the usual
    definition of the matrix as a vector, to create a matrix. The implementation name
    is specified as a keyword. For example, the default persistent vector implementation
    is specified as `:persistent-vector` and the clatrix implementation is specified
    as `:clatrix`. We can call the `matrix` function by specifying this keyword argument
    to create matrices of different implementations, as shown in the following code.
    In the first call, we call the `matrix` function with the `:persistent-vector`
    keyword to specify the default persistent vector implementation. Similarly, we
    call the `matrix` function with the `:clatrix` keyword to create a clatrix implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`matrix`函数的重载版本，它将矩阵实现名称作为第一个参数，后面跟着矩阵作为向量的常规定义，来创建矩阵。实现名称指定为一个关键字。例如，默认的持久向量实现指定为`:persistent-vector`，而clatrix实现指定为`:clatrix`。我们可以通过指定这个关键字参数来调用`matrix`函数，创建不同实现的矩阵，如下述代码所示。在第一次调用中，我们使用`:persistent-vector`关键字调用`matrix`函数来指定默认的持久向量实现。同样，我们使用`:clatrix`关键字调用`matrix`函数来创建clatrix实现。
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An interesting point is that the vectors of both vectors and numbers are treated
    as valid parameters for the `matrix` function by clatrix, which is different from
    how core.matrix handles it. For example, `[0 1]` produces a 2 x 1 matrix, while
    `[[0 1]]` produces a 1 x 2 matrix. The `matrix` function from core.matrix does
    not have this functionality and always expects a vector of vectors to be passed
    to it. However, calling the `cl/matrix` function with either `[0 1]` or `[[0 1]]`
    will create the following matrices without any error:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观点是，clatrix将向量数组和数字的向量都视为`matrix`函数的有效参数，这与core.matrix的处理方式不同。例如，`[0 1]`生成一个2
    x 1的矩阵，而`[[0 1]]`生成一个1 x 2的矩阵。core.matrix的`matrix`函数没有这个功能，并且始终期望传递一个向量数组的向量。然而，使用`[0
    1]`或`[[0 1]]`调用`cl/matrix`函数将创建以下矩阵而不会出现任何错误：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Analogous to the `matrix?` function, we can use the `cl/clatrix?` function
    to check whether a symbol or variable is a matrix from the clatrix library. While
    `matrix?` actually checks for an implementation of the core.matrix specification
    or protocol, the `cl/clatrix?` function checks for a specific type. If the `cl/clatrix?`
    function returns `true` for a particular variable, `matrix?` should return `true`
    as well; however, the converse of this axiom isn''t true. If we call `cl/clatrix?`
    on a matrix created using the `matrix` function and not the `cl/matrix` function,
    it will return `false`; this is shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与`matrix?`函数类似，我们可以使用`cl/clatrix?`函数来检查一个符号或变量是否来自clatrix库的矩阵。实际上，`matrix?`函数检查的是核心矩阵规范或协议的实现，而`cl/clatrix?`函数检查的是特定类型。如果`cl/clatrix?`函数对一个特定变量返回`true`，则`matrix?`也应该返回`true`；然而，这个公理的反面并不成立。如果我们使用`matrix`函数而不是`cl/matrix`函数创建一个矩阵并调用`cl/clatrix?`，它将返回`false`；这在下述代码中显示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Size is an important attribute of a matrix, and it often needs to be calculated.
    We can find the number of rows in a matrix using the `row-count` function. It''s
    actually just the length of the vector composing a matrix, and thus, we can also
    use the standard `count` function to determine the row count of a matrix. Similarly,
    the `column-count` function returns the number of columns in a matrix. Considering
    the fact that a matrix comprises equally long vectors, the number of columns should
    be the length of any inner vector, or rather any row, of a matrix. We can check
    the return value of the `count`, `row-count`, and `column-count` functions on
    the following sample matrix in the REPL:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的大小是一个重要的属性，通常需要计算。我们可以使用`row-count`函数来找到矩阵中的行数。实际上，这仅仅是组成矩阵的向量的长度，因此，我们也可以使用标准的`count`函数来确定矩阵的行数。同样，`column-count`函数返回矩阵中的列数。考虑到矩阵由等长的向量组成，列数应该是任何内部向量，或者说任何矩阵行的长度。我们可以在REPL中对以下示例矩阵的`count`、`row-count`和`column-count`函数的返回值进行检查：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To retrieve an element from a matrix using its row and column indexes, use the
    following `cl/get` function. Apart from the matrix to perform the operation on,
    this function accepts two parameters as indexes to the matrix. Note that all elements
    are indexed relative to *0* in Clojure code, as opposed to the mathematical notation
    of treating *1* as the position of the first element in a matrix.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用矩阵的行和列索引检索元素，请使用以下 `cl/get` 函数。除了执行操作的矩阵外，此函数还接受两个参数作为矩阵的索引。请注意，在 Clojure
    代码中，所有元素都是相对于 *0* 进行索引的，这与矩阵的数学表示法不同，后者将 *1* 视为矩阵中第一个元素的位置。
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As shown in the preceding example, the `cl/get` function also has an alternate
    form where only a single index value is accepted as a function parameter. In this
    case, the elements are indexed through a row-first traversal. For example, `(cl/get
    A 1)` returns `3.0` and `(cl/get A 3)` returns `4.0`. We can use the following
    `cl/set` function to change an element of a matrix. This function takes parameters
    similar to `cl/get`—a matrix, a row index, a column index, and lastly, the new
    element to be set in the specified position in the matrix. The `cl/set` function
    actually mutates or modifies the matrix it is supplied.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`cl/get` 函数还有一个接受单个索引值作为函数参数的替代形式。在这种情况下，元素通过行优先遍历进行索引。例如，`(cl/get A 1)`
    返回 `3.0`，而 `(cl/get A 3)` 返回 `4.0`。我们可以使用以下 `cl/set` 函数来更改矩阵的元素。此函数接受与 `cl/get`
    相似的参数——一个矩阵、一个行索引、一个列索引，以及最后要设置在矩阵指定位置的新元素。实际上，`cl/set` 函数会修改或修改它提供的矩阵。
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The clatrix library also provides two handy functions for functional composition:
    `cl/map` and `cl/map-indexed`. Both these functions accept a function and matrix
    as arguments and apply the passed function to each element in the matrix, in a
    manner that is similar to the standard `map` function. Also, both these functions
    return new matrices and do not mutate the matrix that they are supplied as parameters.
    Note that the function passed to `cl/map-indexed` should accept three arguments—the
    row index, the column index, and the element itself:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Clatrix 库还提供了两个用于函数组合的便捷函数：`cl/map` 和 `cl/map-indexed`。这两个函数都接受一个函数和一个矩阵作为参数，并将传递的函数应用于矩阵中的每个元素，其方式类似于标准的
    `map` 函数。此外，这两个函数都返回新的矩阵，并且不会修改它们作为参数提供的矩阵。请注意，传递给 `cl/map-indexed` 的函数应该接受三个参数——行索引、列索引以及元素本身：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Generating matrices
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成矩阵
- en: 'If the number of rows and columns in a matrix are equal, then we term the matrix
    as a *square matrix*. We can easily generate a simple square matrix of ![Generating
    matrices](img/4351OS_01_06.jpg) size by using the `repeat` function to repeat
    a single element as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵的行数和列数相等，则我们称该矩阵为 *方阵*。我们可以通过使用 `repeat` 函数重复单个元素来轻松生成一个简单的方阵，如下所示：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding example, we define a closure to repeat a value *n* times,
    which is shown as the `repeater`. We then use the *thread* macro (`->`) to pass
    the element `e` through the closure twice, and finally apply the `matrix` function
    to the result of the thread macro. We can extend this definition to allow us to
    specify the matrix implementation to be used for the generated matrix; this is
    done as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前例中，我们定义了一个闭包来重复值 *n* 次，这显示为 `repeater`。然后我们使用 *thread* 宏 (`->`) 将元素 `e` 通过闭包传递两次，最后将
    `matrix` 函数应用于 thread 宏的结果。我们可以扩展此定义，以便我们可以指定用于生成的矩阵的矩阵实现；这是如下完成的：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `square-mat` function is defined as one that accepts optional keyword arguments,
    which specify the matrix implementation of the generated matrix. We specify the
    default `:persistent-vector` implementation of core.matrix as the default value
    for the `:implementation` keyword.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`square-mat` 函数被定义为接受可选的关键字参数，这些参数指定了生成的矩阵的矩阵实现。我们将 core.matrix 的默认 `:persistent-vector`
    实现指定为 `:implementation` 关键字的默认值。'
- en: 'Now, we can use this function to create square matrices and optionally specify
    the matrix implementation when required:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个函数来创建方阵，并在需要时指定矩阵实现：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A special type of matrix that''s used frequently is the identity matrix. An
    **identity matrix** is a square matrix whose diagonal elements are *1* and all
    the other elements are *0*. We formally define an identity matrix ![Generating
    matrices](img/4351OS_01_07.jpg) as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 经常使用的一种特殊类型的矩阵是单位矩阵。**单位矩阵**是一个对角线元素为 *1* 而其他所有元素为 *0* 的方阵。我们正式定义单位矩阵 ![生成矩阵](img/4351OS_01_07.jpg)
    如下：
- en: '![Generating matrices](img/4351OS_01_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![生成矩阵](img/4351OS_01_08.jpg)'
- en: 'We can implement a function to create an identity matrix using the `cl/map-indexed`
    function that we previously mentioned, as shown in the following code snippet.
    We first create a square matrix `init` of ![Generating matrices](img/4351OS_01_06.jpg)
    size by using the previously defined `square-mat` function, and then map all the
    diagonal elements to `1` using `cl/map-indexed`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前提到的 `cl/map-indexed` 函数来实现一个创建单位矩阵的函数，如下代码片段所示。我们首先使用之前定义的 `square-mat`
    函数创建一个 ![生成矩阵](img/4351OS_01_06.jpg) 大小的正方形矩阵 `init`，然后使用 `cl/map-indexed` 将所有对角线元素映射为
    `1`：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The core.matrix library also has its own version of this function, named `identity-matrix`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: core.matrix 库也有自己的这个函数版本，命名为 `identity-matrix`：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another common scenario that we will encounter is the need to generate a matrix
    with random data. Let''s implement the following function to generate a random
    matrix, just like the previously defined `square-mat` function, using the `rand-int`
    function. Note that the `rand-int` function accepts a single argument `n`, and
    returns a random integer between `0` and `n`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会遇到另一个常见场景，即需要生成一个包含随机数据的矩阵。让我们实现以下函数来生成随机矩阵，就像之前定义的 `square-mat` 函数一样，使用
    `rand-int` 函数。请注意，`rand-int` 函数接受一个参数 `n`，并返回一个介于 `0` 和 `n` 之间的随机整数：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But this function produces a matrix whose elements are all single random numbers,
    which is not very useful. For example, if we call the `rand-square-mat` function
    with any integer as its parameter, then it returns a matrix with a single distinct
    random number, as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个函数生成的矩阵的所有元素都是单个随机数，这并不太有用。例如，如果我们用任何整数作为参数调用 `rand-square-mat` 函数，它将返回一个包含单个不同随机数的矩阵，如下代码片段所示：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead, we should map each element of the square matrix generated by the `square-mat`
    function using the `rand-int` function, to generate a random number for each element.
    Unfortunately, `cl/map` only works with matrices created by the clatrix library,
    but we can easily replicate this behavior in Clojure using a lazy sequence, as
    returned by the `repeatedly` function. Note that the `repeatedly` function accepts
    the length of a lazily generated sequence and a function to be used as a generator
    for this sequence as arguments. Thus, we can implement functions to generate random
    matrices using the clatrix and core.matrix libraries as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该使用 `rand-int` 函数映射 `square-mat` 函数生成的正方形矩阵的每个元素，为每个元素生成一个随机数。不幸的是，`cl/map`
    只能与由 clatrix 库创建的矩阵一起使用，但我们可以通过使用 `repeatedly` 函数返回的惰性序列轻松地复制这种行为。请注意，`repeatedly`
    函数接受一个惰性生成序列的长度和一个用作该序列生成器的函数作为参数。因此，我们可以实现使用 clatrix 和 core.matrix 库生成随机矩阵的函数如下：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This implementation works as expected, and each element of the new matrix is
    now an independently generated random number. We can verify this in the REPL by
    calling the following modified `rand-square-mat` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现按预期工作，新矩阵的每个元素现在都是一个独立生成的随机数。我们可以在 REPL 中通过调用以下修改后的 `rand-square-mat` 函数来验证这一点：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can also generate a matrix of random elements using the `cl/rnorm` function
    from the clatrix library. This function generates a matrix of normally distributed
    random elements with optionally specified mean and standard deviations. The matrix
    is normally distributed in the sense that all the elements are distributed evenly
    around the specified mean value with a spread specified by the standard deviation.
    Thus, a low standard deviation produces a set of values that are almost equal
    to the mean.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 clatrix 库中的 `cl/rnorm` 函数生成随机元素矩阵。这个函数生成一个具有可选指定均值和标准差的正态分布随机元素矩阵。矩阵是正态分布的，意味着所有元素都均匀分布在指定的均值周围，其分布由标准差指定。因此，低标准差会产生一组几乎等于均值的值。
- en: 'The `cl/rnorm` function has several overloads. Let''s examine a couple of them
    in the REPL:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`cl/rnorm` 函数有几个重载版本。让我们在 REPL 中检查其中几个：'
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, the first call specifies the mean, the standard deviation,
    and the number of rows and columns. The second call specifies a single argument
    *n* and produces a matrix of size ![Generating matrices](img/4351OS_01_09.jpg).
    Lastly, the third call specifies the number of rows and columns of the matrix.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一次调用指定了均值、标准差以及矩阵的行数和列数。第二次调用指定了一个单个参数 *n* 并生成一个 ![生成矩阵](img/4351OS_01_09.jpg)
    大小的矩阵。最后，第三次调用指定了矩阵的行数和列数。
- en: The core.matrix library also provides a `compute-matrix` function to generate
    matrices, and will feel idiomatic to Clojure programmers. This function requires
    a vector that represents the size of the matrix, and a function that takes a number
    of arguments that is equal to the number of dimensions of the matrix. In fact,
    `compute-matrix` is versatile enough to implement the generation of an identity
    matrix, as well as a matrix of randomly generated elements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.matrix`库还提供了一个`compute-matrix`函数来生成矩阵，这对Clojure程序员来说会感觉非常自然。此函数需要一个表示矩阵大小的向量，以及一个接受与矩阵维度数量相等的参数的函数。实际上，`compute-matrix`足够灵活，可以用来生成单位矩阵，以及随机元素矩阵。'
- en: 'We can implement the following functions to create an identity matrix, as well
    as a matrix of random elements using the `compute-matrix` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`compute-matrix`函数实现以下函数来创建单位矩阵以及随机元素矩阵：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Adding matrices
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加矩阵
- en: 'Operations on matrices are not directly supported by the Clojure language but
    are implemented through the core.matrix specification. Trying to add two matrices
    in the REPL, as shown in the following code snippet, simply throws an error stating
    that a vector was found where an integer was expected:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure语言不直接支持矩阵操作，但通过`core.matrix`规范实现。在REPL中尝试添加两个矩阵，如下面的代码片段所示，只会抛出一个错误，指出在期望整数的地方找到了向量：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is because the `+` function operates on numbers rather than matrices.
    To add matrices, we should use functions from the `core.matrix.operators` namespace.
    The namespace declaration should look like the following code snippet after we
    have included `core.matrix.operators`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`+`函数作用于数字而不是矩阵。要添加矩阵，我们应该使用`core.matrix.operators`命名空间中的函数。在包含`core.matrix.operators`之后，命名空间声明应该看起来像以下代码片段：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that the functions are actually imported into an aliased namespace, as
    function names such as `+` and `*` conflict with those in the default Clojure
    namespace. In practice, we should always try to use aliased namespaces via the
    `:require` and `:as` filters and avoid the `:use` filter. Alternatively, we could
    simply not refer to conflicting function names by using the `:refer-clojure` filter
    in the namespace declaration, which is shown in the following code. However, this
    should be used sparingly and only as a last resort.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些函数实际上被导入到一个别名命名空间中，因为像`+`和`*`这样的函数名与默认Clojure命名空间中的函数名冲突。在实践中，我们应该始终尝试通过`:require`和`:as`过滤器使用别名命名空间，并避免使用`:use`过滤器。或者，我们可以在命名空间声明中使用`:refer-clojure`过滤器简单地不引用冲突的函数名，如下面的代码所示。然而，这应该谨慎使用，并且仅作为最后的手段。
- en: 'For the code examples in this section, we will use the previous declaration
    for clarity:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节中的代码示例，我们将使用之前的声明以提高清晰度：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can use the `M/+` function to perform the matrix addition of two or more
    matrices. To check the equality of any number of matrices, we use the `M/==` function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`M/+`函数对两个或多个矩阵执行矩阵加法。要检查任意数量矩阵的相等性，我们使用`M/==`函数：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Two matrices *A* and *B* are said to be equal if the following equality holds
    true:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个矩阵 *A* 和 *B* 满足以下等式，则称它们是相等的：
- en: '![Adding matrices](img/4351OS_01_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![添加矩阵](img/4351OS_01_10.jpg)'
- en: 'Hence, the preceding equation explains that two or more matrices are equal
    if and only if the following conditions are satisfied:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的等式解释了两个或多个矩阵相等当且仅当满足以下条件：
- en: Each matrix has the same number of rows and columns
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个矩阵都有相同数量的行和列
- en: All elements with the same row and column indices are equal
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有具有相同行和列索引的元素都相等
- en: 'The following is a simple, yet elegant implementation of matrix equality. It''s
    basically comparing vector equality using the standard `reduce` and `map` functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单而优雅的矩阵相等实现。它基本上是使用标准的`reduce`和`map`函数比较向量相等性：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We first compare the row lengths of the two matrices using the `count` and `=`
    functions, and then use the `reduce` function to compare the inner vector elements.
    Essentially, the `reduce` function repeatedly applies a function that accepts
    two arguments to consecutive elements in a sequence and returns the final result
    when all the elements in the sequence have been *reduced* by the applied function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`count`和`=`函数比较两个矩阵的行长度，然后使用`reduce`函数比较内部向量元素。本质上，`reduce`函数反复将一个接受两个参数的函数应用于序列中的连续元素，并在序列中的所有元素都被应用函数“减少”后返回最终结果。
- en: Alternatively, we could use a similar composition using the `every?` and `true?`
    Clojure functions. Using the expression `(every? true? (map = A B))`, we can check
    the equality of two matrices. Keep in mind that the `true?` function returns `true`
    if it is passed `true` (and `false` otherwise), and the `every?` function returns
    `true` if a given predicate function returns `true` for all the values in a given
    sequence.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用类似的组合使用 `every?` 和 `true?` Clojure 函数。使用表达式 `(every? true? (map =
    A B))`，我们可以检查两个矩阵的相等性。请记住，`true?` 函数在传入 `true` 时返回 `true`（否则返回 `false`），而 `every?`
    函数在给定的谓词函数对给定序列中的所有值返回 `true` 时返回 `true`。
- en: 'To add two matrices, they must have an equal number of rows and columns, and
    the sum is essentially a matrix composed of the sum of elements with the same
    row and column indices. The sum of two matrices *A* and *B* has been formally
    defined as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要加两个矩阵，它们必须有相等数量的行和列，和本质上是一个由具有相同行和列索引的元素之和组成的矩阵。两个矩阵 *A* 和 *B* 的和已经正式定义为以下：
- en: '![Adding matrices](img/4351OS_01_11.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵加法](img/4351OS_01_11.jpg)'
- en: 'It''s almost trivial to implement matrix addition using the standard `mapv`
    function, which is simply a variant of the `map` function that returns a vector.
    We apply `mapv` to each row of the matrix as well as to the entire matrix. Note
    that this implementation is intended for a vector of vectors, although it can
    be easily used with the `matrix` and `as-vec` functions from core.matrix to operate
    on matrices. We can implement the following function to perform matrix addition
    using the standard `mapv` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的 `mapv` 函数实现矩阵加法几乎是显而易见的，它只是 `map` 函数的一个变体，返回一个向量。我们将 `mapv` 应用到矩阵的每一行以及整个矩阵上。请注意，此实现旨在用于向量（向量中的向量），尽管它可以很容易地与
    core.matrix 中的 `matrix` 和 `as-vec` 函数一起使用来操作矩阵。我们可以实现以下函数，使用标准 `mapv` 函数执行矩阵加法：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can just as easily generalize the `mat-add` function for any number of matrices
    by using the `reduce` function. As shown in the following code, we can extend
    the previous definition of `mat-add` to apply it to any number of matrices using
    the `reduce` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可以很容易地将 `mat-add` 函数推广到任意数量的矩阵，使用 `reduce` 函数。如下面的代码所示，我们可以扩展 `mat-add`
    的先前定义，使其使用 `reduce` 函数适用于任意数量的矩阵：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An interesting unary operation on a ![Adding matrices](img/4351OS_01_06.jpg)
    matrix *A* is the trace of a matrix, represented as ![Adding matrices](img/4351OS_01_12.jpg).
    The trace of a matrix is essentially the sum of its diagonal elements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 ![矩阵加法](img/4351OS_01_06.jpg) 矩阵 *A* 上有一个有趣的单一运算，即矩阵的迹，表示为 ![矩阵加法](img/4351OS_01_12.jpg)。矩阵的迹本质上是其对角元素的求和：
- en: '![Adding matrices](img/4351OS_01_13.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵加法](img/4351OS_01_13.jpg)'
- en: It's fairly simple enough to implement the trace function of a matrix using
    the `cl/map-indexed` and `repeatedly` functions as described earlier. We have
    skipped it here to serve as an exercise for you.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面描述的 `cl/map-indexed` 和 `repeatedly` 函数实现矩阵的迹函数相当简单。我们在这里省略了它，以便作为你的练习。
- en: Multiplying matrices
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: Multiplication is another important binary operation on matrices. In the broader
    sense, the term **matrix multiplication** refers to several techniques that multiply
    matrices to produce a new matrix.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法是矩阵上的另一个重要二元运算。在更广泛的意义上，**矩阵乘法**这一术语指的是几种将矩阵相乘以产生新矩阵的技术。
- en: 'Let''s define three matrices, *A*, *B*, and *C*, and a single value *N*, in
    the REPL. The matrices have the following values:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 REPL 中定义三个矩阵 *A*、*B* 和 *C* 以及一个单一值 *N*。这些矩阵具有以下值：
- en: '![Multiplying matrices](img/4351OS_01_14.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_14.jpg)'
- en: 'We can multiply the matrices by using the `M/*` function from the core.matrix
    library. Apart from being used to multiply two matrices, this function can also
    be used to multiply any number of matrices, and scalar values as well. We can
    try out the following `M/*` function to multiply two given matrices in the REPL:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 core.matrix 库中的 `M/*` 函数来乘以矩阵。除了用于乘以两个矩阵外，此函数还可以用于乘以任意数量的矩阵以及标量值。我们可以在
    REPL 中尝试以下 `M/*` 函数来乘以两个给定的矩阵：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, we calculated the product of two matrices. This operation is termed
    as **matrix-matrix multiplication**. However, multiplying matrices *A* and *C*
    doesn''t work, as the matrices have incompatible sizes. This brings us to the
    first rule of multiplying matrices: to multiply two matrices *A* and *B*, the
    number of columns in *A* have to be equal to the number of rows in *B*. The resultant
    matrix has the same number of rows as *A* and columns as *B*. That''s the reason
    the REPL didn''t agree to multiply *A* and *C*, but simply threw an exception.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算了两个矩阵的乘积。这个操作被称为**矩阵-矩阵乘法**。然而，矩阵 *A* 和 *C* 的乘法是不行的，因为这两个矩阵的大小不兼容。这把我们带到了矩阵乘法的第一个规则：要乘以两个矩阵
    *A* 和 *B*，*A* 中的列数必须等于 *B* 中的行数。结果矩阵具有与 *A* 相同的行数和与 *B* 相同的列数。这就是为什么 REPL 不同意乘以
    *A* 和 *C*，而是简单地抛出一个异常。
- en: For matrix *A* of size ![Multiplying matrices](img/4351OS_01_15.jpg), and *B*
    of size ![Multiplying matrices](img/4351OS_01_16.jpg), the product of the two
    matrices only exists if ![Multiplying matrices](img/4351OS_01_17.jpg), and the
    product of *A* and *B* is a new matrix of size ![Multiplying matrices](img/4351OS_01_18.jpg).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大小为![矩阵乘法](img/4351OS_01_15.jpg)的矩阵 *A* 和大小为![矩阵乘法](img/4351OS_01_16.jpg)的矩阵
    *B*，这两个矩阵的乘积只有在![矩阵乘法](img/4351OS_01_17.jpg)的情况下才存在，而 *A* 和 *B* 的乘积是一个大小为![矩阵乘法](img/4351OS_01_18.jpg)的新矩阵。
- en: The product of matrices *A* and *B* is calculated by multiplying the elements
    of rows in *A* with the corresponding columns in *B*, and then adding the resulting
    values to produce a single value for each row in *A* and each column in *B*. Hence,
    the resulting product has the same number of rows as *A* and columns as *B*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 *A* 和 *B* 的乘积是通过将 *A* 中行的元素与 *B* 中相应的列相乘，然后将结果值相加，为 *A* 的每一行和 *B* 的每一列产生一个单一值来计算的。因此，结果乘积具有与
    *A* 相同的行数和与 *B* 相同的列数。
- en: 'We can define the product of two matrices with compatible sizes as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义两个兼容大小的矩阵的乘积：
- en: '![Multiplying matrices](img/4351OS_01_19.jpg)![Multiplying matrices](img/4351OS_01_20.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_19.jpg)![矩阵乘法](img/4351OS_01_20.jpg)'
- en: 'The following is an illustration of how the elements from *A* and *B* are used
    to calculate the product of the two matrices:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用 *A* 和 *B* 中的元素来计算两个矩阵的乘积的说明：
- en: '![Multiplying matrices](img/4351OS_01_01.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_01.jpg)'
- en: 'This does look slightly complicated, so let''s demonstrate the preceding definition
    with an example, using the matrices *A* and *B* as we had previously defined.
    The following calculation does, in fact, agree to the value produced in the REPL:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来稍微有些复杂，所以让我们用一个例子来演示前面的定义，使用我们之前定义的矩阵 *A* 和 *B*。以下计算实际上与 REPL 产生的值一致：
- en: '![Multiplying matrices](img/4351OS_01_22.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_22.jpg)'
- en: 'Note that multiplying matrices is not a commutative operation. However, the
    operation does exhibit the associative property of functions. For matrices *A*,
    *B*, and *C* of product-compatible sizes, the following properties are always
    true, with one exception that we will uncover later:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，矩阵乘法不是交换运算。然而，这个操作确实表现出函数的关联性质。对于乘积兼容大小的矩阵 *A*、*B* 和 *C*，以下性质始终成立，只有一个例外，我们稍后会揭露：
- en: '![Multiplying matrices](img/4351OS_01_23.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_23.jpg)'
- en: An obvious corollary is that a square matrix when multiplied with another square
    matrix of the same size produces a resultant matrix that has the same size as
    the two original matrices. Also, the square, cube, and other powers of a square
    matrix results in matrices of the same size.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的推论是，一个方阵与另一个相同大小的方阵相乘会产生一个结果矩阵，其大小与两个原始矩阵相同。同样，方阵的平方、立方以及其他幂次运算会产生相同大小的矩阵。
- en: 'Another interesting property of square matrices is that they have an identity
    element for multiplication, that is, an identity matrix of product-compatible
    size. But, an identity matrix is itself a square matrix, which brings us to the
    conclusion that *the multiplication of a square matrix with an identity matrix
    is a commutative operation*. Hence, the commutative rule for matrices, which states
    that matrix multiplication is not commutative, is actually not true when one of
    the matrices is an identity matrix and the other one is a square matrix. This
    can be formally summarized by the following equality:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的性质是，方阵在乘法中有一个单位元素，即与乘积兼容大小的单位矩阵。但是，单位矩阵本身也是一个方阵，这使我们得出结论，*方阵与单位矩阵的乘法是一个交换操作*。因此，矩阵乘法不是交换的规则实际上在其中一个矩阵是单位矩阵而另一个是方阵时并不成立。这可以由以下等式形式化总结：
- en: '![Multiplying matrices](img/4351OS_01_24.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_24.jpg)'
- en: A naïve implementation of matrix multiplication would have a time complexity
    of ![Multiplying matrices](img/4351OS_01_25.jpg), and requires eight multiplication
    operations for a ![Multiplying matrices](img/4351OS_01_26.jpg) matrix. By time
    complexity, we mean the time taken by a particular algorithm to run till completion.
    Hence, linear algebra libraries use more efficient algorithms, such as *Strassen's
    algorithm*, to implement matrix multiplication, which needs only seven multiplication
    operations and reduces the complexity to ![Multiplying matrices](img/4351OS_01_27.jpg).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法的简单实现的时间复杂度为![矩阵乘法](img/4351OS_01_25.jpg)，对于一个![矩阵乘法](img/4351OS_01_26.jpg)矩阵需要八个乘法操作。时间复杂度指的是特定算法运行到完成所需的时间。因此，线性代数库使用更有效的算法，如*Strassen算法*，来实现矩阵乘法，该算法只需要七个乘法操作，并将复杂度降低到![矩阵乘法](img/4351OS_01_27.jpg)。
- en: The clatrix library implementation for matrix multiplication performs significantly
    better than the default persistent vector implementation, since it interfaces
    with native libraries. In practice, we can use a benchmarking library such as
    criterium for Clojure ([http://github.com/hugoduncan/criterium](http://github.com/hugoduncan/criterium))
    to perform this comparison. Alternatively, we can also compare the performance
    of these two implementations in brief by defining a simple function to multiply
    two matrices and then passing large matrices of different implementations to it
    using our previously defined `rand-square-mat` and `rand-square-clmat` functions.
    We can define a function to measure the time taken to multiply two matrices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Clatrix库对矩阵乘法的实现性能显著优于默认的持久向量实现，因为它与本地库进行了接口。在实践中，我们可以使用像criterium这样的基准测试库来对Clojure进行此比较（[http://github.com/hugoduncan/criterium](http://github.com/hugoduncan/criterium)）。或者，我们也可以通过定义一个简单的函数来乘以两个矩阵，然后使用我们之前定义的`rand-square-mat`和`rand-square-clmat`函数将不同实现的大矩阵传递给它，简要比较这两种实现的性能。我们可以定义一个函数来测量乘以两个矩阵所需的时间。
- en: 'Also, we can define two functions to multiply the matrices that were created
    using the `rand-square-mat` and `rand-square-clmat` functions that we previously
    defined, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以定义两个函数来乘以使用我们之前定义的`rand-square-mat`和`rand-square-clmat`函数创建的矩阵，如下所示：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see that the core.matrix implementation takes a second on average to
    compute the product of two randomly generated matrices. The clatrix implementation,
    however, takes less than a millisecond on average, although the first call that's
    made usually takes 35 to 40 ms to load the native BLAS library. Of course, this
    value could be slightly different depending on the hardware it's calculated on.
    Nevertheless, clatrix is preferred when dealing with large matrices unless there's
    a valid reason, such as hardware incompatibilities or the avoidance of an additional
    dependency, to avoid its usage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，core.matrix实现平均需要一秒钟来计算两个随机生成矩阵的乘积。然而，clatrix实现平均不到一毫秒，尽管第一次调用的通常需要35到40毫秒来加载本地BLAS库。当然，这个值可能会根据计算它的硬件略有不同。尽管如此，除非有有效的理由，例如硬件不兼容或避免额外的依赖，否则在处理大型矩阵时，clatrix是首选。
- en: 'Next, let''s look at *scalar multiplication*, which involves simply multiplying
    a single value *N* or a scalar with a matrix. The resultant matrix has the same
    size as the original matrix. For a 2 x 2 matrix, we can define scalar multiplication
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 *标量乘法*，它涉及将单个值 *N* 或标量与矩阵相乘。结果矩阵的大小与原始矩阵相同。对于一个 2 x 2 矩阵，我们可以定义标量乘法如下：
- en: '![Multiplying matrices](img/4351OS_01_28.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_28.jpg)'
- en: 'For matrices ![Multiplying matrices](img/4351OS_01_29.jpg) and ![Multiplying
    matrices](img/4351OS_01_30.jpg), the following is the product:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵 ![矩阵乘法](img/4351OS_01_29.jpg) 和 ![矩阵乘法](img/4351OS_01_30.jpg)，其乘积如下：
- en: '![Multiplying matrices](img/4351OS_01_31.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_31.jpg)'
- en: 'Note that we can also use the `scale` function from the core.matrix library
    to perform scalar multiplication:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还可以使用 core.matrix 库中的 `scale` 函数来执行标量乘法：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, we will briefly take a look at a special form of matrix multiplication,
    termed as **matrix-vector multiplication**. A vector is simply a matrix with a
    single row, which on multiplication with a square matrix of product-compatible
    size produces a new vector with the same size as the original vector. After multiplying
    a matrix *A* of size ![Multiplying matrices](img/4351OS_01_32.jpg) and the transpose
    *V'* of a vector *V*, of size ![Multiplying matrices](img/4351OS_01_33.jpg), a
    new vector *V"* of size ![Multiplying matrices](img/4351OS_01_34.jpg) is produced.
    If *A* is a square matrix, then *V"* has an identical size as that of the transpose
    *V'*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要地看一下矩阵乘法的一种特殊形式，称为 **矩阵-向量乘法**。向量可以简单地看作是一个只有一行的矩阵，它与大小与乘积兼容的方阵相乘，产生一个与原始向量大小相同的新向量。将大小为
    ![矩阵乘法](img/4351OS_01_32.jpg) 的矩阵 *A* 和向量 *V* 的转置 *V'*（大小为 ![矩阵乘法](img/4351OS_01_33.jpg)）相乘，产生一个大小为
    ![矩阵乘法](img/4351OS_01_34.jpg) 的新向量 *V"*。如果 *A* 是一个方阵，那么 *V"* 的大小与转置 *V'* 相同。
- en: '![Multiplying matrices](img/4351OS_01_35.jpg)![Multiplying matrices](img/4351OS_01_36.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵乘法](img/4351OS_01_35.jpg)![矩阵乘法](img/4351OS_01_36.jpg)'
- en: Transposing and inverting matrices
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵转置和求逆
- en: 'Another frequently used elementary matrix operation is the *transpose* of a
    matrix. The transpose of a matrix *A* is represented as ![Transposing and inverting
    matrices](img/4351OS_01_37.jpg) or ![Transposing and inverting matrices](img/4351OS_01_38.jpg).
    A simple way to define the transpose of a matrix is by reflecting the matrix over
    its *prime diagonal*. By prime diagonal, we mean the diagonal comprising elements
    whose row and column indices are equal. We can also describe the transpose of
    a matrix by swapping of the rows and columns of a matrix. We can use the following
    `transpose` function from core.matrix to perform this operation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的基本矩阵操作是矩阵的 *转置*。矩阵 *A* 的转置表示为 ![矩阵转置和求逆](img/4351OS_01_37.jpg) 或 ![矩阵转置和求逆](img/4351OS_01_38.jpg)。定义矩阵转置的一个简单方法是通过反射矩阵到其
    *主对角线*。主对角线是指由行和列索引相等的元素组成的对角线。我们还可以通过交换矩阵的行和列来描述矩阵的转置。我们可以使用 core.matrix 中的以下
    `transpose` 函数来执行此操作：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can define the following three possible ways to obtain the transpose of
    a matrix:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义以下三种获取矩阵转置的可能方法：
- en: The original matrix is reflected over its main diagonal
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始矩阵沿主对角线进行反射
- en: The rows of the matrix become the columns of its transpose
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的行变成其转置的列
- en: The columns of the matrix become the rows of its transpose
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵的列变成其转置的行
- en: 'Hence, every element in a matrix has its row and column swapped in its transpose,
    and vice versa. This can be formally represented using the following equation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，矩阵中的每个元素在其转置中行和列都交换了，反之亦然。这可以用以下方程正式表示：
- en: '![Transposing and inverting matrices](img/4351OS_01_39.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵转置和求逆](img/4351OS_01_39.jpg)'
- en: 'This brings us to the notion of an invertible matrix. A square matrix is said
    to be invertible if there exists another square matrix that is the inverse of
    a matrix, and which produces an identity matrix when multiplied with the original
    matrix. A matrix *A* of size ![Transposing and inverting matrices](img/4351OS_01_06.jpg),
    is said to have an inverse matrix *B* if the following equality is true:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了可逆矩阵的概念。如果一个方阵存在另一个方阵作为其逆矩阵，并且与原矩阵相乘时产生单位矩阵，则称该方阵是可逆的。一个大小为 ![矩阵转置和求逆](img/4351OS_01_06.jpg)
    的矩阵 *A*，如果以下等式成立，则称其有一个逆矩阵 *B*：
- en: '![Transposing and inverting matrices](img/4351OS_01_41.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵转置和求逆](img/4351OS_01_41.jpg)'
- en: 'Let''s test this equality using the `inverse` function from core.matrix. Note
    that the default persistent implementation of the core.matrix library does not
    implement the inverse operation, so we use a matrix from the clatrix library instead.
    In the following example, we create a matrix from the clatrix library using the
    `cl/matrix` function, determine its inverse using the `inverse` function, and
    multiply these two matrices using the `M/*` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 core.matrix 的 `inverse` 函数来测试这个等式。请注意，core.matrix 库的默认持久实现没有实现逆操作，所以我们使用
    clatrix 库中的矩阵。在以下示例中，我们使用 `cl/matrix` 函数从 clatrix 库创建一个矩阵，使用 `inverse` 函数确定其逆，然后使用
    `M/*` 函数将这两个矩阵相乘：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding example, we first define a matrix *A* and then multiply it
    with its inverse to produce the corresponding identity matrix. An interesting
    observation when we use double precision numeric types for the elements in a matrix
    is that not all matrices produce an identity matrix on multiplication with their
    inverse.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先定义了一个矩阵 *A*，然后将其与其逆矩阵相乘以产生相应的单位矩阵。当我们使用双精度数值类型作为矩阵的元素时，一个有趣的观察是，并非所有矩阵与它们的逆矩阵相乘都会产生单位矩阵。
- en: 'A small amount of error can be observed for some matrices, and this happens
    due to the limitations of using a 32-bit representation for floating-point numbers;
    this is shown as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些矩阵，可以观察到一些小的误差，这是由于使用 32 位表示浮点数的限制造成的；如下所示：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In order to find the inverse of a matrix, we must first define the *determinant*
    of that matrix, which is simply another value determined from a given matrix.
    First off, determinants only exist for square matrices, and thus, inverses only
    exist for matrices with an equal number of rows and columns. The determinant of
    a matrix is represented as ![Transposing and inverting matrices](img/4351OS_01_42.jpg)
    or ![Transposing and inverting matrices](img/4351OS_01_43.jpg). A matrix whose
    determinant is zero is termed as a *singular matrix*. For a matrix *A*, we define
    its determinant as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到一个矩阵的逆，我们首先必须定义该矩阵的 *行列式*，这仅仅是从给定矩阵中确定的一个值。首先，行列式仅存在于方阵中，因此，逆矩阵仅存在于行数和列数相等的矩阵中。矩阵的行列式表示为
    ![矩阵的转置和求逆](img/4351OS_01_42.jpg) 或 ![矩阵的转置和求逆](img/4351OS_01_43.jpg)。行列式为零的矩阵被称为
    *奇异矩阵*。对于一个矩阵 *A*，我们定义其行列式如下：
- en: '![Transposing and inverting matrices](img/4351OS_01_44.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵的转置和求逆](img/4351OS_01_44.jpg)'
- en: 'We can use the preceding definitions to express the determinant of a matrix
    of any size. An interesting observation is that the determinant of an identity
    matrix is always *1*. As an example, we will find the determinant of a given matrix
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的定义来表示任何大小的矩阵的行列式。一个有趣的观察是，单位矩阵的行列式始终是 *1*。作为一个例子，我们将如下找到给定矩阵的行列式：
- en: '![Transposing and inverting matrices](img/4351OS_01_45.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵的转置和求逆](img/4351OS_01_45.jpg)'
- en: 'For a ![Transposing and inverting matrices](img/4351OS_01_46.jpg) matrix, we
    can use *Sarrus'' rule* as an alternative means to calculate the determinant of
    a matrix. To find the determinant of a matrix using this scheme, we first write
    out the first two columns of the matrix to the right of the third column, so that
    there are five columns in a row. Next, we add the products of the diagonals going
    from top to bottom, and subtract the products of diagonals from bottom. This process
    can be illustrated using the following diagram:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个 ![矩阵的转置和求逆](img/4351OS_01_46.jpg) 矩阵，我们可以使用 *萨鲁斯规则* 作为计算矩阵行列式的另一种方法。要使用此方案计算矩阵的行列式，我们首先将矩阵的前两列写在第三列的右侧，使得一行中有五列。接下来，我们加上从上到下对角线的乘积，并减去从下到上对角线的乘积。这个过程可以用以下图表说明：
- en: '![Transposing and inverting matrices](img/4351OS_01_03.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵的转置和求逆](img/4351OS_01_03.jpg)'
- en: 'By using Sarrus'' rule, we formally express the determinant of a matrix *A*
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用萨鲁斯规则，我们正式地将矩阵 *A* 的行列式表达如下：
- en: '![Transposing and inverting matrices](img/4351OS_01_48.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵的转置和求逆](img/4351OS_01_48.jpg)'
- en: We can calculate the determinant of a matrix in the REPL using the following
    `det` function from core.matrix. Note that this operation is not implemented by
    the default persistent vector implementation of core.matrix.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 core.matrix 的以下 `det` 函数在 REPL 中计算矩阵的行列式。请注意，此操作不是由 core.matrix 的默认持久向量实现实现的。
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we've defined the determinant of a matrix, let's use it to define the
    inverse of a matrix. We've already discussed the notion of an invertible matrix;
    finding the inverse of a matrix is simply determining a matrix such that it produces
    an identity matrix when multiplied with the original matrix.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了矩阵的行列式，让我们用它来定义矩阵的逆。我们已经讨论了可逆矩阵的概念；找到矩阵的逆就是确定一个矩阵，当它与原矩阵相乘时会产生一个单位矩阵。
- en: 'For the inverse of a matrix to exist, its determinant must be nonzero. Next,
    for each element in the original matrix, we find the determinant of the matrix
    without the row and column of the selected element. This produces a matrix of
    an identical size as that of the original matrix (termed as the *cofactor matrix*
    of the original matrix). The transpose of the cofactor matrix is called the *adjoint*
    of the original matrix. The adjoint produces the inverse on dividing it by the
    determinant of the original matrix. Now, let''s formally define the inverse of
    a ![Transposing and inverting matrices](img/4351OS_01_26.jpg) matrix *A*. We denote
    the inverse of a matrix *A* as ![Transposing and inverting matrices](img/4351OS_01_49.jpg),
    and it can be formally expressed as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵的逆存在，其行列式必须不为零。接下来，对于原矩阵中的每个元素，我们找到去掉所选元素的行和列的矩阵的行列式。这会产生一个与原矩阵大小相同的矩阵（称为原矩阵的*余子式矩阵*）。余子式矩阵的转置称为原矩阵的*伴随矩阵*。通过将伴随矩阵除以原矩阵的行列式，可以得到逆矩阵。现在，让我们正式定义一个
    ![矩阵转置和求逆](img/4351OS_01_26.jpg) 矩阵 *A* 的逆。我们用 ![矩阵转置和求逆](img/4351OS_01_49.jpg)
    表示矩阵 *A* 的逆，它可以正式表示如下：
- en: '![Transposing and inverting matrices](img/4351OS_01_50.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵转置和求逆](img/4351OS_01_50.jpg)'
- en: 'As an example, let''s find the inverse of a sample ![Transposing and inverting
    matrices](img/4351OS_01_26.jpg) matrix. We can actually verify that the inverse
    produces an identity matrix when multiplied with the original matrix, as shown
    in the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说明，让我们找到一个样本 ![矩阵转置和求逆](img/4351OS_01_26.jpg) 矩阵的逆。实际上，我们可以验证，当与原矩阵相乘时，逆矩阵会产生一个单位矩阵，如下面的例子所示：
- en: '![Transposing and inverting matrices](img/4351OS_01_51.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵转置和求逆](img/4351OS_01_51.jpg)'
- en: 'Similarly, we define the inverse of a ![Transposing and inverting matrices](img/4351OS_01_46.jpg)
    matrix as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们按照以下方式定义一个 ![矩阵转置和求逆](img/4351OS_01_46.jpg) 矩阵的逆：
- en: '![Transposing and inverting matrices](img/4351OS_01_52.jpg)![Transposing and
    inverting matrices](img/4351OS_01_53.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵转置和求逆](img/4351OS_01_52.jpg)![矩阵转置和求逆](img/4351OS_01_53.jpg)'
- en: 'Now, let''s calculate the inverse of a ![Transposing and inverting matrices](img/4351OS_01_46.jpg)
    matrix:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们计算一个 ![矩阵转置和求逆](img/4351OS_01_46.jpg) 矩阵的逆：
- en: '![Transposing and inverting matrices](img/4351OS_01_54.jpg)![Transposing and
    inverting matrices](img/4351OS_01_55.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵转置和求逆](img/4351OS_01_54.jpg)![矩阵转置和求逆](img/4351OS_01_55.jpg)'
- en: 'We''ve mentioned that singular and nonsquare matrices don''t have inverses,
    and we can see that the `inverse` function throws an error when supplied with
    such a matrix. As shown in the following REPL output, the `inverse` function will
    throw an error if the given matrix is not a square matrix, or if the given matrix
    is singular:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到奇异和非方阵没有逆，我们可以看到当`inverse`函数接收到这样的矩阵时，会抛出错误。如下面的REPL输出所示，如果给定的矩阵不是方阵，或者给定的矩阵是奇异的，`inverse`函数将抛出错误：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Interpolating using matrices
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用矩阵进行插值
- en: Let's try out an example to demonstrate how we use matrices. This example uses
    matrices to interpolate a curve between a given set of points. Suppose we have
    a given set of points representing some data. The objective is to trace a smooth
    line between the points in order to produce a curve that estimates the shape of
    the data. Although the mathematical formulae in this example may seem difficult,
    we should know that this technique is actually just a form of regularization for
    a linear regression model, and is termed as **Tichonov regularization**. For now,
    we'll focus on how to use matrices in this technique, and we shall revisit regularization
    in depth in [Chapter 2](ch02.html "Chapter 2. Understanding Linear Regression"),
    *Understanding Linear Regression*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个示例来演示我们如何使用矩阵。这个例子使用矩阵在给定的一组点之间插值曲线。假设我们有一个代表某些数据的给定点集。目标是追踪点之间的平滑线，以产生一个估计数据形状的曲线。尽管这个例子中的数学公式可能看起来很复杂，但我们应该知道，这种技术实际上只是线性回归模型正则化的一种形式，被称为
    **Tichonov 正则化**。现在，我们将专注于如何在这个技术中使用矩阵，我们将在第2章 [理解线性回归](ch02.html "Chapter 2. Understanding
    Linear Regression") 中深入探讨正则化。
- en: 'We will first define an interpolation matrix *L* that can be used to determine
    an estimated curve of the given data points. It''s essentially the vector *[-1,
    2, -1]* moving diagonally across the columns of the matrix. This kind of a matrix
    is called a **band matrix**:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个插值矩阵 *L*，它可以用来确定给定数据点的估计曲线。它本质上是一个向量 *[-1, 2, -1]* 在矩阵的列中斜向移动。这种矩阵被称为
    **带宽矩阵**：
- en: '![Interpolating using matrices](img/4351OS_01_56.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![使用矩阵进行插值](img/4351OS_01_56.jpg)'
- en: 'We can concisely define the matrix *L* using the following `compute-matrix`
    function. Note that for a given size *n*, we generate a matrix of size ![Interpolating
    using matrices](img/4351OS_01_57.jpg):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 `compute-matrix` 函数简洁地定义矩阵 *L*。注意，对于给定的大小 *n*，我们生成一个大小如 ![使用矩阵进行插值](img/4351OS_01_57.jpg)
    的矩阵：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The anonymous closure in the preceding example uses a map to decide the value
    of an element at a specified row and column index. For example, the element at
    row index *2* and column index *3* is *2*, since `(- j i)` is *1* and the key
    *1* in the map has *2* as its value. We can verify that the generated matrix has
    a similar structure as that of the matrix `lmatrix` through the REPL as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，匿名闭包使用一个映射来决定指定行和列索引处的元素值。例如，行索引 *2* 和列索引 *3* 的元素是 *2*，因为 `(- j i)`
    是 *1*，映射中的键 *1* 的值是 *2*。我们可以通过以下方式在REPL中验证生成的矩阵与 `lmatrix` 矩阵具有相似的结构：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Next, we define how to represent the data points that we intend to interpolate
    over. Each point has an observed value *x* that is passed to some function to
    produce another observed value *y*. For this example, we simply choose a random
    value for *x* and another random value for *y*. We perform this repeatedly to
    produce the data points.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义如何表示我们打算进行插值的数值点。每个点都有一个观测值 *x*，它被传递给某个函数以产生另一个观测值 *y*。在这个例子中，我们简单地为一个
    *x* 选择一个随机值，并为 *y* 选择另一个随机值。我们重复执行此操作以产生数据点。
- en: In order to represent the data points along with an *L* matrix of compatible
    size, we define the following simple function named `problem` that returns a map
    of the problem definition. This comprises the *L* matrix, the observed values
    for *x*, the hidden values of *x* for which we have to estimate values of *y*
    to create a curve, and the observed values for *y*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示与兼容大小的 *L* 矩阵一起的数据点，我们定义了一个名为 `problem` 的简单函数，该函数返回问题定义的映射。这包括 *L* 矩阵、*x*
    的观测值、*x* 的隐藏值（对于这些值，我们必须估计 *y* 的值以创建曲线），以及 *y* 的观测值。
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first two parameters of the function are the number of rows `n` in the *L*
    matrix, and the number of observed *x* values `n-observed`. The function takes
    a third argument `lambda`, which is actually the regularization parameter for
    our model. This parameter determines how accurate the estimated curve is, and
    we shall study more about how it's relevant to this model in the later chapters.
    In the map returned by the preceding function, the observed values for *x* and
    *y* have keys `:observed` and `:observed-values`, and the hidden values for *x*
    have the key `:hidden`. Similarly, the key `:L` is mapped to an *L* matrix of
    compatible size.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的前两个参数是 *L* 矩阵中的行数 `n` 和观测的 *x* 值数 `n-observed`。函数接受第三个参数 `lambda`，这实际上是我们的模型的正则化参数。此参数决定了估计曲线的准确性，我们将在后面的章节中更详细地研究它与此模型的相关性。在前面的函数返回的映射中，*x*
    和 *y* 的观测值具有键 `:observed` 和 `:observed-values`，而 *x* 的隐藏值具有键 `:hidden`。同样，键 `:L`
    映射到兼容大小的 *L* 矩阵。
- en: Now that we've defined our problem (or model), we can plot a smooth curve over
    the given points. By *smooth*, we mean that each point in the curve is the average
    of its immediate neighbors, along with some Gaussian noise. Thus, all the points
    on the curve of this noise have a Gaussian distribution, in which all the values
    are scattered about some mean value along with a spread specified by some standard
    deviation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的问题（或模型），我们可以在给定的点上绘制一条平滑的曲线。这里的“平滑”是指曲线上的每个点都是其直接邻居的平均值，以及一些高斯噪声。因此，所有这些噪声曲线上的点都服从高斯分布，其中所有值都围绕某个平均值散布，并带有由某个标准差指定的范围。
- en: 'If we partition matrix *L* into ![Interpolating using matrices](img/4351OS_01_58.jpg)
    and ![Interpolating using matrices](img/4351OS_01_59.jpg) over the observed and
    hidden points respectively, we can define a formula to determine the curve as
    follows. The following equation may seem a bit daunting, but as mentioned earlier,
    we shall study the reasoning behind this equation in the following chapters. The
    curve can be represented by a matrix that can be calculated as follows, using
    the matrix *L*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将矩阵 *L* 分别在观测点和隐藏点上进行 ![使用矩阵进行插值](img/4351OS_01_58.jpg) 和 ![使用矩阵进行插值](img/4351OS_01_59.jpg)
    的划分，我们可以定义一个公式来确定曲线如下。以下方程可能看起来有些令人畏惧，但如前所述，我们将在接下来的章节中研究这个方程背后的推理。曲线可以用一个矩阵来表示，该矩阵可以通过以下方式计算，使用矩阵
    *L*：
- en: '![Interpolating using matrices](img/4351OS_01_60.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![使用矩阵进行插值](img/4351OS_01_60.jpg)'
- en: We estimate the observed values for the hidden values of *x* as ![Interpolating
    using matrices](img/4351OS_01_62.jpg), using the originally observed values of
    *y*, that is, ![Interpolating using matrices](img/4351OS_01_63.jpg) and the two
    matrices that are calculated from the interpolation matrix *L*. These two matrices
    are calculated using only the transpose and inverse functions of a matrix. As
    all the values on the right-hand side of this equation are either matrices or
    vectors, we use matrix multiplication to find the product of these values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用原始观测的 *y* 值，即 ![使用矩阵进行插值](img/4351OS_01_62.jpg)，来估计隐藏的 *x* 值，使用从插值矩阵 *L*
    计算出的两个矩阵。这两个矩阵仅使用矩阵的转置和逆函数来计算。由于此方程右侧的所有值要么是矩阵要么是向量，我们使用矩阵乘法来找到这些值的乘积。
- en: 'The previous equation can be implemented using the functions that we''ve explored
    earlier. In fact, the code comprises just this equation written as a prefix expression
    for the map returned by the `problem` function that we defined previously. We
    now define the following function to solve the problem returned by the `problem`
    function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方程可以使用我们之前探索过的函数来实现。实际上，代码只包含这个方程，以作为我们之前定义的 `problem` 函数返回的映射的前缀表达式。我们现在定义以下函数来解决
    `problem` 函数返回的问题：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding function calculates the estimated values for *y* and simply adds
    them to the original map with the key `:hidden-values` using the `assoc` function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数计算了 *y* 的估计值，并简单地使用 `assoc` 函数将它们添加到原始映射中，键为 `:hidden-values`。
- en: It's rather difficult to mentally visualize the calculated values of the curve,
    so we will now use the *Incanter* library ([http://github.com/liebke/incanter](http://github.com/liebke/incanter))
    to plot the estimated curve and the original points. This library essentially
    provides a simple and idiomatic API to create and view various types of plots
    and charts.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要在心理上可视化曲线的计算值相当困难，因此我们现在将使用 *Incanter* 库（[http://github.com/liebke/incanter](http://github.com/liebke/incanter)）来绘制估计曲线和原始点。这个库本质上提供了一个简单且符合习惯的
    API 来创建和查看各种类型的图表和图表。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Incanter library can be added to a Leiningen project by adding the following
    dependency to the `project.clj` file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `project.clj` 文件中添加以下依赖项将 Incanter 库添加到 Leiningen 项目中：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For the upcoming example, the namespace declaration should look similar to
    the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于即将到来的示例，命名空间声明应类似于以下内容：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We now define a simple function that will plot a graph of the given data using
    functions, such as `xy-plot` and `view`, from the Incanter library:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个简单的函数，它将使用 Incanter 库中的函数，如 `xy-plot` 和 `view`，来绘制给定数据的图表：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As this is our first encounter with the Incanter library, let''s discuss some
    of the functions that are used to implement `plot-points`. We first bind all the
    values on the *x* axis to `X`, and all values on the *y* axis to `Y`. Then, we
    plot the points as a curve using the `xy-plot` function, which takes two sets
    of values to plot on the *x* and *y* axes as arguments and returns a chart or
    plot. Next, we add the originally observed points to the plot using the `add-points`
    function. The `add-points` function requires three arguments: the original plot,
    a vector of all the values of the *x* axis component, and a vector of all the
    values of the *y* axis component. This function also returns a plot such as the
    `xy-plot` function, and we can view this plot using the `view` function. Note
    that we could have equivalently used the thread macro (`->`) to compose the `xy-plot`,
    `add-points`, and `view` functions.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们第一次接触 Incanter 库，让我们讨论一些用于实现 `plot-points` 的函数。我们首先将所有 *x* 轴上的值绑定到 `X`，将所有
    *y* 轴上的值绑定到 `Y`。然后，我们使用 `xy-plot` 函数将点绘制为曲线，该函数接受两个参数，用于在 *x* 和 *y* 轴上绘制，并返回一个图表或图表。接下来，我们使用
    `add-points` 函数将原始观察到的点添加到图表中。`add-points` 函数需要三个参数：原始图表、*x* 轴组件的所有值的向量，以及 *y*
    轴组件的所有值的向量。此函数也返回一个类似于 `xy-plot` 函数的图表，我们可以使用 `view` 函数查看此图表。请注意，我们也可以等效地使用线程宏（`->`）来组合
    `xy-plot`、`add-points` 和 `view` 函数。
- en: 'Now, we can intuitively visualize the estimated curve using the `plot-points`
    function on some random data as shown in the following function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以直观地使用 `plot-points` 函数在随机数据上可视化估计曲线，如下面的函数所示：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When we execute the `plot-rand-sample` function, the following plot of the
    values is displayed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `plot-rand-sample` 函数时，会显示以下值的图表：
- en: '![Interpolating using matrices](img/4351OS_01_02.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![使用矩阵进行插值](img/4351OS_01_02.jpg)'
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we introduced matrices through the core.matrix and clatrix
    libraries. The following are the points that we covered:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过 core.matrix 和 clatrix 库介绍了矩阵。以下是我们所涵盖的要点：
- en: We've discussed how to represent, print, and fetch information from matrices
    through core.matrix and clatrix. We've also discussed how we can generate matrices
    with some random data.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何通过 core.matrix 和 clatrix 来表示、打印和从矩阵中获取信息。我们还讨论了如何使用一些随机数据生成矩阵。
- en: We've talked about some of the rudimentary operations on matrices, such as equality,
    addition, multiplication, transpose, and inverse.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些矩阵的基本操作，例如相等、加法、乘法、转置和逆运算。
- en: We've also introduced the versatile Incanter library that is used to visualize
    plots and charts of data, through an example on using matrices.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还介绍了一个多功能的 Incanter 库，它用于通过矩阵使用示例来可视化数据图表。
- en: Next, we will study some basic techniques for prediction using linear regression.
    As we will see, some of these techniques, in fact, are based on simple matrix
    operations. Linear regression is actually a type of supervised learning, which
    we will discuss in the next chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究一些使用线性回归进行预测的基本技术。正如我们将看到的，其中一些技术实际上是基于简单的矩阵运算。线性回归实际上是一种监督学习类型，我们将在下一章中讨论。
