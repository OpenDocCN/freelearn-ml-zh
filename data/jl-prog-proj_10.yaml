- en: Time Series Forecasting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列预测
- en: In the previous chapter, we learned how to handle date and time with Julia.
    This allowed us to understand the very important concept of time series data.
    Now, we are ready to discuss yet another highly important data science topic—time
    series analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Julia 处理日期和时间。这使我们能够理解时间序列数据的重要概念。现在，我们准备讨论另一个高度重要的数据科学主题——时间序列分析。
- en: Time series analysis and forecasting represents a key strategic and decisive
    component of any organization, from understanding top sales periods to end of
    season intervals and discounts, scheduling employees' time off, budgets, fiscal
    years, product release cycles, increased demand in raw materials, and many, many
    other aspects. Understanding and predicting the evolution of various business
    indicators over time is a necessary part of doing business, whether we're talking
    about a school, a billion dollar corporation, a hotel, a supermarket, or a government.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析和预测代表了任何组织的关键战略和决定性组成部分，从理解销售高峰期到季节结束间隔和折扣，安排员工休假时间，预算，财政年度，产品发布周期，原材料需求增加，以及许多其他方面。理解和预测各种商业指标随时间的变化是商业活动的一个必要部分，无论我们是在谈论学校、价值数十亿美元的公司、酒店、超市还是政府。
- en: However, time series data analysis is one of the most fairly complex tasks of
    data science. The nature and particularities of chronological events led to the
    development of specialized algorithms and methodologies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，时间序列数据分析是数据科学中最复杂任务之一。时间事件的性质和特殊性导致了专用算法和方法的发展。
- en: 'In this chapter, we''ll study the basics of time series analysis and forecasting
    using Julia. Although a fairly young language, Julia already has good support
    for handling time-related data. In the previous chapter, we''ve learned about
    the Dates module and about the `TimeSeries` package. In this chapter, we''ll dive
    deeper and apply what we have previously studied. We''ll also learn about more
    advanced `TimeSeries` methods and about a few other packages for working with
    temporal data. We will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Julia 研究时间序列分析和预测的基础知识。尽管 Julia 是一种相对较新的语言，但它已经具备了处理时间相关数据的好支持。在上一章中，我们学习了关于
    Dates 模块和 `TimeSeries` 包的内容。在本章中，我们将更深入地研究并应用我们之前学到的知识。我们还将了解更多高级的 `TimeSeries`
    方法以及一些其他用于处理时间数据的包。我们将涵盖以下主题：
- en: Exploratory data analysis of the unemployment figures of the **European Union**
    (**EU**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欧洲联盟（**EU**）失业数据的探索性数据分析
- en: Trends, cycles, seasonality, and errors—components of a time series
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 趋势、周期、季节性和误差——时间序列的组成部分
- en: Time series decomposition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列分解
- en: Stationarity, differencing, and autocorrelation of time series data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列数据的平稳性、差分和自相关性
- en: Learning to apply simple forecasting techniques
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习应用简单的预测技术
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 包生态系统正在持续发展中，并且每天都有新的包版本发布。大多数时候，这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍在测试版（版本
    0.x）中，任何新版本都可能引入破坏性更改。因此，书中展示的代码可能无法正常工作。为了确保您的代码能够产生与书中描述相同的结果，建议使用相同的包版本。以下是本章使用的外部包及其具体版本：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，您需要运行：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过下载章节提供的 `Project.toml` 文件并使用 `pkg>` 实例化来安装所有使用的包：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A quick look at our data
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速查看我们的数据
- en: In this chapter, we will use some real-life data provided by Eurostat, the official
    EU office for statistics. Eurostat has a wealth of databases available on its
    website. For our learning project, we'll take a look at the unemployment numbers—with
    the EU's economy growing after a long recession, these stats should be quite interesting.
    Various EU employment and unemployment figures can be downloaded from [http://ec.europa.eu/eurostat/web/lfs/data/database](http://ec.europa.eu/eurostat/web/lfs/data/database).
    We'll be using the **Unemployment by sex and age – monthly average** dataset.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用由欧盟统计局提供的真实数据。欧盟统计局在其网站上拥有丰富的数据库。为了我们的学习项目，我们将查看失业数据——在经历了长期的经济衰退后，欧盟的经济正在增长，这些统计数据应该非常有趣。各种欧盟就业和失业数据可以从
    [http://ec.europa.eu/eurostat/web/lfs/data/database](http://ec.europa.eu/eurostat/web/lfs/data/database)
    下载。我们将使用 **按性别和年龄划分的失业率——月平均** 数据集。
- en: You don't need to download this because a better structured dataset is provided
    in this chapter's support files. However, if you're curious and want to take a
    look, you can get the raw data from under the Employment and unemployment (Labour
    force survey) category | LFS main indicators subcategory | Unemployment - LFS
    adjusted series folder.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要下载这个，因为本章的支持文件中提供了一个结构更好的数据集。然而，如果您好奇并想看看，您可以从就业和失业（劳动力调查）类别 | LFS 主要指标子类别
    | 失业 - LFS 调整系列文件夹下获取原始数据。
- en: 'I''ve also customized the data by using *thousand persons* for the unit of
    measure (the default is *percentage of active population*), and unadjusted data
    (neither seasonally, nor calendar). I''ve also kept the numbers for the EU only
    (no individual countries). Finally, I''ve included all the data from January 2005
    to December 2017\. You can make all of these adjustments in the data explorer
    and then download the table as TSV file. As for the TSV formatting, I went with
    these options:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我还通过使用 *千人* 作为计量单位（默认是 *活跃人口的百分比*）和未调整的数据（既不是季节性的，也不是日历的）来定制了数据。我还只保留了欧盟的数据（没有单个国家）。最后，我包括了
    2005 年 1 月到 2017 年 12 月的所有数据。您可以在数据探索器中进行所有这些调整，然后下载表格作为 TSV 文件。至于 TSV 格式，我选择了以下选项：
- en: '![](img/a03e7928-781a-4f72-b4cb-e037fb87381a.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a03e7928-781a-4f72-b4cb-e037fb87381a.png)'
- en: 'Visualized in the Eurostat data explorer tool, the data looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在欧盟统计局数据探索工具中可视化，数据看起来是这样的：
- en: '![](img/b2f003d7-0f72-40fa-a01a-5de76cb059d0.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2f003d7-0f72-40fa-a01a-5de76cb059d0.png)'
- en: We can see a list of geographical areas in the first column and unemployment
    numbers on a monthly basis in the rest of the columns. This dataset is structured
    in a different way than what we require. For starters, `TimeSeries` requires the
    matrix to be transposed (as in, the dates should become rows instead of columns).
    Additionally, dates are formatted in a non-standard way, for example, `2017M01` designates
    January 2017\. Finally, the numbers are formatted as strings, with spaces for
    thousand separators. You can download this raw data file from this chapter's support
    files, which are hosted at [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter10/data/une_rt_m_1.tsv](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter10/data/une_rt_m_1.tsv).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到第一列是地理区域列表，其余列是按月度的失业数据。这个数据集的结构与我们所需的不同。首先，`TimeSeries` 需要矩阵转置（即，日期应成为行而不是列）。此外，日期以非标准方式格式化，例如，`2017M01`
    表示 2017 年 1 月。最后，数字以字符串格式表示，千位分隔符用空格表示。您可以从本章的支持文件中下载这个原始数据文件，这些文件托管在 [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter10/data/une_rt_m_1.tsv](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter10/data/une_rt_m_1.tsv)。
- en: Such issues are a common occurrence when working with real-life data—differences
    in standards regarding structure and formatting make data sanitization and transformation
    a key first step, and usually also a time-consuming one, in any data science project.
    For the sake of brevity, I have prepared a simplified dataset that's already been
    transformed for seamless usage with `TimeSeries`, which you can download from
    this chapter's support files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理真实数据时，这类问题很常见——关于结构和格式的标准差异使得数据清洗和转换成为任何数据科学项目的关键第一步，通常也是一个耗时的工作。为了简洁起见，我已经准备了一个简化后的数据集，它已经被转换，可以无缝地与
    `TimeSeries` 一起使用，您可以从本章的支持文件中下载。
- en: Data processing
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据处理
- en: 'If you would like to follow along, here is how I processed the raw data using
    Julia:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟上来，以下是我是如何使用 Julia 处理原始数据的：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is what it looks like in a Jupyter Notebook:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Jupyter Notebook中的样子：
- en: '![](img/cf8de08e-56ce-4d2a-92fd-9705b747b76e.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf8de08e-56ce-4d2a-92fd-9705b747b76e.png)'
- en: 'In the next step, we will extract the values by selecting a `DataFrame` composed
    of 1 row and 2 columns to `end` and converting it into an `Array`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将通过选择一个由1行和2列组成的`DataFrame`并将其转换为`Array`来提取值：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can parse the previously extracted string values and convert them into
    integers. The new integer values are stored in a vector as well:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以解析之前提取的字符串值并将它们转换为整数。新的整数值也存储在一个向量中：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Great—our values are ready! We can now focus on the headers. Our goal is to
    extract the date information contained in the labels. As a first step, we pull
    the names of the columns into a vector, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们的值准备好了！现在我们可以专注于头部。我们的目标是提取标签中包含的日期信息。作为第一步，我们将列名拉入一个向量，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s transform the symbols to bring them closer to what we need—that
    is, something resembling a standard date format. We''ll replace the "`M`" with
    a dash, and in the process, we''ll convert the symbol into a `String`, as replacing
    does not work on symbols:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转换符号，使它们更接近我们需要的标准日期格式。我们将用连字符替换"`M`"，在这个过程中，我们将符号转换为`String`，因为替换操作不适用于符号：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Excellent! Now, we can define a `DateFormat` matching our strings—year plus
    dash plus month, with the month as a numeric value with a leading zero. We''ll
    use this to convert the strings to proper date objects:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们可以定义一个与我们的字符串匹配的`DateFormat`——年份加连字符加月份，月份为一个带前导零的数字。我们将使用它将字符串转换为正确的日期对象：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re getting closer! To safely persist the data to a file, I created a new
    `DataFrame`, this time using the proper dates and the original values, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越来越接近了！为了安全地将数据持久化到文件中，我创建了一个新的`DataFrame`，这次使用了正确的日期和原始值，如下所示：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can use `CSV.write` to store the snapshot of our data to file by using the
    following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`CSV.write`通过以下代码将我们的数据快照存储到文件中：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now load the data as a `TimeArray` from the TSV file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从TSV文件中加载数据作为`TimeArray`：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you would like to directly convert from `DataFrame` to `TimeSeries` data,
    without resorting to loading a TSV file, you can use the `IterableTables` package.
    `IterableTables` provides a wealth of converter methods between different table
    types in Julia. You can read more in the package's README at [https://github.com/davidanthoff/IterableTables.jl](https://github.com/davidanthoff/IterableTables.jl).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想直接从`DataFrame`转换为`TimeSeries`数据，而不必加载TSV文件，您可以使用`IterableTables`包。`IterableTables`为Julia中不同表格类型之间提供了丰富的转换方法。您可以在包的README中了解更多信息，网址为[https://github.com/davidanthoff/IterableTables.jl](https://github.com/davidanthoff/IterableTables.jl)。
- en: 'Our time series data was correctly loaded—there are 156 entries between January
    2005 and December 2017\. It will look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的时间序列数据已正确加载——从2005年1月到2017年12月共有156个条目。它看起来像这样：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/25a87a47-e73d-41bb-8a57-ce3362ff049c.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25a87a47-e73d-41bb-8a57-ce3362ff049c.png)'
- en: We had to use the fully qualified name of the head function, `TimeSeries.head`,
    because both `TimeSeries` and `DataFrames` export a `head` method, and both packages
    are loaded into the current scope.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不使用头函数的完全限定名称，`TimeSeries.head`，因为`TimeSeries`和`DataFrames`都导出了`head`方法，并且这两个包都被加载到当前作用域中。
- en: 'Attempting to call the head function without the module''s name would result
    in an error:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有模块的名称就尝试调用头函数，将会导致错误：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The best way to get a quick insight into our data is to render a plot. We''ll
    use the `Plots` package with the `PyPlot` backend—we installed them both in [Chapter
    9](11df7c94-2e9a-4cc5-aba1-b9c9c93800a0.xhtml), *Working with Dates, Time, and
    Time Series*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速了解我们的数据，最好的方法就是绘制一个图表。我们将使用带有`PyPlot`后端的`Plots`包——我们在第9章[11df7c94-2e9a-4cc5-aba1-b9c9c93800a0.xhtml]
    *处理日期、时间和时间序列* 中安装了它们：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `PyPlot` backend has complex dependencies, so if you run into problems executing
    the indicated code, please follow the instructions provided by the warnings and
    errors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyPlot`后端有复杂的依赖关系，所以如果您在执行指示的代码时遇到问题，请按照警告和错误中提供的说明操作。'
- en: 'For instance, at some point, I had to install two extra packages by hand:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在某个时候，我不得不手动安装两个额外的包：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can plot the unemployment numbers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以绘制失业率图表：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Julia will render the following plot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Julia将渲染以下图表：
- en: '![](img/7cde553e-2ac8-4d28-be71-883a2d5e664b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cde553e-2ac8-4d28-be71-883a2d5e664b.png)'
- en: We can easily see that the number of unemployed people had been steadily decreasing
    since 2005, reaching a historical minimum in the second half of 2008\. From there,
    over a couple of months, it skyrocketed to levels unknown since 2005\. This was
    the moment when the recession hit the EU's economy. From that point on, unemployment
    numbers continued to grow, until they finally reached a peak at the beginning
    of 2013\. The maximum number of people without a job was reached in February 2013,
    after which the European economy began to recover, with the unemployment numbers
    rapidly declining and approaching pre-recession levels.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地看出，自2005年以来，失业人数一直在稳步下降，在2008年下半年达到了历史最低点。从那时起，在几个月的时间里，失业人数激增至自2005年以来的未知水平。这是经济衰退袭击欧盟经济的那一刻。从那时起，失业人数继续增长，直到它们最终在2013年初达到峰值。2013年2月，失业人数达到了最高点，此后欧洲经济开始复苏，失业人数迅速下降，接近经济衰退前的水平。
- en: Understanding time series components
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解时间序列成分
- en: There are three components of time series that are key to understanding time-related
    data. They are *trend*, *seasonality*, and *noise*. Let's look at each of them
    in the context of our EU unemployment data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列有三个关键成分对于理解与时间相关的数据至关重要。它们是*趋势*、*季节性*和*噪声*。让我们在我们欧盟失业数据的背景下看看每一个。
- en: Trend
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 趋势
- en: 'The trend can be defined as the long-term tendency of the time series data—the
    fact that, on average, the values tend to increase or decrease over a period of
    time. Looking at our plot, we can identify three distinct trends:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势可以被定义为时间序列数据的长期趋势——即在一段时间内，平均值倾向于增加或减少。观察我们的图表，我们可以识别出三个不同的趋势：
- en: '![](img/51311f42-6866-4abf-9d4a-c408ed5670cf.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51311f42-6866-4abf-9d4a-c408ed5670cf.png)'
- en: A downward trend from 2005 until 2008 (less people unemployed on a year-on-year
    basis); an upward trend starting in 2008 and manifesting until 2013 (unemployment
    rose on average); and again, a downward trend between 2013, all the way until
    the end of 2017 (the number of people without work constantly decreased).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从2005年到2008年呈下降趋势（年度失业人数减少）；从2008年开始上升，一直持续到2013年（失业率平均上升）；再次，从2013年开始，一直持续到2017年底（失业人数持续减少）。
- en: Seasonality
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 季节性
- en: Seasonality is a regularly repeating pattern of highs and lows that is related
    to calendar time; that is, it's directly influenced by seasons, quarters, months,
    and so on. Think, for instance, about the electricity usage in a city—we'll probably
    see increases in consumption during the summer due to air conditioning, and in
    wintertime due to needing to heat the houses instead. In a similar manner, by
    looking at a hotel at the seaside, we'll see a significant increase in bookings
    during the summer, followed by a decrease in the winter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 季节性是指与日历时间相关的规律性高低波动模式；也就是说，它直接受到季节、季度、月份等因素的影响。例如，考虑一个城市的电力消耗——我们可能会在夏季由于空调使用而看到消费量的增加，在冬季由于需要供暖而增加。以类似的方式，通过观察海滨酒店，我们会看到夏季预订量显著增加，随后在冬季减少。
- en: Thus, seasonality generates effects that are reasonably stable with respect
    to timing, direction, and magnitude. The most common calendar-related influences
    are natural conditions (the weather), business and administrative procedures (fiscal
    year), and social and cultural behaviors (bank holidays due to national and religious
    holidays, key dates like Christmas, Valentine's Day, and so on). It also includes
    effects that are caused by calendar events, which are recurrent but not fixed
    in terms of date (such as Easter, whose date falls on a certain Sunday each year,
    but the actual date varies).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，季节性产生的效果在时间、方向和幅度上相对稳定。最常见的日历相关影响是自然条件（天气）、商业和行政程序（财政年度）以及社会和文化行为（由于国家和宗教节日而出现的银行假日，如圣诞节、情人节等）。它还包括由日历事件引起的效果，这些事件是周期性的，但在日期上不是固定的（例如，复活节，每年的日期都落在某个星期日，但实际日期会变化）。
- en: 'Unemployment data suffers a strong seasonal influence—during the summer months,
    more people are employed. These seem to be temporary jobs, probably in tourism,
    to help hotels and restaurants cope with the influx of holiday goers—but maybe
    also in the office and retail sectors to cover for the regular employees'' time
    off. We can clearly identify this on our plot—the summer months bring the lowest
    unemployment figures for the year, with the values beginning to go up again in
    autumn:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 失业数据受到强烈的季节性影响——在夏季月份，更多的人被雇佣。这些似乎都是临时工作，可能是在旅游业，帮助酒店和餐馆应对假日游客的涌入——但也可能在办公室和零售行业，以填补常规员工的休假时间。我们可以在我们的图表中清楚地识别这一点——夏季月份是一年中的最低失业率，数值在秋季又开始上升：
- en: '![](img/b023cc8b-d96f-42e9-a2b5-9a6ca9e4aa77.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b023cc8b-d96f-42e9-a2b5-9a6ca9e4aa77.png)'
- en: During the three summer months in the middle of the year, unemployment reaches
    the lowest levels. Once the peak of the season passes, unemployment steeply rises
    once more.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在年中三个夏季月份，失业率达到了最低水平。一旦季节性高峰过去，失业率再次急剧上升。
- en: Random noise
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机噪声
- en: The default assumption when analyzing time series data is that we can identify
    an underlying pattern (as defined by its trend and seasonality components). However,
    when there is such a systematic pattern in the data (some time series data is
    completely random, for example, earthquake incidence), it will also be accompanied
    by variances—fluctuations in the data that are categorized as random noise, errors,
    or irregularities. They make the task of identifying the patterns more difficult,
    and for this reason, data scientists will use some form of noise filtering.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 分析时间序列数据时的默认假设是我们能够识别一个潜在的规律（由其趋势和季节性成分定义）。然而，当数据中存在这种系统性模式时（例如，一些时间序列数据是完全随机的，例如地震发生频率），它也会伴随着方差——数据中的波动被归类为随机噪声、错误或不规则性。这使得识别模式变得更加困难，因此，数据科学家将使用某种形式的噪声过滤。
- en: In other words, this irregular component is what remains after the seasonal
    and trend components have been computed and removed. They are short-term fluctuations,
    and are neither systematic nor predictable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个不规则成分是在计算并移除季节性和趋势成分之后剩下的部分。它们是短期波动，既不系统也不可预测。
- en: Cyclicity
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环性
- en: '**Cyclicity** is similar to seasonality in a way, and for this reason, the
    two are often confused. However, they are two different things, and the distinction
    is important. Cyclical periods represent larger swathes of time where we can identify
    recurring patterns in the data (periods of growth or decline) and which can''t
    be explained away by calendar patterns. They are usually larger, spanning a few
    years, and do not overlap with calendar events. Such cyclical elements can be
    introduced by product release cycles (the release of a car model, or a new version
    of an operating system, or an upgrade to a line of laptops), election cycles (for
    government budgeting or companies working with government contracts), and so on.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环性**在某种程度上与季节性相似，因此这两个经常被混淆。然而，它们是两件不同的事情，区分它们很重要。循环周期代表更长的时间段，我们可以在这段时间内识别数据中的重复模式（增长或下降的时期），并且不能通过日历模式来解释。它们通常更大，跨越几年，并且不与日历事件重叠。这种循环元素可以由产品发布周期（汽车型号的发布，或操作系统的全新版本，或笔记本电脑系列的升级）、选举周期（政府预算或与政府签订合同的公司）等引入。'
- en: Time series decomposition
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列分解
- en: We can thus say that any value in a time series can be represented through a
    function of the four components we discussed earlier—trend, seasonality, error,
    and cycle. The relationship between the four components can be either *additive*
    or *multiplicative*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样说，时间序列中的任何值都可以通过我们之前讨论的四个成分的函数来表示——趋势、季节性、误差和循环。这四个成分之间的关系可以是**加法**或**乘法**。
- en: 'The additive model is used when the seasonal variation stays about the same
    across time. The trend may be upward or downward, but the seasonality stays more
    or less the same. A plot of such data will look very similar to this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当季节性变化在时间上保持大致相同的时候，使用加法模型。趋势可能是上升或下降，但季节性保持更多或更少相同。此类数据的图表看起来将非常类似于这个：
- en: '![](img/ea8d4fed-7b41-4c10-a529-d9b90858a7a0.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea8d4fed-7b41-4c10-a529-d9b90858a7a0.png)'
- en: If we draw two imaginary lines between the yearly maximums and the yearly minimums,
    the lines will be pretty much parallel.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在年最高值和年最低值之间画两条想象中的线，这些线将几乎是平行的。
- en: For an additive time series model, the four components are summed up to produce
    the values in the series. Thus, a time series *Y* can be decomposed into *Y* =
    *Trend* + *Cycle* + *Seasonality* + *Noise*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加法时间序列模型，四个成分相加产生序列中的值。因此，时间序列 *Y* 可以分解为 *Y* = *趋势* + *周期* + *季节性* + *噪声*。
- en: 'A multiplicative model should be used with a time series where the seasonal
    variability increases over time. For example, a typical multiplicative time series
    is represented by the international airline passenger data between January 1949
    and January 1960:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用乘法模型来处理季节性变异性随时间增加的时间序列。例如，典型的乘法时间序列由1949年1月至1960年1月之间的国际航空旅客数据表示：
- en: '![](img/82d97bc1-6063-4aa7-8287-519ef0a86000.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82d97bc1-6063-4aa7-8287-519ef0a86000.png)'
- en: 'We can see how the variation in the seasonal pattern is correlated with the
    level of the time series: the more passengers we have, the higher the variation.
    A multiplicative time series *Y* can be represented as *Y* = *Trend* * *Cycle*
    * *Seasonality* * *Noise*.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到季节性模式的变异性与时间序列的水平相关：乘客越多，变异性越高。一个乘法时间序列 *Y* 可以表示为 *Y* = *趋势* * *周期* *
    *季节性* * *噪声*。
- en: As a side note, we can convert a multiplicative model into an additive model
    by transforming the data until it becomes stable over time, for example, by means
    of log transformations—*Y* = *Trend* * *Cycle* * *Seasonality* * *Noise* is equivalent
    to *log Y* = *log Trend* + *log Cycle* + *log Seasonality* + *log Noise*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们可以通过转换数据直到它在时间上变得稳定，例如通过对数变换，将乘法模型转换为加法模型——*Y* = *趋势* * *周期* * *季节性*
    * *噪声* 等价于 *log Y* = *log 趋势* + *log 周期* + *log 季节性* + *log 噪声*。
- en: Splitting a time series into its components is a widely employed technique for
    time data analysis. This is known as** time series decomposition**, and it also
    represents the foundation of time series forecasting.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将时间序列分解为其成分是时间数据分析中广泛使用的技术。这被称为**时间序列分解**，它也是时间序列预测的基础。
- en: Explaining data – an additive approach or multiplicative approach?
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释数据——是采用加法方法还是乘法方法？
- en: 'This is the question—which of the two approaches does a better job of explaining
    our data? One way to answer this question is to look at the cycle-by-cycle values
    and see if there is significant variation. As we''re dealing with yearly cycles,
    let''s extract and plot the year on year values as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是问题——两种方法中哪一种更好地解释了我们的数据？回答这个问题的方法之一是查看周期值，看是否有显著变化。由于我们处理的是年度周期，让我们按照以下方式提取并绘制年度年度值：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we render an empty plot. Then, we iterate over a range corresponding
    to our years, between 2005 and 2017, and then we use the `TimeSeries.when` method
    to filter our data by year. We extract the resulting `TimeArray` values and append
    them to the plot by using the `plot!` function. However, this is not enough—we
    also have to call the `Plots.gui` method to actually render the updated plot.
    This is a very important point, per the official documentation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们绘制一个空图。然后，我们遍历从2005年到2017年的年份范围，然后我们使用`TimeSeries.when`方法通过年份过滤我们的数据。我们通过使用`plot!`函数提取结果`TimeArray`值并将它们附加到图上。然而，这还不够——我们还需要调用`Plots.gui`方法来实际渲染更新的图。根据官方文档，这是一个非常重要的点：
- en: '"A plot is only displayed when returned (a semicolon will suppress the return),
    or if explicitly displayed with `display(plt)`, `gui()`, or by adding `show =
    true` to your plot command."'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '"只有在返回时（分号将抑制返回），或者显式地使用`display(plt)`，`gui()`，或者在您的绘图命令中添加`show = true`时，才会显示图形。"'
- en: You can read more about outputting plots at [http://docs.juliaplots.org/latest/output/](http://docs.juliaplots.org/latest/output/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://docs.juliaplots.org/latest/output/](http://docs.juliaplots.org/latest/output/)了解更多关于输出图形的信息。
- en: 'Here''s what we get:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的结果：
- en: '![](img/faa8bea1-d57f-452c-9a64-107b4d1dd029.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/faa8bea1-d57f-452c-9a64-107b4d1dd029.png)'
- en: We can see that there is consistent year-after-year variation, which means that
    we should use the multiplicative model.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每年都有一致的年度变化，这意味着我们应该使用乘法模型。
- en: Eyeballing the components using `plots` is a common way of recognizing patterns
    in a time series. In our case, it is pretty easy to tell that there's both trend
    and seasonality. Also, we can deduce that the data does not exhibit any cyclical
    pattern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`plots`来直观地观察成分是识别时间序列中模式的一种常见方法。在我们的例子中，很容易看出存在趋势和季节性。此外，我们可以推断出数据没有表现出任何周期性模式。
- en: Remember that the multiplicative model holds that *Y = Trend * Cyclicity * Seasonality
    * Noise*. We can write this shorter as *Y = TCSN*. Since we just established that
    our data does not present any cycles, we're going to leave out the cyclicity component,
    and so *Y = TSN*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，乘法模型认为 *Y = 趋势 * 循环 * 季节性 * 噪声*。我们可以将其简写为 *Y = TCSN*。由于我们刚刚确定我们的数据不呈现任何循环，我们将省略循环成分，因此
    *Y = TSN*。
- en: Extracting the trend
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取趋势
- en: The first step in decomposing a time series is to extract the trend component.
    A widely used technique for computing the trend is called **smoothing**. As the
    name suggests, it *smooths out* the values by removing the noise and blurring
    the seasonality so that we can identify the trend.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 分解时间序列的第一步是提取趋势成分。计算趋势的一个广泛使用的技术被称为 **平滑**。正如其名所示，它通过去除噪声和模糊季节性来 *平滑* 值，以便我们可以识别趋势。
- en: One way of performing smoothing is through moving averages. In financial applications,
    the simple moving average is the unweighted mean of the previous *n* points of
    data. It's like applying a moving window on top of our time series and performing
    the calculation using the visible data. Then, we slide the window by one position
    and repeat the calculation. To smooth out seasonal data, the window should be
    the size of the seasonal period—in our case, 12 months. So, to apply simple moving
    average smoothing to our data, we'll start by taking the first 12 month period
    (the year 2005), sum up the values, and then divide them by 12 to get their average.
    Then, we'll slide our window by one month and repeat the computation. As a result,
    we eliminate the effect of the seasonal component and cancel out the impact of
    the noise.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行平滑的一种方法是通过移动平均。在金融应用中，简单移动平均是前 *n* 个数据点的未加权平均值。这就像在我们的时间序列上应用一个移动窗口，并使用可见数据进行计算。然后，我们将窗口滑动一个位置并重复计算。为了平滑季节性数据，窗口的大小应该是季节期的长度——在我们的案例中，是12个月。因此，为了对我们的数据进行简单移动平均平滑，我们首先取前12个月份（2005年），求和这些值，然后除以12以得到它们的平均值。然后，我们将窗口滑动一个月并重复计算。结果，我们消除了季节性成分的影响，并抵消了噪声的影响。
- en: 'The `TimeSeries` package provides a series of *apply methods* that implement
    common transformations of time series data. One of them is the `moving` method,
    which can be used to compute the moving average of a series. Let''s compute the
    moving average for a 12 month interval in order to smooth out the seasonality
    component:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeSeries` 包提供了一系列 *apply 方法*，用于实现时间序列数据的常见转换。其中之一是 `moving` 方法，它可以用来计算序列的移动平均。让我们计算12个月间隔的移动平均，以平滑季节性成分：'
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/db85a03f-60fd-4570-bada-64b584638829.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db85a03f-60fd-4570-bada-64b584638829.png)'
- en: 'As we can see, the result is a new time series that contains the mean of 12-month
    periods in our original time series. The first 12 values of the original series
    are consumed by this operation so that our new series starts with December 2005\.
    If you wish to keep the initial values, the `moving` function takes an additional
    keyword argument, `padding`. By default, `padding` is `false`, but if set to `true`,
    the consumed timestamps will be kept and their values will be set to `NaN`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，结果是包含我们原始时间序列12个月份平均值的新时间序列。原始序列的前12个值被这个操作消耗，因此我们的新序列从2005年12月开始。如果您希望保留初始值，`moving`
    函数接受一个额外的关键字参数，`padding`。默认情况下，`padding` 是 `false`，但如果设置为 `true`，则消耗的时间戳将被保留，其值将被设置为
    `NaN`：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will produce the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/8a396e00-49a3-4849-8fe5-571002e8c806.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a396e00-49a3-4849-8fe5-571002e8c806.png)'
- en: 'Plotting the smoothed values on top of the original data indicates the trend:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始数据上方绘制平滑值可以指示趋势：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is our plot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的图形：
- en: '![](img/9d7e2491-e3b8-46f8-ab08-24a3632989f5.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d7e2491-e3b8-46f8-ab08-24a3632989f5.png)'
- en: The first call to the `plot` method renders the raw EU unemployment figures,
    while the subsequent call of the `plot!` method mutates the plot, overlaying the
    moving average that corresponds to the trend.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `plot` 方法渲染原始欧盟失业率数据，而后续调用 `plot!` 方法会修改图形，叠加与趋势相对应的移动平均线。
- en: Computing the seasonality
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算季节性
- en: Now that we have extracted the trend, we can remove it from the initial time
    series. This is done by division. We will be left with the product of the seasonal
    and noise components. Thus, *SN = Y/T*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提取了趋势，我们可以将其从初始时间序列中移除。这是通过除法完成的。我们将剩下季节性和噪声成分的乘积。因此，*SN = Y/T*。
- en: 'To calculate the fraction between `TimeArray` objects, we''ll use the element-wise
    division operator, `./`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 `TimeArray` 对象之间的分数，我们将使用逐元素除法运算符，`./`：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will get the following result:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下结果：
- en: '![](img/f41594b9-1cfb-465f-a546-b049443ec16f.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f41594b9-1cfb-465f-a546-b049443ec16f.png)'
- en: 'Plotting the resulting `TimeArray` will give us a clearer image of the product
    of the seasonality and noise components:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制结果 `TimeArray` 将会给我们一个更清晰的季节性和噪声成分的乘积的图像：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This results in the following plot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下图表：
- en: '![](img/062eaaec-3351-479f-aa72-f2911041b9b0.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/062eaaec-3351-479f-aa72-f2911041b9b0.png)'
- en: 'The next step is calculating the sum over years of these values for the same
    month. That is, we''ll sum the value for all of the months of January throughout
    all the years; then, we will do the same for February, March, and so on. We''ll
    get the average over all the years, for each calendar month. This will lead to
    the minimization of the noise:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是计算相同月份这些值的年度总和。也就是说，我们将计算所有年份1月份的所有月份的值；然后，我们将对2月、3月做同样的处理。我们将得到每个日历月份所有年份的平均值。这将导致噪声的最小化：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'First, we instantiate a `Vector` of `Float64` values. Then, we iterate over
    a range between `1` and `12`, which represents the months. Within the loop, we
    apply the `when` method to filter the values for the currently iterated month
    (all the January values for all the years, then all the February values for all
    the years, then March, and so on), and then we push the mean of these values into
    the `month_avg` array. At the end of the loop, we collect these values in `month_avg`,
    where the first is the average value for the month of January across all the years,
    the second for February, then March, and so on. It will look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化一个 `Float64` 类型的 `Vector`。然后，我们在 `1` 到 `12` 的范围内迭代，这代表月份。在循环内部，我们使用
    `when` 方法来过滤当前迭代月份的值（所有年份的1月值，然后是所有年份的2月值，然后是3月，依此类推），然后将这些值的平均值推入 `month_avg`
    数组。循环结束时，我们将这些值收集到 `month_avg` 中，其中第一个是所有年份1月份的平均值，第二个是2月份，然后是3月，依此类推。它看起来会是这样：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Theoretically, these values should add up to `12`. In practice, that doesn''t
    happen (although we''re pretty close). We can easily sum up all of the elements
    of an array using the `sum` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这些值应该加起来是 `12`。实际上，这种情况并不发生（尽管我们非常接近）。我们可以很容易地使用 `sum` 函数来求出数组的所有元素的总和：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As a consequence, we need to normalize the averages so that they *do* sum up
    to `12`. This is achieved by multiplying each seasonal factor by `12` and then
    dividing each factor by their sum:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，我们需要将平均值归一化，以便它们确实加起来是 `12`。这是通过将每个季节因子乘以 `12`，然后除以它们的总和来实现的：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We used the `map` function to iterate over each item in `month_avg` as `m`
    and applied an anonymous function so that `m = 12m/s`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `map` 函数来遍历 `month_avg` 中的每个项目作为 `m`，并应用了一个匿名函数，使得 `m = 12m/s`：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s check the sum again:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次检查总和：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Perfection!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！
- en: Now that we have calculated the monthly seasonal factor, we can perform the
    seasonal adjustment on our original time series by dividing it by the seasonal
    factor. This way, we'll get the reminder, which represents the product of trend
    and noise—*Y/S = TN*. To compute this in Julia, we have to divide each value of
    `unemployment_data` by the corresponding monthly seasonal factor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了月度季节因子，我们可以通过除以季节因子来对原始时间序列进行季节调整。这样，我们将得到余数，它代表了趋势和噪声的乘积—*Y/S = TN*。在
    Julia 中计算这个值，我们必须将 `unemployment_data` 的每个值除以相应的月度季节因子。
- en: 'To keep things clean and tidy, let''s copy our original time series into a
    different object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持整洁，让我们将原始时间序列复制到一个不同的对象中：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `deepcopy` function creates a deep copy of the object, given as an argument.
    A deep copy means that everything is copied recursively, resulting in a fully
    independent object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`deepcopy` 函数创建了一个对象的深拷贝，该对象作为参数给出。深拷贝意味着一切都会递归地复制，从而产生一个完全独立的对象。'
- en: 'Next, we can use the `map` function to modify the `TimeArray` in place by recursively
    applying a function that divides the original value by the seasonality:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `map` 函数就地修改 `TimeArray`，通过递归应用一个将原始值除以季节性的函数：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The result is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/a22f7a94-52c1-4941-9ac4-ffb36a8af057.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a22f7a94-52c1-4941-9ac4-ffb36a8af057.png)'
- en: The `adj_unemployment_data` variable represents the seasonally adjusted time
    series.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`adj_unemployment_data` 变量代表季节调整后的时间序列。'
- en: TimeSeries operators
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列运算符
- en: Performing operations between `TimeArray` objects—or rather between the elements
    contained in them—is a common occurrence in time series analysis. The `TimeSeries`
    package exposes a complete set of element-wise operators for mathematical, comparison,
    and logical operations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间序列分析中，在`TimeArray`对象之间（或者更确切地说，在它们包含的元素之间）进行操作是一种常见现象。`TimeSeries`包公开了一套完整的元素级运算符，用于数学、比较和逻辑操作。
- en: 'As we have already seen when doing division between two `TimeArray` objects,
    the mathematical operators create a new `TimeArray` instance by using the values
    with common timestamps. Operations between a single `TimeArray` and `Int` or `Float`
    are also supported. The following operators are available:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在两个`TimeArray`对象之间进行除法运算时已经看到的那样，数学运算符通过使用具有共同时间戳的值来创建一个新的`TimeArray`实例。也支持单个`TimeArray`与`Int`或`Float`之间的操作。以下运算符可用：
- en: '`.+`: Arithmetic element-wise addition'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.+`: 元素级数的算术加法'
- en: '`.-`: Arithmetic element-wise subtraction'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.-`: 元素级数的算术减法'
- en: '`.*`: Arithmetic element-wise multiplication'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.*`: 元素级数的算术乘法'
- en: '`./`: Arithmetic element-wise division'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./`: 元素级数的算术除法'
- en: '`.^`: Arithmetic element-wise exponentiation'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.^`: 元素级数的指数运算'
- en: '`.%`: Arithmetic element-wise remainder'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.%`: 元素级数的算术余数'
- en: Similar to mathematical operators, in the case of comparison ones, when two
    `TimeArray` instances are provided, the values are compared on shared timestamps
    too. However, the difference, in this case, is that the result will be a time
    array of type `Bool`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与数学运算符类似，在比较运算符的情况下，当提供两个`TimeArray`实例时，值将在共享时间戳上进行比较。然而，这里的区别在于，结果将是一个类型为`Bool`的时间数组。
- en: 'These are the available comparison operators:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可用的比较运算符：
- en: '`.>`: Element-wise greater-than comparison'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.>`: 元素级数的大于比较'
- en: '`.<`: Element-wise less-than comparison'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.<`: 元素级数的小于比较'
- en: '`.==`: Element-wise equivalent comparison'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.==`: 元素级数的等价比较'
- en: '`.>=`: Element-wise greater-than or equal comparison'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.>=`: 元素级数的大于或等于比较'
- en: '`.<=`: Element-wise less-than or equal comparison'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.<=`: 元素级数的小于或等于比较'
- en: '`.!=`: Element-wise not-equivalent comparison'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.!=`: 元素级数的非等价比较'
- en: 'Let''s look at an example. First, let''s create a `TimeArray` spreading between
    a week ago and today and fill it with random values. Your timestamps will be different
    as you''ll run the code sometime in the future, and so the output will be different
    compared to mine, but the logic will be the same. Don''t forget to execute `using
    Dates` if the module is not already in scope:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。首先，让我们创建一个从一周前到今天的`TimeArray`，并用随机值填充它。由于你将在未来某个时间运行代码，所以你的时间戳将不同，因此输出将与我的不同，但逻辑将是相同的。如果该模块尚未在作用域内，不要忘记执行`using
    Dates`：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is what we get:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的结果：
- en: '![](img/780158c5-3bc1-49b3-84fd-b1c21f1ec1a7.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/780158c5-3bc1-49b3-84fd-b1c21f1ec1a7.png)'
- en: 'Now, we''ll do the same for the second array:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对第二个数组做同样的操作：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is what we get:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的结果：
- en: '![](img/3b641102-005b-4c98-b97d-b34e2cd7160b.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b641102-005b-4c98-b97d-b34e2cd7160b.png)'
- en: 'Now, we can compare the two objects, for instance:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以比较两个对象，例如：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/12cafc14-56f4-43e9-834f-867a24c27ec6.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12cafc14-56f4-43e9-834f-867a24c27ec6.png)'
- en: 'Comparisons between a single `TimeArray` and `Int`, `Float`, or `Bool` values
    are supported too:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 也支持单个`TimeArray`与`Int`、`Float`或`Bool`值之间的比较：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, the output is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出如下：
- en: '![](img/08bf2425-0ad4-450b-b506-39c5a376347b.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08bf2425-0ad4-450b-b506-39c5a376347b.png)'
- en: 'Finally, we can use the following logic operators:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下逻辑运算符：
- en: '`.&` element-wise logical `AND`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.&` 元素级数的逻辑“与”'
- en: '`.|` element-wise logical `OR`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.|` 元素级数的逻辑“或”'
- en: '`.!`, `.~` element-wise logical `NOT`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.!`, `.~` 元素级数的逻辑“非”'
- en: '`.``⊻` element-wise logical `XOR`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.``⊻` 元素级数的逻辑“异或”'
- en: They are defined for `TimeArrays` of type `Bool` and return a `TimeArray` of
    type `Bool`. Values are computed on common timestamps when two `TimeArray` objects
    are the operands and operations between a single `TimeArray` and a `Bool` are
    supported.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是为`TimeArrays`类型`Bool`定义的，并返回一个类型为`Bool`的`TimeArray`。当两个`TimeArray`对象是操作数，以及单个`TimeArray`与`Bool`之间的操作时，值将在共同时间戳上计算。
- en: Time series stationarity
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列平稳性
- en: A time series is considered stationary if its statistical properties such as
    mean, variance, autocorrelation, and so on, are constant over time. **Stationarity**
    is important because most forecasting models run on the assumption that the time
    series is stationary or can be rendered (approximately) stationary using transformations.
    The reason for this approach is that values in a stationary time series are much
    easier to predict—if its properties are constant, we can simply state that they
    will be in the future as they were in the past. Once we forecast future values
    based on stationary time series, we can then reverse the process and the transformations
    to compute the values that would match the original series.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个时间序列被认为是平稳的，如果其统计属性，如均值、方差、自相关等，随时间保持不变。**平稳性**很重要，因为大多数预测模型都是基于时间序列是平稳的或可以通过变换（近似）平稳的假设来运行的。这种方法的理由是，平稳时间序列中的值更容易预测——如果其属性是恒定的，我们就可以简单地声明它们在将来会像过去一样。一旦我们根据平稳时间序列预测了未来的值，我们就可以通过逆过程和变换来计算与原始序列匹配的值。
- en: Thus, the properties of a stationary time series do not depend on the time when
    the series is observed. Implicitly, this means that time series that present seasonality
    or trends are not stationary. In this context, again, we must be careful of the
    difference between seasonality and cyclicity—cyclic time series that do not expose
    seasonal or trending patterns *are* stationary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，平稳时间序列的性质不依赖于观察序列的时间。隐含地，这意味着呈现季节性或趋势的时间序列不是平稳的。在这种情况下，我们再次必须小心季节性和周期性的区别——不暴露季节性或趋势模式的周期性时间序列是平稳的。
- en: Differencing a time series
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列的微分
- en: One way to make a time series stationary is by *differencing*. This means computing
    the difference between consecutive values. In this technique, we calculate the
    difference between a value at a certain point in time and the one at the previous
    instant.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使时间序列平稳的一种方法是通过*微分*。这意味着计算连续值之间的差分。在这种技术中，我们计算在特定时间点的值与之前时刻的值之间的差分。
- en: 'This can be easily computed by using the `diff` method that''s provided by
    `TimeSeries`. Differentiating a time series calculates the finite difference between
    two consecutive points in the time series. By default, the difference is by one
    day. Consider the following, for instance:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用`TimeSeries`提供的`diff`方法轻松计算。对时间序列进行微分计算的是时间序列中两个连续点之间的有限差分。默认情况下，差分是以一天为单位的。例如，考虑以下内容：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'One day from the original series is lost as part of the operation, with the
    resulting `TimeArray` beginning on January 2, 2005, resulting in the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 原始系列中的一天在操作过程中丢失了，导致`TimeArray`从2005年1月2日开始，结果如下：
- en: '![](img/ce2a54b2-d31c-4df3-85b4-e0a2b09d7af7.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce2a54b2-d31c-4df3-85b4-e0a2b09d7af7.png)'
- en: 'We can render the result as a bar plot:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果绘制成条形图：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We get the following result:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![](img/a1735f08-90c2-416a-a1a2-95557449f6d6.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1735f08-90c2-416a-a1a2-95557449f6d6.png)'
- en: Changes in the values are clearly visible throughout the entire dataset, meaning
    that the variance is relatively constant.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 整个数据集中值的变化清晰可见，这意味着方差相对恒定。
- en: Autocorrelation
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自相关
- en: Autocorrelation represents the degree of similarity of a time series and a lagged
    version of itself over successive time intervals. It is a very important concept
    as it measures the relationship between a current value and a corresponding past
    value. Thus, it has many valuable applications in time series forecasting; for
    example, to match trends and relationships in prices, stocks, returns, and so
    on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 自相关表示时间序列与其滞后版本在连续时间间隔内相似的程度。这是一个非常重要的概念，因为它衡量了当前值与相应过去值之间的关系。因此，它在时间序列预测中有许多有价值的用途；例如，匹配价格、股票、回报等中的趋势和关系。
- en: We want to use autocorrelation to determine if we can reliably identify causality
    and trend – or if, on the contrary, we're dealing with a random walk model. A
    random walk would imply that the values in the time series are randomly defined,
    and this would imply that there's no relationship between past and present values.
    The random walk model is common, especially for financial and economic data. For
    a random walk model, forecasting the next value is done by taking the last value
    in the series. This is due to the fact that future movements are unpredictable—they
    are equally likely to be increasing or decreasing. Thus, the random walk model
    underpins naïve forecasts.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用自相关来确定我们是否可以可靠地识别因果关系和趋势——或者相反，我们是否在处理一个随机游走模型。随机游走意味着时间序列中的值是随机定义的，这将意味着过去和现在的值之间没有关系。随机游走模型很常见，尤其是在金融和经济数据中。对于随机游走模型，预测下一个值是通过取序列中的最后一个值来完成的。这是由于未来运动是不可预测的——它们同样可能增加或减少。因此，随机游走模型是简单预测的基础。
- en: 'We can compute autocorrelation by using a combination of two functions—`TimeSeries.lag`
    and `xcorr`. The `lag` method works by shifting the values of the time series.
    For instance, let''s use our previously defined `ts1`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用两个函数的组合——`TimeSeries.lag`和`xcorr`来计算自相关。`lag`方法通过移动时间序列的值来实现。例如，让我们使用我们之前定义的`ts1`：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We get the following result:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下结果：
- en: '![](img/e8490e06-5b4f-4177-972a-5dcdc07db0c5.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8490e06-5b4f-4177-972a-5dcdc07db0c5.png)'
- en: 'We can apply the `lag` function as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下应用`lag`函数：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will cause the first value to be assigned to the next timestamp. In my
    case, the value `0.3903`, which was initially corresponding to `2018-11-06`, now
    corresponds to `2018-11-07`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致第一个值被分配给下一个时间戳。在我的例子中，最初对应于`2018-11-06`的值`0.3903`现在对应于`2018-11-07`：
- en: '![](img/5abd220a-976f-49e5-a274-89dcabea6cf3.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5abd220a-976f-49e5-a274-89dcabea6cf3.png)'
- en: Remember that if you run the code in parallel, your data will be different (the
    actual dates and values are different since we're using random values), but the
    behavior will be the same.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您并行运行代码，您的数据将不同（由于我们使用随机值，实际日期和值是不同的），但行为将是相同的。
- en: 'We can experiment with lagging the unemployment data by `12` intervals (12
    months) to account for the yearly seasonality:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将失业数据滞后`12`个区间（12个月）来考虑年度季节性：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/0b7d22d0-a167-4ee3-ac10-a6bff223918a.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b7d22d0-a167-4ee3-ac10-a6bff223918a.png)'
- en: 'The values have been shifted and the resulting `TimeArray` starts on the January
    1, 2006\. We can now use `TimeSeries.merge` to join the two series on the common
    timestamps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 值已经移动，结果`TimeArray`从2006年1月1日开始。我们现在可以使用`TimeSeries.merge`在共同的时戳上连接两个序列：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This results in the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/0daad74d-3e4d-4a16-a170-baafee8259e2.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0daad74d-3e4d-4a16-a170-baafee8259e2.png)'
- en: 'If we plot the original unemployment data together with the one year lagged
    series, we can see that the data is positively correlated, indicating strong yearly
    seasonality:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将原始失业数据与滞后一年的序列一起绘制，我们可以看到数据呈正相关，表明有强烈的年度季节性：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d7a5dcd7-fc92-41bc-b099-dd7965beacc5.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7a5dcd7-fc92-41bc-b099-dd7965beacc5.png)'
- en: Time series forecasting
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间序列预测
- en: Forecasting implies identifying models that fit the historical data and using
    them to predict future values. When forecasting time series data, decomposition
    plays a very important part, helping to make predictions more accurate. The underlying
    assumption is that we can be more precise if we forecast each component individually,
    using the best-suited method, and then sum or multiply the parts (depending on
    whether the model is additive or multiplicative) to compute the final value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 预测意味着识别适合历史数据的模型，并使用它们来预测未来的值。在预测时间序列数据时，分解起着非常重要的作用，有助于使预测更加准确。基本假设是，如果我们单独预测每个组件，使用最适合的方法，然后将部分求和或相乘（取决于模型是加法还是乘法）来计算最终值。
- en: Naïve
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单预测
- en: 'This is the simplest method, stating that the forecasted value is equal to
    the last value in the series. As mentioned previously, this is used with random
    walk models, where future movements are unpredictable. For example, to predict
    the value for the first unknown month, January 2018, using the naïve model, we
    can take the seasonally adjusted value from December 2017 and add (multiply) the
    seasonal component of the month of January:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的方法，它表明预测值等于序列中的最后一个值。如前所述，这种方法与随机游走模型一起使用，其中未来的移动是不可预测的。例如，为了使用简单模型预测第一个未知月份（2018年1月）的值，我们可以从2017年12月取季节性调整值并加上（乘以）1月份的季节性成分：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We use the `TimeSeries.update` method to append a new item for January 2018\.
    Its value is the seasonality adjusted value of December 2017, multiplied by the
    normalized seasonality of the month of January:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TimeSeries.update`方法为2018年1月添加一个新项目。其值是2017年12月的季节性调整值，乘以1月份的正常季节性：
- en: '![](img/d18a8e40-afba-409f-9f2c-8bdecb9a5dc2.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d18a8e40-afba-409f-9f2c-8bdecb9a5dc2.png)'
- en: Notice that we also assume that the seasonal component is unchanged, which means
    that we're using the seasonal naïve method for the seasonal component.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还假设季节性成分没有变化，这意味着我们在季节性成分上使用的是季节性简单方法。
- en: Simple average
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单平均
- en: 'A method that is slightly more advanced involves computing the mean of the
    previous data points to forecast the next value. It''s a basic approach but in
    some situations, it can be a good fit. To compute it, we can apply the `mean`
    function to the underlying array of values:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微先进的方法是计算前几个数据点的平均值来预测下一个值。这是一个基本的方法，但在某些情况下，它可以是一个很好的选择。为了计算它，我们可以将`mean`函数应用于值的基本数组：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Moving average
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平均
- en: We covered the moving average in detail when we extracted the trend component
    of our time series. It can also be employed for forecasting, using the result
    of the computation to fill up the next value. It is important to pick the right
    window size by understanding the series' seasonality, for example, by using autocorrelation
    plots.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在提取时间序列的趋势成分时详细介绍了移动平均。它也可以用于预测，使用计算结果来填充下一个值。重要的是要选择合适的窗口大小，通过理解序列的季节性，例如，使用自相关图。
- en: Linear regression
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性回归
- en: 'We can use linear regression on the seasonally adjusted time series to forecast
    the next value. Let''s take a closer look at this since it presents some good
    opportunities to dive into interesting Julia code. Since our data presents three
    trends (down, up, and down again), let''s focus only on the last segment, where
    the current downward trend can be observed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用线性回归对季节性调整的时间序列进行预测下一个值。让我们更仔细地看看这一点，因为它提供了深入了解有趣的Julia代码的好机会。由于我们的数据呈现三个趋势（下降、上升和再次下降），让我们只关注最后一个部分，其中可以观察到当前下降趋势：
- en: '![](img/8d5c2dbe-ff7c-4bb9-be65-b4b45d903353.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d5c2dbe-ff7c-4bb9-be65-b4b45d903353.png)'
- en: 'We can see that the current trend had started with an unemployment peak, so
    all we have to do is look for the maximum value in the series:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当前趋势始于失业高峰，所以我们只需要在序列中寻找最大值：
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We get the following value:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下值：
- en: '![](img/3ee71ee6-5f1e-4d1a-96a3-3a637f89e3e5.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3ee71ee6-5f1e-4d1a-96a3-3a637f89e3e5.png)'
- en: 'The downward trend started in February 2013\. Let''s extract all the data from
    that moment onward, all the way until the end of the series:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下降趋势始于2013年2月。让我们从那时起提取所有数据，一直到序列的末尾：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The result is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/7aeb19dc-f5f8-4506-bdb1-74066968866b.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7aeb19dc-f5f8-4506-bdb1-74066968866b.png)'
- en: We can now compute the linear regression—it will summarize the relationship
    between the unemployment numbers and the passing of time, allowing us to forecast
    the next value in the series. We have our unemployment numbers on the *y*-axis
    of the plot and the time on the *x*-axis. In this case, we can express `y` with
    the formula `y = a+b*x`, where `a` and `b` correspond to the linear regression.
    We'll compute the linear regression for the trend series to get `a` and `b`, and
    we'll calculate the next value of `y` (the unemployment forecast), corresponding
    to the next value of `x` (January 2018). Let's go through this, step by step.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以计算线性回归——它将总结失业数字与时间流逝之间的关系，使我们能够预测序列中的下一个值。我们在图的*Y*轴上有失业数字，在*X*轴上有时间。在这种情况下，我们可以用公式`y
    = a+b*x`来表示`y`，其中`a`和`b`对应于线性回归。我们将对趋势序列进行线性回归以获得`a`和`b`，并计算`y`的下一个值（失业预测），对应于`x`的下一个值（2018年1月）。让我们一步一步地来做这件事。
- en: 'The first thing we need to do is convert the timestamps in the time series
    into a simple integer series that we can use in our equation:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将时间序列中的时间戳转换为我们可以用于我们方程的简单整数序列：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On the *x*-axis, we use integer values from `1` to `59`, instead of the actual
    dates. In this line of thought, the next value, the one we want to forecast, will
    be `x = 60`, which means that our next `y` (the forecasted unemployment value)
    will be *27,608.61 + (-167.13 * 60)*:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在*x*轴上，我们使用从`1`到`59`的整数，而不是实际的日期。在这个思路下，下一个值，我们想要预测的值将是`x = 60`，这意味着我们的下一个`y`（预测的失业值）将是`27,608.61
    + (-167.13 * 60)`：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Like we did previously, we need to add the seasonality for the month of January:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们需要为1月份添加季节性：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can append it to our unemployment data and plot it:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将它附加到我们的失业数据上并绘制它：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result is the following plot:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/f48963a1-5285-4091-91ac-a9e9ba0cbf6c.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f48963a1-5285-4091-91ac-a9e9ba0cbf6c.png)'
- en: Our forecasted value has shown up on the plot.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预测的值已经显示在图表上了。
- en: Closing thoughts
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束语
- en: It should be mentioned that the preceding sections represent only a few of the
    simplest forecasting methods available. We focused on gaining a good understanding
    of time series decomposition, which is a key tool for both analysis and forecasting.
    However, more powerful and more complex forecasting algorithms are available,
    for example, **autoregressive integrated moving average** (**ARIMA**), **artificial
    neural networks** (**ANN**), and Holt-Winters. These are recommended for business-critical
    predictions. We have now set the foundation for understanding them, but their
    implementations are more involved and would go beyond the technical expertise
    assumed by this chapter—especially as Julia's package ecosystem, at the time of
    writing, does not provide any libraries that implement these algorithms, and we'd
    have to write them from scratch.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提到的是，前面的部分只代表了一些最简单的预测方法。我们专注于对时间序列分解有一个良好的理解，这是分析和预测的关键工具。然而，还有更强大、更复杂的预测算法可用，例如**自回归积分移动平均**（**ARIMA**）、**人工神经网络**（**ANN**）和Holt-Winters。这些算法适用于业务关键预测。我们现在已经为理解它们奠定了基础，但它们的实现更为复杂，超出了本章所假设的技术专长——特别是在撰写本文时，Julia的包生态系统没有提供任何实现这些算法的库，我们不得不从头开始编写。
- en: For instance, one commonly-used time series forecasting technique is the Holt-Winters
    method, also called **Triple exponential smoothing**. It is based on weighted
    moving averages and exponential smoothing, both of which have been covered already.
    You can read more about these at [https://www.otexts.org/fpp/7/2](https://www.otexts.org/fpp/7/2)
    and [https://www.otexts.org/fpp/7/5](https://www.otexts.org/fpp/7/5).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一种常用的时间序列预测技术是Holt-Winters方法，也称为**三重指数平滑**。它基于加权移动平均和指数平滑，这两者都已经介绍过了。你可以在[https://www.otexts.org/fpp/7/2](https://www.otexts.org/fpp/7/2)和[https://www.otexts.org/fpp/7/5](https://www.otexts.org/fpp/7/5)了解更多信息。
- en: ARIMA models are yet another very popular forecasting algorithm. They don't
    use the trend and seasonality components, instead focusing on autocorrelations
    in the data. If you're curious, a good starting point to learn about ARIMA models
    is [https://www.otexts.org/fpp/8](https://www.otexts.org/fpp/8).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ARIMA模型是另一种非常流行的预测算法。它们不使用趋势和季节性成分，而是专注于数据中的自相关性。如果你对此感兴趣，了解ARIMA模型的好起点是[https://www.otexts.org/fpp/8](https://www.otexts.org/fpp/8)。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Time series are a very common type of data—they can be used to represent key
    business metrics such as financial prices, resource usage (energy, water, raw
    materials, and so on), weather patterns, or macroeconomic trends—and the list
    could go on and on. The particularity of time series is that the data has to be
    collected at regular intervals, and the key aspect of time series analysis is
    exploring ways that allow us to understand past values so that we can predict
    future ones.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列是一种非常常见的数据类型——它们可以用来表示关键的业务指标，如金融价格、资源使用（能源、水、原材料等）、天气模式或宏观经济趋势——这个列表可以一直列下去。时间序列的特殊之处在于数据必须以固定的时间间隔收集，时间序列分析的关键方面是探索允许我们理解过去值以便预测未来值的方法。
- en: One powerful approach is to decompose a time series into a combination of trend,
    cycle, seasonality, and irregular (also called **error** or **noise**). We learned
    how to do this in this chapter while we analysed the EU's unemployment data. We
    started by learning to compute the trend component by means of moving averages.
    Then, we applied multiplicative series decomposition formulas to calculate seasonality
    and error, and we also applied basic forecasting methods to predict future values.
    In the process, we learned about more advanced `TimeSeries` methods and we experimented
    further with `Plots`. That was quite a ride—congratulations!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一种强大的方法是将时间序列分解为趋势、周期、季节性和不规则（也称为**误差**或**噪声**）的组合。在我们分析欧盟的失业数据时，我们学习了如何做到这一点。我们首先通过移动平均法学习计算趋势成分。然后，我们应用了乘法序列分解公式来计算季节性和误差，并且我们还应用了基本的预测方法来预测未来的值。在这个过程中，我们学习了更多高级的`TimeSeries`方法，并且进一步对`Plots`进行了实验。这是一段相当刺激的经历——祝贺你！
- en: In the next chapter, we will look at a few more advanced topics, including package
    development, benchmarking techniques for measuring and improving performance,
    generating documentation, and registering packages. How exciting—see you in the
    next chapter!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些更高级的主题，包括包的开发、用于衡量和改进性能的基准测试技术、生成文档以及注册包。多么令人兴奋——我们下一章见！
