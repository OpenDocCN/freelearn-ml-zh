- en: Chapter 2. Data Pipelines and Modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 数据管道和建模
- en: We have looked at basic hands-on tools for exploring the data in the previous
    chapter, thus we now can delve into more complex topics of statistical model building
    and optimal control or science-driven tools and problems. I will go ahead and
    say that we will only touch on some topics in optimal control since this book
    really is just about ML in Scala and not the theory of data-driven business management,
    which might be an exciting topic for a book on its own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中已经探讨了探索数据的基本动手工具，因此我们现在可以深入探讨更复杂的主题，如统计模型构建和最优控制或科学驱动工具和问题。我提前声明，我们只会触及最优控制的一些主题，因为这本书真正关注的是Scala中的机器学习，而不是数据驱动业务管理的理论，这可能是一个单独成书的激动人心的主题。
- en: 'In this chapter, I will stay away from specific implementations in Scala and
    discuss the problem of building a data-driven enterprise at a high level. Later
    chapters will address how to solve these smaller pieces of the puzzle. A special
    emphasis will be given to handing uncertainty. Uncertainty usually comes in several
    favors: first, there can be noise in the information we are provided with. Secondly,
    the information can be incomplete. The system may have some degree of freedom
    in filling the missing pieces, which results in uncertainty. Finally, there may
    be variations in the interpretation of the models and the resulting metrics. The
    final point is subtle, as most classic textbooks assume that we can measure things
    directly. Not only the measurements may be noisy, but the definition of the measure
    may change in time—try measuring satisfaction or happiness. Certainly, we can
    avoid the ambiguity by saying that we can optimize only measurable metrics, as
    people usually do, but it will significantly limit the application domain in practice.
    Nothing prevents the scientific machinery from handling the uncertainty in the
    interpretation into account as well.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将避免具体讨论Scala的实现，而是从高层次上讨论构建数据驱动企业的相关问题。后面的章节将解决这些难题的解决方案。特别强调处理不确定性。不确定性通常以几种形式出现：首先，我们提供的信息中可能存在噪声。其次，信息可能不完整。系统在填补缺失部分时可能有一定的自由度，这导致不确定性。最后，模型解释和结果指标可能存在差异。最后一个观点很微妙，因为大多数经典教科书都假设我们可以直接测量事物。不仅测量可能存在噪声，而且测量的定义可能随时间变化——尝试测量满意度或幸福感。当然，我们可以通过说我们只能优化可测量的指标来避免这种歧义，就像人们通常做的那样，但这将显著限制实际应用的范围。科学机器处理解释中的不确定性并没有什么阻止。
- en: The predictive models are often built just for data understanding. From the
    linguistic derivation, model is a simplified representation of the actual complex
    buildings or processes for exactly the purpose of making a point and convincing
    people, one or another way. The ultimate goal for predictive modeling, the modeling
    I am concerned about in this book and this chapter specifically, is to optimize
    the business processes by taking the most important factors into account in order
    to make the world a better place. This was certainly a sentence with a lot of
    uncertainty entrenched, but at least it looks like a much better goal than optimizing
    a click-through rate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 预测模型通常只是为了数据理解而构建。从语言学的推导来看，模型是对实际复杂建筑或过程的简化表示，其目的正是为了阐明观点和说服人们，无论通过何种方式。预测模型的最终目标，也就是我在本书和本章中关注的目标，是通过考虑最重要的因素来优化业务流程，以便让世界变得更美好。这当然是一个充满不确定性的句子，但至少它看起来比优化点击率要好得多。
- en: 'Let''s look at a traditional business decision-making process: a traditional
    business might involve a set of C-level executives making decisions based on information
    that is usually obtained from a set of dashboards with graphical representation
    of the data in one or several DBs. The promise of an automated data-driven business
    is to be able to automatically make most of the decisions provided the uncertainties
    eliminating human bias. This is not to say that we no longer need C-level executives,
    but the C-level executives will be busy helping the machines to make the decisions
    instead of the other way around.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看传统的商业决策过程：一个传统的商业可能涉及一组C级高管基于通常从一组包含一个或多个数据库中数据图形表示的仪表板中获得的信息做出决策。自动化数据驱动商业的承诺是能够在消除人类偏见的不确定性下自动做出大多数决策。这并不是说我们不再需要C级高管，但C级高管将忙于帮助机器做出决策，而不是相反。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Going through the basics of influence diagrams as a tool for decision making
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握影响图作为决策工具的基本知识
- en: Looking at variations of the pure decision making optimization in the context
    of adaptive **Markov Decision** making process and **Kelly Criterion**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自适应**马尔可夫决策过程**和**凯利准则**的背景下，研究纯决策优化变体
- en: Getting familiar with at least three different practical strategies for exploration-exploitation
    trade-off
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉至少三种不同的探索-利用权衡策略
- en: Describing the architecture of a data-driven enterprise
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述数据驱动企业的架构
- en: Discussing major architectural components of a decision-making pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论决策流程的主要架构组件
- en: Getting familiar with standard tools for building data pipelines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉构建数据管道的标准工具
- en: Influence diagrams
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影响图
- en: 'While the decision making process can have multiple facets, a book about decision
    making under uncertainty would be incomplete without mentioning influence diagrams
    (*Influence Diagrams for Team Decision Analysis*, Decision Analysis 2 (4): 207–228),
    which help the analysis and understanding of the decision-making process. The
    decision may be as mundane as selection of the next news article to show to a
    user in a personalized environment or a complex one as detecting malware on an
    enterprise network or selecting the next research project.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然决策过程可能有多个方面，但一本关于不确定性下决策的书如果没有提到影响图（*团队决策分析的影响图*，决策分析 2 (4): 207–228）将是不完整的，因为影响图有助于分析和理解决策过程。决策可能像在个性化环境中向用户展示下一篇新闻文章的选择这样平凡，也可能像在企业网络中检测恶意软件或选择下一个研究项目这样复杂。'
- en: 'Depending on the weather she can try and go on a boat trip. We can represent
    the decision-making process as a diagram. Let''s decide whether to take a river
    boat tour during her stay in Portland, Oregon:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据天气情况，她可以尝试进行一次乘船旅行。我们可以将决策过程表示为图表。让我们决定是否在她待在俄勒冈州波特兰期间参加河上观光游：
- en: '![Influence diagrams](img/B04935_02_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![影响图](img/B04935_02_01.jpg)'
- en: Figure 02-1\. A simple vacation influence diagram to represent a simple decision-making
    process. The diagram contains decision nodes such as Vacation Activity, observable
    and unobservable information nodes such as Weather Forecast and Weather, and finally
    the value node such as Satisfaction
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 02-1\. 一个简单的假期影响图，用于表示简单的决策过程。该图包含决策节点，如假期活动，以及可观察和不可观察的信息节点，如天气预报和天气，最后是价值节点，如满意度
- en: The preceding diagram represents this situation. The decision whether to participate
    in the activity is clearly driven by the potential to get certain satisfaction,
    which is a function of the decision itself and the weather at the time of the
    activity. While the actual weather conditions are unknown at the time of the trip
    planning, we believe there is a certain correlation between the weather forecast
    and the actual weather experienced during the trip, which is represented by the
    edge between the **Weather** and **Weather Forecast** nodes. The **Vacation Activity**
    node is the decision node, it has only one parent as the decision is made solely
    based on **Weather Forecast**. The final node in the DAG is **Satisfaction**,
    which is a function of the actual whether and the decision we made during the
    trip planning—obviously, *yes + good weather* and *no + bad weather* are likely
    to have the highest scores. The *yes + bad weather* and *no + good weather* would
    be a bad outcome—the latter case is probably just a missed opportunity, but not
    necessarily a bad decision, provided an inaccurate weather forecast.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表表示这种情况。是否参加活动的决策明显是由获得一定满意度的可能性驱动的，这是决策本身和活动当时天气的函数。虽然实际天气条件在旅行计划时是未知的，但我们相信天气预报和旅行期间实际经历的天气之间存在一定的相关性，这由**天气**和**天气预报**节点之间的边表示。**假期活动**节点是决策节点，它只有一个父节点，因为决策完全基于**天气预报**。DAG中的最后一个节点是**满意度**，它是实际天气和我们在旅行计划期间所做的决策的函数——显然，“是
    + 好天气”和“否 + 坏天气”可能得分最高。而“是 + 坏天气”和“否 + 好天气”将是一个不良的结果——后者可能只是错过了一个机会，但并不一定是一个糟糕的决定，前提是天气预报不准确。
- en: The absence of an edge carries an independence assumption. For example, we believe
    that **Satisfaction** should not depend on **Weather Forecast**, as the latter
    becomes irrelevant once we are on the boat. Once the vacation plan is finalized,
    the actual weather during the boating activity can no longer affect the decision,
    which was made solely based on the weather forecast; at least in our simplified
    model, where we exclude the option of buying a trip insurance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 边界的缺失包含了一个独立性假设。例如，我们相信**满意度**不应该依赖于**天气预报**，因为一旦我们上了船，后者就变得无关紧要。一旦度假计划确定，实际的水上活动中的天气状况就不再影响决策，该决策完全是基于天气预报做出的；至少在我们的简化模型中，我们排除了购买旅行保险的选项。
- en: 'The graph shows different stages of decision making and the flow of information
    (we will provide an actual graph implementation in Scala in [Chapter 7](ch07.xhtml
    "Chapter 7. Working with Graph Algorithms"), *Working with Graph Algorithms*).
    There is only one piece of information required to make the decision in our simplified
    diagram: the weather forecast. Once the decision is made, we can no longer change
    it, even if we have information about the actual weather at the time of the trip.
    The weather and the decision data can be used to model her satisfaction with the
    decision she has made.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了决策的不同阶段和信息流（我们将在第7章[Chapter 7. Working with Graph Algorithms](ch07.xhtml
    "Chapter 7. Working with Graph Algorithms")中提供Scala的实际图表实现）。在我们的简化图中，做出决策只需要一条信息：天气预报。一旦做出决策，我们就无法更改它，即使我们拥有旅行时实际天气的信息。天气和决策数据可以用来模拟她对所做决策的满意度。
- en: 'Let''s map this approach to an advertising problem as an illustration: the
    ultimate goal is to get user satisfaction with the targeted ads, which results
    in additional revenue for an advertiser. The satisfaction is the function of user-specific
    environmental state, which is unknown at the time of decision making. Using machine
    learning algorithms, however, we can forecast this state based on the user''s
    recent Web visit history and other information that we can gather, such as geolocation,
    browser-agent string, time of day, category of the ad, and so on (refer to *Figure
    02-2*).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种方法映射到一个广告问题作为说明：最终目标是获得用户对目标广告的满意度，这将为广告商带来额外的收入。满意度是用户特定环境状态的函数，在决策时是未知的。然而，使用机器学习算法，我们可以根据用户的最近网页访问历史和其他信息来预测这种状态，例如地理位置、浏览器代理字符串、一天中的时间、广告类别等等（参见图02-2）。
- en: 'While we are unlikely to measure the level of dopamine in the user''s brain,
    which will certainly fall under the realm of measurable metrics and probably reduce
    the uncertainty, we can measure the user satisfaction indirectly by the user''s
    actions, either the fact that they responded to the ad or even the measure of
    time the user spent between the clicks to browse relevant information, which can
    be used to estimate the effectiveness of our modeling and algorithms. Here is
    an influence diagram, similar to the one for "vacation", adjusted for the advertising
    decision-making process:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不太可能测量用户大脑中的多巴胺水平，这肯定会落入可测量指标的范畴，并可能减少不确定性，但我们可以通过用户的行为间接测量用户满意度，无论是他们是否对广告做出了回应，还是用户在点击浏览相关信息之间花费的时间，这些都可以用来估计我们建模和算法的有效性。以下是一个影响图，类似于“度假”的影响图，调整用于广告决策过程：
- en: '![Influence diagrams](img/B04935_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![影响图](img/B04935_02_02.jpg)'
- en: Figure 02-2\. The vacation influence diagram adjusted to the online advertising
    decision-making case. The decisions for online advertising can be made thousand
    times per second
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图02-2. 调整到在线广告决策案例的度假影响图。在线广告的决策可以每秒做出数千次。
- en: The actual process might be more complex, representing a chain of decisions,
    each one depending on a few previous time slices. For example, the so-called **Markov
    Chain Decision Process**. In this case, the diagram might be repeated over multiple
    time slices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际过程可能更复杂，代表了一系列决策，每个决策都依赖于几个先前的时段。例如，所谓的**马尔可夫链决策过程**。在这种情况下，图表可能需要在多个时段上重复。
- en: Yet another example might be Enterprise Network Internet malware analytics system.
    In this case, we try to detect network connections indicative of either **command
    and control** (**C2**), lateral movement, or data exfiltration based on the analysis
    of network packets flowing through the enterprise switches. The goal is to minimize
    the potential impact of an outbreak with minimum impact on the functioning systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是企业网络互联网恶意软件分析系统。在这种情况下，我们试图根据对企业交换机流经的网络数据包的分析来检测指示**指挥与控制**（**C2**）、横向移动或数据泄露的网络连接。目标是最大限度地减少爆发对系统功能的最小影响。
- en: One of the decisions we might take is to reimage a subset of nodes or to at
    least isolate them. The data we collect may contain uncertainty—many benign software
    packages may send traffic in suspicious ways, and the models need to differentiate
    between them based on the risk and potential impact. One of the decisions in this
    specific case may be to collect additional information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能做出的一个决定是重新映像节点的一个子集，或者至少将它们隔离。我们收集的数据可能包含不确定性——许多良性软件包可能会以可疑的方式发送流量，而模型需要根据风险和潜在影响将它们区分开来。在这个特定案例中的一个决定可能是收集更多信息。
- en: I will leave it to the reader to map this and other potential business cases
    to the corresponding diagram as an exercise. Let's consider a more complex optimization
    problem now.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把这个以及其他潜在的商业案例映射到相应的图表上作为练习留给读者。现在让我们考虑一个更复杂的优化问题。
- en: Sequential trials and dealing with risk
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序试验和风险管理
- en: 'What if my preferences for making an extra few dollars outweigh the risk of
    losing the same amount? I will stop on why one''s preferences might be asymmetric
    in a little while in this section, and there is scientific evidence that this
    asymmetry is ingrained in our minds for evolutionary reasons, but you are right,
    I have to optimize the expected value of the asymmetric function of the parameterized
    utility now, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我为了多赚几美元而愿意承担损失同样金额的风险，那会怎样？我将在本节稍后解释为什么一个人的偏好可能是不对称的，并且有科学证据表明这种不对称性是由于进化原因而根植于我们心中的，但您是对的，我现在必须优化参数化效用函数的不对称函数的期望值，如下所示：
- en: '![Sequential trials and dealing with risk](img/B04935_02_01F.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![顺序试验和风险管理](img/B04935_02_01F.jpg)'
- en: 'Why would an asymmetric function surface in the analysis? One example is repeated
    bets or re-investments, also known as the Kelly Criterion problem. Although originally,
    the Kelly Criterion was developed for a specific case of binary outcome as in
    a gambling machine and the optimization of the fraction of money to bet in each
    round (*A New Interpretation of Information Rate*, Bell System Technical Journal
    35 (4): 917–926, 1956), a more generic formulation as an re-investment problem
    involves a probabilistic distribution of possible returns.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '为什么不对称函数会在分析中显现出来？一个例子是重复投注或再投资，也称为凯利公式问题。虽然最初，凯利公式是为赌博机等二元结果的特定情况开发的，用于优化每轮投注的金钱比例（*《信息率的新解释》*，贝尔系统技术期刊
    35 (4): 917–926，1956），但作为一个更通用的再投资问题，它涉及到可能回报的概率分布。'
- en: 'The return over multiple bets is a product of individual return rates on each
    of the bets—the return rate is the ratio between the bankroll after the bet to
    the original bankroll before each individual bet, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多次投注的回报是每次投注的个别回报率的乘积——回报率是投注后的资金与每次个别投注前的原始资金的比率，如下所示：
- en: '![Sequential trials and dealing with risk](img/B04935_02_02F.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![顺序试验和风险管理](img/B04935_02_02F.jpg)'
- en: 'This does not help us much to optimize the total return as we don''t know how
    to optimize the product of *i.i.d*. random variables. However, we can convert
    the product to a sum using log transformation and apply the **central limit theorem**
    (**CLT**) to approximate the sum of *i.i.d*. variables (provided that the distribution
    of *r* *[i]* is subect to CLT conditions, for example, has a finite mean and variance),
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们优化总回报帮助不大，因为我们不知道如何优化**独立同分布**随机变量的乘积。然而，我们可以通过对数变换将乘积转换为和，并应用**中心极限定理**（**CLT**）来近似**独立同分布**变量的和（假设*r*的分布满足CLT条件，例如，具有有限的均值和方差），如下所示：
- en: '![Sequential trials and dealing with risk](img/B04935_02_03F.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![顺序试验和风险管理](img/B04935_02_03F.jpg)'
- en: Thus, the cumulative result of making *N* bets would look like the result of
    making *N* bets with expected return of ![Sequential trials and dealing with risk](img/B04935_02_04F.jpg),
    and not ![Sequential trials and dealing with risk](img/B04935_02_05F.jpg)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，进行 *N* 次投注的累积结果将类似于进行 *N* 次预期收益为 ![顺序试验和风险处理](img/B04935_02_04F.jpg) 的投注，而不是
    ![顺序试验和风险处理](img/B04935_02_05F.jpg)
- en: 'As I mentioned before, the problem is most often applied for the case of binary
    bidding, although it can be easily generalized, in which case there is an additional
    parameter: *x*, the amount of money to bid in each round. Let''s say I make a
    profit of *W* with probability *p* or completely lose my bet otherwise with the
    probability *(1-p)*. Optimizing the expected return with respect to the following
    additional parameter:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，这个问题最常应用于二元投标的情况，尽管它可以很容易地推广，在这种情况下，还有一个额外的参数：*x*，即每轮投注的金额。假设我以概率 *p*
    获得利润 *W*，或者以概率 *(1-p)* 完全输掉赌注。优化以下附加参数的预期回报：
- en: '![Sequential trials and dealing with risk](img/B04935_02_06F.jpg)![Sequential
    trials and dealing with risk](img/B04935_02_07F.jpg)![Sequential trials and dealing
    with risk](img/B04935_02_08F.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![顺序试验和风险处理](img/B04935_02_06F.jpg)![顺序试验和风险处理](img/B04935_02_07F.jpg)![顺序试验和风险处理](img/B04935_02_08F.jpg)'
- en: The last equation is the Kelly Criterion ratio and gives you the optimal amount
    to bet.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方程是凯利公式比率，它给出了最佳投注金额。
- en: 'The reason that one might bet less than the total amount is that even if the
    average return is positive, there is still a possibility to lose the whole bankroll,
    particularly, in highly skewed situations. For example, even if the probability
    of making *10 x* on your bet is *0.105* (*W = 10*, the expected return is *5%)*,
    the combinatorial analysis show that even after *60* bets, there is roughly a
    *50%* chance that the overall return will be negative, and there is an *11%* chance,
    in particular, of losing *(57 - 10 x 3) = 27* times your bet or more:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可能会投注少于总额的原因是，即使平均回报是正的，仍然有可能输掉全部银行账户，尤其是在高度偏斜的情况下。例如，即使你投注获得 *10 x* 的概率为
    *0.105* (*W = 10*，预期回报为 *5%)*，组合分析显示，即使经过 *60* 次投注，整体回报为负的大约概率为 *50%*，特别是有 *11%*
    的概率会输掉 *(57 - 10 x 3) = 27* 倍的投注或更多：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that to recover the *27 x* amount, one would need to play only ![Sequential
    trials and dealing with risk](img/B04935_02_09F.jpg) additional rounds on average
    with these favourable odds, but one must have something to bet to start with.
    The Kelly Criterion provides that the optimal is to bet only *1.55%* of our bankroll.
    Note that if I bet the whole bankroll, I would lose all my money with 89.5% certainty
    in the first round (the probability of a win is only *0.105*). If I bet only a
    fraction of the bankroll, the chances of staying in the game are infinitely better,
    but the overall returns are smaller. The plot of expected log of return is shown
    in *Figure 02-3* as a function of the portions of the bankroll to bet, *x*, and
    possible distribution of outcomes in 60 bets that I just computed. In 24% of the
    games we''ll do worse than the lower curve, in 39% worse than the next curve,
    in about half—44%—a gambler we''ll do the same or better than the black curve
    in the middle, and in 30% of cases better than the top one. The optimal Kelly
    Criterion value for *x* is *0.0155*, which will eventually optimize the overall
    return over infinitely many rounds:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了收回 *27 x* 的金额，平均来说，只需要在这些有利赔率的条件下再玩 ![顺序试验和风险处理](img/B04935_02_09F.jpg)
    轮额外的游戏即可。但必须先有可以投注的金额。凯利公式指出，最佳策略是只投注我们银行账户的 *1.55%*。注意，如果我投注全部银行账户，我将在第一轮（获胜的概率仅为
    *0.105*）以 89.5% 的确定性输掉所有钱。如果我只投注银行账户的一部分，留在游戏中的机会将无限好，但整体回报会较小。预期对数回报的图示如图 *02-3*
    所示，它是银行账户投注比例 *x* 和我刚刚计算的 60 次投注可能结果分布的函数。在 24% 的游戏中，我们的表现将不如下方的曲线，在 39% 的游戏中不如下一条曲线，大约一半——44%——的赌徒的表现将与中间的黑色曲线相同或更好，而在
    30% 的情况下表现将优于最上面的曲线。对于 *x* 的最佳凯利公式值为 *0.0155*，这将最终优化无限多轮次的整体回报：
- en: '![Sequential trials and dealing with risk](img/B04935_02_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![顺序试验和风险处理](img/B04935_02_03.jpg)'
- en: Figure 02-3\. The expected log of return as a function of the bet amount and
    possible outcomes in 60 rounds (see equation (2.2))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 02-3\. 投注金额和 60 轮可能结果作为函数的预期对数回报（参见方程式 (2.2)）
- en: The Kelly Criterion has been criticized for being both too aggressive (gamblers
    tend to overestimate their winning potential/ratio and underestimate the probability
    of a ruin), as well as for being too conservative (the value at risk should be
    the total available capital, not just the bankroll), but it demonstrates one of
    the examples where we need to compensate our intuitive understanding of the "benefit"
    with some additional transformations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 凯利公式因其过于激进（赌徒往往高估他们的获胜潜力/比率并低估破产的概率）以及过于保守（风险价值应该是总可用资本，而不仅仅是赌注）而受到批评，但它展示了我们需要用一些额外的转换来补偿我们对“收益”的直观理解的一个例子。
- en: 'From the financial point of view, the Kelly Criterion is a much better description
    of risk than the standard definition as volatility or variance of the returns.
    For a generic parametrized payoff distribution, *y(z)*, with a probability distribution
    function, *f(z)*, the equation (2.3) can be reformulated as follows. after the
    substitution *r(x) = 1 + x y(z)*, where *x* is still the amount to bet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从金融角度来看，凯利公式比标准定义（如回报的波动性或方差）更好地描述了风险。对于具有概率分布函数*f(z)*的通用参数化收益分布*y(z)*，方程(2.3)可以重新表述如下。在替换*r(x)
    = 1 + x y(z)*后，其中*x*仍然是投注的金额：
- en: '![Sequential trials and dealing with risk](img/B04935_02_10F.jpg)![Sequential
    trials and dealing with risk](img/B04935_02_11F.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![连续试验和风险管理](img/B04935_02_10F.jpg)![连续试验和风险管理](img/B04935_02_11F.jpg)'
- en: 'It can also be written in the following manner in the discrete case:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在离散情况下，它也可以写成以下形式：
- en: '![Sequential trials and dealing with risk](img/B04935_02_12F.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![连续试验和风险管理](img/B04935_02_12F.jpg)'
- en: Here, the denominator emphasizes the contributions from the regions with negative
    payoffs. Specifically, the possibility of losing all your bankroll is exactly
    where the denominator ![Sequential trials and dealing with risk](img/B04935_02_13F.jpg)
    is zero.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，分母强调了来自负收益区域的贡献。具体来说，失去所有赌注的可能性正是分母![连续试验和风险管理](img/B04935_02_13F.jpg)为零的地方。
- en: As I mentioned before, interestingly, risk aversion is engrained in our intuitions
    and there seems to be a natural risk-aversion system of preferences encoded in
    both humans and primates (*A Monkey Economy as Irrational as Ours* by Laurie Santos,
    TED talk, 2010). Now enough about monkeys and risk, let's get into another rather
    controversial subject—the exploration-exploitation trade-off, where one might
    not even know the payoff trade-offs initially.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，有趣的是，风险规避植根于我们的直觉，似乎在人类和灵长类动物中编码了一个自然的风险规避偏好系统（劳里·桑托斯所著《像我们一样不理性的猴子经济》，TED演讲，2010年）。现在关于猴子与风险的话题就到这里，让我们进入另一个相当有争议的主题——探索-利用权衡，其中一个人可能甚至一开始都不知道收益权衡。
- en: Exploration and exploitation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索与利用
- en: 'The exploration-exploitation trade-off is another problem that has its apparent
    origin within gambling, even though the real applications range from allocation
    of funding to research projects to self-driving cars. The traditional formulation
    is a multi-armed bandit problem, which refers to an imaginary slot machine with
    one or more arms. Sequential plays of each arm generate *i.i.d* `.` returns with
    unknown probabilities for each arm; the successive plays are independent in the
    simplified models. The rewards are assumed to be independent across the arms.
    The goal is to maximize the reward—for example, the amount of money won, and to
    minimize the learning loss, or the amount spend on the arms with less than optimal
    winning rate, provided an agreed upon arm selection policy. The obvious trade-off
    is between the **exploration** in search of an arm that produces the best return
    and **exploitation** of the best-known arm with optimal return:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 探索-利用权衡是另一个问题，尽管其真实应用范围从研究项目的资金分配到自动驾驶汽车，但其明显的起源在赌博中。传统的公式是多臂老虎机问题，它指的是一个或多个臂的想象中的老虎机。每个臂的连续操作生成具有未知概率的*i.i.d*
    `.`回报；在简化模型中，连续操作是独立的。假设奖励在臂之间是独立的。目标是最大化奖励——例如，赢得的金额，并最小化学习损失，即花费在获胜率低于最优的臂上的金额，前提是有一个商定的臂选择策略。明显的权衡在于**探索**以寻找产生最佳回报的臂和**利用**已知最佳回报的臂：
- en: '![Exploration and exploitation](img/B04935_02_14F.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![探索与利用](img/B04935_02_14F.jpg)'
- en: 'The **pseudo-regret** is then the difference:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪后悔**是指以下差异：'
- en: '![Exploration and exploitation](img/B04935_02_15F.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![探索与利用](img/B04935_02_15F.jpg)'
- en: Here, ![Exploration and exploitation](img/B04935_02_16F.jpg) is the *i^(th)*
    arm selection out of *N* trials. The multi-armed bandit problem was extensively
    studied in the 1930s and again during the early 2000s, with the application in
    finance and ADTECH. While in general, due to stochastic nature of the problem,
    it is not possible to provide a bound on the expected regret better than the square
    root of *N*, the pseudo-regret can be controlled so that we are able to bound
    it by a log of *N* (*Regret Analysis of Stochastic and Nonstochastic Multi-armed
    Bandit Problems* by Sebastien Bubeck and Nicolo Cesa-Bianchi, [http://arxiv.org/pdf/1204.5721.pdf](http://arxiv.org/pdf/1204.5721.pdf)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![探索与利用](img/B04935_02_16F.jpg) 是从 *N* 次试验中选出的 *i* 臂。多臂老虎机问题在 1930 年代和 2000
    年代初被广泛研究，应用在金融和 ADTECH 中。虽然由于问题的随机性，通常无法提供一个比 *N* 的平方根更好的预期遗憾界限，但伪遗憾可以被控制，以便我们能够将其限制为
    *N* 的对数（Sebastien Bubeck 和 Nicolo Cesa-Bianchi 的《随机和非随机多臂老虎机问题的遗憾分析》，[http://arxiv.org/pdf/1204.5721.pdf](http://arxiv.org/pdf/1204.5721.pdf)）。
- en: One of the most common strategies used in practice is epsilon strategies, where
    the optimal arm is chosen with the probability of ![Exploration and exploitation](img/B04935_02_17F.jpg)
    and one of the other arms with the remaining probability. The drawback of this
    approach is that we might spend a lot of exploration resources on the arms that
    are never going to provide any rewards. The UCB strategy improves the epsilon
    strategy by choosing an arm with the largest estimate of the return, plus some
    multiple or fraction of the standard deviation of the return estimates. The approach
    needs the recomputation of the best arm to pull at each round and suffers from
    approximations made to estimate the mean and standard deviation. Besides, UCB
    requires the recomputation of the estimates for each successive pull, which might
    be a scalability problem.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中最常用的策略之一是 epsilon 策略，其中最优臂以 ![探索与利用](img/B04935_02_17F.jpg) 的概率被选中，而其他臂以剩余的概率被选中。这种方法的缺点是我们可能会在永远不会提供任何奖励的臂上花费大量的探索资源。UCB
    策略通过选择回报估计最大的臂，加上一些回报估计标准差的倍数或分数来改进 epsilon 策略。这种方法需要在每一轮重新计算最佳臂，并受到用于估计均值和标准差的近似的影响。此外，UCB
    需要为每次连续抽取重新计算估计值，这可能会成为可扩展性问题。
- en: 'Finally, the Thompson sampling strategy uses a fixed random sample from Beta-Bernoulli
    posterior estimates and assigns the next arm to the one that gives the minimal
    expected regret, for which real data can be used to avoid parameter recomputation.
    Although the specific numbers may depend on the assumptions, one available comparison
    for these model performances is provided in the following diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Thompson 抽样策略使用 Beta-Bernoulli 后验估计的固定随机样本，并将下一个臂分配给给出最小预期遗憾的臂，这样可以使用真实数据来避免参数重新计算。尽管具体数字可能取决于假设，以下图表提供了一个可用于比较这些模型性能的可用比较：
- en: '![Exploration and exploitation](img/B04935_02_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![探索与利用](img/B04935_02_04.jpg)'
- en: Figure 02-3\. The simulation results for different exploration exploitation
    strategies for K = 5, one-armed bandits, and different strategies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 02-3\. K = 5，单臂老虎机，不同策略的探索利用策略模拟结果。
- en: '*Figure 02-3* shows simulation results for different strategies (taken from
    the Rich Relevance website at [http://engineering.richrelevance.com/recommendations-thompson-sampling](http://engineering.richrelevance.com/recommendations-thompson-sampling)).
    The **Random** strategy just allocates the arms at random and corresponds to pure
    exploration. The **Naive** strategy is random up to a certain threshold and than
    switches to pure Exxploitation mode. **Upper Confidence Bound** (**UCB**) with
    95% confidence level. UCB1 is a modification of UCB to take into account the log-normality
    of the distributions. Finally the Thompson sampling strategy makes a random sample
    from actual posterior distribution to optimize the regret.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 02-3* 展示了不同策略的模拟结果（摘自 Rich Relevance 网站上的 [http://engineering.richrelevance.com/recommendations-thompson-sampling](http://engineering.richrelevance.com/recommendations-thompson-sampling)）。**随机**策略只是随机分配臂，对应于纯探索。**朴素**策略在某个阈值内是随机的，然后切换到纯利用模式。**上置信界**（**UCB**）置信水平为
    95%。UCB1 是对 UCB 的修改，以考虑分布的对数正态性。最后，Thompson 抽样策略从实际后验分布中随机抽样以优化遗憾。'
- en: Exploration/exploitation models are known to be very sensitive to the initial
    conditions and outliers, particularly on the low-response side. One can spend
    enormous amount of trials on the arms that are essentially dead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 探索/利用模型众所周知对初始条件和异常值非常敏感，尤其是在低响应方面。一个人可以在本质上已经失败的武器上花费巨大的试验。
- en: Other improvements on the strategies are possible by estimating better priors
    based on additional information, such as location, or limiting the set of arms
    to explore—*K*—due to such additional information, but these aspects are more
    domain-specific (such as personalization or online advertising).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基于额外信息（如位置）估计更好的先验概率，或者由于这种额外信息而限制探索武器的集合——*K*——，可以可能地对策略进行其他改进，但这些方面更具有领域特定性（如个性化或在线广告）。
- en: Unknown unknowns
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未知之未知
- en: 'Unknown unknowns have been largely made famous due to a phrase from a response
    the United States Secretary of Defense, Donald Rumsfeld, gave to a question at
    a United States **Department of Defense** (**DoD**) news briefing on February
    12, 2002 about the lack of evidence linking the government of Iraq with the supply
    of weapons of mass destruction to terrorist groups, and books by Nassim Taleb
    (*The Black Swan: The Impact of the Highly Improbable* by Nassim Taleb, Random
    House, 2007).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 未知之未知因其与美国国防部长唐纳德·拉姆斯菲尔德在2002年2月12日的一次美国国防部（**DoD**）新闻发布会上对关于伊拉克政府与向恐怖组织供应大规模杀伤性武器缺乏证据的提问的回答中的一句话而广为人知，以及纳西姆·尼古拉斯·塔勒布的书籍（《黑天鹅：几乎不可能发生的事件的影响》由纳西姆·尼古拉斯·塔勒布著，Random
    House出版社，2007年）。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '**Turkey paradox**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**火鸡悖论**'
- en: Arguably, the unknown unknown is better explained by the turkey paradox. Suppose
    you have a family of turkeys playing in the backyard and enjoying protection and
    free food. Across the fence, there is another family of turkeys. This all works
    day after day, and month after month, until Thanksgiving comes—Thanksgiving Day
    is a national holiday celebrated in Canada and the United States, where it's customary
    to roast the turkeys in an oven. The turkeys are very likely to be harvested and
    consumed at this point, although from the turkey's point of view, there is no
    discernable signal that anything will happen on the second Monday of October in
    Canada and the fourth Thursday of November in the United States. No amount of
    modeling on the within-the-year data can fix this prediction problem from the
    turkey's point of view besides the additional year-over-year information.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，未知之未知可以通过火鸡悖论来更好地解释。假设你有一群火鸡在后院玩耍，享受保护和免费食物。栅栏的另一边，还有另一群火鸡。这一切日复一日，月复一月，直到感恩节来临——感恩节是加拿大和美国庆祝的全国性假日，在这一天，人们习惯于在烤箱里烤火鸡。火鸡很可能在这个时候被收割并消费，尽管从火鸡的角度来看，加拿大10月第二个星期一和美国11月第四个星期四没有任何明显的信号表明会发生任何事情。除了额外的年度信息之外，没有任何模型可以在火鸡的角度上解决这个问题。
- en: The unknown unknown is something that is not in the model and cannot be anticipated
    to be in the model. In reality, the only unknown unknowns that are of interest
    are the ones that affect the model so significantly that the results that were
    previously virtually impossible, or possible with infinitesimal probability, now
    become the reality. Given that most of the practical distributions are from exponential
    family with really thin tails, the deviation from normal does not have to be more
    than a few sigmas to have devastating results on the standard model assumptions.
    While one has still to come up with an actionable strategy of how to include the
    unknown factors in the model—a few ways have been proposed, including fractals,
    but few if any are actionable—the practitioners have to be aware of the risks,
    and here the definition of the risk is exactly the possibility of delivering the
    models useless. Of course, the difference between the known unknown and unknown
    unknown is exactly that we understand the risks and what needs to be explored.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 未知之未知是那些不在模型中且无法预测将出现在模型中的东西。在现实中，唯一真正感兴趣的未知之未知是那些对模型影响如此之大，以至于之前几乎不可能或几乎不可能发生的结果现在变成了现实。鉴于大多数实际分布都属于指数家族，尾部非常薄，因此，与正常分布的偏差不必超过几个标准差，就会对标准模型假设产生破坏性的影响。尽管人们仍然需要想出一个可操作的策略来如何在模型中包含未知因素——已经提出了几种方法，包括分形，但很少有可操作的——从业者必须意识到风险，这里的定义就是模型无用的可能性。当然，已知之未知和未知之未知之间的区别正是我们理解风险和需要探索的内容。
- en: As we looked at the basic scope of problems that the decision-making systems
    are facing, let's look at the data pipelines, the software systems that provide
    information for making the decisions, and more practical aspects of designing
    the data pipeline for a data-driven system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们审视决策系统面临的基本问题范围时，让我们看看数据管道，提供决策信息的软件系统，以及为数据驱动系统设计数据管道的更实际方面。
- en: Basic components of a data-driven system
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据驱动系统的基本组件
- en: 'In short, a data-driven architecture contains the following components—at least
    all the systems I''ve seen have them—or can be reduced to these components:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，数据驱动架构包含以下组件——至少我所见到的所有系统都有这些组件——或者可以简化为这些组件：
- en: '**Data ingest**: We need to collect the data from systems and devices. Most
    of the systems have logs, or at least an option to write files into a local filesystem.
    Some can have capabilities to report information to network-based interfaces such
    as syslog, but the absence of persistence layer usually means potential data loss,
    if not absence of audit information.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据摄取**: 我们需要从系统和设备中收集数据。大多数系统都有日志，或者至少有将文件写入本地文件系统的选项。一些系统可能具有将信息报告给基于网络的接口（如syslog）的能力，但通常没有持久化层意味着可能存在数据丢失的风险，如果没有审计信息的话。'
- en: '**Data transformation layer**: It was also historically called **extract, transform,
    and load** (**ETL**). Today the data transformation layer can also be used to
    have real-time processing, where the aggregates are computed on the most recent
    data. The data transformation layer is also traditionally used to reformat and
    index the data to be efficiently accessed by a UI component of algorithms down
    the pipeline.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据转换层**: 它也被称为**提取、转换和加载**（**ETL**）。今天，数据转换层也可以用于实时处理，其中聚合是在最新数据上计算的。数据转换层也传统上用于重新格式化和索引数据，以便由管道下方的算法UI组件高效访问。'
- en: '**Data analytics and machine learning engine**: The reason this is not part
    of the standard data transformation layer is usually that this layer requires
    quite different skills. The mindset of people who build reasonable statistical
    models is usually different from people who make terabytes of data move fast,
    even though occasionally I can find people with both skills. Usually, these unicorns
    are called data scientists, but the skills in any specific field are usually inferior
    to ones who specialize in a particular field. We need more of either, though.
    Another reason is that machine learning, and to a certain extent, data analysis,
    requires multiple aggregations and passes over the same data, which as opposed
    to a more stream-like ETL transformations, requires a different engine.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分析与机器学习引擎**: 这不是标准数据转换层的一部分的原因通常是因为这个层需要相当不同的技能。构建合理统计模型的人的心态通常与那些使数以千计的数据快速移动的人不同，尽管偶尔我也能找到具备这两种技能的人。通常，这些“独角兽”被称为数据科学家，但任何特定领域的技能通常都不如那些专注于特定领域的人。尽管如此，我们仍然需要更多这样的人。另一个原因是机器学习，以及在某种程度上数据分析，需要多次对相同数据进行聚合和遍历，这与更流式的ETL转换不同，需要不同的引擎。'
- en: '**UI component**: Yes, UI stands for user interface, which most often is a
    set of components that allow you to communicate with the system via a browser
    (it used to be a native GUI, but these days the web-based JavaScript or Scala-based
    frameworks are much more powerful and portable). From the data pipeline and modeling
    perspective, this component offers an API to access internal representation of
    data and models.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI组件**: 是的，UI代表用户界面，它通常是一组组件，允许您通过浏览器与系统进行通信（过去通常是本地GUI，但如今基于Web的JavaScript或Scala框架要强大得多，且更易于移植）。从数据管道和建模的角度来看，这个组件提供了一个API来访问数据和模型的内部分布。'
- en: '**Actions engine**: This is usually a configurable rules engine to optimize
    the provided metrics based on insights. The actions may be either real-time, like
    in online advertising, in which case the engine should be able to supply real-time
    scoring information, or a recommendation for a user action, which can take the
    form of an e-mail alert.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作引擎**: 这通常是一个可配置的规则引擎，根据洞察力优化提供的指标。动作可以是实时的，例如在线广告，在这种情况下，引擎应该能够提供实时评分信息，或者为用户动作提供推荐，这可能以电子邮件警报的形式出现。'
- en: '**Correlation engine**: This is an emerging component that may analyze the
    output of data analysis and machine learning engine to infer additional insights
    into data or model behavior. The actions might also be triggered by an output
    from this layer.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联引擎**：这是一个新兴组件，它可以分析数据分析引擎和机器学习引擎的输出，以推断出关于数据或模型行为的额外见解。该层的输出也可能触发这些操作。'
- en: '**Monitoring**: This is a complex system will be incomplete without logging,
    monitoring, and some way to change system parameters. The purpose of monitoring
    is to have a nested decision-making system regarding the optimal health of the
    system and either to mitigate the problem(*s*) automatically or to alert the system
    administrators about the problem(*s*).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：这是一个复杂的系统，如果没有日志记录、监控以及某种方式来更改系统参数，它将是不完整的。监控的目的是拥有一个关于系统最佳健康状况的嵌套决策系统，要么自动减轻问题（*s*），要么向系统管理员发出关于问题（*s*）的警报。'
- en: Let's discuss each of the components in detail in the following sections.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将详细讨论每个组件。
- en: Data ingest
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据摄取
- en: With the proliferation of smart devices, information gathering has become less
    of a problem and more of a necessity for any business that does more than a type-written
    text. For the purpose of this chapter, I will assume that the device or devices
    are connected to the Internet or have some way of passing this information via
    home dialing or direct network connection.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着智能设备的普及，信息收集不再是问题，而是任何从事除打字文本之外业务的企业的一种必要性。为了本章的目的，我将假设设备或设备已连接到互联网或以某种方式通过家庭拨号或直接网络连接传递此信息。
- en: 'The major purpose of this component is to collect all relevant information
    that can be relevant for further data-driven decision making. The following table
    provides details on the most common implementations of the data ingest:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件的主要目的是收集所有可能对进一步的数据驱动决策有相关性的相关信息。以下表格提供了关于数据摄取最常见实现的详细信息：
- en: '| Framework | When used | Comments |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 使用时 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Syslog** | Syslog is one of the most common standards to pass messages
    between the machines on Unix. Syslog usually listens on port 514 and the transport
    protocol can be configured either with UDP (unreliable) or with TCP. The latest
    enhanced implementation on CentOS and Red Hat Linux is rsyslog, which includes
    many advanced options such as regex-based filtering that is useful for system-performance
    tuning and debugging. Apart from slightly inefficient raw message representation—plain
    text, which might be inefficient for long messages with repeated strings—the syslog
    system can support tens of thousands of messages per second. | Syslog is one of
    the oldest protocols developed in the 1980s by Eric Allman as part of Sendmail.
    While it does not guarantee delivery or durability, particularly for distributed
    systems, it is one of the most widespread protocols for message passing. Some
    of the later frameworks, such as Flume and Kafka, have syslog interfaces as well.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **Syslog** | Syslog是Unix机器之间传递消息的最常见标准之一。Syslog通常监听端口514，传输协议可以配置为UDP（不可靠）或TCP。在CentOS和Red
    Hat Linux上的最新增强实现是rsyslog，它包括许多高级选项，如基于正则表达式的过滤，这对于系统性能调整和调试非常有用。除了略微低效的原始消息表示——纯文本，这可能对重复字符串的长消息效率不高——syslog系统可以每秒支持数万条消息。
    | Syslog是1980年代由Eric Allman作为Sendmail的一部分开发的最早协议之一。虽然它不保证交付或持久性，尤其是对于分布式系统，但它是最广泛的消息传递协议之一。一些后来的框架，如Flume和Kafka，也有syslog接口。|'
- en: '| **Rsync** | Rsync is a younger framework developed in the 1990s. If the data
    is put in the flat files on a local filesystem, rsync might be an option. While
    rsync is more traditionally used to synchronize two directories, it also can be
    run periodically to transfer log data in batches. Rsync uses a recursive algorithm
    invented by an Australian computer programmer, Andrew Tridgell, for efficiently
    detecting the differences and transmitting a structure (such as a file) across
    a communication link when the receiving computer already has a similar, but not
    identical, version of the same structure. While it incurs extra communication,
    it is better from the point of durability, as the original copy can always be
    retrieved. It is particularly appropriate if the log data is known to arrive in
    batches in the first place (such as uploads or downloads). | Rsync has been known
    to be hampered by network bottlenecks, as it ultimately passes more information
    over the network when comparing the directory structures. However, the transferred
    files may be compressed when passed over the network. The network bandwidth can
    be limited per command-line flags. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **Rsync** | Rsync 是在 1990 年代开发的一个较年轻的框架。如果数据被放在本地文件系统上的平面文件中，rsync 可能是一个选择。虽然
    rsync 传统上用于同步两个目录，但它也可以定期运行以批量传输日志数据。Rsync 使用澳大利亚计算机程序员 Andrew Tridgell 发明的递归算法，以高效地检测差异并在接收计算机已经有一个类似但不完全相同的结构版本的情况下，通过通信链路传输结构（如文件）。虽然它会产生额外的通信，但从耐久性的角度来看，它更好，因为原始副本总是可以检索。如果已知日志数据最初是以批量形式到达的（例如上传或下载），则特别适用。|
    Rsync 已知会受到网络瓶颈的限制，因为它在比较目录结构时最终会在网络上传递更多信息。然而，传输的文件在通过网络传输时可能会被压缩。可以通过命令行标志限制网络带宽。|'
- en: '| **Flume** | Flume is one of the youngest frameworks developed by Cloudera
    in 2009-2011 and open sourced. Flume—we refer to the more popular flume-ng implementation
    as Flume as opposed to an older regular Flume—consists of sources, pipes, and
    sinks that may be configured on multiple nodes for high availability and redundancy
    purposes. Flume was designed to err on the reliability side at the expense of
    possible duplication of data. Flume passes the messages in the **Avro** format,
    which is also open sourced and the transfer protocol, as well as messages can
    be encoded and compressed. | While Flume originally was developed just to ship
    records from a file or a set of files, it can also be configured to listen to
    a port, or even grab the records from a database. Flume has multiple adapters
    including the preceding syslog. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **Flume** | Flume 是 Cloudera 在 2009-2011 年间开发的一个较年轻的框架，并且已经开源。Flume——我们指的是更流行的
    flume-ng 实现，称为 Flume，而不是较老的常规 Flume——由源、管道和可能在多个节点上配置以实现高可用性和冗余目的的汇组成。Flume 被设计为在可靠性的代价下可能重复数据的情况下出错。Flume
    以 **Avro** 格式传递消息，该格式也是开源的，传输协议，以及消息可以被编码和压缩。| 虽然Flume最初是为了从文件或一组文件中传输记录而开发的，但它也可以配置为监听端口，甚至从数据库中抓取记录。Flume
    有多个适配器，包括前面的 syslog。|'
- en: '| **Kafka** | Kafka is the latest addition to the log-processing framework
    developed by LinkedIn and is open sourced. Kafka, compared to the previous frameworks,
    is more like a distributed reliable message queue. Kafka keeps a partitioned,
    potentially between multiple distributed machines; buffer and one can subscribe
    to or unsubscribe from getting messages for a particular topic. Kafka was built
    with strong reliability guarantees in mind, which is achieved through replication
    and consensus protocol. | Kafka might not be appropriate for small systems (<
    five nodes) as the benefits of the fully distributed system might be evident only
    at larger scales. Kafka is commercially supported by Confluent. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **Kafka** | Kafka 是 LinkedIn 开发的日志处理框架的最新补充，并且已经开源。与之前的框架相比，Kafka 更像是一个分布式可靠的消息队列。Kafka
    维护一个分区，可能分布在多个分布式机器上；缓冲区，并且可以订阅或取消订阅特定主题的消息。Kafka 是在考虑了强大的可靠性保证的情况下构建的，这是通过复制和共识协议实现的。Kafka
    对于小型系统（小于五个节点）可能不太合适，因为完全分布式系统的优势可能只有在更大规模时才会明显。Kafka 由 Confluent 商业支持。|'
- en: The transfer of information usually occurs in batches, or micro batches if the
    requirements are close to real time. Usually the information first ends up in
    a file, traditionally called log, in a device's local filesystem, and then is
    transferred to a central location. Recently developed Kafka and Flume are often
    used to manage these transfers, together with a more traditional syslog, rsync,
    or netcat. Finally, the data can be placed into a local or distributed storage
    such as HDFS, Cassandra, or Amazon S3.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 信息传输通常以批量或微批量的形式发生，如果需求接近实时，则可能以微批量形式。通常，信息首先存储在设备本地文件系统中的一个文件中，传统上称为日志，然后传输到中央位置。最近开发的Kafka和Flume经常用于管理这些传输，同时还有更传统的syslog、rsync或netcat。最后，数据可以存储在本地或分布式存储中，如HDFS、Cassandra或Amazon
    S3。
- en: Data transformation layer
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据转换层
- en: 'After the data ends up in HDFS or other storage, the data needs to be made
    available for processing. Traditionally, the data is processed on a schedule and
    ends up partitioned by time-based buckets. The processing can happen daily or
    hourly, or even on a sub-minute basis with the new Scala streaming framework,
    depending on the latency requirements. The processing may involve some preliminary
    feature construction or vectorization, even though it is traditionally considered
    a machine-learning task. The following table summarizes some available frameworks:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 数据最终存储在HDFS或其他存储中后，需要使数据可用于处理。传统上，数据按计划处理，并最终按时间桶分区。处理可以按日、按小时，甚至在新Scala流框架的基础上按分钟以下进行，具体取决于延迟要求。处理可能涉及一些初步的特征构建或矢量化，尽管它传统上被认为是机器学习任务。以下表格总结了一些可用的框架：
- en: '| Framework | When used | Comments |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 当使用时 | 评论 |'
- en: '| --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Oozie** | This is one of the oldest open source frameworks developed by
    Yahoo. This has good integration with big data Hadoop tools. It has limited UI
    that lists the job history. | The whole workflow is put into one big XML file,
    which might be considered a disadvantage from the modularity point of view. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **Oozie** | 这是雅虎（Yahoo）开发的最古老的开放源框架之一。它与大数据Hadoop工具具有良好的集成。它具有有限的用户界面，列出了作业历史。
    | 整个工作流被放入一个大的XML文件中，这可能从模块化角度来看被认为是一个缺点。|'
- en: '| **Azkaban** | This is an alternative open source workflow-scheduling framework
    developed by LinkedIn. Compared to Oozie, this arguably has a better UI. The disadvantage
    is that all high-level tasks are executed locally, which might present a scalability
    problem. | The idea behind Azkaban is to create a fully modularized drop-in architecture
    where the new jobs/tasks can be added with as few modifications as possible. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **Azkaban** | 这是由领英（LinkedIn）开发的一个替代开源工作流调度框架。与Oozie相比，它可能具有更好的用户界面。缺点是所有高级任务都在本地执行，这可能会带来可扩展性问题。
    | Azkaban背后的理念是创建一个完全模块化的即插即用架构，其中新作业/任务可以尽可能少地修改后添加。|'
- en: '| **StreamSets** | StreamSets is the latest addition build by the former Informix
    and Cloudera developers. It has a very developed UI and supports a much richer
    set of input sources and output destinations. | This is a fully UI-driven tool
    with an emphasis on data curation, for example, constantly monitoring the data
    stream for problems and abnormalities. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **StreamSets** | StreamSets是由前Informix和Cloudera的开发者构建的最新产品。它具有非常发达的用户界面，并支持更丰富的输入源和输出目标。
    | 这是一个完全由用户界面驱动的工具，强调数据管理，例如，持续监控数据流中的问题和异常。|'
- en: Separate attention should be given to stream-processing frameworks, where the
    latency requirements are reduced to one or a few records at a time. First, stream
    processing usually requires much more resources dedicated to processing, as it
    is more expensive to process individual records at a time as opposed to batches
    of records, even if it is tens or hundreds of records. So, the architect needs
    to justify the additional costs based on the value of more recent result, which
    is not always warranted. Second, stream processing requires a few adjustments
    to the architecture as handling the more recent data becomes a priority; for example,
    a delta architecture where the more recent data is handled by a separate substream
    or a set of nodes became very popular recently with systems such as **Druid**
    ([http://druid.io](http://druid.io)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 应当特别关注流处理框架，其中延迟要求降低到每次一个或几个记录。首先，流处理通常需要更多的资源用于处理，因为与处理记录批次相比，逐个处理记录的成本更高，即使只有几十或几百条记录也是如此。因此，架构师需要根据更近期结果的价值来证明额外成本是合理的，而这并不总是有保证的。其次，流处理需要对架构进行一些调整，因为处理最新数据成为优先事项；例如，最近随着像**Druid**([http://druid.io](http://druid.io))这样的系统，一个delta架构，其中最新数据由一个单独的子流或一组节点处理，变得非常流行。
- en: Data analytics and machine learning
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据分析和机器学习
- en: For the purpose of this chapter, **Machine Learning** (**ML**) is any algorithm
    that can compute aggregates or summaries that are actionable. We will cover more
    complex algorithms from [Chapter 3](ch03.xhtml "Chapter 3. Working with Spark
    and MLlib"), *Working with Spark and MLlib* to [Chapter 6](ch06.xhtml "Chapter 6. Working
    with Unstructured Data"), *Working with Unstructured Data*, but in some cases,
    a simple sliding-window average and deviation from the average may be sufficient
    signal for taking an action. In the past few years, it just works in A/B testing
    somehow became a convincing argument for model building and deployment. I am not
    speculating that solid scientific principles might or might not apply, but many
    fundamental assumptions such as *i.i.d.*, balanced designs, and the thinness of
    the tail just fail to hold for many big data situation. Simpler models tend to
    be faster and to have better performance and stability.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，**机器学习**（**ML**）是指任何可以计算可操作聚合或摘要的算法。我们将从[第3章](ch03.xhtml "第3章。使用Spark和MLlib")*使用Spark和MLlib*到[第6章](ch06.xhtml
    "第6章。处理非结构化数据")*处理非结构化数据*涵盖更复杂的算法，但在某些情况下，一个简单的滑动窗口平均值和偏离平均值可能就足够作为采取行动的信号。在过去几年中，A/B测试中的“它起作用了”某种程度成为模型构建和部署的令人信服的论据。我并不是在猜测是否可能或不可能应用坚实的科学原理，但许多基本假设，如*i.i.d.*、平衡设计和尾部稀薄性，在许多大数据情况下都未能成立。简单的模型往往更快，性能和稳定性更好。
- en: For example, in online advertising, one might just track average performance
    of a set of ads over a certain similar properties over times to make a decision
    whether to have this ad displayed. The information about anomalies, or deviation
    from the previous behavior, may be a signal a new unknown unknown, which signals
    that the old data no longer applies, in which case, the system has no choice but
    to start the new exploration cycle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在在线广告中，人们可能会跟踪一组广告在一段时间内某些相似属性的平均性能，以决定是否显示该广告。关于异常或偏离先前行为的信息可能是一个信号，表明出现了新的未知未知，这表明旧数据不再适用，在这种情况下，系统别无选择，只能开始新的探索周期。
- en: I will talk about more complex non-structured, graph, and pattern mining later
    in [Chapter 6](ch06.xhtml "Chapter 6. Working with Unstructured Data"), *Working
    with Unstructured Data*, [Chapter 8](ch08.xhtml "Chapter 8. Integrating Scala
    with R and Python"), *Integrating Scala with R and Python* and [Chapter 9](ch09.xhtml
    "Chapter 9. NLP in Scala"), *NLP in Scala*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第6章](ch06.xhtml "第6章。处理非结构化数据")*处理非结构化数据*，[第8章](ch08.xhtml "第8章。Scala与R和Python的集成")*Scala与R和Python的集成*和[第9章](ch09.xhtml
    "第9章。Scala中的NLP")*Scala中的NLP*中稍后讨论更复杂的非结构化、图和模式挖掘。
- en: UI component
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI组件
- en: Well, UI is for wimps! Just joking...maybe it's too harsh, but in reality, UI
    usually presents a syntactic sugar that is necessary to convince the population
    beyond the data scientists. A good analyst should probably be able to figure out
    t-test probabilities by just looking at a table with numbers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，UI是给弱者的！只是开玩笑...也许有点严厉，但现实中，UI通常呈现一种必要的语法糖，以说服数据科学家之外的人群。一个好的分析师可能只需通过查看数字表格就能找出t检验的概率。
- en: However, one should probably apply the same methodologies we used at the beginning
    of the chapter, assessing the usefulness of different components and the amount
    of cycles put into them. The presence of a good UI is often justified, but depends
    on the target audience.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能应该应用我们在本章开头使用的方法，评估不同组件的有用性和投入的周期数量。良好的UI的存在往往是合理的，但取决于目标受众。
- en: 'First, there are a number of existing UIs and reporting frameworks. Unfortunately,
    most of them are not aligned with the functional programming methodologies. Also,
    the presence of complex/semi-structured data, which I will describe in [Chapter
    6](ch06.xhtml "Chapter 6. Working with Unstructured Data"), *Working with Unstructured
    Data* in more detail, presents a new twist that many frameworks are not ready
    to deal with without implementing some kind of DSL. Here are a few frameworks
    for building the UI in a Scala project that I find particularly worthwhile:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，存在许多现有的用户界面(UI)和报告框架。不幸的是，其中大部分与函数式编程方法不匹配。此外，复杂/半结构化数据的存在，我将在[第6章](ch06.xhtml
    "第6章。处理非结构化数据")“处理非结构化数据”中更详细地描述，为许多框架带来了新的挑战，它们在没有实现某种领域特定语言(DSL)的情况下可能无法应对。以下是我认为特别值得注意的几个用于在Scala项目中构建UI的框架：
- en: '| Framework | When used | Comments |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 使用场景 | 评论 |'
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Scala Swing** | If you used Swing components in Java and are proficient
    with them, Scala Swing is a good choice for you. Swing component is arguably the
    least portable component of Java, so your mileage can vary on different platforms.
    | The `Scala.swing` package uses the standard Java Swing library under the hood,
    but it has some nice additions. Most notably, as it''s made for Scala, it can
    be used in a much more concise way than the standard Swing. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **Scala Swing** | 如果你熟悉Java中的Swing组件，Scala Swing是一个不错的选择。Swing组件可以说是Java中最不便携的组件，因此在不同平台上的表现可能会有所不同。
    | `Scala.swing`包在底层使用标准的Java Swing库，但它有一些很好的补充。最值得注意的是，由于它是为Scala设计的，它可以比标准的Swing以更简洁的方式使用。|'
- en: '| **Lift** | Lift is a secure, developer-centric, scalable, and interactive
    framework written in Scala. Lift is open sourced under Apache 2.0 license. | The
    open source Lift framework was launched in 2007 by David Polak, who was dissatisfied
    with certain aspects of the Ruby on Rails framework. Any existing Java library
    and web container can be used in running Lift applications. Lift web applications
    are thus packaged as WAR files and deployed on any servlet 2.4 engine (for example,
    Tomcat 5.5.xx, Jetty 6.0, and so on). Lift programmers may use the standard Scala/Java
    development toolchain, including IDEs such as Eclipse, NetBeans, and IDEA. Dynamic
    web content is authored via templates using standard HTML5 or XHTML editors. Lift
    applications also benefit from native support for advanced web development techniques,
    such as Comet and Ajax. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **Lift** | Lift是一个安全、以开发者为中心、可扩展和交互式的框架，用Scala编写。Lift在Apache 2.0许可下开源。 |
    开源Lift框架于2007年由David Polak启动，他对Ruby on Rails框架的某些方面不满意。任何现有的Java库和Web容器都可以用于运行Lift应用程序。因此，Lift
    Web应用程序被打包成WAR文件，并部署在任何servlet 2.4引擎上（例如，Tomcat 5.5.xx、Jetty 6.0等）。Lift程序员可以使用标准的Scala/Java开发工具链，包括Eclipse、NetBeans和IDEA等IDE。动态Web内容通过模板使用标准的HTML5或XHTML编辑器编写。Lift应用程序还受益于对高级Web开发技术的本地支持，如Comet和Ajax。|'
- en: '| **Play** | Play is arguably better aligned with Scala as a functional language
    than any other platform—it is officially supported by Typesafe, the commercial
    company behind Scala. The Play framework 2.0 builds on Scala, Akka, and sbt to
    deliver superior asynchronous request handling, fast and reliable. Typesafe templates,
    and a powerful build system with flexible deployment options. Play is open sourced
    under Apache 2.0 license. | The open source Play framework was created in 2007
    by Guillaume Bort, who sought to bring a fresh web development experience inspired
    by modern web frameworks like Ruby on Rails to the long-suffering Java web development
    community. Play follows a familiar stateless model-view-controller architectural
    pattern, with a philosophy of convention-over-configuration and an emphasis on
    developer productivity. Unlike traditional Java web frameworks with their tedious
    compile-package-deploy-restart cycles, updates to Play applications are instantly
    visible with a simple browser refresh. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **Play** | Play框架可以说是与Scala作为函数式语言比其他任何平台都更匹配——它得到了Scala背后的商业公司Typesafe的官方支持。Play框架2.0建立在Scala、Akka和sbt的基础上，提供卓越的异步请求处理、快速和可靠的性能。Typesafe模板以及一个功能强大的构建系统，具有灵活的部署选项。Play在Apache
    2.0许可下开源。 | 开源Play框架是由Guillaume Bort于2007年创建的，他希望将受现代Web框架如Ruby on Rails启发的全新Web开发体验带给长期受苦的Java
    Web开发社区。Play遵循熟悉的无状态模型-视图-控制器（MVC）架构模式，强调约定优于配置和开发者生产力。与传统的Java Web框架相比，它们有繁琐的编译-打包-部署-重启周期，Play应用程序的更新只需简单的浏览器刷新即可立即可见。
    |'
- en: '| **Dropwizard** | The dropwizard ([www.dropwizard.io](http://www.dropwizard.io))
    project is an attempt to build a generic RESTful framework in both Java and Scala,
    even though one might end up using more Java than Scala. What is nice about this
    framework is that it is flexible enough to be used with arbitrary complex data
    (including semi-structured).This is licensed under Apache License 2.0. | RESTful
    API assumes state, while functional languages shy away from using state. Unless
    you are flexible enough to deviate from a pure functional approach, this framework
    is probably not good enough for you. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **Dropwizard** | dropwizard项目（[www.dropwizard.io](http://www.dropwizard.io)）试图在Java和Scala中构建一个通用的RESTful框架，尽管最终可能使用Java多于Scala。这个框架的优点是它足够灵活，可以用于任意复杂的数据（包括半结构化数据）。这是在Apache
    License 2.0许可下发布的。 | RESTful API假设状态，而函数式语言则避免使用状态。除非你足够灵活，可以偏离纯函数式方法，否则这个框架可能不适合你。
    |'
- en: '| **Slick** | While Slick is not a UI component, it is Typesafe''s modern database
    query and access library for Scala, which can serve as a UI backend. It allows
    you to work with the stored data almost as if you were using Scala collections,
    while at the same time, giving you full control over when a database access occurs
    and what data is transferred. You can also use SQL directly. Use it if all of
    your data is purely relational. This is open sourced under BSD-Style license.
    | Slick was started in 2012 by Stefan Zeiger and maintained mainly by Typesafe.
    It is useful for mostly relational data. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **Slick** | 虽然Slick不是一个UI组件，但它却是Typesafe为Scala提供的现代数据库查询和访问库，可以作为UI后端使用。它允许你几乎像使用Scala集合一样处理存储的数据，同时，让你完全控制数据库访问发生的时间和传输的数据。你还可以直接使用SQL。如果你的所有数据都是纯关系型数据，请使用它。这是在BSD风格许可下开源的。
    | Slick是由Stefan Zeiger于2012年开始的，主要由Typesafe维护。它主要用于关系型数据。 |'
- en: '| **NodeJS** | Node.js is a JavaScript runtime, built on Chrome''s V8 JavaScript
    engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight
    and efficient. Node.js'' package ecosystem, npm, is the largest ecosystem of open
    source libraries in the world. It is open sourced under MIT License. | Node.js
    was first introduced in 2009 by Ryan Dahl and other developers working at Joyent.
    Originally Node.js supported only Linux, but now it runs on OS X and Windows.
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **NodeJS** | Node.js是一个基于Chrome的V8 JavaScript引擎构建的JavaScript运行时。Node.js使用事件驱动、非阻塞I/O模型，使其轻量级且高效。Node.js的包生态系统npm是世界上最大的开源库生态系统。它在MIT许可下开源。
    | Node.js最初于2009年由Ryan Dahl和其他在Joyent工作的开发者引入。最初Node.js只支持Linux，但现在它可以在OS X和Windows上运行。
    |'
- en: '| **AngularJS** | AngularJS ([https://angularjs.org](https://angularjs.org))
    is a frontend development framework, built to simplify development of one-page
    web applications. This is open sourced under MIT License. | AngularJS was originally
    developed in 2009 by Misko Hevery at Brat Tech LLC. AngularJS is mainly maintained
    by Google and by a community of individual developers and corporations, and thus
    is specifically for Android platform (support for IE8 is dropped in versions 1.3
    and later). |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **AngularJS** | AngularJS ([https://angularjs.org](https://angularjs.org))
    是一个前端开发框架，旨在简化单页 Web 应用程序的开发。这是在 MIT 许可证下开源的。| AngularJS 最初于 2009 年由 Misko Hevery
    在 Brat Tech LLC 开发。AngularJS 主要由 Google 和一群个人开发者及企业维护，因此专门针对 Android 平台（从版本 1.3
    开始不再支持 IE8）。|'
- en: Actions engine
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行动引擎
- en: While this is the heart of the data-oriented system pipeline, it is also arguably
    the easiest one. Once the system of metrics and values is known, the system decides,
    based on the known equations, whether to take a certain set of actions or not,
    based on the information provided. While the triggers based on a threshold is
    the most common implementation, the significance of probabilistic approaches that
    present the user with a set of possibilities and associated probabilities is emerging—or
    just presenting the user with the top *N* relevant choices like a search engine
    does.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是数据导向系统管道的核心，但也许也是最简单的一个。一旦知道了指标和值系统，系统就会根据已知的方程，根据提供的信息决定是否采取某些行动。虽然基于阈值的触发器是最常见的实现方式，但呈现给用户一系列可能性和相关概率的概率方法的重要性正在显现——或者像搜索引擎一样，只向用户展示最相关的
    *N* 个选择。
- en: The management of the rules might become pretty involved. It used to be that
    managing the rules with a rule engine, such as **Drools** ([http://www.drools.org](http://www.drools.org)),
    was sufficient. However, managing complex rules becomes an issue that often requires
    development of a DSL (*Domain-Specific Languages* by Martin Fowler, Addison-Wesley,
    2010). Scala is particularly fitting language for the development of such an actions
    engine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 规则的管理可能会变得相当复杂。过去，使用规则引擎（如 **Drools** ([http://www.drools.org](http://www.drools.org)））管理规则是足够的。然而，管理复杂的规则成为一个经常需要开发领域特定语言（*Martin
    Fowler 的《领域特定语言*》，Addison-Wesley，2010）的问题。Scala 特别适合开发这样的行动引擎。
- en: Correlation engine
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关性引擎
- en: The more complex the decision-making system is, the more it requires a secondary
    decision-making system to optimize its management. DevOps is turning into DataOps
    (*Getting Data Right* by Michael Stonebraker et al., Tamr, 2015). Data collected
    about the performance of a data-driven system are used to detect anomalies and
    semi-automated maintenance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 决策系统越复杂，就越需要二级决策系统来优化其管理。DevOps 正在转变为 DataOps（由 Michael Stonebraker 等人撰写的《*Getting
    Data Right*》，Tamr，2015）。关于数据驱动系统性能收集的数据用于检测异常和半自动化维护。
- en: Models are often subject to time drift, where the performance might deteriorate
    either due to the changes in the data collection layers or the behavioral changes
    in the population (I will cover model drift in [Chapter 10](ch10.xhtml "Chapter 10. Advanced
    Model Monitoring"), *Advanced Model Monitoring*). Another aspect of model management
    is to track model performance, and in some cases, use "collective" intelligence
    of the models by various consensus schemes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模型通常会受到时间漂移的影响，性能可能会因为数据收集层的变化或人群行为的变化而下降（我将在第 10 章[高级模型监控](ch10.xhtml "第 10
    章。高级模型监控")中介绍模型漂移，*高级模型监控*）。模型管理的另一个方面是跟踪模型性能，在某些情况下，通过各种共识方案使用“集体”智能。
- en: Monitoring
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控
- en: Monitoring a system involves collecting information about system performance
    either for audit, diagnostic, or performance-tuning purposes. While it is related
    to the issues raised in the previous sections, monitoring solution often incorporates
    diagnostic and historical storage solutions and persistence of critical data,
    such as a black box on an airplane. In the Java and, thus, Scala world, a popular
    tool of choice is Java performance beans, which can be monitored in the Java Console.
    While Java natively supports MBean for exposing JVM information over JMX, **Kamon**
    ([http://kamon.io](http://kamon.io)) is an open source library that uses this
    mechanism to specifically expose Scala and Akka metrics.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 监控一个系统涉及收集有关系统性能的信息，无论是为了审计、诊断还是性能调整。虽然它与前面章节中提出的问题有关，但监控解决方案通常包含诊断和存储解决方案以及关键数据的持久化，例如飞机上的黑匣子。在
    Java 和 Scala 世界中，一个流行的选择工具是 Java 性能豆，它可以在 Java 控制台中进行监控。虽然 Java 本地支持 MBean 以通过
    JMX 揭示 JVM 信息，但 **Kamon** ([http://kamon.io](http://kamon.io)) 是一个开源库，它使用这种机制专门暴露
    Scala 和 Akka 的度量。
- en: Some other popular monitoring open source solutions are **Ganglia** ([http://ganglia.sourceforge.net/](http://ganglia.sourceforge.net/))
    and **Graphite** ([http://graphite.wikidot.com](http://graphite.wikidot.com)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他流行的监控开源解决方案是 **Ganglia** ([http://ganglia.sourceforge.net/](http://ganglia.sourceforge.net/))
    和 **Graphite** ([http://graphite.wikidot.com](http://graphite.wikidot.com))。
- en: I will stop here, as I will address system and model monitoring in more detail
    in [Chapter 10](ch10.xhtml "Chapter 10. Advanced Model Monitoring"), *Advanced
    Model Monitoring*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里就停止了，因为我将在第 10 章 [高级模型监控](ch10.xhtml "第 10 章。高级模型监控")中更详细地讨论系统和模型监控。
- en: Optimization and interactivity
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化和交互性
- en: 'While the data collected can be just used for understanding the business, the
    final goal of any data-driven business is to optimize the business behavior by
    automatically making data-based and model-based decisions. We want to reduce human
    intervention to minimum. The following simplified diagram can be depicted as a
    cycle:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然收集到的数据可以仅用于理解业务，但任何数据驱动型企业的最终目标是通过自动做出基于数据和模型的决定来优化业务行为。我们希望将人为干预降到最低。以下简化图可以描述为一个循环：
- en: '![Optimization and interactivity](img/B04935_02_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![优化和交互性](img/B04935_02_05.jpg)'
- en: Figure 02-4\. The predictive model life cycle
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 02-4\. 预测模型生命周期
- en: The cycle is repeated over and over for new information coming into the system.
    The parameters of the system may be tuned to improve the overall system performance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当新信息进入系统时，这个循环会反复进行。系统参数可能被调整以改善整体系统性能。
- en: Feedback loops
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反馈循环
- en: While humans are still likely to be kept in the loop for most of the systems,
    last few years saw an emergence of systems that can manage the complete feedback
    loop on their own—ranging from advertisement systems to self-driving cars.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管人类可能仍然会在大多数系统中保持参与，但最近几年出现了一些能够独立管理完整反馈循环的系统——从广告系统到自动驾驶汽车。
- en: The classical formulation of this problem is the optimal control theory, which
    is also an optimization problem to minimize cost functional, given a set of differential
    equations describing the system. An optimal control is a set of control policies
    to minimize the cost functional given constraints. For example, the problem might
    be to find a way to drive the car to minimize its fuel consumption, given that
    it must complete a given course in a time not exceeding some amount. Another control
    problem is to maximize profit for showing ads on a website, provided the inventory
    and time constraints. Most software packages for optimal control are written in
    other languages such as C or MATLAB (PROPT, SNOPT, RIOTS, DIDO, DIRECT, and GPOPS),
    but can be interfaced with Scala.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的经典公式是最优控制理论，它也是一个优化问题，旨在最小化成本泛函，给定一组描述系统的微分方程。最优控制是一组控制策略，用于在给定约束条件下最小化成本泛函。例如，问题可能是找到一种方法来驾驶汽车以最小化其燃油消耗，前提是它必须在不超过某个时间限制内完成给定的课程。另一个控制问题是在满足库存和时间约束的情况下，最大化网站上的广告利润。大多数最优控制软件包是用其他语言（如
    C 或 MATLAB）编写的（PROPT、SNOPT、RIOTS、DIDO、DIRECT 和 GPOPS），但可以与 Scala 接口。
- en: However, in many cases, the parameters for the optimization or the state transition,
    or differential equations, are not known with certainty. **Markov Decision Processes**
    (**MDPs**) provide a mathematical framework to model decision making in situations
    where outcomes are partly random and partly under the control of the decision
    maker. In MDPs, we deal with a discrete set of possible states and a set of actions.
    The "rewards" and state transitions depend both on the state and actions. MDPs
    are useful for studying a wide range of optimization problems solved via dynamic
    programming and reinforcement learning.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，优化或状态转换的参数，或者微分方程，并不确定。**马尔可夫决策过程**（**MDPs**）提供了一个数学框架来模拟在结果部分随机且部分受决策者控制的情况下的决策。在MDPs中，我们处理一组可能的状态和一组动作。"奖励"和状态转换既取决于状态也取决于动作。MDPs对于研究通过动态规划和强化学习解决的广泛优化问题是有用的。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I described a high-level architecture and approach to design
    a data-driven enterprise. I also introduced you to influence diagrams, a tool
    for understanding how the decisions are made in traditional and data-driven enterprises.
    I stopped on a few key models, such as Kelly Criterion and multi-armed bandit,
    essential to demonstrate the issues from the mathematical point of view. I built
    on top of this to introduce some Markov decision process approaches where we deal
    with decision policies based on the results of the previous decisions and observations.
    I delved into more practical aspects of building a data pipeline for decision-making,
    describing major components and frameworks that can be used to built them. I also
    discussed the issues of communicating the data and modeling results between different
    stages and nodes, presenting the results to the user, feedback loop, and monitoring.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了一个设计数据驱动企业的整体架构和途径。我还向您介绍了影响图，这是一种理解传统和数据驱动企业中决策如何做出的工具。我简要介绍了几个关键模型，如凯利准则和多臂老虎机，这些模型对于从数学角度展示问题至关重要。在此基础上，我介绍了几种马尔可夫决策过程方法，其中我们处理基于先前决策和观察结果的决策策略。我深入探讨了构建决策数据管道的更多实际方面，描述了可以用来构建它们的主要组件和框架。我还讨论了在不同阶段和节点之间传达数据和建模结果的问题，包括向用户展示结果、反馈循环和监控。
- en: In the next chapter, I will describe MLlib, a library for machine learning over
    distributed set of nodes written in Scala.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将描述MLlib，这是一个用Scala编写的在分布式节点集上执行机器学习的库。
