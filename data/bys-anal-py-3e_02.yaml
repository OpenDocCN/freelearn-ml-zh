- en: Chapter 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: Hierarchical Models
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分层模型
- en: Hierarchical models are one honking great idea – let’s do more of those! - The
    zen of Bayesian modeling
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分层模型是一个非常棒的想法——让我们做更多这样的模型吧！- 贝叶斯建模的禅意
- en: In *Chapter [2](CH02.xhtml#x1-440002)*, we saw a tips example where we had multiple
    groups in our data, one for each of Thursday, Friday, Saturday, and Sunday. We
    decided to model each group separately. That’s sometimes fine, but we should be
    aware of our assumptions. By modeling each group independently, we are assuming
    the groups are unrelated. In other words, we are assuming that knowing the tip
    for one day does not give us any information about the tip for another day. That
    could be too strong an assumption. Would it be possible to build a model that
    allows us to share information between groups? That’s not only possible, but is
    also the main topic of this chapter. Lucky you!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第[2章](CH02.xhtml#x1-440002)*中，我们看到了一个小费的例子，其中数据中有多个组，每个组对应星期四、星期五、星期六和星期日。我们决定分别建模每个组。这样做有时是可以的，但我们应当注意我们的假设。通过独立建模每个组，我们假设这些组是互不相关的。换句话说，我们假设知道一天的小费信息并不能给我们提供其他一天的小费信息。这可能是一个过于强的假设。那么，是否有可能构建一个模型，允许我们在组之间共享信息呢？这不仅可能，而且正是本章的主要内容。幸运的是，你来了！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Hierarchical models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层模型
- en: Partial pooling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分合并
- en: Shrinkage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收缩
- en: 3.1 Sharing information, sharing priors
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 信息共享，共享先验
- en: Hierarchical models are also known as multilevel models, mixed-effects models,
    random-effects models, or nested models. They are particularly useful when dealing
    with data that can be described as grouped or having different levels, such as
    data nested within geographic regions (for example, cities belonging to a province
    and provinces belonging to a country), or with a hierarchical structure (such
    as students nested within schools, or patients nested within hospitals) or repeated
    measurements on the same individuals.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 分层模型也被称为多级模型、混合效应模型、随机效应模型或嵌套模型。当数据可以被描述为分组或具有不同层级时，分层模型尤其有用，比如数据嵌套在地理区域中（例如，属于一个省的城市和属于一个国家的省），或者具有分层结构（如学生嵌套在学校内，或者病人嵌套在医院中），或者是对同一个体的重复测量。
- en: '![PIC](img/file87.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file87.png)'
- en: '**Figure 3.1**: The differences between a pooled model, an unpooled model,
    and a hierarchical model'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.1**：合并模型、非合并模型和分层模型之间的差异'
- en: Hierarchical models are a natural way to share information between groups. In
    a hierarchical model, the parameters of the prior distributions are themselves
    given a prior distribution. These higher-level priors are often called hyperpriors;
    ”hyper” means ”over” in Greek. Having hyperpriors allows the model to share information
    between groups, while still allowing differences between groups. In other words,
    we can think of the parameters of the prior distributions as belonging to a common
    population of parameters. *Figure [3.1](#x1-68003r1)* shows a diagram with the
    high-level differences between a pooled model (a single group), an unpooled model
    (all separated groups), and a hierarchical model, also known as a partially pooled
    model.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 分层模型是一个自然的方式，用于在不同组之间共享信息。在分层模型中，先验分布的参数本身也会赋予一个先验分布。这些更高层次的先验通常被称为超先验；“超”在希腊语中意味着“在……之上”。拥有超先验使得模型可以在组之间共享信息，同时仍允许组之间存在差异。换句话说，我们可以认为先验分布的参数属于一个共同的参数群体。*图
    [3.1](#x1-68003r1)* 显示了一个图示，展示了合并模型（单一组）、非合并模型（所有分开的组）和分层模型（也称为部分合并模型）之间的高层次差异。
- en: The concept of a hierarchical model may seem confusingly simple, almost trivial,
    but it has subtle implications. That is why in the rest of this chapter we will
    use different examples to understand their implications. I am sure that these
    examples will not only help you better understand this concept but will also convince
    you that it is a very useful tool to apply to your own problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 分层模型的概念看起来可能过于简单，几乎是微不足道的，但它有着深远的影响。因此，在本章的其余部分，我们将通过不同的例子来理解它们的含义。我相信这些例子不仅能帮助你更好地理解这一概念，还能说服你，它是一个非常有用的工具，能够应用于你自己的问题。
- en: 3.2 Hierarchical shifts
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 分层转变
- en: Proteins are molecules formed by 20 units called amino acids. Each amino acid
    can appear in a protein 0 or more times. Just as a melody is defined by a sequence
    of musical notes, a protein is defined by a sequence of amino acids. Some musical
    note variations can result in small variations of the melody and other variations
    in completely different melodies. Something similar happens with proteins. One
    way to study proteins is by using nuclear magnetic resonance (the same technique
    used for medical imaging). This technique allows us to measure various quantities,
    one of which is called a chemical shift. You may remember that we saw an example
    using chemical shifts in *Chapter [2](CH02.xhtml#x1-440002)*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋白质是由20种叫做氨基酸的单位组成的分子。每种氨基酸可以在蛋白质中出现0次或更多次。就像旋律是由一系列音符定义的，蛋白质则是由一系列氨基酸定义的。一些音符的变化可能导致旋律的微小变化，而其他音符的变化则可能导致完全不同的旋律。蛋白质中也有类似的情况。研究蛋白质的一种方法是使用核磁共振（与医学成像使用的技术相同）。这项技术使我们能够测量多种量，其中之一叫做化学位移。你可能还记得我们在*第[2](CH02.xhtml#x1-440002)*章中看过一个使用化学位移的例子。
- en: 'Suppose we want to compare a theoretical method of computing chemical shift
    against the experimental observations to evaluate the ability of the theoretical
    method to reproduce the experimental values. Luckily for us, someone has already
    run the experiments and carried out the theoretical calculations, and we just
    need to compare them. The following dataset contains chemical shift values for
    a set of proteins. If you inspect the `cs_data` DataFrame, you will see that it
    has four columns:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将一种理论的化学位移计算方法与实验观察结果进行比较，以评估该理论方法是否能再现实验值。幸运的是，有人已经做了实验并进行了理论计算，我们只需要将它们进行比较。以下数据集包含了一组蛋白质的化学位移值。如果你查看`cs_data`数据框，你会发现它有四列：
- en: The first is a code that identifies the protein (you can get a lot of information
    about that protein by entering that code at [https://www.rcsb.org/](https://www.rcsb.org/))
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一列是一个代码，用来识别蛋白质（你可以通过在[https://www.rcsb.org/](https://www.rcsb.org/)输入该代码来获取有关该蛋白质的许多信息）
- en: The second column has the name of the amino acid (you might notice that there
    are only 19 unique names; one of the amino acids is missing from this dataset)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二列是氨基酸的名称（你可能会注意到这里只有19个独特的名称；该数据集中缺少一种氨基酸）
- en: The third contains theoretical values of chemical shift (calculated using quantum
    methods)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三列包含了化学位移的理论值（使用量子方法计算得出）
- en: The fourth has experimental values
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四列包含了实验值
- en: Now that we have the data, how should we proceed? One option is to take the
    empirical differences and fit a Gaussian or maybe Student’s t model. Because amino
    acids are a family of chemical compounds, it would make sense to assume they are
    all the same and estimate a single Gaussian for all the differences. But you may
    argue that there are 20 different kinds of amino acids, each one with different
    chemical properties, and hence a better choice is to fit 20 separated Gaussians.
    What should we do?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，接下来应该怎么做？一个选项是采用经验差异并拟合一个高斯分布，或者也许是学生t分布。因为氨基酸是一类化学化合物，假设它们都是相同的，并为所有差异估算一个单一的高斯分布是有道理的。但你可能会认为，有20种不同类型的氨基酸，每种都有不同的化学性质，因此一个更好的选择是拟合20个独立的高斯分布。我们应该怎么做？
- en: Let’s take a moment to think about which option is the best. If we combine all
    the data, our estimates are going to be more accurate, but we will not be able
    to get information from individual groups (amino acids). On the contrary, if we
    treat them as separate groups, we will get a much more detailed analysis but with
    less accuracy. What should we do?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间思考一下，哪个选项是最好的。如果我们将所有数据合并，估算结果会更准确，但我们无法从单个组（氨基酸）中获取信息。相反，如果我们将它们作为独立的组处理，我们将获得更详细的分析，但准确性较差。我们应该怎么做？
- en: When in doubt, everything! (Not sure this is good general advice for your life,
    but I like the song [https://www.youtube.com/watch?v=1di09XZUlIw](https://www.youtube.com/watch?v=1di09XZUlIw)).
    We can build a hierarchical model; that way, we allow estimates at the group level
    but with the restriction that they all belong to a larger group or population.
    To better understand this, let’s build a hierarchical model for the chemical shift
    data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，什么都行！(不确定这是否是你生活中好的普遍建议，但我喜欢这首歌 [https://www.youtube.com/watch?v=1di09XZUlIw](https://www.youtube.com/watch?v=1di09XZUlIw))。我们可以建立一个层级模型；通过这种方式，我们允许在组级别进行估算，但有一个限制，即它们都属于一个更大的组或人群。为了更好地理解这一点，我们来为化学位移数据建立一个层级模型。
- en: 'To see the difference between a non-hierarchical (unpooled) model and a hierarchical
    one, we are going to build two models. The first one is essentially the same as
    the `comparing_groups` model from *Chapter [2](CH02.xhtml#x1-440002)*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看非层次模型（非汇聚模型）和层次模型之间的区别，我们将构建两个模型。第一个模型本质上与*第 [2](CH02.xhtml#x1-440002)*
    章中的`comparing_groups`模型相同：
- en: '**Code 3.1**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 3.1**'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will build the hierarchical version of the model. We are adding two
    hyperpriors, one for the mean of *μ* and one for the standard deviation of *μ*.
    We are leaving *σ* without hyperpriors; in other words, we are assuming that the
    variance between observed and theoretical values should be the same for all groups.
    This is a modeling choice, and you may face a problem where this seems unacceptable
    and consider it necessary to add a hyperprior for *σ*; feel free to do that:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建模型的层次版本。我们添加了两个超先验，一个用于*μ*的均值，另一个用于*μ*的标准差。我们将*σ*留空，不添加超先验；换句话说，我们假设观察值与理论值之间的方差对于所有组都是相同的。这是一个建模选择，你可能会遇到一个问题，觉得这种假设不可接受，并认为有必要为*σ*添加一个超先验；你可以自由这样做：
- en: '**Code 3.2**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 3.2**'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Figure [3.2](#x1-69030r2)* shows the graphical representation of the `cs_h`
    and `cs_nh` models. We can see that we have one more level for `cs_h` representing
    the hyperpriors for *μ*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [3.2](#x1-69030r2)* 显示了`cs_h`和`cs_nh`模型的图形表示。我们可以看到，`cs_h`多了一个层级，用于表示*μ*的超先验。'
- en: '![PIC](img/file88.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file88.png)'
- en: '**Figure 3.2**: Graph representation of the non-hierarchical (left) and hierarchical
    (right) models for the chemical shift data. Each subfigure was generated with
    the `pm.model_to_graphviz(.)` function'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.2**：化学位移数据的非层次（左）和层次（右）模型的图形表示。每个子图都是通过`pm.model_to_graphviz(.)`函数生成的'
- en: We are going to compare the results using ArviZ’s `plot_forest` function. We
    can pass more than one model to this function. This is useful when we want to
    compare the values of parameters from different models such as with the present
    example. In *Figure [3.3](#x1-69031r3)*, we have a plot for the 40 estimated means,
    one per amino acid (20) for each of the two models. We also have their 94% HDI
    and the inter-quantile range (the central 50% of the distribution). The vertical
    dashed line is the global mean according to the hierarchical model. This value
    is close to zero, as expected for theoretical values faithfully reproducing experimental
    ones.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用ArviZ的`plot_forest`函数来比较结果。我们可以将多个模型传递给此函数。当我们希望比较不同模型中参数的值时，这非常有用，比如当前示例中所展示的。在*图
    [3.3](#x1-69031r3)*中，我们有一个包含40个估计均值的图，每个氨基酸（共20个）对应两个模型中的一个。我们还展示了它们的94% HDI和四分位距（分布的中央50%）。垂直虚线表示根据层次模型得到的全局均值。该值接近零，正如预期的那样，理论值与实验值相符。
- en: '![PIC](img/file89.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file89.png)'
- en: '**Figure 3.3**: Chemical shift differences for the hierarchical and non-hierarchical
    models'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.3**：层次和非层次模型的化学位移差异'
- en: The most relevant part of this plot is that the estimates from the hierarchical
    model are pulled toward the partially pooled mean, or equivalently they are shrunken
    in comparison to the unpooled estimates. You will also notice that the effect
    is more notorious for those groups farther away from the mean (such as `PRO`)
    and that the uncertainty is on par with or smaller than that from the non-hierarchical
    model. The estimates are partially pooled because we have one estimate for each
    group, but estimates for individual groups restrict each other through the hyperprior.
    Therefore, we get an intermediate situation between having a single group with
    all chemical shifts together and having 20 separate groups, one per amino acid.
    And that, ladies, gentlemen, and non-binary-gender-fluid people, is the beauty
    of hierarchical models.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该图的最相关部分是层次模型的估计值被拉向部分汇聚的均值，或者说它们相比于非汇聚的估计值被“收缩”。你还会注意到，这种效应在那些离均值较远的组（如`PRO`）中更加明显，而且不确定性与非层次模型的相当，甚至更小。估计值是部分汇聚的，因为我们为每个组都有一个估计，但各个组的估计值通过超先验相互约束。因此，我们得到了一种介于将所有化学位移放在一个组中和将每个氨基酸分为20个独立组之间的中间情况。各位女士、先生以及非二元性别流动者，这就是层次模型的美妙之处。
- en: 3.3 Water quality
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 水质
- en: 'Suppose we want to analyze the quality of water in a city, so we take samples
    by dividing the city into neighborhoods. We may think we have two options for
    analyzing this data:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想分析一个城市的水质，那么我们通过将城市划分为多个社区来进行采样。我们可能认为有两种选择来分析这些数据：
- en: Study each neighborhood as a separate entity
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个社区作为一个独立实体进行研究
- en: Pool all the data together and estimate the water quality of the city as a single
    big group
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有数据汇总在一起，并将城市的水质估算为一个大的整体。
- en: 'You have probably already noticed the pattern here. We can justify the first
    option by saying we obtain a more detailed view of the problem, which otherwise
    could become invisible or less evident if we average the data. The second option
    can be justified by saying that if we pool the data, we obtain a bigger sample
    size and hence a more accurate estimation. But we already know we have a third
    option: we can do a hierarchical model!'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这里的模式。我们可以通过说我们获得了问题的更详细视图来证明第一个选项的合理性，否则如果我们对数据进行平均处理，问题可能会变得不可见或不那么明显。第二个选项的合理性可以通过说如果我们将数据汇总，我们就能获得更大的样本量，从而得到更准确的估计来证明。但是我们已经知道我们有第三个选项：我们可以做一个层次模型！
- en: 'For this example, we are going to use synthetic data. I love using synthetic
    data; it is a great way to understand things. If you don’t understand something,
    simulate it! There are many uses for synthetic data. Here, we are going to imagine
    we have collected water samples from three different regions of the same city
    and measured the lead content of water; samples with concentrations of lead above
    recommendations from the World Health Organization are marked with zero and samples
    with values below the recommendations are marked with one. This is a very simple
    scenario. In a more realistic example, we would have a continuous measurement
    of lead concentration and probably many more groups. Nevertheless, for our current
    purposes, this example is good enough to uncover the details of hierarchical models.
    We can generate the synthetic data with the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用合成数据。我喜欢使用合成数据；它是理解事物的一个好方法。如果你不理解某个东西，就模拟它！合成数据有很多用途。在这里，我们将假设我们已经从同一城市的三个不同区域收集了水样，并测量了水中的铅含量；铅含量超过世界卫生组织建议值的样本标记为零，低于建议值的样本标记为一。这是一个非常简单的场景。在更现实的例子中，我们会有铅浓度的连续测量，并且可能会有更多的组。然而，针对我们当前的目的，这个例子足够揭示层次模型的细节。我们可以用以下代码生成合成数据：
- en: '**Code 3.3**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 3.3**'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are simulating an experiment where we have measured three groups, each one
    consisting of a certain number of samples; we store the total number of samples
    per group in the `N_samples` list. Using the `G_samples` list, we keep a record
    of the number of good-quality samples per group. The rest of the code is there
    just to generate a list of the data, filled with zeros and ones.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在模拟一个实验，我们测量了三个组，每个组包含一定数量的样本；我们将每组的样本总数存储在`N_samples`列表中。使用`G_samples`列表，我们记录每组中良好水质样本的数量。其余的代码仅用于生成一个包含零和一的数据列表。
- en: 'The model for this problem is similar to the one we used for the coin problem,
    except for two important features:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的模型与我们用于硬币问题的模型类似，除了两个重要特征：
- en: We have defined two hyperpriors that will influence the Beta prior.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了两个超先验，这些将影响Beta先验。
- en: 'Instead of setting hyperpriors on the parameters *α* and *β*, we are defining
    the Beta distribution in terms of *μ*, the mean, and *ν*, the concentration (or
    precision) of the Beta distribution. The precision is analog to the inverse of
    the standard deviation; the larger the value of *ν*, the more concentrated the
    Beta distribution will be. In statistical notation, our model is as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是对参数*α*和*β*设置超先验，而是通过*μ*（均值）和*ν*（Beta分布的浓度或精度）来定义Beta分布。精度类似于标准差的倒数；*ν*的值越大，Beta分布就越集中。在统计符号中，我们的模型如下所示：
- en: '![ μ ∼ Beta(𝛼μ,𝛽μ) ν ∼ ℋ𝒩 (σν) θi ∼ Beta(μ,ν) y ∼ Bernoulli(θ) i i ](img/file90.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![ μ ∼ Beta(𝛼μ,𝛽μ) ν ∼ ℋ𝒩 (σν) θi ∼ Beta(μ,ν) y ∼ Bernoulli(θ) i i ](img/file90.jpg)'
- en: Notice that we are using the subscript *i* to indicate that the model has groups
    with different values for some of the parameters. Using Kruschke diagrams (see
    *Figure [3.4](#x1-70010r4)*), we can recognize that the new model has one additional
    level compared to the one from *Figure [1.14](CH01.xhtml#x1-39001r14)*. Notice
    also that for this model, we are parametrizing the Beta prior distribution in
    terms of *μ* and *ν* instead of *α* and *β*. This is a common practice in Bayesian
    statistics, and it is done because *μ* and *ν* are more intuitive parameters than
    *α* and *β*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用下标*i*来表示模型中某些参数在不同组之间的取值。通过Kruschke图（见*图 [3.4](#x1-70010r4)*），我们可以看到新模型相比于*图
    [1.14](CH01.xhtml#x1-39001r14)*，多了一个额外的层级。还要注意，在这个模型中，我们是用*μ*和*ν*来参数化Beta先验分布，而不是使用*α*和*β*。这是贝叶斯统计中的常见做法，因为*μ*和*ν*比*α*和*β*更直观。
- en: '![PIC](img/file91.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file91.png)'
- en: '**Figure 3.4**: Hierarchical model'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.4**：层次模型'
- en: 'Let’s write the model in PyMC:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在PyMC中编写这个模型：
- en: '**Code 3.4**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 3.4**'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 3.4 Shrinkage
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 收缩效应
- en: 'To show you one of the main consequences of hierarchical models, I will require
    your assistance, so please join me in a brief experiment. I will need you to print
    and save the summary computed with `az.summary(idata_h)`. Then, I want you to
    rerun the model two more times after making small changes to the synthetic data.
    Remember to save the summary after each run. In total, we will have three runs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示层次模型的主要后果，我需要你的帮助，请参与一个简短的实验。我需要你打印并保存通过`az.summary(idata_h)`计算出的摘要。然后，我希望你在对合成数据做些小调整后，再运行模型两次。记得每次运行后保存摘要。总的来说，我们会进行三次运行：
- en: One run setting all the elements of `G_samples` to 18
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一轮设置`G_samples`的所有元素为18
- en: One run setting all the elements of `G_samples` to 3
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一轮设置`G_samples`的所有元素为3
- en: One last run setting one element to 18 and the other two to 3
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一轮设置一个元素为18，另外两个为3
- en: Before continuing, please take a moment to think about the outcome of this experiment.
    Focus on the estimated mean value of *θ* in each experiment. Based on the first
    two runs of the model, could you predict the outcome for the third case?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请花点时间思考一下这个实验的结果。重点关注每个实验中*θ*的估计均值。根据前两次运行的模型，你能预测第三种情况的结果吗？
- en: 'If we put the result in a table, we get something more or less like this; remember
    that small variations could occur due to the stochastic nature of the sampling
    process:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把结果放在表格中，会得到大致如下的内容；记住，由于采样过程的随机性，可能会有小的变化：
- en: '| G_samples | Mean |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| G_samples | Mean |'
- en: '| 18, 18, 18 | 0.6, 0.6, 0.6 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 18, 18, 18 | 0.6, 0.6, 0.6 |'
- en: '| 3, 3, 3 | 0.11, 0.11, 0.11 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 3, 3, 3 | 0.11, 0.11, 0.11 |'
- en: '| 18, 3, 3 | 0.55, 0.13, 0.13 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 18, 3, 3 | 0.55, 0.13, 0.13 |'
- en: '**Table 3.1**: Sample data and corresponding means'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 3.1**：样本数据和对应的均值'
- en: In the first row, we can see that for a dataset of 18 good samples out of 30,
    we get a mean value for *θ* of 0.6; remember that now the mean of *θ* is a vector
    of 3 elements, 1 per group. Then, on the second row, we have only 3 good samples
    out of 30 and the mean of *θ* is 0.11\. These results should not be surprising;
    our estimates are practically the same as the empirical means. The interesting
    part comes in the third row. Instead of getting a mix of the mean estimates of
    *θ* from the other two rows, such as 0.6, 0.11, and 0.11, we get different values,
    namely 0.55, 0.13, and 0.13.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们看到对于一个由30个样本中挑选出的18个好样本组成的数据集，我们得到的*θ*均值是0.6；请记住，现在*θ*的均值是一个包含3个元素的向量，每个组对应一个元素。然后，在第二行中，只有30个样本中的3个是好样本，*θ*的均值为0.11。这些结果并不令人惊讶；我们的估计值与经验均值几乎相同。有趣的部分出现在第三行。我们没有得到来自前两行的*θ*均值的混合结果，如0.6、0.11和0.11，而是得到了不同的值，即0.55、0.13和0.13。
- en: What on Earth happened? Did we make a mistake somewhere? Nothing like that.
    What we are seeing is that the estimates have shrunk toward the common mean. This
    is totally OK; indeed this is just a consequence of our model. By using hyperpriors,
    we are estimating the parameters of the Beta prior distribution from the data.
    Each group is informing the rest, and each group is informed by the estimation
    of the others.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到底发生了什么？我们是不是哪里出错了？并不是那样。我们看到的现象是估计值已经向共同均值收缩了。这是完全正常的；实际上，这只是我们模型的一个结果。通过使用超先验，我们是从数据中估计Beta先验分布的参数。每个组都在向其他组提供信息，同时每个组也通过其他组的估计结果来获得信息。
- en: '*Figure [3.5](#x1-71004r5)* shows the posterior estimates of *μ* and *ν* plugged
    into a Beta distribution. In other words, this is the posterior distribution of
    the inferred Beta prior distribution.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [3.5](#x1-71004r5)* 显示了将*μ*和*ν*的后验估计值代入Beta分布。换句话说，这是推断Beta先验分布的后验分布。'
- en: '![PIC](img/file92.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file92.png)'
- en: '**Figure 3.5**: Posterior distribution of the inferred Beta prior distribution'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.5**: 推断Beta先验分布的后验分布'
- en: Why is shrinkage desirable? Because it contributes to more stable inferences.
    This is, in many ways, similar to what we saw with the Student’s t-distribution
    and the outliers; using a heavy-tailed distribution results in a more robust model
    to data points away from the mean. Introducing hyperpriors results in a more conservative
    model, one that is less responsive to extreme values in individual groups. Imagine
    that the sample sizes are different from each neighborhood, some small, some large;
    the smaller the sample size, the easier it is to get bogus results. At an extreme,
    if you take only one sample in a given neighborhood, you may just hit the only
    really old lead pipe in the whole neighborhood or, on the contrary, the only one
    made out of PVC. In one case, you will overestimate the bad quality and in the
    other underestimate it. Under a hierarchical model, the misestimation of one group
    will be ameliorated by the information provided by the other groups. A larger
    sample size will also do the trick but, more often than not, that is not an option.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么收缩是可取的？因为它有助于更稳定的推断。从多个方面来看，这类似于我们在学生t分布和异常值中看到的情况；使用重尾分布能够使模型对偏离均值的数据点更具鲁棒性。引入超先验会导致模型更为保守，使其对单个组中极端值的反应更为迟缓。想象一下，不同邻里之间的样本量不同，有的较小，有的较大；样本量越小，出现虚假结果的可能性越大。在极端情况下，如果你在某个邻里只取一个样本，可能会碰到整个邻里唯一的老旧铅管，或者相反，唯一的PVC管。在一种情况下，你会高估差的质量，而在另一种情况下，你会低估它。在层级模型下，一个组的错误估计会通过其他组提供的信息得到缓解。更大的样本量也能起到类似的效果，但往往这种方法不可行。
- en: The amount of shrinkage depends on the data; a group with more data will pull
    the estimate of the other groups harder than a group with fewer data points. If
    several groups are similar and one group is different, the similar groups are
    going to inform the others of their similarity and reinforce a common estimation,
    while pulling the estimation for the less similar group toward them; this is exactly
    what we saw in the previous example. The hyperpriors also have a role in modulating
    the amount of shrinkage. We can effectively use an informative prior distribution
    to shrink our estimate to some reasonable value if we have trustworthy information
    about the group-level distribution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 收缩的程度取决于数据；数据量更多的组会比数据量较少的组更强烈地拉动其他组的估计值。如果几个组相似，而某一个组不同，那么相似的组会将它们的相似性传递给其他组，并强化共同的估计，同时将不同组的估计值向它们拉拢；这正是我们在之前的例子中看到的情况。超先验在调节收缩量方面也起着作用。如果我们对组级分布有可信的信息，我们可以有效地使用信息性先验分布将估计值收缩到一个合理的值。
- en: Shrinkage
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 收缩
- en: In a hierarchical model, groups sharing a common hyperprior are effectively
    sharing information through the hyperprior. This results in shrinkage, that is,
    individual estimates are shrunk toward the common mean. By partially pooling the
    data, we are modeling the groups as some middle ground between the groups being
    independent of each other and being a single big group.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在层级模型中，共享相同超先验的组实际上通过超先验共享信息。这导致了收缩现象，也就是，单独的估计值会向共同的均值收缩。通过部分汇总数据，我们将组视为一种在独立组和单一大组之间的中间状态。
- en: Nothing prevents us from building a hierarchical model with just two groups,
    but we would prefer to have several groups. Intuitively, the reason is that getting
    shrinkage is like assuming each group is a data point, and we are estimating the
    standard deviation at the group level. Generally, we do not trust an estimation
    with too few data points unless we have a strong prior informing our estimation.
    Something similar is true for a hierarchical model.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能阻止我们只使用两个组来构建层级模型，但我们更倾向于使用多个组。直观来看，原因是收缩的过程就像假设每个组都是一个数据点，我们在组层面上估计标准差。一般而言，除非我们有强有力的先验信息来指导我们的估计，否则我们不太信任数据点过少的估计。层级模型也是如此。
- en: 3.5 Hierarchies all the way up
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 层级模型逐层构建
- en: 'Various data structures lend themselves to hierarchical descriptions that can
    encompass multiple levels. For example, consider professional football (soccer)
    players. As in many other sports, players have different positions. We may be
    interested in estimating some skill metrics for each player, for the positions,
    and for the overall group of professional football players. This kind of hierarchical
    structure can be found in many other domains as well:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 各种数据结构有助于层次化描述，可以涵盖多个层级。例如，考虑职业足球（足球）运动员。与许多其他运动一样，运动员有不同的职位。我们可能有兴趣估算每个运动员、每个职位以及所有职业足球运动员的技能指标。这种层次化结构在许多其他领域也能找到：
- en: 'Medical research: Suppose we are interested in estimating the effectiveness
    of different drugs for treating a particular disease. We can categorize patients
    based on their demographic information, disease severity, and other relevant factors
    and build a hierarchical model to estimate the probability of cure or treatment
    success for each subgroup. We can then use the parameters of the subgroup distribution
    to estimate the overall probability of cure or treatment success for the entire
    patient population.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 医学研究：假设我们有兴趣估计不同药物治疗某种疾病的效果。我们可以根据患者的个人信息、疾病严重程度和其他相关因素对患者进行分类，并构建一个层次模型来估算每个子组的治愈或治疗成功的概率。然后，我们可以使用子组分布的参数来估算整个患者群体的治愈或治疗成功的总体概率。
- en: 'Environmental science: Suppose we are interested in estimating the impact of
    a certain pollutant on a particular ecosystem. We can categorize different habitats
    within the ecosystem (e.g., rivers, lakes, forests, wetlands) and build a hierarchical
    model to estimate the distribution of pollutant levels within each habitat. We
    can then use the parameters of the habitat distribution to estimate the overall
    distribution of pollutant levels within the ecosystem.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境科学：假设我们有兴趣估计某种污染物对特定生态系统的影响。我们可以对生态系统内的不同栖息地（例如河流、湖泊、森林、湿地）进行分类，并构建一个层次模型来估算每个栖息地内的污染物水平分布。然后，我们可以使用栖息地分布的参数来估算整个生态系统中污染物水平的总体分布。
- en: 'Market research: Suppose we are interested in understanding the purchasing
    behavior of consumers for a particular product across different regions. We can
    categorize consumers based on their demographic information (e.g., age, gender,
    income, education) and build a hierarchical model to estimate the distribution
    of purchasing behavior for each subgroup. We can then use the parameters of the
    subgroup distribution to estimate the distribution of purchasing behavior for
    the overall group of consumers.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 市场研究：假设我们有兴趣了解不同地区消费者购买某一产品的行为。我们可以根据消费者的个人信息（例如年龄、性别、收入、教育）对其进行分类，并构建一个层次模型来估算每个子组的购买行为分布。然后，我们可以使用子组分布的参数来估算整个消费者群体的购买行为分布。
- en: Going back to our football players, we have collected data from the *Premier
    League*, *Ligue 1*, *Bundesliga*, *Serie A*, and *La Liga* over the course of
    four years (2017 to 2020). Let’s suppose we are interested in the goals-per-shot
    metric. This is what statisticians usually call a *success rate*, and we can estimate
    it with a Binomial model where the parameter *n* is the number of shots and the
    observations *y* is the number of goals. This leaves us with an unknown value
    for *p*. In previous examples, we have been calling this parameter *θ* and we
    have used a Beta distribution to model it. We will do the same now, but hierarchically.
    See *Figure [3.6](#x1-72002r6)* for a graphical representation of the entire model.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的足球运动员数据，我们收集了来自*英超联赛*、*法甲联赛*、*德甲联赛*、*意甲联赛*和*西甲联赛*的数据，数据覆盖了四年（2017至2020年）。假设我们有兴趣了解每次射门的进球数。这通常是统计学家所说的*成功率*，我们可以通过二项模型来估算，模型中参数*n*是射门次数，观察值*y*是进球数。这样就剩下了一个未知的参数*p*。在之前的例子中，我们将此参数称为*θ*，并使用Beta分布对其建模。我们现在也会这样做，但采用层次化的方法。请参见*图[3.6](#x1-72002r6)*，它提供了整个模型的图形表示。
- en: '![PIC](img/file93.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file93.png)'
- en: '**Figure 3.6**: Hierarchical model for the football players example. Notice
    that we have one more level than in previous hierarchical models'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.6**：足球运动员示例的层次模型。注意，与之前的层次模型相比，我们增加了一个层级。'
- en: In our model, *θ* represents the success rate for each player, and thus it is
    a vector of size `n_players`. We use a Beta distribution to model *θ*. The hyperparameters
    of the Beta distribution will be the vectors *μ*[*p*] and *ν*[*p*], which are
    vectors of size 4, representing the four positions in our dataset (defender `DF`,
    midfielder `MF`, forward `FW`, and goalkeeper `GK`). We will need to properly
    index the vectors *μ*[*p*] and *ν*[*p*] to match the total number of players.
    Finally, we will have two global parameters, *μ* and *ν*, representing the professional
    football players.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模型中，*θ*表示每个球员的成功率，因此它是一个大小为`n_players`的向量。我们使用Beta分布来建模*θ*。Beta分布的超参数将是*μ*[*p*]和*ν*[*p*]向量，这些向量的大小为4，代表我们数据集中四个位置（后卫`DF`、中场`MF`、前锋`FW`和门将`GK`）。我们需要正确地索引向量*μ*[*p*]和*ν*[*p*]，以匹配球员的总数。最后，我们将有两个全局参数，*μ*和*ν*，表示职业足球运动员。
- en: 'The PyMC model is defined in the following block of code. `pm.Beta(’`*μ*`’,
    1.7, 5.8)` was chosen with the help of PreliZ as a prior with 95% of the mass
    between 0 and 0.5\. This is an example of a weakly informative prior, as there
    is little doubt that a success rate of 0.5 is a high value. Sports statistics
    are well-studied, and there is a lot of prior information that could be used to
    define stronger priors. For this example, we will settle on this prior. A similar
    justification can be done for the prior `pm.Gamma(’![](img/nu.PNG)’, mu=125, sigma=50)`,
    which we define as the maximum entropy Gamma prior with 90% of the mass between
    50 and 200:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PyMC模型在下面的代码块中定义。`pm.Beta(’`*μ*`’, 1.7, 5.8)`是在PreliZ的帮助下选择的先验，95%的质量分布在0到0.5之间。这是一个弱信息先验的示例，因为几乎没有疑问，0.5的成功率是一个较高的值。体育统计数据研究得非常透彻，存在大量可用于定义更强先验的信息。对于这个示例，我们将使用这个先验。类似的理由也适用于先验`pm.Gamma(’![](img/nu.PNG)’,
    mu=125, sigma=50)`，我们定义其为最大熵Gamma先验，90%的质量分布在50到200之间：
- en: '**Code 3.5**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 3.5**'
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the top panel of *Figure [3.7](#x1-72024r7)*, we have the posterior distribution
    for the global parameter *μ*. The posterior distribution is close to 0.1\. This
    means that overall for a professional football player (from a top league), the
    probability of scoring a goal is on average 10%. This is a reasonable value, as
    scoring goals is not an easy task and we are not discriminating positions, i.e,
    we are considering players whose main role is not scoring goals. In the middle
    panel, we have the estimated *μ*[*p*] value for the forward position; as expected,
    it is higher than the global parameter *μ*. In the bottom panel, we have the estimated
    *θ* value for Lionel Messi, with a value of 0.17, which is higher than the global
    parameter *μ* and the forward position *μ*[*p*] value. This is also expected,
    as Lionel Messi is the best football player in the world, and his main role is
    scoring goals.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 [3.7](#x1-72024r7)*的顶部面板中，我们展示了全局参数*μ*的后验分布。后验分布接近于0.1。这意味着，对于一名职业足球运动员（来自顶级联赛），进球的概率平均为10%。这是一个合理的值，因为进球并非易事，并且我们没有区分位置，即我们考虑的是那些主要角色不是进球的球员。在中间面板中，我们展示了前锋位置的估计*μ*[*p*]值；如预期的那样，它高于全局参数*μ*。在底部面板中，我们展示了梅西的估计*θ*值，值为0.17，高于全局参数*μ*和前锋位置*μ*[*p*]值。这也是可以预期的，因为梅西是世界上最优秀的足球运动员，他的主要角色是进球。
- en: '![PIC](img/file94.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file94.png)'
- en: '**Figure 3.7**: Posterior distribution for the mean global parameter (top),
    mean forward position (middle), and the *θ* parameter for Messi (bottom)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.7**：全局参数的后验分布（顶部）、前向位置的均值（中部）以及梅西的*θ*参数（底部）'
- en: '*Figure [3.8](#x1-72025r8)* shows a forest plot for the posterior distribution
    for the parameter *μ*[*p*]. The posterior distribution for the forward position
    is centered around 0.13, as we have already seen, and is the highest of the four.
    This makes sense as the role of the players at a forward position is scoring goals
    as well as assisting them. The lowest value of *μ*[*p*] is for the goalkeeper
    position. This is expected, as the main role is to stop the opposing team from
    scoring, and not to score goals. The interesting aspect is that the uncertainty
    is very high; this is because we have very few goalkeepers scoring goals in our
    dataset, three to be precise. The posterior distributions for the defender and
    midfielder positions are somewhat in the middle, being slightly higher for the
    midfielder. We can explain this as the main role of a midfielder is to defend
    and attack, and thus the probability of scoring a goal is higher than a defender
    but lower than a forward.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [3.8](#x1-72025r8)* 展示了参数 *μ*[*p*] 的后验分布的森林图。正如我们已经看到的，前锋位置的后验分布集中在 0.13
    附近，并且是四个位置中最高的。这是有道理的，因为前锋的角色是进球以及助攻。*μ*[*p*] 的最低值出现在守门员位置。这是预期的，因为守门员的主要角色是阻止对方进球，而不是进球。值得注意的是，不确定性非常高；这是因为我们数据集中进球的守门员数量非常少，准确来说只有三名。后卫和中场的位置的后验分布大致处于中间，且中场略高于后卫。我们可以解释为，中场的主要角色是既要防守也要进攻，因此进球的概率比后卫高，但低于前锋。'
- en: '![PIC](img/file95.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file95.png)'
- en: '**Figure 3.8**: Posterior distribution for the parameter *μ*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.8**：参数 *μ* 的后验分布'
- en: '*p, the mean position*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*p，均值位置*'
- en: You Need to Know When to Stop
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道何时停止
- en: It is possible to create hierarchical models with as many levels as we want.
    But unless the problem necessitates additional structure, adding more levels than
    required does not enhance the quality of our model or inferences. Instead, we
    will get entangled in a web of hyperpriors and hyperparameters without the ability
    to assign any meaningful interpretation to them. The goal of building models is
    to make sense of data, and thus useful models are usually those that reflect and
    take advantage of the structure of the data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要创建具有任意层级的层级模型。但除非问题需要额外的结构，否则添加超过必要层级的层次不会提升模型或推断的质量。相反，我们会陷入超先验和超参数的迷网中，而无法为它们赋予任何有意义的解释。构建模型的目标是理解数据，因此，实用的模型通常是那些能够反映并利用数据结构的模型。
- en: 3.6 Summary
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 小结
- en: 'In this chapter, we have presented one of the most important concepts to learn
    from this book: hierarchical models. We can build hierarchical models every time
    we can identify subgroups in our data. In such cases, instead of treating the
    subgroups as separate entities or ignoring the subgroups and treating them as
    a single group, we can build a model to partially pool information among groups.
    The main effect of this partial pooling is that the estimates of each subgroup
    will be biased by the estimates of the rest of the subgroups. This effect is known
    as shrinkage and, in general, is a very useful trick that helps to improve inferences
    by making them more conservative (as each subgroup informs the others by pulling
    estimates toward it) and more informative. We get estimates at the subgroup level
    and the group level.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了本书中最重要的概念之一：层级模型。每当我们能在数据中识别出子群时，就可以构建层级模型。在这种情况下，我们不是将子群当作独立的实体，或忽略子群将它们视为单一群体，而是构建一个模型，在群体之间部分合并信息。部分合并的主要效果是，每个子群的估计会受到其他子群估计的影响。这种效应被称为收缩效应，一般来说，这是一个非常有用的技巧，通过让推断更加保守（因为每个子群通过将估计拉向自己来影响其他子群）和更具信息量，来帮助改进推断。我们在子群层面和群体层面都能获得估计。
- en: Paraphrasing the Zen of Python, we can certainly say *hierarchical models are
    one* *honking great idea, let’s do more of those!* In the following chapters,
    we will keep building hierarchical models and learn how to use them to build better
    models. We will also discuss how hierarchical models are related to the pervasive
    overfitting/underfitting issue in statistics and machine learning in *Chapter
    [5](CH05.xhtml#x1-950005)*. In *Chapter [10](CH10.xhtml#x1-18900010)*, we will
    discuss some technical problems that we may find when sampling from hierarchical
    models and how to diagnose and fix those problems.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 借用 Python 禅意的表达方式，我们可以肯定地说，*层次模型是一个* *非常棒的主意，让我们做更多这样的事情！* 在接下来的章节中，我们将继续构建层次模型，并学习如何使用它们来构建更好的模型。我们还将讨论层次模型与统计学和机器学习中普遍存在的过拟合/欠拟合问题的关系，内容将在*第[5](CH05.xhtml#x1-950005)章*中进行探讨。在*第[10](CH10.xhtml#x1-18900010)章*中，我们将讨论在从层次模型中采样时可能遇到的一些技术问题，并探讨如何诊断和解决这些问题。
- en: 3.7 Exercises
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 练习
- en: 'Using your own words explain the following concepts in two or three sentences:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你自己的话解释以下概念，用两到三句话：
- en: Complete pooling
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全汇总
- en: No pooling
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无汇总
- en: Partial pooling
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分汇总
- en: Repeat the exercise we did with `model_h`. This time, without a hierarchical
    structure, use a flat prior such as Beta(*α* = 1*,*β** = 1). Compare the results
    of both models.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复我们在`model_h`中进行的练习。这一次，不使用层次结构，使用一个简单的先验，比如 Beta(*α* = 1*,*β* = 1)。比较两种模型的结果。
- en: Create a hierarchical version of the tips example from *Chapter [2](CH02.xhtml#x1-440002)*,
    by partially pooling across the days of the week. Compare the results to those
    obtained without the hierarchical structure.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个层次化版本的 *第[2](CH02.xhtml#x1-440002)章* 中的 tips 示例，通过在一周的天数之间进行部分汇总。将结果与没有层次结构时获得的结果进行比较。
- en: For each subpanel in *Figure [3.7](#x1-72024r7)*, add a reference line representing
    the empirical mean value at each level, that is, the global mean, the forward
    mean, and Messi’s mean. Compare the empirical values to the posterior mean values.
    What do you observe?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对*图[3.7](#x1-72024r7)*中的每个子面板，添加一条表示每个层级的经验均值的参考线，即全局均值、前向均值和梅西的均值。比较经验值和后验均值。你观察到什么？
- en: Amino acids are usually grouped into categories such as `polar`, `non-polar`,
    `charged`, and `special`. Build a hierarchical model similar to `cs_h` but including
    a group effect for the amino acid category. Compare the results to those obtained
    in this chapter.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 氨基酸通常被分为`极性`、`非极性`、`带电`和`特殊`等类别。构建一个类似于`cs_h`的层次模型，但包括一个氨基酸类别的组效应。将结果与本章中获得的结果进行比较。
- en: Join our community Discord space
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 5000 members at: [https://packt.link/bayesian](https://packt.link/bayesian)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区，与志同道合的人交流，并和超过 5000 名成员一起学习，链接地址：[https://packt.link/bayesian](https://packt.link/bayesian)
- en: '![PIC](img/file1.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
