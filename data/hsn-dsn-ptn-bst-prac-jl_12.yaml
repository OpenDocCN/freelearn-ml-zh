- en: Miscellaneous Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他模式
- en: 'This chapter will cover a few miscellaneous design patterns that are quite
    useful in building larger applications. These patterns provide additional tools
    that we can leverage apart of the major patterns that we have seen so far from
    previous chapters. In a nutshell, we will explore three patterns, as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些在构建大型应用程序中非常有用的其他设计模式。这些模式提供了额外的工具，我们可以利用这些工具来补充之前章节中看到的重大模式。简而言之，我们将探索以下三个模式：
- en: The singleton type dispatch pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例类型分派模式
- en: The stubbing/mocking pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟/存根模式
- en: The functional pipes pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数管道模式
- en: The singleton type dispatch pattern leverages Julia's multiple dispatch feature,
    which allows you to add new functionalities without having to modify existing
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类型分派模式利用了Julia的多重分派特性，这使得你可以在不修改现有代码的情况下添加新功能。
- en: The stubbing/mocking pattern can be utilized to test software components in
    isolation. It's also possible to test external dependencies without actually using
    them. It makes automated testing a lot easier.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟/存根模式可以用来单独测试软件组件。也有可能在不实际使用它们的情况下测试外部依赖。这使得自动化测试变得容易得多。
- en: The functional pipes pattern makes use of the pipe operator to represent a linear
    flow of execution. It is a way of programming that is adopted in many data processing
    pipelines. Some people find this concept of linear execution more intuitive. We
    will explore some examples about they may well with this pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数管道模式利用管道操作符来表示执行流程的线性流。这是一种在许多数据处理管道中采用的编程方式。有些人认为这种线性执行的概念更直观。我们将探讨一些关于它们如何使用此模式的好例子。
- en: '*Let''s get started!*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们开始吧！*'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code for this chapter is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码位于[https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter09)。
- en: The code in this chapter has been tested in a Julia 1.3.0 environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码已在Julia 1.3.0环境中进行了测试。
- en: Singleton type dispatch pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例类型分派模式
- en: Julia supports dynamic dispatch, which is a specific feature of its multiple
    dispatch system. Dynamic dispatch allows the program to dispatch to the proper
    function based on the type of the function arguments at runtime. If you are familiar
    with polymorphism in terms of object-oriented programming languages, then this
    concept is similar. In this section, we will explain what singleton types are
    and how they can be used to implement dynamic dispatch.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Julia支持动态分派，这是其多重分派系统的一个特定特性。动态分派允许程序在运行时根据函数参数的类型分派到适当的函数。如果你熟悉面向对象编程语言中的多态，那么这个概念是相似的。在本节中，我们将解释什么是单例类型以及它们如何用于实现动态分派。
- en: 'To begin, let''s consider a desktop application use case where the system responds
    to user click events. Here is what the **graphical user interface** (**GUI**)
    may look like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一个桌面应用程序用例，其中系统响应用户点击事件。以下是**图形用户界面**（**GUI**）可能的样子：
- en: '![](img/976936e4-7904-447f-ab73-2015b753ec97.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/976936e4-7904-447f-ab73-2015b753ec97.png)'
- en: We will try to implement the processing function with simple logic first and
    then see how it can be improved using the singleton type dispatch pattern.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先尝试用简单的逻辑实现处理函数，然后看看如何使用单例类型分派模式来改进它。
- en: Developing a command processor
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发命令处理器
- en: 'Our first attempt to implement a command process that may look similar to the
    following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次尝试实现一个可能看起来类似的命令处理过程：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `process_command` function simply takes the command as a string. Then, depending
    on the value of the string, it will call the respective function. The `args` argument
    may be passed by the GUI code for additional information; for example, the path
    of the file that is being opened or closed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_command`函数简单地接受命令作为字符串。然后，根据字符串的值，它将调用相应的函数。`args`参数可能由GUI代码传递以提供更多信息；例如，正在打开或关闭的文件路径。'
- en: 'There is nothing wrong with this code from a logical perspective, but it can
    be improved, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑角度来看，这段代码没有问题，但可以按照以下方式改进：
- en: The code contains a list of if-then-else statements. In this example, we only
    have to support four functions. In practice, we will probably have to handle many
    more functions. Having such a large if-then-else block makes the code very ugly
    and hard to maintain.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码包含一系列if-then-else语句。在这个例子中，我们只需要支持四个函数。在实践中，我们可能需要处理更多的函数。拥有这样一个大的if-then-else块会使代码非常丑陋且难以维护。
- en: Whenever we need to add a new command, we have to modify this function to include
    a new condition.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们需要添加一个新命令时，我们必须修改这个函数以包含一个新条件。
- en: Fortunately, we can make it better using singleton types and dynamic dispatch.
    We'll go over that next.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过使用单例类型和动态分派来使其变得更好。我们将在下一节中介绍这一点。
- en: Understanding singleton types
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单例类型
- en: 'A singleton type is just a data type that is designed to have a single instance.
    In Julia, it can be implemented easily by defining a type without any field:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类型只是一个设计为具有单个实例的数据类型。在Julia中，可以通过定义一个没有任何字段的类型来轻松实现：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create a single instance of such a data type, we can use the following default
    constructor:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此类数据类型的一个单例实例，我们可以使用以下默认构造函数：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unlike in some object-oriented programming languages, this constructor returns
    exactly the same instance, even if you call it multiple times. In other words,
    it is already a singleton. We can prove this like so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些面向对象编程语言不同，这个构造函数在多次调用时返回的实例完全相同。换句话说，它已经是一个单例。我们可以这样证明：
- en: '![](img/95b2889b-a5f9-4df4-9277-c1b672422565.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95b2889b-a5f9-4df4-9277-c1b672422565.png)'
- en: After creating two instances of `OpenCommand`, we compare them using the `===`
    operator, which tells us that these two instances are indeed referring to the
    same object. Hence, we have achieved the creation of a singleton.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了两个`OpenCommand`实例之后，我们使用`===`运算符比较它们，这告诉我们这两个实例确实指向同一个对象。因此，我们已经实现了单例的创建。
- en: Moving on, we can take the same approach and create a singleton types for each
    command, that is, `CloseCommand`, `ExitCommand`, `HelpCommand`, and so on. Furthermore,
    we can also create a new abstract type called `AbstractCommand`, which can serve
    as the supertype for all these command types.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以采取相同的方法，为每个命令创建一个单例类型，即`CloseCommand`、`ExitCommand`、`HelpCommand`等。此外，我们还可以创建一个新的抽象类型`AbstractCommand`，它可以作为所有这些命令类型的超类型。
- en: It seems exhaustively verbose that we have to create a new type for each command.
    A better way to handle this situation is to use parametric types. Since it's a
    fairly common use case, Julia predefines a type called `Val`. Let's take a look
    at it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都创建一个新类型似乎非常冗长。处理这种情况的更好方法是使用参数化类型。由于这是一个相当常见的用例，Julia预定义了一个名为`Val`的类型。让我们看看它。
- en: Using the Val parametric data type
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Val参数化数据类型
- en: '`Val` is a parametric data type that is defined in the Julia Base package.
    Its purpose is to provide us with an easy way to dispatch using singleton types.
    The `Val` type is defined as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Val`是一个在Julia Base包中定义的参数化数据类型。它的目的是为我们提供一个使用单例类型进行分派的简单方法。`Val`类型定义如下：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How do we create a singleton object? We can use the `Val` constructor and pass
    it any value. For example, we can create a singleton type that embeds a value
    of 1, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建一个单例对象？我们可以使用`Val`构造函数并传递任何值。例如，我们可以创建一个包含值为1的单例类型，如下所示：
- en: '![](img/d03674fd-7f84-4a68-bef0-c3bdc0a4dde2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d03674fd-7f84-4a68-bef0-c3bdc0a4dde2.png)'
- en: 'Let''s confirm the data type of such an object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认这样一个对象的数据类型：
- en: '![](img/617825ba-704a-48c4-924b-19f835d9721d.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/617825ba-704a-48c4-924b-19f835d9721d.png)'
- en: 'Here, we can see that `Val(1)` and `Val(2)` have their own types – `Val{1}`
    and `Val{2}`, respectively. Interestingly, the value being passed to the constructor
    ends up in the type signature. Again, we can prove that these are indeed singletons
    by calling the `Val` constructor twice and comparing their identities:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`Val(1)`和`Val(2)`有自己的类型——分别是`Val{1}`和`Val{2}`。有趣的是，传递给构造函数的值最终出现在类型签名中。同样，我们可以通过调用两次`Val`构造函数并比较它们的身份来证明这些确实是单例：
- en: '![](img/66e95cb6-912d-47c4-805a-8373b30d7256.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66e95cb6-912d-47c4-805a-8373b30d7256.png)'
- en: 'As you can see, the `Val` constructor function can also accept a symbol as
    an argument. Note that `Val` can only accept data that is a bit type because it
    goes to the type signature. Most use cases involve the `Val` type with integers
    and symbols in the type parameter. If we try to create new `Val` objects with
    non-bits type, then we get an error, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Val`构造函数也可以接受一个符号作为参数。请注意，`Val`只能接受位类型的数据，因为它会传递到类型签名。大多数用例涉及在类型参数中使用整数和符号的`Val`类型。如果我们尝试使用非位类型创建新的`Val`对象，那么我们会得到一个错误，如下所示：
- en: '![](img/8efc1c0a-2188-4587-b5da-627cd0d6cc4c.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8efc1c0a-2188-4587-b5da-627cd0d6cc4c.png)'
- en: You may be wondering why we go through so much to talk about singleton types.
    This is because singleton types can be used for dynamic dispatch. Now that we
    know how to create singletons, let's learn how to utilize them for dispatch.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们要花费这么多时间去讨论单例类型。这是因为单例类型可以用于动态调度。现在我们已经知道了如何创建单例，让我们学习如何利用它们进行调度。
- en: Using singleton types with dynamic dispatch
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单例类型和动态调度
- en: In Julia, function calls are dispatched according to the type of the arguments
    when the function is called. For a quick introduction to this mechanism, please
    refer to [Chapter 3](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml), *Designing Functions
    and Interfaces.*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，当函数被调用时，函数调用是根据参数的类型来调度的。为了快速介绍这个机制，请参阅[第3章](6c453014-3590-4a63-9d39-9bdd735185d5.xhtml)，*设计函数和接口*。
- en: Let's recall the use case that we presented earlier in this chapter about a
    command processor function. With a naive implementation, we have a large if-then-else
    block that dispatch to different functions according to the command string. Let's
    try to implement the same feature using singleton types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章前面提到的关于命令处理器函数的使用案例。使用原始实现，我们有一个大的if-then-else块，根据命令字符串调度到不同的函数。让我们尝试使用单例类型实现相同的功能。
- en: 'For each command, we can define a function that takes a singleton type. For
    example, the signatures of the functions for the `Open` and `Close` events are
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个命令，我们可以定义一个接受单例类型的函数。例如，`Open`和`Close`事件的函数签名如下：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We didn''t have to specify any name for the first argument because we don''t
    need to use it. However, we do specify the type of the first argument to be `Val{:open}` or
    `Val{:close}`. Given such a function signature, we can handle the `Open` event
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为第一个参数指定任何名称，因为我们不需要使用它。然而，我们指定第一个参数的类型为`Val{:open}`或`Val{:close}`。给定这样的函数签名，我们可以处理`Open`事件，如下所示：
- en: '![](img/c5b252b1-cce3-4177-b36e-c070da2415ad.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5b252b1-cce3-4177-b36e-c070da2415ad.png)'
- en: 'Basically, we create a singleton and pass it to the function. Because the type
    signature matches, Julia will dispatch to the function we just defined in the
    preceding screenshot. Now, assuming that we have defined all other functions,
    we can write the code for the main dispatcher as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们创建一个单例并将其传递给函数。因为类型签名匹配，Julia将会调度到我们在上一张截图中所定义的函数。现在，假设我们已经定义了所有其他函数，我们可以编写主调度器的代码如下：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we simply convert the command into a symbol and then create a singleton
    type object by passing it to the `Val` constructor. At runtime, the proper `process_command`
    functions will be dispatched accordingly. Let''s quickly test that out:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将命令转换为符号，然后通过传递给`Val`构造函数来创建单例类型对象。在运行时，相应的`process_command`函数将被调度。让我们快速测试一下：
- en: '![](img/84106eb5-0204-449a-838d-5ff6158c230b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84106eb5-0204-449a-838d-5ff6158c230b.png)'
- en: '*Fabulous!* Now, let''s pause for a moment and think about what we have just
    achieved. In particular, we can make two observations:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*太棒了!* 现在，让我们暂停一下，思考一下我们刚刚取得的成就。特别是，我们可以做出以下两个观察：'
- en: The main dispatcher function in the preceding screenshot no longer has an if-then-else
    block. It just utilizes dynamic dispatch to figure out which underlying function
    to call.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一张截图中的主调度器函数不再有if-then-else块。它只是利用动态调度来确定调用哪个底层函数。
- en: Whenever we need to add a new command, we can just define a new `process_command`
    function with a new `Val` singleton. There is no change to the main dispatcher
    function anymore.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们需要添加一个新的命令时，我们只需定义一个新的带有新`Val`单例的`process_command`函数。主调度器函数不再有任何变化。
- en: 'It is possible to create your own parametric type rather than using the standard
    `Val` type. This can be achieved quite simply, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能创建自己的参数化类型，而不是使用标准的`Val`类型。这可以非常简单地实现，如下所示：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The constructor function takes a string and creates a `Command` singleton object
    with a `Symbol` type parameter that is converted from the string. Having such
    a singleton type, we can define our dispatcher function and corresponding actions
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个字符串，并创建一个具有`Symbol`类型参数的`Command`单例对象，该参数从字符串转换而来。有了这样的单例类型，我们可以定义我们的调度函数和相应的操作如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This style of code is fairly idiomatic in Julia programming – there is no conditional
    branch anymore since it is replaced by function dispatch. In addition, you also
    extend the functionality of a system by defining new functions, without the need
    to modify any existing code. This is a fairly useful characteristic when we need
    to extend functions from a third-party library.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码风格在Julia编程中相当常见——由于它被函数调度所取代，因此不再有条件分支。此外，你还可以通过定义新函数来扩展系统的功能，而无需修改任何现有代码。当我们需要从第三方库扩展函数时，这是一个相当有用的特性。
- en: Next, we will do some experiments and measure the performance of dynamic dispatch.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行一些实验并测量动态调度的性能。
- en: Understanding the performance benefits of dispatch
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解调度的性能优势
- en: Using a singleton type is nice because we can avoid writing conditional branches.
    Another side benefit is that performance can be greatly improved. An interesting
    example can be found in the `ntuple` function from Julia's Base package.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单例类型很棒，因为我们可以避免编写条件分支。另一个副作用是性能可以大大提高。一个有趣的例子可以在Julia的Base包中的`ntuple`函数中找到。
- en: 'The `ntuple` function is used to create a tuple of N elements by applying a
    function over the sequence of 1 to N. For example, we can create a tuple of even
    numbers as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ntuple`函数用于通过在1到N的序列上应用函数来创建N个元素的元组。例如，我们可以创建一个偶数元组如下：'
- en: '![](img/edba9bf7-adba-4e1c-8afe-decf81c3ecdd.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edba9bf7-adba-4e1c-8afe-decf81c3ecdd.png)'
- en: 'The first argument is an anonymous function that doubles the value. Since we
    specified 10 in the second argument, it mapped over the range of 1 to 10 and gave
    us 2, 4, 6, ... 20\. If we take a peek into the source code, we will find this
    interesting definition:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个匿名函数，它将值加倍。由于我们在第二个参数中指定了10，它映射了从1到10的范围，并给出了2，4，6，... 20。如果我们查看源代码，我们会发现这个有趣的定义：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While the code is indented quite nicely, we can clearly see that it supports
    up to 10 elements by hard coding the short-circuit branches with the `?` and `:` ternary
    operators. If it''s more than 10, then it calls another function to create the
    tuple:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码缩进得相当好，但我们清楚地看到它通过使用`?`和`:`三联运算符硬编码短路分支来支持最多10个元素。如果超过10个，则调用另一个函数来创建元组：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This `_ntuple` function is expected to perform poorly because it creates an
    array using comprehension and then the result is splatted into a new tuple. You
    may be very surprised by the performance benchmarking result when we compare the
    case of creating a 10-element tuple versus an 11-element tuple:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`_ntuple`函数预计会表现不佳，因为它使用列表推导创建一个数组，然后将结果展开到一个新的元组中。当我们比较创建一个10个元素的元组与一个11个元素的元组的性能基准测试结果时，你可能会非常惊讶：
- en: '![](img/d37679bc-bcb4-4bf7-9af2-e0fb7c398352.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d37679bc-bcb4-4bf7-9af2-e0fb7c398352.png)'
- en: The `ntuple` function is designed to perform optimally when the number of elements
    is small, that is, for 10 or fewer elements. It would be possible to change the
    `ntuple` function to hardcode more, but it would be too tedious to write the code,
    and the resulting code would be extremely ugly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ntuple`函数旨在在元素数量较少时表现最佳，即10个或更少的元素。理论上，我们可以将`ntuple`函数更改为硬编码更多的内容，但这将非常繁琐，并且生成的代码将非常丑陋。'
- en: 'Perhaps a little more surprisingly, Julia actually comes with another variation
    of the same function while using the `Val` singleton type, as shown in the following
    screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更令人惊讶的是，当使用`Val`单例类型时，Julia实际上还提供了同一函数的另一种变体，如下面的截图所示：
- en: '![](img/0a146254-a816-4277-9f65-161d4f3b2dee.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a146254-a816-4277-9f65-161d4f3b2dee.png)'
- en: 'There is literally no difference between 10 and 11 elements. In fact, even
    with 100 elements, the performance is quite reasonable (17 nanoseconds) compared
    to the non-`Val` version (820 nanoseconds). Let''s take a look at how it is implemented.
    The following has been taken from the Julia source code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 10个和11个元素之间实际上没有区别。事实上，即使有100个元素，性能也非常合理（17纳秒），与非`Val`版本（820纳秒）相比。让我们看看它是如何实现的。以下是从Julia源代码中摘录的：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding code, we can see that there are a few functions being defined
    for tuples that have fewer than four elements. After that, the function uses a
    meta-programming technique to generate code on the fly. In this case, it uses
    a special construct that allows the compiler to choose between code generation
    and its generic implementation, which is represented in if-blocks and else-blocks
    in the code. Looking at how the `@generated`, `@nexprs`, and `@ncalls` macros
    work is out of the scope of this section, but you are encouraged to find out more
    from the Julia reference manual.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到定义了一些用于元素少于四个的元组的函数。之后，该函数使用元编程技术即时生成代码。在这种情况下，它使用一个特殊的结构，允许编译器在代码生成和其通用实现之间进行选择，通用实现用代码中的
    if 块和 else 块表示。关于 `@generated`、`@nexprs` 和 `@ncalls` 宏的工作原理超出了本节的范围，但鼓励您从 Julia
    参考手册中了解更多信息。
- en: According to our preceding performance test, calling `ntuple` with `Val(100)` was
    quite fast, so it appears that the compiler has chosen the code generation path.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的性能测试，使用 `Val(100)` 调用 `ntuple` 非常快，因此看起来编译器已经选择了代码生成路径。
- en: To summarize, we have learned how to use parametric types to create new singletons
    and create functions that are dispatched by these singleton types. We can apply
    this pattern whenever we need to handle such conditional branches.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们已经学习了如何使用参数化类型来创建新的单例（singletons）并创建由这些单例类型调用的函数。我们可以在需要处理此类条件分支时应用此模式。
- en: Next, we will learn how to develop automated testing code effectively using
    stubs and mocks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何有效地使用存根和模拟来开发自动化测试代码。
- en: Stubbing/Mocking pattern
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stubbing/Mocking 模式
- en: Julia comes with excellent tools for building automated unit tests. When the
    programmer follows good design patterns and best practices, the software is likely
    going to be composed of many small functions that can be tested individually.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了构建自动化单元测试的优秀工具。当程序员遵循良好的设计模式和最佳实践时，软件很可能会由许多可以单独测试的小函数组成。
- en: 'Unfortunately, certain test cases are more difficult to handle. They usually
    involve testing components that have specific dependencies that are awkward to
    be included in automated tests. Common issues include the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，某些测试用例处理起来比较困难。它们通常涉及测试具有特定依赖项的组件，这些依赖项难以包含在自动化测试中。常见问题包括以下内容：
- en: '**Performance**: The dependency may be a time-consuming process.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：依赖项可能是一个耗时的过程。'
- en: '**Cost**: The dependency may incur a financial cost every time it is invoked.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：依赖项每次被调用时可能会产生财务成本。'
- en: '**Randomness**: The dependency may produce a different result every time it
    is invoked.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机性**：依赖项每次被调用时可能会产生不同的结果。'
- en: Stubbing/Mocking is a common strategy to address these issues. In this section,
    we will look into how to apply stubs and mocks while testing Julia code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Stubbing/Mocking 是解决这些问题的常用策略。在本节中，我们将探讨如何在测试 Julia 代码时应用存根（stubs）和模拟（mocks）。
- en: What are testing doubles?
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试替身是什么？
- en: Before we get into the specifics about stubbing/mocking, it would be helpful
    to go over some industry-standard terminology. First of all, there is the concept
    of *testing doubles*. Interestingly, the term comes from a movie-making technique
    that's related to how stunts are filmed. When performing dangerous acts, a stuntman
    or stuntwoman replaces the actor or actress to perform the job. From a viewer's
    perspective, it would look like the original actor or actress was performing.
    Testing doubles are the same in the sense that a fake component is used in place
    of the real thing during testing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨存根/模拟的具体内容之前，回顾一些行业标准术语会有所帮助。首先，有 *测试替身（testing doubles）* 的概念。有趣的是，这个术语来源于与特技拍摄相关的电影制作技术。当表演危险动作时，特技演员会代替演员或女演员来完成工作。从观众的角度来看，这会让人误以为原演员或女演员在表演。测试替身在此意义上是相同的，即在测试中使用一个假组件来代替真实组件。
- en: There are multiple types of testing doubles, but the most useful ones are *stubs*
    and *mocks*, which we will focus on in this section. In object-oriented programming,
    these concepts are expressed in terms of classes and objects. In Julia, we will
    leverage the same terminology for functions. One benefit of working with functions
    is that we can focus all of our effort on testing a single thing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 测试替身有多种类型，但最有用的是 *存根（stubs）* 和 *模拟（mocks）*，我们将在本节中重点关注。在面向对象编程中，这些概念用类和对象来表示。在
    Julia 中，我们将使用相同的术语来表示函数。与函数一起工作的一个好处是我们可以将所有精力集中在测试单一事物上。
- en: 'A **stub** is a fake function that imitates the real function, also known as
    the *collaborator function*. Depending on what is required from the testing objectives,
    they can be as dumb as returning the same result all the time, or they can be
    a little smarter and return different values, depending on the input arguments.
    Regardless of how smart they are, return values are almost always hardcoded for
    consistency reasons. During testing, stubs replace the collaborator function when
    the **function under test** (**FUT**) is being exercised. When the FUT finishes
    its execution, we can determine the correctness of the returned value. This is
    called *state verification*. The interaction between these functions can be depicted
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**存根**是一个模仿真实函数的假函数，也称为*协作函数*。根据测试目标的要求，它们可以非常简单，总是返回相同的结果，或者它们可以稍微聪明一些，根据输入参数返回不同的值。无论它们有多聪明，出于一致性的原因，返回值几乎总是硬编码的。在测试期间，当**被测试函数**（**FUT**）被调用时，存根会替换协作函数。当
    FUT 完成执行后，我们可以确定返回值的正确性。这被称为*状态验证*。这些函数之间的交互可以表示如下：'
- en: '![](img/83731e39-751b-414f-a05c-d6d91115f015.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83731e39-751b-414f-a05c-d6d91115f015.png)'
- en: 'A **mock** is also a fake function that imitates the collaborator function.
    The difference between mocks and stubs is that a mock focuses on behavior verification.
    Rather than just examining the state of the FUT, mocks keep track of all the calls
    being made. It can be used to verify behavior, such as how many times the mock
    is expected to be called, the types and values of the arguments that the mock
    expected to be passed, and so on. This is called *behavior verification*. At the
    end of their execution, we can perform both state verification and behavior verification. This
    is depicted as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟**也是一个模仿协作函数的假函数。与存根（stubs）相比，模拟关注行为验证。而不是仅仅检查 FUT 的状态，模拟会跟踪所有被调用的函数。它可以用来验证行为，例如模拟预期被调用的次数、模拟期望传递的参数的类型和值等。这被称为*行为验证*。在它们的执行结束时，我们可以进行状态验证和行为验证。如下所示：'
- en: '![](img/f0022792-8675-41c0-a4da-970a06c2352f.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0022792-8675-41c0-a4da-970a06c2352f.png)'
- en: In the upcoming sections, we will focus on how to apply stubs and mocks in testing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将重点介绍如何在测试中应用存根和模拟。
- en: Introducing the credit approval use case
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍信用审批用例
- en: 'In this section, we''ll introduce a sample use case related to credit approval.
    Suppose that you are developing a system that has the ability to open a new credit
    card account for a customer upon a successful background check. You may create
    a Julia module that has the following structure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个与信用审批相关的示例用例。假设你正在开发一个系统，该系统能够在背景调查成功后为客户开设新的信用卡账户。你可以创建一个具有以下结构的
    Julia 模块：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s implement each of the functions. We''ll start with the `check_background`
    function, which just logs the event and returns true, meaning that the background
    check is successful. Consider the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现每个函数。我们将从 `check_background` 函数开始，该函数只是记录事件并返回 true，表示背景调查成功。考虑以下代码：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `create_account` function is similar to this. In this case, the expected
    behavior is to return an account number, that is, an integer value that refers
    to the account that has just been created. For this example, we just return a
    hardcoded value of 1, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_account` 函数与此类似。在这种情况下，预期的行为是返回一个账户号，即一个整数值，它指的是刚刚创建的账户。对于这个例子，我们只返回一个硬编码的值
    1，如下所示：'
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `notify_customer` function is supposed to send an email to the customer.
    For testing purposes, we will just log the event; nothing needs to be returned:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify_customer` 函数的目的是向客户发送电子邮件。出于测试目的，我们只需记录事件；不需要返回任何内容：'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, the `open_account` function is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`open_account` 函数如下：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the FUT in our example. The logic involves checking the background for
    a customer and creating an account and notifying downstream about the new account
    if the background check is successful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例中的 FUT。逻辑涉及检查客户的背景，并在背景调查成功时创建账户，并通知下游关于新账户的信息。
- en: Let's think about how to test the `open_account` function. The obvious thing
    that needs our attention is the background check code. More specifically, we expect
    two possible execution paths – when the background check is successful and when
    the background check fails. If we need to cover both cases, then we need to be
    able to simulate the different return values of the `check_background` function.
    We will do that next with a stub.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考如何测试 `open_account` 函数。需要我们注意的明显事情是背景检查代码。更具体地说，我们期望有两个可能的执行路径——当背景检查成功和当背景检查失败时。如果我们需要覆盖这两个案例，那么我们需要能够模拟
    `check_background` 函数的不同返回值。我们将使用存根来实现这一点。
- en: Performing state verification using stubs
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根执行状态验证
- en: Our goal is to test the `open_account` function with two scenarios, where the
    `check_background` function returns either true or false. When a background check
    is successful, we expect `open_account` to return `:success`. Otherwise, it should
    return `:failure`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是测试 `open_account` 函数的两个场景，其中 `check_background` 函数返回 true 或 false。当背景检查成功时，我们期望
    `open_account` 返回 `:success`。否则，它应该返回 `:failure`。
- en: Using our terminology, `open_account` is the function under test, while `check_background`
    is the collaborator function. It is a bit unfortunate that we can't really control
    how the collaborator function behaves. In practice, this function may even reach
    out to a background check service, the working of which we have little influence
    on. As a matter of fact, we would not want to call the remote service every single
    time that we test our software.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的术语，`open_account` 是被测试的函数，而 `check_background` 是协作函数。我们无法真正控制协作函数的行为，这有点不幸。实际上，这个函数甚至可能调用背景检查服务，而我们对此几乎没有影响力。事实上，我们不想在每次测试我们的软件时都调用远程服务。
- en: Now that we have copied from the original `CreditApproval` module to a new module
    called `CreditApprovalStub`, we can move on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将原始的 `CreditApproval` 模块复制到一个名为 `CreditApprovalStub` 的新模块中，我们可以继续下一步。
- en: 'Since we are smart programmers, we can just create a stub that replaces the
    collaborator function. As functions are first-class in Julia, we can refactor
    the `open_account` function so that it can take any background check function
    from a keyword argument, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是聪明的程序员，我们可以创建一个存根来替换协作函数。由于在 Julia 中函数是一等公民，我们可以重构 `open_account` 函数，使其能够接受任何来自关键字参数的背景检查函数，如下所示：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The new `checker` keyword argument takes a function that is used to perform
    a background check for a customer. We have set the default value to the original
    `check_background` function, so it should behave the same as before. Now, the
    function is more testable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `checker` 关键字参数接受一个用于为客户执行背景检查的函数。我们已将其默认值设置为原始的 `check_background` 函数，因此它应该与之前的行为相同。现在，函数更容易进行测试。
- en: 'In our test suite, we can now exercise both execution paths, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试套件中，我们现在可以练习两个执行路径，如下所示：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we have created two stubs for background checks: `check_background_success`
    and `check_background_failure`. They return true and false to simulate a successful
    and failed background check, respectively. Then, when we need to test the `open_account`
    function, we can just pass these stub functions via the `checker` keyword argument.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为背景检查创建了两个存根：`check_background_success` 和 `check_background_failure`。它们分别返回
    true 和 false 来模拟成功和失败的背景检查。然后，当我们需要测试 `open_account` 函数时，我们只需通过 `checker` 关键字参数传递这些存根函数。
- en: 'Let''s run the test now:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来运行测试：
- en: '![](img/3167bd6e-aff8-4ad0-8535-7952bbd8e10f.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3167bd6e-aff8-4ad0-8535-7952bbd8e10f.png)'
- en: At this point, we have only enabled the `check_background` function for stubbing
    in the `open_account` function. What if we want to do the same for the `create_account`
    and `notify_downstream` functions? It would be just as easy if we created two
    more keyword arguments and called it done. This isn't a bad option. However, you
    may not be very satisfied with the fact that we need to keep changing the code
    to make new tests. Furthermore, these keyword arguments were added merely for
    the sake of testing, rather than being a part of the call interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅在 `open_account` 函数中为存根启用了 `check_background` 函数。如果我们想对 `create_account`
    和 `notify_downstream` 函数做同样的事情怎么办？如果我们创建了两个额外的关键字参数并完成它，这将会同样简单。这不是一个坏选项。然而，你可能对我们的代码需要不断更改以进行新测试的事实不太满意。此外，这些关键字参数仅仅是为了测试而添加的，而不是调用接口的一部分。
- en: In the next section, we will explore the use of the Mocking package, which is
    an excellent tool for applying stubs and mocks without messing too much with the
    source code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 Mocking 包的使用，这是一个在源代码上改动不大的优秀工具，用于应用占位符和模拟。
- en: Implementing stubs with the Mocking package
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mocking 包实现占位符
- en: A good alternative to implementing stubs is the Mocking package. This package
    is fairly straightforward to use. We will quickly go over how to use Mocking to
    apply the same stubs that we applied earlier.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实现占位符的一个很好的替代方案是 Mocking 包。这个包使用起来相当简单。我们将快速概述如何使用 Mocking 来应用之前应用过的相同占位符。
- en: 'In order to follow this exercise, you can copy the code from the original `CreditApproval`
    module to a new module called `CreditApprovalMockingStub`. Now, follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随这个练习，你可以将 `CreditApproval` 模块中的代码复制到一个名为 `CreditApprovalMockingStub` 的新模块中。现在，按照以下步骤操作：
- en: 'First, make sure that the Mocking package is installed. Then, modify the function
    under test, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保 Mocking 包已安装。然后，修改测试函数，如下所示：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `@mock` macro creates an injection point where a stub can be applied, replacing
    the existing call to the collaborator function, that is, `check_background`. Under
    normal execution conditions, the `@mock` macro simply calls the collaborator function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`@mock` 宏创建了一个注入点，在这里可以应用占位符，替换现有的协作函数调用，即 `check_background`。在正常执行条件下，`@mock`
    宏简单地调用协作函数。'
- en: 'During testing, however, a stub can be applied. To achieve such behavior, we
    need to activate mocking at the top of the test script, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在测试期间，可以应用占位符。为了实现这种行为，我们需要在测试脚本顶部激活模拟，如下所示：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we can define stub functions using the `@patch` macro:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `@patch` 宏来定义占位符函数：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `@patch` macro can be placed right in front of a function definition. The
    function name must match the original collaborator function name. Likewise, the
    function arguments should match as well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`@patch` 宏可以直接放在函数定义的前面。函数名必须与原始协作函数名匹配。同样，函数参数也应该匹配。'
- en: 'The `@patch` macro returns an anonymous function that can be applied to the
    call site in the FUT. To apply a patch, we use the `apply` function, as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@patch` 宏返回一个匿名函数，可以应用到 FUT（Future of the Under Test）中的调用位置。要应用补丁，我们使用 `apply`
    函数，如下所示：'
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `apply` function takes the stub and applies it to everywhere that the collaborator
    function is called, as identified by the `@mock` macro in the function under test.
    Let''s run the test from the REPL:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`apply` 函数接受一个占位符并将其应用到测试函数中由 `@mock` 宏标识的协作函数被调用之处。让我们从交互式解释器（REPL）中运行这个测试：'
- en: '![](img/f6b663ef-9c64-4867-aaf4-f0506f33e17f.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6b663ef-9c64-4867-aaf4-f0506f33e17f.png)'
- en: 'Now, let''s make sure that the stubs are not applied under normal execution
    conditions. From the REPL, we can call the function directly:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们确保在正常执行条件下不会应用占位符。从交互式解释器（REPL）中，我们可以直接调用该函数：
- en: '![](img/f8d540fc-ed9d-44e7-bf76-e8fa5ca204e4.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8d540fc-ed9d-44e7-bf76-e8fa5ca204e4.png)'
- en: '*Fabulous!*From the preceding output, we can see that the original collaborator
    function, `check_background`, was called.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*太棒了!* 从前面的输出中，我们可以看到原始的协作函数 `check_background` 被调用了。'
- en: Next, we will expand on the same idea and apply multiple stubs to the same function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展同样的想法，并将多个占位符应用到同一个函数上。
- en: Applying multiple stubs to the same function
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个占位符应用到同一个函数上
- en: In our example, the `open_account` function calls several dependent functions.
    It performs background checks for a customer, creates the account, and notifies
    downstream systems. Practically speaking, we may want to create stubs for all
    of them. How do we apply multiple stubs? The Mocking package supports this feature.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`open_account` 函数调用几个依赖函数。它为客户执行背景检查，创建账户，并通知下游系统。实际上，我们可能想要为所有这些函数创建占位符。我们如何应用多个占位符？Mocking
    包支持这个功能。
- en: 'As usual, we would need to decorate the `open_account` function with a `@mock`
    macro for every function that we want to apply to our stubs. The following code
    shows this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们需要为想要应用到占位符中的每个函数用 `@mock` 宏进行装饰。以下代码展示了这一点：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we''re all set to create more stubs. For demonstration purpose, we will
    define another stub for the `create_account` function, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建更多的占位符。为了演示目的，我们将为 `create_account` 函数定义另一个占位符，如下所示：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As part of its design, this stub function must return an account number. Therefore,
    we are just returning a fake value of 314\. To test the scenario where both `check_background_success_patch`
    and `create_account_patch` are applied, we can pass them as an array to the `apply`
    function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其设计的一部分，这个存根函数必须返回一个账户号码。因此，我们只是返回一个假的值314。为了测试同时应用`check_background_success_patch`和`create_account_patch`的场景，我们可以将它们作为数组传递给`apply`函数：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that we have not provided any stub for the `notify_downstream` function.
    When a stub is not provided, the original collaborator function is used. Hence,
    we have all the flexibility we want in applying stub functions in our test suite.
    In the `open_account` function, since we have placed `@mock` in three different
    injection points, we can technically test eight different scenarios, for which
    each stub is enabled or disabled.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有为`notify_downstream`函数提供任何存根。当没有提供存根时，将使用原始的协作函数。因此，我们在测试套件中应用存根函数时拥有所有想要的灵活性。在`open_account`函数中，由于我们在三个不同的注入点放置了`@mock`，我们可以从技术上测试八个不同的场景，对于每个场景，每个存根都是启用或禁用的。
- en: The complexity of tests for the FUT increases exponentially by the number of
    branches and functions that are used inside the function. This is also one of
    the reasons why we want to write small functions. Due to this, it is a good idea
    to break down large functions into smaller ones so that they can be tested independently.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: FUT（Future of Testing）测试的复杂性会随着函数内部使用的分支和函数数量的指数级增长。这也是我们想要编写小函数的原因之一。因此，将大函数分解成较小的函数是一个好主意，这样它们就可以独立进行测试。
- en: Using stubs, we can easily verify the expected return value for a function.
    A different approach is mocking, which shifts the focus to verifying the behavior
    of the FUT and its collaboration functions. We will look into that next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存根，我们可以轻松验证函数的预期返回值。另一种方法是模拟，它将重点放在验证FUT及其协作函数的行为上。我们将在下一节中探讨这一点。
- en: Performing behavior verification using mocks
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟对象进行行为验证
- en: 'Mocks are different from stubs – rather than just testing the return value
    of a function, we focus on testing expectations from the collaborator functions''
    perspective. What kind of activities does a collaborator function expect? Here
    are some examples for our use case:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象与存根对象不同——我们不仅仅测试函数的返回值，而是从协作函数的角度来测试期望。协作函数期望进行哪些活动？以下是一些针对我们用例的示例：
- en: From the `check_background` function's perspective, was it called only once
    for each `open_account` call?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`check_background`函数的角度来看，它是否在每次`open_account`调用时只被调用一次？
- en: From the `create_account` function's perspective, was it called when a background
    check was successful?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`create_account`函数的角度来看，当背景检查成功时，它是否被调用？
- en: From the `create_account` function's perspective, was it not called when the
    background check failed?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`create_account`函数的角度来看，当背景检查失败时，它是否没有被调用？
- en: From the `notify_account` function's perspective, was it called with an account
    number that is greater than 0?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`notify_account`函数的角度来看，它是否被调用，并且账户号码大于0？
- en: 'The process to set up a mock-enabled test involves four main steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 设置模拟对象启用测试的过程涉及四个主要步骤：
- en: Set up the mock functions that will be used during the test.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置测试期间将使用的模拟函数。
- en: Establish the expectations for the collaborator functions.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为协作函数建立期望。
- en: Run the tests.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Verify the expectations that we set earlier.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们之前设置的期望。
- en: 'Now, let''s try to develop our own mock test. Here, we will exercise the success
    path for opening a new account. In this case, we can expect the `check_background`,
    `create_account`, and `notify_downstream` functions to be called exactly once.
    Also, we can expect that the account number being passed to the `notify_downstream`
    function should be a number greater than 1\. Keeping this information in mind,
    we will create a let-block with bound variables to track everything that we want
    to test against our expectations:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试开发自己的模拟测试。在这里，我们将练习为新账户打开的成功路径。在这种情况下，我们可以期望`check_background`、`create_account`和`notify_downstream`函数被精确地调用一次。此外，我们还可以期望传递给`notify_downstream`函数的账户号码应该是一个大于1的数字。记住这些信息，我们将创建一个带有绑定变量的let-block来跟踪我们想要测试的所有期望：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first three variables will be used to track the number of calls to the
    three mocks that we are about to create. Also, the last variable will be used
    to record whether the `notify_downstream` function received a proper account number
    during the test. Within this let-block, we will implement the four steps we outlined
    previously. Let''s define the mock functions first:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个变量将用于跟踪即将创建的三个模拟的调用次数。最后一个变量将用于记录在测试期间`notify_downstream`函数是否收到了正确的账户号码。在这个let块中，我们将实现之前概述的四个步骤。让我们首先定义模拟函数：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we just increment the `check_background_call_count` counter within the
    mock function so that we can keep track of how many times the mock function is
    called. Similarly, we can define the `create_account_patch` mock function in the
    same way:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在模拟函数中增加`check_background_call_count`计数器，以便我们可以跟踪模拟函数被调用的次数。同样，我们可以以相同的方式定义`create_account_patch`模拟函数：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last mock function, `notify_downstream_patch`, covers two expectations.
    Not only does it keep track of the number of calls, but it also verifies that
    the account number being passed is proper and, if so, updates the Boolean flag.
    The following code shows this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个模拟函数`notify_downstream_patch`覆盖了两个期望。它不仅跟踪调用次数，还验证传递的账户号码是否正确，如果是，则更新布尔标志。以下代码展示了这一点：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second step is to establish our expectation formally. This can be defined
    as a simple function, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是正式建立我们的期望。这可以定义为以下简单函数：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `verify` function includes a set of expectations, formally defined as regular
    Julia tests. Now, we are ready to exercise our test by applying all three mock
    functions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`verify`函数包含一系列期望，正式定义为常规Julia测试。现在，我们已经准备好通过应用所有三个模拟函数来执行我们的测试：'
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, as the very last step, we will test against our expectation. It is
    simply a call to the `verify` function that we defined earlier:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为最后一步，我们将针对我们的期望进行测试。这只是一个调用我们之前定义的`verify`函数：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we are ready to run the mock test. The respective results are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行模拟测试。相应的结果如下：
- en: '![](img/cf26ccee-e303-4386-88c2-d76e934bee99.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf26ccee-e303-4386-88c2-d76e934bee99.png)'
- en: The result statistics show five test cases in total and all of them passed.
    Four out of the five tests came from the `verify` function for behavior verification,
    while one came from the state verification for the return value of the `open_account`
    function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果统计显示总共有五个测试用例，并且所有测试都通过了。其中四个测试来自`verify`函数的行为验证，而另一个测试来自对`open_account`函数返回值的`state
    verification`。
- en: As you can see, mocks are quite different from stub because they are used to
    perform both behavior and state verifications.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模拟与存根有很大不同，因为它们用于执行行为和状态验证。
- en: Next, we will look into a pattern that's related to how data pipelines can be
    built more intuitively.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一个与如何更直观地构建数据管道相关的模式。
- en: Functional pipes pattern
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能管道模式
- en: Sometimes, when building an application, we face a large problem that requires
    complex calculations and data transformation. Using structured programming techniques,
    we can often break down the large problem into medium-sized problems and then
    break these down further into small-sized problems. When a problem is small enough,
    we can write functions to tackle each problem individually.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在构建应用程序时，我们会遇到需要复杂计算和数据转换的大问题。使用结构化编程技术，我们通常可以将大问题分解为中等规模的问题，然后再进一步将这些中等规模的问题分解为小规模的问题。当问题足够小的时候，我们可以编写函数来单独处理每个问题。
- en: Of course, these functions do not work in isolation – it is more likely that
    the results of one function will feed into another function. In this section,
    we will explore the functional pipes pattern, which allows data to be passed seamlessly
    through a data pipeline. This is not uncommon in functional programming languages
    but is seen less in Julia. Nevertheless, we will take a look and see how it can
    be done.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些函数并不是独立工作的——更有可能的是，一个函数的结果会输入到另一个函数中。在本节中，我们将探讨功能管道模式，它允许数据在数据管道中无缝传递。这在函数式编程语言中并不罕见，但在Julia中却较少见。尽管如此，我们仍将探讨它，看看它是如何实现的。
- en: First, we will go over a sample use case related to downloading recent Hacker
    News stories for analysis. Then, we will progressively refactor the code into
    using the functional pipes pattern. Let's go!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将回顾一个与下载最近Hacker News故事进行分析相关的示例用例。然后，我们将逐步重构代码以使用功能管道模式。让我们开始吧！
- en: Introducing the Hacker News analysis use case
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Hacker News 分析用例
- en: Hacker News is a popular online forum that's used by software developers. The
    topics on this forum are usually related to technology, but not always. The stories
    are ranked according to the number of votes by users, respective timeliness, and
    other factors. Every story has a score associated with it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Hacker News是一个流行的在线论坛，被软件开发者所使用。这个论坛上的主题通常与技术相关，但并不总是如此。故事根据用户投票数、相关时效性和其他因素进行排名。每个故事都有一个与之相关的评分。
- en: In this section, we will develop a program that retrieves the top stories from
    Hacker News and calculates an average score of those stories. More information
    about the Hacker News API can be found in the following GitHub repository: [https://github.com/HackerNews/API](https://github.com/HackerNews/API).
    Here, you can quickly go over the process of retrieving stories and details about
    each story.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个程序，用于从Hacker News检索顶级故事并计算这些故事的平均评分。有关Hacker News API的更多信息，请参阅以下GitHub仓库：[https://github.com/HackerNews/API](https://github.com/HackerNews/API)。在这里，您可以快速了解检索故事和每个故事详情的过程。
- en: Fetching top story IDs on Hacker News
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Hacker News上的顶级故事ID
- en: 'First, we will create a module called `HackerNewsAnalysis`. The very first
    function is going to retrieve the top stories from Hacker News. The code for this
    is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`HackerNewsAnalysis`的模块。第一个函数将用于从Hacker News检索顶级故事。该代码如下：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'How does it work? Let''s try it out:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？让我们试试看：
- en: '![](img/11d3946d-238d-48c9-8b75-665dafb60b92.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11d3946d-238d-48c9-8b75-665dafb60b92.png)'
- en: 'Let''s take several steps and dissect the logic in this function. The top stories
    can be retrieved from a fixed URL. Here, we have used the HTTP package for fetching
    data from web services. The `HTTP.request` function call, if successful, returns
    an `HTTP.Message.Response` object. It is easy to verify from the REPL:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分几个步骤来剖析这个函数的逻辑。顶级故事可以从一个固定的URL中检索。在这里，我们使用了HTTP包从网络服务中获取数据。如果`HTTP.request`函数调用成功，它将返回一个`HTTP.Message.Response`对象。这很容易在REPL中验证：
- en: '![](img/b969a9a6-2a41-4438-a89d-f56e27943147.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b969a9a6-2a41-4438-a89d-f56e27943147.png)'
- en: 'So, how do we get the content from the `Response` object? It is available from
    the `body` field. As it turns out, the `body` field is just a byte array. To understand
    what the data means, we can convert it into a `String`, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何从`Response`对象中获取内容呢？它可以从`body`字段中获取。实际上，`body`字段只是一个字节数组。为了理解这些数据的意义，我们可以将其转换为`String`，如下所示：
- en: '![](img/df1b8b94-11b8-47e7-8cba-c22c6f14acbe.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df1b8b94-11b8-47e7-8cba-c22c6f14acbe.png)'
- en: 'Judging from the output, we can see that it is in JSON format. We can also
    verify the same by visiting the web URL from a browser. From the API documentation,
    we know that the numbers represent story IDs from Hacker News. To parse the data
    into usable Julia data types, we can leverage the `JSON3` package:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，它是以JSON格式。我们也可以通过在浏览器中访问网络URL来验证这一点。从API文档中，我们知道这些数字代表Hacker News的故事ID。为了将数据解析为可用的Julia数据类型，我们可以利用`JSON3`包：
- en: '![](img/d256434e-2e77-4bad-ad88-f14c3eb11456.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d256434e-2e77-4bad-ad88-f14c3eb11456.png)'
- en: The `JSON3.Array` object is a lazy version of an array. By design, JSON3 does
    not extract the value until you ask for it. We can use it as if it were a regular
    Julia array. For more information, you are encouraged to visit JSON3's documentation
    on GitHub: [https://github.com/quinnj/JSON3.jl/blob/master/README.md](https://github.com/quinnj/JSON3.jl/blob/master/README.md).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON3.Array`对象是数组的懒加载版本。按照设计，JSON3不会提取值，直到你请求它。我们可以将其用作普通的Julia数组。有关更多信息，请访问GitHub上的JSON3文档：[https://github.com/quinnj/JSON3.jl/blob/master/README.md](https://github.com/quinnj/JSON3.jl/blob/master/README.md)。'
- en: Now that we have an array of story IDs, we will develop the function for retrieving
    detailed information about a Hacker News story.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了故事ID数组，我们将开发一个用于检索Hacker News故事详细信息的函数。
- en: Fetching details about a story
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取故事详情
- en: 'Given a story ID, we can retrieve information about the story using the `item`
    endpoint of the Hacker News API. Before we write the function, let''s define a
    type to store the data:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个故事ID，我们可以使用Hacker News API的`item`端点检索关于该故事的信息。在我们编写函数之前，让我们定义一个类型来存储数据：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The fields of a `Story` are designed according to the JSON schema documented
    on the Hacker News API website. Sometimes, a field may be unavailable for certain
    story types, in which case we will leave them as `nothing` in the object. These
    optional fields include `descendants`, `kids`, and `url`. Lastly, every story
    comes with a unique identifier `id`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Story`的字段是根据Hacker News API网站上的JSON模式设计的。有时，某些字段可能对某些故事类型不可用，在这种情况下，我们将它们在对象中留为`nothing`。这些可选字段包括`descendants`、`kids`和`url`。最后，每篇故事都有一个唯一的标识符`id`。'
- en: 'We need a constructor to create `Story` objects. Because JSON3 returns a dictionary-like
    object, we can just extract individual fields and pass them to the constructor.
    The constructor''s function can be defined as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个构造函数来创建`Story`对象。因为JSON3返回一个类似字典的对象，我们可以直接提取单个字段并将它们传递给构造函数。构造函数的函数可以定义为以下内容：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Generally, we can extract the field from a `Dict` object using the index operator
    (square brackets). However, we need to handle the fact that some fields may be
    unavailable in the object. To avoid an unexpected `KeyError`, we can define a
    closure function called `value` for extracting a field or returning `nothing`
    when the key is not found in the object.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以使用索引操作符（方括号）从`Dict`对象中提取字段。然而，我们需要处理某些字段可能不在对象中的事实。为了避免意外的`KeyError`，我们可以定义一个名为`value`的闭包函数来提取字段，或者在键不在对象中时返回`nothing`。
- en: 'Now, let''s take a look at the function for retrieving the details of a single
    story:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看获取单个故事详情的函数：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, we retrieve the data using `HTTP.request`. After we receive the response,
    we can parse the data using JSON3 and construct a `Story` object accordingly.
    Here''s how it works:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用`HTTP.request`检索数据。在收到响应后，我们可以使用JSON3解析数据并相应地构建一个`Story`对象。以下是它是如何工作的：
- en: '![](img/4e8dfc3f-df1d-4b92-be7b-43656a6713d3.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e8dfc3f-df1d-4b92-be7b-43656a6713d3.png)'
- en: Next, we will go over the main program for calculating the average score for
    the top N stories from Hacker News.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍计算Hacker News前N篇故事平均分数的主程序。
- en: Calculating the average score for the top N stories
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算前N篇故事的平均分数
- en: Now that we have the ability to find the top stories and retrieve details about
    each story, we can create a new function to calculate an average score from the
    top N stories.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了找到前N篇故事并检索每篇故事详情的能力，我们可以创建一个新的函数来计算前N篇故事的平均分数。
- en: 'The `average_score` function is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`average_score`函数如下：'
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There are three parts to this function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有三个部分：
- en: The first part finds the story IDs for top stories using the `fetch_top_stories`
    function.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一部分使用`fetch_top_stories`函数找到前N篇故事的ID。
- en: Then, it retrieves details of the first `n` stories using the `fetch_story`
    function.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它使用`fetch_story`函数检索前`n`个故事的详情。
- en: Finally, it calculates the average score from just those stories. Then, the
    average score is returned to the caller.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它只从这些故事中计算平均分数。然后，将平均分数返回给调用者。
- en: In order to get the top `n` story IDs, we have chosen to use the index operator
    with the range `1:min(n,end)`. The `min` function is used to handle the case when
    `n` is greater than the size of the array.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取前`n`个故事ID，我们选择使用索引操作符和范围`1:min(n,end)`。`min`函数用于处理`n`大于数组大小的情况。
- en: 'Let''s run the function and see what happens:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个函数看看会发生什么：
- en: '![](img/58abdc3a-b34c-4f72-a864-1e982c6181cd.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58abdc3a-b34c-4f72-a864-1e982c6181cd.png)'
- en: From the result, we can see that the top `n` stories from Hacker News have an
    average score of 125.4\. Note that you may get a different result since this number
    changes in real time as Hacker News users vote on their favorite stories.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，我们可以看到Hacker News的前`n`篇故事平均得分为125.4。请注意，你可能得到不同的结果，因为这个数字会随着Hacker News用户对他们的最爱故事进行投票而实时变化。
- en: Now that the use case has been established, we will leap forward and experiment
    with a different way of writing the same program. We call this style of programming
    *functional pipes*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用例已经确定，我们将跃进并尝试用不同的方式编写相同的程序。我们称这种编程风格为*函数式管道*。
- en: Understanding functional pipes
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数式管道
- en: In Julia, there is a pipe operator that can be used to pass data from one function
    to another. The concept is very simple. First, let's take a look at some examples.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，有一个管道操作符可以用来从一个函数传递数据到另一个函数。这个概念非常简单。首先，让我们看看一些例子。
- en: 'In the previous section, we developed a `fetch_top_stories` function that''s
    used to retrieve the current top stories from Hacker News. The return value is
    a `JSON3.Array` object that looks like an array of integers. Let''s say we want
    to find the first story ID from the array. To do this, we can create a pipe operation,
    as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们开发了一个`fetch_top_stories`函数，用于从 Hacker News 获取当前的热门故事。返回值是一个看起来像整数数组的`JSON3.Array`对象。假设我们想从数组中找到第一个故事ID。为此，我们可以创建一个管道操作，如下所示：
- en: '![](img/229a17c3-b359-4565-8ac5-a52df569fcea.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/229a17c3-b359-4565-8ac5-a52df569fcea.png)'
- en: 'The pipe operator `|>` is actually defined as a regular function in Julia,
    just like how `+` is defined as a function. Note that the preceding code is syntactically
    equivalent to the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 管道操作符`|>`实际上在 Julia 中被定义为一个常规函数，就像`+`被定义为一个函数一样。请注意，前面的代码在语法上等同于以下代码：
- en: '![](img/a552b267-2943-49a1-b204-cde7e323d37f.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a552b267-2943-49a1-b204-cde7e323d37f.png)'
- en: 'In addition, we can use multiple pipe operators in an expression. For example,
    we can retrieve the details of the first story by appending the `fetch_story`
    function at the end of the pipe:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在表达式中使用多个管道操作符。例如，我们可以通过在管道末尾附加`fetch_story`函数来检索第一个故事的详细信息：
- en: '![](img/a132a714-c648-4b1d-b6ee-276278dab5d3.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a132a714-c648-4b1d-b6ee-276278dab5d3.png)'
- en: 'Because the data naturally flows from left to right, this is called a functional
    pipe pattern. This can be seen in the following diagram:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据自然地从左到右流动，这被称为函数管道模式。这可以在以下图中看到：
- en: '![](img/27f8a457-078e-41db-9389-2e0797fd83a6.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27f8a457-078e-41db-9389-2e0797fd83a6.png)'
- en: 'Note that every function that follows the piping operator must accept a single
    argument. In the preceding example, we can see the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个跟随管道操作符的函数都必须接受单个参数。在前面的例子中，我们可以看到以下内容：
- en: The `first` function takes an array and returns the first element.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`函数接受一个数组并返回第一个元素。'
- en: The `fetch_story` function takes an integer of the story ID and returns a `Story`
    object.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_story`函数接受一个故事ID的整数并返回一个`Story`对象。'
- en: This is a very important point, so let me say this once again – *a functional
    pipe only feeds data to single-argument functions*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的观点，所以让我再说一遍——*函数管道只向单参数函数提供数据*。
- en: We will learn about how to deal with this constraint later. For now, we will
    talk about a similar pattern where the syntax is written in reverse compared to
    functional pipes. This concept is called composability, and is a design technique
    that leads to highly reusable code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后学习如何处理这个限制。现在，我们将讨论一个与函数管道语法相反的类似模式。这个概念被称为可组合性，是一种导致高度可重用代码的设计技术。
- en: Designing composable functions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计可组合函数
- en: Sometimes, you may hear other Julia programmers talk about composability. What
    does that mean?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能会听到其他 Julia 程序员谈论可组合性。那是什么意思？
- en: Composability is used to describe how easily functions can be assembled in different
    ways to achieve different results. Let's look at an analogy. I would say that
    Lego has a highly composable design. This is because almost every piece of Lego
    can be combined with any other piece of Lego, even if they have different shapes.
    For that reason, any kid can use Lego to build almost anything imaginable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合性用来描述函数如何以不同的方式轻松组装以实现不同的结果。让我们来看一个类比。我会说乐高有一个高度可组合的设计。这是因为几乎每一块乐高都可以与其他任何一块乐高组合，即使它们的形状不同。因此，任何孩子都可以用乐高搭建几乎任何可以想象的东西。
- en: When it comes to system design, we can also keep composability in mind. If we
    could build our functions so that they can be composed easily, then we would have
    the flexibility to build many different things as well. In Julia, we can compose
    functions quite easily.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到系统设计时，我们也可以考虑可组合性。如果我们能构建我们的函数，使它们可以轻松组合，那么我们就有了构建许多不同事物的灵活性。在 Julia 中，我们可以非常容易地组合函数。
- en: 'Let''s use the same example from the previous section. We will create a new
    function called `top_story_id` that retrieves the first story ID from Hacker News:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用上一节中的相同示例。我们将创建一个新的函数`top_story_id`，用于从 Hacker News 获取第一个故事ID：
- en: '![](img/71baa434-d1e6-41b1-a26c-b6d9e27af910.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71baa434-d1e6-41b1-a26c-b6d9e27af910.png)'
- en: 'From the preceding code, we can see that the `top_story_id` function is defined
    as an anonymous function. The Unicode circle symbol (`∘`, input as `\circ`) is
    the compose operator in Julia. Unlike the pipe operator, we read the order of
    composed functions from right to left. In this case, we apply the `fetch_top_stories` function
    first and then apply the `first` function. Intuitively, we can use the `top_story_id`
    function as usual:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到 `top_story_id` 函数被定义为匿名函数。Unicode 圆形符号（`∘`，输入为 `\circ`）是 Julia
    中的组合操作符。与管道操作符不同，我们是从右到左读取组合函数的顺序。在这种情况下，我们首先应用 `fetch_top_stories` 函数，然后应用 `first`
    函数。直观上，我们可以像通常一样使用 `top_story_id` 函数：
- en: '![](img/9779ab10-0cc4-453a-a454-f61e49b7b1bf.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9779ab10-0cc4-453a-a454-f61e49b7b1bf.png)'
- en: 'We can also compose multiple functions. To get the top story details, we can
    compose a new function called `top_story`, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以组合多个函数。为了获取最上面的故事详情，我们可以组合一个新的函数，称为 `top_story`，如下所示：
- en: '![](img/939b8ad1-ba1b-44b2-9bd4-162a7f7d8342.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/939b8ad1-ba1b-44b2-9bd4-162a7f7d8342.png)'
- en: '*This is great!* We have taken three random Lego blocks and built a new thing
    out of them. The `top_story` function is a new thing that is composed of three
    smaller blocks:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*太棒了!* 我们拿出了三个随机的乐高积木，用它们搭建了一个新的事物。`top_story`函数是一个由三个较小的积木组成的新事物：'
- en: '![](img/ee9e6815-8318-412d-818f-e2d3ef5a1fe5.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee9e6815-8318-412d-818f-e2d3ef5a1fe5.png)'
- en: Let's go one step further and create a new function to retrieve the title of
    the top story. Now, we run into a little trouble. No function that returns the
    story title from a `Story` object has been defined. However, we can solve this
    problem by utilizing the Accessors Pattern, which we described in [Chapter 8](6b565339-641f-444c-ad42-f8ff7998001b.xhtml),
    *Robustness Patterns*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，创建一个新的函数来检索最上面的故事标题。现在，我们遇到了一点麻烦。还没有定义从 `Story` 对象返回故事标题的函数。然而，我们可以通过利用我们在[第8章](6b565339-641f-444c-ad42-f8ff7998001b.xhtml)中描述的访问器模式来解决此问题，*鲁棒性模式*。
- en: 'Let''s define an accessor for the title field and then compose a new `top_story_title`
    function, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个标题字段的访问器，然后组合一个新的 `top_story_title` 函数，如下所示：
- en: '![](img/6f93e148-a75d-446a-9543-3d52cb7e52fa.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f93e148-a75d-446a-9543-3d52cb7e52fa.png)'
- en: 'This new function works beautifully, as expected:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数工作得非常好，正如预期的那样：
- en: '![](img/6045db13-c177-4561-a5ad-d1ea102a83d9.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6045db13-c177-4561-a5ad-d1ea102a83d9.png)'
- en: The compose operator allows us to create a new function that is composed of
    several other functions. It is slightly more convenient than the pipe operator
    in the sense that the composed function doesn't need to be executed right away.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 组合操作符允许我们创建一个由多个其他函数组成的新函数。在某种程度上，它比管道操作符更方便，因为组合函数不需要立即执行。
- en: Similar to functional pipes, the compose operator also expects single-argument
    functions. Having said that, it is also the reason why single-argument functions
    are more composable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与功能管道类似，组合操作符也期望单参数函数。话虽如此，这也是为什么单参数函数更易于组合的原因。
- en: Next, we will go back and revisit the Hacker News `average_score` function and
    see how we can refactor the code into the functional pipe style.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回到 Hacker News 的 `average_score` 函数，看看我们如何可以将代码重构为功能管道风格。
- en: Developing a functional pipe for the average score function
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发用于平均分数函数的功能管道
- en: 'First, let''s recap on how the `average_score` function was written:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下 `average_score` 函数是如何编写的：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Although the code looks quite decent and simple to understand, let me point
    out some potential issues:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码看起来相当整洁且易于理解，但让我指出一些潜在的问题：
- en: The top stories are retrieved via array comprehension syntax. The logic is a
    little busy and we won't be able to test this part of the code independently from
    the `average_score` function.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最上面的故事是通过数组推导语法检索的。逻辑有点复杂，我们将无法独立于`average_score`函数测试这段代码。
- en: The `println` function is used for logging, but we seem to be replicating the
    code to display the current timestamp.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`println` 函数用于日志记录，但看起来我们似乎在复制代码来显示当前的时间戳。'
- en: 'Now, we will refactor the code. The logic is largely linear, which makes it
    a good candidate for functional pipes. Conceptually, this is what we think about
    the computation:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重构代码。逻辑基本上是线性的，这使得它成为功能管道的良好候选者。从概念上讲，这是我们关于计算的想法：
- en: '![](img/c8f6a9fa-b301-47d9-b72e-17ba0d97f58b.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8f6a9fa-b301-47d9-b72e-17ba0d97f58b.png)'
- en: 'It would be nice to design a function that works like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个像这样工作的函数会很好：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is our second version of the same function, so we have named it `average_score2`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该函数的第二个版本，所以我们将其命名为 `average_score2`。
- en: 'For now, we just ignore the logging aspect to keep it simple. We will come
    back to this later. Since we have already defined the `fetch_top_stories` function,
    we just have to develop the other three functions, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只是忽略日志记录方面，以保持简单。我们稍后会回到这一点。由于我们已定义了 `fetch_top_stories` 函数，我们只需开发其他三个函数，如下所示：
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'From the preceding code, we can see the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到以下内容：
- en: The `take` function takes an integer, `n`, and returns an anonymous function
    that returns the first `n` elements from an array.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take` 函数接收一个整数 `n`，并返回一个匿名函数，该函数从数组中返回前 `n` 个元素。'
- en: The `min` function is used to ensure that it will take no more than the actual
    size of the array.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min` 函数用于确保它不会超过数组的实际大小。'
- en: The `fetch_story_details` function takes an array of story IDs and broadcasts
    the `fetch_story` function over them using the dot notation.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_story_details` 函数接收一个故事 ID 数组，并使用点符号广播 `fetch_story` 函数。'
- en: The `calculate_average_score` function takes an array of `Story` objects and
    calculates the mean of the scores.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculate_average_score` 函数接收一个 `Story` 对象数组，并计算分数的平均值。'
- en: As a quick reminder, all of these functions accept a single argument as input
    so that they can participate in the functional pipe operation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速提醒，所有这些函数都接受单个参数作为输入，这样它们就可以参与函数式管道操作。
- en: Now, let's get back to logging. Logging plays a funny role in functional pipes.
    It is designed to produce side effects and do not affect the result of computation.
    It is *slippery* in the sense that it just returns the same data that it received
    from its input. Since the standard `println` function returns nothing, we cannot
    use it directly in a piping operation. Instead, we must create a logging function
    that is smart enough to print what we want and yet returns the same data that
    it was passed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到日志记录。在函数式管道中，日志记录扮演着有趣的角色。它被设计用来产生副作用，并且不会影响计算结果。在某种意义上，它是“滑稽”的，因为它只是返回从输入接收到的相同数据。由于标准的
    `println` 函数不返回任何内容，我们无法直接在管道操作中使用它。相反，我们必须创建一个足够聪明的日志函数，它能够打印我们想要的内容，同时返回传递给它的相同数据。
- en: 'In addition, we want to be able to format the output using the data that passes
    through the system. For that reason, we can utilize the `Formatting` package.
    It contains a flexible and efficient formatting facility. Let''s build our own
    logging function, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想能够使用通过系统传递的数据来格式化输出。为此，我们可以利用 `Formatting` 包。它包含一个灵活且高效的格式化工具。让我们构建自己的日志函数，如下所示：
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `logx` function takes a format string and a possible transformer function, `f`.
    It returns an anonymous function that passes the transformed value to the `printfmln`
    function. It also automatically prefixes the log with the current timestamp. Most
    importantly, this anonymous function returns the original value of the argument.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`logx` 函数接收一个格式字符串和一个可能的转换函数 `f`。它返回一个匿名函数，该函数将转换后的值传递给 `printfmln` 函数。它还自动在日志前加上当前的时间戳。最重要的是，这个匿名函数返回参数的原始值。'
- en: 'To see how this logging function works, we can play with a few examples:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个日志函数是如何工作的，我们可以尝试一些示例：
- en: '![](img/badbdf09-9008-486e-9c28-5178db123ad0.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/badbdf09-9008-486e-9c28-5178db123ad0.png)'
- en: In the first example shown in the preceding screenshot, the `logx` function
    was called with just a format string, so the input coming via the pipe will be
    used as-is in the log. The second example passes the `length` function as the
    second argument of `logx`. The `length` function is then used to transform the
    input value for logging purposes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个截图所示的第一例中，`logx` 函数仅使用一个格式字符串被调用，因此通过管道传入的输入将直接用于日志。第二个例子将 `length` 函数作为
    `logx` 的第二个参数传递。然后，`length` 函数被用来转换用于日志记录的输入值。
- en: 'Putting this all together, we can introduce logging to our functional pipe
    in our new `average_score3` function, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们可以在新的 `average_score3` 函数中引入日志记录，如下所示：
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Occasionally, functional pipes can make the code easier to understand. Because
    conditional statements are not allowed in a piping operation, the logic is always
    linear.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，函数式管道可以使代码更容易理解。因为管道操作不允许使用条件语句，所以逻辑总是线性的。
- en: You may be wondering how to handle conditional logic in functional pipe design.
    We'll learn about this in the next section.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何在函数式管道设计中处理条件逻辑。我们将在下一节中学习这一点。
- en: Implementing conditional logic in functional pipes
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数式管道中实现条件逻辑
- en: Since the logical flow is quite linear, how do we deal with conditional logic?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逻辑流程相当线性，我们如何处理条件逻辑？
- en: Suppose we want to determine the hotness of top stories by checking the average
    score against a threshold. If the average score is higher than 100, then it would
    be considered high; otherwise, it would be considered low. So, literally, we need
    an if-statement that determines what to execute next.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要通过检查平均分数与阈值的比较来确定热门新闻的热度。如果平均分数高于100，则被认为是高热度；否则，被认为是低热度。因此，字面上，我们需要一个if语句来决定接下来执行什么。
- en: We can use dynamic dispatch to solve this problem. We are going to build this
    function from the bottom-up, as follows.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用动态调度来解决此问题。我们将自下而上构建此函数，如下所示。
- en: 'Create the `hotness` function, which determines the hotness of the Hacker News
    site by score. It returns an instance of the `Val{:high}` or `Val{:low}` parametric
    type. The built-in `Val` data type is a convenient way to create new parametric
    types that can be used for dispatch purposes:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`hotness`函数，它通过分数确定Hacker News网站的热度。它返回`Val{:high}`或`Val{:low}`参数类型的一个实例。内置的`Val`数据类型是创建可用于调度目的的新参数类型的一种方便方式：
- en: '[PRE42]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create two `celebrate` functions with respect to the `Val` parametric types.
    They simply use the `logx` function to print some text. We call it with the value
    of `v` so that the hotness argument is passed downstream if we ever want to do
    more work after celebration:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据参数类型`Val`创建两个`celebrate`函数。它们简单地使用`logx`函数来打印一些文本。我们通过传递`v`的值来调用它，这样在庆祝之后如果我们想要做更多的工作，热度的参数就可以向下传递：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Build the `check_hotness` function, which uses a functional pipe pattern. It
    uses the `average_score3` function to calculate the average score. Then, it uses
    the `hotness` function to determine how to change the execution path. Finally,
    it calls the `celebrate` function via the multiple dispatch mechanism:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`check_hotness`函数，它使用函数式管道模式。它使用`average_score3`函数来计算平均分数。然后，它使用`hotness`函数来确定如何改变执行路径。最后，它通过多态调度机制调用`celebrate`函数：
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s test this out:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: '![](img/374a2225-7a96-4ded-8ff8-1cb54906358f.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/374a2225-7a96-4ded-8ff8-1cb54906358f.png)'
- en: This simple example demonstrates how conditional logic can be implemented in
    functional pipe design. Of course, in reality, we would have more complex logic
    than just printing something to the screen.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子演示了如何在函数式管道设计中实现条件逻辑。当然，在现实中，我们的逻辑会比仅仅在屏幕上打印一些内容要复杂得多。
- en: 'An important observation is that functional pipes only handle linear execution.
    Hence, whenever the execution splits conditionally, we would form a new pipe for
    each possible path. The following diagram depicts how an execution path may be
    designed with functional pipes. Each split of execution is enabled by dispatching
    over the type of a single argument:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的观察是，函数式管道只处理线性执行。因此，每当执行条件分支时，我们就会为每个可能的路径创建一个新的管道。以下图表展示了如何使用函数式管道设计执行路径。每个执行分支的分裂都是由对单个参数类型的调度来实现的：
- en: '![](img/eea27711-3695-463d-8b04-e66e43f2f0e4.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eea27711-3695-463d-8b04-e66e43f2f0e4.png)'
- en: Functional pipes look fairly simple and straightforward from a conceptual point
    of view. However, they are sometimes criticized for having to pass intermediate
    data between each component in the pipe, causing unnecessary memory allocation
    and slowness. In the next section, we will go over how to use broadcasting to
    overcome this issue.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上看，函数式管道看起来相当简单和直接。然而，它们有时因为需要在管道的每个组件之间传递中间数据而被批评，这会导致不必要的内存分配和速度减慢。在下一节中，我们将介绍如何使用广播来克服这个问题。
- en: Broadcasting along functional pipes
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿着函数式管道进行广播
- en: In a data processing pipeline, we may encounter a situation where the functions
    can be fused together into a single loop. This is called *broadcasting *and it
    can be conveniently enabled by using the dot notation. Using broadcasting may
    make a huge performance difference for data-intensive applications.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据处理管道中，我们可能会遇到一种情况，即函数可以融合成一个单一的循环。这被称为*广播*，并且可以通过使用点符号方便地启用。使用广播可能会对数据密集型应用程序的性能产生巨大影响。
- en: 'Consider the following scenario, where two vectorized functions have already
    been defined, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景，其中已经定义了两个向量化函数，如下所示：
- en: '[PRE45]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `add1v` function takes a vector and increments all the elements by 1\.
    Likewise, the `mul2v` function takes a vector and multiplies every element by
    2\. Now, we can combine the functions to create a new one that takes a vector
    and sends it down the pipe to `add1v` and subsequently `mul2v`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`add1v`函数接受一个向量并将所有元素加1。同样，`mul2v`函数接受一个向量并将每个元素乘以2。现在，我们可以组合这些函数来创建一个新的函数，它接受一个向量并将其传递到管道中的`add1v`和随后的`mul2v`：'
- en: '[PRE46]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, the `add1mul2v` function is not optimal from a performance perspective.
    The reason for this is that each operation must be fully completed and then passed
    to the next function. The intermediate result, while only needed temporarily,
    must be allocated in memory:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从性能角度来看，`add1mul2v`函数并不最优。原因是每个操作必须完全完成然后传递到下一个函数。虽然中间结果只需要临时存储，但必须在内存中分配：
- en: '![](img/c5a64914-0132-490a-bd82-f55aae4c0fcc.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5a64914-0132-490a-bd82-f55aae4c0fcc.png)'
- en: As depicted in the preceding diagram, besides the input vector and the output
    vector, an intermediate vector must be allocated to hold the results from the
    `add1v` function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，除了输入向量和输出向量外，还必须分配一个中间向量来存储`add1v`函数的结果。
- en: 'In order to avoid the allocation of the intermediate results, we can utilize
    broadcasting. Let''s create another set of functions that operate on individual
    elements rather than arrays, as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免分配中间结果，我们可以利用广播。让我们创建另一组函数，这些函数操作单个元素而不是数组，如下所示：
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our original problem still requires taking a vector, adding 1, and multiplying
    by 2 for every element. So, we can define such a function using the dot notation,
    as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始的问题仍然需要取出一个向量，对每个元素加1，然后乘以2。因此，我们可以使用点符号定义这样的函数，如下所示：
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The dot character right before the pipe operator indicates that the elements
    in `xs` will be broadcast to the `add1` and `mul2` functions, fusing the whole
    operation into a single loop. The data flow now looks more like the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道操作符之前的点字符表示`xs`中的元素将被广播到`add1`和`mul2`函数，将整个操作融合成一个循环。数据流现在看起来更像是以下这样：
- en: '![](img/170e5aeb-9ac8-430c-ba2a-accbeb830d8a.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/170e5aeb-9ac8-430c-ba2a-accbeb830d8a.png)'
- en: 'Here, the intermediate result becomes a single integer, eliminating the need
    for the temporary array. To appreciate the performance improvement we get from
    broadcasting, we can run a performance benchmark for the two functions, as shown
    in the following screenshot:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，中间结果变成一个单独的整数，消除了对临时数组的需要。为了欣赏我们从广播中获得性能提升，我们可以运行两个函数的性能基准测试，如下面的截图所示：
- en: '![](img/35b7e0a6-5e15-468b-a5f4-e2ff5a4f4a42.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35b7e0a6-5e15-468b-a5f4-e2ff5a4f4a42.png)'
- en: As you can see, the broadcasting version ran twice as fast as the vectorized
    version in this scenario.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，广播版本比矢量化版本快了两倍。
- en: In the next section, we will review some considerations about using functional
    pipes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾一些关于使用功能管道的注意事项。
- en: Considerations about using functional pipes
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于使用功能管道的注意事项
- en: Before you get too excited about functional pipes, let's make sure that we understand
    the pros and cons of using functional pipes.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在您对功能管道过于兴奋之前，让我们确保我们理解使用功能管道的优缺点。
- en: From a readability perspective, functional pipes can possibly make the code
    easier to read and easier to follow. This is because the logic has to be linear.
    On the contrary, some people may find it less intuitive and harder to read because
    the direction of computation is reversed as compared to nested function calls.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从可读性的角度来看，功能管道可能会使代码更容易阅读和跟踪。这是因为逻辑必须是线性的。相反，有些人可能会觉得它不太直观，更难阅读，因为与嵌套函数调用相比，计算的方向是相反的。
- en: 'Functional pipes require single-argument functions, for which they can be easily
    composed with other functions. When it comes to functions that require multiple
    arguments, the general solution is to create *curried functions* – higher-order
    functions that fix an argument. Previously, we defined a `take` function that
    takes the first few elements from a collection:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 功能管道需要单参数函数，它们可以很容易地与其他函数组合。当涉及到需要多个参数的函数时，一般的解决方案是创建*柯里化函数*——一种固定一个参数的高阶函数。之前，我们定义了一个`take`函数，它从一个集合中取出前几个元素：
- en: '[PRE49]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `take` function is a curried function made out of the `getindex` function
    (with a convenient syntax of using square brackets). The `getindex` function takes
    two arguments: a collection and a range. Because the number of arguments has been
    reduced to 1, it can now participate in the functional pipe.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`take` 函数是由 `getindex` 函数（使用方便的方括号语法）构成的柯里化函数。`getindex` 函数接受两个参数：一个集合和一个范围。由于参数数量已减少到
    1，它现在可以参与功能管道。'
- en: On the flip side, we cannot utilize multiple dispatch for single-argument functions.
    This could be a huge disadvantage when you are handling logic that requires consideration
    of multiple arguments.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一方面来看，我们不能为单参数函数使用多重分派。当你处理需要考虑多个参数的逻辑时，这可能会是一个巨大的缺点。
- en: While functions can only accept single arguments, it is possible to work around
    the issue by using tuples. Tuples have a composite type signature that can be
    used for dispatch. However, it's not recommended because it is quite awkward to
    define functions that take a single tuple argument rather than multiple arguments.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数只能接受单个参数，但可以通过使用元组来解决这个问题。元组具有复合类型签名，可用于分派。然而，不推荐这样做，因为定义只接受单个元组参数的函数而不是多个参数的函数相当尴尬。
- en: Nevertheless, functional pipes can be a useful pattern under certain circumstances.
    Any data-processing task that fits into a linear process style could be a good
    fit.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，函数式管道可以是一个有用的模式。任何适合线性过程风格的数据处理任务都可能是一个很好的匹配。
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about several patterns that can be quite useful
    in application design.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在应用设计中可能非常有用的几种模式。
- en: We started with the singleton type dispatch pattern. Using a command processor
    example, we successfully refactored the code from using if-then-else conditional
    statements to utilizing dynamic dispatch. We learned how to create new singleton
    types using the standard `Val` type or rolling our own parametric type.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从单例类型分发模式开始。通过使用命令处理器示例，我们成功地将代码重构为从使用 if-then-else 条件语句到利用动态分发的形式。我们学习了如何使用标准的
    `Val` 类型或自己实现参数化类型来创建新的单例类型。
- en: Then, we switched gears and discussed how to implement automated testing effectively
    using the stubbing/mocking pattern. We took a simple use case of a credit approval
    process and experimented with a simple way to inject stubs using keyword arguments.
    We weren't very satisfied with the need to change the API for testing, so we leaned
    on the Mocking package for a more seamless approach. We then learned how to replace
    function calls with stubs and mocks in our test suite and how they work differently.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转换了话题，讨论了如何有效地使用存根/模拟模式来实现自动化测试。我们以一个简单的信用审批流程为例，并尝试了一种简单的方法来使用关键字参数注入存根。我们对需要更改
    API 以进行测试的需求并不满意，因此我们依赖于 Mocking 包来实现更流畅的方法。然后我们学习了如何在测试套件中用存根和模拟替换函数调用，以及它们如何不同工作。
- en: Finally, we learned about the functional pipes pattern and how it can make the
    code easier to read and follow. We learned about composability and how the compose
    operator works similarly to the pipe operator. We went over how to develop efficient
    code using functional pipes and broadcasting. Finally, we discussed the pros and
    cons of using functional pipes and other related considerations.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了功能管道模式以及它如何使代码更容易阅读和跟踪。我们学习了组合性以及组合操作符如何与管道操作符类似工作。我们讨论了如何使用功能管道和广播来开发高效的代码。最后，我们讨论了使用功能管道的优缺点以及其他相关考虑因素。
- en: In the next chapter, we will turn around and look at some anti-patterns of Julia
    programming.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转过头来探讨一些 Julia 编程的反模式。
- en: Questions
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What predefined data type can be used to conveniently create new singleton types?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用什么预定义的数据类型方便地创建新的单例类型？
- en: What are the benefits of using singleton type dispatch?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单例类型分发的优点是什么？
- en: Why do we want to create stubs?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要创建存根？
- en: What is the difference between mocking and stubbing?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟和存根之间的区别是什么？
- en: What does composability mean?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合性意味着什么？
- en: What is the primary constraint of using functional pipes?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用功能管道的主要约束是什么？
- en: How are functional pipes useful?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式管道有什么用途？
