- en: Get Closer to Your Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贴近您的数据
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Data manipulation with Python
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行数据处理
- en: Analyzing, visualizing, and treating missing values
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析、可视化和处理缺失值
- en: Exploratory data analysis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索性数据分析
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this book, we will cover various ensemble techniques and will learn how to
    ensemble multiple machine learning algorithms to enhance a model's performance.
    We will use pandas, NumPy, scikit-learn, and Matplotlib, all of which were built
    for working with Python, as we will do throughout the book. By now, you should be
    well aware of data manipulation and exploration.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将介绍各种集成技术，并学习如何集成多个机器学习算法以增强模型性能。我们将使用pandas、NumPy、scikit-learn和Matplotlib，这些都是为与Python一起使用而构建的，正如我们将在整本书中做的那样。到目前为止，你应该已经非常熟悉数据处理和探索。
- en: In this chapter, we will recap how to read and manipulate data in Python, how
    to analyze and treat missing values, and how to explore data to gain deeper insights. We
    will use various Python packages, such as `numpy` and `pandas`, for data manipulation
    and exploration, and `seaborn` packages for data visualization. We will continue
    to use some or all of these libraries in the later chapters of this book as well.
    We will also use the Anaconda distribution for our Python coding. If you have
    not installed Anaconda, you need to download it from [https://www.anaconda.com/download](https://www.anaconda.com/download/#macos).
    At the time of writing this book, the latest version of Anaconda is 5.2, and comes
    with both Python 3.6 and Python 2.7\. We suggest you download Anaconda for Python
    3.6\. We will also use the `HousePrices` dataset, which is available on GitHub.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾如何在Python中读取和处理数据，如何分析和处理缺失值，以及如何探索数据以获得更深入的见解。我们将使用各种Python包，如`numpy`和`pandas`，用于数据操作和探索，以及`seaborn`包用于数据可视化。我们将在本书的后续章节中也继续使用这些库中的某些或全部库。我们还将使用Anaconda发行版进行我们的Python编码。如果您尚未安装Anaconda，您需要从[https://www.anaconda.com/download](https://www.anaconda.com/download/#macos)下载它。在撰写本书时，Anaconda的最新版本是5.2，它包含Python
    3.6和Python 2.7。我们建议您下载Python 3.6的Anaconda。我们还将使用可在GitHub上找到的`HousePrices`数据集。
- en: Data manipulation with Python
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行数据处理
- en: In real life, it is often hard to get a complete and clean dataset formatted
    exactly as we need it. The data we receive often cannot be directly used in statistical
    or machine learning algorithms. We need to manipulate the raw data so that the
    processed data can be used for further analysis and modelling purposes. To begin
    with, we need to import the required packages, such as `pandas`, and read our
    dataset into Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，往往很难获得一个完整且干净的数据集，其格式正好符合我们的需求。我们接收到的数据通常不能直接用于统计或机器学习算法。我们需要处理原始数据，以便处理后的数据可以用于进一步分析和建模。首先，我们需要导入所需的包，例如`pandas`，并将我们的数据集读入Python。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the `os` package in the operating system's dependent functionality,
    and the `pandas` package for data manipulation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用操作系统的依赖功能中的`os`包，以及用于数据处理的`pandas`包。
- en: 'Let''s now take a look at the data definitions to understand our variables.
    In the following code, we list the data definition for a few variables. The dataset
    and the complete data definitions are available on GitHub. Here is an abridged
    version of the data description file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看数据定义以了解我们的变量。在下面的代码中，我们列出了一些变量的数据定义。数据集和完整的数据定义可在GitHub上找到。以下是数据描述文件的简略版本：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will then import the `os` and `pandas` packages and set our working directory
    according to our requirements, as seen in the following code block:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将导入`os`和`pandas`包，并根据我们的要求设置我们的工作目录，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next step is to download the dataset from GitHub and copy it to your working
    directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从GitHub下载数据集并将其复制到您的当前工作目录。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, let''s perform some data manipulation steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行一些数据处理步骤：
- en: 'First, we will read the data in `HousePrices.csv` from our current working
    directory and create our first DataFrame for manipulation. We name the DataFrame `housepricesdata`,
    as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从当前工作目录读取`HousePrices.csv`数据，并创建我们的第一个用于操作的数据框。我们将其命名为`housepricesdata`，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now take a look at our DataFrame and see how it looks:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看一下我们的数据框，看看它的样子：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You might not be able to see all the rows; Jupyter will truncate some of the
    variables. In order to view all of the rows and columns for any output in Jupyter,
    execute the following commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能看不到所有行；Jupyter将截断一些变量。为了在Jupyter中查看任何输出的所有行和列，请执行以下命令：
- en: '`# Setting options to display all rows and columns`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 设置选项以显示所有行和列`'
- en: '`pd.options.display.max_rows = None`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.options.display.max_rows = None`'
- en: '`pd.options.display.max_columns = None`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.options.display.max_columns = None`'
- en: 'We can see the dimensions of the DataFrame with `shape`. `shape` is an attribute
    of the `pandas` DataFrame:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用`shape`查看DataFrame的维度。`shape`是`pandas` DataFrame的一个属性：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the preceding command, we can see the number of rows and columns, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们可以看到行数和列数，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can see that the DataFrame has `1460` observations and `81` columns.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到DataFrame有`1460`个观测值和`81`个列。
- en: 'Let''s take a look at the datatypes of the variables in the DataFrame:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看DataFrame中变量的数据类型：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the following code block, we can see the datatypes of each variable in the
    DataFrame:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们可以看到DataFrame中每个变量的数据类型：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We're now all ready to start with our data manipulation, which we can do in
    many different ways. In this section, we'll look at a few ways in which we can
    manipulate and prepare our data for the purpose of analysis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好开始数据操作，我们可以以许多不同的方式来完成。在本节中，我们将探讨几种我们可以用来操纵和准备数据以便分析的方法。
- en: Let's start by summarizing our data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先总结一下我们的数据。
- en: 'The `describe()` function will show the statistics for the numerical variables
    only:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`describe()`函数将只显示数值变量的统计信息：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see the output in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的屏幕截图中看到输出：
- en: '![](img/ae71b07f-4ae3-49f4-824c-63a95f2fabd8.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae71b07f-4ae3-49f4-824c-63a95f2fabd8.png)'
- en: 'We will remove the `id` column, as this will not be necessary for our analysis:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将删除`id`列，因为这对于我们的分析将不是必需的：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s now look at the distribution of some of the object type variables, that
    is, the categorical variables. In the following example, we are going to look
    at `LotShape` and `LandContour`. We can study the other categorical variables
    of the dataset in the same way as shown in the following code block:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些对象类型变量（即分类变量）的分布。在下面的示例中，我们将查看`LotShape`和`LandContour`。我们可以以相同的方式研究数据集中的其他分类变量，如下面的代码块所示：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will now see how to perform a conversion between datatypes. What we notice
    is that the data definition of variables such as `MSSubClass`, `OverallQual`,
    and `OverallCond` are all categorical variables. After importing the dataset,
    however, they appear as integers.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将看到如何在不同数据类型之间进行转换。我们注意到变量如`MSSubClass`、`OverallQual`和`OverallCond`的数据定义都是分类变量。然而，在导入数据集之后，它们却显示为整数。
- en: Prior to typecasting any variable, ensure that there are no missing values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在对任何变量进行类型转换之前，请确保没有缺失值。
- en: 'Here, we''ll convert the variables to a categorical datatype:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将变量转换为分类数据类型：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see the count of observations for each category of houses, as shown
    in the following code block:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每种房屋类别的观测值数量，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are many variables that might not be very useful by themselves, but transforming
    them gives us a lot of interesting insights. Let's create some new, meaningful
    variables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多变量单独可能并不很有用，但转换它们会给我们带来很多有趣的见解。让我们创建一些新的、有意义的变量。
- en: '`YearBuilt` and `YearRemodAdd` represent the original construction date and
    the remodel date respectively. However, if they can be converted into age, these
    variables will tell us how old the buildings are and how many years it has been
    since they were remodeled. To do this, we create two new variables, `BuildingAge`
    and `RemodelAge`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`YearBuilt`和`YearRemodAdd`分别代表原始建筑日期和翻修日期。然而，如果它们可以被转换为年龄，这些变量将告诉我们建筑物的年龄以及它们翻修以来的年数。为此，我们创建了两个新的变量，`BuildingAge`和`RemodelAge`：'
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s add the two variables to our dataset:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这两个变量添加到我们的数据集中：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We notice that `building_age` and `remodelled_age` are now added to the DataFrame,
    as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`building_age`和`remodelled_age`现在已添加到DataFrame中，如下面的屏幕截图所示：
- en: '![](img/9a775483-e117-482a-9a06-ca71ada35476.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a775483-e117-482a-9a06-ca71ada35476.png)'
- en: Variables that contain label data need to be converted into a numerical form
    for machine learning algorithms to use. To get around this, we will perform encoding
    that will transform the labels into numerical forms so that the algorithms can
    use them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 包含标签数据的变量需要转换为数值形式，以便机器学习算法可以使用。为了解决这个问题，我们将执行编码，将标签转换为数值形式，以便算法可以使用它们。
- en: 'We need to identify the variables that need encoding, which include `Street`,
    `LotShape`, and `LandContour`. We will perform one-hot encoding, which is a representation
    of categorical variables as binary vectors. We will use the `pandas` package in
    Python to do this:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要识别需要编码的变量，包括`Street`、`LotShape`和`LandContour`。我们将执行独热编码，这是一种将分类变量表示为二进制向量的方法。我们将使用Python中的`pandas`包来完成此操作：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can see the one-hot encoded variables that have been created in the following
    screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图中看到已创建的独热编码变量：
- en: '![](img/394c838b-dc90-47d9-9e03-9676cca5c3c2.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/394c838b-dc90-47d9-9e03-9676cca5c3c2.png)'
- en: 'Add the one-hot encoded variables to our DataFrame, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将独热编码变量添加到我们的DataFrame中，如下所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can see the output that we get after adding the one-hot encoded variables
    to the DataFrame in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下屏幕截图中看到将独热编码变量添加到DataFrame后的输出：
- en: '![](img/62732d2d-f5c0-4382-8ab2-7a6820ab2193.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62732d2d-f5c0-4382-8ab2-7a6820ab2193.png)'
- en: 'Now, let''s remove the original variables since we have already created our
    one-hot encoded variables:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们删除原始变量，因为我们已经创建了我们的独热编码变量：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `pandas` module is a part of the Python standard library – it is one of
    the key modules for data manipulation. We have also used other packages, such
    as `os` and `datetime`. After we set our working directory and read the CSV file
    into Python as a `pandas` DataFrame, we moved on to looking at a few data manipulation
    methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`模块是Python标准库的一部分——它是数据操作的关键模块之一。我们还使用了其他包，如`os`和`datetime`。在设置我们的工作目录并将CSV文件作为`pandas`
    DataFrame读取到Python中之后，我们继续查看一些数据操作方法。'
- en: '*Step 1* to *Step 5* in the preceding section showed us how to read the data
    from a CSV file in Python using `pandas`, and also how to use functions such as `dtypes`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的*步骤 1*至*步骤 5*展示了如何使用`pandas`在Python中读取CSV文件中的数据，以及如何使用`dtypes`等函数。
- en: The `pandas` package also provides methods for reading data from various file
    types. For example, `pandas.read_excel()` reads an Excel table into a `pandas`
    DataFrame; `pandas.read_json()` converts a JSON string into a`pandas` object;
    and `pandas.read_parquet()` loads a parquet object from a file path and returns
    the `pandas` DataFrame. More information on this can be found at [https://bit.ly/2yBqtvd](https://bit.ly/2yBqtvd).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`包还提供了从各种文件类型读取数据的方法。例如，`pandas.read_excel()`将Excel表读取到`pandas` DataFrame中；`pandas.read_json()`将JSON字符串转换为`pandas`对象；`pandas.read_parquet()`从文件路径加载parquet对象并返回`pandas`
    DataFrame。更多信息可以在[https://bit.ly/2yBqtvd](https://bit.ly/2yBqtvd)找到。'
- en: 'You can also read HDF5 format files in Python using the `h5py` package. The `h5py` package
    is a Python interface to the HDF5 binary data format. HDF® supports n-dimensional
    datasets, and each element in the dataset may itself be a complex object. There
    is no limit on the number or size of data objects in the collection. More info
    can be found at [https://www.hdfgroup.org/](https://www.hdfgroup.org/). A sample
    code block looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用Python中的`h5py`包读取HDF5格式文件。`h5py`包是Python对HDF5二进制数据格式的接口。HDF®支持多维数据集，数据集中的每个元素本身也可以是一个复杂对象。集合中数据对象的数量或大小没有限制。更多信息可以在[https://www.hdfgroup.org/](https://www.hdfgroup.org/)找到。一个示例代码块如下所示：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We look at the datatypes of the variables, and use `describe()` to see the summary
    statistics for the numerical variables. We need to note that `describe()` works
    only for numerical variables and is intelligent enough to ignore non-numerical
    variables. In *Step 6*, we saw how to look at the count of each level for categorical
    variables such as `LotShape` and `LandContour`. We can use the same code to take
    a look at the distribution of other categorical variables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看变量的数据类型，并使用`describe()`来查看数值变量的摘要统计信息。需要注意的是，`describe()`仅适用于数值变量，并且足够智能，可以忽略非数值变量。在*步骤
    6*中，我们看到了如何查看分类变量（如`LotShape`和`LandContour`）每个级别的计数。我们可以使用相同的代码来查看其他分类变量的分布。
- en: In *Step 7*, we took a look at the distribution of the `LotShape` and `LandContour` variables
    using `pd.crosstab()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 7*中，我们使用`pd.crosstab()`查看`LotShape`和`LandContour`变量的分布。
- en: One common requirement in a crosstab is to include subtotals for the rows and
    the columns. We can display subtotals using the `margins` keyword. We pass `margins=True` to
    the `pd.crosstab()` function. We can also give a name to subtotal columns using
    the `margins_name` keyword. The default value for `margins_name` is `All`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在交叉表中，一个常见的需求是包括行和列的小计。我们可以使用`margins`关键字显示小计。我们将`margins=True`传递给`pd.crosstab()`函数。我们还可以使用`margins_name`关键字给小计列命名。`margins_name`的默认值是`All`。
- en: We then moved on to learning how to convert datatypes. We had a few variables
    that were actually categorical, but appeared to be numerical in the dataset. This
    is often the case in a real-life scenario, hence we need to learn how to typecast
    our variables. *Step 8* showed us how to convert a numerical variable, such as `MSSubClass`,
    into a categorical type. In *Step 8*, we converted a few variables into a categorical
    datatype. We then created a crosstab to visualize the frequencies of each level
    of categorical variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续学习如何转换数据类型。我们有一些实际上是分类变量，但在数据集中看起来是数值型的变量。这在现实生活中很常见，因此我们需要学习如何类型转换我们的变量。*步骤8*展示了如何将数值变量，如`MSSubClass`，转换为分类类型。在*步骤8*中，我们将一些变量转换为分类数据类型。然后我们创建了一个交叉表来可视化分类变量的每个级别的频率。
- en: In *Step 9*, we created new meaningful variables from existing variables. We
    created the new variables, `BuildingAge` and `RemodelAge`, from `YearBuilt` and
    `YearRemodAdd` respectively, to represent the age of the building and the number
    of years that have passed since the buildings were remodeled. This method of creating
    new variables can provide better insights into our analysis and modeling. This
    process of creating new features is called **feature engineering**. In *Step 10*,
    we added the new variables to our DataFrame.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们从现有变量中创建了新的有意义的变量。我们分别从`YearBuilt`和`YearRemodAdd`创建了新的变量`BuildingAge`和`RemodelAge`，以表示建筑物的年龄和自建筑物翻新以来经过的年数。这种方法创建新变量可以为我们分析和建模提供更好的洞察力。创建新特征的过程称为**特征工程**。在*步骤10*中，我们将新变量添加到我们的DataFrame中。
- en: From there, we moved on to encoding our categorical variables. We needed to
    encode our categorical variables because they have named descriptions. Many machine
    learning algorithms cannot operate on labelled data because they require all input
    and output variables to be numeric. In *Step 12*, we encoded them with one-hot
    encoding. In *Step 11*, we learned how to use the `get_dummies()` function, which
    is a part of the `pandas` package, to create the one-hot encoded variables. In
    *Step 12*, we added the `one-hot_encoded_variables` to our DataFrame. And finally,
    in *Step 13*, we removed the original variables that are now one-hot encoded.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们继续学习如何对分类变量进行编码。我们需要对分类变量进行编码，因为它们有命名描述。许多机器学习算法不能在标记数据上操作，因为它们需要所有输入和输出变量都是数值型的。在*步骤12*中，我们使用独热编码对它们进行了编码。在*步骤11*中，我们学习了如何使用`get_dummies()`函数，它是`pandas`包的一部分，来创建独热编码变量。在*步骤12*中，我们将`one-hot_encoded_variables`添加到我们的DataFrame中。最后，在*步骤13*中，我们移除了现在已独热编码的原始变量。
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The types of data manipulation required depend on your business requirements.
    In this first recipe, we saw a few ways to carry out data manipulation, but there
    is no limit to what you can do and how you can manipulate data for analysis.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的数据操作类型取决于您的业务需求。在这个第一个菜谱中，我们看到了几种执行数据操作的方法，但您能做的事情以及如何为分析操作数据没有限制。
- en: 'We have also seen how to convert a numerical variable into a categorical variable.
    We can do this kind of typecasting in many ways. For example, we can convert a
    categorical variable into a numerical variable, if required, with the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了如何将数值变量转换为分类变量。我们可以以多种方式执行此类类型转换。例如，如果需要，我们可以使用以下代码将分类变量转换为数值变量：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can only convert the `GarageYrBlt` variable if it does not contain any missing
    values. The preceding code will throw an error, since `GarageYrBlt` contains missing
    values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`GarageYrBlt`变量不包含任何缺失值时，才能转换该变量。前面的代码将引发错误，因为`GarageYrBlt`包含缺失值。
- en: 'We have looked at how we can use one-hot encoding to convert categorical variables
    to numerical variables, and why we do this. In addition to one-hot encoding, we
    can perform other kinds of encoding, such as label encoding, frequency encoding,
    and so on. An example code for label encoding is given in the following code block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何使用一热编码将分类变量转换为数值变量，以及为什么我们要这样做。除了 一热编码，我们还可以执行其他类型的编码，例如标签编码、频率编码等等。以下代码块提供了一个标签编码的示例代码：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考内容
- en: The pandas guide to type conversion functions ([https://bit.ly/2MzFwiG](https://bit.ly/2MzFwiG))
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pandas 类型转换函数指南([https://bit.ly/2MzFwiG](https://bit.ly/2MzFwiG))
- en: The pandas guide to one-hot encoding using `get_dummies()` ([https://bit.ly/2N1xjTZ](https://bit.ly/2N1xjTZ))
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `get_dummies()` 进行一热编码的 pandas 指南([https://bit.ly/2N1xjTZ](https://bit.ly/2N1xjTZ))
- en: The scikit-learn guide to one-hot encoding ([https://bit.ly/2wrNNLz](https://bit.ly/2wrNNLz))
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[scikit-learn 的一热编码指南](https://bit.ly/2wrNNLz)'
- en: The scikit-learn guide to label encoding ([https://bit.ly/2pDddVb](https://bit.ly/2pDddVb))
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scikit-learn 标签编码指南([https://bit.ly/2pDddVb](https://bit.ly/2pDddVb))
- en: Analyzing, visualizing, and treating missing values
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析、可视化和处理缺失值
- en: Missing values are caused by incomplete data. It is important to handle missing
    values effectively, as they can lead to inaccurate inferences and conclusions. In
    this section, we will look at how to analyze, visualize, and treat missing values.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失值是由不完整的数据引起的。有效地处理缺失值非常重要，因为它们可能导致不准确的推断和结论。在本节中，我们将探讨如何分析、可视化和处理缺失值。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start by analyzing variables with missing values. Set the options in
    pandas to view all rows and columns, as shown in the previous section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分析带有缺失值的变量开始。将 pandas 的选项设置为显示所有行和列，如前一小节所示：
- en: 'With the following syntax, we can see which variables have missing values:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下语法，我们可以看到哪些变量有缺失值：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will produce the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/9acdec10-9936-422f-9b64-e31b4d337ac2.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9acdec10-9936-422f-9b64-e31b4d337ac2.png)'
- en: 'You might also like to see the missing values in terms of percentages. To see
    the count and percentage of missing values, execute the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还想以百分比的形式查看缺失值。要查看缺失值的计数和百分比，请执行以下命令：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It will show you the missing values in both absolute and percentage terms,
    as shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它将以绝对值和百分比的形式显示缺失值，如下面的截图所示：
- en: '![](img/56aadd15-3792-4bd6-af6b-8494ad2e1288.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56aadd15-3792-4bd6-af6b-8494ad2e1288.png)'
- en: We notice that variables such as **Alley**, **PoolQC**, **Fence**, and **MiscFeature**
    have **80%** to **90%** of their values missing. **FireplaceQu** has **47.26%**
    of its values missing. A few other variables, such as **LotFrontage**, **MasVnrType**,
    **MasVnrArea**, **BsmtQual**, **BsmtCond**, and a few more Garage-related variables
    have missing values as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，例如 **Alley**、**PoolQC**、**Fence** 和 **MiscFeature** 等变量有 **80%** 到 **90%**
    的值是缺失的。**FireplaceQu** 有 **47.26%** 的值是缺失的。还有一些其他变量，如 **LotFrontage**、**MasVnrType**、**MasVnrArea**、**BsmtQual**、**BsmtCond**
    以及一些与车库相关的变量也有缺失值。
- en: 'But there is a catch. Let''s look at the `Alley` variable again. It shows us
    that it has **93.76%** missing values. Now take another look at the data description
    that we looked at in the preceding section. The variable description for `Alley`
    shows that it has three levels: *gravel*, *paved*, and *no access*. In the original
    dataset, `''No Access''` is codified as `NA`. When `NA` is read in Python, it
    is treated as **NaN**, which means that a value is missing, so we need to be careful.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个问题。让我们再次看看 `Alley` 变量。它显示它有 **93.76%** 的缺失值。现在，再看看前一小节中我们查看的数据描述。`Alley`
    的变量描述显示它有三个级别：*砾石*、*铺路*和*无通道*。在原始数据集中，`'No Access'` 被编码为 `NA`。当 `NA` 在 Python
    中读取时，它被视为 **NaN**，这意味着缺失了一个值，因此我们需要小心处理。
- en: 'Now, we will replace the missing values for `Alley` with a valid value, such
    as `''No Access''`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将用有效值，如 `'No Access'` 替换 `Alley` 的缺失值：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s visualize the missing values and try to see how can we treat them. The following
    code generates a chart that showcases the spread of missing values. Here we use
    the `seaborn` library to plot the charts:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们可视化缺失值并尝试了解如何处理它们。以下代码生成一个图表，展示了缺失值的分布。在这里，我们使用 `seaborn` 库来绘制图表：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The color of the map is generated with linearly increasing brightness by the
    `cubehelix_palette()` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的颜色是通过 `cubehelix_palette()` 函数以线性增加的亮度生成的：
- en: '![](img/fce12232-d35b-4808-a677-f6aa0a48a877.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fce12232-d35b-4808-a677-f6aa0a48a877.png)'
- en: From the preceding plot, it is easier to read the spread of the missing values.
    The white marks on the chart indicate missing values. Notice that `Alley` no longer
    reports any missing values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，更容易读取缺失值的分布。图表上的白色标记表示缺失值。请注意，`Alley`不再报告任何缺失值。
- en: '`LotFrontage` is a continuous variable and has **17.74%** of its values missing.
    Replace the missing values in this variable with its median as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LotFrontage`是一个连续变量，其**17.74%**的值是缺失的。按照以下方式用该变量的中位数替换缺失值：'
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s view the missing value plot once again to see if the missing values
    from `LotFrontage` have been imputed. Copy and execute the preceding code. The
    missing value plot will look as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次查看缺失值图，以查看`LotFrontage`中的缺失值是否已填充。复制并执行前面的代码。缺失值图将如下所示：
- en: '![](img/3fee1f9b-cda4-48f0-acaf-6dddba9faf97.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fee1f9b-cda4-48f0-acaf-6dddba9faf97.png)'
- en: Here, we can see in the preceding plot that there are no more missing values
    for `Alley` or `LotFrontage`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在先前的图表中，`Alley`或`LotFrontage`不再有缺失值。
- en: 'We have figured out from the data description that several variables have values
    that are codified as `NA`. Because this is read in Python as missing values, we
    replace all of these with their actual values, which we get to see in the data
    description shown in the following code block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据描述中，我们发现几个变量的值被编码为`NA`。因为这在Python中被读取为缺失值，所以我们用它们的实际值替换所有这些值，这些值可以在以下代码块中看到的数据描述中看到：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s take a look at the missing value plot after having treated the preceding variables:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一下处理了前面的变量之后的缺失值图：
- en: '![](img/e0321ab2-6f0f-4f91-9157-699fdae69fed.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0321ab2-6f0f-4f91-9157-699fdae69fed.png)'
- en: We notice from the preceding plot that there are no more missing values for
    the variables that we have just treated. However, we are left with a few missing
    values in `MasVnrType`, `MasVnrArea`, and `Electrical`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们注意到我们刚刚处理的变量中不再有缺失值。然而，我们在`MasVnrType`、`MasVnrArea`和`Electrical`中还有一些缺失值。
- en: 'Let''s try to look at the distribution of `MasVnrType` by `MasVnrArea` with
    a crosstab:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用交叉表查看`MasVnrType`按`MasVnrArea`的分布：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following output shows that when `MasVnrArea` is zero, we have `MasVnrType`
    as `None` in the majority of cases:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示，当`MasVnrArea`为零时，大多数情况下`MasVnrType`为`None`：
- en: '![](img/a65a465b-030d-4368-8a76-e1c0e6b36702.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a65a465b-030d-4368-8a76-e1c0e6b36702.png)'
- en: 'We will then impute the missing values in `MasVnrType` with `None` and `MasVnrArea`
    with zero. This is done with the commands shown in the following code block:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下代码块中的命令将`MasVnrType`中的缺失值用`None`填充，将`MasVnrArea`用零填充。
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are still left with one missing value in the `Electrical` variable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Electrical`变量中仍然有一个缺失值。
- en: 'Let''s take a look at the observation where `Electrical` has a missing value:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一下`Electrical`有缺失值的观测值：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/9dbf6447-f753-49e3-8e0a-7a674d0c92d4.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dbf6447-f753-49e3-8e0a-7a674d0c92d4.png)'
- en: 'We see that `MSSubClass` is `80` when `Electrical` is null. Let''s see the
    distribution of the `Electrical` type by `MSSubClass`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Electrical`为空时，我们看到`MSSubClass`是`80`。让我们看看`Electrical`类型的分布情况，按`MSSubClass`分类：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'From the following output, we can see that when `MSSubClass` is `80`, the majority of
    cases of the `Electrical` type are `SBrkr`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中，我们可以看到当`MSSubClass`为`80`时，大多数`Electrical`类型的案例都是`SBrkr`：
- en: '![](img/ba143935-687a-420c-955c-06f40a4920d6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba143935-687a-420c-955c-06f40a4920d6.png)'
- en: 'Go ahead and impute the missing value in the `Electrical` variable with `SBrKr` by
    executing the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，接下来请使用以下代码执行，将`Electrical`变量中的缺失值用`SBrKr`进行填充：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After this, let''s take a look at our missing value plot for a final time:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们再次查看我们的缺失值图，作为最后的检查：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output we get can be seen in the following chart:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出可以在以下图表中查看：
- en: '![](img/ce0bfa9e-4173-4621-9497-9242509f5889.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce0bfa9e-4173-4621-9497-9242509f5889.png)'
- en: Notice that the plot has changed and now shows no missing values in our DataFrame.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到图表已经改变，现在显示我们的DataFrame中没有缺失值。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Step 1 *and *Step **2*, we looked at the variables with missing values in
    absolute and percentage terms. We noticed that the `Alley` variable had more than
    **93%** of its values missing. However, from the data description, we figured
    out that the `Alley` variable had a **No Access to Alley **value, which is codified
    as `NA` in the dataset. When this value was read in Python, all instances of `NA`
    were treated as missing values. In *Step 3*, we replaced the `NA` in `Alley` with
    `No Access`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**和**步骤 2**中，我们以绝对和百分比的形式查看具有缺失值的变量。我们注意到 `Alley` 变量有超过 **93%** 的值是缺失的。然而，从数据描述中，我们了解到
    `Alley` 变量有一个 **无通道入口** 的值，在数据集中编码为 `NA`。当这个值在 Python 中读取时，所有的 `NA` 实例都被视为缺失值。在**步骤
    3**中，我们将 `Alley` 中的 `NA` 替换为 `No Access`。
- en: Note that we used `%matplotlib inline` in *Step 2*. This is a magic function
    that renders the plot in the notebook itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在**步骤 2**中使用了 `%matplotlib inline`。这是一个魔法函数，可以在笔记本本身中渲染图表。
- en: In *Step 4*, we used the `seaborn` library to plot the missing value chart.
    In this chart, we identified the variables that had missing values. The missing
    values were denoted in white, while the presence of data was denoted in color.
    We noticed from the chart that `Alley` had no more missing values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 4**中，我们使用了 `seaborn` 库来绘制缺失值图表。在这个图表中，我们识别了具有缺失值的变量。缺失值用白色表示，而数据的出现用颜色表示。我们从图表中注意到
    `Alley` 没有更多的缺失值。
- en: In *Step 4*, we used `cubehelix_palette()` from the `seaborn` library,  which produces
    a color map with linearly decreasing (or increasing) brightness. The `seaborn`
    library also provides us with options including `light_palette()` and `dark_palette()`.
    `light_palette()` gives a sequential palette that blends from light to color,
    while `dark_palette()` produces a sequential palette that blends from dark to
    color.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 4**中，我们使用了来自 `seaborn` 库的 `cubehelix_palette()` 函数，它生成一个线性减少（或增加）亮度的颜色图。`seaborn`
    库还为我们提供了包括 `light_palette()` 和 `dark_palette()` 在内的选项。`light_palette()` 提供了一个从浅色到颜色的顺序调色板，而
    `dark_palette()` 则生成一个从深色到颜色的顺序调色板。
- en: In *Step 5*, we noticed that one of the numerical variables, `LotFrontage`,
    had more than **17%** of its values missing. We decided to impute the missing
    values with the median of this variable. We revisited the missing value chart
    in *Step 6* to see whether the variables were left with any missing values. We
    noticed that `Alley` and `LotFrontage` showed no white marks, indicating that
    neither of the two variables had any further missing values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 5**中，我们发现一个数值变量 `LotFrontage` 的超过 **17%** 的值是缺失的。我们决定用这个变量的中位数来填充缺失值。我们在**步骤
    6**中重新访问了缺失值图表，看看是否还有变量有缺失值。我们注意到 `Alley` 和 `LotFrontage` 没有任何白色标记，这表明这两个变量都没有进一步的缺失值。
- en: In *Step 7*, we identified a handful of variables that had data codified with
    `NA`. This caused the same problem we encountered previously, as Python treated
    them as missing values. We replaced all such codified values with actual information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 7**中，我们确定了一些用 `NA` 编码的数据变量。这导致了我们之前遇到的问题，因为 Python 将它们视为缺失值。我们将所有这样的编码值替换为实际信息。
- en: We then revisited the missing value chart in *Step 8*. We saw that almost all
    the variables then had no missing values, except for `MasVnrType`, `MasVnrArea`,
    and `Electrical`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在**步骤 8**中重新访问了缺失值图表。我们看到当时几乎所有的变量都没有缺失值，除了 `MasVnrType`、`MasVnrArea` 和
    `Electrical`。
- en: In *Step 9* and *10*, we filled in the missing values for the `MasVnrType` and
    `MasVnrArea` variables. We noticed that `MasVnrType` is `None` whenever `MasVnrArea`
    is `0.0`, except for some rare occasions. So, we imputed the `MasVnrType` variable
    with `None`, and `MasVnrArea` with `0.0` wherever those two variables had missing
    values. We were then only left with one variable with missing values, `Electrical`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 9**和**步骤 10**中，我们填充了 `MasVnrType` 和 `MasVnrArea` 变量的缺失值。我们注意到，当 `MasVnrArea`
    为 `0.0` 时，`MasVnrType` 总是 `None`，除了少数罕见情况。因此，我们在两个变量有缺失值的地方用 `None` 填充 `MasVnrType`，用
    `0.0` 填充 `MasVnrArea`。这样我们就只剩下一个有缺失值的变量，即 `Electrical`。
- en: In *Step 11*, we looked at what type of house was missing the `Electrical` value. We
    noticed that `MSSubClass` denoted the dwelling type and, for the missing `Electrical `value,
    the `MSSubClass` was `80`, which meant it was split or multi-level. In *Step 12*,
    we checked the distribution of `Electrical` by the dwelling type, which was `MSSubClass`.
    We noticed that when `MSSubClass` equals `80`, the majority of the values of `Electrical`
    are `SBrkr`, which stands for standard circuit breakers and Romex. For this reason,
    we decided to impute the missing value in `Electrical` with `SBrkr`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*中，我们查看哪种类型的房屋缺失了`Electrical`值。我们注意到`MSSubClass`表示住宅类型，对于缺失的`Electrical`值，`MSSubClass`为`80`，这意味着它是分割的或多层。在*步骤12*中，我们检查了`Electrical`值的分布，该分布是按住宅类型`MSSubClass`进行的。我们注意到当`MSSubClass`等于`80`时，`Electrical`的大多数值是`SBrkr`，这代表标准断路器和Romex。因此，我们决定用`SBrkr`来填补`Electrical`中的缺失值。
- en: Finally, in *Step 14*, we again revisited the missing value chart and saw that
    there were no more missing values in the dataset.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤14*中，我们再次回顾了缺失值图表，并看到数据集中没有更多的缺失值。
- en: There's more...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Using the preceding plots and missing value charts, it was easy to figure out
    the count, percentage, and spread of missing values in the datasets. We noticed
    that many variables had missing values for the same observations. However, after
    consulting the data description, we saw that most of the missing values were actually
    not missing, but since they were codified as `NA`, pandas treated them as missing
    values.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面的图表和缺失值图表，我们很容易地确定了数据集中缺失值的数量、百分比和分布。我们注意到许多变量对于相同的观测值都有缺失值。然而，在查阅数据描述后，我们发现大多数缺失值实际上并不是缺失的，但由于它们被编码为`NA`，pandas将其视为缺失值。
- en: It is very important for data analysts to understand data descriptions and treat
    the missing values appropriately.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据分析师来说，理解数据描述并适当处理缺失值非常重要。
- en: 'Usually, missing data is categorized into three categories:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，缺失数据可以分为三类：
- en: '**Missing completely at random** (**MCAR**): MCAR denotes that the missing
    values have nothing to do with the object being studied. In other words, data
    is MCAR when the probability of missing data on a variable is not related to other
    measured variables or to the values themselves. An example of this could be, for
    instance, the age of certain respondents to a survey not being recorded, purely
    by chance.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全随机缺失**（**MCAR**）：MCAR表示缺失值与被研究的对象无关。换句话说，当变量缺失数据的概率与其他测量变量或其自身值无关时，数据就是MCAR。例如，某些受访者调查的年龄未记录，纯粹是偶然的。'
- en: '**Missing at random** (**MAR**): The name MAR is a little misleading here because
    the absence of values is not random in this case. Data is MAR if its absence is
    related to other observed variables, but not to the underlying values of the data
    itself. For example, when we collect data from customers, rich customers are less
    likely to disclose their income than their other counterparts, resulting in MAR
    data.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机缺失**（**MAR**）：在这里，MAR的名字有点误导，因为在这种情况下，值的缺失并不是随机的。如果数据的缺失与观察到的其他变量有关，但与数据的潜在值无关，则数据是MAR。例如，当我们从客户那里收集数据时，富裕的客户比其他客户更不愿意披露他们的收入，从而导致MAR数据。'
- en: '**Missing not at random** (**MNAR**): Data is MNAR, also known as **non-ignorable** if
    it can''t be classified as MCAR nor MAR. For example, perhaps some consumers don''t
    want to share their age when it is above 40 because they would like to hide it.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非随机缺失**（**MNAR**）：如果数据不能被归类为MCAR或MAR，则数据是MNAR，也称为**不可忽略的**。例如，也许一些消费者在年龄超过40岁时不想分享他们的年龄，因为他们想隐藏它。'
- en: 'There are various strategies that can be applied to impute the missing values,
    as listed here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用多种策略来填补缺失值，如下所示：
- en: Source the missing data
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取缺失数据
- en: Leave out incomplete observations
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 留出不完整的观测值
- en: Replace missing data with an estimate, such as a mean or a median
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用估计值替换缺失数据，例如均值或中位数
- en: Estimate the missing data from other variables in the dataset
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据集中的其他变量估计缺失数据
- en: See also
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The scikit-learn module for imputation ([https://bit.ly/2MzFwiG](https://bit.ly/2MzFwiG))
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于插补的scikit-learn模块（[https://bit.ly/2MzFwiG](https://bit.ly/2MzFwiG)）
- en: Multiple imputation by chained equations using the `StatsModels` library in
    Python ([https://bit.ly/2PYLuYy](https://bit.ly/2PYLuYy))
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python中的`StatsModels`库进行链式方程的多次插补（[https://bit.ly/2PYLuYy](https://bit.ly/2PYLuYy)）
- en: Feature imputation algorithms using fancyimpute ([https://bit.ly/2MJKfOY](https://bit.ly/2MJKfOY))
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fancyimpute的特徵填充算法（[https://bit.ly/2MJKfOY](https://bit.ly/2MJKfOY)）
- en: Exploratory data analysis
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索性数据分析
- en: We will continue from where we left off in the previous section, on analyzing
    and treating missing values. Data scientists spend the majority of their time
    doing data preparation and exploration, not model building and optimization. Now
    that our dataset has no missing values, we can proceed with our exploratory data
    analysis.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在上一节中留下的地方，即分析和处理缺失值。数据科学家的大部分时间都花在数据准备和探索上，而不是模型构建和优化。现在我们的数据集中没有缺失值，我们可以继续进行探索性数据分析。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the first section on data manipulation, we saw the summary statistics for
    our datasets. However, we have not looked at this since imputing the missing values.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据处理的第一节中，我们看到了数据集的摘要统计信息。然而，自从填充缺失值以来，我们还没有查看过这些信息。
- en: 'Let''s now look at the data and its basic statistics using the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下代码查看数据和其基本统计信息：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With the preceding code, we can see the summary statistics of the variables
    in the earlier section.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们可以看到之前章节中变量的摘要统计信息。
- en: 'Now let''s see how many columns there are by datatype:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看有多少列按数据类型划分：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code shows us how many variables there are for each datatype.
    We can see that we have 3 float-type variables, 33 integer-type variables, 45
    object-type variables, and 4 unsigned integers that hold the one-hot encoded values
    for the `LotShape` variable:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了每种数据类型有多少变量。我们可以看到，我们有3个浮点型变量，33个整型变量，45个对象型变量，以及4个无符号整数，它们存储了`LotShape`变量的单热编码值：
- en: '![](img/90ebfe78-e84f-406b-9455-c774e6817f53.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90ebfe78-e84f-406b-9455-c774e6817f53.png)'
- en: 'Let''s create two variables to hold the names of the numerical and categorical
    variables:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建两个变量来存储数值和分类变量的名称：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This shows us the amount of numerical and categorical variables there are:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了数值和分类变量的数量：
- en: '![](img/a2029e24-dcf1-403a-b0f3-11f5a2444dfe.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2029e24-dcf1-403a-b0f3-11f5a2444dfe.png)'
- en: 'We will now use the `numerical_features` variable that we previously created
    to see the distributions of numerical variables. We will use the `seaborn` library
    to plot our charts:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用之前创建的`numerical_features`变量来查看数值变量的分布。我们将使用`seaborn`库来绘制我们的图表：
- en: We use the `melt()` method from pandas to reshape our DataFrame. You may want
    to view the reshaped data after using the `melt()` method to understand how the DataFrame
    is arranged.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用pandas的`melt()`方法来重塑我们的DataFrame。你可能想在使用`melt()`方法后查看重塑后的数据，以了解DataFrame是如何排列的。
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code shows us the univariate distribution of the observations
    of numerical variables using distribution plots:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了使用分布图观察数值变量观测值的单变量分布：
- en: '![](img/e7c5098f-9d3f-4ddd-b430-a60b5a8883c6.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7c5098f-9d3f-4ddd-b430-a60b5a8883c6.png)'
- en: 'Now, we use the `categorical_features` variable to plot the distribution of
    house prices by each categorical variable:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`categorical_features`变量来绘制按每个分类变量划分的房价分布：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In our dataset, we see that various attributes are present that can drive house
    prices. We can try to see the relationship between the attributes and the `SalesPrice`
    variable, which indicates the prices of the houses.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集中，我们看到存在各种属性，这些属性可以推动房价。我们可以尝试查看属性与表示房价的`SalesPrice`变量之间的关系。
- en: 'Let''s see the distribution of the house sale prices by each categorical variable
    in the following plots:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下图表中每个分类变量按房价的分布：
- en: '![](img/f69cc0a0-e586-4c9f-8e8a-74fd2816c47e.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f69cc0a0-e586-4c9f-8e8a-74fd2816c47e.png)'
- en: 'We will now take a look at the correlation matrix for all numerical variables
    using the following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用以下代码查看所有数值变量的相关矩阵：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will give you the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '![](img/1e63dc46-aceb-4074-b6c0-5c5ec3261313.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e63dc46-aceb-4074-b6c0-5c5ec3261313.png)'
- en: It might be tough to view the correlations displayed in the preceding format.
    You might want to take a look at the correlations graphically.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可能很难以先前的格式查看显示的相关性。你可能想通过图形方式查看相关性。
- en: 'We can also view the correlation matrix plot for the numerical variables. In
    order to do this, we use the `numerical_features` variable that we created in
    *Step 3* to hold the names of all the numerical variables:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以查看数值变量的相关矩阵图。为了做到这一点，我们使用在*步骤3*中创建的`numerical_features`变量来存储所有数值变量的名称：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, we used `select_dtypes(include=[np.number])` to create
    the `df_numeric_features` variable. However, in *Step 3*, we used `dtypes[housepricesdata.dtypes
    != "object"].index`. Note that `select_dtypes()` returns a `pandas.DataFrame`,
    whereas `dtypes[].index` returns a `pandas.Index` object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`select_dtypes(include=[np.number])`来创建`df_numeric_features`变量。然而，在*第3步*中，我们使用了`dtypes[housepricesdata.dtypes
    != "object"].index`。请注意，`select_dtypes()`返回一个`pandas.DataFrame`，而`dtypes[].index`返回一个`pandas.Index`对象。
- en: 'We can now visualize the correlation plot as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以如下可视化相关图：
- en: '![](img/43b35176-1948-4674-89e9-07bfac1934cd.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43b35176-1948-4674-89e9-07bfac1934cd.png)'
- en: '`cmap` is a Matplotlib color map object.There are various categories of color
    map, including sequential, diverging, and qualitative. Among the sequential colors,
    you may choose to set your `cmap` parameter to `BuPu` or `YlGn`. For qualitative
    colors, you can set it to values such as `Set3`, `Pastel2`, and so on. More information
    on color options can be found at [https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmap`是Matplotlib颜色映射对象。颜色映射有多种类别，包括顺序、发散和定性。在顺序颜色中，您可以选择将`cmap`参数设置为`BuPu`或`YlGn`。对于定性颜色，您可以设置为`Set3`、`Pastel2`等值。有关颜色选项的更多信息，请参阅[https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html)。'
- en: 'You may also want to evaluate the correlation of your numerical variables with
    `SalePrice` to see how these numerical variables are related to the prices of
    the houses:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还想评估您的数值变量与`SalePrice`的相关性，以了解这些数值变量与房价之间的关系：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following screenshot shows us the correlation plots. Here, we plot the
    correlation between each of the numerical variables and `SalePrice`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了相关图。在这里，我们绘制了每个数值变量与`SalePrice`之间的相关性：
- en: '![](img/6a52456a-94c6-48ac-a721-8808c27fbaff.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6a52456a-94c6-48ac-a721-8808c27fbaff.png)'
- en: 'If you want to evaluate the correlation of your numerical variables with the
    sale prices of the houses numerically, you can use the following commands:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想数值地评估您的数值变量与房价的相关性，可以使用以下命令：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can view the correlation output sorted in a descending manner in the following
    table:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下表格中按降序查看相关输出：
- en: '![](img/ed9ccd39-d221-4fd8-b335-5dd28ab8cee9.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed9ccd39-d221-4fd8-b335-5dd28ab8cee9.png)'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Step 1*, we started by reading and describing our data. This step provided
    us with summary statistics for our dataset. We looked at the number of variables
    for each datatype in *Step 2*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1步*中，我们首先读取并描述了我们的数据。这一步为我们提供了数据集的摘要统计信息。我们在*第2步*中查看每种数据类型的变量数量。
- en: In *Step 3*, we created two variables, namely, `numerical_features` and `categorical_features`,
    to hold the names of numerical and categorical variables respectively. We used
    these two variables in the steps when we worked with numerical and categorical
    features separately.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3步*中，我们创建了两个变量，即`numerical_features`和`categorical_features`，分别用于存储数值变量和分类变量的名称。当我们分别处理数值和分类特征时，我们使用了这两个变量。
- en: In *Step *4 and *Step *5, we used the `seaborn` library to plot our charts.
    We also introduced the `melt()` function from pandas, which can be used to reshape
    our DataFrame and feed it to the `FacetGrid()` function of the `seaborn` library.
    Here, we showed how you can paint the distribution plots for all the numerical variables
    in one single go. We also showed you how to use the same `FacetGrid()` function
    to plot the distribution of `SalesPrice` by each categorical variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4步和第5步*中，我们使用了`seaborn`库来绘制我们的图表。我们还介绍了pandas中的`melt()`函数，该函数可以用来重塑我们的DataFrame并将其馈送到`seaborn`库的`FacetGrid()`函数。在这里，我们展示了如何一次性绘制所有数值变量的分布图。我们还展示了如何使用相同的`FacetGrid()`函数来绘制每个分类变量`SalesPrice`的分布。
- en: We generated the correlation matrix in *Step 6* using the `corr()` function
    of the DataFrame object. However, we noticed that with too many variables, the
    display does not make it easy for you to identify the correlations. In *Step 7*,
    we plotted the correlation matrix heatmap by using the `heatmap()` function from
    the `seaborn` library.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第6步*中使用DataFrame对象的`corr()`函数生成了相关矩阵。然而，我们注意到，当变量太多时，显示并不便于您识别相关性。在*第7步*中，我们通过使用`seaborn`库中的`heatmap()`函数绘制了相关矩阵热图。
- en: The `corr()` function computes the pairwise correlation of variables, excluding
    the missing values. The `pearson` method is used as the default for computing
    the correlation. You can also use the `kendall` or `spearman` methods, depending
    on your requirements. More information can be found at [https://bit.ly/2CdXr8n](https://bit.ly/2CdXr8n).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`corr()`函数计算变量的成对相关性，排除缺失值。默认使用`pearson`方法来计算相关性。根据需要，你也可以使用`kendall`或`spearman`方法。更多信息可以在[https://bit.ly/2CdXr8n](https://bit.ly/2CdXr8n)找到。'
- en: In *Step 8*, we saw how the numerical variables correlated with the sale prices
    of houses using a scatter plot matrix. We generated the scatter plot matrix using
    the `regplot()` function from the `seaborn` library. Note that we used a parameter, `fit_reg=False`,
    to remove the regression line from the scatter plots.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 8*中，我们看到了如何使用散点图矩阵来分析数值变量与房价的相关性。我们使用`seaborn`库中的`regplot()`函数生成了散点图矩阵。请注意，我们使用了一个参数`fit_reg=False`来从散点图中移除回归线。
- en: In *Step 9*, we repeated *Step 8* to see the relationship of the numerical variables
    with the sale prices of the houses in a numerical format, instead of scatter plots.
    We also sorted the output in descending order by passing a `[::-1]` argument to
    the `corr()` function.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 9*中，我们重复了*步骤 8*，以数值格式查看数值变量与房价的关系，而不是散点图。我们还通过将`[::-1]`参数传递给`corr()`函数来按降序排序输出。
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We have seen a few ways to explore data, both statistically and visually. There
    are quite a few libraries in Python that you can use to visualize your data. One
    of the most widely used of these is `ggplot`. Before we look at a few commands,
    let's learn how `ggplot` works.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些探索数据的方法，无论是从统计上还是从视觉上。Python中有许多库可以用来可视化数据。其中最广泛使用的是`ggplot`。在我们查看一些命令之前，让我们先了解`ggplot`是如何工作的。
- en: 'There are seven layers of grammatical elements in `ggplot`, out of which, first
    three layers are mandatory:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ggplot`中有七个语法元素层，其中前三层是强制性的：
- en: Data
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Aesthetics
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美学
- en: Geometrics
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何学
- en: Facets
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分面
- en: Statistics
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计
- en: Coordinates
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标
- en: Theme
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: You will often start by providing a dataset to `ggplot()`. Then, you provide
    an aesthetic mapping with the `aes()` function to map the variables to the *x *and
    *y* axes. With `aes()`, you can also set the color, size, shape, and position of
    the charts. You then add the type of geometric shape you want with functions such
    as `geom_point()` or `geom_histogram()`. You can also add various options, such
    as plotting statistical summaries, faceting, visual themes, and coordinate systems.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会先提供一个数据集给`ggplot()`。然后，使用`aes()`函数提供一个美学映射，将变量映射到*x*和*y*轴。使用`aes()`，你还可以设置图表的颜色、大小、形状和位置。然后，使用如`geom_point()`或`geom_histogram()`之类的函数添加你想要的几何形状。你还可以添加各种选项，例如绘制统计摘要、分面、视觉主题和坐标系。
- en: 'The following code is an extension to what we have used already in this chapter,
    so we will directly delve into the `ggplot` code here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是对本章中已经使用过的内容的扩展，因此我们将直接进入`ggplot`代码部分：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code generates the following chart:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下图表：
- en: '![](img/33685075-4116-479c-9e26-f86291e74187.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33685075-4116-479c-9e26-f86291e74187.png)'
- en: 'Similarly, in order to view the density plot for the numerical variables, we
    can execute the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了查看数值变量的密度图，我们可以执行以下代码：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The plot shows us the univariate density plot for each of our numerical variables.
    The `geom_density()` computes and draws a kernel density estimate, which is a
    smoothed version of the histogram:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了每个数值变量的单变量密度图。`geom_density()`计算并绘制核密度估计，这是直方图的平滑版本：
- en: '![](img/77c12994-1627-466f-a8f9-e17432430292.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77c12994-1627-466f-a8f9-e17432430292.png)'
- en: See also
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The guide to the `seaborn` library ([https://bit.ly/2iU2aRU](https://bit.ly/2iU2aRU))
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`seaborn`库的指南([https://bit.ly/2iU2aRU](https://bit.ly/2iU2aRU))'
