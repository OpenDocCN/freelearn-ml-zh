- en: Adding a Web UI for the Wiki Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为维基游戏添加Web用户界面
- en: Developing the backend of our game was quite a learning experience. This strong
    foundation will serve us well—the modular approach will allow us to easily convert
    the **read-eval-print loop** (**REPL)** app into a web app, while our understanding
    of types will prove to be priceless when dealing with Julia's web stack and its
    rich taxonomy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开发我们游戏的后端是一个相当有学习经验的过程。这个坚实的基础将为我们带来很多好处——模块化的方法将使我们能够轻松地将**读取-评估-打印循环**（**REPL**）应用程序转换为Web应用程序，而我们对类型的理解在处理Julia的Web堆栈及其丰富的分类法时将证明是无价的。
- en: 'We''re now entering the last stage of our game development journey—building
    a web user interface for the *Six Degrees of Wikipedia*. Since building a full-featured
    web app is no simple feat, this last part will be dedicated to this task alone.
    In the process, we will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正进入游戏开发旅程的最后阶段——为*维基百科六度分隔*构建Web用户界面。由于构建一个功能齐全的Web应用程序并非易事，这部分内容将专门用于这项任务。在这个过程中，我们将学习以下主题：
- en: Julia's web stack; namely, the `HTTP` package and its main components—`Server`,
    `Router`, `HandlerFunction`, and `Response`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia的Web堆栈；即`HTTP`包及其主要组件——`Server`、`Router`、`HandlerFunction`和`Response`
- en: Architecting a web app to take advantage of `HTTP` and integrate it with existing
    Julia modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个Web应用程序以利用`HTTP`并集成现有Julia模块
- en: Exposing features on the web by defining routes that map URLs to Julia functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义将URL映射到Julia函数的路由来在Web上公开功能
- en: Spawning a web server to handle user requests and send back proper responses
    to the clients
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个Web服务器来处理用户请求并向客户端发送适当的响应
- en: The end of this chapter comes with a cool reward—our game will be ready and
    we'll play a few rounds of *Six Degrees of Wikipedia*!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结尾带来了一份酷炫的回报——我们的游戏将准备就绪，我们将玩几轮*维基百科六度分隔*！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的包生态系统正在持续发展中，并且每天都有新的包版本发布。大多数时候这是个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍在测试版（版本0.x）中，任何新版本都可能引入破坏性更改。因此，书中展示的代码可能无法正常工作。为了确保您的代码将产生与书中描述相同的结果，建议使用相同的包版本。以下是本章使用的外部包及其特定版本：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，您需要运行：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过下载本章提供的`Project.toml`文件并使用`pkg>`实例化来安装所有使用的包，如下所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The game plan
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏计划
- en: We're onto the last stage of our project—the web UI. Let's start by discussing
    the spec; we need to lay out the blueprint before we can proceed with the implementation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目已经进入最后阶段——Web用户界面。让我们先讨论一下规格说明；在我们可以进行实现之前，我们需要制定蓝图。
- en: The player will start on the landing page. This will display the rules and will
    provide options for launching a new game, allowing the user to choose a difficulty
    level. Following this starting point, the player will be redirected to the new
    game page. Here, taking into account the selected difficulty level, we'll bootstrap
    a new game session by fetching the articles with the algorithm we wrote in the
    previous chapter. Once we pick the articles that represent the *Six Degrees of
    Wikipedia*, we will display a heading with the game's objective—the titles of
    the start and end articles. We'll also display the content of the first article,
    thus kickstarting the game. When the player clicks on a link in this article,
    we have to respond accordingly by checking if the player has found the end article
    and won the game. If not, render the new article and increment the number of steps
    taken.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家将从着陆页开始。这将显示规则，并提供启动新游戏的选择，让用户选择难度级别。从这个起点开始，玩家将被重定向到新游戏页面。在这里，考虑到所选的难度级别，我们将通过获取我们在上一章中编写的算法来启动一个新的游戏会话。一旦我们选择了代表维基百科“六度分隔”的文章，我们将显示一个带有游戏目标的标题——起始和结束文章的标题。我们还将显示第一篇文章的内容，从而启动游戏。当玩家点击这篇文章中的链接时，我们必须相应地检查玩家是否找到了结束文章并赢得了游戏。如果没有，渲染新文章并增加所采取的步骤数。
- en: We'll also need an area to display the progress of the game—the articles that
    were viewed in the current session, how many steps have been taken in total, and
    a form of navigation to allow the players to go back and rethink their choices
    if they find themselves on the wrong track. Therefore, we'll need to store the
    player's navigation history. Finally, it would be nice to provide an option to
    solve the puzzle—of course, as a result, the player will lose the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个区域来显示游戏的进度——当前会话中查看的文章、总共采取了多少步骤，以及一种导航方式，允许玩家在发现自己走错路时返回并重新考虑他们的选择。因此，我们需要存储玩家的导航历史。最后，提供一种解决谜题的选项会很好——当然，作为结果，玩家将输掉游戏。
- en: A very important piece of the spec is that between the stateless browser requests
    and the server responses, while navigating through the Wikipedia articles, we
    need some sort of mechanism to allow us to maintain the state of the game, that
    is, to retrieve a game with its corresponding data—difficulty, path (articles)
    and progress, navigation history, number of steps taken, and so on. This will
    be achieved by creating a unique game identifier at the beginning of each play
    session and passing it with every request as a part of the URL.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中非常重要的一部分是，在无状态的浏览器请求和服务器响应之间，在浏览维基百科文章时，我们需要某种机制来允许我们保持游戏的状态，也就是说，检索带有相应数据的游戏——难度、路径（文章）、进度、导航历史、所采取的步骤数等等。这将通过在每个游戏会话开始时创建一个唯一的游戏标识符，并将其作为URL的一部分与每个请求一起传递来实现。
- en: Learning about Julia's web stack
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解朱莉娅的Web栈
- en: Julia's package ecosystem has long provided a variety of libraries for building
    web apps. Some of the most mature are `HttpServer`, `Mux`, `WebSockets`, and `JuliaWebAPI`
    (to name just a few; this list is not exhaustive). But as the ecosystem settled
    with Julia version 1, a lot of community effort has been put into a newer package,
    simply known as `HTTP`. It provides a web server, an HTTP client (which we already
    used in the previous chapters to fetch the web pages from Wikipedia), as well
    as various utilities for making web development simpler. We'll learn about key
    `HTTP` modules ,such as `Server`, `Router`, `Request`, `Response`, and `HandlerFunction`,
    and we'll put them to good use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅的包生态系统长期以来为构建Web应用提供了各种库。其中一些最成熟的包括 `HttpServer`、`Mux`、`WebSockets` 和 `JuliaWebAPI`（仅举几个例子；这个列表并不全面）。但随着朱莉娅版本1的生态系统稳定下来，社区投入了大量努力开发了一个新的包，简单地称为
    `HTTP`。它提供了一个Web服务器、一个HTTP客户端（我们已经在之前的章节中使用它从维基百科获取网页），以及各种使Web开发更简单的实用工具。我们将了解关键的
    `HTTP` 模块，如 `Server`、`Router`、`Request`、`Response` 和 `HandlerFunction`，并将它们用于良好的用途。
- en: Beginning with a simple example – Hello World
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个简单的例子——Hello World开始
- en: Let's take a look at a simple example of employing the `HTTP` server stack.
    This will help us understand the foundational building blocks before we dive into
    the more complex issue of exposing our game on the web.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用 `HTTP` 服务器栈的简单示例。这将帮助我们理解在深入探讨将我们的游戏公开在网络上这一更复杂问题之前的基础构建块。
- en: If you followed the previous chapter, you should already have the `HTTP` package
    installed. If not, you know the drill—run `pkg> add HTTP` in Julia's REPL.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随着上一章的内容，你应该已经安装了 `HTTP` 包。如果没有，你知道该怎么做——在 Julia 的 REPL 中运行 `pkg> add HTTP`。
- en: 'Now, somewhere on your computer, create a new file called `hello.jl`. Since
    this will be a simple piece of software contained in just one file, there''s no
    need to define a module. Here is the full code, the whole eight lines, in all
    their glory. We''ll go over them next:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的电脑上的某个位置，创建一个名为 `hello.jl` 的新文件。由于这将是一个仅包含一个文件的简单软件，因此不需要定义模块。以下是完整的代码，全部八行，全部的辉煌。我们将在下一部分中讲解它们：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The workflow for handling web requests with `HTTP` requires four entities—`Server`,
    `Router`, `HandlerFunction`, and `Response`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HTTP` 处理网页请求的工作流程需要四个实体——`Server`（服务器）、`Router`（路由器）、`HandlerFunction`（处理函数）和
    `Response`（响应）。
- en: Beginning our analysis of the code with the simplest part, on the last line,
    we start our server by calling `HTTP.serve`. The `serve` function takes a `server`,
    an object of type `Server`, plus the `HOST` information (an IP string) and the
    `PORT` (an integer) that are used to attach to and listen to requests as arguments.
    We have defined `HOST` and `PORT` at the top of the file as constants. The value
    of `HOST` is defined using the non-standard `ip""` string literal. We learned
    about non-standard string literals when we discussed the `String` type. In this
    regard, the `ip"..."` notation is similar to regular expressions (`r"..."`), version
    strings (`v"..."`), or `Pkg` commands (`pkg"..."`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的最简单部分开始分析，在最后一行，我们通过调用 `HTTP.serve` 来启动服务器。`serve` 函数接受一个 `server`，一个类型为
    `Server` 的对象，以及用于附加和监听请求的 `HOST` 信息（一个 IP 字符串）和 `PORT`（一个整数）作为参数。我们在文件顶部定义了 `HOST`
    和 `PORT` 作为常量。`HOST` 的值使用非标准的 `ip""` 字面量定义。我们在讨论 `String` 类型时学习了非标准字符串字面量。在这方面，`ip"..."`
    语法类似于正则表达式 (`r"..."`)、版本字符串 (`v"..."`) 或 `Pkg` 命令 (`pkg"..."`)。
- en: Instantiating a new `Server` requires a `Router` object, which we will name `router`.
    The job of the `Router` is to register a list of mappings (called **routes**)
    between the links (URIs) that are exposed by our app on the internet and our Julia
    functions (called `HandlerFunctions`), which provide the response. We have set
    up the routes using the `register!` function, passing the `router` object, the
    URI structures (like `/` or `/bye`) and the corresponding `HandlerFunction` objects
    as arguments.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个新的 `Server` 需要一个 `Router` 对象，我们将它命名为 `router`。`Router` 的任务是注册一个映射列表（称为
    **路由**），这些映射是在互联网上由我们的应用程序公开的链接（URI）和我们的 Julia 函数（称为 `HandlerFunctions`）之间。我们使用
    `register!` 函数设置了路由，传递了 `router` 对象、URI 结构（如 `/` 或 `/bye`）和相应的 `HandlerFunction`
    对象作为参数。
- en: Now, if you look at the body of the `HandlerFunction`, you'll see that the root
    page `/` will display the string `"Hello World"`; the `/bye` URL will display
    the string `"Bye"`; and finally, every other URI, expressed by the star symbol
    `*`, will return a `"Not found"` text, accompanied by the correct `404 Not Found`
    header.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看 `HandlerFunction` 的主体，你会看到根页面 `/` 将显示字符串 `"Hello World"`；`/bye` URL
    将显示字符串 `"Bye"`；最后，所有其他由星号符号 `*` 表示的 URI 将返回一个 `"Not found"` 文本，并伴随正确的 `404 Not
    Found` 标头。
- en: I'm sure you can now recognize the arrow `->` operator, hinting to the use of
    lambdas. Each `HandlerFunction` constructor takes an anonymous function. This
    function is responsible for processing the request and generating the appropriate
    `Response`. As its argument, it accepts the `Request` object (named `req`), and
    it is expected to return an instance of `Response`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你现在可以识别出箭头 `->` 操作符，这暗示了使用 lambda 函数。每个 `HandlerFunction` 构造函数都接受一个匿名函数。这个函数负责处理请求并生成适当的
    `Response`。作为其参数，它接受名为 `req` 的 `Request` 对象，并预期返回一个 `Response` 实例。
- en: In our example code, we constructed three `Response` objects using two of the
    available HTTP status codes (`200` for `OK` and `404` for page not found), plus
    some strings for the body of the responses (the simple strings `"Hello World"`,
    `"Bye"`, and `"Not found"`, respectively).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，我们使用了两种可用的 HTTP 状态码（`200` 表示 `OK` 和 `404` 表示页面未找到），以及一些用于响应体的字符串（分别是简单的字符串
    `"Hello World"`、`"Bye"` 和 `"Not found"`）来构建了三个 `Response` 对象。
- en: To conclude, when the server receives a request, it delegates it to the router,
    which matches the URI of the request to the most appropriately mapped URI pattern
    and invokes the corresponding `HandlerFunction`, passing in the `Request` as the
    argument. The handler function returns a `Response` object, which is sent by the
    server back to the client.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当服务器收到请求时，它会将其委托给路由器，路由器将请求的 URI 与最合适的映射 URI 模式匹配，并调用相应的 `HandlerFunction`，将
    `Request` 作为参数传入。处理函数返回一个 `Response` 对象，该对象由服务器发送回客户端。
- en: 'Let''s see it in action. You can use the `Run` functionality in your editor
    or you can execute `$ julia hello.jl` in the Terminal. Alternatively, you can
    run the code in this chapter''s accompanying IJulia notebook:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的实际效果。您可以在编辑器中使用 `Run` 功能，或者您可以在终端中执行 `$ julia hello.jl`。或者，您也可以在本章的配套
    IJulia 笔记本中运行代码：
- en: '![](img/7a15f58c-e321-4428-9c93-e02ab12045be.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a15f58c-e321-4428-9c93-e02ab12045be.png)'
- en: The preceding screenshot shows the `hello.jl` file running in Juno. The REPL
    pane displays debugging information from the web server as requests are received
    and handled.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了在 Juno 中运行的 `hello.jl` 文件。REPL 窗格显示了在接收和处理请求时来自网络服务器的调试信息。
- en: 'As soon as the server is ready, you''ll get a log message saying that the server
    is listening on the indicated socket. At this point, you can open a web browser
    and navigate to `http://localhost:9999`. You''ll be greeted by the (in)famous
    **Hello World** message, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器一准备好，您就会收到一条日志消息，说明服务器正在监听指定的套接字。此时，您可以在网络浏览器中导航到 `http://localhost:9999`。您将看到（或许）著名的
    **Hello World** 消息，如下所示：
- en: '![](img/b7b0f528-967b-4b4b-9aa5-0ba49dfb1a99.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7b0f528-967b-4b4b-9aa5-0ba49dfb1a99.png)'
- en: Congratulations—we've just developed our first web app with Julia!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——我们刚刚用 Julia 开发了我们的第一个网络应用！
- en: No bonus points for guessing what happens when navigating to `http://localhost:9999/bye`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '当您导航到 `http://localhost:9999/bye` 时，猜猜会发生什么，没有加分。 '
- en: 'Finally, you can confirm that any other request will result in a `404 Not Found`
    page by attempting to navigate to any other link under `http://localhost:9999`—for
    instance, `http://localhost:9999/oh/no`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过尝试导航到 `http://localhost:9999/bye` 来确认任何其他请求都将导致 `404 Not Found` 页面。
- en: '![](img/7a7d0203-9289-4860-aad6-d1926ff26149.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a7d0203-9289-4860-aad6-d1926ff26149.png)'
- en: Here is the **Not Found** page, correctly returning the `404` status code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 **未找到** 页面，正确地返回了 `404` 状态码。
- en: Developing the game's web UI
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发游戏的网络用户界面
- en: Please start your favorite Julia editor and open the `sixdegrees/` folder we
    used in the previous chapter. It should contain all the files that we've worked
    on already—`six_degrees.jl`, plus the `Articles`, `Database`, `Gameplay`, and
    `Wikipedia` modules.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请启动您最喜欢的 Julia 编辑器并打开我们在上一章中使用的 `sixdegrees/` 文件夹。它应该包含我们之前已经工作过的所有文件——`six_degrees.jl`，以及
    `Articles`、`Database`、`Gameplay` 和 `Wikipedia` 模块。
- en: If you haven't followed through the code up to this point, you can download
    this chapter's accompanying support files, which are available at [https://github.com/PacktPublishing/Julia-Programming-Projects/tree/master/Chapter05](https://github.com/PacktPublishing/Julia-Programming-Projects/tree/master/Chapter05).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有跟上到这一点的代码，您可以下载本章的配套支持文件，这些文件可在以下网址找到：[https://github.com/PacktPublishing/Julia-Programming-Projects/tree/master/Chapter05](https://github.com/PacktPublishing/Julia-Programming-Projects/tree/master/Chapter05)。
- en: 'Add a new file for our web app. Since the code will be more complex this time
    and should integrate with the rest of our modules, let''s define a `WebApp` module
    within a new `WebApp.jl` file. Then, we can add these first few lines of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的网络应用添加一个新文件。由于这次代码会更复杂，并且应该与我们的其他模块集成，让我们在新的 `WebApp.jl` 文件中定义一个 `WebApp`
    模块。然后，我们可以添加以下几行代码：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: No surprises here—similar to the previous example, we define constants for `HOST`
    and `PORT`, and then instantiate a `Router` and a `Server` and start listening
    for requests. The code should work just fine, but it's not worth running it yet
    as it won't do anything useful. We need to define and register our routes, and
    then set up the handler functions for generating the game's pages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜——与之前的例子类似，我们定义了 `HOST` 和 `PORT` 的常量，然后实例化一个 `Router` 和一个 `Server` 并开始监听请求。代码应该可以正常工作，但现在运行它还没有什么实际作用。我们需要定义和注册我们的路由，然后设置生成游戏页面的处理函数。
- en: Defining our routes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们的路由
- en: 'By reviewing the high-level spec that we defined at the beginning of the chapter,
    we can identify the following pages:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回顾我们在本章开头定义的高级规范，我们可以确定以下页面：
- en: '**Landing page**: The starting place of our web app and the home page, where
    the player can begin a new game and choose the difficulty.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着陆页面**：我们网络应用的起始页面和主页，玩家可以在这里开始新游戏并选择难度。'
- en: '**New game page**: Bootstraps a new game, taking into account the difficulty
    settings.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新游戏页面**：根据难度设置启动新游戏。'
- en: '**Wiki article page**: This will display the Wikipedia article corresponding
    to a link in the chain and will update the game''s stats. Here, we''ll also check
    if the current article is the goal (the end) article, which is to finish the game
    as a winner. If not, we''ll check if the maximum number of articles has been reached,
    and if so finish the game as a loser.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维基百科文章页面**：这将显示链中链接对应的维基百科文章，并更新游戏的统计数据。在这里，我们还将检查当前文章是否是目标（结束）文章，即以胜利者的身份完成游戏。如果不是，我们将检查是否达到了文章的最大数量，如果是，则以失败者的身份结束游戏。'
- en: '**Back page**: This will allow the player to go back up the chain if the solution
    wasn''t found. We''ll display the corresponding Wikipedia article while correctly
    updating the game''s stats.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回页面**：这将允许玩家在解决方案未找到时返回链。我们将显示相应的维基百科文章，同时正确更新游戏的统计数据。'
- en: '**Solution page**: If the player gives up, this page will display the last
    article in the chain, together with the path to it. The game is ended as a loss.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案页面**：如果玩家放弃，此页面将显示链中的最后一篇文章，以及到达该文章的路径。游戏以失败结束。'
- en: Any other page should end up as `Not Found`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他页面都应该最终显示为`未找到`。
- en: 'Taking into account that the route handlers will be fairly complex, it''s best
    if we *don''t* define them inline with the route definitions. Instead, we''ll
    use separately defined functions. Our route''s definitions will look like this—please
    add them to the `WebApp` module, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到路由处理程序将会相当复杂，最好我们不要在路由定义中直接定义它们。相反，我们将使用单独定义的函数。我们的路由定义将看起来像这样——请按照以下方式将它们添加到`WebApp`模块中：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might be wondering what's with the extra `*` in front of the URI patterns.
    We stated that we'll need a way to identify a running game session between the
    otherwise stateless web requests. The `articlepage`, `backpage`, and `solutionpage`
    functions will all require an existing game session. We'll pass this session ID
    as the first part of the URL. Effectively, their paths are to be interpreted as
    `/$session_id/wiki/*`, `/$session_id/back/*`, and `/$session_id/solution`, where
    the `$session_id` variable represents the unique game identifier. As for the trailing
    `*`, it represents different things for different routes—in the case of `new`,
    it's the difficulty level of the game; for `articlepage`, it's the actual Wikipedia
    URL, which is also our article identifier; and for the `backpage`, it represents
    the index in the navigation stack. Similar to regular expressions, for route matching
    as well, the `*` will match anything. If this sounds complicated, don't worry—seeing
    and running the code will make things clear.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么URI模式前面有额外的`*`。我们提到我们需要一种方法来识别在无状态的网络请求之间的运行游戏会话。`articlepage`、`backpage`和`solutionpage`函数都将需要一个现有的游戏会话。我们将把会话ID作为URL的第一部分传递。实际上，它们的路径将被解释为`/$session_id/wiki/*`、`/$session_id/back/*`和`/$session_id/solution`，其中`$session_id`变量代表唯一的游戏标识符。至于尾随的`*`，对于不同的路由有不同的含义——在`new`的情况下，它是游戏的难度级别；对于`articlepage`，它是实际的维基百科URL，也是我们的文章标识符；对于`backpage`，它代表导航堆栈中的索引。类似于正则表达式，对于路由匹配也是如此，`*`将匹配任何内容。如果这听起来很复杂，不要担心——看到并运行代码会让事情变得清晰。
- en: 'Let''s add placeholder definitions for each handler function—please add these
    *before* the list of routes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为每个处理程序函数添加占位符定义——请在路由列表之前添加这些定义：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Preparing the landing page
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备着陆页面
- en: Straight away, we can address the landing page handler. All it needs to do is
    display some static content describing the game's rules, as well as provide a
    way to start a new game with various levels of difficulty. Remember that the difficulty
    of the game determines the length of the article chain, and we need this information
    when we start a new game. We can pass it to the new game page as part of the URL,
    under the format `/new/$difficulty_level`. The difficulty levels are already defined
    in the `Gameplay` module, so don't forget to declare that we're `using Gameplay`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，我们可以处理着陆页面处理程序。它需要做的只是显示一些静态内容，描述游戏规则，并提供以不同难度级别开始新游戏的方式。记住，游戏的难度决定了文章链的长度，我们在开始新游戏时需要这个信息。我们可以将其作为URL的一部分传递给新游戏页面，格式为`/new/$difficulty_level`。难度级别已经在`Gameplay`模块中定义，所以别忘了声明我们正在`使用
    Gameplay`。
- en: Taking this into account, we'll end up with the following code for our `WebApp`
    module. We're putting everything together and we're also adding the `landingpage`
    `HandlerFunction`. This works in correlation with the first route—`HTTP.register!(ROUTER,
    "/",landingpage)`. What this means is that when we access the `/` route in the
    browser, the ` landingpage` `HandlerFunction` will be executed and its output
    will be returned as the response. In this case, we're simply returning a bunch
    of HTML code. If you're not familiar with HTML, here's what the markup does—we
    include the Twitter Bootstrap CSS theme to make our page prettier, we display
    a few paragraphs of text explaining the rules of the game, and we display three
    buttons for starting a new game—one button for each level of difficulty.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们将得到以下`WebApp`模块的代码。我们正在将所有内容组合在一起，同时也添加了`landingpage` `HandlerFunction`。这与第一个路由`HTTP.register!(ROUTER,
    "/", landingpage)`相关联。这意味着当我们通过浏览器访问`/`路由时，`landingpage` `HandlerFunction`将被执行，其输出将作为响应返回。在这种情况下，我们只是返回一些HTML代码。如果你不熟悉HTML，以下是标记的作用——我们包含了Twitter
    Bootstrap CSS主题来使我们的页面更美观，我们显示了一些解释游戏规则的段落，并显示了三个用于开始新游戏的按钮——每个难度级别一个按钮。
- en: 'Here is the code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s update the `six_degrees.jl` file to bootstrap our web app. Please make
    sure that it now reads as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`six_degrees.jl`文件以启动我们的Web应用。请确保它现在如下所示：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run `six_degrees.jl` using your preferred approach, either in the editor or
    the Terminal (`$ julia six_degrees.jl`). Look for the message `Info: Listening
    on:...`, which notifies us that the web server has been started. Visit `http://localhost:8888/`
    in your browser and feast your eyes on our landing page! I''m sure you''ll notice
    the effect of including the Twitter Bootstrap CSS file—adding just a few CSS classes
    to our code makes for a great visual impact!'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '使用你喜欢的途径运行`six_degrees.jl`，无论是编辑器还是终端（`$ julia six_degrees.jl`）。寻找消息`Info:
    Listening on:...`，这会通知我们Web服务器已启动。在你的浏览器中访问`http://localhost:8888/`，欣赏我们的着陆页！我相信你会注意到包含Twitter
    Bootstrap CSS文件的效果——只需在我们的代码中添加几个CSS类，就能产生很大的视觉冲击力！'
- en: '![](img/c55d8dcb-0509-440e-914e-e35e4e5866c8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c55d8dcb-0509-440e-914e-e35e4e5866c8.png)'
- en: The preceding screenshot is of our game's landing page running on localhost
    at port `8888`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图是我们游戏着陆页在本地主机`8888`端口上运行时的样子。
- en: Starting a new game
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: 'Excellent! Now, let''s focus on the functionality for starting a new game.
    Here, we need to implement the following steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，让我们专注于开始新游戏的功能。在这里，我们需要实现以下步骤：
- en: Extract the difficulty settings from the URL.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从URL中提取难度设置。
- en: Start a new game. This game should have an ID, which will be our `session id`.
    Plus, it should keep track of the list of articles, progress, navigation history,
    the total number of steps taken, and the difficulty.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始新游戏。这个游戏应该有一个ID，即我们的`session id`。此外，它应该跟踪文章列表、进度、导航历史、总步数和难度。
- en: Render the first Wikipedia article.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染第一篇维基百科文章。
- en: Set up in-article navigation. We need to make sure that the links within the
    Wikipedia article will properly link back into our app, and not the Wikipedia
    website itself.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置文章内导航。我们需要确保维基百科文章内的链接能够正确链接回我们的应用，而不是维基百科网站本身。
- en: Display information about the game session, such as the objective (start and
    end articles), number of steps taken, and so on.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示有关游戏会话的信息，例如目标（起始和结束文章）、所走步数等。
- en: We'll look at all of these steps next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中查看所有这些步骤。
- en: Extracting the difficulty settings from the page URL
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从页面URL中提取难度设置
- en: 'This is the very first step. Remember that within our `HandlerFunction`, we
    have access to the `Request` object, `req`. All the `Request` objects expose a
    field called `target` that references the URL of the request. The `target` does
    not include the protocol or the domain name, so it will be of the form `/new/$difficulty_level`.
    A quick way to extract the value of `$difficulty_level` is to simply replace the
    first part of the URI with an empty string, `""`, effectively removing it. The
    result will be used in a function, `newgamesession`, to create a new game of the
    indicated difficulty. Put into code, it will look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一步。记住，在我们的`HandlerFunction`中，我们可以访问`Request`对象，`req`。所有的`Request`对象都暴露一个名为`target`的字段，它引用请求的URL。`target`不包括协议或域名，所以它的形式将是`/new/$difficulty_level`。提取`$difficulty_level`值的一个快速方法是简单地用空字符串`""`替换URI的第一部分，从而有效地删除它。结果将用于一个函数`newgamesession`，以创建指定难度的游戏。用代码表示，它将看起来像这样：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we represent difficulty levels as integers (number of articles), we parse
    the string into an integer (specifically of type `UInt8`) before using it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将难度级别表示为整数（文章数量），我们在使用它之前将字符串解析为整数（具体为 `UInt8` 类型）。
- en: Starting a new game session
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个新的游戏会话
- en: Starting a new game session is the second step. The game session manager, which
    should include the preceding `newgamesession` function, is missing entirely, so
    it's time we added it. We'll represent a game session as an instance of a corresponding
    type. Let's pack the `type` definition and the methods for manipulating it into
    a dedicated module. We can name the module `GameSession`, and the type `Game`.
    Please create the `GameSession.jl` file within the `"sixdegrees/"` folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的游戏会话是第二步。游戏会话管理器，应该包括前面的 `newgamesession` 函数，完全缺失，所以现在是时候添加它了。我们将游戏会话表示为相应类型的实例。让我们将
    `type` 定义和操作它的方法打包到一个专用模块中。我们可以将模块命名为 `GameSession`，类型命名为 `Game`。请在 `"sixdegrees/"`
    文件夹中创建 `GameSession.jl` 文件。
- en: Our `Game` type will need a custom constructor. We'll provide the difficulty
    level, and the constructor will take care of setting all of the internals—it will
    fetch the right number of Wikipedia articles using the previously created `Gameplay.newgame`
    function; it will create a unique game ID (which will be our session ID); and
    it'll initialize the rest of the fields with default values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Game` 类型需要一个自定义构造函数。我们将提供难度级别，构造函数将负责设置所有内部设置——它将使用之前创建的 `Gameplay.newgame`
    函数获取正确数量的维基百科文章；它将创建一个唯一的游戏 ID（这将是我们会话 ID）；并且它将使用默认值初始化其余字段。
- en: 'A first attempt will look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试可能看起来像这样：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Random.randstring` function creates a random string. This is our game's
    and our session's ID.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random.randstring` 函数创建一个随机字符串。这是我们游戏和会话的 ID。'
- en: We've also defined a `GAMES` dictionary, which will store all the active games
    and will allow us to look them up by their `id` field. Remember, our game is exposed
    on the web, so we'll have multiple game sessions running in parallel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个 `GAMES` 字典，它将存储所有活动游戏，并允许我们通过其 `id` 字段查找它们。记住，我们的游戏是在网络上公开的，所以我们将有多个并行运行的游戏会话。
- en: 'We can now add the rest of the functions. Add the following definitions before
    the module''s closing `end`, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加其余的函数。在模块的关闭 `end` 之前添加以下定义，如下所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It's worth noting that storing our games in memory is fine for the purpose of
    this learning project, but in production, with a lot of players, you'd risk running
    out of memory quickly. For production use, we'd be better off persisting each
    `Game` to the database and retrieving it as necessary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，为了这个学习项目，将我们的游戏存储在内存中是可以的，但在实际生产中，随着玩家数量的增加，你可能会很快耗尽内存。对于生产使用，我们最好将每个
    `Game` 持久化到数据库中，并在需要时检索它。
- en: Rendering the first Wikipedia article from the chain
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从链中渲染第一篇维基百科文章
- en: 'This is the third step. Going back to our `WebApp` module (in `WebApp.jl`),
    let''s continue with the logic for the `newgamepage` handler. The implementation
    will look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第三步。回到我们的 `WebApp` 模块（在 `WebApp.jl` 中），让我们继续处理 `newgamepage` 处理器的逻辑。实现方式如下：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we create a new game, we need to reference its first article. We add the
    starting article to the game''s history and then we render it as HTML using the
    following `wikiarticle` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个新的游戏，我们需要引用它的第一篇文章。我们将起始文章添加到游戏的历史记录中，然后使用以下 `wikiarticle` 函数将其渲染为
    HTML：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We simply display the title of the Wikipedia article as the main heading, and
    then the content.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地显示维基百科文章的标题作为主标题，然后是内容。
- en: 'Finally, don''t forget to load `GameSession` into our app by adding it to `"six_degrees.jl"`.
    Beware that it needs to be loaded before `WebApp` to be available for `WebApp`.
    The full `"six_degrees.jl"` file should now look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了通过将其添加到 `"six_degrees.jl"` 中将 `GameSession` 加载到我们的应用中。请注意，它需要在 `WebApp`
    之前加载，以便 `WebApp` 可以使用。现在，完整的 `"six_degrees.jl"` 文件应该看起来像这样：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you rerun our code and navigate to `http://localhost:8888/new/2`, you''ll
    see our app rendering a random Wikipedia article:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行我们的代码并导航到 `http://localhost:8888/new/2`，你会看到我们的应用正在渲染一个随机的维基百科文章：
- en: '![](img/7cf79cd6-fbb9-4938-98c3-e94cc8328470.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cf79cd6-fbb9-4938-98c3-e94cc8328470.png)'
- en: It's a good start, but there are some problems. First, we were a bit too greedy
    when fetching the content from Wikipedia. It includes the full page HTML, which
    contains things we don't really need, like the invisible `<head>` section and
    the all-too visible Wikipedia content from above the article's text (the search
    form, the menu, and so on). This is easy to fix—all we need to do is be a bit
    more specific about the content we want by using a better-defined CSS selector.
    A bit of playing around with the browser's inspector will reveal that the desired
    selector is `#bodyContent`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的开始，但也有一些问题。首先，我们在从维基百科获取内容时有点过于贪婪。它包含了完整的页面HTML，其中包含我们实际上并不需要的东西，比如不可见的`<head>`部分和文章文本上方的所有太明显的维基百科内容（搜索表单、菜单等等）。这很容易解决——我们只需要通过使用更明确的CSS选择器来更具体地定义我们想要的内容。在浏览器的检查器中稍微玩一下，就可以发现所需的选择器是`#bodyContent`。
- en: 'Armed with this knowledge, we need to update the `Wikipedia` module. Please
    replace the existing `articleinfo` function with this one:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个知识，我们需要更新`Wikipedia`模块。请用以下函数替换现有的`articleinfo`函数：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead of using the whole HTML, we will now extract just the content of the
    desired CSS selector:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将只提取所需CSS选择器的内容，而不是使用整个HTML。
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please add the definition of `extractcontent` to the `Wikipedia.jl` file, under
    the `extractimage` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请在`Wikipedia.jl`文件中，在`extractimage`函数下添加`extractcontent`的定义。
- en: 'By revisiting our page at `http://localhost:8888/new/2`, we will see our efforts
    rewarded with a much better-looking replacement:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新访问`http://localhost:8888/new/2`页面，我们将看到我们的努力得到了一个看起来好得多的替代品：
- en: '![](img/2dc79e56-d94e-4ef1-97bc-3549a9756aa2.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2dc79e56-d94e-4ef1-97bc-3549a9756aa2.png)'
- en: Setting up in-article navigation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置文章内导航
- en: 'All right, that wasn''t so hard! But the next issue is more difficult. The
    fourth step is all about the setup. We established that we need to capture all
    the internal Wikipedia links so that when the player clicks on a link, they are
    taken to our app instead of going to the original Wikipedia article. Half of this
    work is done by Wikipedia''s content itself because it uses relative URLs. That
    is, instead of using absolute URLs in the form of `https://en.wikipedia.org/wiki/Wikipedia:Six_degrees_of_Wikipedia`,
    it uses the relative form `/wiki/Wikipedia:Six_degrees_of_Wikipedia`. This means
    that when rendered in the browser, these links will inherit the domain name (or
    the *base URL*) of the current host. That is, when rendering the content of a
    Wikipedia article at `http://localhost:8888/`, its relative URLs will be interpreted
    as `http://localhost:8888/wiki/Wikipedia:Six_degrees_of_Wikipedia`. Therefore,
    they''ll automatically point back to our web app. That''s great, but one big piece
    of the puzzle is missing: we said that we want to maintain the state of our game
    by passing the session ID as part of the URL. Thus, our URLs should be of the
    form `http://localhost:8888/ABCDEF/wiki/Wikipedia:Six_degrees_of_Wikipedia`, where
    `ABCDEF` represents the game (or session) ID. The simplest solution is to replace
    `/wiki/` with `/ABCDEF/wiki/` when rendering the content—of course, using the
    actual game ID instead of `ABCDEF`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不难！但下一个问题更难。第四步完全是关于设置。我们确定我们需要捕获所有内部维基百科链接，这样当玩家点击链接时，他们会转到我们的应用而不是去原始的维基百科文章。这项工作的一半是由维基百科的内容本身完成的，因为它使用相对URL。也就是说，它不是使用形式为`https://en.wikipedia.org/wiki/Wikipedia:Six_degrees_of_Wikipedia`的绝对URL，而是使用相对形式`/wiki/Wikipedia:Six_degrees_of_Wikipedia`。这意味着当在浏览器中渲染时，这些链接将继承当前主机的域名（或基础URL）。也就是说，当在`http://localhost:8888/`上渲染维基百科文章的内容时，它的相对URL将被解释为`http://localhost:8888/wiki/Wikipedia:Six_degrees_of_Wikipedia`。因此，它们将自动指向我们的网络应用。这很好，但拼图中还缺一块大拼图：我们说过，我们想要通过将会话ID作为URL的一部分来保持游戏的状态。因此，我们的URL应该是形式为`http://localhost:8888/ABCDEF/wiki/Wikipedia:Six_degrees_of_Wikipedia`，其中`ABCDEF`代表游戏（或会话）ID。最简单的解决方案是在渲染内容时将`/wiki/`替换为`/ABCDEF/wiki/`——当然，使用实际的游戏ID而不是`ABCDEF`。
- en: 'In the definition of the `WebApp.wikiarticle` function, please look for this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WebApp.wikiarticle`函数的定义中，请查找以下内容：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Replace it with the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because we now need the `game` object, we must make sure that we pass it into
    the function, so its declaration should become the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在需要`game`对象，我们必须确保将其传递到函数中，所以它的声明应该变成以下这样：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This means that we also need to update the `newgamepage` route handler to correctly
    invoke the updated `wikiarticle` function. The last line of the `WebApp.newgamepage`
    function should now be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们还需要更新`newgamepage`路由处理程序，以正确调用更新的`wikiarticle`函数。`WebApp.newgamepage`函数的最后一行现在应该是这样的：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you execute `six_degrees.jl` and take your browser to `http://localhost:8888/new/2`,
    you should see a nice rendering of a Wikipedia article with all the internal links
    containing the game ID:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行`six_degrees.jl`并将你的浏览器导航到`http://localhost:8888/new/2`，你应该会看到一个包含所有包含游戏ID的内部链接的维基百科文章的渲染效果：
- en: '![](img/cb4f92b0-576f-4d7c-9b87-6b61d5939b03.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb4f92b0-576f-4d7c-9b87-6b61d5939b03.png)'
- en: In the preceding screenshot, we can see that all the URLs start with `/x2wHk2XI`—our
    game ID.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到所有URL都以`/x2wHk2XI`开头——我们的游戏ID。
- en: Displaying information about the game session
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示游戏会话信息
- en: 'For the fifth and very last part of our spec, we need to display information
    about the game and provide a way to navigate back to the previous articles. We''ll
    define the following functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们规格说明的第五部分和最后一部分，我们需要显示游戏信息并提供一种方式来导航回之前的文章。我们将定义以下函数：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `objective` function informs the player about the start and end articles
    and about the current progress. It also provides a small menu so that you can
    view the solution or start a new game.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`objective`函数会告知玩家起始和结束文章以及当前进度。它还提供了一个小的菜单，以便你可以查看解决方案或开始新游戏。'
- en: 'For navigating back, we need to generate the game history links:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导航回上一页，我们需要生成游戏历史链接：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we need a bit of extra logic to check if the game was won or lost:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一些额外的逻辑来检查游戏是否获胜或失败：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have a winner if the URL of the current article is the same as the URL of
    the last article in the game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前文章的URL与游戏中最后一条文章的URL相同，我们就有了胜者。
- en: 'The game is lost if the player runs out of moves:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家用完了移动次数，游戏就输了：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The complete code, so far, should look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，完整的代码应该看起来像这样：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Please note that we've also refactored the `<head>` of the pages, abstracting
    it away into the `head` function, which is used by both `landingpage` and `wikiarticle`.
    This way, we keep our code DRY, avoiding the repetition of the same `<head>` HTML
    element.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还重构了页面的`<head>`部分，将其抽象到`head`函数中，该函数由`landingpage`和`wikiarticle`共同使用。这样，我们保持了代码的DRY原则，避免了重复的`<head>`
    HTML元素。
- en: 'Now, let''s make sure that we add `Gameplay.MAX_NUMBER_OF_STEPS` to `Gameplay.jl`.
    Add it at the top, under the difficulty constants:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保将`Gameplay.MAX_NUMBER_OF_STEPS`添加到`Gameplay.jl`中。在难度常量下面添加它：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Displaying a Wikipedia article page
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示维基百科文章页面
- en: The player has read the starting article and clicked on a link within the content.
    We need to add the logic for rendering the linked article. We'll have to fetch
    the article (or read it from the database if it was already fetched), display
    it, and update the game's state.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家已经阅读了起始文章并点击了内容中的链接。我们需要添加渲染链接文章的逻辑。我们将必须获取文章（或者如果它已经被获取，则从数据库中读取），显示它，并更新游戏状态。
- en: 'Here is the code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We start by parsing the `Request` URI to extract all the values sent via GET.
    It is a string with the format `/$session_id/wiki/$article_name`, for example, `/c701b1b0b1/wiki/Buenos_Aires`.
    We want to break it into its parts. Since this is an operation that we''ll need
    to perform more than once, we will abstract this functionality into the `parseuri`
    function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解析`Request` URI以提取通过GET发送的所有值。它是一个格式为`/$session_id/wiki/$article_name`的字符串，例如，`/c701b1b0b1/wiki/Buenos_Aires`。我们希望将其分解成各个部分。由于这是一个我们需要多次执行的操作，我们将这个功能抽象到`parseuri`函数中：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we use Julia's `split` function to break the URI string into an `Array`
    of `SubString`, corresponding to the segments between forward slashes `/`. Then,
    we convert the resulting `Array` of `SubString` to an `Array` of `String`, which
    is returned and stored in the `uri_parts` variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Julia的`split`函数将URI字符串分解成一个由`SubString`组成的`Array`，对应于正斜杠`/`之间的各个部分。然后，我们将得到的`SubString`的`Array`转换成一个`String`的`Array`，它被返回并存储在`uri_parts`变量中。
- en: Continuing with the definition of the `articlepage` handler, we use the first
    element of the `uri_parts` array, which corresponds to the session ID, to retrieve
    our game object, by invoking `gamesession(uri_parts[1])`. With the last element,
    we generate the Wikipedia article URL. We then look up the article by URL, and
    either retrieve it from the database or fetch it from the website.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 继续定义`articlepage`处理程序，我们使用`uri_parts`数组的第一元素，它对应于会话ID，通过调用`gamesession(uri_parts[1])`来检索我们的游戏对象。使用最后一个元素，我们生成维基百科文章URL。然后，我们通过URL查找文章，要么从数据库中检索它，要么从网站上获取它。
- en: 'Once we have the article, we add it to the game''s history and increase the
    `game.steps_taken` counter. Then, we check if we should end the game as a win:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了文章，我们就将其添加到游戏的历史记录中，并增加`game.steps_taken`计数器。然后，我们检查是否应该以胜利结束游戏：
- en: '![](img/994e68d4-d843-4ed8-b235-25b745cc474f.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/994e68d4-d843-4ed8-b235-25b745cc474f.png)'
- en: This is a screenshot of the winning article page. The design is not great, but
    the sweet taste of victory surely is!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是胜利文章页面的截图。设计不是很好，但胜利的甜蜜滋味肯定是的！
- en: Finally, similar to the new game page, we respond by rendering the article and
    all the game information.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，类似于新游戏页面，我们通过渲染文章和所有游戏信息来响应。
- en: Navigating back up the article chain
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文章链中向上导航
- en: 'Keep in mind that a back navigation URL looks like `/c701b1b0b1/back/1`, where
    the first part is the session ID and the last part is the index of the item in
    the history stack. To implement it, the workflow is similar to `articlepage`—we
    parse the `Request` URI, retrieve the game by session ID, and get the article
    from the game''s history stack. Since we go back in the game''s history, everything
    beyond the current article index is to be removed from the navigation stack. When
    done, we respond by rendering the corresponding Wikipedia article. The code is
    short and readable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，后退导航URL看起来像`/c701b1b0b1/back/1`，其中第一部分是会话ID，最后一部分是历史堆栈中项目的索引。为了实现它，工作流程与`articlepage`类似——我们解析`Request`
    URI，通过会话ID检索游戏，并从游戏的历史堆栈中获取文章。由于我们在游戏历史中后退，所以当前文章索引之后的所有内容都应该从导航堆栈中删除。完成后，我们通过渲染相应的维基百科文章来响应。代码简短且易于阅读：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Showing the solution
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示解决方案
- en: 'For the solution page, the only thing we need from the `Request` URI is the
    session ID. Then, we follow the same workflow to get the current `Game` object.
    Once we have it, we copy the list of articles into the history stack to display
    the game''s solution using the existing rendering logic. We also set the `steps_taken`
    counter to the maximum because the game is considered a loss. Finally, we display
    the last article:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解决方案页面，我们只需要从`Request` URI中获取会话ID。然后，我们遵循相同的流程来获取当前的`Game`对象。一旦我们有了它，我们将文章列表复制到历史堆栈中，以使用现有的渲染逻辑显示游戏的解决方案。我们还把`steps_taken`计数器设置为最大值，因为游戏被认为是失败的。最后，我们显示最后一条文章：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The solution page appears as follows, settling the game as a loss:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案页面如下所示，将游戏判定为失败：
- en: '![](img/53597668-7976-468f-81f3-f432d7cdf57c.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53597668-7976-468f-81f3-f432d7cdf57c.png)'
- en: Handling any other requests
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理任何其他请求
- en: 'Similar to our `Hello World` example, we''ll respond to any other requests
    with a `404 Not Found` response:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`Hello World`示例类似，我们将对任何其他请求以`404 Not Found`响应：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Wrapping it up
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'I''ve added a few more UI tweaks to the  `WebApp.jl` file to spice things up
    a bit. Here are the important parts—please download the full file from [https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter05/sixdegrees/WebApp.jl](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter05/sixdegrees/WebApp.jl):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`WebApp.jl`文件中添加了一些更多的UI调整，以使事情变得更有趣。以下是重要部分——请从[https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter05/sixdegrees/WebApp.jl](https://github.com/PacktPublishing/Julia-Programming-Projects/blob/master/Chapter05/sixdegrees/WebApp.jl)下载完整文件：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You will see that I have reorganized the layout a bit and that I''ve added
    a few extra styles to make our UI prettier. Here is our game with its updated
    look:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我稍微调整了布局，并添加了一些额外的样式来使我们的UI更漂亮。以下是我们的游戏及其更新的外观：
- en: '![](img/03d56710-7271-47cc-8a32-49fa8bb210a9.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03d56710-7271-47cc-8a32-49fa8bb210a9.png)'
- en: As for the rest of the files, if you need them, they are available for download
    in this chapter's GitHub repository, which is accessible at [https://github.com/PacktPublishing/Julia-Programming-Projects/tree/master/Chapter05/sixdegrees](https://github.com/PacktPublishing/Julia-Programming-Projects/tree/master/Chapter05/sixdegrees).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 至于其他文件，如果您需要，它们可以在本章的 GitHub 仓库中下载，该仓库可通过以下链接访问：[https://github.com/PacktPublishing/Julia-Programming-Projects/tree/master/Chapter05/sixdegrees](https://github.com/PacktPublishing/Julia-Programming-Projects/tree/master/Chapter05/sixdegrees)。
- en: That is all we need to do to run a full game of *Six Degrees of Wikipedia*.
    Now, it's time to enjoy it!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们运行一整场 *维基百科六度分隔* 所需要做的全部。现在，是时候享受它了！
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Julia focuses on scientific computing and data science. But thanks to its great
    qualities as a generic programming language, its native parallel computing features,
    and its performance, we have an excellent use case for Julia in the area of web
    development.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 专注于科学计算和数据科学。但得益于其作为通用编程语言的优秀品质、原生并行计算特性和性能，我们在网络开发领域对 Julia 的应用非常出色。
- en: The package ecosystem provides access to a powerful set of libraries dedicated
    to web programming. They are relatively low level, but still abstract away most
    of the complexities of working directly with the network stack. The `HTTP` package
    provides a good balance between usability, performance, and flexibility.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 包含生态系统提供了访问一组强大的库，这些库专门用于网络编程。它们相对较低级，但仍然抽象掉了直接与网络栈工作的大部分复杂性。`HTTP` 包在可用性、性能和灵活性之间提供了良好的平衡。
- en: The fact that we managed to build a fairly complex (albeit small) web app with
    so little code is a testimony to the power and expressiveness of the language
    and to the quality of the third-party libraries. We did a great job with our learning
    project—it's now time to relax a bit and enjoy a round of *Six Degrees of Wikipedia*,
    Julia style!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够用如此少的代码构建一个相当复杂（尽管规模较小）的 Web 应用，这证明了该语言的力量和表现力，以及第三方库的质量。我们在学习项目中做得很好——现在是时候稍微放松一下，以
    Julia 风格享受一轮 *维基百科六度分隔* 了！
