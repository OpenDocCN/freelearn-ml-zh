- en: 'Chapter 12: Deploying Applications to the Cloud'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章：将应用程序部署到云
- en: 'In the previous chapter, we focused our efforts on integrating our models within
    the **Flask** framework to develop two main methods of serving data to end users:
    **Graphical User Interfaces** (**GUIs**), and **Application Programming Interfaces**
    (**APIs**). Using the Flask framework, we managed to locally deploy our models
    for development purposes only. In this chapter, we will take the next step forward
    and deploy our model to the cloud, thus making it available not only locally to
    ourselves but also across the web to many other users.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们专注于将我们的模型集成到**Flask**框架中，以开发两种向最终用户提供服务的主要方法：**图形用户界面**（**GUIs**）和**应用程序编程接口**（**APIs**）。使用Flask框架，我们成功地将我们的模型仅用于开发目的进行本地部署。在本章中，我们将迈出下一步，将我们的模型部署到云中，使其不仅对我们本地可用，而且对网络上的许多其他用户也可用。
- en: There are many different deployment platforms out there, such as **Amazon Web
    Services** (**AWS**), **Google Cloud Platform** (**GCP**), Azure, and Heroku,
    each of which serves to fulfill a number of needs. In each of these platforms,
    there are a number of solutions, each containing its respective pros and cons.
    For each of these solutions, there are a number of ways we can deploy a framework
    within them. Essentially, the number of possible ways to deploy a solution is
    practically uncountable, and because of this, users can get easily overwhelmed.
    Over the course of this chapter, we will explore some of the most common and straightforward
    paths new developers generally take to deploy their applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有许多不同的部署平台，例如**亚马逊网络服务**（**AWS**）、**谷歌云平台**（**GCP**）、Azure和Heroku，每个平台都旨在满足多种需求。在这些平台中的每一个，都有许多解决方案，每个解决方案都有其各自的优缺点。对于这些解决方案中的每一个，我们都有许多方法可以在其中部署一个框架。本质上，部署解决方案的可能方式数量实际上是无法计数的，因此用户可能会感到容易不知所措。在本章的整个过程中，我们将探讨新开发者通常采取的一些最常见和最直接的方法来部署他们的应用程序。
- en: 'Throughout the following sections, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将涵盖以下主题：
- en: Exploring current cloud computing platforms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索当前的云计算平台
- en: Understanding containers and images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容器和镜像
- en: Tutorial – deploying a container to AWS (Lightsail)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程 – 将容器部署到AWS（Lightsail）
- en: Tutorial – deploying an application to GCP (App Engine)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程 – 将应用程序部署到GCP（App Engine）
- en: Tutorial – deploying an application's code to GitHub
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程 – 将应用程序代码部署到GitHub
- en: With these objectives in mind, let's go ahead and get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些目标，让我们继续前进，开始吧！
- en: Exploring current cloud computing platforms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索当前的云计算平台
- en: One of the most significant technology trends over the last few years has been
    the shift to cloud computing. Although most companies used to prefer to own, operate,
    and maintain their own data centers and infrastructure, most enterprises around
    the globe now maintain a cloud-first approach. There are many reasons as to why
    companies have moved down this path, such as reduced costs, scalability, security,
    and much more. Given the surge in demand for cloud computing capabilities, a number
    of cloud computing platforms began to grow and expand in the market in response
    to this major movement in the digital world.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，最显著的技术趋势之一是转向云计算。尽管大多数公司过去更喜欢拥有、运营和维护自己的数据中心和基础设施，但现在全球大多数企业都采用以云为先的方法。公司选择这条道路的原因有很多，比如成本降低、可扩展性、安全性等等。鉴于对云计算能力的需求激增，许多云计算平台开始响应这一数字世界的重大运动而增长和扩张。
- en: 'Over the last few years, many of these cloud computing platforms began to not
    only develop solutions to meet major infrastructure needs but also focus on targeted
    needs specifically within the field of data science. The main platforms are **AWS**,
    **GCP**, and **Microsoft Azure**, as depicted in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，许多这些云计算平台不仅开始开发解决方案以满足主要的基础设施需求，而且开始专注于数据科学领域内的特定需求。主要平台是**AWS**、**GCP**和**微软Azure**，如下面的图所示：
- en: '![Figure 12.1 – Some common cloud computing platforms ](img/B17761_12_001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 一些常见的云计算平台](img/B17761_12_001.jpg)'
- en: Figure 12.1 – Some common cloud computing platforms
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 一些常见的云计算平台
- en: Many companies around the world generally operate at the **enterprise** level
    with one of these providers for consistency. From the perspective of data scientists
    and developers, these platforms are nearly identical as they generally contain
    very similar solutions to meet our needs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地的许多公司通常以**企业级**的运营水平使用这些提供商之一来保持一致性。从数据科学家和开发者的角度来看，这些平台几乎相同，因为它们通常包含非常相似的工具来满足我们的需求。
- en: 'Each of these platforms includes numerous solutions designed to deploy frameworks
    and make them available to end users in some form. The degree to which these resources
    are provided to end users is generally the difference between these platforms.
    For example, a developer may expect high levels of activity for a given web application
    and may therefore decide to deploy their model using **AWS Elastic Beanstalk**
    or **Amazon** **Elastic Container Service** (**ECS**). On the other hand, another
    user may only wish to deploy their web application to a few users and in the simplest
    way possible and would therefore choose to use **Amazon Elastic Compute Cloud**
    (**EC2**). In any case, the specific solution a developer chooses is generally
    selected based on the specific need. Let''s go ahead and take a look at some of
    the most popular solutions out there, as depicted in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些平台中的每一个都包含了许多旨在部署框架并将它们以某种形式提供给最终用户的解决方案。这些资源提供给最终用户程度的不同，通常就是这些平台之间的区别。例如，开发者可能期望特定Web应用有很高的活动量，因此可能会决定使用**AWS
    Elastic Beanstalk**或**Amazon** **Elastic Container Service**（**ECS**）来部署他们的模型。另一方面，另一个用户可能只想以最简单的方式将他们的Web应用部署给少数用户，因此会选择使用**Amazon
    Elastic Compute Cloud**（**EC2**）。在任何情况下，开发者选择的特定解决方案通常是基于具体需求来选择的。让我们继续看看以下截图中所描述的一些最受欢迎的解决方案：
- en: '![Figure 12.2 – Some of the most common tools to deploy web applications ](img/B17761_12_002.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 部署Web应用的一些最常用工具](img/B17761_12_002.jpg)'
- en: Figure 12.2 – Some of the most common tools to deploy web applications
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 部署Web应用的一些最常用工具
- en: When it comes to deploying **Flask** applications, three deployment solutions
    have gained a great deal of traction in recent years within the data science community.
    Each of these solutions contains its respective pros and cons, and it is the responsibility
    of the data scientist or developer to ensure that the business needs for a given
    web application are matched to the best possible solution in any of these platforms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到部署**Flask**应用时，近年来在数据科学社区中，三种部署方案已经获得了很大的影响力。每个方案都有其各自的优缺点，确保特定Web应用的业务需求与这些平台中任何一个最佳解决方案相匹配，这是数据科学家或开发者的责任。
- en: As web applications began to increase in popularity, it soon became evident
    that consistency within the applications was needed to ensure that an application
    that a developer creates and deploys within one platform can be just as easily
    deployed in another platform with the smallest number of changes. In the following
    section, we will discuss the idea of containerization using an example known as
    **Docker**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web应用的普及，很快变得明显的是，应用内部的一致性是必要的，以确保开发者在某个平台上创建和部署的应用可以轻松地以最小的更改在另一个平台上部署。在下一节中，我们将通过一个名为**Docker**的例子来讨论容器化的概念。
- en: Understanding containers and images
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器和镜像
- en: One of the easiest ways to build, deploy, and manage a web application is through
    the use of **containers**. We can think of containers as buckets or vessels containing
    all items that make up a web application but in the form of an **Operating System**
    (**OS**) **virtualization**. Think back for a moment to the previous chapter—[*Chapter
    11*](B17761_11_Final_JM_ePub.xhtml#_idTextAnchor154), *Deploying Models with Flask*—in
    which we created a virtual environment to better maintain the packages we needed
    to install for the application. Containers can be thought of in quite a similar
    way, only on the OS level.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署Web应用的最简单方法之一是通过使用**容器**。我们可以将容器视为包含构成Web应用所有项目的桶或容器，但以**操作系统**（**OS**）**虚拟化**的形式。回想一下上一章——[*第11章*](B17761_11_Final_JM_ePub.xhtml#_idTextAnchor154)，*使用Flask部署模型*——我们在其中创建了一个虚拟环境来更好地维护为应用安装所需的包。容器可以以相当类似的方式思考，只是在操作系统级别。
- en: Containers consist of a number of items such as executables, libraries, binary
    code, and much more. Given that they do not contain some of the heavier items
    servers tend to have such as OS images, they are considered to have less overhead,
    making them more lightweight. Since these lightweight containers are considered
    to be packaged up and ready to go, developers (or automated systems) are able
    to easily deploy multiple instances of these containers to meet the needs of the
    increased traffic to a given website or application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 容器由许多项目组成，如可执行文件、库、二进制代码等等。鉴于它们不包含服务器通常具有的一些较重的项目，如操作系统镜像，因此被认为开销较小，更轻量。由于这些轻量级容器被认为是打包好并随时可用的，因此开发人员（或自动化系统）能够轻松部署多个容器实例以满足特定网站或应用增加的流量需求。
- en: Understanding the benefits of containers
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解容器的好处
- en: 'There are many benefits to using a container when managing and deploying web
    applications, especially at the enterprise scale. Ultimately, they provide a consistent
    and streamlined way to build, deploy, and manage multiple applications in an efficient
    manner. A few of the main benefits include the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理和部署Web应用时，使用容器有许多好处，尤其是在企业规模上。最终，它们提供了一种一致且高效的构建、部署和管理多个应用的方式。以下是一些主要好处：
- en: '**Greater scalability**—Easily deploy more instances to meet a given need.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更大的可扩展性**—轻松部署更多实例以满足特定需求。'
- en: '**Increased portability**—Deploy to different platforms and OSes.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可移植性**—部署到不同的平台和操作系统。'
- en: '**Reduced overhead**—Use fewer resources than traditional methods.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低开销**—比传统方法使用更少的资源。'
- en: Containers are highly effective in many different areas—two in particular fall
    within the scope of microservices and automation. In the case of microservices,
    applications are generally broken down into smaller components in which each component
    needs to be deployed and scaled independently of the others. It is no surprise
    that containers in this case would be an excellent solution for the given problem.
    On the other hand, in the case of automation, containers can be easily created
    or removed in an automated fashion, making them very useful for scalability, as
    well as for **Continuous Integration/Continuous Deployment** (**CI/CD**) pipelines.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在许多不同领域都非常有效——特别是两个领域属于微服务和自动化。在微服务的情况下，应用通常被分解成更小的组件，每个组件都需要独立于其他组件部署和扩展。在这种情况下，容器是解决该问题的绝佳解决方案并不令人惊讶。另一方面，在自动化的情况下，容器可以轻松地以自动化的方式创建或删除，这使得它们对于可扩展性以及**持续集成/持续部署**（**CI/CD**）管道非常有用。
- en: Important note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'We can think of CI/CD pipelines as methods to automate software delivery in
    order to standardize processes and reduce human error. There are generally four
    stages for any given CI/CD pipeline: new code being pushed to a repository such
    as GitHub (which we will see later in this chapter), a building script that builds
    or compiles the code, a testing script that tests certain parts of the code, and
    finally the deployment platform that hosts the final product.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将CI/CD管道视为自动化软件交付的方法，以标准化流程并减少人为错误。任何给定的CI/CD管道通常有四个阶段：将新代码推送到GitHub等存储库（我们将在本章后面看到），构建脚本构建或编译代码，测试脚本测试代码的某些部分，最后是托管最终产品的部署平台。
- en: In the following tutorial, we will explore the process of deploying a container—specifically,
    a Docker container—to AWS Lightsail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的教程中，我们将探讨部署容器的过程——具体来说，是将Docker容器部署到AWS Lightsail。
- en: Tutorial – deploying a container to AWS (Lightsail)
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 - 将容器部署到AWS（Lightsail）
- en: '**AWS Lightsail** is a managed cloud platform that has gained a great deal
    of popularity in recent years due to its simple interface and fast deployment
    capabilities and is overall a great way to get started when deploying applications
    using AWS. Some of the most common use cases for using Lightsail as opposed to
    other AWS products or solutions include simple **Machine Learning** (**ML**) web
    applications (such as ours!), static portfolio websites, and dynamic e-commerce
    websites, as well as simple APIs.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS Lightsail**是一个管理云平台，由于其简单的界面和快速的部署能力，近年来获得了极大的普及，并且是使用AWS部署应用时入门的绝佳方式。与AWS的其他产品或解决方案相比，使用Lightsail的一些最常见用例包括简单的**机器学习**（**ML**）Web应用（如我们的应用！），静态投资组合网站，动态电子商务网站，以及简单的API。'
- en: 'Over the course of this tutorial, we will deploy our Flask application to AWS
    Lightsail using the AWS **Command Line Interface** (**CLI**). You can install
    the CLI by navigating to the AWS CLI page ([https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html](https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html)),
    selecting an OS of interest, and following the installation instructions. You
    can confirm that the CLI was correctly installed by running the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程的过程中，我们将使用 AWS **命令行界面**（**CLI**）将我们的 Flask 应用程序部署到 AWS Lightsail。您可以通过访问
    AWS CLI 页面（[https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html](https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html)）来安装
    CLI，选择感兴趣的操作系统，并按照安装说明进行操作。您可以通过运行以下命令来确认 CLI 是否正确安装：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the installation was properly completed, you will be guided through the configuration
    process. Please go ahead and configure the CLI as needed. The process may request
    **Identity and Access Management** (**IAM**) credentials—go ahead and provide
    it with the proper credentials from our previous examples or prepare a new set
    of credentials, as we have previously done in [*Chapter 9*](B17761_09_Final_JM_ePub.xhtml#_idTextAnchor132),
    *Natural Language Processing*, specifically in the *Working with unstructured
    data* section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装完成正确，您将进入配置过程。请继续按照需要配置 CLI。此过程可能需要请求 **身份和访问管理**（**IAM**）凭据——请提供我们之前示例中的正确凭据，或者准备一套新的凭据，就像我们在
    [*第 9 章*](B17761_09_Final_JM_ePub.xhtml#_idTextAnchor132) 的 *自然语言处理* 部分，特别是 *处理非结构化数据*
    部分中所做的那样。
- en: 'With the CLI and credentials all set, let''s now once again focus on the application,
    starting with the content. If you recall from [*Chapter 11*](B17761_11_Final_JM_ePub.xhtml#_idTextAnchor154),
    *Deploying Models with Flask Applications*, the content of the application should
    now include the virtual environment, `styles.css`, `index.html`, and, of course,
    `app.py`, as depicted in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CLI 和凭据都设置好的情况下，现在让我们再次专注于应用程序，从内容开始。如果您还记得从 [*第 11 章*](B17761_11_Final_JM_ePub.xhtml#_idTextAnchor154)
    的 *使用 Flask 应用程序部署模型*，应用程序的内容现在应包括虚拟环境、`styles.css`、`index.html`，当然还有 `app.py`，如下面的截图所示：
- en: '![Figure 12.3 – The content of our current working directory ](img/B17761_12_003.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 当前工作目录的内容](img/B17761_12_003.jpg)'
- en: Figure 12.3 – The content of our current working directory
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 当前工作目录的内容
- en: In order to deploy our application, we will need a few more files that we will
    soon explore to help both with the deployment process and the containerization
    process. In addition to AWS Lightsail, we will also be using **Docker**—a commonly
    used tool that allows users to create, deploy, and run applications in isolated
    containers. You can download Docker for your specific OS by visiting the Docker
    website ([https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)).
    Let's go ahead and explore these new files, their content, and how they will be
    used within the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署我们的应用程序，我们还需要一些文件，我们将很快探索这些文件，以帮助部署过程和容器化过程。除了 AWS Lightsail，我们还将使用 **Docker**——这是一个常用的工具，允许用户在隔离的容器中创建、部署和运行应用程序。您可以通过访问
    Docker 网站下载适用于您特定操作系统的 Docker ([https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/))。让我们继续探索这些新文件，它们的内容以及它们如何在应用程序中使用。
- en: 'First, we begin with the Dockerfile, which contains a set of instructions to
    prepare the environment for the application. These instructions include the version
    of Python, establishing the working directory, copying the files of interest,
    and of course, installing the requirements. The code is illustrated in the following
    snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 Dockerfile 开始，它包含一系列准备应用程序环境的指令。这些指令包括 Python 版本、设置工作目录、复制感兴趣的文件，当然还有安装需求。代码如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the Dockerfile prepared, we can now go ahead and build the container image.
    We can build the container using Docker, which we installed earlier, by executing
    the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好的 Dockerfile 之后，我们现在可以继续构建容器镜像。我们可以使用之前安装的 Docker 来构建容器，通过执行以下命令：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Upon executing this command (don't forget the `.` at the end, which signifies
    the current directory!), Docker will build a container tagged as `flask-container`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令（不要忘记末尾的 `.`，它表示当前目录！）后，Docker 将构建一个标记为 `flask-container` 的容器。
- en: 'Our next step will be to create a container service using the AWS CLI. We can
    do this by executing the following code, in which we specify `service-name`, `power`,
    and `scale` parameters. Note that these parameters specify the capacity of the
    service:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步将使用AWS CLI创建一个容器服务。我们可以通过执行以下代码来完成此操作，其中我们指定了 `service-name`、`power` 和
    `scale` 参数。请注意，这些参数指定了服务的容量：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Upon executing this command, you should be able to monitor the progress. Once
    the service changes from a state of `pending` to `active`, you can execute the
    next command, which pushes the container image:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，你应该能够监控进度。一旦服务从 `pending` 状态变为 `active`，你可以执行下一个命令，该命令推送容器镜像：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Upon executing this command, you will see the following value in the results:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，你将在结果中看到以下值：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Please note that `X` should be a numeric value that corresponds to the time
    the image was pushed to the container service. If this is the first time you have
    done this, the value should be `1`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`X` 应该是一个与将镜像推送到容器服务时的时间相对应的数值。如果你是第一次这样做，该值应该是 `1`。
- en: 'Next, we will need to create a file called `containers.json`, specifying the
    Flask image as well as the port, containing the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个名为 `containers.json` 的文件，指定Flask镜像以及端口，包含以下代码：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Go ahead and replace `X` with the numerical value you received before. Again,
    if this is your first time deploying the container, the value should be `1`. With
    that done, we can now go ahead and create our final file called `public-endpoint.json`,
    which specifies the container name and port, containing the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `X` 替换为你之前收到的数值。再次提醒，如果你是第一次部署容器，该值应该是 `1`。完成这些后，我们现在可以继续创建我们的最终文件 `public-endpoint.json`，该文件指定了容器名称和端口，包含以下代码：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At this point, the hierarchy of the directory should include all of the previous
    files in addition to `containers.json`, `Dockerfile`, and `public-endpoint.json`,
    as depicted in the following figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，目录的层次结构应包括所有之前的文件，以及 `containers.json`、`Dockerfile` 和 `public-endpoint.json`，如图下所示：
- en: '![Figure 12.4 – The content of our current working directory ](img/B17761_12_004.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 当前工作目录的内容](img/B17761_12_004.jpg)'
- en: Figure 12.4 – The content of our current working directory
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 当前工作目录的内容
- en: 'Now that the files and containers are all in order, we can now proceed with
    the final steps of deploying the container to end users. In order to do so, we
    can use the `create-container-service-deployment` command with the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件和容器都已就绪，我们可以继续进行将容器部署给最终用户的最后步骤。为此，我们可以使用 `create-container-service-deployment`
    命令，以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon executing the code, you should see the state of the application be listed
    as `get-container-services` command to monitor the current application by executing
    the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，你应该会看到应用程序的状态被列为 `get-container-services` 命令，通过执行以下命令来监控当前应用程序：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Upon completion of the command, you will see a **Uniform Resource Locator**
    (**URL**) as output. Go ahead and navigate to the URL listed, and you should be
    able to see the application we developed online and available to our end users.
    We can see an example of this in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命令完成后，你将看到一个**统一资源定位符**（**URL**）作为输出。前往列出的URL，你应该能够看到我们开发的在线应用程序，并且可供我们的最终用户使用。以下是一个示例截图：
- en: '![Figure 12.5 – Web application running on AWS Lightsail ](img/B17761_12_005.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 在AWS Lightsail上运行的Web应用程序](img/B17761_12_005.jpg)'
- en: Figure 12.5 – Web application running on AWS Lightsail
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 在AWS Lightsail上运行的Web应用程序
- en: 'Alternatively, you may want to view the application using the management console
    on AWS. To do so, navigate the console and search for AWS Lightsail. You should
    be redirected to the AWS Lightsail page where you should see your instance and
    container, as depicted in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能想通过AWS上的管理控制台查看应用程序。为此，导航到控制台并搜索AWS Lightsail。你应该会被重定向到AWS Lightsail页面，在那里你应该能看到你的实例和容器，如图下所示：
- en: '![Figure 12.6 – AWS Lightsail management console ](img/B17761_12_006.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – AWS Lightsail管理控制台](img/B17761_12_006.jpg)'
- en: Figure 12.6 – AWS Lightsail management console
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – AWS Lightsail管理控制台
- en: In this tutorial, we successfully took our local implementation of Flask and
    deployed it as a web application to AWS. In the following tutorial, we will deploy
    the same application to GCP's App Engine.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们成功地将我们的本地Flask实现部署为Web应用程序到AWS。在下一个教程中，我们将部署相同的应用程序到GCP的App Engine。
- en: Tutorial – deploying an application to GCP (App Engine)
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 - 将应用程序部署到GCP（App Engine）
- en: Over the course of this tutorial, we will deploy the same application to GCP's
    App Engine. One of the biggest benefits of GCP relative to most other cloud platforms
    is its ease of use while ensuring users can deploy models with minimal problems
    and errors. With that in mind, let's go ahead and deploy our application to GCP.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将部署相同的应用程序到GCP的App Engine。与大多数其他云平台相比，GCP最大的好处是易于使用，同时确保用户可以以最小的问题和错误部署模型。考虑到这一点，让我们继续将我们的应用程序部署到GCP。
- en: 'We can begin by installing the `y` key, as shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从安装`y`键开始，如下所示：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will be redirected to your browser where you can log in using your Google
    account. Go ahead and log in using the same Google credentials you used in our
    previous adventure in [*Chapter 7*](B17761_07_Final_JM_ePub.xhtml#_idTextAnchor101),
    *Supervised Machine Learning*, concerning GCP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被重定向到浏览器，您可以使用您的Google账户登录。请使用与我们在上一章[*第7章*](B17761_07_Final_JM_ePub.xhtml#_idTextAnchor101)，“监督式机器学习”，关于GCP所使用的相同Google凭证登录。
- en: Once logged in, you will be prompted to select a project. Select the project
    you previously created earlier in this book. Go ahead and complete any other remaining
    items such as the default region, and finish up the configuration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您将被提示选择一个项目。选择您在本书中之前创建的项目。请继续完成任何其他剩余的项目，如默认区域，并完成配置。
- en: Once completed, you should have the `gcloud` CLI installed on your system. Be
    sure to restart the command-line window you are using, as some `PATH` variables
    may need to be refreshed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该在您的系统上安装了`gcloud` CLI。请确保重新启动您正在使用的命令行窗口，因为一些`PATH`变量可能需要刷新。
- en: 'With the CLI now installed and working, we can go ahead and get started. Navigate
    to the `flask_cancer_ae` directory found in the accompanying code. We will need
    to create a new file called `app.yaml` in our directory, containing the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在CLI已安装并运行，我们可以继续开始。导航到附带的代码中找到的`flask_cancer_ae`目录。我们需要在我们的目录中创建一个名为`app.yaml`的新文件，包含以下代码：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will simply specify the runtime for our application. With this file saved,
    we can go ahead and do some preliminary configuration. We will first need to set
    the project **Identifier** (**ID**), if we''ve not already done so, using the
    following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简单地指定我们应用程序的运行时间。保存此文件后，我们可以继续进行一些初步配置。我们首先需要设置项目**标识符**（**ID**），如果我们还没有这样做，可以使用以下命令：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Be sure to replace `GCP-PROJECT-ID` with your associated project ID. With that
    set, we will now need to enable the **Cloud Build CLI**, which is used to create
    a container for the application using our files, with the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将`GCP-PROJECT-ID`替换为您关联的项目ID。设置完成后，我们现在需要启用**Cloud Build CLI**，它用于使用我们的文件创建应用程序的容器，以下命令：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will initialize the application in **App Engine** for this particular
    project. We can do so using the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为此特定项目在**App Engine**中初始化应用程序。我们可以使用以下命令来完成：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Be sure to replace `GCP-PROJECT-ID` with your particular project ID. Finally,
    in order to go ahead and deploy the project, we can use the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将`GCP-PROJECT-ID`替换为您特定的项目ID。最后，为了继续部署项目，我们可以使用以下命令：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once the process is complete, the project will be deployed to GCP! We can check
    the application using the `browse` command, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦过程完成，项目将被部署到GCP！我们可以使用以下命令检查应用程序，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In addition to using the CLI, we can also visit the **App Engine dashboard**
    found in the GCP console to complete a number of tasks, such as the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用CLI之外，我们还可以访问GCP控制台中找到的**App Engine仪表板**以完成以下任务：
- en: Access the application.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问应用程序。
- en: Monitor traffic.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控流量。
- en: Review billing.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查账单。
- en: …and much more!
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: …以及更多！
- en: GCP has many wonderful capabilities, giving users a great experience when it
    comes to deploying applications, managing data, and monitoring traffic. If you
    are interested in learning more about GCP, I highly encourage you to follow and
    complete the many great tutorials provided by the GCP platform.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: GCP拥有许多令人惊叹的功能，在部署应用程序、管理数据和监控流量方面为用户提供极佳的体验。如果您对学习更多关于GCP感兴趣，我强烈建议您关注并完成GCP平台提供的许多优秀教程。
- en: 'With our application now deployed to GCP, our next step will be to explore
    a different way to send our code elsewhere: through the `git` CLI. In the following
    section, we will explore the process of pushing code to GitHub.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将应用程序部署到GCP，我们的下一步将是探索将我们的代码发送到其他地方的不同方式：通过`git` CLI。在下一节中，我们将探讨将代码推送到GitHub的过程。
- en: Tutorial – deploying an application's code to GitHub
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 教程 – 将应用程序代码部署到GitHub
- en: Over the last two tutorials, we deployed our applications to cloud platforms
    in order to allow users to interact with our models using the Flask framework.
    In the first platform, we used AWS Lightsail, and in the second, we used GCP's
    App Engine. In this tutorial, our objective will be to deploy our code, not with
    the intent of making the models available to users but to showcase our code and
    hard work to other data scientists, as well as potential future employers. We
    will do so by deploying our code using **GitHub**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两个教程中，我们将我们的应用程序部署到云平台，以便用户可以使用Flask框架与我们的模型进行交互。在第一个平台中，我们使用了AWS Lightsail，在第二个平台中，我们使用了GCP的App
    Engine。在这个教程中，我们的目标将是部署我们的代码，不是为了使模型对用户可用，而是为了向其他数据科学家以及潜在的未来雇主展示我们的代码和辛勤工作。我们将通过使用**GitHub**来部署我们的代码来实现这一点。
- en: All of the coding examples and tutorials throughout this book have been made
    available online using GitHub. If you have not done so already, I highly encourage
    you to create your own account. You can think of GitHub as LinkedIn for coders—a
    space to showcase your hard work to others.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有编码示例和教程都已通过GitHub在线提供。如果您还没有这样做，我强烈建议您创建自己的账户。您可以将GitHub视为程序员的LinkedIn——一个展示您辛勤工作的空间。
- en: You can create a free GitHub account by navigating to their main website ([https://github.com/](https://github.com/))
    and registering as a new user. Once you are registered, you will be able to save
    your code and work with projects or repositories. You can think of a repository
    as a space to save your work, with multiple versions being saved so that users
    can revert to older code when needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问他们的官方网站([https://github.com/](https://github.com/))并注册为新用户来创建一个免费的GitHub账户。一旦您注册成功，您就可以保存您的代码并与项目或仓库一起工作。您可以将仓库视为一个保存您工作的空间，其中保存了多个版本，以便用户在需要时可以回滚到旧代码。
- en: 'The way this works is that users will have an instance or copy of a given project
    or repository locally on their computers. Every now and then, when significant
    progress has been made, a user can make an update or commit, and then push those
    new changes to the remote repository for backup, as depicted in the following
    figure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式是用户将在他们的计算机上本地有一个给定项目或仓库的实例或副本。每当取得重大进展时，用户可以做出更新或提交，然后将这些新更改推送到远程仓库以进行备份，如图所示：
- en: '![Figure 12.7 – Local and remote repositories ](img/B17761_12_007.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 本地与远程仓库](img/B17761_12_007.jpg)'
- en: Figure 12.7 – Local and remote repositories
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 本地与远程仓库
- en: With your profile created, let's go ahead and install `git` on the command line.
    We can get things going by navigating to [https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
    and installing `git` for your given OS. You can confirm the installation was successful
    by running the `git` command on the command line, which should return a list of
    commands and possible parameters to use.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建好您的个人资料后，让我们继续在命令行上安装`git`。我们可以通过导航到[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)并为您的操作系统安装`git`来开始操作。您可以通过在命令行上运行`git`命令来确认安装是否成功，它应该会返回一个命令和可能的参数列表。
- en: 'Let''s go ahead and navigate to one of the applications we previously deployed
    using the command line. Depending on where in your local computer you created
    the application, your path may look similar to this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用命令行导航到我们之前部署的一个应用程序。根据您在本地计算机上创建应用程序的位置，您的路径可能看起来像这样：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Go ahead and navigate to your directory either through a command-line window
    or by using **Visual Studio Code** (**VSC**). Once there, go ahead and **initialize**
    a new repository using the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令行窗口或使用**Visual Studio Code**（**VSC**）导航到您的目录。一旦到达那里，使用以下命令**初始化**一个新的仓库：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the repository has been initialized, we will need to create a repository
    on your GitHub account (and later connect to it). We can do so using the following
    simple steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦仓库初始化完成，我们将在您的GitHub账户上创建一个仓库（稍后连接到它）。我们可以通过以下简单步骤来完成：
- en: Log in to your new **GitHub** account, as illustrated in the following screenshot:![Figure
    12.8 – GitHub login page ](img/B17761_12_008.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的新**GitHub**账户，如图所示：![图12.8 – GitHub登录页面](img/B17761_12_008.jpg)
- en: Figure 12.8 – GitHub login page
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.8 – GitHub登录页面
- en: On the main page, click the **New** button on the left-hand side of the screen,
    as illustrated in the following screenshot:![Figure 12.9 – Creating a new repository
    ](img/B17761_12_009.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主页面上，点击屏幕左侧的**新建**按钮，如图所示：![图12.9 – 创建新仓库](img/B17761_12_009.jpg)
- en: Figure 12.9 – Creating a new repository
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.9 – 创建新仓库
- en: 'Give the new repository a name, such as `flask-cancer-ls`. While leaving all
    other fields with their default values, go ahead and click **Create repository**,
    as illustrated in the following screenshot:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新仓库起一个名字，例如`flask-cancer-ls`。在保留所有其他字段为默认值的情况下，点击**创建仓库**，如图所示：
- en: '![Figure 12.10 – Creating a new repository (continued) ](img/B17761_12_010.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – 创建新仓库（继续）](img/B17761_12_010.jpg)'
- en: Figure 12.10 – Creating a new repository (continued)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 创建新仓库（继续）
- en: 'Once created, you will be redirected to a new page containing some sample code
    for you to use. Given that we have already created a new repository, we will not
    need to go through this again. If we head back to the command line, we can go
    ahead and run the following command to add our files to `git` to be `git` and
    allow it to determine any new changes that need to be sent to `add` command, like
    this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建完成，您将被重定向到一个新页面，其中包含一些供您使用的示例代码。鉴于我们已经创建了一个新的仓库，我们不需要再次进行这一步骤。如果我们回到命令行，我们可以继续运行以下命令，将我们的文件添加到`git`中，以便`git`确定需要发送到`add`命令的任何新更改，如下所示：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or, we could add all files using the period notation, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用点表示法添加所有文件，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is generally considered better practice to add files individually as you
    are less likely to run into errors. Trust me!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为，逐个添加文件是更好的做法，因为这样出错的可能性较小。请相信我！
- en: 'With the files added to the *staging area* using the `add` command, our next
    step is to commit them. We can think of the staging area as a space where we stage
    our new code that is about to be sent to the remote repository. We can do so using
    the `commit` command, followed by a useful message describing the current commit,
    as illustrated in the following code snippet. You can use messages to briefly
    describe the changes in your commit. This will make things much easier when looking
    back at older code, trying to find a specific change on the GitHub website:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add`命令将文件添加到**暂存区**后，我们的下一步是提交它们。我们可以将暂存区视为一个空间，用于存放即将发送到远程仓库的新代码。我们可以使用`commit`命令，并附上一个描述当前提交的有用消息，如下面的代码片段所示。您可以使用消息简要描述提交中的更改。这将使得在查看旧代码时，尝试在GitHub网站上找到特定的更改变得容易得多：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Upon executing this code, you may encounter an error asking you to specify
    your name and email address. Go ahead and complete this using the following commands:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，您可能会遇到一个错误，要求您指定您的姓名和电子邮件地址。请使用以下命令完成此操作：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With your credentials saved and your commit completed, we can now go ahead
    and link together our **local repository** and the **remote repository** using
    the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存您的凭据并完成提交后，我们现在可以继续使用以下命令将我们的**本地仓库**和**远程仓库**链接起来：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Be sure to replace `username` and `reponame` with your respective values! Once
    that is complete, you can go ahead and complete the final step, which is pushing
    your code to GitHub, using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将`username`和`reponame`替换为您各自的值！一旦完成，您可以继续完成最后一步，即使用以下命令将您的代码推送到GitHub：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With that step completed, if you navigate back to the GitHub website, you will
    be able to see your code here! Unlike the last two tutorials where we deployed
    our code in the form of an application to an online website available to end users
    to interact with, the objective here is to store our code and other content in
    a safe space. We have the option to allow other users to see our code or keep
    it private to ourselves. In addition, there are a number of platforms out there,
    such as Heroku, that are able to deploy an application simply by providing it
    with a link to the repository.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，如果你导航回GitHub网站，你将能够在这里看到你的代码！与最后两个教程不同，在那里我们将代码以应用程序的形式部署到在线网站，供最终用户交互，这里的目的是将我们的代码和其他内容存储在一个安全的空间中。我们有选择让其他用户看到我们的代码或将其保留为私有的选项。此外，还有一些平台，如Heroku，只需提供仓库链接，就能简单地部署应用程序。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we reviewed a number of ways to deploy our
    application to end users in the cloud. First, we explored the use of AWS Lightsail,
    which allowed us to deploy our code in the form of an online web application using
    a Docker container. Next, we explored the use of GCP's App Engine to deploy our
    code, once again in the form of an online web application, using its user-friendly
    and abstract methodologies. Finally, we deployed our code in the form of a repository
    to GitHub, allowing us to expose the content to users, professionals, and tentative
    employers alike.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了将我们的应用程序部署到云端最终用户的一些方法。首先，我们探讨了使用AWS Lightsail，它允许我们以在线Web应用程序的形式部署我们的代码，使用Docker容器。接下来，我们探讨了使用GCP的App
    Engine来部署我们的代码，再次以在线Web应用程序的形式，使用其用户友好和抽象的方法。最后，我们将代码以仓库的形式部署到GitHub，使我们能够向用户、专业人士和潜在的雇主
    alike 暴露内容。
- en: 'Congratulations! With this last tutorial now complete, we have come to the
    end of this book. Looking back at the last 12 chapters, we have covered many different
    topics in a diverse set of areas. In the beginning, we learned some new languages
    such as Python and **Structured Query Language** (**SQL**) and used them to analyze
    and visualize our data. We then explored some of the most common ML and **Deep
    Learning** (**DL**) architectures out there and used them to develop powerful
    predictive models. We then turned our attention to some specific areas of application,
    such as **Natural Language Processing** (**NLP**) and time series. Finally, we
    explored a few ways to deploy our applications to end users using AWS and GCP.
    Although we have covered a great deal of material within this book, there is still
    a vast galaxy of knowledge and information out there waiting for you. Before you
    move on to your next great adventure, there are three things you should always
    remember:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！随着本教程的最后部分完成，我们已到达这本书的结尾。回顾过去12章，我们在众多不同领域涵盖了众多不同主题。起初，我们学习了新的语言，如Python和**结构化查询语言**（**SQL**），并使用它们来分析和可视化我们的数据。然后，我们探索了最常见的一些机器学习（**ML**）和**深度学习**（**DL**）架构，并使用它们来开发强大的预测模型。接着，我们将注意力转向一些特定的应用领域，例如**自然语言处理**（**NLP**）和时间序列。最后，我们探索了几种使用AWS和GCP将我们的应用程序部署给最终用户的方法。尽管我们在本书中涵盖了大量的内容，但外面还有浩瀚的知识和信息宇宙等待你去探索。在你迈向下一个伟大冒险之前，有三件事你应该永远记住：
- en: The simplest solutions are often the best solutions. Never overcomplicate a
    model if you don't need to.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的解决方案通常是最好的解决方案。如果你不需要，永远不要过度复杂化模型。
- en: Never ever stop learning. We live in a digital age where new discoveries are
    being achieved faster than ever.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要停止学习。我们生活在一个数字时代，新的发现正以前所未有的速度实现。
- en: Metrics are your best friend. They will guide you throughout development and
    will help you make your arguments as a data scientist. Remember—everything is
    a sales pitch.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标是你的最佳朋友。它们将引导你贯穿整个开发过程，并帮助你作为数据科学家提出论点。记住——一切都是推销。
- en: With these three things now in mind, go forth and do data science!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了这三件事，勇敢地去做数据科学吧！
