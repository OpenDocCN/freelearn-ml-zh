- en: Temporal and Sequential Pattern Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间和顺序模式发现
- en: Many of us have visited retail shops such as Reliance and Walmart for our household
    needs. Let's say that we are planning to buy an iPhoneX from Reliance Digital.
    What we would typically do is search for the model by visiting the mobile section
    of the store, and then select the product and head toward the billing counter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人为了家庭需求去过像Reliance和Walmart这样的零售商店。假设我们计划从Reliance Digital购买一部iPhoneX。我们通常会做的是访问商店的移动部门，搜索型号，然后选择产品并前往结账柜台。
- en: But, in today's world, the goal of the organization is to increase revenue.
    Can this be done by pitching just one product at a time to the customer? The answer
    is a clear **no**. Hence, organizations began mining data relating to frequently
    bought items. They try to find out associations between different items and products
    that can be sold together, which gives assisting in right product placement. Typically,
    it figures out what products are being bought together and organizations can place
    products in a similar manner.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在当今世界，组织的目标是增加收入。这仅仅通过一次向客户推销一个产品就能实现吗？答案是明确的**不**。因此，组织开始挖掘与频繁购买项目相关的数据。他们试图找出不同项目之间的关联，以及可以一起销售的产品，这有助于正确的产品定位。通常，它会找出哪些产品是共同购买的，组织可以以类似的方式摆放产品。
- en: This is what we are going to talk about in this chapter. How do we come up with
    such rules by means of machine learning? We will discuss number of techniques
    here.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本章中讨论的内容。我们如何通过机器学习手段制定这样的规则？我们将在这里讨论多种技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Association rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联规则
- en: Frequent pattern growth
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁模式增长
- en: Validation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Association rules
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联规则
- en: Association rule mining is a technique that focuses upon observing frequently
    occurring patterns and associations from datasets found in databases such as relational
    and transactional databases. These rules do not say anything about the preferences
    of an individual; rather, they rely chiefly on the items within transactions to
    deduce a certain association. Every transaction is identified by a primary key
    (distinct ID) called, **transaction ID**. All these transactions are studied as
    a group and patterns are mined.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则挖掘是一种技术，它关注于从数据库中观察频繁出现的模式和关联，如关系数据库和事务数据库。这些规则并没有说任何关于个人偏好的内容；相反，它们主要依赖于交易中的项目来推断某种关联。每个交易都有一个主键（唯一的ID），称为，**交易ID**。所有这些交易都被作为一个整体进行研究，并从中挖掘模式。
- en: 'Association rules can be thought of as an **if—then** relationship. Just to
    elaborate on that, we have to come up with a rule: **if** an item **A** is being
    bought by the customer, **then** the chances of item **B** being picked by the
    customer too under the same transaction ID (along with item **A**) is found out.
    You needs to understand here that it''s not a causality, rather, it is co-occurrence
    pattern that comes to the fore.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则可以被视为一个**如果—那么**的关系。为了详细阐述这一点，我们必须制定一条规则：**如果**客户购买了一个项目**A**，**那么**在相同的交易ID下（与项目**A**一起），客户选择项目**B**的概率被找到。在这里，你需要理解这不是因果关系，而是一种共现模式，它浮出水面。
- en: 'There are two elements of these rules:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则有两个要素：
- en: '**Antecedent (if)**: This is an item/group of items that are typically found
    in the itemsets or datasets'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前件（如果）**：这是通常在项集或数据集中找到的项目/项目组'
- en: '**Consequent (then)**: This comes along as an item with an antecedent/group
    of antecedents'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后件（那么）**：这是一个与前件/前件组一起出现的项目'
- en: 'Have a look at the following rule:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下规则：
- en: '*{Bread, milk} ⇒ {Butter}*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*{面包，牛奶} ⇒ {黄油}*'
- en: The first part of this rule is called **antecedent** and the second part (after
    the arrow) is **consequent**. It is able to convey that there is a chance of *Butter* being
    picked in a transaction if *Bread* and  *Milk* are picked earlier. However, the
    percentage chance for the consequent to be present in an itemset, given the antecedent,
    is not clear.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则的第一个部分被称为**前件**，第二个部分（在箭头之后）是**后件**。它能够传达在交易中如果先选择了*面包*和*牛奶*，那么选择*黄油*的可能性。然而，给定前件，后件在项集中出现的百分比概率并不明确。
- en: 'Let''s look at a few metrics that will help us in getting there:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些有助于我们达到目标的指标：
- en: '**Support**: This is a measure of the frequency of the itemset in all the transactions.
    For example, there are two itemsets popping up through the number of transactions
    for a retail outlet such as Walmart: itemset *A = {Milk}*, itemset *B = {laptop}*.
    Given that support is how frequent the itemset is in all the transactions, we
    are asked to find out which itemset has got the higher support. We know that itemset
    *A* will have higher support because *Milk* features in everyday grocery lists
    (and, in turn, the transaction) at a greater probability than *laptop*. Let''s
    add another level of association and study with two new itemsets: itemset *A=
    {milk, cornflakes}*, itemset *B= {milk, USB Drive}*. The purchasing frequency
    of *milk* and *cornflakes* together will be higher than *milk and USB Drive*.
    It will make the support metric higher for *A*.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**支持度**：这是度量项目集在所有交易中的频率。例如，通过零售店如沃尔玛的交易数量，会出现两个项目集：项目集*A = {Milk}*)，项目集*B
    = {laptop}*)。鉴于支持度是项目集在所有交易中的频率，我们需要找出哪个项目集具有更高的支持度。我们知道项目集*A*将具有更高的支持度，因为*Milk*出现在日常杂货清单（以及交易）中的概率比*laptop*更高。让我们增加一个关联级别，并使用两个新的项目集进行研究：项目集*A=
    {milk, cornflakes}*)，项目集*B= {milk, USB Drive}*)。*milk*和*cornflakes*一起的购买频率将高于*milk
    and USB Drive*。这将使*A*的支持度指标更高。'
- en: 'Let''s translate this into mathematics:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这转化为数学表达式：
- en: '*Support(A, B) = Transactions comprising A and B/Total number of transactions*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*支持度(A, B) = 包含A和B的交易/总交易数*'
- en: 'Here''s an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: The total number of transactions is 10,000
  id: totrans-22
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总交易数是10,000
- en: Transactions comprising *A* and *B = 500*
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含*A*和*B*的交易 = 500*
- en: Then support *(A, B) = 500/10000= 0.05*
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，支持度*(A, B) = 500/10000= 0.05*
- en: 5% of transactions contain *A* and *B* together
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5%的交易包含*A*和*B*一起
- en: '**Confidence**: This indicates how likely item 1 is to be purchased/picked
    when item 2 is already picked. In other words, it measures the likelihood of the
    occurrence of consequent transactions given that the antecedent is already there
    in the transaction. In other words, it is the probability of the occurrence of
    *Butter* in the transaction if *Bread* has already been part of that transaction.
    It is quite clear that it is a conditional probability of the occurrence of the
    consequent while having the antecedent:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**信心**：这表示当项目2已经被选中时，项目1被购买/选中的可能性。换句话说，它衡量的是在先导交易已经存在的情况下，后续交易发生的可能性。换句话说，如果*Bread*已经参与了该交易，那么它衡量的是交易中发生*Butter*的概率。很明显，这是在具有先导条件的情况下，后续事件发生的条件概率：'
- en: '*Confidence(A ⇒ B) = Transactions comprising A and B/Transactions comprising
    A*'
  id: totrans-27
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心(A ⇒ B) = 包含A和B的交易/包含A的交易*'
- en: '*Confidence can be transformed in terms of support*'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心可以转换为支持度*'
- en: '*Confidence(A ⇒ B) = Support(A, B)/Support(A)*'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心(A ⇒ B) = 支持度(A, B)/支持度(A)*'
- en: 'Here''s an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: Transactions with the itemset as *milk = 50*
  id: totrans-31
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含项目集*milk*的交易 = 50*
- en: Transactions with the itemset as *cereal = 30*
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含项目集*cereal*的交易 = 30*
- en: Transactions comprising *milk* and *cereal = 10*
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含*milk*和*cereal*的交易 = 10*
- en: Total number of transactions = 100
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总交易数 = 100
- en: '*Confidence(milk ⇒ Cereal) = 10/(50 +10) = 0.167*'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心(milk ⇒ Cereal) = 10/(50 +10) = 0.167*'
- en: It means that there is 16.7% probability of that event taking place.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该事件发生的概率是16.7%。
- en: A drawback of the confidence is it only accounts for how popular item 1 is,
    but not item 2\. If item 2 is equally frequent, there will be a higher chance
    that a transaction containing item 1 will also contain item 2\. Hence, it will
    result in an inflated outcome. To account for the frequency of both constituent
    items, we use a third measure called **lift**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 信心的一个缺点是它只考虑了项目1的流行程度，但没有考虑项目2。如果项目2同样频繁，那么包含项目1的交易也包含项目2的可能性会更高。因此，这会导致结果被夸大。为了考虑两个构成项目的频率，我们使用一个称为**提升**的第三个度量。
- en: '**Lift**: This is an indicator of how likely it is that item B will be picked
    in the cart/transaction, given that item *A* is already picked, while keeping
    a tab on the frequency of item *B.* A lift value greater than 1 says that there
    is a great association between item *A* and item *B,* which implies that there
    is a good chance that item *B* will be picked if item *A* is already in the cart.
    A lift value of less than 1 means that the chances are slim that item *B* will
    be picked if item *A* is already present. If the lift value hits zero, it means
    no association can be established here.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提升度**：这是指在项目 *A* 已经被选中时，项目 *B* 被选中的可能性，同时关注项目 *B* 的频率。提升度大于1表示项目 *A* 和项目
    *B* 之间有很强的关联，这意味着如果项目 *A* 已经在购物车中，那么项目 *B* 被选中的可能性很大。提升度小于1表示如果项目 *A* 已经存在，项目
    *B* 被选中的可能性很小。如果提升度为零，则表示无法建立任何关联。'
- en: '*Lift(A⇒B) = (Transactions comprising A and B/(Transactions comprising A))/fraction
    of Transaction comprising B*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lift(A⇒B) = (包含A和B的事务数/(包含A的事务数))/包含B的事务数*'
- en: 'Implies:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着：
- en: '*= Support(A, B)/(Support(A) * Support(B))*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*= Support(A, B)/(Support(A) * Support(B))*'
- en: '*Lift(milk⇒cereal) = ( 10/(50+10))/0.4*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lift(牛奶⇒麦片) = ( 10/(50+10))/0.4*'
- en: '*= 0.416*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*= 0.416*'
- en: We will see this in a better format here. The probability of having cereal in
    the cart with the knowledge that milk is already in the cart (which is called
    **confidence**) = *10/(50+10) = 0.167.*
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里以更好的格式展示它。在知道牛奶已经在购物车中的情况下，购物车中有麦片的概率（称为**置信度**）= *10/(50+10) = 0.167*。
- en: The probability of having cereal in the cart without the knowledge that milk
    is in the *cart = (30+10)/100 = 0.4*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在不知道牛奶在购物车中的情况下，购物车中有麦片的概率为 *cart = (30+10)/100 = 0.4*.
- en: It means that having knowledge that milk is already in the cart reduces the
    chance of picking cereal from *0.4* to *0.167*. It is a lift of *0.167/0.4= 0.416*
    and is less than *1*. Hence, the chances of picking cereal while milk is already
    in the cart are very small.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着知道牛奶已经在购物车中，将选择麦片的机会从 *0.4* 降低到 *0.167*。提升度为 *0.167/0.4= 0.416*，并且小于 *1*。因此，当牛奶已经在购物车中时，选择麦片的机会非常小。
- en: Apriori algorithm
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apriori算法
- en: Apriori is a classical algorithm that is used to mine frequent itemsets to derive
    various association rules. It will help set up a retail store in a much better
    way, which will aid revenue generation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori是一种经典的算法，用于挖掘频繁项集以推导出各种关联规则。它将帮助以更好的方式设置零售店，从而有助于增加收入。
- en: 'The anti-monotonicity of the support measure is one of the prime concepts around
    which Apriori revolves. It assumes the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 支持度测量的反单调性是Apriori围绕的核心概念之一。它假设以下内容：
- en: All subsets of a frequent itemset must be frequent
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个频繁项集的所有子集都必须是频繁的
- en: Similarly, for any infrequent itemset, all its supersets must be infrequent
    too
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，对于任何不频繁的项集，它的所有超集也必须是不频繁的
- en: 'Let''s look at an example and explain it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子并解释它：
- en: '| **Transaction ID** | **Milk** | **Butter** | **Cereal** | **Bread** | **Book**
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **事务ID** | **牛奶** | **黄油** | **麦片** | **面包** | **书籍** |'
- en: '| t1 | 1 | 1 | 1 | 0 | 0 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| t1 | 1 | 1 | 1 | 0 | 0 |'
- en: '| t2 | 0 | 1 | 1 | 1 | 0 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| t2 | 0 | 1 | 1 | 1 | 0 |'
- en: '| t3 | 0 | 0 | 0 | 1 | 1 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| t3 | 0 | 0 | 0 | 1 | 1 |'
- en: '| t4 | 1 | 1 | 0 | 1 | 0 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| t4 | 1 | 1 | 0 | 1 | 0 |'
- en: '| t5 | 1 | 1 | 1 | 0 | 1 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| t5 | 1 | 1 | 1 | 0 | 1 |'
- en: '| t6 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| t6 | 1 | 1 | 1 | 1 | 1 |'
- en: We have got the transaction ID and items such as milk, butter, cereal, bread,
    and book. 1 denotes that item is part of the transaction and 0 means that it is
    not.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了事务ID和如牛奶、黄油、麦片、面包和书籍等项目。1表示项目是事务的一部分，0表示它不是。
- en: 'We came up with a frequency table for all the items along, with support (division
    by 6):'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为所有项目创建了一个频率表，包括支持（除以6）：
- en: '| **Items** | **Number of transactions** | **Support** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **项目** | **事务数量** | **支持度** |'
- en: '| Milk | 4 | 67% |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 牛奶 | 4 | 67% |'
- en: '| Butter | 5 | 83% |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 黄油 | 5 | 83% |'
- en: '| Cereal | 4 | 67% |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 麦片 | 4 | 67% |'
- en: '| Bread | 4 | 67% |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 面包 | 4 | 67% |'
- en: '| Book | 3 | 50% |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 书籍 | 3 | 50% |'
- en: 'We will put a threshold of support at 60%, which will filter out the items
    by frequency as these are the ones that can be addressed as frequent itemsets
    in this scenario:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将设置一个支持度阈值为60%，这将根据频率过滤项目，因为这些项目可以被视为此场景中的频繁项集：
- en: '| **Items** | **Number of transactions** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **项目** | **事务数量** |'
- en: '| Milk | 4 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 牛奶 | 4 |'
- en: '| Butter | 5 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 黄油 | 5 |'
- en: '| Cereal | 4 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 麦片 | 4 |'
- en: '| Bread | 4 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 面包 | 4 |'
- en: 'Similarly, we form the number of combinations (two at a time, three at a time,
    and four at a time) with these items and find out frequencies:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们用这些项目形成组合数（每次两个、三个和四个），并找出频率：
- en: '| **Items** | **Number of transactions** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **项目** | **交易数量** |'
- en: '| Milk, Butter | 4 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 牛奶，黄油 | 4 |'
- en: '| Milk, Cereal | 3 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 牛奶，谷物 | 3 |'
- en: '| Milk, Bread | 2 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 牛奶，面包 | 2 |'
- en: '| Butter, Bread | 3 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 黄油，面包 | 3 |'
- en: '| Butter, Cereal | 4 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 黄油，谷物 | 4 |'
- en: '| Cereal, Bread | 2 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 谷物，面包 | 2 |'
- en: Now, again, we have to find out the support for the preceding examples and filter
    them by threshold, which is support at 60%
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们再次需要找出前面示例的支持度，并通过阈值进行过滤，即支持度为60%
- en: Similarly, the combinations have to be formed with three items at a time (for
    example, Milk, Butter, and Bread) and support needs to be calculated for them.
    And, finally, we will filter them out by threshold. The same process needs to
    be done by doing four items at a time. The step that we have done till now is
    called **frequent itemset generation**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，必须一次形成三个项目的组合（例如，牛奶、黄油和面包），并计算它们的支持度。最后，我们将通过阈值过滤它们。同样，需要通过每次四个项目的方式执行相同的过程。我们到目前为止所做的是**频繁项集生成**。
- en: Finding association rules
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找关联规则
- en: 'In order to find the association rules, we have to first search for all of
    the rules that have support greater than the threshold support. But the question
    arises: how do we find these? A possible way to find this is by brute force, which
    means to list all the possible association rules and calculate the support and
    confidence for each rule. Later, remove all the rules that fail the confidence
    and support thresholds.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到关联规则，我们首先需要搜索所有支持度大于阈值支持度的规则。但是问题来了：我们如何找到这些规则？一种可能的方法是暴力搜索，这意味着列出所有可能的关联规则，并计算每个规则的支持度和置信度。然后，移除所有未通过置信度和支持度阈值的规则。
- en: Given there are *n* items in the set* I*, the total number of possible association
    rules is *3^n - 2^(n+1) + 1*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设集合* I*中有*n*个元素，可能的关联规则总数为*3^n - 2^(n+1) + 1*。
- en: If *X* is a frequent itemset with *k* elements, then there are *2^k - 2* association
    rules.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*X*是一个包含*k*个元素的频繁项集，那么将存在*2^k - 2*个关联规则。
- en: 'Let''s see how to execute association rules in Python:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Python中执行关联规则：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we are asking for an item to appear three times in a day for seven days''
    time, the support will be *3 x 7/7051*. *7051* is the total number of transactions.
    We will keep the confidence as 20% in the beginning:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要求一个项目在一天内出现三次，在七天时间内，支持度将是*3 x 7/7051*。*7051*是交易总数。我们最初将置信度设置为20%：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can visualize the output by running the `results` command from the preceding
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行前面代码中的`results`命令来可视化输出：
- en: '![](img/fc03af0b-27fb-4b45-b579-87be6c9ecb77.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc03af0b-27fb-4b45-b579-87be6c9ecb77.png)'
- en: Frequent pattern growth
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频繁模式增长
- en: '**Frequent pattern growth** (**FP-growth**) is a frequent itemset generation
    technique (similar to Apriori). FP-Growth builds a compact-tree structure and
    uses the tree for frequent itemset mining and generating rules. It is faster than
    Apriori and can throw results with large datasets.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**频繁模式增长**（**FP-growth**）是一种频繁项集生成技术（类似于Apriori）。FP-Growth构建一个紧凑的树结构，并使用该树进行频繁项集挖掘和生成规则。它比Apriori更快，并且可以处理大型数据集。'
- en: 'Let''s go through the steps of FP-Growth:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过FP-Growth的步骤来了解：
- en: '**Setting up the transactions**: This step sets up the items by frequency.
    However, the items are set up vertically, not horizontally. That means transforming
    input from transaction to items:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置事务**：这一步按频率设置项目。但是，项目是垂直设置的，而不是水平设置。这意味着将输入从事务转换为项目：'
- en: '| **t_id** | **Items** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **t_id** | **项目** |'
- en: '| 1 | (B, C, D, A) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 1 | (B, C, D, A) |'
- en: '| 2 | (B, C, D) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 2 | (B, C, D) |'
- en: '| 3 | (D, A) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 3 | (D, A) |'
- en: '| 4 | (A, B) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 4 | (A, B) |'
- en: '| 5 | (A, C, B) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 5 | (A, C, B) |'
- en: '**Finding the frequency**: Now we have to find out the frequency of each item
    individually:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查找频率**：现在我们必须找出每个项目的单独频率：'
- en: '| **Items** | **Frequency** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **项目** | **频率** |'
- en: '| A | 4 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| A | 4 |'
- en: '| B | 4 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| B | 4 |'
- en: '| C | 3 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| C | 3 |'
- en: '| D | 3 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| D | 3 |'
- en: 'Let''s set up the minimum threshold or minimum support as 50%:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置最小阈值或最小支持度为50%：
- en: Min Support = (5*50/100) = 2.5
  id: totrans-111
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小支持度 = (5*50/100) = 2.5
- en: Ceiling of minimum support = 2.5 ~ 3
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小支持度的上限 = 2.5 ~ 3
- en: '**Prioritize the items by frequency**: Since all the items have a frequency
    greater than or equal to minimum support, all the items will be part of it. Also,
    based on their frequency, priority or rank will be assigned to the items:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按频率优先排序项目**：由于所有项目的频率都大于或等于最小支持度，所有项目都将包含在内。此外，根据它们的频率，将分配优先级或排名给项目：'
- en: '| **Items** | **Frequency** | **Rank** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **项目** | **频率** | **排名** |'
- en: '| A | 4 | 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| A | 4 | 1 |'
- en: '| B | 4 | 2 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| B | 4 | 2 |'
- en: '| C | 3 | 3 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| C | 3 | 3 |'
- en: '| D | 3 | 4 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| D | 3 | 4 |'
- en: 'The order of the items is: A, B, C, and D (by frequency in descending order)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的顺序是：A、B、C 和 D（按频率降序排列）
- en: '**Ordering the items by priority**: Now the order of items will be set according
    to the priority given to various items based on frequency. Currently, the order
    is A, B, C, and D:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**按优先级排序项目**：现在，项目的顺序将根据基于频率分配给各种项目的优先级来设置。目前，顺序是 A、B、C 和 D：'
- en: '| **t_id** | **Items** | **Order by priority** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **t_id** | **Items** | **Order by priority** |'
- en: '| 1 | (B, C, D, A) | (A, B, C, D) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 1 | (B, C, D, A) | (A, B, C, D) |'
- en: '| 2 | (B, C, D) | (B, C, D) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 2 | (B, C, D) | (B, C, D) |'
- en: '| 3 | (D, A) | (A, D) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 3 | (D, A) | (A, D) |'
- en: '| 4 | (A, B) | (A, B) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 4 | (A, B) | (A, B) |'
- en: '| 5 | (A, C, B) | (A, B, C) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 5 | (A, C, B) | (A, B, C) |'
- en: Frequent pattern tree growth
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 频繁模式树增长
- en: 'We will study the different frequent pattern tree growth from the following
    rows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下行研究不同的频繁模式树的增长：
- en: '**Row 1**: Every FP-Tree starts with a null node as a root node. Let''s draw
    the first row of the tree order along with their frequency:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一行**: 每个FP-树都以一个空节点作为根节点。让我们绘制树的第一个行及其频率：'
- en: '![](img/6018c3aa-74dd-46d3-97ba-c8cfb4792d04.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6018c3aa-74dd-46d3-97ba-c8cfb4792d04.png)'
- en: '**Row 2**: It has got *{B,C,D}*. *A* is missing, so we can not merge it with
    the earlier node. Hence, we will have to create another node, altogether as shown
    here:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二行**: 它包含 *{B,C,D}*。*A* 缺失，所以我们不能将其与前面的节点合并。因此，我们必须创建另一个节点，整体情况如下所示：'
- en: '![](img/64811bcc-9002-4203-a764-0e28f7b0d86b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64811bcc-9002-4203-a764-0e28f7b0d86b.png)'
- en: '**Row 3**: It has got *{A,D}*. *B* and *C* are missing, but we can tie it with
    the earlier node. *A* encounters a repetition, so frequency will change. It becomes
    *2* now:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三行**: 它包含 *{A,D}*。*B* 和 *C* 缺失，但我们可以将其与前面的节点绑定。*A* 遇到重复，因此其频率将发生变化。现在变为
    *2*：'
- en: '![](img/7e0a0970-2717-4b76-ba4a-722a683fa292.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e0a0970-2717-4b76-ba4a-722a683fa292.png)'
- en: '**Row 4**: It has got *{A,B}*. We can tie it with the earlier node and will
    traverse on the previous node. *A* and *B* encounters a repetition, so frequency
    will change for it. It becomes 3 and 2 respectively:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四行**: 它包含 *{A,B}*。我们可以将其与前面的节点绑定，并将遍历应用于前面的节点。*A* 和 *B* 遇到重复，因此其频率将发生变化。分别变为
    3 和 2：'
- en: '![](img/bbb3d66b-ce39-4fff-bcdf-9af564cfb132.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bbb3d66b-ce39-4fff-bcdf-9af564cfb132.png)'
- en: '**Row 5**: It has got *{A,B,C}*. Again, it can be tied with the earlier node
    and A, B, and C see a repetition, so the frequency will change for them. It becomes
    4, 3, and 2 respectively:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第五行**: 它包含 *{A,B,C}*。再次，它可以与前面的节点绑定，并且 A、B 和 C 出现重复，因此它们的频率将发生变化。分别变为 4、3
    和 2：'
- en: '![](img/53cfa7ef-1d4e-48a0-83bc-52cf57af72bc.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53cfa7ef-1d4e-48a0-83bc-52cf57af72bc.png)'
- en: Validation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'Now, let''s count the frequency of the final tree that we have got and compare
    the frequency of each item with the table to ensure that we have got the correct
    frequencies in the table:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们计算我们得到的最终树的频率，并将每个项目的频率与表格进行比较，以确保我们在表格中得到了正确的频率：
- en: '**A:4**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A:4**'
- en: '**B:4**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B:4**'
- en: '**C:3**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C:3**'
- en: '**D:3**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D:3**'
- en: 'Now we will go from bottom to top. We will find out the branches where D appears:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从底部到顶部进行。我们将找出 D 出现的分支：
- en: '![](img/613380ab-1fe4-4529-8db5-b1527163ee34.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/613380ab-1fe4-4529-8db5-b1527163ee34.png)'
- en: 'We can see that there are three branches where D appears:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有三个分支中出现了 D：
- en: 'BC: 1'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BC: 1'
- en: 'ABC: 1'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ABC: 1'
- en: 'A: 1'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'A: 1'
- en: 'These branches are termed as conditional pattern base for D. While we do this,
    there are points to be kept in mind:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分支被称为 D 的条件模式基。当我们这样做时，有一些要点需要注意：
- en: Even if we traverse from bottom to top, we write the branches in a top-to-bottom
    manner
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们从底部向上遍历，我们也以从上到下的方式编写分支
- en: D is not part of it
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D 不是其中的一部分
- en: 1 represents the frequency of occurrence of D in each branch
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 代表每个分支中 D 发生的频率
- en: Now, the conditional pattern for D results in the conditional frequencies for
    A, B, and C, which are 2, 2, and 2\. All are less than the minimum support (3).
    Hence, there can't be any conditional FP- Tree for it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，D 的条件模式导致 A、B 和 C 的条件频率，分别是 2、2 和 2。所有这些都小于最小支持度（3）。因此，不能为它创建任何条件 FP-树。
- en: 'Now, let''s do it for C. C is appears in the following branches:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对 C 进行操作。C 出现在以下分支中：
- en: '![](img/c42a910a-7183-4359-a62e-77209960285c.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c42a910a-7183-4359-a62e-77209960285c.png)'
- en: 'The branches end up like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 分支最终如下所示：
- en: B:1
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B:1
- en: AB:2
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AB:2
- en: 'It results in A:2 and B:3\. So, B fit with the bill in accordance with the
    minimum support. Now the conditional tree ends up like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致 A:2 和 B:3。因此，根据最小支持度，B 符合条件。现在条件树最终如下所示：
- en: '![](img/ede86a39-0990-469c-96e9-89dac495cb1b.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ede86a39-0990-469c-96e9-89dac495cb1b.png)'
- en: Similarly, conditional pattern finding is done for different combinations. Thus,
    it sets up the frequent item dataset.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于不同的组合进行条件模式查找。因此，它建立了频繁项集数据集。
- en: Let's see how it can be done in Python. We will be using a library called `pyfpgrowth`.
    Also, we shall create an itemset in the following section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Python中实现。我们将使用一个名为`pyfpgrowth`的库。此外，我们将在下一节创建一个项集。
- en: Importing the library
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入库
- en: 'In order to perform validation we will import the library and build the transactions
    as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行验证，我们将导入库并构建如所示的交易：
- en: '[PRE2]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We build our transactions like so:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建我们的交易如下：
- en: '[PRE3]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Minimum support is defined now to find the pattern. `find_frequent_patterns()`*,*
    where `transactions` are the list of items bought at each transaction, and `2`
    is the minimum threshold set for support count:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义最小支持度以找到模式。`find_frequent_patterns()`，其中`transactions`是每次交易中购买的项目列表，`2`是设置的最小支持度阈值：
- en: '[PRE4]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we have to define the confidence to get the rules. Rules are generated
    based on the patterns and `0.5` is the minimum threshold set for confidence. Then,
    we store the rules in a dataframe named `rules`. `rules` initially consists of
    an antecedent, a consequent, and the confidence value:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须定义置信度以获取规则。规则是基于模式生成的，`0.5`是置信度的最小阈值。然后，我们将规则存储在名为`rules`的数据框中。`rules`最初包含一个前件、一个后件和置信度值：
- en: '[PRE5]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We get the output as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![](img/af558284-73fa-4c72-a90e-b8fcf6389188.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af558284-73fa-4c72-a90e-b8fcf6389188.png)'
- en: This is how we get the rules. FP-growth tends to have the edge over Apriori
    as it is faster and more efficient.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们获取规则的方式。FP-growth通常比Apriori有优势，因为它更快、更高效。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have studied association rules. We also discussed the Apriori
    algorithm, which is used for mining frequent itemsets to derive various association
    rules. We also learned about frequent pattern growth (FP-growth), which is similar
    to Apriori and about the frequent itemset generation technique, which is similar
    to the Apriori algorithm. Finally, we saw how FP-growth tends to have an edge
    over Apriori, as it is faster and more efficient, using an example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关联规则。我们还讨论了Apriori算法，该算法用于挖掘频繁项集以推导出各种关联规则。我们还了解了频繁模式增长（FP-growth），它与Apriori类似，以及频繁项集生成技术，它与Apriori算法类似。最后，我们看到了FP-growth如何比Apriori有优势，因为它更快、更高效，并通过一个例子来说明。
- en: In the next chapter, we will study probabilistic graphical models. We will learn
    in depth about the Bayesian rules and Bayesian networks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习概率图模型。我们将深入了解贝叶斯规则和贝叶斯网络。
