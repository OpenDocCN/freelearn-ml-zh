- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Extracting Features from Relational Data with Featuretools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Featuretools从关系数据中提取特征
- en: In previous chapters, we worked with data organized in rows and columns, where
    the columns are the variables, the rows are the observations, and each observation
    is independent. In this chapter, we will focus on creating features from relational
    datasets. In relational datasets, data is structured across various tables, which
    can be joined together via unique identifiers. These unique identifiers indicate
    relationships that exist between the different tables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们处理了以行和列组织的数据，其中列是变量，行是观察值，每个观察值都是独立的。在本章中，我们将专注于从关系数据集中创建特征。在关系数据集中，数据结构跨越各种表，可以通过唯一标识符进行连接。这些唯一标识符表明不同表之间存在的关系。
- en: A classic example of relational data is that held by retail companies. One table
    contains information about customers, such as names and addresses. A second table
    has information about the purchases made by the customers, such as the type and
    number of items bought per purchase. A third table contains information about
    the customers’ interactions with the company’s website, variables such as session
    duration, the mobile device used, and pages visited. Customers, purchases, and
    sessions are identified with unique identifiers. These unique identifiers allow
    us to put these tables together, and in this way, we can get information about
    customers’ purchases or sessions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据的经典例子是零售公司持有的数据。一张表包含有关客户的信息，例如姓名和地址。第二张表包含有关客户所进行的购买的信息，例如每次购买的物品类型和数量。第三张表包含有关客户与公司网站互动的信息，例如会话持续时间、使用的移动设备和访问的页面。客户、购买和会话通过唯一标识符进行识别。这些唯一标识符使我们能够将这些表放在一起，这样我们就可以获取有关客户购买或会话的信息。
- en: If we want to know more about the types of customers we have (that is, customer
    segmentation) or make predictions about whether they would buy a product, we can
    create features that aggregate or summarize information across different tables
    at the customer level. For example, we can create features that capture the maximum
    amount spent by a customer on a purchase, the number of purchases they have made,
    the time between sessions, or the average session duration. The number of features
    we can create and the various ways we can aggregate data across tables are abundant.
    In this chapter, we will discuss some common ways of creating aggregated views
    of relational data utilizing the `featuretools` Python library. We will begin
    by setting up various data tables and their relationships and automatically creating
    features, and next, we will follow up with more detail on the different features
    we can create.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想了解更多关于我们拥有的客户类型（即客户细分）或者预测他们是否会购买产品，我们可以创建在客户层面跨不同表汇总或总结信息的特征。例如，我们可以创建捕捉客户在购买中花费的最大金额、他们所进行的购买次数、会话之间的时间或平均会话持续时间的特征。我们可以创建的特征数量以及我们可以在表中跨表汇总数据的不同方式是丰富的。在本章中，我们将讨论使用`featuretools`
    Python库创建关系数据聚合视图的一些常见方法。我们将从设置各种数据表及其关系并自动创建特征开始，然后我们将详细介绍我们可以创建的不同特征。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Setting up an entity set and creating features automatically
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置实体集并自动创建特征
- en: Creating features with general and cumulative operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用和累积操作创建特征
- en: Combining numerical features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合数值特征
- en: Extracting features from date and time
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从日期和时间中提取特征
- en: Extracting features from text
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文本中提取特征
- en: Creating features with aggregation primitives
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用聚合原语创建特征
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will use `pandas`, `matplotlib`, and `featuretools` open
    source Python libraries. You can install `featuretools` with `pip`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`pandas`、`matplotlib`和`featuretools`开源Python库。您可以使用`pip`安装`featuretools`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, you can do so with `conda`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用`conda`：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These commands install the basic `featuretools` functionality, but we can install
    add-ons for creating features with `dask` as the backend instead of `pandas`.
    For more information on how to install `featuretools` add-ons, including `graphviz`,
    check out their documentation here: [https://docs.featuretools.com/en/v0.16.0/getting_started/install.html](https://docs.featuretools.com/en/v0.16.0/getting_started/install.html).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令安装了基本的 `featuretools` 功能，但我们可以安装用于使用 `dask` 作为后端而不是 `pandas` 的附加组件。有关如何安装
    `featuretools` 附加组件（包括 `graphviz`）的更多信息，请参阅他们的文档：[https://docs.featuretools.com/en/v0.16.0/getting_started/install.html](https://docs.featuretools.com/en/v0.16.0/getting_started/install.html)。
- en: 'We will work with the *Online Retail II* dataset from the UCI Machine Learning
    Repository, which is available at [https://archive.ics.uci.edu/ml/datasets/Online+Retail+II](https://archive.ics.uci.edu/ml/datasets/Online+Retail+II)
    and licensed under a **Creative Commons Attribution 4.0 International** (**CC
    BY 4.0**) license: [https://creativecommons.org/licenses/by/4.0/legalcode](https://creativecommons.org/licenses/by/4.0/legalcode).
    The corresponding citation for this data is provided here: *Chen, Daqing* (*2019*).
    *Online Retail II*. *UCI Machine Learning* *Repository* ([https://doi.org/10.24432/C5CG6D](https://doi.org/10.24432/C5CG6D)).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自 UCI 机器学习仓库的 *Online Retail II* 数据集，该数据集可在 [https://archive.ics.uci.edu/ml/datasets/Online+Retail+II](https://archive.ics.uci.edu/ml/datasets/Online+Retail+II)
    找到，并受 **Creative Commons Attribution 4.0 国际**（**CC BY 4.0**）许可协议的约束：[https://creativecommons.org/licenses/by/4.0/legalcode](https://creativecommons.org/licenses/by/4.0/legalcode)。该数据的相应引用如下：*Chen,
    Daqing*（2019）。*Online Retail II*。*UCI Machine Learning Repository* ([https://doi.org/10.24432/C5CG6D](https://doi.org/10.24432/C5CG6D))。
- en: 'I downloaded and modified the data as shown in this notebook: [https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我已下载并修改了如本笔记本所示的数据：[https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/prepare-retail-dataset.ipynb)
- en: 'You’ll find a copy of the modified dataset in the accompanying GitHub repository:
    [https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附带的 GitHub 仓库中找到修改后的数据集：[https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/retail.csv)
- en: Setting up an entity set and creating features automatically
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置实体集和自动创建特征
- en: Relational datasets or databases contain data spread across multiple tables,
    and the relationships between tables are dictated by a unique identifier that
    tells us how we can join those tables. To automate feature creation with `featuretools`,
    we first need to enter the different data tables and establish their relationships
    within what is called an `featuretools` how these tables are connected so that
    the library can automatically create features based on those relationships.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据集或数据库包含分散在多个表中的数据，表之间的关系由一个唯一标识符决定，它告诉我们如何连接这些表。为了使用 `featuretools` 自动创建特征，我们首先需要输入不同的数据表，并在所谓的
    `featuretools` 中建立它们之间的关系，以便库可以自动根据这些关系创建特征。
- en: We will work with a dataset containing information about customers, invoices,
    and products. First, we will set up an entity set highlighting the relationships
    between these three items. This entity set will be the starting point for the
    remaining recipes in this chapter. Next, we will create features automatically
    by aggregating the data at the customer, invoice, and product levels, utilizing
    the default parameters from `featuretools`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用包含客户、发票和产品信息的数据集。首先，我们将设置一个实体集，突出这三个项目之间的关系。这个实体集将是本章剩余菜谱的起点。接下来，我们将通过在客户、发票和产品级别汇总数据，利用
    `featuretools` 的默认参数自动创建特征。
- en: In this recipe, you will learn how to correctly set up an entity set and extract
    a bunch of features automatically for each entity. In the upcoming recipes, we
    will dig deeper into the different types of features that we can create with `featuretools`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，你将学习如何正确设置实体集并自动为每个实体提取一系列特征。在接下来的菜谱中，我们将深入探讨我们可以使用 `featuretools` 创建的不同类型的特征。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will use the *Online Retail II* dataset from the UCI Machine
    Learning Repository. In this table, there are customers, which are businesses
    that buy in bulk from the retail company. Customers are identified with a `customer_id`
    unique identifier. Each customer makes one or more purchases, which are flagged
    by an `invoice` unique identifier, containing the invoice number. In each invoice,
    there are one or more items that have been bought by the customer. Each item or
    product sold by the company is also identified with a unique stock code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用来自UCI机器学习仓库的*在线零售II*数据集。在这个表中，有客户，他们是批量从零售公司购买的企业。客户通过一个唯一的`customer_id`标识符来识别。每位客户进行一次或多次购买，这些购买通过一个唯一的`invoice`标识符标记，包含发票号。在每张发票中，都有客户购买的一个或多个项目。公司销售的每个项目或产品也通过一个唯一的库存代码来识别。
- en: 'Thus, the data has the following relations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据有以下关系：
- en: '![Figure 9.1 – Diagram showing the relationships in the data](img/B22396_09_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 显示数据中关系的图](img/B22396_09_01.jpg)'
- en: Figure 9.1 – Diagram showing the relationships in the data
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 显示数据中关系的图
- en: Each customer made one or more purchases, identified by the invoice number.
    Each invoice contains one or more items, identified by the stock code. Each item
    can be bought by one or more customers and is therefore present in several invoices.
    With these relationships in mind, let’s proceed to the recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每位客户进行了一次或多次购买，由发票号识别。每张发票包含一个或多个项目，由库存代码识别。每个项目可以被一个或多个客户购买，因此出现在多个发票中。考虑到这些关系，让我们继续进行食谱。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we will set up an entity set with the data, and then highlight
    the different relationships in the dataset. Finally, we will create features by
    aggregating information in the dataset at the customer, invoice, and product levels:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用数据设置一个实体集，然后突出显示数据集中的不同关系。最后，我们将通过在客户、发票和产品级别对数据集中的信息进行聚合来创建特征：
- en: 'Let’s import the required libraries:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入所需的库：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s load the retail dataset described in the *Getting ready* section and
    display its first five rows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载在*准备就绪*部分描述的零售数据集，并显示其前五行：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the following screenshot, we see the unique identifiers for customers (`customer_id`)
    and invoices (`invoice`), and additional information about the items bought in
    each invoice, such as the item’s code (`stock_code`), description, quantity, and
    unit price, as well as the date of the invoice:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到客户(`customer_id`)和发票(`invoice`)的唯一标识符，以及关于每张发票购买的项目（如项目的代码`stock_code`）、描述、数量、单价以及发票日期的附加信息：
- en: '![Figure 9.2 – Online Retail II dataset](img/B22396_09_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 在线零售II数据集](img/B22396_09_02.jpg)'
- en: Figure 9.2 – Online Retail II dataset
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 在线零售II数据集
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Use `pandas`’ `unique()` function to identify the number of unique items, customers,
    and invoices – for example, by executing `df["customer_id"].nunique()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pandas`的`unique()`函数来识别唯一的项目、客户和发票的数量——例如，通过执行`df["customer_id"].nunique()`。
- en: 'Let’s initialize an entity set with an arbitrary name, such as `data`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用一个任意的名字初始化一个实体集，例如`data`：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s add a DataFrame to the entity set; we give the DataFrame a name (`data`).
    We need to add a unique identifier for each row, which we call `rows`, and since
    we do not have a unique row identifier in this dataset, we will create it as an
    additional column by setting `make_index=True`. Finally, we indicate that `invoice_date`
    is of the `datetime` type and `customer_id` should be handled as `Categorical`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在实体集中添加一个DataFrame；我们给DataFrame起一个名字（`data`）。我们需要为每一行添加一个唯一标识符，我们称之为`rows`，由于在这个数据集中我们没有唯一的行标识符，我们将通过设置`make_index=True`创建它作为额外的列。最后，我们指出`invoice_date`是`datetime`类型，`customer_id`应被视为`Categorical`：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we add the relationship between the original `data` DataFrame and `invoices`.
    To do this, we indicate the original or base DataFrame, which we called `data`
    in *step 4*, we give the new DataFrame a name, `invoices`, we add the unique identifier
    for invoices, and we add the column containing `customer_id` to this DataFrame:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加原始`data` DataFrame和`invoices`之间的关系。为此，我们指出原始或基本DataFrame，我们在*步骤4*中将其称为`data`，我们给新的DataFrame起一个名字，`invoices`，我们添加发票的唯一标识符，并将包含`customer_id`的列添加到这个DataFrame中：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We copy the `customer_id` variable to the `invoices` data because we want to
    create a subsequent relationship between customers and invoices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`customer_id`变量复制到`invoices`数据中，因为我们想创建客户和发票之间的后续关系。
- en: 'Now, we add a second relationship, which is between customers and invoices.
    To do this, we indicate the base DataFrame, which we named `invoices` in *step
    5*, then we give the new DataFrame a name, `customers`, and add the unique customer
    identifier:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加第二个关系，即客户与发票之间的关系。为此，我们指示基础DataFrame，我们在*步骤5*中将其命名为`invoices`，然后我们为新DataFrame命名，命名为`customers`，并添加唯一的客户标识符：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can add a third relationship between the original data and the products:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在原始数据和产品之间添加第三个关系：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s display the information in the entity set:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示实体集中的信息：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the following output, we see that the entity set contains four DataFrames:
    the original data, the `invoices` DataFrame, the `customers` DataFrame, and the
    product or `items` DataFrame. The entity also contains the relationships between
    invoices or items with the original data, as well as between customers and invoices:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到实体集包含四个DataFrame：原始数据、`invoices` DataFrame、`customers` DataFrame以及产品或`items`
    DataFrame。实体还包含发票或项目与原始数据之间的关系，以及客户与发票之间的关系：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: es["invoices"].head()
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: es["invoices"].head()
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Figure 9.3 – DataFrame with information at the invoice level](img/B22396_09_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 发票级别的DataFrame信息](img/B22396_09_03.jpg)'
- en: Figure 9.3 – DataFrame with information at the invoice level
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 发票级别的DataFrame信息
- en: 'Let’s now display the `customers` DataFrame:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们显示`customers` DataFrame：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see in the following output that `featuretools` automatically created
    a DataFrame containing the customer’s unique identifier, followed by the date
    of the first invoice for this customer:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到`featuretools`自动创建了一个包含客户唯一标识符的DataFrame，随后是此客户的第一个发票日期：
- en: '![Figure 9.4 – DataFrame with information at the customer level](img/B22396_09_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 客户级别的DataFrame信息](img/B22396_09_04.jpg)'
- en: Figure 9.4 – DataFrame with information at the customer level
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 客户级别的DataFrame信息
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Go ahead and display the DataFrame containing the products by executing `es["items"].head()`.
    You can also evaluate the size of the different DataFrames using `pandas`’ `shape`
    function. You will notice that the number of rows in each DataFrame coincides
    with the number of unique invoices, customers, and products.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行`es["items"].head()`来显示包含产品的DataFrame。您还可以使用`pandas`的`shape`函数评估不同DataFrame的大小。您会注意到每个DataFrame中的行数与唯一发票、客户和产品的数量相匹配。
- en: 'We can also display the relationships between these data tables as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以如下显示这些数据表之间的关系：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To visualize the data relationships, you need to have `graphviz` installed.
    If you don’t, follow the instructions in the `featuretools` documentation to install
    it: [https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz](https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化数据关系，您需要安装`graphviz`。如果没有安装，请按照`featuretools`文档中的说明进行安装：[https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz](https://featuretools.alteryx.com/en/stable/install.html#installing-graphviz)。
- en: 'In the following output, we can see the relational datasets and their relationships:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到关系数据集及其关系：
- en: '![Figure 9.5 – Relationships between the tables containing invoices, customers,
    and products](img/B22396_09_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 包含发票、客户和产品的表之间的关系](img/B22396_09_05.jpg)'
- en: Figure 9.5 – Relationships between the tables containing invoices, customers,
    and products
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 包含发票、客户和产品的表之间的关系
- en: After entering the data and their relationships, we can start automatically
    creating features for each one of our new DataFrames – that is, customers, invoices,
    and products – using the default parameters from `featuretools`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入数据和它们之间的关系后，我们可以开始自动为我们的新DataFrame（即客户、发票和产品）创建特征，使用`featuretools`的默认参数。
- en: 'Let’s create features by aggregating the data at the customer level. To do
    this, we set up the `featuretools`, indicating `customers` as the target DataFrame.
    When creating features, we want to ignore the two columns with unique identifiers:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在客户级别聚合数据来创建特征。为此，我们设置`featuretools`，将`customers`指定为目标DataFrame。在创建特征时，我们希望忽略具有唯一标识符的两个列：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The command from *step 12* triggered the creation of 114 features with different
    aggregations of data at the customer level. The `feature_matrix` variable is a
    DataFrame with the feature values, and `feature_defs` is a list with the names
    of the new features. Go ahead and execute `feature_defs` or visit our accompanying
    GitHub repository ([https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb))
    to check the names of the created features. You will find more details about these
    features in the *How it* *works…* section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 12* 中的命令触发了 114 个具有不同客户级别数据聚合的特征的创建。`feature_matrix` 变量是一个包含特征值的 DataFrame，`feature_defs`
    是一个包含新特征名称的列表。继续执行 `feature_defs` 或访问我们的配套 GitHub 仓库 ([https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe1-Setting-up-an-entitity-set.ipynb))
    来检查创建的特征名称。你将在 *如何工作…* 部分找到更多关于这些特征的信息。'
- en: 'For reasons of space, we can’t print out all the features in the book, so instead,
    let’s display the names of five of the created features:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于空间限制，我们无法在书中打印出所有特征，因此，让我们显示五个创建特征的名称：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the following output, we see 5 of the 114 features created by `featuretools`:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到由 `featuretools` 创建的 114 个特征中的 5 个：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `featuretools` library names the new features with the function used to
    create them, followed by the DataFrame that was used to perform the aggregation,
    followed by the aggregated variable name. Thus, `MIN(data.quantity)` is equivalent
    to `df.groupby(["customer_id"])["quantity"].min()`, if you are familiar with `pandas`.
    We will give more details in the *How it* *works…* section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools` 库使用创建它们的函数来命名新特征，然后是用于执行聚合的 DataFrame，最后是聚合变量名称。因此，`MIN(data.quantity)`
    等同于 `df.groupby(["customer_id"])["quantity"].min()`，如果你熟悉 `pandas`。我们将在 *如何工作…*
    部分提供更多细节。'
- en: 'Let’s display the first five rows of the DataFrame containing five of the created
    features:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示包含五个创建特征的 DataFrame 的前五行：
- en: '[PRE17]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the following output, we can see the first five rows containing the values
    of the five new features:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到包含五个新特征值的前五行：
- en: '![Figure 9.6 – DataFrame with five features created by aggregating the data
    at the customer level](img/B22396_09_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 通过聚合客户级别的数据创建的五个特征的 DataFrame](img/B22396_09_06.jpg)'
- en: Figure 9.6 – DataFrame with five features created by aggregating the data at
    the customer level
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 通过聚合客户级别的数据创建的五个特征的 DataFrame
- en: 'Similarly, we can create features automatically by aggregating information
    at the invoice level:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以通过在发票级别聚合信息来自动创建特征：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The previous step returns 24 features – let’s display their names:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一步返回了 24 个特征——让我们显示它们的名称：
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can see the names of the features in the following output:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在以下输出中看到特征的名称：
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Go ahead and display the DataFrame containing the new features by executing
    `feature_matrix.head()` or check our accompanying GitHub repository for the result.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行 `feature_matrix.head()` 来显示包含新特征的 DataFrame，或检查我们的配套 GitHub 仓库以查看结果。
- en: To wrap up, by using the code from *step 16* and changing the target DataFrame
    name from `invoices` to `items`, go ahead and create features automatically at
    the product level.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，通过使用 *步骤 16* 中的代码并将目标 DataFrame 名称从 `invoices` 更改为 `items`，继续在产品级别自动创建特征。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: In this recipe, we set up an entity set containing the data and the relationships
    between some of its variables (unique identifiers). After that, we automatically
    created features by aggregating the information in the dataset for each of the
    unique identifiers. We used two main classes from `featuretools`, `EntitySet`
    and `dfs`, to create the features. Let’s discuss each of these in more detail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们设置了一个包含数据和某些变量（唯一标识符）之间关系的实体集。之后，我们通过聚合数据集中每个唯一标识符的信息自动创建特征。我们使用了 `featuretools`
    的两个主要类，`EntitySet` 和 `dfs`，来创建特征。让我们更详细地讨论这些内容。
- en: The `EntitySet` class stores the data, the logical types of the variables, and
    the relationships between the variables. The variable types (whether numeric or
    categorical) are automatically assigned by `featuretools`. We can also set up
    specific variable types when adding a DataFrame to the entity set. In *step 4*,
    we added the data to the entity set and set the logical type of `customer_id`
    to `Categorical`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntitySet` 类存储数据、变量的逻辑类型以及变量之间的关系。变量类型（是否为数值或分类）由 `featuretools` 自动分配。我们也可以在将
    DataFrame 添加到实体集时设置特定的变量类型。在 *步骤 4* 中，我们将数据添加到实体集并将 `customer_id` 的逻辑类型设置为 `Categorical`。'
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To inspect the datatypes inferred by `featuretools`, you can execute `es["data"].ww`,
    where `es` is the entity set and `data` is the name of the DataFrame.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 `featuretools` 推断的数据类型，您可以执行 `es["data"].ww`，其中 `es` 是实体集，`data` 是 DataFrame
    的名称。
- en: The `EntitySet` class has the `add_dataframe` method, which we used in *step
    4* to add a new DataFrame. When using this method, we need to specify the unique
    identifier, and if there is none, then we need to create one, as we did in *step
    4*, by setting `make_index` to `True`. Note that in the `index` parameter from
    `add_dataframe`, we passed the `"rows"` string. With this configuration, `EntitySet`
    added a `rows` column containing the unique identifier for each row to the DataFrame,
    which is a new sequence of integers starting at 0.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntitySet` 类具有 `add_dataframe` 方法，我们在 *步骤 4* 中使用此方法添加新的 DataFrame。在使用此方法时，我们需要指定唯一标识符，如果没有，则需要创建一个，就像我们在
    *步骤 4* 中所做的那样，通过将 `make_index` 设置为 `True`。请注意，在 `add_dataframe` 的 `index` 参数中，我们传递了
    `"rows"` 字符串。使用此配置，`EntitySet` 将包含每行的唯一标识符的 `rows` 列添加到 DataFrame 中，这是一个从 0 开始的新整数序列。'
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of using the `add_dataframe` method to add a DataFrame to an entity
    set, we can add it by executing `es["df_name"]=df`, where `"df_name"` is the name
    we want to give to the DataFrame and `df` is the DataFrame we want to add.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `add_dataframe` 方法将 DataFrame 添加到实体集中，我们可以通过执行 `es["df_name"]=df` 来添加它，其中
    `"df_name"` 是我们想要给 DataFrame 的名称，`df` 是我们想要添加的 DataFrame。
- en: The `EntitySet` class has the `normalize_dataframe` method, which is used to
    create a new DataFrame and relationship from the unique values of an existing
    column. The method takes the name of the DataFrame to which the new DataFrame
    will be related and a name for the new DataFrame. We also need to indicate the
    unique identifier for the new DataFrame in the `index` parameter. By default,
    this method creates a new DataFrame containing the unique identifier, followed
    by a `datetime` column containing the first date each unique identifier was registered.
    We can add more columns to this DataFrame by using the `copy_columns` parameters,
    as we did in *step 5*. Adding more columns to the new DataFrame is useful if we
    want to follow up with relationships to this new DataFrame, as we did in *step
    6*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntitySet` 类具有 `normalize_dataframe` 方法，该方法用于从现有列的唯一值创建新的 DataFrame 和关系。此方法接受新
    DataFrame 将关联的 DataFrame 的名称以及新 DataFrame 的名称。我们还需要在 `index` 参数中指明新 DataFrame
    的唯一标识符。默认情况下，此方法创建一个包含唯一标识符的新 DataFrame，后面跟着一个包含每个唯一标识符首次注册的日期的 `datetime` 列。我们可以通过使用
    `copy_columns` 参数向此 DataFrame 添加更多列，就像我们在 *步骤 5* 中所做的那样。向新 DataFrame 添加更多列对于如果我们想跟踪与该新
    DataFrame 的关系是有用的，就像我们在 *步骤 6* 中所做的那样。'
- en: The `EntitySet` class also has the `plot()` method, which displays existing
    relationships in the entity set. In *Figure 9**.5*, we saw the relationships between
    our data tables; the `invoices` and `items` (products) tables were related to
    the original data, whereas the `customers` table was related to the `invoices`
    table, which was, in turn, related to the original data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntitySet` 类还具有 `plot()` 方法，该方法显示实体集中的现有关系。在 *图 9**.5* 中，我们看到了我们的数据表之间的关系；`invoices`
    和 `items`（产品）表与原始数据相关联，而 `customers` 表与 `invoices` 表相关联，而 `invoices` 表又与原始数据相关联。'
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The relationship between the tables dictates how features will be created. The
    `invoices` and `items` tables are related to the original data. Thus, we can only
    create features with depth 1\. The `customers` table is, on the other hand, related
    to invoices, which is related to data. Thus, we can create features with depth
    2\. That means that new features will consist of aggregations from the entire
    dataset or aggregations for invoices first, which will then be subsequently aggregated
    for customers. We can regulate the features to create with the `max_depth` parameter
    in `dfs`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表之间的关系决定了特征的创建方式。`invoices`和`items`表与原始数据相关。因此，我们只能创建深度为1的特征。另一方面，`customers`表与发票相关，而发票又与数据相关。因此，我们可以创建深度为2的特征。这意味着新特征将包括整个数据集的聚合或首先对发票进行聚合，然后对客户进行后续聚合。我们可以通过`dfs`中的`max_depth`参数来调节要创建的特征。
- en: After setting up the data and the relationships, we used `dfs` from `featuretools`
    to automatically create features. When creating features with `dfs`, we need to
    set the target DataFrame – that is, the data table for which the features should
    be created. The `dfs` class creates features by *transforming* and *aggregating*
    existing variables, through what are called **transform** and **aggregate primitives**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好数据和关系后，我们使用了`featuretools`中的`dfs`来自动创建特征。在用`dfs`创建特征时，我们需要设置目标DataFrame——即应该创建特征的对应数据表。`dfs`类通过所谓的**转换**和**聚合原语**，通过转换和聚合现有变量来创建特征。
- en: A transform primitive transforms variables. For example, from datetime variables,
    using a transform primitive, `dfs` extracts the `month`, `year`, `day`, and `week`
    values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 转换原语转换变量。例如，使用转换原语，`dfs`可以从日期时间变量中提取`month`、`year`、`day`和`week`值。
- en: An aggregate primitive aggregates information for a unique identifier. It uses
    mathematical operations such as the mean, standard deviation, maximum and minimum
    values, the sum, and the skew coefficient for numerical variables. For categorical
    variables, aggregate primitives use the mode and the count of unique items. For
    unique identifiers, they count the number of occurrences.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合原语对唯一标识符的信息进行聚合。它使用诸如平均值、标准差、最大值和最小值、总和以及数值变量的偏度系数等数学运算。对于分类变量，聚合原语使用众数和唯一项目的计数。对于唯一标识符，它们计算出现的次数。
- en: With the functionality of transform and aggregate primitives in mind, let’s
    try to understand the features that we created in this recipe. We used the default
    parameters of `dfs` to create the default features.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到转换和聚合原语的功能，让我们尝试理解在这个配方中创建的特征。我们使用了`dfs`的默认参数来创建默认特征。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on the default features returned by `featuretools`, visit [https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs](https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于`featuretools`返回的默认特征的信息，请访问[https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs](https://featuretools.alteryx.com/en/stable/generated/featuretools.dfs.html#featuretools.dfs)。
- en: We first created features for each customer. `featuretools` returned 114 features
    for each customer. Because the `customers` data is related to the `invoices` data,
    which is related to the entire dataset, the features were created by aggregating
    data at two levels. First, the data was aggregated for each customer using the
    entire dataset. Next, it was aggregated for each invoice first, and then the pre-aggregated
    data was aggregated again for each customer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为每位客户创建了特征。`featuretools`为每位客户返回了114个特征。由于`customers`数据与`invoices`数据相关，而`invoices`数据又与整个数据集相关，因此特征是通过在两个级别上聚合数据来创建的。首先，使用整个数据集对每个客户的数据进行聚合。接下来，首先对每个发票进行聚合，然后对预先聚合的数据再次进行聚合，以创建每个客户的特征。
- en: The `featuretools` library names the new features with the function used to
    aggregate the data – for example, `COUNT`, `MEAN`, `STD`, and `SKEW`, among others.
    Next, it uses the data that was used for the aggregation and follows it with the
    variable that was aggregated. For example, the `MEAN(data.quantity)` feature contains
    the mean quantity of items bought by the customer calculated from the entire dataset,
    which is the equivalent of `df.groupby("customer_id"])["quantity"].mean()`, if
    you are familiar with `pandas`. On the other hand, the `MEAN(invoices.MEAN(data.quantity))`
    feature first takes the mean quantity of items for each invoice – that is, `df.groupby("invoice"])["quantity"].mean()`
    – and from the resulting series, it takes the mean value, considering the invoices
    for a particular customer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools` 库使用用于聚合数据的函数来命名新特征 – 例如，`COUNT`、`MEAN`、`STD` 和 `SKEW` 等。接下来，它使用用于聚合的数据，并跟随聚合的变量。例如，`MEAN(data.quantity)`
    特征包含从整个数据集中计算出的客户购买物品的平均数量，这相当于如果你熟悉 `pandas`，则是 `df.groupby("customer_id")["quantity"].mean()`。另一方面，`MEAN(invoices.MEAN(data.quantity))`
    特征首先获取每个发票的物品平均数量 – 即 `df.groupby("invoice")["quantity"].mean()` – 然后从生成的序列中获取平均值，考虑特定客户的发票。'
- en: For categorical features, `featuretools` determines the mode and the unique
    values. For example, from the `description` variable, we’ve got the `NUM_UNIQUE(data.description)`
    and `MODE(data.description)` features. The description is just the name of the
    item. Thus, these features highlight the number of unique items the customer bought
    and the item the customer bought the most times.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分类特征，`featuretools` 确定众数和唯一值。例如，从 `description` 变量中，我们得到了 `NUM_UNIQUE(data.description)`
    和 `MODE(data.description)` 特征。描述只是物品的名称。因此，这些特征突出了客户购买的独特物品数量以及客户购买次数最多的物品。
- en: Note something interesting
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一些有趣的事情
- en: The `NUM_UNIQUE(data.description)` and `MODE(data.description)` variables are
    numeric after the aggregation of the categorical features. The `featuretools`
    library creates more features by using numerical aggregations of these newly created
    variables. In this way, the `MAX(invoices.NUM_UNIQUE(data.description)` feature
    first finds the number of unique items per invoice and then returns the maximum
    from those values for a particular customer, considering all the customer’s invoices.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在对分类特征进行聚合后，`NUM_UNIQUE(data.description)` 和 `MODE(data.description)` 变量是数值型的。`featuretools`
    库通过使用这些新创建变量的数值聚合来创建更多特征。这样，`MAX(invoices.NUM_UNIQUE(data.description))` 特征首先找到每个发票的独特物品数量，然后返回特定客户这些值中的最大值，考虑所有客户的发票。
- en: From datetime features, `featuretools` extracts date components by default.
    Remember that the `customers` DataFrame contains the `customer_id` variable and
    the date of the first invoice for each customer, as we saw in the output of *step
    10*. From this datetime feature, `featuretools` created `DAY(first_invoices_time)`,
    `MONTH(first_invoices_time)`, `WEEKDAY(first_invoices_time)`, and `YEAR(first_invoices_time)`
    features containing the different date parts.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从日期时间特征中，`featuretools` 默认提取日期组件。记住，`customers` DataFrame 包含 `customer_id` 变量和每个客户的第一个发票日期，正如我们在
    *步骤 10* 的输出中看到的。从这个日期时间特征中，`featuretools` 创建了包含不同日期部分的 `DAY(first_invoices_time)`、`MONTH(first_invoices_time)`、`WEEKDAY(first_invoices_time)`
    和 `YEAR(first_invoices_time)` 特征。
- en: Finally, `featuretools` also returned the total number of invoices per customer
    (`COUNT(invoices)`) and the total number of rows (`COUNT(data)`) per customer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`featuretools` 还返回了每个客户的发票总数（`COUNT(invoices)`) 和每客户的总行数（`COUNT(data)`)。
- en: See also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more details into what inspired `featuretools`, check the original article
    *Deep Feature Synthesis: Towards Automating Data Science Endeavors* by Kanter
    and Veeramachaneni at [https://www.jmaxkanter.com/papers/DSAA_DSM_2015.pdf](https://www.jmaxkanter.com/papers/DSAA_DSM_2015.pdf).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '要了解更多关于 `featuretools` 的灵感来源，请查看 Kanter 和 Veeramachaneni 在 [https://www.jmaxkanter.com/papers/DSAA_DSM_2015.pdf](https://www.jmaxkanter.com/papers/DSAA_DSM_2015.pdf)
    发表的原始文章 *Deep Feature Synthesis: Towards Automating Data Science Endeavors*。'
- en: Creating features with general and cumulative operations
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通用和累积操作创建特征
- en: The `featuretools` library uses what are called **transform primitives** to
    create features. Transform primitives take one or more columns in a dataset as
    input and return one or more columns as output. They are applied to a *single*
    DataFrame.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools` 库使用所谓的 **转换原语** 来创建特征。转换原语将一个或多个数据集中的列作为输入，并返回一个或多个列作为输出。它们应用于一个
    *单个* DataFrame。'
- en: The `featuretools` library divides its transform primitives into various categories
    depending on the type of operation they perform or the type of variable they modify.
    For example, **general transform primitives** apply mathematical operations, such
    as the square root, the sine, and the cosine. **Cumulative transform primitives**
    create new features by comparing a row’s value to the previous row’s value. For
    example, the cumulative sum, cumulative mean, and cumulative minimum and maximum
    values belong to this category, as well as the difference between row values.
    There is another cumulative transformation that can be applied to datetime variables,
    which is the **time since previous** transformation, which determines the time
    passed between two consecutive timestamps.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools`库根据它们执行的操作类型或修改的变量类型将转换原语分为各种类别。例如，**通用转换原语**应用数学运算，如平方根、正弦和余弦。**累积转换原语**通过比较一行值与前一行的值来创建新特征。例如，累积和、累积平均值、累积最小值和最大值以及行值之间的差异属于这一类别。还有一个可以应用于日期时间变量的累积转换，即**自上次以来**转换，它确定两个连续时间戳之间的时间流逝。'
- en: In this recipe, we will create features using the general and cumulative transform
    primitives from `featuretools`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用`featuretools`中的通用和累积转换原语来创建特征。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Variable transformations such as the square root or the logarithm are useful
    when we want to change the distribution of a variable, as we saw in [*Chapter
    3*](B22396_03.xhtml#_idTextAnchor351), *Transforming Numerical Variables*. Other
    mathematical derivations such as the sine and cosine help to capture underlying
    data patterns, as we described in the *Creating periodic features from cyclical
    variables* recipe in [*Chapter 8*](B22396_08.xhtml#_idTextAnchor987), *Creating
    New Features*. From the transformations described in those chapters, `featuretools`
    supports the square root and the logarithm transformation and the sine and cosine
    (but without the normalization between 0 and 2π).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要改变变量的分布，就像我们在[*第3章*](B22396_03.xhtml#_idTextAnchor351)中看到的，*转换数值变量*时，变量转换，如平方根或对数是有用的。其他数学推导，如正弦和余弦，有助于捕捉潜在的数据模式，正如我们在[*第8章*](B22396_08.xhtml#_idTextAnchor987)中描述的*从周期性变量创建周期性特征*配方中所述，*创建新特征*。从那些章节中描述的转换中，`featuretools`支持平方根和对数转换以及正弦和余弦（但不需要在0和2π之间归一化）。
- en: 'With a cumulative transformation, we can, for example, get the total number
    of items bought per invoice by adding up the item’s quantity on each row at the
    invoice level. To understand the features that we will create in this recipe,
    let’s create them with `pandas` first:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过累积转换，例如，我们可以通过将发票级别的每一行的项目数量相加来获取每个发票购买的项目总数。为了理解我们将在此配方中创建的特征，让我们首先使用`pandas`创建它们：
- en: 'Let’s import `pandas` and `numpy`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入`pandas`和`numpy`：
- en: '[PRE21]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s load the retail dataset described in the *Technical* *requirements* section:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载在*技术* *要求*部分中描述的零售数据集：
- en: '[PRE22]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s capture the two numerical variables, `price` and `quantity`, in a list:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们捕捉两个数值变量，`价格`和`数量`，到一个列表中：
- en: '[PRE23]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s capture the names of the cumulative functions in a list:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将累积函数的名称捕捉到一个列表中：
- en: '[PRE24]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s create a list with new names for the variables that we will create:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含我们将创建的变量新名称的列表：
- en: '[PRE25]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s create new variables using the cumulative functions from *step 4*, applied
    to the variables from *step 3*, and add them to the DataFrame:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用第4步中的累积函数，应用于第3步中的变量，并添加到DataFrame中：
- en: '[PRE26]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous step returns the cumulative sum, cumulative maximum value, and
    the difference between rows, within each invoice. As soon as it encounters a new
    invoice number, it starts afresh.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一步返回了每个发票内的累积和、累积最大值以及行之间的差异。一旦遇到新的发票编号，它就会重新开始。
- en: 'Let’s display the original and new features for one particular invoice:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们展示一个特定发票的原有和新特征：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the following output, we can see that `quantity_cumsum` is the cumulative
    sum for the variable quantity and `price_diff` is the price difference row after
    row:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到`quantity_cumsum`是数量的累积和，而`price_diff`是逐行后的价格差异：
- en: '![Figure 9.7 – DataFrame showing cumulative functions applied to numerical
    features in a single entity (invoice)](img/B22396_09_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 显示在单个实体（发票）中应用于数值特征的累积函数的DataFrame](img/B22396_09_07.jpg)'
- en: Figure 9.7 – DataFrame showing cumulative functions applied to numerical features
    in a single entity (invoice)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - 显示对单个实体（发票）中的数值特征应用累积函数的DataFrame
- en: Let’s now apply the sine and cosine transformation to the entire DataFrame.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将正弦和余弦转换应用于整个DataFrame。
- en: 'Let’s create a list with names for the new variables:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新变量名称的列表：
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s transform the price and quantity with the sine and cosine:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用正弦和余弦函数转换价格和数量：
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The transformation in *step 9* was applied to the entire dataset, irrespective
    of the invoice number, which is fine because it maps from one row to the same
    row, as opposed to from one row to the next, as with cumulative functions. You
    can inspect the result by executing `df[new_names].head()`.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 步骤9中的转换被应用于整个数据集，无论发票号如何，这是可以的，因为它是从一行映射到同一行，而不是像累积函数那样从一行映射到下一行。您可以通过执行`df[new_names].head()`来检查结果。
- en: Now that we understand the types of features we want to create, let’s automate
    the process with `featuretools`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们想要创建的特征类型，让我们使用`featuretools`自动化这个过程。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will apply cumulative transformations for each invoice and general transformations
    to the entire dataset:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对每个发票应用累积转换，对整个数据集应用通用转换：
- en: 'First, we’ll import `pandas`, `featuretools`, and the `Categorical` logical
    type:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入`pandas`、`featuretools`以及`Categorical`逻辑类型：
- en: '[PRE30]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s load the dataset described in the *Technical* *requirements* section:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载*技术*要求部分中描述的数据集：
- en: '[PRE31]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s set up an entity set:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置一个实体集：
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s add the DataFrame to the entity set:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将DataFrame添加到实体集中：
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, `featuretools` only retains categorical, numeric, and Boolean features
    in the feature matrix that is generated *after* creating new features. The type
    of the `invoice` variable is not accurately inferred, so we need to enforce it
    as categorical by setting its logical type as we do in *step 4*, if we want `featuretools`
    to retain it in the dataset containing the new features. To learn the datatypes
    inferred by `featuretools`, you can execute `es["data"].ww`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`featuretools`仅在生成的特征矩阵中保留分类、数值和布尔特征，该矩阵是在创建新特征之后生成的。`invoice`变量的类型没有被准确推断，所以如果我们想让`featuretools`在包含新特征的数据集中保留它，我们需要通过将其逻辑类型设置为我们在步骤4中做的那样来强制将其作为分类。要了解`featuretools`推断的数据类型，您可以执行`es["data"].ww`。
- en: 'Let’s create a new DataFrame with a relationship to the DataFrame from *step
    4*:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的与步骤4中的DataFrame相关联的DataFrame：
- en: '[PRE34]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about *steps 4* and *5*, visit the *Setting up an entity set
    and creating features* *automatically* recipe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关于步骤4和5的更多详细信息，请访问*设置实体集和自动创建特征*菜谱。
- en: 'Let’s make a list with the cumulative transformations that we’ll use to create
    features:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出我们将用于创建特征的累积转换：
- en: '[PRE35]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find `featuretools`-supported cumulative transformations at this link:
    [https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到`featuretools`支持的累积转换：[https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#cumulative-transform-primitives)
- en: 'Let’s make a list of the general transformations to carry out:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出要执行的一般转换：
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find `featuretools`-supported general transformations at this link:
    [https://featuretools.alteryx.com/en/stable/api_reference.html#general-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#general-transform-primitives)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到`featuretools`支持的通用转换：[https://featuretools.alteryx.com/en/stable/api_reference.html#general-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#general-transform-primitives)
- en: 'Finally, let’s create the features. We use the `dfs` class, setting the original
    DataFrame as the target DataFrame – that is, the one whose variables we’ll use
    as a template for the new features. Note that we pass an empty list to the `agg_primitives`
    parameter; this is to avoid returning the default aggregation primitives. We pass
    the general primitives from *step 7* to the `trans_primitives` parameter and the
    cumulative primitives from *step 6* to the `groupby_trans_primitives` parameter:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建特征。我们使用`dfs`类，将原始DataFrame设置为目标DataFrame——即我们将使用其变量作为新特征模板的那个DataFrame。注意，我们向`agg_primitives`参数传递一个空列表；这是为了避免返回默认的聚合原语。我们将步骤7中的通用原语传递给`trans_primitives`参数，将步骤6中的累积原语传递给`groupby_trans_primitives`参数：
- en: '[PRE37]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*Step 8* triggers the creation of features, which may take some time depending
    on how big the data is, how many aggregation levels it has, and the number of
    features to create. You can check out the output features *before* creating them,
    by setting the `features_only` parameter to `True`. This will return just the
    feature names; you can check them out, make sure they show what you need, and
    only then trigger the feature synthesis by setting that parameter back to `False`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 8* 触发特征的创建，这可能会根据数据的大小、聚合级别数量以及要创建的特征数量而花费一些时间。你可以在创建它们之前检查输出特征，通过将`features_only`参数设置为`True`。这将仅返回特征名称；你可以检查它们，确保它们显示了你需要的内容，然后通过将参数设置回`False`来触发特征合成。'
- en: 'Let’s now display the names of the created features:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在显示创建的特征名称：
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the following output, we see the names of the features that we created,
    including the sine and cosine of the price and quantity, and the cumulative transformations
    of these variables after grouping them by invoice number:'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到我们创建的特征名称，包括价格和数量的正弦和余弦，以及按发票号分组后的这些变量的累积变换：
- en: '[PRE39]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The sine and cosine transformation of price and quantity will probably not add
    much value because these are not cyclical features. I kept these transformations
    in the recipe to show you how to apply transformation primitives in general, if
    you ever need them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 价格和数量的正弦和余弦变换可能不会增加太多价值，因为这些不是周期性特征。我保留这些变换在配方中，是为了向你展示如何在需要时应用变换原语。
- en: 'As you can see from the previous list, the new features were appended as new
    columns to the original DataFrame. You can display the final DataFrame by executing
    `feature_matrix.head()`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述列表所示，新特征作为新列附加到原始DataFrame中。你可以通过执行`feature_matrix.head()`来显示最终的DataFrame：
- en: "![Figure 9.8 – DataFrame resulting from the deep feature synthesis, containing\
    \ the \uFEFForiginal variables and the new features](img/B22396_09_08.jpg)"
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 深度特征合成产生的DataFrame，包含原始变量和新特征](img/B22396_09_08.jpg)'
- en: Figure 9.8 – DataFrame resulting from the deep feature synthesis, containing
    the original variables and the new features
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 深度特征合成产生的DataFrame，包含原始变量和新特征
- en: For more details about the created features, check the *How it* *works…* section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建的特征的更多详细信息，请查看*它是如何工作的…*部分。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To create features using general and cumulative transformations with `featuretools`,
    we first need to set up an entity set with the data and define the relationships
    between its variables. We described how to set up an entity set in the *Setting
    up an entity set and creating features* *automatically* recipe.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`featuretools`创建一般和累积变换的特征，我们首先需要设置一个包含数据的实体集并定义其变量之间的关系。我们在*设置实体集和自动创建特征*配方中描述了如何设置实体集。
- en: To apply cumulative and general transforms, we used the `dfs` class from `featuretools`.
    General transformations are applied to the entire DataFrame without grouping by
    a specific variable. To perform general transformations, we passed a list of strings
    with the transformation names to the `trans_primitives` parameter from `dfs`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用累积和一般变换，我们使用了`featuretools`中的`dfs`类。一般变换应用于整个DataFrame，而不按特定变量分组。要执行一般变换，我们将包含变换名称的字符串列表传递给`dfs`的`trans_primitives`参数。
- en: We applied cumulative transformation after grouping by `invoice`. To do this,
    we passed a list of strings with the names of the cumulative transformation to
    the `groupby_trans_primitives` parameter from `dfs`. The `featuretools` library
    knows it should group by invoice because we established this unique identifier
    by using the `normalize_dataframe` method from `EntitySet` in *step 5*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在按`invoice`分组后应用了累积变换。为此，我们将包含累积变换名称的字符串列表传递给`dfs`的`groupby_trans_primitives`参数。`featuretools`库知道应该按发票分组，因为我们通过使用`EntitySet`中的`normalize_dataframe`方法在*步骤
    5*中建立了这个唯一标识符。
- en: Finally, we did not want features created from the variables in the `invoices`
    DataFrame; thus, we set `dfs` to ignore this DataFrame by setting `ignore_dataframes
    = ["``invoices"]`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不想从`invoices`DataFrame中的变量创建特征；因此，我们将`dfs`设置为通过设置`ignore_dataframes = ["``invoices"]`来忽略此DataFrame。
- en: The `dfs` class returned two variables, the DataFrame with the original and
    new features, and the name of the features in a list. The new features are named
    with the operations applied to create them, such as `SINE`, `COSINE`, `CUM_MAX`,
    or `DIFF`, followed by the variable to which the transformation was applied and,
    when corresponding, the variable that was used for grouping.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`dfs`类返回了两个变量，包含原始和新特征的DataFrame以及一个包含特征名称的列表。新特征以创建它们的操作命名，例如`SINE`、`COSINE`、`CUM_MAX`或`DIFF`，后跟应用转换的变量，以及当适用时用于分组的变量。'
- en: Note that `featuretools` automatically recognizes and selects the variables
    over which the transformations should be applied. The sine, cosine, cumulative
    sum, maximum, and difference were applied to numerical variables, whereas the
    `time_since_previous` transformation was applied to the datetime variable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`featuretools`会自动识别并选择应用转换的变量。正弦、余弦、累计总和、最大值和差分被应用于数值变量，而`time_since_previous`转换被应用于日期时间变量。
- en: Combining numerical features
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合数值特征
- en: In [*Chapter 8*](B22396_08.xhtml#_idTextAnchor987), *Creating New Features*,
    we saw that we can create new features by combining variables with mathematical
    operations. The `featuretools` library supports several operations for combining
    variables, including addition, division, modulo, and multiplication. In this recipe,
    we will learn how to combine these features with `featuretools`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B22396_08.xhtml#_idTextAnchor987) *创建新特征*中，我们看到了我们可以通过使用数学运算结合变量来创建新特征。`featuretools`库支持多种结合变量的操作，包括加法、除法、取模和乘法。在本食谱中，我们将学习如何使用`featuretools`结合这些特征。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s begin by importing the libraries and getting the dataset ready:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入库和准备数据集开始：
- en: 'First, we’ll import `pandas`, `featuretools`, and the `Categorical` logical
    type:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入`pandas`、`featuretools`和`Categorical`逻辑类型：
- en: '[PRE40]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s load the dataset that described in the *Technical* *requirements* section:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载在*技术* *要求*部分中描述的数据集：
- en: '[PRE41]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s set up an entity set:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置一个实体集：
- en: '[PRE42]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s add the DataFrame to the entity set:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将DataFrame添加到实体集中：
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s create a new DataFrame with a relationship to the DataFrame from *step
    4*:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个与*步骤4*中的DataFrame相关联的新DataFrame：
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about *steps 4* and *5*, visit the *Setting up an entity set
    and creating features* *automatically* recipe.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*步骤4*和*步骤5*的更多详细信息，请访问*设置实体集和自动创建特征* *食谱*。
- en: 'We will multiply the `quantity` and `price` variables, which reflect the number
    of items bought and the unit price, respectively, to obtain the total amount paid:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将乘以`quantity`和`price`变量，分别反映购买的商品数量和单价，以获得总支付金额：
- en: '[PRE45]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We set `agg_primitives` to an empty list to avoid the creation of default primitives.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`agg_primitives`设置为空列表，以避免创建默认的原始操作。
- en: 'Let’s now display the name of the new features:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来显示新特征的名称：
- en: '[PRE46]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the following output, we see the feature names, the last one of which corresponds
    to the combination of the `price` and `quantity` variables:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到特征名称，其中最后一个对应于`price`和`quantity`变量的组合：
- en: '[PRE47]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To finish off, let’s inspect the new DataFrame created in *step 6*:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们检查在*步骤6*中创建的新DataFrame：
- en: '[PRE48]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the following output, we can see that the new feature was appended to the
    right of the original DataFrame:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到新特征被附加到原始DataFrame的右侧：
- en: '![Figure 9.9 – DataFrame with the new feature resulting from the product of
    price with quantity](img/B22396_09_09.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 由价格与数量乘积产生的新特征的DataFrame](img/B22396_09_09.jpg)'
- en: Figure 9.9 – DataFrame with the new feature resulting from the product of price
    with quantity
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 由价格与数量乘积产生的新特征的DataFrame
- en: Combining features with `featuretools` may seem like a lot of work compared
    to the `df["price"].mul(df["quantity"])` `pandas` functionality. The real power
    comes in when we create new features in this way and follow it up with aggregations
    at the invoice or customer level. We will discuss aggregation functions in the
    *Creating features with aggregation* *primitives* recipe.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与`featuretools`结合特征可能比`df["price"].mul(df["quantity"])`的`pandas`功能要复杂得多。真正的力量在于我们以这种方式创建新特征并随后在发票或客户级别进行聚合时。我们将在*使用聚合*
    *原始操作*创建特征*的食谱中讨论聚合函数。
- en: How it works...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To multiply features, we used the `MultiplyNumeric` primitive from `featuretools`,
    which can be accessed from `dfs` using the `multiply_numeric` string. We passed
    the former string to the `trans_primitive` parameter and then used the `primitive_options`
    parameter to specify which variables to multiply. Note that in addition, we passed
    an empty list to the `agg_primitives` parameter to avoid returning the default
    aggregation primitives, and we ignored the features coming from the `invoices`
    DataFrame.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了乘法特征，我们使用了来自 `featuretools` 的 `MultiplyNumeric` 原始操作，它可以通过 `dfs` 使用 `multiply_numeric`
    字符串访问。我们将前一个字符串传递给 `trans_primitive` 参数，然后使用 `primitive_options` 参数指定要乘法的变量。请注意，此外，我们还向
    `agg_primitives` 参数传递了一个空列表，以避免返回默认的聚合原始操作，并且我们忽略了来自 `invoices` DataFrame 的特征。
- en: 'To check out other functions that allow you to combine variables, visit [https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives).
    At the time of writing, I noticed that `MultiplyNumeric` and `DivideNumeric` are
    not in the documentation. You can always double-check which functions are supported
    by inspecting the source code: [https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary](https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary).
    You can also check out which operations you can perform on your data by running
    the following command after you set up the entity set and its relationships: `ft.get_valid_primitives(es,
    target_dataframe_name="data", max_depth=2)`. Here, `es` is the entity set resulting
    from *step 5*.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看允许您组合变量的其他函数，请访问 [https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#binary-transform-primitives)。在撰写本文时，我注意到
    `MultiplyNumeric` 和 `DivideNumeric` 不在文档中。您始终可以通过检查源代码来双检查哪些函数受支持：[https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary](https://github.com/alteryx/featuretools/tree/main/featuretools/primitives/standard/transform/binary)。您还可以通过在设置实体集及其关系后运行以下命令来检查您可以在数据上执行哪些操作：`ft.get_valid_primitives(es,
    target_dataframe_name="data", max_depth=2)`。在这里，`es` 是由 *步骤 5* 得到的实体集。
- en: Extracting features from date and time
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从日期和时间中提取特征
- en: In [*Chapter 6*](B22396_06.xhtml#_idTextAnchor748), *Extracting Features from
    Date and Time* *Variables*, we discussed how we can enrich our datasets by extracting
    features from the date and time parts of datetime variables, such as the year,
    the month, the day of the week, the hour, and much more. We can extract those
    features automatically utilizing `featuretools`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第6章*](B22396_06.xhtml#_idTextAnchor748) 中，*从日期和时间变量中提取特征*，我们讨论了如何通过从日期和时间变量的日期和时间部分提取特征来丰富我们的数据集，例如年份、月份、星期几、小时等等。我们可以利用
    `featuretools` 自动提取这些特征。
- en: The `featuretools` library supports the creation of various features from datetime
    variables using its **datetime transform primitives**. These primitives include
    common variables such as year, month, and day, and other features such as *is
    it lunch time* or *is it weekday*. In addition, we can extract features indicating
    if the date was a federal or bank holiday (as they call it in the UK) or features
    that determine the distance in time to a certain date. For a retail company, the
    proximity to dates such as Boxing Day, Black Fridays, or Christmas normally signals
    an increase in sales, and if they are forecasting demand, these will make useful
    variables.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools` 库支持使用其 **日期时间转换原始操作** 创建来自日期时间变量的各种特征。这些原始操作包括常见的变量，如年份、月份和日期，以及其他特征，如
    *是否是午餐时间* 或 *是否是工作日*。此外，我们可以提取表示日期是否为联邦假日或银行假日（如英国所称）的特征，或者确定到特定日期的时间距离的特征。对于零售公司来说，圣诞节、黑色星期五或节礼日等日期的邻近性通常意味着销售额的增加，如果他们正在预测需求，这些将是有用的变量。'
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on the features that can be created from datetime variables,
    visit [https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可以创建的日期时间变量特征的更多详细信息，请访问 [https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives)。
- en: In this recipe, we will automatically create multiple features from a datetime
    variable with `featuretools`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `featuretools` 自动从日期时间变量创建多个特征。
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let’s begin by importing the libraries and getting the dataset ready:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入库和准备数据集开始：
- en: 'First, we’ll import `pandas`, `featuretools`, and some special datetime primitives:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入`pandas`、`featuretools`和一些特殊的datetime原始函数：
- en: '[PRE49]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s load the dataset described in the *Technical* *requirements* section:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载*技术要求*部分描述的数据集：
- en: '[PRE50]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let’s set up an entity set:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置一个实体集：
- en: '[PRE51]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s add the DataFrame to the entity set:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将DataFrame添加到实体集中：
- en: '[PRE52]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s create a new DataFrame with a relationship to the DataFrame from *step
    4*:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的DataFrame，它与*步骤4*中的DataFrame有关联：
- en: '[PRE53]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about *steps 4* and *5*, visit the *Setting up an entity set
    and creating features* *automatically* recipe.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于*步骤4*和*步骤5*的详细信息，请访问*设置实体集和自动创建特征*配方。
- en: 'Let’s create a primitive that returns a Boolean vector indicating if the date
    coincides with a UK bank holiday (that is, a non-working day):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个返回布尔向量的原始函数，指示日期是否与英国的银行假日（即非工作日）相符（即，非工作日）：
- en: '[PRE54]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When setting up the primitive to determine bank holidays, it is important to
    choose the right country. For a list of supported countries, visit [https://github.com/dr-prodigy/python-holidays#available-countries](https://github.com/dr-prodigy/python-holidays#available-countries).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置用于确定银行假日的原始函数时，选择正确的国家非常重要。要查看支持的国家列表，请访问[https://github.com/dr-prodigy/python-holidays#available-countries](https://github.com/dr-prodigy/python-holidays#available-countries)。
- en: 'Let’s check out which bank holidays are included in this primitive:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查这个原始函数中包含哪些银行假日：
- en: '[PRE55]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we execute `available_hols`, we’ll see a list of bank holidays supported
    for the UK:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行`available_hols`，我们将看到支持英国银行假日的列表：
- en: '[PRE56]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s create another primitive that determines the days to a certain date –
    in this case, the distance to Boxing Day:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个原始函数，用于确定到特定日期的天数 – 在这种情况下，到节礼日的距离：
- en: '[PRE57]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let’s make a list containing strings that identify common features that
    we can get from `datetime` and include the primitives from *steps 6* and *8*:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包含字符串的列表，这些字符串可以识别从`datetime`中获取的常见特征，并包括*步骤6*和*步骤8*中的原始函数：
- en: '[PRE58]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s now create date and time features from *step 9* based on the `invoice_date`
    date variable:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在根据`invoice_date`日期变量从*步骤9*创建日期和时间特征：
- en: '[PRE59]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In *step 4*, we entered the `invoice_date` variable as a time variable. Thus,
    `featuretools` will use this variable to create date- and time-related features.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们将`invoice_date`变量作为时间变量输入。因此，`featuretools`将使用此变量来创建日期和时间相关特征。
- en: 'Let’s display the names of the created features:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示创建的特征的名称：
- en: '[PRE60]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the following output, we see the names of the original and time features:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到原始特征和时间特征的名字：
- en: '[PRE61]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s display the resulting DataFrame containing three of the new features:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示包含三个新特征的DataFrame的结果：
- en: '[PRE62]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the following output, we see the DataFrame with the new features:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到包含新特征的DataFrame：
- en: "![Figure 9.10 – DataF\uFEFFrame with some of the features derived from datetime](img/B22396_09_10.jpg)"
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 从datetime派生的一些DataFrame特征](img/B22396_09_10.jpg)'
- en: Figure 9.10 – DataFrame with some of the features derived from datetime
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 从datetime派生的一些DataFrame特征
- en: Note that some of the created features are numeric, such as `HOUR` or `DAY`,
    some are Booleans, such as `IS_FEDERAL_HOLIDAY`, and some are categorical, such
    as `PART_OF_DAY`. To take a look at the values of `PART_OF_DAY`, execute `feature_matrix["PART_OF_DAY(first_data_time)"].unique()`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到一些创建的特征是数值型的，例如`HOUR`或`DAY`，一些是布尔型的，例如`IS_FEDERAL_HOLIDAY`，还有一些是分类型的，例如`PART_OF_DAY`。要查看`PART_OF_DAY`的值，请执行`feature_matrix["PART_OF_DAY(first_data_time)"].unique()`。
- en: How it works...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To create features from datetime variables, we used datetime transform primitives
    from `featuretools` ([https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives)).
    These primitives can be accessed from `dfs` using the strings and functions we
    specified in *steps 6* to *9* through the `trans_primitive` parameter. Note that
    in addition, we passed an empty list to the `agg_primitives` parameter not to
    return the default aggregation primitives that would have been otherwise applied
    to our datetime features. We also ignored the features coming from the `invoices`
    DataFrame.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要从日期时间变量中创建特征，我们使用了 `featuretools` 的日期时间转换原语 ([https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#datetime-transform-primitives))。这些原语可以通过
    `dfs` 使用我们在 *步骤 6* 到 *9* 中指定的字符串和函数通过 `trans_primitive` 参数访问。请注意，此外，我们还向 `agg_primitives`
    参数传递了一个空列表，以避免返回应用于我们的日期时间特征的默认聚合原语。我们还忽略了来自 `invoices` DataFrame 的特征。
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We set `agg_primitives` to an empty list and ignored the `invoices` DataFrame
    to keep the outputs simple and be able to focus on datetime features. However,
    note that the real power of `featuretools` consists in creating primitives from
    `datetime` and then aggregating them further at different entity levels.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `agg_primitives` 设置为空列表，并忽略了 `invoices` DataFrame，以保持输出简单并能够专注于日期时间特征。然而，请注意，`featuretools`
    的真正威力在于从 `datetime` 创建原语，然后在不同的实体级别进一步聚合它们。
- en: Extracting features from text
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文本中提取特征
- en: In [*Chapter 11*](B22396_11.xhtml#_idTextAnchor1459), *Extracting Features from
    Text Variables*, we will discuss various features that we can extract from text
    pieces utilizing `pandas` and `scikit-learn`. We can also extract multiple features
    from text automatically by utilizing `featuretools`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第11章*](B22396_11.xhtml#_idTextAnchor1459) *从文本变量中提取特征* 中，我们将讨论我们可以利用 `pandas`
    和 `scikit-learn` 从文本片段中提取的各种特征。我们还可以通过利用 `featuretools` 自动从文本中提取多个特征。
- en: The `featuretools` library supports the creation of several basic features from
    text as part of its default functionality, such as the number of characters, the
    number of words, the mean character count per word, and the median word length
    in a piece of text, among others.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools` 库支持创建多个基本特征作为其默认功能的一部分，例如文本中的字符数、单词数、每个单词的平均字符数以及文本片段中的中位词长等。'
- en: Note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a full list of the default text primitives, visit [https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看默认文本原语的全列表，请访问 [https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#naturallanguage-transform-primitives)。
- en: In addition, there is an accompanying Python library, `nlp_primitives`, which
    contains additional primitives to create more advanced features based on NLP.
    Among these functions, we find primitives for determining the diversity score,
    the polarity score, or the count of stop words.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个配套的 Python 库，`nlp_primitives`，其中包含额外的原语，用于基于 NLP 创建更高级的特征。在这些函数中，我们发现了一些用于确定多样性得分、极性得分或停用词计数的原语。
- en: Note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is no documentation at the time of writing to learn more about the primitives
    supported by the `nlp_primitives` library, so to find out more, you need to check
    the source code: [https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives](https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本文档时，没有关于 `nlp_primitives` 库支持的原始语法的文档，因此要了解更多信息，您需要检查源代码：[https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives](https://github.com/alteryx/nlp_primitives/tree/6243ef2379501bfec2c3f19e35a30b5954605e57/nlp_primitives)。
- en: In this recipe, we will first create multiple features from a text variable
    utilizing `featuretools`’ default functionality and then highlight how to use
    primitives from the `nlp_primitives` library.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将首先利用 `featuretools` 的默认功能从文本变量中创建多个特征，然后突出显示如何使用 `nlp_primitives`
    库中的原语。
- en: Getting ready
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To follow along with this recipe, you need to install the `nlp_primitives`
    library, which you can do with `pip`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个配方，您需要安装 `nlp_primitives` 库，您可以使用 `pip` 来完成：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Otherwise, you can use `conda`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以使用 `conda`：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more details, visit the `nlp_primitives` GitHub repository: [https://github.com/alteryx/nlp_primitives](https://github.com/alteryx/nlp_primitives)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请访问 `nlp_primitives` GitHub 仓库：[https://github.com/alteryx/nlp_primitives](https://github.com/alteryx/nlp_primitives)
- en: How to do it...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s begin by importing the libraries and getting the dataset ready:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入库并准备好数据集：
- en: 'First, we’ll import `pandas`, `featuretools`, and the logical types:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入 `pandas`、`featuretools` 和逻辑类型：
- en: '[PRE65]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let’s load the dataset described in the *Technical* *requirements* section:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将第 *技术* *要求* 部分中描述的数据集加载进来：
- en: '[PRE66]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let’s set up an entity set:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置一个实体集：
- en: '[PRE67]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let’s add the DataFrame to the entity set, highlighting that the `description`
    variable is a text variable:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 DataFrame 添加到实体集中，并突出显示 `description` 变量是一个文本变量：
- en: '[PRE68]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the `featuretools` library‘s text primitives to work, we need to indicate
    which variables are text by using the `NaturalLanguage` logical type.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `featuretools` 库的文本原语正常工作，我们需要通过使用 `NaturalLanguage` 逻辑类型来指示哪些变量是文本。
- en: 'Let’s create a new DataFrame with a relationship to the DataFrame from *step
    4*:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 DataFrame，它与第 4 步中的 DataFrame 有关系：
- en: '[PRE69]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about *steps 4* and *5*, visit the *Setting up an entity set
    and creating features* *automatically* recipe.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 *步骤 4* 和 *5* 的详情，请访问 *设置实体集和自动创建特征* 的配方。
- en: 'Let’s make a list with strings corresponding to the text features we want to
    create:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个字符串列表，对应于我们想要创建的文本特征：
- en: '[PRE70]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let’s now extract the text features from the `description` variable:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们从 `description` 变量中提取文本特征：
- en: '[PRE71]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let’s display the names of the created features:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示创建的特征的名称：
- en: '[PRE72]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the following output, we see the names of the original features, followed
    by those created from the `description` variable:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到原始特征名称，然后是来自 `description` 变量的创建特征：
- en: '[PRE73]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let’s display a slice of the DataFrame containing the text-derived features:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示包含文本派生特征的 DataFrame 的一个切片：
- en: '[PRE74]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the following output, we see a DataFrame with the features created from
    the text:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们看到一个包含从文本创建的特征的 DataFrame：
- en: '![Figure 9.11 – DataFrame with the features created from text](img/B22396_09_11.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 从文本创建的特征 DataFrame](img/B22396_09_11.jpg)'
- en: Figure 9.11 – DataFrame with the features created from text
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 从文本创建的特征 DataFrame
- en: Note
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `featuretools` library removes the original text variable, `description`,
    and in its place, it returns the new features.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools` 库移除了原始文本变量 `description`，并返回了新的特征。'
- en: To create features using the primitives from the `nlp_primitives` package, you
    need to import them first – for example, by executing from `nlp_primitives import
    DiversityScore` – and then add the primitives to the text primitive list that
    we created in *step 6*. Note that these are complex functions, so they may take
    some time to create the features.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `nlp_primitives` 包中的原语创建特征，您需要首先导入它们 – 例如，通过执行 `from nlp_primitives import
    DiversityScore` – 然后将原语添加到我们在第 *6* 步中创建的文本原语列表中。请注意，这些是复杂函数，因此创建特征可能需要一些时间。
- en: How it works...
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To create features from text variables, we used the default text primitives
    from `featuretools`. These primitives can be accessed from `dfs` by passing a
    list with strings corresponding to the primitive names, such as those from *step
    6*, to the `trans_primitives` parameter.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文本变量创建特征，我们使用了 `featuretools` 的默认文本原语。这些原语可以通过 `dfs` 通过传递一个字符串列表来访问，这些字符串对应于原语名称，例如第
    *6* 步中的那些，传递给 `trans_primitives` 参数。
- en: For more advanced primitives, you need to import the primitive functions from
    the `nlp_primitives` library and then pass them on to the `trans_primitives` parameter
    from `dfs`. With this, `dfs` can tap into the functionality of these primitives
    to create new features from the text. The `nlp_primitives` library uses the `nltk`
    Python library under the hood.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的原语，您需要从 `nlp_primitives` 库中导入原语函数，然后将它们传递给 `dfs` 的 `trans_primitives`
    参数。这样，`dfs` 就可以利用这些原语的功能从文本中创建新的特征。`nlp_primitives` 库在底层使用 `nltk` Python 库。
- en: Creating features with aggregation primitives
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用聚合原语创建特征
- en: Throughout this chapter, we’ve created features automatically by mapping existing
    variables into new features through various functions. For example, we extracted
    date and time parts from datetime variables, counted the number of words, characters,
    and punctuation in texts, combined numerical features into new variables, and
    transformed features with functions such as sine and cosine. To create these features,
    we worked with transform primitives.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过将现有变量映射到新特征中，通过各种函数自动创建了特征。例如，我们从日期时间变量中提取日期和时间部分，计算文本中的单词、字符和标点符号的数量，将数值特征组合成新变量，并使用正弦和余弦等函数转换特征。为了创建这些特征，我们使用了转换原语。
- en: The `featuretools` library also supports `price`, related to an invoice, an
    aggregation primitive would take all the price observations for a single invoice
    and return a single value, such as the mean price or the sum (that is, the total
    amount paid), for that invoice.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools` 库也支持与发票相关的 `price`，一个聚合原语将取单个发票的所有价格观测值并返回一个单一值，例如该发票的平均价格或总和（即支付的总金额）。'
- en: Note
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `featuretools` aggregation functionality is the equivalent of `groupby`
    in `pandas`, followed by `pandas` functions such as `mean`, `sum`, `std`, and
    `count`, among others.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`featuretools` 的聚合功能相当于 `pandas` 中的 `groupby`，随后是 `pandas` 函数如 `mean`、`sum`、`std`
    和 `count` 等。'
- en: Some aggregation primitives work with numerical variables, such as the mean,
    sum, or maximum and minimum values. Other aggregation primitives are specific
    to categorical variables, such as the number of unique values and the most frequent
    value (mode).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一些聚合原语与数值变量一起工作，例如平均值、总和、最大值和最小值。其他聚合原语是特定于分类变量的，例如唯一值的数量和最频繁的值（众数）。
- en: Note
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete list of supported aggregation primitives, visit [https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取支持的聚合原语的完整列表，请访问 [https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives](https://featuretools.alteryx.com/en/stable/api_reference.html#aggregation-primitives)。
- en: In this recipe, we will first create multiple features by aggregating existing
    variables. After that, we will combine the use of transform and aggregation primitives
    to highlight the true power of `featuretools`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先将通过聚合现有变量来创建多个特征。之后，我们将结合使用转换和聚合原语，以突出 `featuretools` 的真正威力。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the *Online Retail II* dataset from the UCI Machine
    Learning Repository. This dataset has information about products (items), invoices,
    and customers. To follow along with this recipe, it is important to understand
    the nature of and the relationships between these entities and how to correctly
    set up an entity set with `featuretools`, which we described in the *Setting up
    an entity set and creating features automatically* recipe. Make sure you checked
    that recipe out before proceeding with the next section.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用来自 UCI 机器学习仓库的 *Online Retail II* 数据集。这个数据集包含有关产品（项目）、发票和客户的信息。为了跟随这个菜谱，了解这些实体的性质及其关系，以及如何正确设置
    `featuretools` 的实体集，非常重要，这些我们在 *设置实体集和自动创建特征* 菜谱中已经描述过。在继续下一部分之前，请确保你已经查看了那个菜谱。
- en: How to do it...
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s begin by importing the libraries and getting the dataset ready:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入库并准备数据集：
- en: 'First, we’ll import `pandas`, `featuretools`, and the logical types:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入 `pandas`、`featuretools` 和逻辑类型：
- en: '[PRE75]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let’s load the dataset described in the *Technical* *requirements* section:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载 *技术* *要求* 部分中描述的数据集：
- en: '[PRE76]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s set up an entity set:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置一个实体集：
- en: '[PRE77]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let’s add the DataFrame to the entity set, highlighting that the `description`
    variable is a text variable, `customer_id` is categorical, and `invoice_date`
    is a datetime feature:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 DataFrame 添加到实体集中，并突出显示 `description` 变量是一个文本变量，`customer_id` 是分类变量，而 `invoice_date`
    是一个日期时间特征：
- en: '[PRE78]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let’s create a new DataFrame with a relationship to the DataFrame from *step
    4*:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 DataFrame，它与 *步骤 4* 中的 DataFrame 有关系：
- en: '[PRE79]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, we add the second relationship, which is between customers and invoices.
    To do this, we indicate the base DataFrame, which we called `invoices` in *step
    5*, we give the new DataFrame a name, `customers`, and we add a unique customer
    identifier:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加第二个关系，即客户与发票之间的关系。为此，我们指出基础 DataFrame，我们在 *步骤 5* 中将其称为 `invoices`，我们给新的
    DataFrame 起个名字，`customers`，并添加一个唯一的客户标识符：
- en: '[PRE80]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about *steps 4* to *5*, visit the *Setting up an entity set
    and creating features* *automatically* recipe.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于*步骤4*到*步骤5*的详细信息，请访问*设置实体集和自动创建特征*配方。
- en: 'Let’s make a list with string names that identify the aggregation primitives
    we want to use:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个字符串名称列表，以标识我们想要使用的聚合原语：
- en: '[PRE81]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let’s create features by aggregating the data at the customer level. To do
    this, we set up the `dfs` class from `featuretools`, indicating `customers` as
    the target DataFrame and passing the aggregation primitives from *step 7* and
    an empty list to the `trans_primitives` parameter to prevent `dfs` from returning
    the default transformations:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在客户级别聚合数据来创建特征。为此，我们设置`featuretools`中的`dfs`类，将`customers`指定为目标DataFrame，并将*步骤7*中的聚合原语传递给`trans_primitives`参数，同时传递一个空列表以防止`dfs`返回默认的转换：
- en: '[PRE82]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let’s display the names of the created features:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示创建的特征名称：
- en: '[PRE83]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In the following output, we see the name features that were aggregated at the
    customer level:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到在客户级别聚合的特征名称：
- en: '[PRE84]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that `featuretools` names features with the function used to create
    them, followed by the DataFrame that was used in the computation, followed by
    the variable that was used in the computation. Thus, `MAX(data.price)` is the
    maximum price seen in the dataset for each customer. On the other hand, `MEAN(invoices.MAX(data.price))`
    is the mean value of all maximum prices observed in each invoice for a particular
    customer. That is, if a customer has six invoices, we first find the maximum price
    for each of the six invoices and then take the average of those values.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`featuretools`使用创建它们的函数来命名特征，然后是用于计算的DataFrame，最后是用于计算的变量。因此，`MAX(data.price)`是每个客户在数据集中看到的最高价格。另一方面，`MEAN(invoices.MAX(data.price))`是每个客户在特定发票中观察到的所有最高价格的平均值。也就是说，如果一个客户有六张发票，我们首先找到六张发票中的每张的最高价格，然后取这些值的平均值。
- en: 'Let’s now display the resulting DataFrame containing the original data and
    new features:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们显示包含原始数据和新特征的DataFrame的结果：
- en: '[PRE85]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In the following output, we see *some* of the variables in the DataFrame returned
    by `dfs`:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到`dfs`返回的DataFrame中的*一些*变量：
- en: '![Figure 9.12 – DataFrame with some of the features resulting from aggregations
    at the customer level](img/B22396_09_12.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 在客户级别聚合的一些特征结果的DataFrame](img/B22396_09_12.jpg)'
- en: Figure 9.12 – DataFrame with some of the features resulting from aggregations
    at the customer level
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 在客户级别聚合的一些特征结果的DataFrame
- en: 'Due to space limitations, we can’t display the entire output of *step 10*,
    so make sure you execute it on your computer or visit our accompanying GitHub
    repository for more details: [https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间限制，我们无法显示*步骤10*的整个输出，所以请确保你在你的电脑上执行它，或者访问我们的配套GitHub仓库以获取更多详细信息：[https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch09-featuretools/Recipe6-Creating-features-with-aggregation-primitives.ipynb).
- en: To follow up, let’s combine what we learned from the recipes using transform
    primitives with the aggregation functions from this recipe. First, we will create
    new features from existing datetime and text variables; then, we will aggregate
    those features along with the numerical variables, at the customer level.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟进，让我们结合从使用转换原语和本配方中的聚合函数中学习到的内容。首先，我们将从现有的日期时间和文本变量中创建新特征；然后，我们将这些特征与数值变量一起在客户级别进行聚合。
- en: 'Let’s make lists with date and text primitives:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建日期和文本原语列表：
- en: '[PRE86]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let’s make a list with an aggregation primitive:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个包含聚合原语的列表：
- en: '[PRE87]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Let’s now automatically create features by transforming and then aggregating
    variables:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过转换和聚合变量来自动创建特征：
- en: '[PRE88]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The code from *step 13* triggers the creation of the features and their subsequent
    aggregation at the customer level.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*步骤13*中的代码触发了特征的创建以及它们在客户级别的后续聚合。'
- en: 'Let’s display the names of the new features:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们显示新特征的名称：
- en: '[PRE89]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the following output, we see the names of the created variables:'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下输出中，我们可以看到创建的变量的名称：
- en: '[PRE90]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note that in our recipes, we keep the creation of features to a minimum due
    to space limitations, but you can create as many features as you want and enrich
    your datasets dramatically with the functionality built into `featuretools`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的配方中，由于空间限制，我们尽量减少特征的创建，但你可以创建尽可能多的特征，并使用 `featuretools` 内置的功能显著丰富你的数据集。
- en: How it works...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we brought together the creation of features using transform
    primitives, which we discussed throughout the chapter, with the creation of features
    using aggregation primitives.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用转换原语创建特征的方法与使用聚合原语创建特征的方法结合起来，这些方法我们在本章中进行了讨论。
- en: To create features with `featuretools` automatically, we first need to enter
    the data into an entity set and establish the relationships between the data.
    We discussed how to set up an entity set in the *Setting up an entity set and
    creating features* *automatically* recipe.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `featuretools` 自动创建特征，我们首先需要将数据输入到实体集中，并建立数据之间的关系。我们在 *设置实体集和自动创建特征* 的配方中讨论了如何设置实体集。
- en: To aggregate existing features, we used the `dfs` class. We created a list with
    a string corresponding to the aggregation primitives and passed it to the `agg_primitives`
    parameter from `dfs`. To aggregate existing variables without creating new features,
    we passed an empty list to the `trans_primitives` parameter of `dfs`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为了聚合现有特征，我们使用了 `dfs` 类。我们创建了一个包含对应聚合原语字符串的列表，并将其传递给 `dfs` 的 `agg_primitives`
    参数。为了聚合现有变量而不创建新特征，我们将一个空列表传递给 `dfs` 的 `trans_primitives` 参数。
- en: The `customers` DataFrame is the child of the `invoice` DataFrame, which is,
    in turn, the child of the original data. Thus, `dfs` created aggregations from
    the original data and the pre-aggregated data for each invoice. Thus, the `MEAN(data.price)`
    feature consists of the mean price for an item bought by a customer calculated
    from the entire data, whereas `MEAN(invoices.MEAN(data.price))` calculates the
    mean price per invoice first and then takes the mean of those values for a customer.
    Thus, if a customer has five invoices, `featuretools` first calculates the mean
    price paid for each of those invoices and then takes the mean of those values.
    As such, `MEAN(data.price)` and `MEAN(invoices.MEAN(data.price))` are not the
    same feature.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`customers` DataFrame 是 `invoice` DataFrame 的子集，而 `invoice` DataFrame 又是原始数据的子集。因此，`dfs`
    从原始数据和每个发票的预聚合数据中创建了聚合。因此，`MEAN(data.price)` 特征由客户购买的商品的平均价格组成，这个价格是通过整个数据计算得出的，而
    `MEAN(invoices.MEAN(data.price))` 首先计算每个发票的平均价格，然后取这些值的平均值来计算客户的价格。因此，如果一个客户有五张发票，`featuretools`
    首先计算每张发票支付的平均价格，然后取这些值的平均值。因此，`MEAN(data.price)` 和 `MEAN(invoices.MEAN(data.price))`
    不是同一个特征。'
- en: Note
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An aggregate primitive aggregates information for a unique identifier. Aggregate
    primitives use mathematical operations such as the mean, standard deviation, maximum
    and minimum values, the sum, and the skew coefficient for numerical variables.
    For categorical variables, aggregate primitives use the mode and the count of
    unique items. For unique identifiers, aggregate primitives count the number of
    occurrences.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合原语对唯一标识符的信息进行聚合。聚合原语使用数学运算，如均值、标准差、最大值和最小值、总和以及数值变量的偏度系数。对于分类变量，聚合原语使用众数和唯一项的计数。对于唯一标识符，聚合原语计算出现的次数。
- en: Next, we combined the creation of new features from date and text variables
    with aggregation. To do this, we passed a list of strings corresponding to the
    transform primitives to the `trans_primitives` parameter, and another list of
    strings corresponding to the aggregation primitives to the `agg_primitives` parameter
    of `dfs`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将新特征的创建与聚合相结合。为此，我们将对应转换原语的字符串列表传递给 `dfs` 的 `trans_primitives` 参数，并将对应聚合原语的字符串列表传递给
    `dfs` 的 `agg_primitives` 参数。
- en: One of the outputs of *step 13* is a list of the new features. From these, we
    can identify features created from the first invoice date for each customer, such
    as `MONTH(first_invoices_time)` and `WEEKDAY(first_invoices_time)`. We can also
    see features that were aggregated from features created from text, such as `MEAN(data.NUM_WORDS(description))`
    and `MEAN(invoices.MEAN(data.NUM_WORDS(description)))`. Finally, we can see the
    aggregations of existing numerical variables, such as `MEAN(data.price)` and `MEAN(invoices.MEAN(data.price))`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 13* 的一个输出是一个新特性的列表。从这些特性中，我们可以识别出从每个客户的第一个发票日期创建的特性，例如 `MONTH(first_invoices_time)`
    和 `WEEKDAY(first_invoices_time)`。我们还可以看到从文本特性中聚合而来的特性，例如 `MEAN(data.NUM_WORDS(description))`
    和 `MEAN(invoices.MEAN(data.NUM_WORDS(description)))`。最后，我们还可以看到现有数值变量的聚合，例如 `MEAN(data.price)`
    和 `MEAN(invoices.MEAN(data.price))`。'
- en: Note
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to apply transform and aggregation primitives to specific variables,
    you can do so by specifying the primitive options as discussed here: [https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html](https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html).'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将转换和聚合原语应用于特定的变量，你可以通过指定如这里所讨论的原语选项来实现：[https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html](https://docs.featuretools.com/en/stable/guides/specifying_primitive_options.html)。
