- en: Chapter 3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: Working with Quadratic Unconstrained Binary Optimization Problems
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与二次无约束二进制优化问题一起工作
- en: '*The universe cannot be read until we have learned the language and* *become
    familiar with the characters in which it is written.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*宇宙的语言在我们学会这种语言并* *熟悉其字符之前是无法被阅读的*。'
- en: — Galileo Galilei
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——伽利略·伽利莱
- en: Starting with this chapter, we will be studying different algorithms that have
    been proposed to solve optimization problems with quantum computers. We will work
    both with **quantum annealers** and with computers that implement the **quantum
    circuit model**. We will use methods such as the **Quantum Approximate Optimization
    Algorithm** (**QAOA**), **Grover’s** **Adaptive Search** (**GAS**), and the **Variational
    Quantum Eigensolver** (**VQE**). We will also learn how to adapt these algorithms
    to different types of problems, and how to run them on simulators and actual quantum
    computers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将研究被提出用于解决量子计算机优化问题的不同算法。我们将与**量子退火器**以及实现**量子电路模型**的计算机一起工作。我们将使用**量子近似优化算法**（**QAOA**）、**Grover的**
    **自适应搜索**（**GAS**）和**变分量子本征求解器**（**VQE**）等方法。我们还将学习如何将这些算法适应不同类型的问题，以及如何在模拟器和实际的量子计算机上运行它们。
- en: But before we can do all that, we need a language in which we can state problems
    in a manner that makes it possible for a quantum computer to solve them. In this
    regard, with the **Quadratic Unconstrained Binary** **Optimization** (**QUBO**)
    framework, we can formulate many different optimization problems in a way that
    maps directly into the quantum setting, allowing us to use a plethora of quantum
    algorithms to try to find solutions that are optimal or, at least, close to optimal.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们能够做所有这些之前，我们需要一种语言，我们可以用它以使量子计算机能够解决问题的方式陈述问题。在这方面，使用**二次无约束二进制** **优化**（**QUBO**）框架，我们可以以直接映射到量子设置的方式公式的许多不同的优化问题，使我们能够使用大量的量子算法来尝试找到最优或至少接近最优的解决方案。
- en: This chapter will introduce all the tools that we need to work with QUBO formulations.
    We will start by studying the **maximum cut** (or **Max-Cut**) problem in graphs,
    probably the simplest problem that can be formulated in the QUBO framework, and
    we will work our way up from there.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍我们用于处理QUBO公式的所有工具。我们将从研究图中的**最大割**（或**Max-Cut**）问题开始，这可能是QUBO框架中可以公式的最简单问题，然后我们将逐步深入。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: The Max-Cut problem and the Ising model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大割问题与伊辛模型
- en: 'Enter quantum: formulating optimization problems the quantum way'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入量子领域：以量子方式公式的优化问题
- en: Moving from Ising to QUBO and back
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从伊辛到QUBO以及返回
- en: Combinatorial optimization problems with the QUBO model
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于QUBO模型的组合优化问题
- en: After reading this chapter, you will be ready to write your own optimization
    problems in a format that will allow you to solve them using quantum computers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你将准备好以适合使用量子计算机解决优化问题的格式编写自己的优化问题。
- en: 3.1 The Max-Cut problem and the Ising model
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 最大割问题与伊辛模型
- en: In order for us to understand how to use quantum computers to solve optimization
    problems, we need to get used to some abstractions and techniques that we will
    develop throughout this chapter. To get started, we will consider the problem
    of finding what we call **maximum cuts** in a mathematical structure called a
    **graph**. This is possibly the simplest problem that can be written in the formalism
    that we will be using in the following chapters. It will help us in gaining intuition
    and it will provide a solid foundation for formulating more complicated problems
    later on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们了解如何使用量子计算机解决优化问题，我们需要习惯一些在本章中我们将发展的抽象和技巧。为了开始，我们将考虑在称为**图**的数学结构中找到我们所说的**最大割**的问题。这可能是在我们将在以下章节中使用的形式主义中可以写出的最简单问题。这将帮助我们获得直觉，并为以后公式的更复杂问题提供一个坚实的基础。
- en: 3.1.1 Graphs and cuts
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.1 图和割集
- en: When you are given a graph, you are essentially given some *elements*, which
    we will refer to as **vertices**, and some *connections* between pairs of these
    vertices, which we will call **edges**. See *Figure* *[*3.1*](#Figure3.1) for
    an example of a graph with five vertices and six edges.*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你得到一个图时，你实际上得到了一些*元素*，我们将它们称为**顶点**，以及这些顶点对之间的某些*连接*，我们将它们称为**边**。参见*图*[*3.1*](#Figure3.1)以了解一个具有五个顶点和六条边的图的示例。
- en: '*![Figure 3.1: Example of a graph](img/file303.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图3.1：图的示例](img/file303.jpg)'
- en: '**Figure 3.1**: Example of a graph'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.1**：图的示例'
- en: Given a graph, the **Max-Cut problem** consists in finding a **maximum cut**
    of it. That is, we want to divide the vertices of the graph into two sets — that’s
    what we call **cutting** the graph into two parts — such that the number of edges
    with extremes in different sets of the cut is the maximum possible. We call the
    number of such edges the **size of the cut**, and we say that these edges are
    **cut**. You can imagine that, for instance, the vertices represent workers of
    a company, edges have been added between people who don’t get along that well,
    and you need to form two teams trying to minimize the number of conflicts by putting
    potential enemies in different teams.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个图，**最大割问题**在于找到它的**最大割**。也就是说，我们想要将图的顶点分成两个集合——这就是我们所说的将图**割**成两部分——使得不同集合的割边数量达到最大。我们称这样的边数为**割的大小**，并称这些边为**割边**。你可以想象，例如，顶点代表公司的员工，边被添加到那些相处不太融洽的人之间，你需要组成两个团队，通过将潜在的敌人分到不同的团队中来尽量减少冲突。
- en: '*Figure* *[*3.2*](#Figure3.2) presents two different cuts for the graph in
    *Figure* *[*3.1*](#Figure3.1), using different colors for vertices that go in
    different sets and using dashed lines for edges that have extremes in different
    parts of the cut. As you can see, the cut in *Figure* *[*3.2a*](#Figure3.2a) has
    size ![5](img/file296.png "5"), while the cut in *Figure* * [*3.2b*](#Figure3.2b)
    is of size ![4](img/file143.png "4"). In fact, it is easy to check that no cut
    of this graph can have a size bigger than ![5](img/file296.png "5") since vertices
    ![0,1](img/file304.png "0,1"), and ![2](img/file302.png "2") can’t all go in different
    sets and, hence, at least one of the edges ![(0,1)](img/file305.png "(0,1)"),
    ![(0,2)](img/file306.png "(0,2)"), or ![(1,2)](img/file307.png "(1,2)") will not
    be cut. The cut in *Figure* * [*3.2a*](#Figure3.2a) is, then, a **maximum** or
    **optimal** cut.*****'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图*[*3.2*](#Figure3.2)展示了*图*[*3.1*](#Figure3.1)的两种不同割，使用不同颜色表示属于不同集合的顶点，使用虚线表示割的不同部分的边。如图所示，*图*[*3.2a*](#Figure3.2a)的割大小为![5](img/file296.png
    "5")，而*图*[*3.2b*](#Figure3.2b)的割大小为![4](img/file143.png "4")。实际上，很容易检查出这个图没有任何割的尺寸能超过![5](img/file296.png
    "5")，因为顶点![0,1](img/file304.png "0,1")和![2](img/file302.png "2")不能全部属于不同的集合，因此至少有一条边![（0,1）](img/file305.png
    "(0,1)"), ![（0,2）](img/file306.png "(0,2)"), 或![（1,2）](img/file307.png "(1,2)")不会被割。因此，*图*[*3.2a*](#Figure3.2a)是一个**最大**或**最优**割。'
- en: '**![(a)](img/file308.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**![（a）](img/file308.jpg)**'
- en: '**(a)**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**（a）**'
- en: '![(b)](img/file309.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![（b）](img/file309.jpg)'
- en: '**(b)**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**（b）**'
- en: '**Figure 3.2**: Two different cuts of the same graph'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.2**：同一图的两种不同割'
- en: Exercise 3.1
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 练习3.1
- en: The maximum cut in a graph doesn’t need to be unique. Find a maximum cut for
    the graph in *Figure* *[*3.1*](#Figure3.1) in which vertices ![0](img/file12.png
    "0") and ![1](img/file13.png "1") are in the same set.*
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的最大割不一定是唯一的。在*图*[*3.1*](#Figure3.1)中找到最大割，其中顶点![0](img/file12.png "0")和![1](img/file13.png
    "1")属于同一集合。
- en: '*So now we know what the Max-Cut problem is about. But how do we formulate
    it mathematically? We will learn exactly that in the next subsection.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*因此，我们现在已经知道了最大割问题是什么。但是，我们如何将其数学化呢？我们将在下一小节中详细了解这一点。*'
- en: 3.1.2 Formulating the problem
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.2 问题表述
- en: 'Surprisingly enough, we can formulate the Max-Cut problem as a combinatorial
    optimization problem with no reference whatsoever to graphs, edges, or vertices.
    In order to do that, we associate a variable ![z_{i}](img/file310.png "z_{i}")
    to each vertex ![i = 0,\ldots,n - 1](img/file311.png "i = 0,\ldots,n - 1") of
    the graph. Variables ![z_{i}](img/file310.png "z_{i}") will take value ![1](img/file13.png
    "1") or ![- 1](img/file312.png "- 1"). Each assignment of values to the variables
    determines a cut: vertices whose variables take value ![1](img/file13.png "1")
    will be in one set and vertices whose variables take value ![- 1](img/file312.png
    "- 1") will be in the other one. For instance, for the cut of *Figure* * [*3.2a*](#Figure3.2a)
    we could have ![z_{0} = z_{2} = z_{3} = 1](img/file313.png "z_{0} = z_{2} = z_{3}
    = 1") and ![z_{1} = z_{4} = - 1](img/file314.png "z_{1} = z_{4} = - 1"). Notice
    that, for our purposes, we could also represent that cut with the assignment ![z_{0}
    = z_{2} = z_{3} = - 1](img/file315.png "z_{0} = z_{2} = z_{3} = - 1"), ![z_{1}
    = z_{4} = 1](img/file316.png "z_{1} = z_{4} = 1").*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们可以将最大割问题表述为一个与图、边或顶点无关的组合优化问题。为了做到这一点，我们为图中的每个顶点![i = 0,\ldots,n -
    1](img/file311.png "i = 0,\ldots,n - 1")关联一个变量![z_{i}](img/file310.png "z_{i}")。变量![z_{i}](img/file310.png
    "z_{i}")将取值![1](img/file13.png "1")或![- 1](img/file312.png "- 1")。变量的每个值赋都确定了一个割：取值为![1](img/file13.png
    "1")的变量对应的顶点将属于一个集合，而取值为![- 1](img/file312.png "- 1")的变量对应的顶点将属于另一个集合。例如，对于*图*
    * [*3.2a*](#Figure3.2a)的割，我们可能有![z_{0} = z_{2} = z_{3} = 1](img/file313.png "z_{0}
    = z_{2} = z_{3} = 1")和![z_{1} = z_{4} = - 1](img/file314.png "z_{1} = z_{4} =
    - 1")。请注意，为了我们的目的，我们也可以用![z_{0} = z_{2} = z_{3} = - 1](img/file315.png "z_{0}
    = z_{2} = z_{3} = - 1")和![z_{1} = z_{4} = 1](img/file316.png "z_{1} = z_{4} =
    1")的赋值来表示那个割。*
- en: '*The key observation to formulate Max-Cut as a combinatorial optimization problem
    is to notice that, if there is an edge between two vertices ![j](img/file258.png
    "j") and ![k](img/file317.png "k"), then that edge is cut if and only if ![z_{j}z_{k}
    = - 1](img/file318.png "z_{j}z_{k} = - 1"). This is because if the two vertices
    are in the same set, then either ![z_{j} = z_{k} = 1](img/file319.png "z_{j} =
    z_{k} = 1") or ![z_{j} = z_{k} = - 1](img/file320.png "z_{j} = z_{k} = - 1") and,
    consequently, ![z_{j}z_{k} = 1](img/file321.png "z_{j}z_{k} = 1"). However, if
    they are in different sets, then either ![z_{j} = 1](img/file322.png "z_{j} =
    1") and ![z_{k} = - 1](img/file323.png "z_{k} = - 1"), or ![z_{j} = - 1](img/file324.png
    "z_{j} = - 1") and ![z_{k} = 1](img/file325.png "z_{k} = 1"), yielding ![z_{j}z_{k}
    = - 1](img/file318.png "z_{j}z_{k} = - 1").'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*将最大割问题表述为组合优化问题的关键观察是注意到，如果两个顶点![j](img/file258.png "j")和![k](img/file317.png
    "k")之间存在一条边，那么这条边被割断当且仅当![z_{j}z_{k} = - 1](img/file318.png "z_{j}z_{k} = - 1")。这是因为如果这两个顶点属于同一个集合，那么要么![z_{j}
    = z_{k} = 1](img/file319.png "z_{j} = z_{k} = 1")，要么![z_{j} = z_{k} = - 1](img/file320.png
    "z_{j} = z_{k} = - 1")，从而![z_{j}z_{k} = 1](img/file321.png "z_{j}z_{k} = 1")。然而，如果它们属于不同的集合，那么要么![z_{j}
    = 1](img/file322.png "z_{j} = 1")且![z_{k} = - 1](img/file323.png "z_{k} = - 1")，要么![z_{j}
    = - 1](img/file324.png "z_{j} = - 1")且![z_{k} = 1](img/file325.png "z_{k} = 1")，从而![z_{j}z_{k}
    = - 1](img/file318.png "z_{j}z_{k} = - 1")。*'
- en: Thus, our problem can be written as
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的问题可以写成
- en: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {\sum\limits_{(j,k) \in E}z_{j}z_{k}\qquad}
    & & \qquad \\ {\text{subject~to~}\quad} & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,n
    - 1\qquad} & & \qquad \\ \end{array}](img/file326.png "\begin{array}{rlrl} {\text{Minimize~}\quad}
    & {\sum\limits_{(j,k) \in E}z_{j}z_{k}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,n - 1\qquad} & & \qquad \\ \end{array}")'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {\sum\limits_{(j,k) \in E}z_{j}z_{k}\qquad}
    & & \qquad \\ {\text{subject~to~}\quad} & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,n
    - 1\qquad} & & \qquad \\ \end{array}](img/file326.png "\begin{array}{rlrl} {\text{Minimize~}\quad}
    & {\sum\limits_{(j,k) \in E}z_{j}z_{k}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,n - 1\qquad} & & \qquad \\ \end{array}")'
- en: where ![E](img/file327.png "E") is the set of edges in the graph and the vertices
    are ![\{ 0,\ldots,n - 1\}](img/file328.png "\{ 0,\ldots,n - 1\}"). For instance,
    for the graph in *Figure* * [*3.1*](#Figure3.1), we would have the following formulation:*
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![E](img/file327.png "E")是图中边的集合，顶点是![\{ 0,\ldots,n - 1\}](img/file328.png
    "\{ 0,\ldots,n - 1\}")。例如，对于*图* * [*3.1*](#Figure3.1)中的图，我们会有以下表述：*
- en: '*![\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} + z_{0}z_{2} +
    z_{1}z_{2} + z_{1}z_{3} + z_{2}z_{4} + z_{3}z_{4}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,4.\qquad} & & \qquad \\ \end{array}](img/file329.png
    "\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} + z_{0}z_{2} + z_{1}z_{2}
    + z_{1}z_{3} + z_{2}z_{4} + z_{3}z_{4}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,4.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} + z_{0}z_{2} +
    z_{1}z_{2} + z_{1}z_{3} + z_{2}z_{4} + z_{3}z_{4}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,4.\qquad} & & \qquad \\ \end{array}](img/file329.png
    "\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} + z_{0}z_{2} + z_{1}z_{2}
    + z_{1}z_{3} + z_{2}z_{4} + z_{3}z_{4}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,4.\qquad} & & \qquad \\ \end{array}")'
- en: Note that the cut ![z_{0} = z_{2} = z_{3} = 1](img/file313.png "z_{0} = z_{2}
    = z_{3} = 1"), ![z_{1} = z_{4} = - 1](img/file314.png "z_{1} = z_{4} = - 1") (which
    is the one in *Figure* * [*3.2a*](#Figure3.2a)), attains a value of ![- 4](img/file330.png
    "- 4") in the function to be minimized, which is the minimum possible value for
    this particular case — but notice that it does not coincide with the number of
    edges that are cut! The cut ![z_{0} = z_{3} = - 1](img/file331.png "z_{0} = z_{3}
    = - 1"), ![z_{1} = z_{2} = z_{4} = 1](img/file332.png "z_{1} = z_{2} = z_{4} =
    1"), on the other hand, achieves a value of ![- 2](img/file333.png "- 2"), showing
    once again that the cut on *Figure* * [*3.2b*](#Figure3.2b) is not optimal.**
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，切割 ![z_{0} = z_{2} = z_{3} = 1](img/file313.png "z_{0} = z_{2} = z_{3} =
    1"), ![z_{1} = z_{4} = - 1](img/file314.png "z_{1} = z_{4} = - 1")（如图 *图* * [*3.2a*](#Figure3.2a)
    所示），在要最小化的函数中达到的值为 ![- 4](img/file330.png "- 4")，这是此特定情况的最小可能值——但请注意，它并不与切割的边数相吻合！另一方面，切割
    ![z_{0} = z_{3} = - 1](img/file331.png "z_{0} = z_{3} = - 1"), ![z_{1} = z_{2}
    = z_{4} = 1](img/file332.png "z_{1} = z_{2} = z_{4} = 1")，达到的值为 ![- 2](img/file333.png
    "- 2")，再次表明 *图* * [*3.2b*](#Figure3.2b) 中的切割不是最优的。
- en: '**Exercise 3.2'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 3.2'
- en: Write the Max-Cut problem for the graph in *Figure* *[*3.3*](#Figure3.3) as
    an optimization problem. What is the value of the function to be minimized when
    ![z_{0} = z_{1} = z_{2} = 1](img/file334.png "z_{0} = z_{1} = z_{2} = 1") and
    ![z_{3} = z_{4} = z_{5} = - 1](img/file335.png "z_{3} = z_{4} = z_{5} = - 1").
    Is it an optimal cut?*
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *图* *[*3.3*](#Figure3.3) 中的最大切割问题写成优化问题。当 ![z_{0} = z_{1} = z_{2} = 1](img/file334.png
    "z_{0} = z_{1} = z_{2} = 1") 和 ![z_{3} = z_{4} = z_{5} = - 1](img/file335.png
    "z_{3} = z_{4} = z_{5} = - 1") 时，要最小化的函数的值是多少？这是一个最优切割吗？
- en: '*![Figure 3.3: Another example of a graph](img/file336.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图 3.3: 另一个图的示例](img/file336.jpg)'
- en: '**Figure 3.3**: Another example of a graph'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.3**：另一个图的示例'
- en: At first sight, solving the Max-Cut problem might seem easy enough. However,
    it is an **NP-hard** problem (refer to *Appendix* *[*C*](ch026.xhtml#x1-233000C),
    *Computational* *Complexity*, for more details on this kind of problem). That
    means that if we were able to solve it efficiently with a classical algorithm,
    we would have ![P = NP](img/file337.png "P = NP"), something the scientific community
    strongly believes not to be true. This would be the case even if we could find
    a classical algorithm that approximates the optimal cut within a factor of ![\left.
    16\slash 17 \right.](img/file338.png "\left. 16\slash 17 \right."), as was proved
    by Håstad in a paper published in 2001 [[50](ch030.xhtml#Xhastad01optimal)]. So,
    even if we resort to looking for precise enough approximations, the problem is
    indeed hard!*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，解决最大切割问题似乎足够简单。然而，它是一个 **NP-hard** 问题（有关这类问题的更多详细信息，请参阅 *附录* *[*C*](ch026.xhtml#x1-233000C),
    *计算复杂性*）。这意味着如果我们能够用经典算法有效地解决它，我们就会得到 ![P = NP](img/file337.png "P = NP")，这是科学界普遍认为不真实的事情。即使我们能够找到一个经典算法，在因子
    ![\left. 16\slash 17 \right.](img/file338.png "\left. 16\slash 17 \right.") 内近似最优切割，这种情况也会发生，正如
    Håstad 在 2001 年发表的一篇论文中证明的那样 [[50](ch030.xhtml#Xhastad01optimal)]。因此，即使我们求助于寻找足够精确的近似值，这个问题确实很困难！
- en: '*To learn more…'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*要了解更多…'
- en: 'If you want to learn more about ![P](img/file1.png "P"), ![NP](img/file2.png
    "NP"), and ![NP](img/file2.png "NP")-hard problems, please check *Appendix* *
    [*C*](ch026.xhtml#x1-233000C), *Computational Complexity*. We will be discussing
    the **ratio of approximation** that quantum algorithms can achieve for the Max-Cut
    problem in *Chapter* * [*5*](ch013.xhtml#x1-940005), *QAOA: Quantum* *Approximate
    Optimization Algorithm*.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你想了解更多关于 ![P](img/file1.png "P"), ![NP](img/file2.png "NP"), 和 ![NP](img/file2.png
    "NP")-hard 问题，请查看 *附录* * [*C*](ch026.xhtml#x1-233000C), *计算复杂性*。我们将在 *第* * [*5*](ch013.xhtml#x1-940005),
    *QAOA: 量子* *近似优化算法* * 中讨论量子算法对于最大切割问题所能达到的近似比率。'
- en: '**We are now able to formulate Max-Cut as a minimization problem in which the
    variables take values ![1](img/file13.png "1") and ![- 1](img/file312.png "- 1").
    Is this just accidental or are there more problems that can be written in a similar
    way? Keep on reading and you will learn the answer in the next subsection.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们现在能够将Max-Cut表述为一个变量取值为![1](img/file13.png "1")和![ - 1](img/file312.png
    "- 1")的最小化问题。这仅仅是巧合，还是有更多问题可以用类似的方式表述？继续阅读，你将在下一小节中找到答案。'
- en: 3.1.3 The Ising model
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1.3 伊辛模型
- en: 'The Max-Cut problem, as formulated in the previous pages, can be seen as just
    a particular case of a seemingly unrelated problem in statistical physics: finding
    the state of minimum **energy** of an instance of the **Ising model**. For the
    physics geeks out there, this is a mathematical model for the ferromagnetic interaction
    of particles with **spin**, usually arranged in a lattice (see *Figure* *[*3.4*](#Figure3.4)
    and refer to the book by Gallavotti [[42](ch030.xhtml#Xgallavotti1999statistical)]
    for more details). The particle spins are represented by variables ![z_{j}](img/file339.png
    "z_{j}") that can take values ![1](img/file13.png "1") (spin up) or ![- 1](img/file312.png
    "- 1") (spin down) — sounds familiar, doesn’t it?*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几页所阐述的Max-Cut问题，可以看作是统计物理中一个看似无关问题的特例：寻找伊辛模型实例的最小**能量**状态。对于物理学爱好者来说，这是一个描述具有**自旋**粒子的铁磁相互作用的数学模型，通常排列在晶格中（参见*图*
    *[*3.4*](#Figure3.4) 并参考Gallavotti的书籍[[42](ch030.xhtml#Xgallavotti1999statistical)]以获取更多详细信息）。粒子自旋由变量![z_{j}](img/file339.png
    "z_{j}")表示，可以取值![1](img/file13.png "1")（自旋向上）或![ - 1](img/file312.png "- 1")（自旋向下）——听起来熟悉，不是吗？
- en: '*![Figure 3.4: Example of the Ising model](img/file340.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图3.4：伊辛模型的示例](img/file340.jpg)'
- en: '**Figure 3.4**: Example of the Ising model'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.4**：伊辛模型的示例'
- en: The total energy of the system is given by a quantity called the **Hamiltonian**
    function (more about this later in this chapter) defined by
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的总能量由称为**哈密顿**函数的量给出（关于这一点将在本章后面详细介绍）定义为
- en: '![- \sum\limits_{j,k}J_{jk}z_{j}z_{k} - \sum\limits_{j}h_{j}z_{j}](img/file341.png
    "- \sum\limits_{j,k}J_{jk}z_{j}z_{k} - \sum\limits_{j}h_{j}z_{j}")'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![ - \sum\limits_{j,k}J_{jk}z_{j}z_{k} - \sum\limits_{j}h_{j}z_{j}](img/file341.png
    "- \sum\limits_{j,k}J_{jk}z_{j}z_{k} - \sum\limits_{j}h_{j}z_{j}")'
- en: where the coefficients ![J_{jk}](img/file342.png "J_{jk}") represent the interaction
    between particles ![j](img/file258.png "j") and ![k](img/file317.png "k") (usually,
    only non-zero for adjacent particles) and the coefficients ![h_{j}](img/file343.png
    "h_{j}") represent the influence of an external magnetic field on particle ![j](img/file258.png
    "j").
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，系数![J_{jk}](img/file342.png "J_{jk}")代表粒子![j](img/file258.png "j")和![k](img/file317.png
    "k")之间的相互作用（通常，只有相邻粒子的系数不为零）和系数![h_{j}](img/file343.png "h_{j}")代表外部磁场对粒子![j](img/file258.png
    "j")的影响。
- en: Finding the state of minimum energy of the system consists in obtaining a spin
    configuration for which the Hamiltonian function attains its minimum value. As
    you can easily check yourself, when all the ![J_{jk}](img/file342.png "J_{jk}")
    coefficients are ![- 1](img/file312.png "- 1") and all the ![h_{j}](img/file343.png
    "h_{j}") coefficients are ![0](img/file12.png "0"), the problem is exactly the
    same as getting the maximum cut in a graph — although in a completely different
    context! Of course, this makes the problem of finding the state of minimum energy
    of a given Ising model an ![NP](img/file2.png "NP")-hard problem.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找系统的最小能量状态，在于获得一个使得哈密顿函数达到最小值的自旋配置。正如你可以轻松检查的那样，当所有![J_{jk}](img/file342.png
    "J_{jk}")系数为![ - 1](img/file312.png "- 1")，所有![h_{j}](img/file343.png "h_{j}")系数为![0](img/file12.png
    "0")时，问题与在图中获得最大割集的问题完全相同——尽管在完全不同的背景下！当然，这使得寻找给定伊辛模型的最小能量状态成为一个![NP](img/file2.png
    "NP")-难问题。
- en: To learn more…
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: The quantum annealers that we will be using in *Chapter* *[*4*](ch012.xhtml#x1-750004),
    *Quantum Adiabatic Computing and Quantum Annealing*, are quantum computers constructed
    with the specific purpose of sampling from states of low energy of systems whose
    behavior can be described with the Ising model. We will use this property to try
    to approximate solutions to Max-Cut and many other related problems.*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第4章* *[*4*](ch012.xhtml#x1-750004)，*量子绝热计算与量子退火*中使用的量子退火器，是专门用于从可以用伊辛模型描述的系统低能量状态中进行采样的量子计算机。我们将利用这一特性来尝试近似Max-Cut和其他许多相关问题的解。
- en: '*Let’s give an example of the problem of finding the minimum energy state of
    an Ising model. Imagine that we have particles arranged as in *Figure* *[*3.4*](#Figure3.4),
    where the numbers on the edges represent the coefficients ![J_{jk}](img/file342.png
    "J_{jk}") and we assume that the external magnetic field is homogeneous and that
    all coefficients ![h_{j}](img/file343.png "h_{j}") are equal to ![1](img/file13.png
    "1"). Then, the problem can be formulated as follows:*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们以寻找伊辛模型最小能量状态的问题为例。想象一下，我们有一些粒子按照 *图* *[*3.4*](#Figure3.4) 中的方式排列，其中边上的数字代表系数
    ![J_{jk}](img/file342.png "J_{jk}")，我们假设外部磁场是均匀的，并且所有系数 ![h_{j}](img/file343.png
    "h_{j}") 都等于 ![1](img/file13.png "1")。然后，问题可以表述如下：*'
- en: '*![\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} - 2z_{1}z_{2}
    + z_{2}z_{3} - 3z_{0}z_{4} + z_{1}z_{5} + z_{2}z_{6} - 3z_{3}z_{7}\qquad} & &
    \qquad \\ & {+ z_{4}z_{5} - 2z_{5}z_{6} + z_{6}z_{7} - 3z_{4}z_{8} + z_{5}z_{9}
    + z_{6}z_{10} - 3z_{7}z_{11}\qquad} & & \qquad \\ & {+ z_{8}z_{9} - 2z_{9}z_{10}
    + z_{10}z_{11} - z_{0} - z_{1} - z_{2} - z_{3} - z_{4} - z_{5}\qquad} & & \qquad
    \\ & {- z_{6} - z_{7} - z_{8} - z_{9} - z_{10} - z_{11}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,11.\qquad} & & \qquad \\ \end{array}](img/file344.png
    "\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} - 2z_{1}z_{2} + z_{2}z_{3}
    - 3z_{0}z_{4} + z_{1}z_{5} + z_{2}z_{6} - 3z_{3}z_{7}\qquad} & & \qquad \\  &
    {+ z_{4}z_{5} - 2z_{5}z_{6} + z_{6}z_{7} - 3z_{4}z_{8} + z_{5}z_{9} + z_{6}z_{10}
    - 3z_{7}z_{11}\qquad} & & \qquad \\  & {+ z_{8}z_{9} - 2z_{9}z_{10} + z_{10}z_{11}
    - z_{0} - z_{1} - z_{2} - z_{3} - z_{4} - z_{5}\qquad} & & \qquad \\  & {- z_{6}
    - z_{7} - z_{8} - z_{9} - z_{10} - z_{11}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,11.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} - 2z_{1}z_{2}
    + z_{2}z_{3} - 3z_{0}z_{4} + z_{1}z_{5} + z_{2}z_{6} - 3z_{3}z_{7}\qquad} & &
    \qquad \\ & {+ z_{4}z_{5} - 2z_{5}z_{6} + z_{6}z_{7} - 3z_{4}z_{8} + z_{5}z_{9}
    + z_{6}z_{10} - 3z_{7}z_{11}\qquad} & & \qquad \\ & {+ z_{8}z_{9} - 2z_{9}z_{10}
    + z_{10}z_{11} - z_{0} - z_{1} - z_{2} - z_{3} - z_{4} - z_{5}\qquad} & & \qquad
    \\ & {- z_{6} - z_{7} - z_{8} - z_{9} - z_{10} - z_{11}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,11.\qquad} & & \qquad \\ \end{array}](img/file344.png
    "\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} - 2z_{1}z_{2} + z_{2}z_{3}
    - 3z_{0}z_{4} + z_{1}z_{5} + z_{2}z_{6} - 3z_{3}z_{7}\qquad} & & \qquad \\  &
    {+ z_{4}z_{5} - 2z_{5}z_{6} + z_{6}z_{7} - 3z_{4}z_{8} + z_{5}z_{9} + z_{6}z_{10}
    - 3z_{7}z_{11}\qquad} & & \qquad \\  & {+ z_{8}z_{9} - 2z_{9}z_{10} + z_{10}z_{11}
    - z_{0} - z_{1} - z_{2} - z_{3} - z_{4} - z_{5}\qquad} & & \qquad \\  & {- z_{6}
    - z_{7} - z_{8} - z_{9} - z_{10} - z_{11}\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {z_{j} \in \{ - 1,1\},\qquad j = 0,\ldots,11.\qquad} & & \qquad \\ \end{array}")'
- en: This seems a little more involved than the formulations of the Max-Cut problem
    that we have seen so far, but it clearly follows the same pattern. However, you
    could be wondering what all this has to with quantum computing, since all these
    formulas only involve classical variables. Fair point! It is now time to use our
    knowledge of qubits and quantum gates to try to see all these problems under a
    different, quantum light.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎比我们迄今为止所看到的 Max-Cut 问题的公式更复杂一些，但它显然遵循相同的模式。然而，你可能想知道所有这些与量子计算有什么关系，因为所有这些公式只涉及经典变量。这是一个很好的观点！现在是时候利用我们对量子比特和量子门的知识，尝试以不同的、量子化的视角来看待所有这些问题了。
- en: '3.2 Enter quantum: formulating optimization problems the quantum way'
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 进入量子：以量子方式制定优化问题
- en: In this section, we will unveil how all the work that we have done so far in
    this chapter has followed a secret plan! Was the choice of ![z](img/file81.png
    "z") as the name for the variables in our problems completely arbitrary? Of course
    not! If it made you think of those lovely ![Z](img/file8.png "Z") quantum gates
    and matrices that we introduced back in *Chapter* * [*1*](ch008.xhtml#x1-180001),
    *Foundations* *of Quantum Computing*, you were on the right track. It will be
    the key to introducing the *quantum factor* into our problems, as we will begin
    to see in the next subsection.*
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将揭示我们迄今为止在本章中所做的一切工作是如何遵循一个秘密计划的！选择 ![z](img/file81.png "z") 作为我们问题中变量的名称是完全随意的吗？当然不是！如果你想起了我们在
    *第* *[*1*](ch008.xhtml#x1-180001) *章* *[*1*] *《量子计算基础》* 中引入的那些可爱的 ![Z](img/file8.png
    "Z") 量子门和矩阵，你就走在了正确的道路上。它将是引入 *量子因子* 到我们问题的关键，正如我们将在下一小节中开始看到的。
- en: '*## 3.2.1 From classical variables to qubits'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*## 3.2.1 从经典变量到量子比特'
- en: So far, the formulations that we have considered for the Max-Cut problem and
    for the Ising model are purely classical. They do not mention quantum elements
    such as qubits, quantum gates, or measurements. But we are closer than you might
    think to being able to give a quantum formulation for these problems. We will
    start with a very simple instance of the Max-Cut problem and show how we can easily
    transform it into *quantum form*. Consider the graph in *Figure* *[*3.5*](#Figure3.5).
    We already know that the corresponding Max-Cut problem can be written as follows:*
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑的最大切割问题和伊辛模型都是纯粹的经典公式。它们没有提到量子元素，如量子比特、量子门或测量。但事实上，我们比你想的更接近于为这些问题提供一个量子公式。我们将从一个非常简单的最大切割问题实例开始，并展示我们如何轻松地将它转化为*量子形式*。考虑图
    *[*3.5*](#Figure3.5)。我们已经知道相应的最大切割问题可以写成以下形式：*
- en: '*![\begin{array}{rlrl} {\text{Minimize~}\quad} & {z_{0}z_{1} + z_{0}z_{2}\qquad}
    & & \qquad \\ {\text{subject~to~}\quad} & {z_{j} \in \{ - 1,1\},\qquad j = 0,1,2.\qquad}
    & & \qquad \\ \end{array}](img/file345.png "\begin{array}{rlrl} {\text{Minimize~}\quad}
    & {z_{0}z_{1} + z_{0}z_{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {z_{j}
    \in \{ - 1,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\begin{array}{rlrl} {\text{最小化~}\quad} & {z_{0}z_{1} + z_{0}z_{2}\qquad}
    & & \qquad \\ {\text{约束~}\quad} & {z_{j} \in \{ - 1,1\},\qquad j = 0,1,2.\qquad}
    & & \qquad \\ \end{array}](img/file345.png "\begin{array}{rlrl} {\text{最小化~}\quad}
    & {z_{0}z_{1} + z_{0}z_{2}\qquad} & & \qquad \\ {\text{约束~}\quad} & {z_{j} \in
    \{ - 1,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}")'
- en: '![Figure 3.5: A very simple Max-Cut problem](img/file346.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：一个非常简单的最大切割问题](img/file346.jpg)'
- en: '**Figure 3.5**: A very simple Max-Cut problem'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 3.5**：一个非常简单的最大切割问题'
- en: The crucial observation that we need to make in order to transform this formulation
    into a quantum one is that our beloved ![Z](img/file8.png "Z") matrix can be used
    to evaluate the different terms in the function that we need to minimize. Namely,
    it is easy to check that
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个公式转化为量子公式，我们需要做出一个关键观察：我们心爱的 ![Z](img/file8.png "Z") 矩阵可以用来评估我们需要最小化的函数中的不同项。具体来说，很容易验证
- en: '![\left\langle 0 \right|Z\left| 0 \right\rangle = \begin{pmatrix} 1 & 0 \\
    \end{pmatrix}\begin{pmatrix} 1 & 0 \\ 0 & {- 1} \\ \end{pmatrix}\begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix} = 1,\qquad\left\langle 1 \right|Z\left| 1 \right\rangle
    = \begin{pmatrix} 0 & 1 \\ \end{pmatrix}\begin{pmatrix} 1 & 0 \\ 0 & {- 1} \\
    \end{pmatrix}\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = - 1.](img/file347.png "\left\langle
    0 \right|Z\left| 0 \right\rangle = \begin{pmatrix} 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    1 & 0 \\ 0 & {- 1} \\ \end{pmatrix}\begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} = 1,\qquad\left\langle
    1 \right|Z\left| 1 \right\rangle = \begin{pmatrix} 0 & 1 \\ \end{pmatrix}\begin{pmatrix}
    1 & 0 \\ 0 & {- 1} \\ \end{pmatrix}\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = -
    1.")'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![\left\langle 0 \right|Z\left| 0 \right\rangle = \begin{pmatrix} 1 & 0 \\
    \end{pmatrix}\begin{pmatrix} 1 & 0 \\ 0 & {- 1} \\ \end{pmatrix}\begin{pmatrix}
    1 \\ 0 \\ \end{pmatrix} = 1,\qquad\left\langle 1 \right|Z\left| 1 \right\rangle
    = \begin{pmatrix} 0 & 1 \\ \end{pmatrix}\begin{pmatrix} 1 & 0 \\ 0 & {- 1} \\
    \end{pmatrix}\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = - 1.](img/file347.png "\left\langle
    0 \right|Z\left| 0 \right\rangle = \begin{pmatrix} 1 & 0 \\ \end{pmatrix}\begin{pmatrix}
    1 & 0 \\ 0 & {- 1} \\ \end{pmatrix}\begin{pmatrix} 1 \\ 0 \\ \end{pmatrix} = 1,\qquad\left\langle
    1 \right|Z\left| 1 \right\rangle = \begin{pmatrix} 0 & 1 \\ \end{pmatrix}\begin{pmatrix}
    1 & 0 \\ 0 & {- 1} \\ \end{pmatrix}\begin{pmatrix} 0 \\ 1 \\ \end{pmatrix} = -
    1.")'
- en: Now, consider the tensor product ![Z \otimes Z \otimes I](img/file348.png "Z
    \otimes Z \otimes I") and basis state ![\left| {010} \right\rangle](img/file251.png
    "\left| {010} \right\rangle"). We know from *Section* * [*1.5.1*](ch008.xhtml#x1-360001.5.1)
    that*
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑张量积 ![Z \otimes Z \otimes I](img/file348.png "Z \otimes Z \otimes I") 和基态
    ![\left| {010} \right\rangle](img/file251.png "\left| {010} \right\rangle")。我们知道从
    *第 1.5.1 节* 中，*[*1.5.1*](ch008.xhtml#x1-360001.5.1)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*，*[*3.5*](#Figure3.5)*
- en: '*![\begin{array}{rlrl} {\left\langle {010} \right|Z \otimes Z \otimes I\left|
    {010} \right\rangle} & {= \left\langle {010} \right|\left( {Z\left| 0 \right\rangle
    \otimes Z\left| 1 \right\rangle \otimes I\left| 0 \right\rangle} \right)\qquad}
    & & \qquad \\ & {= \left\langle 0 \right|Z\left| 0 \right\rangle\left\langle 1
    \right|Z\left| 1 \right\rangle\left\langle 0 \right|I\left| 0 \right\rangle =
    1 \cdot ( - 1) \cdot 1 = - 1.\qquad} & & \qquad \\ \end{array}](img/file349.png
    "\begin{array}{rlrl} {\left\langle {010} \right|Z \otimes Z \otimes I\left| {010}
    \right\rangle} & {= \left\langle {010} \right|\left( {Z\left| 0 \right\rangle
    \otimes Z\left| 1 \right\rangle \otimes I\left| 0 \right\rangle} \right)\qquad}
    & & \qquad \\  & {= \left\langle 0 \right|Z\left| 0 \right\rangle\left\langle
    1 \right|Z\left| 1 \right\rangle\left\langle 0 \right|I\left| 0 \right\rangle
    = 1 \cdot ( - 1) \cdot 1 = - 1.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\begin{array}{rlrl} {\left\langle {010} \right|Z \otimes Z \otimes I\left|
    {010} \right\rangle} & {= \left\langle {010} \right|\left( {Z\left| 0 \right\rangle
    \otimes Z\left| 1 \right\rangle \otimes I\left| 0 \right\rangle} \right)\qquad}
    & & \qquad \\ & {= \left\langle 0 \right|Z\left| 0 \right\rangle\left\langle 1
    \right|Z\left| 1 \right\rangle\left\langle 0 \right|I\left| 0 \right\rangle =
    1 \cdot ( - 1) \cdot 1 = - 1.\qquad} & & \qquad \\ \end{array}](img/file349.png
    "\begin{array}{rlrl} {\left\langle {010} \right|Z \otimes Z \otimes I\left| {010}
    \right\rangle} & {= \left\langle {010} \right|\left( {Z\left| 0 \right\rangle
    \otimes Z\left| 1 \right\rangle \otimes I\left| 0 \right\rangle} \right)\qquad}
    & & \qquad \\  & {= \left\langle 0 \right|Z\left| 0 \right\rangle\left\langle
    1 \right|Z\left| 1 \right\rangle\left\langle 0 \right|I\left| 0 \right\rangle
    = 1 \cdot ( - 1) \cdot 1 = - 1.\qquad} & & \qquad \\ \end{array}")*'
- en: We interpret ![\left| {010} \right\rangle](img/file251.png "\left| {010} \right\rangle")
    as representing a cut in which vertices ![0](img/file12.png "0") and ![2](img/file302.png
    "2") are assigned to one set (because the value of qubits ![0](img/file12.png
    "0") and ![2](img/file302.png "2") in ![\left| {010} \right\rangle](img/file251.png
    "\left| {010} \right\rangle") is ![0](img/file12.png "0")) and vertex ![1](img/file13.png
    "1") is assigned to the other (because qubit ![1](img/file13.png "1") has value
    ![1](img/file13.png "1") in ![\left| {010} \right\rangle](img/file251.png "\left|
    {010} \right\rangle")). Then, the fact that the product ![\left\langle {010} \right|Z
    \otimes Z \otimes I\left| {010} \right\rangle](img/file350.png "\left\langle {010}
    \right|Z \otimes Z \otimes I\left| {010} \right\rangle") evaluates to ![- 1](img/file312.png
    "- 1") means that edge ![(0,1)](img/file305.png "(0,1)") has extremes in different
    sets of the cut; that is because we have used ![Z \otimes Z \otimes I](img/file348.png
    "Z \otimes Z \otimes I"), having ![Z](img/file8.png "Z") operators acting on qubits
    ![0](img/file12.png "0") and ![1](img/file13.png "1"). This behavior is analogous
    to the one that we had with term ![z_{0}z_{1}](img/file351.png "z_{0}z_{1}") in
    the function to minimize our classical formulation of the problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将![\left| {010} \right\rangle](img/file251.png "\left| {010} \right\rangle")解释为表示一个切割，其中顶点![0](img/file12.png
    "0")和![2](img/file302.png "2")被分配到一个集合中（因为![\left| {010} \right\rangle](img/file251.png
    "\left| {010} \right\rangle")中![0](img/file12.png "0")和![2](img/file302.png "2")的量子比特值为![0](img/file12.png
    "0"))，而顶点![1](img/file13.png "1")被分配到另一个集合（因为![1](img/file13.png "1")量子比特在![\left|
    {010} \right\rangle](img/file251.png "\left| {010} \right\rangle")中的值为![1](img/file13.png
    "1")）。然后，事实是乘积![\left\langle {010} \right|Z \otimes Z \otimes I\left| {010} \right\rangle](img/file350.png
    "\left\langle {010} \right|Z \otimes Z \otimes I\left| {010} \right\rangle")评估为![-
    1](img/file312.png "- 1")意味着切割的不同集合中存在极端；这是因为我们使用了![Z \otimes Z \otimes I](img/file348.png
    "Z \otimes Z \otimes I")，其中![Z](img/file8.png "Z")算子作用于量子比特![0](img/file12.png
    "0")和![1](img/file13.png "1")。这种行为类似于我们在最小化问题的经典公式函数中的![z_{0}z_{1}](img/file351.png
    "z_{0}z_{1}")项所具有的行为。
- en: In fact, ![Z \otimes Z \otimes I](img/file348.png "Z \otimes Z \otimes I") is
    usually denoted by just ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}") (the subindices
    indicate the positions of each ![Z](img/file8.png "Z") gate; the other positions
    are assumed to be the identity) and, following this convention, we would have,
    for instance,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，![Z \otimes Z \otimes I](img/file348.png "Z \otimes Z \otimes I")通常简写为![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}")（下标表示每个![Z](img/file8.png "Z")门的位置；其他位置假设为恒等变换），按照这个惯例，例如，我们会有：
- en: '![\left\langle {010} \right|Z_{0}Z_{2}\left| {010} \right\rangle = \left\langle
    0 \right|Z\left| 0 \right\rangle\left\langle 1 \right|I\left| 1 \right\rangle\left\langle
    0 \right|Z\left| 0 \right\rangle = 1 \cdot 1 \cdot 1 = 1](img/file353.png "\left\langle
    {010} \right|Z_{0}Z_{2}\left| {010} \right\rangle = \left\langle 0 \right|Z\left|
    0 \right\rangle\left\langle 1 \right|I\left| 1 \right\rangle\left\langle 0 \right|Z\left|
    0 \right\rangle = 1 \cdot 1 \cdot 1 = 1")'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![\\left\\langle {010} \\right\\vert Z_{0}Z_{2}\\left\\vert {010} \\right\\rangle
    = \\left\\langle 0 \\right\\vert Z\\left\\vert 0 \\right\\rangle\\left\\langle
    1 \\right\\vert I\\left\\vert 1 \\right\\rangle\\left\\langle 0 \\right\\vert
    Z\\left\\vert 0 \\right\\rangle = 1 \\cdot 1 \\cdot 1 = 1](img/file353.png "\\left\\langle
    {010} \\right\\vert Z_{0}Z_{2}\\left\\vert {010} \\right\\rangle = \\left\\langle
    0 \\right\\vert Z\\left\\vert 0 \\right\\rangle\\left\\langle 1 \\right\\vert
    I\\left\\vert 1 \\right\\rangle\\left\\langle 0 \\right\\vert Z\\left\\vert 0
    \\right\\rangle = 1 \\cdot 1 \\cdot 1 = 1")'
- en: because the edge ![(0,2)](img/file306.png "(0,2)") is not cut with this particular
    assignment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这个特定的分配下，边 ![\\left( {0,2} \\right)](img/file306.png "\\left( {0,2} \\right)")
    没有被切断。
- en: Of course, this is analogous for any basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") with ![x \in \{ 000,001,\ldots,111\}](img/file354.png
    "x \in \{ 000,001,\ldots,111\}"), so ![\left\langle x \right|Z_{j}Z_{k}\left|
    x \right\rangle](img/file355.png "\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle")
    will be ![- 1](img/file312.png "- 1") if the edge ![(j,k)](img/file356.png "(j,k)")
    is cut under an assignment ![x](img/file269.png "x") and it will be ![1](img/file13.png
    "1") otherwise. We only need to notice that if ![j](img/file258.png "j") and ![k](img/file317.png
    "k") are in different parts of the cut, then their qubits will have different
    values and the product will be ![- 1](img/file312.png "- 1").
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于任何基态 ![\\left| x \\right\\rangle](img/file267.png "\\left| x \\right\\rangle")，其中
    ![x \\in \\{ 000,001,\\ldots,111\\}](img/file354.png "x \\in \\{ 000,001,\\ldots,111\\}")，这也成立，所以如果边
    ![\\left( {j,k} \\right)](img/file356.png "\\left( {j,k} \\right)") 在分配 ![x](img/file269.png
    "x") 下被切断，那么 ![\\left\\langle x \\right\\vert Z_{j}Z_{k}\\left\\vert x \\right\\rangle](img/file355.png
    "\\left\\langle x \\right\\vert Z_{j}Z_{k}\\left\\vert x \\right\\rangle") 将是
    ![- 1](img/file312.png "- 1")，否则将是 ![1](img/file13.png "1")。我们只需要注意，如果 ![j](img/file258.png
    "j") 和 ![k](img/file317.png "k") 在切断的不同部分，那么它们的量子比特将具有不同的值，乘积将是 ![- 1](img/file312.png
    "- 1")。
- en: Furthermore, by linearity it holds that
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据线性性质，以下等式成立。
- en: '![\left\langle x \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x \right\rangle
    = \left\langle x \right|Z_{0}Z_{1}\left| x \right\rangle + \left\langle x \right|Z_{0}Z_{2}\left|
    x \right\rangle.](img/file357.png "\left\langle x \right|\left( {Z_{0}Z_{1} +
    Z_{0}Z_{2}} \right)\left| x \right\rangle = \left\langle x \right|Z_{0}Z_{1}\left|
    x \right\rangle + \left\langle x \right|Z_{0}Z_{2}\left| x \right\rangle.")'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![\\left\\langle x \\right\\vert \\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \\right)\\left\\vert
    x \\right\\rangle = \\left\\langle x \\right\\vert Z_{0}Z_{1}\\left\\vert x \\right\\rangle
    + \\left\\langle x \\right\\vert Z_{0}Z_{2}\\left\\vert x \\right\\rangle.](img/file357.png
    "\\left\\langle x \\right\\vert \\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \\right)\\left\\vert
    x \\right\\rangle = \\left\\langle x \\right\\vert Z_{0}Z_{1}\\left\\vert x \\right\\rangle
    + \\left\\langle x \\right\\vert Z_{0}Z_{2}\\left\\vert x \\right\\rangle.")'
- en: Thus, we can rewrite our problem as finding a basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") for which ![\left\langle x \right|\left( {Z_{0}Z_{1}
    + Z_{0}Z_{2}} \right)\left| x \right\rangle](img/file358.png "\left\langle x \right|\left(
    {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x \right\rangle") attains a minimum.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将问题重新表述为寻找一个基态 ![\\left| x \\right\\rangle](img/file267.png "\\left|
    x \\right\\rangle")，使得 ![\\left\\langle x \\right\\vert \\left( {Z_{0}Z_{1} +
    Z_{0}Z_{2}} \\right)\\left\\vert x \\right\\rangle](img/file358.png "\\left\\langle
    x \\right\\vert \\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \\right)\\left\\vert x \\right\\rangle")
    达到最小值。
- en: Exercise 3.3
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.3
- en: Compute ![\left\langle {010} \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left|
    {010} \right\rangle](img/file359.png "\left\langle {010} \right|\left( {Z_{0}Z_{1}
    + Z_{0}Z_{2}} \right)\left| {010} \right\rangle") and ![\left\langle {100} \right|\left(
    {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| {100} \right\rangle](img/file360.png "\left\langle
    {100} \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| {100} \right\rangle").
    Does any of those states minimize ![\left\langle x \right|\left( {Z_{0}Z_{1} +
    Z_{0}Z_{2}} \right)\left| x \right\rangle](img/file358.png "\left\langle x \right|\left(
    {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x \right\rangle")?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 计算以下表达式 ![\\left\\langle {010} \\right\\vert \\left( {Z_{0}Z_{1} + Z_{0}Z_{2}}
    \\right)\\left\\vert {010} \\right\\rangle](img/file359.png "\\left\\langle {010}
    \\right\\vert \\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \\right)\\left\\vert {010} \\right\\rangle")
    和 ![\\left\\langle {100} \\right\\vert \\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \\right)\\left\\vert
    {100} \\right\\rangle](img/file360.png "\\left\\langle {100} \\right\\vert \\left(
    {Z_{0}Z_{1} + Z_{0}Z_{2}} \\right)\\left\\vert {100} \\right\\rangle")。这些状态中是否有任何一个能最小化
    ![\\left\\langle x \\right\\vert \\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \\right)\\left\\vert
    x \\right\\rangle](img/file358.png "\\left\\langle x \\right\\vert \\left( {Z_{0}Z_{1}
    + Z_{0}Z_{2}} \\right)\\left\\vert x \\right\\rangle")？
- en: But that is not the end of the story. For any basis state ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle"), it holds that either ![Z_{j}Z_{k}\left| x \right\rangle
    = \left| x \right\rangle](img/file361.png "Z_{j}Z_{k}\left| x \right\rangle =
    \left| x \right\rangle") or ![Z_{j}Z_{k}\left| x \right\rangle = - \left| x \right\rangle](img/file362.png
    "Z_{j}Z_{k}\left| x \right\rangle = - \left| x \right\rangle"), as you can easily
    check. Notice that this proves that each ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") is an **eigenvector** of ![Z_{j}Z_{k}](img/file363.png
    "Z_{j}Z_{k}") with **eigenvalue** either ![1](img/file13.png "1") or ![- 1](img/file312.png
    "- 1") (refer to *Appendix* * [*B*](ch025.xhtml#x1-226000B), *Basic Linear Algebra*,
    for more information about eigenvectors and eigenvalues). Thus, for ![x \neq y](img/file364.png
    "x \neq y") we will have*
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是故事的结束。对于任何基态 ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle")，它要么满足
    ![Z_{j}Z_{k}\left| x \right\rangle = \left| x \right\rangle](img/file361.png "Z_{j}Z_{k}\left|
    x \right\rangle = \left| x \right\rangle")，要么满足 ![Z_{j}Z_{k}\left| x \right\rangle
    = - \left| x \right\rangle](img/file362.png "Z_{j}Z_{k}\left| x \right\rangle
    = - \left| x \right\rangle")，这很容易验证。请注意，这证明了每个 ![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle") 都是 ![Z_{j}Z_{k}](img/file363.png "Z_{j}Z_{k}") 的一个 **特征向量**，其
    **特征值** 要么是 ![1](img/file13.png "1")，要么是 ![- 1](img/file312.png "- 1")（有关特征向量和特征值的更多信息，请参阅
    *附录* * [*B*](ch025.xhtml#x1-226000B)，*基础线性代数*）。因此，对于 ![x \neq y](img/file364.png
    "x \neq y")，我们将有*
- en: '*![\left\langle y \right|Z_{j}Z_{k}\left| x \right\rangle = \pm \left\langle
    y \middle| x \right\rangle = 0,](img/file365.png "\left\langle y \right|Z_{j}Z_{k}\left|
    x \right\rangle = \pm \left\langle y \middle| x \right\rangle = 0,")'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\left\langle y \right|Z_{j}Z_{k}\left| x \right\rangle = \pm \left\langle
    y \middle| x \right\rangle = 0,](img/file365.png "\left\langle y \right|Z_{j}Z_{k}\left|
    x \right\rangle = \pm \left\langle y \middle| x \right\rangle = 0,")'
- en: because ![\left\langle y \middle| x \right\rangle = 0](img/file366.png "\left\langle
    y \middle| x \right\rangle = 0") whenever ![x \neq y](img/file364.png "x \neq
    y"), as we proved in *Section* * [*1.5.1*](ch008.xhtml#x1-360001.5.1).*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ![\left\langle y \middle| x \right\rangle = 0](img/file366.png "\left\langle
    y \middle| x \right\rangle = 0") 当 ![x \neq y](img/file364.png "x \neq y") 时，正如我们在
    *第* * [*1.5.1*](ch008.xhtml#x1-360001.5.1) * *节* * 中所证明的。
- en: '*Consequently, since a general state ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle") can always be written as ![\left| \psi \right\rangle
    = {\sum}_{x}a_{x}\left| x \right\rangle](img/file367.png "\left| \psi \right\rangle
    = {\sum}_{x}a_{x}\left| x \right\rangle"), it follows by linearity that'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*因此，由于一个一般状态 ![\left| \psi \right\rangle](img/file43.png "\left| \psi \right\rangle")
    总可以写成 ![\left| \psi \right\rangle = {\sum}_{x}a_{x}\left| x \right\rangle](img/file367.png
    "\left| \psi \right\rangle = {\sum}_{x}a_{x}\left| x \right\rangle")，根据线性原理，可以得出以下结论'
- en: '![\begin{array}{rlrl} {\left\langle \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle}
    & {= \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle y \right|} \right)Z_{j}Z_{k}\left(
    {\sum\limits_{x}a_{x}\left| x \right\rangle} \right) = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle
    y \right|Z_{j}Z_{k}\left| x \right\rangle\qquad} & & \qquad \\ & {= \sum\limits_{x}\left|
    a_{x} \right|^{2}\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle,\qquad}
    & & \qquad \\ \end{array}](img/file368.png "\begin{array}{rlrl} {\left\langle
    \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle} & {= \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle
    y \right|} \right)Z_{j}Z_{k}\left( {\sum\limits_{x}a_{x}\left| x \right\rangle}
    \right) = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle y \right|Z_{j}Z_{k}\left|
    x \right\rangle\qquad} & & \qquad \\  & {= \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle
    x \right|Z_{j}Z_{k}\left| x \right\rangle,\qquad} & & \qquad \\ \end{array}")'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\left\langle \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle}
    & {= \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle y \right|} \right)Z_{j}Z_{k}\left(
    {\sum\limits_{x}a_{x}\left| x \right\rangle} \right) = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle
    y \right|Z_{j}Z_{k}\left| x \right\rangle\qquad} & & \qquad \\ & {= \sum\limits_{x}\left|
    a_{x} \right|^{2}\left\langle x \right|Z_{j}Z_{k}\left| x \right\rangle,\qquad}
    & & \qquad \\ \end{array}](img/file368.png "\begin{array}{rlrl} {\left\langle
    \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle} & {= \left( {\sum\limits_{y}a_{y}^{\ast}\left\langle
    y \right|} \right)Z_{j}Z_{k}\left( {\sum\limits_{x}a_{x}\left| x \right\rangle}
    \right) = \sum\limits_{y}\sum\limits_{x}a_{y}^{\ast}a_{x}\left\langle y \right|Z_{j}Z_{k}\left|
    x \right\rangle\qquad} & & \qquad \\  & {= \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle
    x \right|Z_{j}Z_{k}\left| x \right\rangle,\qquad} & & \qquad \\ \end{array}")'
- en: where we have used ![a_{x}^{\ast}a_{x} = \left| a_{x} \right|^{2}](img/file369.png
    "a_{x}^{\ast}a_{x} = \left| a_{x} \right|^{2}").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 ![a_{x}^{\ast}a_{x} = \left| a_{x} \right|^{2}](img/file369.png "a_{x}^{\ast}a_{x}
    = \left| a_{x} \right|^{2}").
- en: Hence, again by linearity, it is true that
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次根据线性原理，以下结论成立
- en: '![\begin{array}{rlrl} {\left\langle \psi \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}}
    \right)\left| \psi \right\rangle} & {= \left\langle \psi \right|Z_{0}Z_{1}\left|
    \psi \right\rangle + \left\langle \psi \right|Z_{0}Z_{2}\left| \psi \right\rangle\qquad}
    & & \qquad \\ & {= \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle x \right|Z_{0}Z_{1}\left|
    x \right\rangle + \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle x \right|Z_{0}Z_{2}\left|
    x \right\rangle\qquad} & & \qquad \\ & {= \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle
    x \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x \right\rangle.\qquad}
    & & \qquad \\ \end{array}](img/file370.png "\begin{array}{rlrl} {\left\langle
    \psi \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| \psi \right\rangle}
    & {= \left\langle \psi \right|Z_{0}Z_{1}\left| \psi \right\rangle + \left\langle
    \psi \right|Z_{0}Z_{2}\left| \psi \right\rangle\qquad} & & \qquad \\  & {= \sum\limits_{x}\left|
    a_{x} \right|^{2}\left\langle x \right|Z_{0}Z_{1}\left| x \right\rangle + \sum\limits_{x}\left|
    a_{x} \right|^{2}\left\langle x \right|Z_{0}Z_{2}\left| x \right\rangle\qquad}
    & & \qquad \\  & {= \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle x \right|\left(
    {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x \right\rangle.\qquad} & & \qquad \\
    \end{array}")'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![公式](img/file370.png "公式")'
- en: We know that ![{\sum}_{x}\left| a_{x} \right|^{2} = 1](img/file371.png "{\sum}_{x}\left|
    a_{x} \right|^{2} = 1") and that every ![\left| a_{x} \right|^{2}](img/file372.png
    "\left| a_{x} \right|^{2}") is non-negative, so it holds that
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 \([\sum]_{x}\left| a_{x} \right|^{2} = 1\)(![公式](img/file371.png "公式"))，并且每个
    \(\left| a_{x} \right|^{2}\)(![公式](img/file372.png "公式")) 都是非负的，因此成立。
- en: '![\begin{array}{rlrl} {\sum\limits_{x}\left| a_{x} \right|^{2}\left\langle
    x \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x \right\rangle} & {\geq
    \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle x_{\min} \right|\left( {Z_{0}Z_{1}
    + Z_{0}Z_{2}} \right)\left| x_{\min} \right\rangle\qquad} & & \qquad \\ & {= \left\langle
    x_{\min} \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x_{\min} \right\rangle\sum\limits_{x}\left|
    a_{x} \right|^{2}\qquad} & & \qquad \\ & {= \left\langle x_{\min} \right|\left(
    {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x_{\min} \right\rangle,\qquad} & & \qquad
    \\ \end{array}](img/file373.png "\begin{array}{rlrl} {\sum\limits_{x}\left| a_{x}
    \right|^{2}\left\langle x \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left|
    x \right\rangle} & {\geq \sum\limits_{x}\left| a_{x} \right|^{2}\left\langle x_{\min}
    \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x_{\min} \right\rangle\qquad}
    & & \qquad \\  & {= \left\langle x_{\min} \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}}
    \right)\left| x_{\min} \right\rangle\sum\limits_{x}\left| a_{x} \right|^{2}\qquad}
    & & \qquad \\  & {= \left\langle x_{\min} \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}}
    \right)\left| x_{\min} \right\rangle,\qquad} & & \qquad \\ \end{array}")'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![公式](img/file373.png "公式")'
- en: where ![\left| x_{\min} \right\rangle](img/file374.png "\left| x_{\min} \right\rangle")
    is a basis state (there could be more than one) for which ![\left\langle x \right|\left(
    {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x \right\rangle](img/file358.png "\left\langle
    x \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| x \right\rangle") is minimum
    and, hence, ![x_{\min}](img/file375.png "x_{\min}") represents a maximum cut.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![\left| x_{\min} \right\rangle](img/file374.png "\left| x_{\min} \right\rangle")
    是一个基态（可能不止一个），对于这个基态，![\left\langle x \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}}
    \right)\left| x \right\rangle](img/file358.png "\left\langle x \right|\left( {Z_{0}Z_{1}
    + Z_{0}Z_{2}} \right)\left| x \right\rangle") 取得最小值，因此，![x_{\min}](img/file375.png
    "x_{\min}") 代表了一个最大割。
- en: This may all seem a little bit too abstract. But what we have proved is simply
    that the minimum over all possible quantum states is always reached on one of
    the basis states — which are the only ones that we can directly interpret as representing
    cuts. Then, we can rewrite the problem of finding a maximum cut for the graph
    of *Figure* *[*3.5*](#Figure3.5) as follows:*
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点抽象。但我们证明的是，所有可能量子状态的最小值总是在基态之一上达到——这些基态是我们唯一可以直接解释为表示割的态。然后，我们可以将寻找图
    *图* *[*3.5*](#Figure3.5) 的最大割的问题重新表述如下：
- en: '*![\begin{array}{rlrl} & {\text{Minimize~}\quad\left\langle \psi \right|\left(
    {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| \psi \right\rangle = \left\langle \psi
    \right|Z_{0}Z_{1}\left| \psi \right\rangle + \left\langle \psi \right|Z_{0}Z_{2}\left|
    \psi \right\rangle,\qquad} & & \qquad \\ & {{\text{where~}\left| \psi \right\rangle\text{~is~taken~from~the~set~of~quantum~states~on~}3\text{~qubits.}}\qquad}
    & & \qquad \\ \end{array}](img/file376.png "\begin{array}{rlrl}  & {\text{Minimize~}\quad\left\langle
    \psi \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| \psi \right\rangle
    = \left\langle \psi \right|Z_{0}Z_{1}\left| \psi \right\rangle + \left\langle
    \psi \right|Z_{0}Z_{2}\left| \psi \right\rangle,\qquad} & & \qquad \\  & {{\text{where~}\left|
    \psi \right\rangle\text{~is~taken~from~the~set~of~quantum~states~on~}3\text{~qubits.}}\qquad}
    & & \qquad \\ \end{array}")'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\begin{array}{rlrl} & {\text{最小化~}\quad\left\langle \psi \right|\left( {Z_{0}Z_{1}
    + Z_{0}Z_{2}} \right)\left| \psi \right\rangle = \left\langle \psi \right|Z_{0}Z_{1}\left|
    \psi \right\rangle + \left\langle \psi \right|Z_{0}Z_{2}\left| \psi \right\rangle,\qquad}
    & & \qquad \\ & {{\text{其中~}\left| \psi \right\rangle\text{~取自3个量子比特上的量子态集合。}}\qquad}
    & & \qquad \\ \end{array}](img/file376.png "\begin{array}{rlrl}  & {\text{最小化~}\quad\left\langle
    \psi \right|\left( {Z_{0}Z_{1} + Z_{0}Z_{2}} \right)\left| \psi \right\rangle
    = \left\langle \psi \right|Z_{0}Z_{1}\left| \psi \right\rangle + \left\langle
    \psi \right|Z_{0}Z_{2}\left| \psi \right\rangle,\qquad} & & \qquad \\  & {{\text{其中~}\left|
    \psi \right\rangle\text{~取自3个量子比特上的量子态集合。}}\qquad} & & \qquad \\ \end{array}")'
- en: Notice the change that we have introduced. In our previous formulation, we were
    only minimizing over basis states, but now that we know that the minimum over
    all possible states is reached on a basis state, we are minimizing over all possible
    quantum states. This will make our life easier in future chapters when we introduce
    quantum algorithms to solve this kind of problem, because we will be justified
    in using any quantum state instead of just constraining ourselves to those that
    come from the basis.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们引入的变化。在我们之前的公式中，我们只是在基态上最小化，但现在我们知道所有可能状态的最小值是在基态上达到的，所以我们现在是在所有可能量子状态上最小化。这将在未来章节中介绍量子算法来解决这类问题时使我们的生活变得更简单，因为我们有理由使用任何量子状态，而不仅仅局限于那些来自基态的状态。
- en: Important note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although the minimum energy is always achieved on one basis state, it could
    also be the case that it is also achieved on a non-basis state. In fact, if two
    different basis states ![\left| x \right\rangle](img/file267.png "\left| x \right\rangle")
    and ![\left| y \right\rangle](img/file268.png "\left| y \right\rangle") achieve
    the minimum energy, then any superposition ![a\left| x \right\rangle + b\left|
    y \right\rangle](img/file377.png "a\left| x \right\rangle + b\left| y \right\rangle")
    is of minimum energy as well. That is the case, for example, for ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}") for which both ![\left| {01} \right\rangle](img/file199.png "\left|
    {01} \right\rangle") and ![\left| {10} \right\rangle](img/file200.png "\left|
    {10} \right\rangle") have energy ![- 1](img/file312.png "- 1"). Then, any superposition
    ![a\left| {01} \right\rangle + b\left| {10} \right\rangle](img/file378.png "a\left|
    {01} \right\rangle + b\left| {10} \right\rangle") also achieves energy ![- 1](img/file312.png
    "- 1"), which is the minimum possible for ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}").
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最小能量总是在一个基态上实现，但它也可能在非基态上实现。事实上，如果两个不同的基态![\left| x \right\rangle](img/file267.png
    "\left| x \right\rangle")和![\left| y \right\rangle](img/file268.png "\left| y
    \right\rangle")实现了最小能量，那么任何叠加![a\left| x \right\rangle + b\left| y \right\rangle](img/file377.png
    "a\left| x \right\rangle + b\left| y \right\rangle")也是最小能量的。例如，对于![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}")，其两个基态![\left| {01} \right\rangle](img/file199.png "\left| {01} \right\rangle")和![\left|
    {10} \right\rangle](img/file200.png "\left| {10} \right\rangle")的能量都是![- 1](img/file312.png
    "- 1")。那么，任何叠加![a\left| {01} \right\rangle + b\left| {10} \right\rangle](img/file378.png
    "a\left| {01} \right\rangle + b\left| {10} \right\rangle")也实现了能量![- 1](img/file312.png
    "- 1")，这是![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}")可能的最小能量。
- en: 'It can be easily checked that our preceding argument holds for any number of
    qubits and any sum of tensor products ![Z_{j}Z_{k}](img/file363.png "Z_{j}Z_{k}"),
    so if we have a graph with set of vertices ![V](img/file379.png "V"), of size
    ![n](img/file244.png "n"), and set of edges ![E](img/file327.png "E"), we can
    rewrite the Max-Cut problem for the graph as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以很容易地验证，我们前面的论点适用于任何数量的量子比特和任何张量积之和![Z_{j}Z_{k}](img/file363.png "Z_{j}Z_{k}"),
    因此，如果我们有一个顶点集合![V](img/file379.png "V")的图，大小为![n](img/file244.png "n")，边集合为![E](img/file327.png
    "E")，我们可以将图的Max-Cut问题重写如下：
- en: '![\begin{array}{rlrl} & {\text{Minimize~}\quad\sum\limits_{(j,k) \in E}\left\langle
    \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle,\qquad} & & \qquad \\ & {{\text{where~}\left|
    \psi \right\rangle\text{~is~taken~from~the~set~of~quantum~states~on~}n\text{~qubits.}}\qquad}
    & & \qquad \\ \end{array}](img/file380.png "\begin{array}{rlrl}  & {\text{Minimize~}\quad\sum\limits_{(j,k)
    \in E}\left\langle \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle,\qquad} & &
    \qquad \\  & {{\text{where~}\left| \psi \right\rangle\text{~is~taken~from~the~set~of~quantum~states~on~}n\text{~qubits.}}\qquad}
    & & \qquad \\ \end{array}")'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![最小化~\quad\sum\limits_{(j,k) \in E}\left\langle \psi \right|Z_{j}Z_{k}\left|
    \psi \right\rangle,\qquad](img/file380.png "\begin{array}{rlrl}  & {\text{最小化~}\quad\sum\limits_{(j,k)
    \in E}\left\langle \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle,\qquad} & &
    \qquad \\  & {{\text{其中~}\left| \psi \right\rangle\text{~取自~n~个量子态的集合。}}\qquad}
    & & \qquad \\ \end{array}")'
- en: Important note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Let’s take a step back and examine what we have proved. First, notice that matrices
    such as
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看我们已经证明了什么。首先，注意像
- en: '![\sum\limits_{(j,k) \in E}Z_{j}Z_{k}](img/file381.png "\sum\limits_{(j,k)
    \in E}Z_{j}Z_{k}")'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![\sum\limits_{(j,k) \in E}Z_{j}Z_{k}](img/file381.png "\sum\limits_{(j,k)
    \in E}Z_{j}Z_{k}")'
- en: are **Hermitian** or **self-adjoint**. This means that they are equal to their
    conjugate transposes, as you can easily verify, and they have particular properties
    such as having real eigenvalues and being able to form an orthonormal basis with
    their eigenvectors (refer to *Appendix* *[*B*](ch025.xhtml#x1-226000B), *Basic
    Linear Algebra*, for more details). In our case, we have proved that the computational
    basis *is* such an orthonormal basis of eigenvectors. Furthermore, the quantity*
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是**厄米**或**自伴**的。这意味着它们等于它们的共轭转置，这很容易验证，并且它们具有特定的性质，例如具有实特征值并且能够与它们的特征向量形成正交归一基（更多详情请参阅*附录*
    *[*B*](ch025.xhtml#x1-226000B)，*基础线性代数*）。在我们的情况下，我们已经证明了计算基*是*这样的正交归一基的特征向量。此外，数量
- en: '*![\left\langle \psi \right|\left( {\sum\limits_{(j,k) \in E}Z_{j}Z_{k}} \right)\left|
    \psi \right\rangle = \sum\limits_{(j,k) \in E}\left\langle \psi \right|Z_{j}Z_{k}\left|
    \psi \right\rangle,](img/file382.png "\left\langle \psi \right|\left( {\sum\limits_{(j,k)
    \in E}Z_{j}Z_{k}} \right)\left| \psi \right\rangle = \sum\limits_{(j,k) \in E}\left\langle
    \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle,")'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*![\left\langle \psi \right|\left( {\sum\limits_{(j,k) \in E}Z_{j}Z_{k}} \right)\left|
    \psi \right\rangle = \sum\limits_{(j,k) \in E}\left\langle \psi \right|Z_{j}Z_{k}\left|
    \psi \right\rangle,](img/file382.png "\left\langle \psi \right|\left( {\sum\limits_{(j,k)
    \in E}Z_{j}Z_{k}} \right)\left| \psi \right\rangle = \sum\limits_{(j,k) \in E}\left\langle
    \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle,")'
- en: which is usually called the **expectation value** of ![{\sum}_{(j,k) \in E}Z_{j}Z_{k}](img/file383.png
    "{\sum}_{(j,k) \in E}Z_{j}Z_{k}"), attains its minimum value on one of those eigenvectors,
    called the **ground state**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被称为![{\sum}_{(j,k) \in E}Z_{j}Z_{k}](img/file383.png "{\sum}_{(j,k) \in E}Z_{j}Z_{k}")的**期望值**，在那些称为**基态**的特征向量之一上达到其最小值。
- en: 'This result is known as the **variational principle**, and we will revisit
    it in a more general form in *Chapter* *[*7*](ch015.xhtml#x1-1190007), *VQE: Variational*
    *Quantum Eigensolver*.**  **For the Ising model, the situation is exactly the
    same. We can go through an analogous reasoning, only this time also involving
    terms of the form ![Z_{j}](img/file384.png "Z_{j}"). Each ![Z_{j}](img/file384.png
    "Z_{j}") is a tensor product with all the factors equal to the identity matrix
    except for the one in the ![j](img/file258.png "j")-th position, which is ![Z](img/file8.png
    "Z"). Then, finding the state of minimum energy of an Ising model with ![n](img/file244.png
    "n") particles and coefficients ![J_{jk}](img/file342.png "J_{jk}") and ![h_{j}](img/file343.png
    "h_{j}") is equivalent to the following problem:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果被称为**变分原理**，我们将在*第7章*[*7*](ch015.xhtml#x1-1190007)，*变分量子本征值求解器*中更一般的形式中重新讨论。**对于伊辛模型，情况完全相同。我们可以进行类似的推理，这次还涉及到形式为![Z_{j}](img/file384.png
    "Z_{j}")的项。每个![Z_{j}](img/file384.png "Z_{j}")都是一个张量积，除了![j](img/file258.png "j")-th位置上的因子等于单位矩阵外，其他所有因子都等于单位矩阵，该位置上的因子是![Z](img/file8.png
    "Z")。然后，找到具有![n](img/file244.png "n")个粒子和系数![J_{jk}](img/file342.png "J_{jk}")和![h_{j}](img/file343.png
    "h_{j}")的伊辛模型的最小能量状态，相当于以下问题：
- en: '![\begin{array}{rlrl} & {\text{Minimize~}\qquad - \sum\limits_{(j,k) \in E}J_{jk}\left\langle
    \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle - \sum\limits_{j}h_{j}\left\langle
    \psi \right|Z_{j}\left| \psi \right\rangle,\qquad} & & \qquad \\ & {{\text{where~}\left|
    \psi \right\rangle\text{~is~taken~from~the~set~of~quantum~states~on~}n\text{~qubits.}}\qquad}
    & & \qquad \\ \end{array}](img/file385.png "\begin{array}{rlrl}  & {\text{Minimize~}\qquad
    - \sum\limits_{(j,k) \in E}J_{jk}\left\langle \psi \right|Z_{j}Z_{k}\left| \psi
    \right\rangle - \sum\limits_{j}h_{j}\left\langle \psi \right|Z_{j}\left| \psi
    \right\rangle,\qquad} & & \qquad \\  & {{\text{where~}\left| \psi \right\rangle\text{~is~taken~from~the~set~of~quantum~states~on~}n\text{~qubits.}}\qquad}
    & & \qquad \\ \end{array}")'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} & {\text{Minimize~}\qquad - \sum\limits_{(j,k) \in E}J_{jk}\left\langle
    \psi \right|Z_{j}Z_{k}\left| \psi \right\rangle - \sum\limits_{j}h_{j}\left\langle
    \psi \right|Z_{j}\left| \psi \right\rangle,\qquad} & & \qquad \\ & {{\text{where~}\left|
    \psi \right\rangle\text{~is~taken~from~the~set~of~quantum~states~on~}n\text{~qubits.}}\qquad}
    & & \qquad \\ \end{array}](img/file385.png "\begin{array}{rlrl}  & {\text{Minimize~}\qquad
    - \sum\limits_{(j,k) \in E}J_{jk}\left\langle \psi \right|Z_{j}Z_{k}\left| \psi
    \right\rangle - \sum\limits_{j}h_{j}\left\langle \psi \right|Z_{j}\left| \psi
    \right\rangle,\qquad} & & \qquad \\  & {{\text{where~}\left| \psi \right\rangle\text{~is~taken~from~the~set~of~quantum~states~on~}n\text{~qubits.}}\qquad}
    & & \qquad \\ \end{array}")'
- en: So, we have been able to cast several combinatorial optimization problems into
    a *quantum form*. More concretely, we have rewritten our problems as instances
    of finding the ground state of a self-adjoint matrix called the **Hamiltonian**
    of the system. Notice, however, that we do not really need to obtain the exact
    ground state. If we can prepare a state ![\left| \psi \right\rangle](img/file43.png
    "\left| \psi \right\rangle") such that the amplitude ![a_{x_{\min}} = \left\langle
    x_{\min} \middle| \psi \right\rangle](img/file386.png "a_{x_{\min}} = \left\langle
    x_{\min} \middle| \psi \right\rangle") is big in absolute value, then we will
    have a high probability of finding ![x_{\min}](img/file375.png "x_{\min}") when
    we measure ![\left| \psi \right\rangle](img/file43.png "\left| \psi \right\rangle").
    This approach will be behind the algorithms that we will introduce in *Chapters*
    * [*4*](ch012.xhtml#x1-750004) through * [*7*](ch015.xhtml#x1-1190007).**
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经能够将几个组合优化问题转化为*量子形式*。更具体地说，我们将我们的问题重写为寻找一个称为系统**哈密顿量**的自伴矩阵的基态的实例。然而，请注意，我们实际上并不需要获得确切的基态。如果我们能够准备一个状态![\left|
    \psi \right\rangle](img/file43.png "\left| \psi \right\rangle")，使得振幅![a_{x_{\min}}
    = \left\langle x_{\min} \middle| \psi \right\rangle](img/file386.png "a_{x_{\min}}
    = \left\langle x_{\min} \middle| \psi \right\rangle")的绝对值很大，那么当我们测量![\left| \psi
    \right\rangle](img/file43.png "\left| \psi \right\rangle")时，找到![x_{\min}](img/file375.png
    "x_{\min}")的概率就会很高。这种方法将是我们将在*第4章*到*第7章*中介绍的计算方法背后的原理。
- en: '**In the following sections, we will see that the possibility of rewriting
    combinatorial optimization problems as instances of ground state problems is not
    just a happy coincidence, but rather the norm, and we will show how to write many
    other important problems in this form. But, before we turn to that, let us write
    some code to work with those tensor products of ![Z](img/file8.png "Z") matrices
    and to compute their expectation values.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几节中，我们将看到将组合优化问题重写为基态问题实例的可能性不仅是一个愉快的巧合，而是一种常态，我们将展示如何以这种形式写出许多其他重要的问题。但在我们转向这一点之前，让我们编写一些代码来处理那些![Z](img/file8.png
    "Z")矩阵的张量积，并计算它们的期望值。
- en: 3.2.2 Computing expectation values with Qiskit
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2.2 使用Qiskit计算期望值
- en: 'In *Chapter* *[*2*](ch009.xhtml#x1-400002), *The Tools of the Trade in Quantum
    Computing*, we introduced the main ways in which Qiskit can be used to work with
    quantum circuits and to execute them on simulators and real quantum computers.
    But Qiskit also allows us to work with quantum states and Hamiltonians, combining
    them with tensor products and computing their expectation values, something that
    can be useful when dealing with optimization problems, as we have just seen. Learning
    how to perform these computations will help make the concepts that we have introduced
    more concrete. Moreover, in *Chapter* *[*5*](ch013.xhtml#x1-940005), *QAOA: Quantum*
    *Approximate Optimization Algorithm*, we will be working extensively with Hamiltonians
    in Qiskit, so we will need to know how to initialize and manipulate them.**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*[*2*](ch009.xhtml#x1-400002)，*量子计算中的工具*中，我们介绍了Qiskit可以用来处理量子电路并在模拟器和真实量子计算机上执行它们的主要方式。但Qiskit还允许我们处理量子状态和哈密顿量，将它们与张量积结合并计算它们的期望值，这在处理优化问题时可能很有用，正如我们刚才看到的。学习如何执行这些计算将有助于使我们所介绍的概念更加具体。此外，在*第5章*[*5*](ch013.xhtml#x1-940005)，*QAOA：量子近似优化算法*中，我们将大量使用Qiskit中的哈密顿量，因此我们需要了解如何初始化和操作它们。**
- en: '**Let’s start by showing, for example, how to define in Qiskit a basis state
    of three qubits such as ![\left| {100} \right\rangle](img/file387.png "\left|
    {100} \right\rangle"). We can do this in several different ways. For instance,
    we can first define one-qubit states ![\left| 0 \right\rangle](img/file6.png "\left|
    0 \right\rangle") and ![\left| 1 \right\rangle](img/file14.png "\left| 1 \right\rangle")
    and compute their tensor products. There are several possible approaches to achieve
    this. The first one is to directly use the amplitudes to initialize a `Statevector`
    object. To do that, we need to import the class and then call its constructor
    with input `[1,0]` (the amplitudes of ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle")) as shown in the following fragment of code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**让我们先通过一个例子来展示如何在Qiskit中定义一个三比特基态，例如![\left| {100} \right\rangle](img/file387.png
    "\left| {100} \right\rangle")。我们可以用几种不同的方法来完成这个任务。例如，我们首先定义一个单比特态![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle")和![\left| 1 \right\rangle](img/file14.png "\left| 1 \right\rangle")，然后计算它们的张量积。实现这一目标有几种可能的方法。第一种方法是直接使用振幅来初始化一个`Statevector`对象。为此，我们需要导入该类，然后使用输入`[1,0]`（![\left|
    0 \right\rangle](img/file6.png "\left| 0 \right\rangle")的振幅）调用其构造函数，如下面的代码片段所示：'
- en: '[PRE0]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The output that you will get if you run this code is
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，您将得到以下输出：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: which shows that, indeed, we have created a quantum state and set it to ![\left|
    0 \right\rangle](img/file6.png "\left| 0 \right\rangle"). Of course, to initialize
    a quantum state to ![\left| 1 \right\rangle](img/file14.png "\left| 1 \right\rangle"),
    we can run
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，我们确实创建了一个量子态并将其设置为![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle")。当然，要将量子态初始化为![\left|
    1 \right\rangle](img/file14.png "\left| 1 \right\rangle")，我们可以执行以下操作：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'obtaining this output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 获得以下输出：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An alternative, probably more convenient way of achieving the same result is
    to initialize the `Statevector` object from an integer such as `0` or `1`. We
    will use the `from_int` method and it is important to also use the `dims` parameter
    to indicate the size of the statevector. Otherwise, `0` could be interpreted to
    be ![\left| 0 \right\rangle](img/file6.png "\left| 0 \right\rangle") or ![\left|
    {00} \right\rangle](img/file198.png "\left| {00} \right\rangle") or ![\left| {000}
    \right\rangle](img/file388.png "\left| {000} \right\rangle") or... (as we mentioned
    in *Section* * [*1.4.1*](ch008.xhtml#x1-280001.4.1)). In our case, we set `dims`
    `=` `2`, but in general, we will have to set `dims` to ![2^{n}](img/file256.png
    "2^{n}"), where ![n](img/file244.png "n") is the number of qubits, because that
    is the number of amplitudes on an ![n](img/file244.png "n")-qubit system. Then,
    we can run*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的另一种可能更方便的方法是从整数（如`0`或`1`）初始化`Statevector`对象。我们将使用`from_int`方法，并且也很重要地使用`dims`参数来指示状态向量的大小。否则，`0`可能被解释为![\left|
    0 \right\rangle](img/file6.png "\left| 0 \right\rangle")、![\left| {00} \right\rangle](img/file198.png
    "\left| {00} \right\rangle")、![\left| {000} \right\rangle](img/file388.png "\left|
    {000} \right\rangle")或...（如我们在*第* *[*1.4.1*](ch008.xhtml#x1-280001.4.1)中提到的）。在我们的例子中，我们将`dims`设置为`2`，但通常，我们必须将`dims`设置为![2^{n}](img/file256.png
    "2^{n}")，其中![n](img/file244.png "n")是比特数，因为这是一个![n](img/file244.png "n")比特系统的振幅数量。然后，我们可以运行*
- en: '*[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE4]'
- en: 'which results in the following output, as expected:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下预期的输出：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In either case, we can now construct states with a higher number of qubits
    by computing tensor products with the `tensor` method, as shown in the following
    lines:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们现在都可以通过使用`tensor`方法计算张量积来构建更高比特数的态，如下面的几行所示：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After running them, we will get the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它们后，我们将得到以下输出：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the amplitude whose value is ![1](img/file13.png "1") is in the
    fifth position. It corresponds to ![\left| {100} \right\rangle](img/file387.png
    "\left| {100} \right\rangle"), because, in binary, ![100](img/file389.png "100")
    is ![4](img/file143.png "4") and we start counting on ![0](img/file12.png "0").
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值为![1](img/file13.png "1")的振幅位于第五位。它对应于![\left| {100} \right\rangle](img/file387.png
    "\left| {100} \right\rangle")，因为在二进制中![100](img/file389.png "100")等于![4](img/file143.png
    "4")，我们是从![0](img/file12.png "0")开始计数的。
- en: 'As you can imagine, both the way in which we compute the tensor product and
    the representation as an amplitude vector can become difficult to parse when we
    are working with many qubits. The following lines show a more concise way of using
    tensor products and a much more beautiful way of presenting states, but they achieve
    exactly the same result as the code shown previously:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，当我们处理许多量子比特时，我们计算张量积的方式以及作为振幅向量的表示都可能变得难以解析。以下行展示了使用张量积的更简洁方式以及展示状态的一个更美观的方式，但它们与之前显示的代码达到完全相同的结果：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the output will be just ![\left| 100\rangle \right.](img/file390.png
    "\left| 100\rangle \right."). More readable, right?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出将仅仅是 ![\left| 100\rangle \right.](img/file390.png "\left| 100\rangle
    \right.")。更易于阅读，对吧？
- en: A faster way of constructing the ![\left| 100\rangle \right.](img/file390.png
    "\left| 100\rangle \right.") state is using, again, the `from_int` method, as
    in
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 构建状态 ![\left| 100\rangle \right.](img/file390.png "\left| 100\rangle \right.")
    的一个更快的方法是再次使用 `from_int` 方法，如下所示
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: where we specify that we are working with three qubits by setting `dims` `=`
    `8` (because we need 8 amplitudes to define a three-qubit state).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们指定我们正在使用三个量子比特，通过设置 `dims` `=` `8`（因为我们需要8个振幅来定义一个三量子比特状态）。
- en: So, we now know a bunch of ways of creating basis states. What about states
    that are in superposition? Well, it couldn’t be easier, because, in Qiskit, you
    can simply multiply basis states by amplitudes and then add them together. For
    instance, the instructions
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道了创建基态的多种方法。那么，关于处于叠加态的状态呢？嗯，这很简单，因为在 Qiskit 中，你可以简单地通过振幅乘以基态并将它们相加来创建叠加态。例如，以下指令
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: create the state ![\left. 1\slash\sqrt{2}\left| {000} \right\rangle + 1\slash\sqrt{2}\left|
    {111} \right\rangle \right.](img/file391.png "\left. 1\slash\sqrt{2}\left| {000}
    \right\rangle + 1\slash\sqrt{2}\left| {111} \right\rangle \right.").
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建状态 ![\left. 1\slash\sqrt{2}\left| {000} \right\rangle + 1\slash\sqrt{2}\left|
    {111} \right\rangle \right.](img/file391.png "\left. 1\slash\sqrt{2}\left| {000}
    \right\rangle + 1\slash\sqrt{2}\left| {111} \right\rangle \right.").
- en: Important note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It may seem that we have included some unnecessary parenthesis in the previous
    code. However, if you remove them, you will not get the expected result. Qiskit
    overloads the `^` operator to be used as the tensor product operation. But, in
    Python, `^` has a lower precedence than `+`, so we need the parenthesis for the
    operations to be performed in the desired order.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我们在之前的代码中包含了一些不必要的括号。然而，如果你去掉它们，你将不会得到预期的结果。Qiskit 将 `^` 运算符重载为张量积运算。但在
    Python 中，`^` 的优先级低于 `+`，因此我们需要括号来确保按照期望的顺序执行操作。
- en: To learn more…
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: An additional, indirect way of setting the values of a quantum state is creating
    a quantum circuit that prepares the state and running it to obtain the state vector
    with `get_stavector` as we learned to do in *Chapter* *[*2*](ch009.xhtml#x1-400002),
    *The Tools of the Trade in Quantum Computing*; or you can even just pass the quantum
    circuit to the `Statevector` constructor. For instance, to create basis states,
    you would only need a circuit with ![X](img/file9.png "X") gates on the qubits
    that you need to be set to ![1](img/file13.png "1"). If you use this method, however,
    you need to be careful to remember that qubit ![0](img/file12.png "0") in Qiskit
    circuits is represented as the rightmost one in kets. Thus, if you have a three-qubit
    `QuantumCircuit` called `qc` and you use `qc``.``x` `(0)`, you will obtain ![\left|
    {001} \right\rangle](img/file392.png "\left| {001} \right\rangle")!*
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 设置量子状态值的另一种间接方法是创建一个准备该状态的量子电路，并运行它以获得状态向量，就像我们在 *第* *[*2*](ch009.xhtml#x1-400002)，*量子计算的工具*
    *第* *[*2*](ch009.xhtml#x1-400002) *章* 中学习的那样；或者你也可以直接将量子电路传递给 `Statevector` 构造函数。例如，要创建基态，你只需要一个在需要设置为
    ![1](img/file13.png "1") 的量子比特上具有 ![X](img/file9.png "X") 门电路的电路。如果你使用这种方法，然而，你需要小心记住在
    Qiskit 电路中，量子比特 ![0](img/file12.png "0") 被表示为矢量中的最右边。因此，如果你有一个名为 `qc` 的三量子比特 `QuantumCircuit`，并且你使用
    `qc``.``x` `(0)`，你将获得 ![\left| {001} \right\rangle](img/file392.png "\left| {001}
    \right\rangle")!*
- en: '*In order to compute expectation values, quantum states are not enough. We
    also need to create Hamiltonians. For now, we will learn how to work with tensor
    products of ![Z](img/file8.png "Z") gates, like the ones we used in the previous
    section, starting with simple ones that can be stored in Qiskit `Pauli` objects.
    Qiskit offers several ways to initialize them, like in the case of `Statevector`
    objects. The first one is to use a string to specify the positions of ![Z](img/file8.png
    "Z") and ![I](img/file53.png "I") matrices in the product. For instance, if we
    are working with three qubits and we want to create ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}") (which is, as you surely remember, the tensor product ![Z \otimes
    Z \otimes I](img/file348.png "Z \otimes Z \otimes I")), we can use the following
    instructions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了计算期望值，量子态是不够的。我们还需要创建哈密顿量。现在，我们将学习如何处理![Z](img/file8.png "Z")门张量积，就像我们在上一节中使用的那样，从可以存储在Qiskit
    `Pauli`对象中的简单门开始。Qiskit提供了几种初始化它们的方法，就像`Statevector`对象的情况一样。第一种方法是使用字符串来指定乘积中对![Z](img/file8.png
    "Z")和![I](img/file53.png "I")矩阵的位置。例如，如果我们正在处理三个量子比特，并且我们想要创建![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}")（您可能还记得，这是张量积![Z \otimes Z \otimes I](img/file348.png "Z \otimes
    Z \otimes I")），我们可以使用以下指令：'
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'They give the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它们给出了以下输出：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The matrix representing ![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}") is of size
    ![8 \times 8](img/file393.png "8 \times 8") and, as you can see, it can be hard
    to read. Fortunately, we can use the fact that tensor products of diagonal matrices
    are always diagonal, and print only the non-zero coefficients with the following
    instructions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表示![Z_{0}Z_{1}](img/file352.png "Z_{0}Z_{1}")的矩阵大小为![8 \times 8](img/file393.png
    "8 \times 8")，如您所见，它可能难以阅读。幸运的是，我们可以利用对角矩阵的张量积总是对角的事实，并使用以下指令仅打印非零系数：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'They will give us:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将给出：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To learn more…
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: When constructing a `Pauli` object, we can also specify which positions of the
    tensor product are ![Z](img/file8.png "Z") matrices, passing them as a vector
    of ones (indicating the presence of ![Z](img/file8.png "Z")) and zeroes (indicating
    the absence of ![Z](img/file8.png "Z") or, equivalently, the presence of ![I](img/file53.png
    "I")). Since the construction method is more general and it can be used to create
    other tensor products, we would need to specify another vector with positions
    of ![X](img/file9.png "X") matrices, which we will set to all zeroes for the moment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建`Pauli`对象时，我们还可以指定张量积中哪些位置是![Z](img/file8.png "Z")矩阵，通过传递一个包含![Z](img/file8.png
    "Z")（表示存在）和零（表示不存在![Z](img/file8.png "Z")或等价地，存在![I](img/file53.png "I")）的向量。由于构造方法更通用，它可以用来创建其他张量积，因此我们需要指定另一个包含![X](img/file9.png
    "X")矩阵位置的向量，我们暂时将其设置为全零。
- en: For instance, you can run something like `Z0Z1` `=` `Pauli``(([0,1,1],[0,0,0]))`
    in order to obtain ![Z \otimes Z \otimes I](img/file348.png "Z \otimes Z \otimes
    I"). Notice that, because of the convention of qubit numbering in Qiskit, we need
    to use `[0,1,1]` for the vector of ![Z](img/file8.png "Z") positions instead of
    `[1,1,0]`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以运行类似`Z0Z1` `=` `Pauli``(([0,1,1],[0,0,0]))`的命令以获得![Z \otimes Z \otimes
    I](img/file348.png "Z \otimes Z \otimes I")。请注意，由于Qiskit中量子比特编号的约定，我们需要使用`[0,1,1]`作为![Z](img/file8.png
    "Z")位置向量的值，而不是`[1,1,0]`。
- en: 'The main drawback of working with `Pauli` objects is that you cannot add them
    or multiply them by scalars. To get something like ![Z_{0}Z_{1} + Z_{1}Z_{2}](img/file394.png
    "Z_{0}Z_{1} + Z_{1}Z_{2}"), we need first to convert the `Pauli` objects to `PauliOp`,
    which we can then add together as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Pauli`对象工作的主要缺点是，你不能将它们相加或乘以标量。为了得到类似![Z_{0}Z_{1} + Z_{1}Z_{2}](img/file394.png
    "Z_{0}Z_{1} + Z_{1}Z_{2}")的东西，我们首先需要将`Pauli`对象转换为`PauliOp`，然后我们可以像以下代码所示那样将它们相加：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output, in this case, is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出如下：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the sum of diagonal matrices is diagonal, we have used the sparse representation
    to more compactly show the non-zero terms of `H_cut`. Notice that even some of
    the diagonal terms are zero, because some elements of ![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}") cancel with those of ![Z_{0}Z_{2}](img/file395.png "Z_{0}Z_{2}").
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对角矩阵之和是对角矩阵，我们已使用稀疏表示法来更紧凑地显示`H_cut`的非零项。请注意，即使某些对角项为零，因为![Z_{0}Z_{1}](img/file352.png
    "Z_{0}Z_{1}")的一些元素与![Z_{0}Z_{2}](img/file395.png "Z_{0}Z_{2}")的一些元素相抵消。
- en: 'A more compact way of obtaining the same Hamiltonian is:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 获取相同哈密顿量的更紧凑方式是：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This evaluates to:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估为：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that we have used `^` to compute tensor products and parenthesis to get
    the operation priorities right.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`^`来计算张量积，并使用括号来正确设置操作优先级。
- en: Of course, more complicated Hamiltonians, even including coefficients, can be
    constructed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以构建更复杂的哈密顿量，甚至包括系数。
- en: For example,
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: defines the Hamiltonian ![\left. - 1\slash 2Z_{0}Z_{1} + 2Z_{0}Z_{2} - Z_{1}Z_{2}
    + Z_{1} - 5Z_{2} \right.](img/file396.png "\left. - 1\slash 2Z_{0}Z_{1} + 2Z_{0}Z_{2}
    - Z_{1}Z_{2} + Z_{1} - 5Z_{2} \right.").
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 定义哈密顿量![\left. - 1\slash 2Z_{0}Z_{1} + 2Z_{0}Z_{2} - Z_{1}Z_{2} + Z_{1} - 5Z_{2}
    \right.](img/file396.png "\left. - 1\slash 2Z_{0}Z_{1} + 2Z_{0}Z_{2} - Z_{1}Z_{2}
    + Z_{1} - 5Z_{2} \right.").
- en: 'Now we are ready to compute expectation values. Thanks to the code that we
    have written and executed so far, `psi` stores ![\left| {100} \right\rangle](img/file387.png
    "\left| {100} \right\rangle") and `H_cut` stores ![Z_{0}Z_{1} + Z_{1}Z_{2}](img/file394.png
    "Z_{0}Z_{1} + Z_{1}Z_{2}"). Then, computing ![\left\langle {100} \right|\left(
    {Z_{0}Z_{1} + Z_{1}Z_{2}} \right)\left| {100} \right\rangle](img/file397.png "\left\langle
    {100} \right|\left( {Z_{0}Z_{1} + Z_{1}Z_{2}} \right)\left| {100} \right\rangle")
    is as easy as running the following instruction:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好计算期望值。多亏了我们迄今为止编写的和执行的代码，`psi`存储![\left| {100} \right\rangle](img/file387.png
    "\left| {100} \right\rangle")，而`H_cut`存储![Z_{0}Z_{1} + Z_{1}Z_{2}](img/file394.png
    "Z_{0}Z_{1} + Z_{1}Z_{2}")。然后，计算![\left\langle {100} \right|\left( {Z_{0}Z_{1}
    + Z_{1}Z_{2}} \right)\left| {100} \right\rangle](img/file397.png "\left\langle
    {100} \right|\left( {Z_{0}Z_{1} + Z_{1}Z_{2}} \right)\left| {100} \right\rangle")就像运行以下指令一样简单：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will give us the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since ![Z_{0}Z_{1} + Z_{0}Z_{2}](img/file398.png "Z_{0}Z_{1} + Z_{0}Z_{2}")
    is the Hamiltonian for the Max-Cut problem of the graph in *Figure* * [*3.5*](#Figure3.5),
    this indicates that the assignment represented by ![\left| {100} \right\rangle](img/file387.png
    "\left| {100} \right\rangle") (vertex ![0](img/file12.png "0") in one set and
    ![1](img/file13.png "1") and ![2](img/file302.png "2") in the other) cuts the
    two edges of the graph and is, therefore, an optimal solution. Notice how the
    output is represented as a complex number because inner products can, in general,
    have imaginary parts. However, these expectation values will always be real, and
    the coefficients that will go with the imaginary unit — represented in Python
    as `j` — will just be ![0](img/file12.png "0").*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于![Z_{0}Z_{1} + Z_{0}Z_{2}](img/file398.png "Z_{0}Z_{1} + Z_{0}Z_{2}")是图*图*[*3.5*](#Figure3.5)的最大切割问题的哈密顿量，这表明由![\left|
    {100} \right\rangle](img/file387.png "\left| {100} \right\rangle")（一个集合中的顶点![0](img/file12.png
    "0")和另一个集合中的![1](img/file13.png "1")和![2](img/file302.png "2")）表示的分配切断了图的两个边，因此是一个最优解。注意输出是如何表示为复数的，因为内积通常可以有虚部。然而，这些期望值始终是实数，与虚数单位（在Python中表示为`j`）相关的系数将只是![0](img/file12.png
    "0")。
- en: '*Exercise 3.4'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*练习3.4'
- en: Write code to compute the expectation value of all the possible cuts of the
    graph in *Figure* *[*3.5*](#Figure3.5). How many optimal solutions are there?*
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以计算图*图*[*3.5*](#Figure3.5)中所有可能切割的期望值。有多少个最优解？
- en: '*If you want to evaluate expressions such as ![\left\langle \psi \right|H_{\text{cut}}\left|
    \psi \right\rangle](img/file399.png "\left\langle \psi \right|H_{\text{cut}}\left|
    \psi \right\rangle") step by step, you can also use Qiskit to first compute ![H_{\text{cut}}\left|
    \psi \right\rangle](img/file400.png "H_{\text{cut}}\left| \psi \right\rangle")
    and, then, the inner product of ![\left| \psi \right\rangle](img/file43.png "\left|
    \psi \right\rangle") with that. This can be achieved with the following instruction:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您想逐步评估如![\left\langle \psi \right|H_{\text{cut}}\left| \psi \right\rangle](img/file399.png
    "\left\langle \psi \right|H_{\text{cut}}\left| \psi \right\rangle")之类的表达式，您也可以使用Qiskit首先计算![H_{\text{cut}}\left|
    \psi \right\rangle](img/file400.png "H_{\text{cut}}\left| \psi \right\rangle")，然后计算![\left|
    \psi \right\rangle](img/file43.png "\left| \psi \right\rangle")与该向量的内积。这可以通过以下指令实现：'
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the `evolve` method is used to compute the matrix-vector multiplication,
    and `inner` is, obviously, used for the inner product.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`evolve`方法来计算矩阵-向量乘法，而`inner`显然用于内积。
- en: Important note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'We must stress that all these operations are numerical and not something that
    we can run on actual quantum computers. In fact, as you already know, on real
    devices we have no access to the full state vector: this is something that we
    can only do when we run circuits on simulators. In any case, we know that state
    vectors grow exponentially in size with the number of qubits, so simulations can
    easily become unfeasible in many scenarios. But don’t worry. In *Chapter* *[*5*](ch013.xhtml#x1-940005),
    *QAOA: Quantum Approximate* *Optimization Algorithm*, we will learn how to use
    quantum computers to estimate expectation values of tensor products of ![Z](img/file8.png
    "Z") matrices. In *Chapter* * [*7*](ch015.xhtml#x1-1190007), *VQE: Variational
    Quantum Eigensolver*, we will do the same with more general tensor products. In
    fact, the procedure that we will use will clarify why we call these quantities
    *expectation values*!**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须强调，所有这些操作都是数值操作，而不是我们可以在实际量子计算机上运行的操作。事实上，正如您已经知道的，在真实设备上，我们无法访问完整的态矢量：这是我们只能在模拟器上运行电路时才能做到的事情。无论如何，我们知道态矢量的大小会随着量子比特数量的指数增长，因此在许多情况下，模拟可能变得不可行。但别担心。在第
    *5* 章 *QAOA：量子近似优化算法* 中，我们将学习如何使用量子计算机来估计![Z](img/file8.png "Z")矩阵张量的期望值。在第 *7*
    章 *VQE：变分量子本征值求解器* 中，我们将对更一般的张量产品做同样的处理。实际上，我们将使用的程序将阐明为什么我们称这些量为 *期望值*！**
- en: '**But enough of tensor products and expectation values for now. Instead, in
    the next section, we will introduce a new formalism that will allow us to formulate
    some optimization problems more naturally than with the Ising model.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**但关于张量积和期望值就先到这里。相反，在下一节中，我们将介绍一种新的形式，这将使我们能够比使用伊辛模型更自然地表述一些优化问题。**'
- en: 3.3 Moving from Ising to QUBO and back
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 从伊辛模型到QUBO模型及其反向转换
- en: Consider the following problem. Let’s say that you are given a set of integers
    ![S](img/file73.png "S") and a target integer value ![T](img/file74.png "T"),
    and you are asked whether there is any subset of ![S](img/file73.png "S") whose
    sum is ![T](img/file74.png "T"). For instance, if ![S = \{ 1,3,4,7, - 4\}](img/file401.png
    "S = \{ 1,3,4,7, - 4\}") and ![T = 6](img/file402.png "T = 6"), then the answer
    is affirmative, because ![3 + 7 - 4 = 6](img/file403.png "3 + 7 - 4 = 6"). However,
    if ![S = \{ 2, - 2,4,8, - 12\}](img/file404.png "S = \{ 2, - 2,4,8, - 12\}") and
    ![T = 1](img/file405.png "T = 1"), the answer is negative because all the numbers
    in the set are even and they cannot add up to an odd number.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题。假设你被给出一组整数![S](img/file73.png "S")和一个目标整数值![T](img/file74.png "T")，并要求你判断是否存在![S](img/file73.png
    "S")的任何子集，其和为![T](img/file74.png "T")。例如，如果![S = \{ 1,3,4,7, - 4\}](img/file401.png
    "S = \{ 1,3,4,7, - 4\}")且![T = 6](img/file402.png "T = 6")，那么答案是肯定的，因为![3 + 7
    - 4 = 6](img/file403.png "3 + 7 - 4 = 6")。然而，如果![S = \{ 2, - 2,4,8, - 12\}](img/file404.png
    "S = \{ 2, - 2,4,8, - 12\}")且![T = 1](img/file405.png "T = 1")，答案是否定的，因为集合中的所有数字都是偶数，它们无法相加得到一个奇数。
- en: This problem, called the **Subset Sum** problem, is known to be ![NP](img/file2.png
    "NP")**-complete** (see, for instance, *Section 7.5* in the book by Sipser [[90](ch030.xhtml#Xsipser2012introduction)]
    for a proof). It turns out that we can **reduce** the Subset Sum problem to finding
    a spin configuration of minimal energy for an Ising model, (which is an ![NP](img/file2.png
    "NP")-hard problem – see *Section* * [*3.1.3*](#x1-630003.1.3)). This means that
    we can rewrite any instance of Subset Sum as an Ising ground state problem (check
    *Appendix* * [*C*](ch026.xhtml#x1-233000C), *Computational* *Complexity*, for
    a refresher on **reductions**).**
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个被称为 **子集和** 的问题已知是 ![NP](img/file2.png "NP")**-完全** 的（例如，参见 Sipser 的书中的 *第7.5节*
    [[90](ch030.xhtml#Xsipser2012introduction)] 以获取证明）。结果证明，我们可以 **将** 子集和问题简化为寻找伊辛模型的最小能量自旋配置（这是一个
    ![NP](img/file2.png "NP")-难问题 –参见 *第3.1.3节*），这意味着我们可以将任何子集和实例重写为伊辛基态问题（检查 *附录*
    * [*C*](ch026.xhtml#x1-233000C)，*计算复杂性*，以复习 **简化**）。**
- en: '**However, it may not be directly evident how to do so.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**然而，如何做到这一点可能并不直接明显。'
- en: In fact, it is much simpler to pose the Subset Sum problem as a minimization
    problem by using binary variables instead of variables that take ![1](img/file13.png
    "1") or ![- 1](img/file312.png "- 1") values. Indeed, if we are given ![S = \{
    a_{0},\ldots,a_{m}\}](img/file406.png "S = \{ a_{0},\ldots,a_{m}\}") and an integer
    ![T](img/file74.png "T"), we can define binary variables ![x_{j}](img/file407.png
    "x_{j}"), ![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m"), and consider
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，通过使用取 ![1](img/file13.png "1") 或 ![- 1](img/file312.png "- 1") 值的变量而不是二进制变量来提出子集和问题作为最小化问题要简单得多。确实，如果我们给定
    ![S = \{ a_{0},\ldots,a_{m}\}](img/file406.png "S = \{ a_{0},\ldots,a_{m}\}")
    和一个整数 ![T](img/file74.png "T")，我们可以定义二进制变量 ![x_{j}](img/file407.png "x_{j}"),
    ![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m")，并考虑
- en: '![c(x_{0},x_{1},\ldots,x_{m}) = \left( {a_{0}x_{0} + a_{1}x_{1} + \ldots +
    a_{m}x_{m} - T} \right)^{2}.](img/file409.png "c(x_{0},x_{1},\ldots,x_{m}) = \left(
    {a_{0}x_{0} + a_{1}x_{1} + \ldots + a_{m}x_{m} - T} \right)^{2}.")'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![c(x_{0},x_{1},\ldots,x_{m}) = \left( {a_{0}x_{0} + a_{1}x_{1} + \ldots +
    a_{m}x_{m} - T} \right)^{2}.](img/file409.png "c(x_{0},x_{1},\ldots,x_{m}) = \left(
    {a_{0}x_{0} + a_{1}x_{1} + \ldots + a_{m}x_{m} - T} \right)^{2}.")'
- en: 'Clearly, the Subset Sum problem has a positive answer if and only if we can
    find binary values ![x_{j}](img/file407.png "x_{j}"), ![j = 0,\ldots,m](img/file408.png
    "j = 0,\ldots,m"), such that ![c(x_{0},x_{1},\ldots,x_{m}) = 0](img/file410.png
    "c(x_{0},x_{1},\ldots,x_{m}) = 0"). In that case, the variables ![x_{j}](img/file407.png
    "x_{j}") that are equal to ![1](img/file13.png "1") will indicate which numbers
    from the set are selected for the sum. But ![c(x_{0},x_{1},\ldots,x_{m})](img/file411.png
    "c(x_{0},x_{1},\ldots,x_{m})") is always non-negative, so we have reduced the
    Subset Sum problem to finding the minimum of ![c(x_{0},x_{1},\ldots,x_{m})](img/file411.png
    "c(x_{0},x_{1},\ldots,x_{m})"): if the minimum is ![0](img/file12.png "0"), the
    Subset Sum has a positive solution; otherwise, it doesn’t.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们可以找到满足 ![c(x_{0},x_{1},\ldots,x_{m}) = 0](img/file410.png "c(x_{0},x_{1},\ldots,x_{m})
    = 0") 的二进制值 ![x_{j}](img/file407.png "x_{j}"), ![j = 0,\ldots,m](img/file408.png
    "j = 0,\ldots,m")，则子集和问题有正解。在这种情况下，等于 ![1](img/file13.png "1") 的变量 ![x_{j}](img/file407.png
    "x_{j}") 将指示哪些数字被选中进行求和。但是 ![c(x_{0},x_{1},\ldots,x_{m})](img/file411.png "c(x_{0},x_{1},\ldots,x_{m})")
    总是非负的，因此我们将子集和问题简化为寻找 ![c(x_{0},x_{1},\ldots,x_{m})](img/file411.png "c(x_{0},x_{1},\ldots,x_{m})")
    的最小值：如果最小值为 ![0](img/file12.png "0")，则子集和有正解；否则，没有。
- en: For example, for the case of ![S = \{ 1,4, - 2\}](img/file412.png "S = \{ 1,4,
    - 2\}") and ![T = 2](img/file413.png "T = 2") that we considered previously, the
    problem would be
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于之前考虑的 ![S = \{ 1,4, - 2\}](img/file412.png "S = \{ 1,4, - 2\}") 和 ![T =
    2](img/file413.png "T = 2") 的情况，问题将是
- en: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {x_{0}^{2} + 8x_{0}x_{1} -
    4x_{0}x_{2} - 4x_{0} + 16x_{1}^{2} - 16x_{1}x_{2} - 16x_{1} + 4x_{2}^{2} + 8x_{2}
    + 4\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {x_{j} \in \{ 0,1\},\qquad
    j = 0,\ldots,m\qquad} & & \qquad \\ \end{array}](img/file414.png "\begin{array}{rlrl}
    {\text{Minimize~}\quad} & {x_{0}^{2} + 8x_{0}x_{1} - 4x_{0}x_{2} - 4x_{0} + 16x_{1}^{2}
    - 16x_{1}x_{2} - 16x_{1} + 4x_{2}^{2} + 8x_{2} + 4\qquad} & & \qquad \\ {\text{subject~to~}\quad}
    & {x_{j} \in \{ 0,1\},\qquad j = 0,\ldots,m\qquad} & & \qquad \\ \end{array}")'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{最小化~}\quad} & {x_{0}^{2} + 8x_{0}x_{1} - 4x_{0}x_{2}
    - 4x_{0} + 16x_{1}^{2} - 16x_{1}x_{2} - 16x_{1} + 4x_{2}^{2} + 8x_{2} + 4\qquad}
    & & \qquad \\ {\text{约束~}\quad} & {x_{j} \in \{ 0,1\},\qquad j = 0,\ldots,m\qquad}
    & & \qquad \\ \end{array}](img/file414.png "\begin{array}{rlrl} {\text{最小化~}\quad}
    & {x_{0}^{2} + 8x_{0}x_{1} - 4x_{0}x_{2} - 4x_{0} + 16x_{1}^{2} - 16x_{1}x_{2}
    - 16x_{1} + 4x_{2}^{2} + 8x_{2} + 4\qquad} & & \qquad \\ {\text{约束~}\quad} & {x_{j}
    \in \{ 0,1\},\qquad j = 0,\ldots,m\qquad} & & \qquad \\ \end{array}")'
- en: where we have expanded ![{(x_{0} + 4x_{1} - 2x_{2} - 2)}^{2}](img/file415.png
    "{(x_{0} + 4x_{1} - 2x_{2} - 2)}^{2}") to obtain the expression to be optimized.
    If you wish, you can simplify it a little by taking into account that ![x_{j}^{2}
    = x_{j}](img/file416.png "x_{j}^{2} = x_{j}") always holds for binary variables.
    In any case, ![x_{0} = 0,x_{1} = x_{2} = 1](img/file417.png "x_{0} = 0,x_{1} =
    x_{2} = 1") would be an optimal solution for this problem.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 ![{(x_{0} + 4x_{1} - 2x_{2} - 2)}^{2}](img/file415.png "{(x_{0} + 4x_{1}
    - 2x_{2} - 2)}^{2}") 展开以获得要优化的表达式。如果您愿意，可以通过考虑二进制变量总是满足 ![x_{j}^{2} = x_{j}](img/file416.png
    "x_{j}^{2} = x_{j}") 来稍微简化它。无论如何，![x_{0} = 0,x_{1} = x_{2} = 1](img/file417.png
    "x_{0} = 0,x_{1} = x_{2} = 1") 将是此问题的最优解。
- en: Notice that, in all of these cases, the function ![c(x_{0},x_{1},\ldots,x_{m})](img/file411.png
    "c(x_{0},x_{1},\ldots,x_{m})") that we need to minimize is a polynomial of degree
    ![2](img/file302.png "2") on the binary variables ![x_{j}](img/file407.png "x_{j}").
    We can thus generalize this setting and define **Quadratic Unconstrained** **Binary
    Optimization** (**QUBO**) problems, which are of the form
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这些所有情况下，我们需要最小化的函数 ![c(x_{0},x_{1},\ldots,x_{m})](img/file411.png "c(x_{0},x_{1},\ldots,x_{m})")
    是一个关于二元变量 ![x_{j}](img/file407.png "x_{j}") 的 ![2](img/file302.png "2") 次多项式。因此，我们可以推广这种设置，并定义
    **二次无约束** **二元优化** （**QUBO**）问题，其形式如下
- en: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {q(x_{0},\ldots,x_{m})\qquad}
    & & \qquad \\ {\text{subject~to~}\quad} & {x_{j} \in \{ 0,1\},\qquad j = 0,\ldots,m\qquad}
    & & \qquad \\ \end{array}](img/file418.png "\begin{array}{rlrl} {\text{Minimize~}\quad}
    & {q(x_{0},\ldots,x_{m})\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {x_{j}
    \in \{ 0,1\},\qquad j = 0,\ldots,m\qquad} & & \qquad \\ \end{array}")'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {q(x_{0},\ldots,x_{m})\qquad}
    & & \qquad \\ {\text{subject~to~}\quad} & {x_{j} \in \{ 0,1\},\qquad j = 0,\ldots,m\qquad}
    & & \qquad \\ \end{array}](img/file418.png "\begin{array}{rlrl} {\text{Minimize~}\quad}
    & {q(x_{0},\ldots,x_{m})\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {x_{j}
    \in \{ 0,1\},\qquad j = 0,\ldots,m\qquad} & & \qquad \\ \end{array}")'
- en: 'where ![q(x_{0},\ldots,x_{m})](img/file419.png "q(x_{0},\ldots,x_{m})") is
    a quadratic polynomial on the ![x_{j}](img/file407.png "x_{j}") variables. The
    reason why these problems are called QUBO should now be clear: we are minimizing
    quadratic expressions over binary variables with no restrictions (because every
    combination of zeroes and ones is acceptable).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![q(x_{0},\ldots,x_{m})](img/file419.png "q(x_{0},\ldots,x_{m})") 是关于 ![x_{j}](img/file407.png
    "x_{j}") 变量的二次多项式。为什么这些问题被称为 QUBO 应该现在很清楚了：我们在没有限制的情况下（因为零和一的任何组合都是可接受的）最小化二次表达式。
- en: From the preceding reduction of the Subset Sum problem, it follows that QUBO
    problems are ![NP](img/file2.png "NP")-hard. Indeed, the QUBO model is very flexible,
    and it enables us to formulate many optimization problems in a natural way. For
    example, it is quite easy to recast any Ising minimization problem as a QUBO instance.
    If you need to minimize
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前对子集和问题的简化中可以得出，QUBO 问题属于 ![NP](img/file2.png "NP")-hard。事实上，QUBO 模型非常灵活，它使我们能够以自然的方式表述许多优化问题。例如，将任何伊辛最小化问题重新表述为
    QUBO 实例相当容易。如果你需要最小化
- en: '![- \sum\limits_{j,k}J_{jk}z_{j}z_{k} - \sum\limits_{j}h_{j}z_{j}](img/file341.png
    "- \sum\limits_{j,k}J_{jk}z_{j}z_{k} - \sum\limits_{j}h_{j}z_{j}")'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![- \sum\limits_{j,k}J_{jk}z_{j}z_{k} - \sum\limits_{j}h_{j}z_{j}](img/file341.png
    "- \sum\limits_{j,k}J_{jk}z_{j}z_{k} - \sum\limits_{j}h_{j}z_{j}")'
- en: with some variables ![z_{j}](img/file339.png "z_{j}"), ![j = 0,\ldots,m](img/file408.png
    "j = 0,\ldots,m"), taking values ![1](img/file13.png "1") or ![- 1](img/file312.png
    "- 1"), you can define new variables ![\left. x_{j} = (1 - z_{j})\slash 2 \right.](img/file420.png
    "\left. x_{j} = (1 - z_{j})\slash 2 \right."). Obviously, ![x_{j}](img/file407.png
    "x_{j}") will be ![0](img/file12.png "0") when ![z_{j}](img/file339.png "z_{j}")
    is ![1](img/file13.png "1"), and ![1](img/file13.png "1") when ![z_{j}](img/file339.png
    "z_{j}") is ![- 1](img/file312.png "- 1"). Furthermore, if you make the substitutions
    ![z_{j} = 1 - 2x_{j}](img/file421.png "z_{j} = 1 - 2x_{j}"), you obtain a quadratic
    polynomial in the binary variables ![x_{j}](img/file407.png "x_{j}") that takes
    exactly the same values as the energy function of the original Ising model. If
    you minimize the polynomial for the variables ![x_{j}](img/file407.png "x_{j}"),
    you can then recover the spin values ![z_{j}](img/file339.png "z_{j}") that achieve
    the minimal energy.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 某些变量 ![z_{j}](img/file339.png "z_{j}"), ![j = 0,\ldots,m](img/file408.png "j
    = 0,\ldots,m")，取值 ![1](img/file13.png "1") 或 ![- 1](img/file312.png "- 1")，你可以定义新的变量
    ![\left. x_{j} = (1 - z_{j})\slash 2 \right.](img/file420.png "\left. x_{j} =
    (1 - z_{j})\slash 2 \right.")。显然，当 ![z_{j}](img/file339.png "z_{j}") 为 ![1](img/file13.png
    "1") 时，![x_{j}](img/file407.png "x_{j}") 将为 ![0](img/file12.png "0")，而当 ![z_{j}](img/file339.png
    "z_{j}") 为 ![- 1](img/file312.png "- 1") 时，![x_{j}](img/file407.png "x_{j}") 将为
    ![1](img/file13.png "1")。此外，如果你进行替换 ![z_{j} = 1 - 2x_{j}](img/file421.png "z_{j}
    = 1 - 2x_{j}"), 你将得到一个关于二元变量 ![x_{j}](img/file407.png "x_{j}") 的二次多项式，其值正好与原始伊辛模型的能量函数相同。如果你对变量
    ![x_{j}](img/file407.png "x_{j}") 的多项式进行最小化，你就可以恢复出 ![z_{j}](img/file339.png "z_{j}")
    的自旋值，这些值实现了最小能量。
- en: In case you were wondering, yes, you can also use the substitution ![z_{j} =
    2x_{j} - 1](img/file422.png "z_{j} = 2x_{j} - 1") to transform Ising problems
    into QUBO formalism. In that case, values of ![z_{j}](img/file339.png "z_{j}")
    equal to ![- 1](img/file312.png "- 1") would be taken to values of ![x_{j}](img/file407.png
    "x_{j}") equal to ![0](img/file12.png "0") and values of ![z_{j}](img/file339.png
    "z_{j}") equal to ![1](img/file13.png "1") would be taken to ![1](img/file13.png
    "1") in ![x_{j}](img/file407.png "x_{j}"). However, we will stick to the transformation
    ![z_{j} = 1 - 2x_{j}](img/file421.png "z_{j} = 1 - 2x_{j}") for the rest of the
    book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有所疑问，是的，您也可以使用替换公式 ![z_{j} = 2x_{j} - 1](img/file422.png "z_{j} = 2x_{j}
    - 1") 将伊辛问题转换为QUBO形式。在这种情况下，![z_{j}](img/file339.png "z_{j}") 的值为 ![- 1](img/file312.png
    "- 1") 将转换为 ![x_{j}](img/file407.png "x_{j}") 的值为 ![0](img/file12.png "0")，而 ![z_{j}](img/file339.png
    "z_{j}") 的值为 ![1](img/file13.png "1") 将转换为 ![x_{j}](img/file407.png "x_{j}") 的值为
    ![1](img/file13.png "1")。然而，我们将坚持使用转换公式 ![z_{j} = 1 - 2x_{j}](img/file421.png
    "z_{j} = 1 - 2x_{j}") 在本书的其余部分。
- en: 'For instance, if the Ising energy is given by ![\left. ( - 1\slash 2)z_{0}z_{1}
    + z_{2} \right.](img/file423.png "\left. ( - 1\slash 2)z_{0}z_{1} + z_{2} \right."),
    then, under the transformation ![z_{j} = 1 - 2x_{j}](img/file421.png "z_{j} =
    1 - 2x_{j}"), the corresponding QUBO problem will be the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果伊辛能量由 ![\left. ( - 1\slash 2)z_{0}z_{1} + z_{2} \right.](img/file423.png
    "\left. ( - 1\slash 2)z_{0}z_{1} + z_{2} \right.") 给出，那么，在转换公式 ![z_{j} = 1 - 2x_{j}](img/file421.png
    "z_{j} = 1 - 2x_{j}") 下，相应的QUBO问题将是以下：
- en: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {- 2x_{0}x_{1} + x_{0} + x_{1}
    - 2x_{2} + \frac{1}{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {x_{j}
    \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}](img/file424.png
    "\begin{array}{rlrl} {\text{Minimize~}\quad} & {- 2x_{0}x_{1} + x_{0} + x_{1}
    - 2x_{2} + \frac{1}{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {x_{j}
    \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {- 2x_{0}x_{1} + x_{0} + x_{1}
    - 2x_{2} + \frac{1}{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {x_{j}
    \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}](img/file424.png
    "\begin{array}{rlrl} {\text{Minimize~}\quad} & {- 2x_{0}x_{1} + x_{0} + x_{1}
    - 2x_{2} + \frac{1}{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {x_{j}
    \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}")'
- en: You can also go from a QUBO problem to an Ising model instance by using the
    ![\left. x_{j} = (1 - z_{j})\slash 2 \right.](img/file420.png "\left. x_{j} =
    (1 - z_{j})\slash 2 \right.") substitution. However, you will need to pay attention
    to a couple of details. Let’s illustrate them with an example. Suppose that your
    QUBO problem is asking to minimize ![x_{0}^{2} + 2x_{0}x_{1} - 3](img/file425.png
    "x_{0}^{2} + 2x_{0}x_{1} - 3"). Then, when you substitute the ![x_{j}](img/file407.png
    "x_{j}") variables, you obtain
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过使用替换公式 ![\left. x_{j} = (1 - z_{j})\slash 2 \right.](img/file420.png "\left.
    x_{j} = (1 - z_{j})\slash 2 \right.") 从QUBO问题转换到伊辛模型实例。然而，您需要注意一些细节。让我们用一个例子来说明。假设您的QUBO问题是要求最小化
    ![x_{0}^{2} + 2x_{0}x_{1} - 3](img/file425.png "x_{0}^{2} + 2x_{0}x_{1} - 3")。那么，当您替换
    ![x_{j}](img/file407.png "x_{j}") 变量时，您将得到
- en: '![\frac{z_{0}^{2}}{4} + \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - \frac{9}{4}.](img/file426.png
    "\frac{z_{0}^{2}}{4} + \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - \frac{9}{4}.")'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![\frac{z_{0}^{2}}{4} + \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - \frac{9}{4}.](img/file426.png
    "\frac{z_{0}^{2}}{4} + \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - \frac{9}{4}.")'
- en: But the Ising model does not allow squared variables or independent terms! Fixing
    these problems is not difficult, though. Regarding the squared variables, we can
    simply notice that it always holds that ![z_{j}^{2} = 1](img/file427.png "z_{j}^{2}
    = 1"), because ![z_{j}](img/file339.png "z_{j}") is either ![1](img/file13.png
    "1") or ![- 1](img/file312.png "- 1"). Thus, we replace each squared variable
    with the constant value ![1](img/file13.png "1"). In our case, we would get
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，伊辛模型不允许平方变量或独立项！虽然解决这些问题并不困难。关于平方变量，我们可以简单地注意到，总是有 ![z_{j}^{2} = 1](img/file427.png
    "z_{j}^{2} = 1")，因为 ![z_{j}](img/file339.png "z_{j}") 要么是 ![1](img/file13.png
    "1")，要么是 ![- 1](img/file312.png "- 1")。因此，我们将每个平方变量替换为常数 ![1](img/file13.png "1")。在我们的情况下，我们会得到
- en: '![\frac{1}{4} + \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - \frac{9}{4}
    = \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - 2.](img/file428.png "\frac{1}{4}
    + \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - \frac{9}{4} = \frac{z_{0}z_{1}}{2}
    - z_{0} - \frac{z_{1}}{2} - 2.")'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![\frac{1}{4} + \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - \frac{9}{4}
    = \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - 2.](img/file428.png "\frac{1}{4}
    + \frac{z_{0}z_{1}}{2} - z_{0} - \frac{z_{1}}{2} - \frac{9}{4} = \frac{z_{0}z_{1}}{2}
    - z_{0} - \frac{z_{1}}{2} - 2.")'
- en: 'Then, we can simply drop the independent term, because we are dealing with
    a minimization problem and it won’t influence the choice of optimal variables
    (however, you should add it back when you want to recover the original value of
    the function to minimize). In the preceding example, the equivalent Ising minimization
    problem would then be the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地去掉独立项，因为我们处理的是一个最小化问题，它不会影响最优变量的选择（然而，当你想要恢复最小化函数的原始值时，你应该把它加回来）。在前面的例子中，等价的伊辛最小化问题将是以下内容：
- en: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {\frac{z_{0}z_{1}}{2} - z_{0}
    - \frac{z_{1}}{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {z_{j} \in
    \{ 1, - 1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}](img/file429.png
    "\begin{array}{rlrl} {\text{Minimize~}\quad} & {\frac{z_{0}z_{1}}{2} - z_{0} -
    \frac{z_{1}}{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {z_{j} \in \{
    1, - 1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize~}\quad} & {\frac{z_{0}z_{1}}{2} - z_{0}
    - \frac{z_{1}}{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {z_{j} \in
    \{ 1, - 1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}](img/file429.png
    "\begin{array}{rlrl} {\text{Minimize~}\quad} & {\frac{z_{0}z_{1}}{2} - z_{0} -
    \frac{z_{1}}{2}\qquad} & & \qquad \\ {\text{subject~to~}\quad} & {z_{j} \in \{
    1, - 1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}")'
- en: 'It is easy to check that this problem has two optimal solutions: ![z_{0} =
    z_{1} = 1](img/file430.png "z_{0} = z_{1} = 1") and ![z_{0} = 1,z_{1} = - 1](img/file431.png
    "z_{0} = 1,z_{1} = - 1"), both attaining the ![- 1](img/file312.png "- 1") value.
    If we add back the independent term of value ![- 2](img/file333.png "- 2") that
    we had dropped, we obtain an optimal cost of ![- 3](img/file432.png "- 3") in
    the QUBO problem. These solutions correspond to ![x_{0} = x_{1} = 0](img/file433.png
    "x_{0} = x_{1} = 0") and ![x_{0} = 0,x_{1} = 1](img/file434.png "x_{0} = 0,x_{1}
    = 1"), respectively, which indeed evaluate to ![- 3](img/file432.png "- 3") and
    are optimal for the original problem.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 容易验证这个问题有两个最优解：![z_{0} = z_{1} = 1](img/file430.png "z_{0} = z_{1} = 1") 和 ![z_{0}
    = 1,z_{1} = - 1](img/file431.png "z_{0} = 1,z_{1} = - 1")，两者都达到了 ![- 1](img/file312.png
    "- 1") 的值。如果我们把之前丢弃的价值独立项 ![- 2](img/file333.png "- 2") 加回来，我们就能在 QUBO 问题中获得最优成本
    ![- 3](img/file432.png "- 3")。这些解分别对应于 ![x_{0} = x_{1} = 0](img/file433.png "x_{0}
    = x_{1} = 0") 和 ![x_{0} = 0,x_{1} = 1](img/file434.png "x_{0} = 0,x_{1} = 1")，确实评估为
    ![- 3](img/file432.png "- 3")，并且对于原始问题是最佳的。
- en: Exercise 3.5
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.5
- en: Write the Subset Sum problem for ![S = \{ 1, - 2,3, - 4\}](img/file435.png "S
    = \{ 1, - 2,3, - 4\}") and ![T = 0](img/file436.png "T = 0") as a QUBO problem
    and transform it into an instance of the Ising model.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将子集和问题 ![S = \{ 1, - 2,3, - 4\}](img/file435.png "S = \{ 1, - 2,3, - 4\}") 和
    ![T = 0](img/file436.png "T = 0") 写成 QUBO 问题，并将其转换为伊辛模型的实例。
- en: So now we know how to go from QUBO problems to Ising energy minimization problems
    and back, and we can use either formalism — whichever is more convenient at any
    given moment. In fact, as we will learn in *Chapters* *[*4*](ch012.xhtml#x1-750004)
    and *[*5*](ch013.xhtml#x1-940005), the Ising model is the preferred formulation
    when solving combinatorial optimization problems with quantum computers. Also,
    the software tools that we will be using (Qiskit and D-Wave’s Ocean) will help
    us in rewriting our QUBO problems in the Ising formalism by using transformations
    like the ones we have described in this section.**
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道了如何从 QUBO 问题到伊辛能量最小化问题，然后再返回，我们可以使用任一形式——在任何给定时刻，哪个更方便就用哪个。实际上，正如我们将在
    **第 4 章**[*4*](ch012.xhtml#x1-750004) 和 **第 5 章**[*5*](ch013.xhtml#x1-940005)
    中学到的那样，伊辛模型是解决量子计算机组合优化问题的首选公式。此外，我们将使用的软件工具（Qiskit 和 D-Wave 的 Ocean）将帮助我们通过使用本节中描述的变换，将我们的
    QUBO 问题重写为伊辛形式。
- en: '**We now have all the mathematical tools that we need in order to work with
    combinatorial optimization problems if we want to solve them with quantum computers.
    Let’s play with our new, shiny toys and use them to write some important problems
    in QUBO formalism.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们现在拥有了所有需要的数学工具，如果我们想用量子计算机解决组合优化问题，我们可以玩转我们的新玩具，并用它们来编写一些重要的 QUBO 形式的问题。**'
- en: 3.4 Combinatorial optimization problems with the QUBO model
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 使用 QUBO 模型的组合优化问题
- en: In this final section of the chapter, we are going to introduce some techniques
    that will allow us to write many important optimization problems as QUBO and Ising
    instances, so we can later solve them with different quantum algorithms. These
    examples will also help you understand how to formulate your own optimization
    problems under these models, which is the first step in order to be able to use
    quantum computers to solve them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节，我们将介绍一些技术，这些技术将使我们能够将许多重要的优化问题写成QUBO和Ising实例，这样我们就可以稍后用不同的量子算法来解决它们。这些例子还将帮助您了解如何在这些模型下制定自己的优化问题，这是使用量子计算机解决它们的第一步。
- en: 3.4.1 Binary linear programming
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.1 二进制线性规划
- en: '**Binary linear programming** problems involve optimizing a linear function
    on binary variables subject to linear constraints. Thus, the general form is'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制线性规划**问题涉及在满足线性约束的二元变量上优化线性函数。因此，其一般形式为'
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {c_{0}x_{0} + c_{1}x_{1} + \ldots
    + c_{m}x_{m}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {Ax \leq b,\qquad}
    & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad j = 0,\ldots,m,\qquad} & & \qquad \\
    \end{array}](img/file437.png "\begin{array}{rlrl} {\text{Minimize}\quad} & {c_{0}x_{0}
    + c_{1}x_{1} + \ldots + c_{m}x_{m}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {Ax \leq b,\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,\ldots,m,\qquad}
    & & \qquad \\ \end{array}")'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {c_{0}x_{0} + c_{1}x_{1} + \ldots
    + c_{m}x_{m}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {Ax \leq b,\qquad}
    & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad j = 0,\ldots,m,\qquad} & & \qquad \\
    \end{array}](img/file437.png "\begin{array}{rlrl} {\text{Minimize}\quad} & {c_{0}x_{0}
    + c_{1}x_{1} + \ldots + c_{m}x_{m}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {Ax \leq b,\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,\ldots,m,\qquad}
    & & \qquad \\ \end{array}")'
- en: where ![c_{j}](img/file438.png "c_{j}") are integer coefficients, ![A](img/file183.png
    "A") is an integer matrix, ![x](img/file269.png "x") is the transpose of ![(x_{0},\ldots,x_{m})](img/file439.png
    "(x_{0},\ldots,x_{m})"), and ![b](img/file17.png "b") is an integer column vector.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![c_{j}](img/file438.png "c_{j}")是整数系数，![A](img/file183.png "A")是整数矩阵，![x](img/file269.png
    "x")是![ (x_{0},\ldots,x_{m})](img/file439.png "(x_{0},\ldots,x_{m})")的转置，而![b](img/file17.png
    "b")是整数列向量。
- en: 'An example of this type of problem could be the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型问题的例子可以是以下内容：
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad
    \\ & {3x_{0} - x_{1} + 3x_{2} \leq 4\qquad} & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad
    j = 0,1,2.\qquad} & & \qquad \\ \end{array}](img/file440.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad \\  & {3x_{0} - x_{1} + 3x_{2} \leq
    4\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad
    \\ \end{array}")'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad
    \\ & {3x_{0} - x_{1} + 3x_{2} \leq 4\qquad} & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad
    j = 0,1,2.\qquad} & & \qquad \\ \end{array}](img/file440.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{0} + x_{2} \leq 1,\qquad} & & \qquad \\  & {3x_{0} - x_{1} + 3x_{2} \leq
    4\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad
    \\ \end{array}")'
- en: Binary linear programming (also known as **zero-one linear programming**) is
    ![NP](img/file2.png "NP")-hard. In fact, the decision version in which the goal
    is to determine if there is any assignment of zeroes and ones that satisfies the
    linear constraints (with no actual optimization performed) was one of Richard
    M. Karp’s original 21 ![NP](img/file2.png "NP")-complete problems published in
    his famous paper on reducibility [[56](ch030.xhtml#Xkarp1972reducibility)]. Assignments
    that satisfy the constraints are called **feasible**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制线性规划（也称为**零一线性规划**）是![NP](img/file2.png "NP")-难问题。事实上，决策版本的目标是确定是否存在任何零和一的分配可以满足线性约束（不进行实际优化）是理查德·M·卡普最初发表的21个![NP](img/file2.png
    "NP")-完全问题之一，发表在他的著名论文《可约性》[[56](ch030.xhtml#Xkarp1972reducibility)]中。满足约束的分配被称为**可行**。
- en: 'To write a binary linear program in QUBO formalism, we need to perform some
    transformations. The first one is to convert the inequality constraints into equality
    constraints by adding **slack variables**. This is better understood with an example.
    In the preceding problem, we have two constraints: ![x_{0} + x_{2} \leq 1](img/file441.png
    "x_{0} + x_{2} \leq 1") and ![3x_{0} - x_{1} + 3x_{2} \leq 4](img/file442.png
    "3x_{0} - x_{1} + 3x_{2} \leq 4"). In the first one, the minimum value of the
    left-hand side is ![0](img/file12.png "0"), attained when both ![x_{0}](img/file443.png
    "x_{0}") and ![x_{2}](img/file444.png "x_{2}") are 0\. Thus, if we add a new binary
    slack variable ![y_{0}](img/file445.png "y_{0}") to that left-hand side and substitute
    ![\leq](img/file446.png "\leq") with ![=](img/file447.png "="), we have'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要将二进制线性规划写成QUBO形式，我们需要进行一些转换。第一个转换是将不等式约束转换为等式约束，通过添加**松弛变量**来实现。这可以通过一个例子来更好地理解。在先前的问题中，我们有两个约束：![x_{0}
    + x_{2} \leq 1](img/file441.png "x_{0} + x_{2} \leq 1") 和 ![3x_{0} - x_{1} + 3x_{2}
    \leq 4](img/file442.png "3x_{0} - x_{1} + 3x_{2} \leq 4")。在第一个约束中，左边表达式的最小值是 ![0](img/file12.png
    "0")，当 ![x_{0}](img/file443.png "x_{0}") 和 ![x_{2}](img/file444.png "x_{2}") 都为0时达到。因此，如果我们向那个左边表达式添加一个新的二进制松弛变量
    ![y_{0}](img/file445.png "y_{0}")，并用 ![\leq](img/file446.png "\leq") 替换为 ![=](img/file447.png
    "=")，我们就有
- en: '![x_{0} + x_{2} + y_{0} = 1,](img/file448.png "x_{0} + x_{2} + y_{0} = 1,")'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![x_{0} + x_{2} + y_{0} = 1,](img/file448.png "x_{0} + x_{2} + y_{0} = 1,")'
- en: which can be satisfied if and only if ![x_{0} + x_{2} \leq 1](img/file441.png
    "x_{0} + x_{2} \leq 1") can be satisfied. Indeed, if ![x_{0} = x_{2} = 0](img/file449.png
    "x_{0} = x_{2} = 0"), then we can take ![y_{0} = 1](img/file450.png "y_{0} = 1");
    and, if ![x_{0} = 0](img/file451.png "x_{0} = 0") and ![x_{2} = 1](img/file452.png
    "x_{2} = 1"), or ![x_{0} = 1](img/file453.png "x_{0} = 1") and ![x_{2} = 0](img/file454.png
    "x_{2} = 0"), we can take ![y_{0} = 0](img/file455.png "y_{0} = 0"). If ![x_{0}
    = x_{2} = 1](img/file456.png "x_{0} = x_{2} = 1"), it is not possible to satisfy
    the constraint. That’s why we can replace ![x_{0} + x_{2} \leq 1](img/file441.png
    "x_{0} + x_{2} \leq 1") with ![x_{0} + x_{2} + y_{0} = 1](img/file457.png "x_{0}
    + x_{2} + y_{0} = 1") without changing the set of feasible solutions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有在 ![x_{0} + x_{2} \leq 1](img/file441.png "x_{0} + x_{2} \leq 1") 可以满足的情况下才能成立。实际上，如果
    ![x_{0} = x_{2} = 0](img/file449.png "x_{0} = x_{2} = 0")，那么我们可以取 ![y_{0} = 1](img/file450.png
    "y_{0} = 1")；如果 ![x_{0} = 0](img/file451.png "x_{0} = 0") 和 ![x_{2} = 1](img/file452.png
    "x_{2} = 1")，或者 ![x_{0} = 1](img/file453.png "x_{0} = 1") 和 ![x_{2} = 0](img/file454.png
    "x_{2} = 0")，我们可以取 ![y_{0} = 0](img/file455.png "y_{0} = 0")。如果 ![x_{0} = x_{2}
    = 1](img/file456.png "x_{0} = x_{2} = 1")，则无法满足约束。这就是为什么我们可以用 ![x_{0} + x_{2}
    + y_{0} = 1](img/file457.png "x_{0} + x_{2} + y_{0} = 1") 替换 ![x_{0} + x_{2} \leq
    1](img/file441.png "x_{0} + x_{2} \leq 1")，而不改变可行解的集合。
- en: In the same way, the minimum value of ![3x_{0} - x_{1} + 3x_{2}](img/file458.png
    "3x_{0} - x_{1} + 3x_{2}") is ![- 1](img/file312.png "- 1"), and it is achieved
    when ![x_{0} = 0](img/file451.png "x_{0} = 0"), ![x_{1} = 1](img/file459.png "x_{1}
    = 1"), and ![x_{2} = 0](img/file454.png "x_{2} = 0").
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，![3x_{0} - x_{1} + 3x_{2}](img/file458.png "3x_{0} - x_{1} + 3x_{2}") 的最小值是
    ![- 1](img/file312.png "- 1")，并且当 ![x_{0} = 0](img/file451.png "x_{0} = 0")，![x_{1}
    = 1](img/file459.png "x_{1} = 1")，和 ![x_{2} = 0](img/file454.png "x_{2} = 0")
    时达到。
- en: Important note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice how the general rule to minimize these linear expressions on binary variables
    within some constraints is to set the variables with positive coefficients to
    ![0](img/file12.png "0") and those with negative coefficients to ![1](img/file13.png
    "1").
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某个约束条件下最小化二进制变量上的这些线性表达式的通用规则是将具有正系数的变量设置为 ![0](img/file12.png "0")，将具有负系数的变量设置为
    ![1](img/file13.png "1")。
- en: Then, in order for ![3x_{0} - x_{1} + 3x_{2}](img/file458.png "3x_{0} - x_{1}
    + 3x_{2}") to reach up to ![4](img/file143.png "4"), which is the right-hand side
    of the constraint, we may need to add a number as big as ![5](img/file296.png
    "5"). But to write non-negative numbers up to ![5](img/file296.png "5") we need
    only three bits, so we can add three new binary variables, ![y_{1}](img/file460.png
    "y_{1}"), ![y_{2}](img/file461.png "y_{2}"), and ![y_{3}](img/file462.png "y_{3}"),
    and consider ![3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 4y_{3} = 4,](img/file463.png
    "3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 4y_{3} = 4,")
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使 ![3x_{0} - x_{1} + 3x_{2}](img/file458.png "3x_{0} - x_{1} + 3x_{2}")
    达到 ![4](img/file143.png "4")，这是约束的右边，我们可能需要添加一个高达 ![5](img/file296.png "5") 的数。但是，为了表示高达
    ![5](img/file296.png "5") 的非负数，我们只需要三个比特位，因此我们可以添加三个新的二进制变量，![y_{1}](img/file460.png
    "y_{1}"), ![y_{2}](img/file461.png "y_{2}"), 和 ![y_{3}](img/file462.png "y_{3}")，并考虑
    ![3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 4y_{3} = 4,](img/file463.png "3x_{0}
    - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 4y_{3} = 4,")
- en: which can be satisfied if and only if ![3x_{0} - x_{1} + 3x_{2} \leq 4](img/file442.png
    "3x_{0} - x_{1} + 3x_{2} \leq 4") can be satisfied.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过满足![3x_{0} - x_{1} + 3x_{2} \leq 4](img/file442.png "3x_{0} - x_{1} + 3x_{2}
    \leq 4")来实现。
- en: To learn more…
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息…
- en: In fact, notice that ![y_{1} + 2y_{2} + 4y_{3}](img/file464.png "y_{1} + 2y_{2}
    + 4y_{3}") may go up to ![7](img/file465.png "7"), but we only need to go up to
    ![5](img/file296.png "5"). Thus, we could also use
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，请注意![y_{1} + 2y_{2} + 4y_{3}](img/file464.png "y_{1} + 2y_{2} + 4y_{3}")可能增加到![7](img/file465.png
    "7")，但我们只需要增加到![5](img/file296.png "5")。因此，我们也可以使用
- en: '![3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} = 4](img/file466.png "3x_{0}
    - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} = 4")'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} = 4](img/file466.png "3x_{0}
    - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} = 4")'
- en: as a replacement for ![3x_{0} - x_{1} + 3x_{2} \leq 4](img/file442.png "3x_{0}
    - x_{1} + 3x_{2} \leq 4").
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 作为![3x_{0} - x_{1} + 3x_{2} \leq 4](img/file442.png "3x_{0} - x_{1} + 3x_{2}
    \leq 4")的替代。
- en: 'Putting it all together, our original problem is equivalent to the following
    one:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们的原始问题等价于以下问题：
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} + y_{0} = 1,\qquad} &
    & \qquad \\ & {3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} = 4\qquad} &
    & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\ & {y_{j}
    \in \{ 0,1\},\qquad j = 0,1,2,3.\qquad} & & \qquad \\ \end{array}](img/file467.png
    "\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} + y_{0} = 1,\qquad} &
    & \qquad \\  & {3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} = 4\qquad} &
    & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\  & {y_{j}
    \in \{ 0,1\},\qquad j = 0,1,2,3.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} + y_{0} = 1,\qquad} &
    & \qquad \\ & {3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} = 4\qquad} &
    & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\ & {y_{j}
    \in \{ 0,1\},\qquad j = 0,1,2,3.\qquad} & & \qquad \\ \end{array}](img/file467.png
    "\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {x_{0} + x_{2} + y_{0} = 1,\qquad} &
    & \qquad \\  & {3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} = 4\qquad} &
    & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\  & {y_{j}
    \in \{ 0,1\},\qquad j = 0,1,2,3.\qquad} & & \qquad \\ \end{array}")'
- en: Now, we are ready to write the problem as a QUBO instance. The only thing that
    we need to do is to incorporate the constraints as **penalty terms** in the expression
    that we are trying to minimize. For that, we use an integer ![B](img/file184.png
    "B") (for which we will select a concrete value later on) and consider the problem
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将问题写成QUBO实例。我们唯一需要做的是将约束作为**惩罚项**纳入我们试图最小化的表达式中。为此，我们使用一个整数![B](img/file184.png
    "B")（稍后我们将选择一个具体的值）并考虑以下问题
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}
    + B{(x_{0} + x_{2} + y_{0} - 1)}^{2}\qquad} & & \qquad \\ & {+ B{(3x_{0} - x_{1}
    + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} - 4)}^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\ & {y_{j}, \in \{
    0,1\},\qquad j = 0,1,2,3,\qquad} & & \qquad \\ \end{array}](img/file468.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2} + B{(x_{0} + x_{2} + y_{0}
    - 1)}^{2}\qquad} & & \qquad \\  & {+ B{(3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2}
    + 2y_{3} - 4)}^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{j} \in
    \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\  & {y_{j}, \in \{ 0,1\},\qquad
    j = 0,1,2,3,\qquad} & & \qquad \\ \end{array}")'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}
    + B{(x_{0} + x_{2} + y_{0} - 1)}^{2}\qquad} & & \qquad \\ & {+ B{(3x_{0} - x_{1}
    + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} - 4)}^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\ & {y_{j}, \in \{
    0,1\},\qquad j = 0,1,2,3,\qquad} & & \qquad \\ \end{array}](img/file468.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2} + B{(x_{0} + x_{2} + y_{0}
    - 1)}^{2}\qquad} & & \qquad \\  & {+ B{(3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2}
    + 2y_{3} - 4)}^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{j} \in
    \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\  & {y_{j}, \in \{ 0,1\},\qquad
    j = 0,1,2,3,\qquad} & & \qquad \\ \end{array}")'
- en: which is already in QUBO form.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经处于QUBO形式。
- en: Since the new problem is unconstrained, we need to set ![B](img/file184.png
    "B") big enough so that violating the constraints does not *pay off* . If one
    of the original constraints is violated, the terms that are multiplied by ![B](img/file184.png
    "B") will be greater than ![0](img/file12.png "0"). Moreover, the expression that
    we wanted to minimize in the original formulation of the problem was ![- 5x_{0}
    + 3x_{1} - 2x_{2}](img/file469.png "- 5x_{0} + 3x_{1} - 2x_{2}"), which can reach
    a minimum value of ![- 7](img/file470.png "- 7") (when ![x_{0} = x_{2} = 1](img/file456.png
    "x_{0} = x_{2} = 1") and ![x_{1} = 0](img/file471.png "x_{1} = 0")) and a maximum
    value of ![3](img/file472.png "3") (when ![x_{0} = x_{2} = 0](img/file449.png
    "x_{0} = x_{2} = 0") and ![x_{1} = 1](img/file459.png "x_{1} = 1")). Thus, if
    we choose, for instance, ![B = 11](img/file473.png "B = 11"), any assignment that
    violates the constraints will achieve a value greater than at least ![4](img/file143.png
    "4") and will never be selected as the optimal solution to the QUBO problem if
    there is at least one feasible solution (which is the case for this particular
    problem).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新问题是无约束的，我们需要设置 ![B](img/file184.png "B") 足够大，以至于违反约束不会*带来收益*。如果其中一个原始约束被违反，乘以
    ![B](img/file184.png "B") 的项将大于 ![0](img/file12.png "0")。此外，我们在问题的原始公式中想要最小化的表达式是
    ![- 5x_{0} + 3x_{1} - 2x_{2}](img/file469.png "- 5x_{0} + 3x_{1} - 2x_{2}"), 它可以达到最小值
    ![- 7](img/file470.png "- 7")（当 ![x_{0} = x_{2} = 1](img/file456.png "x_{0} =
    x_{2} = 1") 和 ![x_{1} = 0](img/file471.png "x_{1} = 0"))，以及最大值 ![3](img/file472.png
    "3")（当 ![x_{0} = x_{2} = 0](img/file449.png "x_{0} = x_{2} = 0") 和 ![x_{1} = 1](img/file459.png
    "x_{1} = 1"))）。因此，如果我们选择，例如，![B = 11](img/file473.png "B = 11")，任何违反约束的分配都将得到至少大于
    ![4](img/file143.png "4") 的值，并且如果至少有一个可行解（对于这个特定问题来说就是这种情况），它永远不会被选为QUBO问题的最优解。
- en: 'In this way, a QUBO problem whose optimal solution is the same as the optimal
    solution of the original one is the following one:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，一个最优解与原始问题最优解相同的QUBO问题是以下这个：
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}
    + 11{(x_{0} + x_{2} + y_{0} - 1)}^{2}\qquad} & & \qquad \\ & {+ 11{(3x_{0} - x_{1}
    + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} - 4)}^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\ & {y_{j}, \in \{
    0,1\},\qquad j = 0,1,2,3.\qquad} & & \qquad \\ \end{array}](img/file474.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2} + 11{(x_{0} + x_{2} + y_{0}
    - 1)}^{2}\qquad} & & \qquad \\  & {+ 11{(3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2}
    + 2y_{3} - 4)}^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{j} \in
    \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\  & {y_{j}, \in \{ 0,1\},\qquad
    j = 0,1,2,3.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2}
    + 11{(x_{0} + x_{2} + y_{0} - 1)}^{2}\qquad} & & \qquad \\ & {+ 11{(3x_{0} - x_{1}
    + 3x_{2} + y_{1} + 2y_{2} + 2y_{3} - 4)}^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad}
    & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\ & {y_{j}, \in \{
    0,1\},\qquad j = 0,1,2,3.\qquad} & & \qquad \\ \end{array}](img/file474.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {- 5x_{0} + 3x_{1} - 2x_{2} + 11{(x_{0} + x_{2} + y_{0}
    - 1)}^{2}\qquad} & & \qquad \\  & {+ 11{(3x_{0} - x_{1} + 3x_{2} + y_{1} + 2y_{2}
    + 2y_{3} - 4)}^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{j} \in
    \{ 0,1\},\qquad j = 0,1,2,\qquad} & & \qquad \\  & {y_{j}, \in \{ 0,1\},\qquad
    j = 0,1,2,3.\qquad} & & \qquad \\ \end{array}")'
- en: If you expand the expression to minimize, you will obtain a quadratic polynomial
    in the ![x_{j}](img/file407.png "x_{j}") variables, exactly what we need in the
    QUBO formulation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将最小化表达式展开，你将得到一个关于 ![x_{j}](img/file407.png "x_{j}") 变量的二次多项式，这正是我们在QUBO公式中需要的。
- en: To learn more…
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息...
- en: '**Integer linear programming** is a generalization of binary linear programming
    in which non-negative integer variables are used instead of binary ones. In some
    instances of that kind of problem, the constraints allow us to deduce that the
    integer variables are bounded. For instance, if you have the constraint'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**整数线性规划**是二进制线性规划的一种推广，其中使用非负整数变量而不是二进制变量。在某些这类问题的实例中，约束允许我们推断出整数变量是有界的。例如，如果你有约束'
- en: '![2a_{0} + 3a_{1} \leq 10](img/file475.png "2a_{0} + 3a_{1} \leq 10")'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![2a_{0} + 3a_{1} \leq 10](img/file475.png "2a_{0} + 3a_{1} \leq 10")'
- en: then you can deduce that ![a_{0} \leq 5](img/file476.png "a_{0} \leq 5") and
    ![a_{1} \leq 3](img/file477.png "a_{1} \leq 3"). Since both ![a_{0}](img/file478.png
    "a_{0}") and ![a_{1}](img/file479.png "a_{1}") are non-negative, we can replace
    them with expressions in binary variables in the same way that we introduced slack
    variables for binary integer programs. In this case, for instance, we can replace
    ![a_{0}](img/file478.png "a_{0}") with ![x_{0} + 2x_{1} + 4x_{2}](img/file480.png
    "x_{0} + 2x_{1} + 4x_{2}") and ![a_{1}](img/file479.png "a_{1}") with ![x_{3}
    + 2x_{4}](img/file481.png "x_{3} + 2x_{4}"). In that manner, the integer linear
    program is transformed into an equivalent binary linear program that, in turn,
    can be written as a QUBO problem.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以推导出![a_{0} \leq 5](img/file476.png "a_{0} \leq 5")和![a_{1} \leq 3](img/file477.png
    "a_{1} \leq 3")。由于![a_{0}](img/file478.png "a_{0}")和![a_{1}](img/file479.png "a_{1}")都是非负的，我们可以用与为二进制整数规划引入松弛变量相同的方式，将它们替换为二进制变量的表达式。例如，我们可以将![a_{0}](img/file478.png
    "a_{0}")替换为![x_{0} + 2x_{1} + 4x_{2}](img/file480.png "x_{0} + 2x_{1} + 4x_{2}")，将![a_{1}](img/file479.png
    "a_{1}")替换为![x_{3} + 2x_{4}](img/file481.png "x_{3} + 2x_{4}")。这样，整数线性规划问题就转化为一个等价的二进制线性规划问题，进而可以写成QUBO问题。
- en: The procedure that we have studied in this section can be applied to transform
    any binary linear program into a QUBO problem. You only need to first introduce
    slack variables and then add penalty terms that substitute the original constraints.
    This is quite useful, since many important problems can be written directly as
    binary linear programs. In the next subsection, we will give a prominent example.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们研究的过程可以应用于将任何二进制线性规划问题转化为QUBO问题。你只需要首先引入松弛变量，然后添加惩罚项来替代原始约束。这非常有用，因为许多重要问题可以直接写成二进制线性规划形式。在下一个小节中，我们将给出一个突出的例子。
- en: 3.4.2 The Knapsack problem
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.2 背包问题
- en: In the famous **Knapsack problem**, you are given a list of objects ![j = 0,\ldots,m](img/file408.png
    "j = 0,\ldots,m"), each of them with a weight ![w_{j}](img/file482.png "w_{j}")
    and a value ![c_{j}](img/file438.png "c_{j}"). You are also given a maximum weight
    ![W](img/file483.png "W") and the goal is to find a collection of objects that
    maximizes the total value without going over the maximum weight allowed. Think
    of it as if you were going on a journey and you want to pack as many valuable
    objects as possible without getting a knapsack that is too heavy to carry.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在著名的**背包问题**中，你被给出一个对象列表![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m")，每个对象都有一个重量![w_{j}](img/file482.png
    "w_{j}")和一个价值![c_{j}](img/file438.png "c_{j}")。你还被给出一个最大重量![W](img/file483.png
    "W")，目标是找到一组对象，使得总价值最大化，同时不超过允许的最大重量。想象一下，如果你正在去旅行，你想要尽可能多地携带有价值的东西，但又不想背一个太重的背包。
- en: For instance, you can have objects with values ![c_{0} = 5](img/file484.png
    "c_{0} = 5"), ![c_{1} = 3](img/file485.png "c_{1} = 3"), and ![c_{2} = 4](img/file486.png
    "c_{2} = 4") and weights ![w_{0} = 3](img/file487.png "w_{0} = 3"), ![w_{1} =
    1](img/file488.png "w_{1} = 1"), and ![w_{2} = 1](img/file489.png "w_{2} = 1").
    If the maximum weight is ![4](img/file143.png "4"), then the optimal solution
    would be to choose objects ![0](img/file12.png "0") and ![2](img/file302.png "2")
    for a total value of ![9](img/file490.png "9"). However, that solution is unfeasible
    if the maximum weight is ![3](img/file472.png "3"). In that case, we should choose
    objects ![1](img/file13.png "1") and ![2](img/file302.png "2") to obtain a total
    value of ![7](img/file465.png "7").
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有价值为![c_{0} = 5](img/file484.png "c_{0} = 5")、![c_{1} = 3](img/file485.png
    "c_{1} = 3")和![c_{2} = 4](img/file486.png "c_{2} = 4")的对象，重量分别为![w_{0} = 3](img/file487.png
    "w_{0} = 3")、![w_{1} = 1](img/file488.png "w_{1} = 1")和![w_{2} = 1](img/file489.png
    "w_{2} = 1")。如果最大重量是![4](img/file143.png "4")，那么最优解将是选择对象![0](img/file12.png "0")和![2](img/file302.png
    "2")，总价值为![9](img/file490.png "9")。然而，如果最大重量是![3](img/file472.png "3")，那么这个解是不可行的。在这种情况下，我们应该选择对象![1](img/file13.png
    "1")和![2](img/file302.png "2")，以获得总价值为![7](img/file465.png "7")。
- en: Although, at first sight, this problem may seem easy to solve, the fact is that
    (surprise, surprise!) it is ![NP](img/file2.png "NP")-hard. In fact, if we consider
    a decision version of the problem in which we are also given a value ![V](img/file379.png
    "V") and we are asked if there is a selection of objects with a value of at least
    ![V](img/file379.png "V") that also satisfies the weight constraint, then the
    problem is ![NP](img/file2.png "NP")-complete.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看这个问题可能看起来容易解决，但事实是（惊讶，惊讶！）它是![NP](img/file2.png "NP")-难问题。实际上，如果我们考虑一个决策版本的问题，其中我们还给出了一个价值![V](img/file379.png
    "V")，并询问是否存在一组对象，其价值至少为![V](img/file379.png "V")，同时满足重量约束，那么这个问题是![NP](img/file2.png
    "NP")-完全的。
- en: To learn more…
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: Proving that the decision version of the Knapsack problem is ![NP](img/file2.png
    "NP")-complete is easy, because we already know that the Subset Sum problem is
    ![NP](img/file2.png "NP")-complete. Suppose, then, that you are given an instance
    of the Subset Sum problem with set ![S = \{ a_{0},\ldots,a_{m}\}](img/file406.png
    "S = \{ a_{0},\ldots,a_{m}\}") and target sum ![T](img/file74.png "T"). Then,
    you can recast this as an instance of the Knapsack problem by considering objects
    ![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m") with values ![c_{j} = a_{j}](img/file491.png
    "c_{j} = a_{j}") and weights ![w_{j} = a_{j}](img/file492.png "w_{j} = a_{j}"),
    maximum weight ![W = T](img/file493.png "W = T"), and minimum total value ![V
    = T](img/file494.png "V = T"). Then, a solution to the Knapsack decision problem
    will give you a selection of objects ![j_{0},\ldots,j_{k}](img/file495.png "j_{0},\ldots,j_{k}")
    such that ![a_{j_{0}} + \ldots + a_{j_{k}} \leq W = T](img/file496.png "a_{j_{0}}
    + \ldots + a_{j_{k}} \leq W = T") because of the weight constraint and such that
    ![a_{j_{0}} + \ldots + a_{j_{k}} \geq V = T](img/file497.png "a_{j_{0}} + \ldots
    + a_{j_{k}} \geq V = T") because of the minimum value condition. Obviously, that
    selection of objects would also be a solution to the Subset Sum problem.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 证明背包问题的决策版本是 ![NP](img/file2.png "NP")-完全的是容易的，因为我们已经知道子集和问题（Subset Sum problem）是
    ![NP](img/file2.png "NP")-完全的。假设，然后，你被给了一个子集和问题的实例，其集合为 ![S = \{ a_{0},\ldots,a_{m}\}](img/file406.png
    "S = \{ a_{0},\ldots,a_{m}\}")，目标总和为 ![T](img/file74.png "T")。然后，你可以通过考虑具有值 ![c_{j}
    = a_{j}](img/file491.png "c_{j} = a_{j}") 和重量 ![w_{j} = a_{j}](img/file492.png
    "w_{j} = a_{j}") 的对象 ![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m")，最大重量
    ![W = T](img/file493.png "W = T") 和最小总价值 ![V = T](img/file494.png "V = T")，将这个问题重新表述为一个背包问题的实例。然后，背包决策问题的解将给出对象的选择
    ![j_{0},\ldots,j_{k}](img/file495.png "j_{0},\ldots,j_{k}")，使得由于重量约束 ![a_{j_{0}}
    + \ldots + a_{j_{k}} \leq W = T](img/file496.png "a_{j_{0}} + \ldots + a_{j_{k}}
    \leq W = T")，并且由于最小价值条件 ![a_{j_{0}} + \ldots + a_{j_{k}} \geq V = T](img/file497.png
    "a_{j_{0}} + \ldots + a_{j_{k}} \geq V = T")。显然，这种对象的选择也将是子集和问题的解。
- en: It is straightforward to write the Knapsack problem as a binary linear program.
    We only need to define binary variables ![x_{j}](img/file407.png "x_{j}"), ![j
    = 0,\ldots,m](img/file408.png "j = 0,\ldots,m"), that indicate whether we choose
    object ![j](img/file258.png "j") (if ![x_{j} = 1](img/file498.png "x_{j} = 1"))
    or not (if ![x_{j} = 0](img/file499.png "x_{j} = 0")) and consider
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将背包问题写成二进制线性规划是直接的。我们只需要定义二进制变量 ![x_{j}](img/file407.png "x_{j}"), ![j = 0,\ldots,m](img/file408.png
    "j = 0,\ldots,m"), 它们表示我们是否选择对象 ![j](img/file258.png "j")（如果 ![x_{j} = 1](img/file498.png
    "x_{j} = 1")），或者不选择（如果 ![x_{j} = 0](img/file499.png "x_{j} = 0")）并考虑
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- c_{0}x_{0} - c_{1}x_{1} -
    \ldots - c_{m}x_{m}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {w_{0}x_{0}
    + w_{1}x_{1} + \ldots + w_{m}x_{m} \leq W,\qquad} & & \qquad \\ & {x_{j} \in \{
    0,1\},\qquad j = 0,\ldots,m,\qquad} & & \qquad \\ \end{array}](img/file500.png
    "\begin{array}{rlrl} {\text{Minimize}\quad} & {- c_{0}x_{0} - c_{1}x_{1} - \ldots
    - c_{m}x_{m}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {w_{0}x_{0} + w_{1}x_{1}
    + \ldots + w_{m}x_{m} \leq W,\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad
    j = 0,\ldots,m,\qquad} & & \qquad \\ \end{array}")'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- c_{0}x_{0} - c_{1}x_{1} -
    \ldots - c_{m}x_{m}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {w_{0}x_{0}
    + w_{1}x_{1} + \ldots + w_{m}x_{m} \leq W,\qquad} & & \qquad \\ & {x_{j} \in \{
    0,1\},\qquad j = 0,\ldots,m,\qquad} & & \qquad \\ \end{array}](img/file500.png
    "\begin{array}{rlrl} {\text{Minimize}\quad} & {- c_{0}x_{0} - c_{1}x_{1} - \ldots
    - c_{m}x_{m}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {w_{0}x_{0} + w_{1}x_{1}
    + \ldots + w_{m}x_{m} \leq W,\qquad} & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad
    j = 0,\ldots,m,\qquad} & & \qquad \\ \end{array}")'
- en: where ![c_{j}](img/file438.png "c_{j}") are the object values, ![w_{j}](img/file482.png
    "w_{j}") are their weights, and ![W](img/file483.png "W") is the maximum weight
    of the knapsack. Notice that, since the original problem was asking to maximize
    the value, we are now minimizing the negative value, which is completely equivalent.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![c_{j}](img/file438.png "c_{j}") 是对象值，![w_{j}](img/file482.png "w_{j}")
    是它们的重量，而 ![W](img/file483.png "W") 是背包的最大重量。请注意，由于原始问题要求最大化价值，我们现在最小化负价值，这是完全等价的。
- en: 'For instance, in the example that we considered previously with object values
    ![5,3](img/file501.png "5,3"), and ![4](img/file143.png "4"), weights ![3,1](img/file502.png
    "3,1"), and ![1](img/file13.png "1"), and maximum weight ![3](img/file472.png
    "3"), the problem would be the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们之前考虑的例子中，对象值为 ![5,3](img/file501.png "5,3") 和 ![4](img/file143.png "4")，重量为
    ![3,1](img/file502.png "3,1") 和 ![1](img/file13.png "1")，最大重量为 ![3](img/file472.png
    "3")，问题将是以下：
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} - 3x_{1} - 4x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {3x_{0} + x_{1} + x_{2} \leq 3,\qquad}
    & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}](img/file503.png
    "\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} - 3x_{1} - 4x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {3x_{0} + x_{1} + x_{2} \leq 3,\qquad}
    & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}")'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} - 3x_{1} - 4x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {3x_{0} + x_{1} + x_{2} \leq 3,\qquad}
    & & \qquad \\ & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}](img/file503.png
    "\begin{array}{rlrl} {\text{Minimize}\quad} & {- 5x_{0} - 3x_{1} - 4x_{2}\qquad}
    & & \qquad \\ {\text{subject~to}\quad} & {3x_{0} + x_{1} + x_{2} \leq 3,\qquad}
    & & \qquad \\  & {x_{j} \in \{ 0,1\},\qquad j = 0,1,2.\qquad} & & \qquad \\ \end{array}")'
- en: Of course, then we can add slack variables and introduce penalty terms, just
    as we did in the previous subsection, to rewrite the program as a QUBO problem.
    And that is exactly what we will need to do in order solve these problems with
    our quantum algorithms!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，然后我们可以添加松弛变量并引入惩罚项，就像我们在上一个子节中所做的那样，将程序重新编写为一个QUBO问题。这正是我们需要用我们的量子算法来解决这些问题的！
- en: Exercise 3.6
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.6
- en: Consider objects with values ![3,1,7,7](img/file504.png "3,1,7,7") and weights
    ![2,1,5,4](img/file505.png "2,1,5,4"). Write the Knapsack problem for the case
    in which the maximum weight is ![8](img/file506.png "8") as a binary linear program.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑具有值 ![3,1,7,7](img/file504.png "3,1,7,7") 和重量 ![2,1,5,4](img/file505.png "2,1,5,4")
    的对象。将最大重量为 ![8](img/file506.png "8") 的背包问题作为二进制线性程序编写。
- en: To learn more…
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多...
- en: A variant of the Knapsack problem allows us to choose several copies of the
    same object to put into the knapsack. In that case, we should use integer variables
    instead of binary ones to represent the number of times that each object is chosen.
    However, notice that, once we know the maximum weight allowed, each integer variable
    is bounded. Thus, we can use the technique that we explained at the end of the
    previous subsection in order to replace the integer variables with binary variables.
    And, afterwards, of course, we can rewrite the problem using the QUBO formalism.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 背包问题的变体允许我们选择多个相同的对象放入背包中。在这种情况下，我们应该使用整数变量而不是二进制变量来表示每个对象被选择的次数。然而，请注意，一旦我们知道允许的最大重量，每个整数变量都是有限的。因此，我们可以使用我们在上一个子节末尾解释的技术来用二进制变量替换整数变量。然后，当然，我们可以使用QUBO形式主义重新编写问题。
- en: For our next examples of optimization problems, we shall go back to working
    with graphs. In fact, in the next subsection, we will deal with a very colorful
    problem!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的优化问题示例中，我们将回到使用图的工作。实际上，在下一个小节中，我们将处理一个非常多彩的问题！
- en: 3.4.3 Graph coloring
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.3 图着色
- en: In this subsection and the next, we will study some problems that are related
    to graphs but have many applications in different fields. The first one is graph
    coloring, in which we are given a graph and we are asked to assign a color to
    each vertex in such a way that vertices that are connected by an edge (also called
    **adjacent** vertices) receive different colors. Usually, we are asked to do this
    using the minimum possible number of colors or using no more than a given number
    of different colors. If we can color a graph with ![k](img/file317.png "k") colors,
    we say that it is ![k](img/file317.png "k")**-colorable**. The minimum number
    of colors needed to color a graph is called its **chromatic** **number**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和下一节中，我们将研究一些与图相关但在不同领域有许多应用的问题。第一个是图着色，其中我们被给出一幅图，并被要求以这种方式为每个顶点分配一种颜色，即通过边的顶点（也称为**相邻**顶点）接收不同的颜色。通常，我们被要求使用尽可能少的颜色或使用不超过给定数量的不同颜色来完成这项任务。如果我们可以用
    ![k](img/file317.png "k") 种颜色着色一个图，我们说它是![k](img/file317.png "k")**-可着色**的。着色图所需的颜色最小数量称为其**色数**。
- en: In *Figure* *[*3.6*](#Figure3.6), we present three color assignments for the
    same graph. The one in *Figure* *[*3.6a*](#Figure3.6a) is not a valid coloring,
    because there are adjacent vertices that share the same color. The one in *Figure*
    *[*3.6b*](#Figure3.6b) is valid, but not optimal, because we do not need more
    than three colors for this graph, as *Figure* *[*3.6c*](#Figure3.6c) proves.****
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图* *[*3.6*](#Figure3.6) 中，我们展示了同一图的三个着色方案。*图* *[*3.6a*](#Figure3.6a) 不是一个有效的着色，因为存在相邻顶点共享相同颜色的情况。*图*
    *[*3.6b*](#Figure3.6b) 是有效的，但不是最优的，因为我们不需要超过三种颜色来着色这个图，正如 *图* *[*3.6c*](#Figure3.6c)
    所证明的那样。
- en: '**![(a) Invalid coloring](img/file507.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**![(a) 无效着色](img/file507.jpg)'
- en: '**(a)** Invalid coloring'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**(a)** 无效着色'
- en: '![(b) Non-optimal coloring](img/file508.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![(b) 非最优着色](img/file508.jpg)'
- en: '**(b)** Non-optimal coloring'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**(b)** 非最优着色'
- en: '![(c) Optimal coloring](img/file509.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![(c) 最优着色](img/file509.jpg)'
- en: '**(c)** Optimal coloring'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**(c)** 最优着色'
- en: '**Figure 3.6**: Different colorings of a graph'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.6**：图的不同的着色'
- en: The graph coloring problem may look like a children’s game. However, many very
    relevant practical problems can be written as instances of graph coloring. For
    example, imagine that your company has several projects and you need to assign
    supervisors to each of them, but some projects are incompatible because of time
    overlaps or other restrictions. You can create a graph in which the projects are
    the vertices and two projects are connected by an edge if and only if they are
    incompatible. Then, finding the chromatic number of the graph is equivalent to
    finding the minimum number of project leaders that you need to assign. Furthermore,
    finding a coloring will give you a way of assigning the supervisors while satisfying
    the constraints.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色问题可能看起来像是一个儿童游戏。然而，许多非常相关的实际问题都可以写成图着色的实例。例如，想象一下，如果你的公司有几个项目，你需要为每个项目分配监督者，但由于时间重叠或其他限制，有些项目是不兼容的。你可以创建一个图，其中项目是顶点，如果两个项目不兼容，则它们通过边连接。然后，找到图的色数就等同于找到你需要分配的最少项目领导人数。此外，找到一种着色方法将为你提供一种在满足约束条件的情况下分配监督者的方式。
- en: To learn more…
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息…
- en: 'The history of graph coloring dates back to the middle of the 19th century
    and it is full of surprising plot twists. It originated from a seemingly simple
    problem: finding the minimum number of colors needed in order to color a geographical
    map in such a way that any pair of neighboring countries receive different colors.
    But, in spite of its *humble* origins, it evolved to even become a philosophical
    debate about the validity of computer-assisted mathematical proofs!'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色的历史可以追溯到19世纪中叶，它充满了令人惊讶的情节转折。它起源于一个看似简单的问题：找到最少需要多少种颜色才能以这种方式着色地理地图，即任何相邻的两个国家都使用不同的颜色。尽管它的起源**谦逊**，但它甚至演变成了一场关于计算机辅助数学证明有效性的哲学辩论！
- en: A very enjoyable popular recounting of this long and winding process can be
    found in *Four Colors Suffice*, by Robin Wilson [[98](ch030.xhtml#Xwilson2021four)].
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在Robin Wilson的《四色足够了》[[98](ch030.xhtml#Xwilson2021four)]中，可以找到对这个漫长而曲折过程的非常有趣的通俗叙述。
- en: Deciding whether a graph is ![2](img/file302.png "2")-colorable or not is relatively
    easy. Indeed, notice that the vertices of a ![2](img/file302.png "2")-colorable
    graph can be assigned to two disjoint sets depending on the color they receive
    and such that there are no edges among vertices of the same set — that’s why these
    graphs are said to be **bipartite graphs**. But it is a well-known fact (originally
    proved by König in 1936) that a graph is bipartite if and only if it has no **cycles**
    of odd length (refer to *Section 1.6* in the book by Diestel [[31](ch030.xhtml#Xdiestel2017graph)])
    and we can check for the presence of cycles by, for instance, computing the powers
    of the adjacency matrix of the graph (cf. *Section 10.4.7* in Rosen’s book on
    discrete mathematics [[81](ch030.xhtml#Xrosen2019discrete)]). However, checking
    if a graph is ![k](img/file317.png "k")-colorable is ![NP](img/file2.png "NP")-complete
    for any ![k \geq 3](img/file510.png "k \geq 3") (see the paper by Garey, Johnson,
    and Stockmeyer [[43](ch030.xhtml#Xgarey1976simplified)]) and, thus, computing
    the chromatic number of a graph is ![NP](img/file2.png "NP")-hard.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 判断一个图是否是![2](img/file302.png "2")-可着色的相对简单。确实，请注意，![2](img/file302.png "2")-可着色图的顶点可以根据它们接收到的颜色分配到两个不相交的集合中，并且这些集合中的顶点之间没有边——这就是为什么这些图被称为**二分图**。但这是一个众所周知的事实（最初由König在1936年证明），一个图是二分图当且仅当它没有奇长**环**（参见Diestel的书中第1.6节[[31](ch030.xhtml#Xdiestel2017graph)]）。我们可以通过计算图的邻接矩阵的幂来检查是否存在环（参见Rosen关于离散数学的书中第10.4.7节[[81](ch030.xhtml#Xrosen2019discrete)]）。然而，对于任何![k
    \geq 3](img/file510.png "k \geq 3")，检查一个图是否是![k](img/file317.png "k")-可着色的都是![NP](img/file2.png
    "NP")-完全的（参见Garey、Johnson和Stockmeyer的论文[[43](ch030.xhtml#Xgarey1976simplified)]），因此，计算图的色数是![NP](img/file2.png
    "NP")-困难的。
- en: Suppose we have a graph with vertices ![0,\ldots,m](img/file511.png "0,\ldots,m").
    In order to write the problem of determining if a graph is ![k](img/file317.png
    "k")-colorable using the QUBO framework, we will define some binary variables
    ![x_{jl}](img/file512.png "x_{jl}") with ![j = 0,\ldots,m](img/file408.png "j
    = 0,\ldots,m") and ![l = 0,\ldots,k - 1](img/file513.png "l = 0,\ldots,k - 1").
    The variable ![x_{jl}](img/file512.png "x_{jl}") will get value ![1](img/file13.png
    "1") if the vertex ![j](img/file258.png "j") receives the ![l](img/file514.png
    "l")-th color (for simplicity, colors are usually identified with numbers) and
    ![0](img/file12.png "0") otherwise. Then, the condition that vertex ![j](img/file258.png
    "j") receives exactly one color can be algebraically written as
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个顶点为 ![0,\ldots,m](img/file511.png "0,\ldots,m") 的图。为了使用 QUBO 框架确定图是否是
    ![k](img/file317.png "k")-可着色的，我们将定义一些二进制变量 ![x_{jl}](img/file512.png "x_{jl}")，其中
    ![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m") 和 ![l = 0,\ldots,k - 1](img/file513.png
    "l = 0,\ldots,k - 1")。如果顶点 ![j](img/file258.png "j") 接收到 ![l](img/file514.png
    "l")-色（为了简单起见，颜色通常与数字相关联），则变量 ![x_{jl}](img/file512.png "x_{jl}") 将获得值 ![1](img/file13.png
    "1")，否则为 ![0](img/file12.png "0")。然后，顶点 ![j](img/file258.png "j") 接收到恰好一种颜色的条件可以代数地写成
- en: '![\sum\limits_{l = 0}^{k - 1}x_{jl} = 1.](img/file515.png "\sum\limits_{l =
    0}^{k - 1}x_{jl} = 1.")'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![\sum\limits_{l = 0}^{k - 1}x_{jl} = 1.](img/file515.png "\sum\limits_{l =
    0}^{k - 1}x_{jl} = 1.")'
- en: For this condition to hold, there must exist ![l](img/file514.png "l") such
    that ![x_{jl} = 1](img/file516.png "x_{jl} = 1") and such that ![x_{jh} = 0](img/file517.png
    "x_{jh} = 0") for any ![h \neq l](img/file518.png "h \neq l"), exactly as we need.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个条件成立，必须存在 ![l](img/file514.png "l") 使得 ![x_{jl} = 1](img/file516.png "x_{jl}
    = 1") 并且对于任何 ![h \neq l](img/file518.png "h \neq l")，![x_{jh} = 0](img/file517.png
    "x_{jh} = 0")，正好符合我们的需求。
- en: On the other hand, we need to impose the constraint that adjacent vertices are
    not assigned the same color. Notice that in the case that two vertices ![j](img/file258.png
    "j") and ![h](img/file519.png "h") receive the same color ![l](img/file514.png
    "l"), then we would have ![x_{jl}x_{hl} = 1](img/file520.png "x_{jl}x_{hl} = 1").
    Thus, for adjacent vertices ![j](img/file258.png "j") and ![h](img/file519.png
    "h") we need to impose
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们需要施加约束，使得相邻顶点不会被分配相同的颜色。注意，在两个顶点 ![j](img/file258.png "j") 和 ![h](img/file519.png
    "h") 接收到相同的颜色 ![l](img/file514.png "l") 的情况下，我们会有 ![x_{jl}x_{hl} = 1](img/file520.png
    "x_{jl}x_{hl} = 1")。因此，对于相邻顶点 ![j](img/file258.png "j") 和 ![h](img/file519.png
    "h")，我们需要施加
- en: '![\sum\limits_{l = 0}^{k - 1}x_{jl}x_{hl} = 0.](img/file521.png "\sum\limits_{l
    = 0}^{k - 1}x_{jl}x_{hl} = 0.")'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![\sum\limits_{l = 0}^{k - 1}x_{jl}x_{hl} = 0.](img/file521.png "\sum\limits_{l
    = 0}^{k - 1}x_{jl}x_{hl} = 0.")'
- en: We can write these constraints as penalty terms in the expression to minimize
    in our QUBO problem to get
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些约束作为我们在 QUBO 问题中要最小化的表达式的惩罚项来写
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {\sum\limits_{j = 0}^{m}\left(
    {\sum\limits_{l = 0}^{k - 1}x_{jl} - 1} \right)^{2} + \sum\limits_{(j,h) \in E}\sum\limits_{l
    = 0}^{k - 1}x_{jl}x_{hl}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{jl}
    \in \{ 0,1\},\qquad j = 0,\ldots,m,l = 0,\ldots,k - 1,\qquad} & & \qquad \\ \end{array}](img/file522.png
    "\begin{array}{rlrl} {\text{Minimize}\quad} & {\sum\limits_{j = 0}^{m}\left( {\sum\limits_{l
    = 0}^{k - 1}x_{jl} - 1} \right)^{2} + \sum\limits_{(j,h) \in E}\sum\limits_{l
    = 0}^{k - 1}x_{jl}x_{hl}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{jl}
    \in \{ 0,1\},\qquad j = 0,\ldots,m,l = 0,\ldots,k - 1,\qquad} & & \qquad \\ \end{array}")'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {\sum\limits_{j = 0}^{m}\left(
    {\sum\limits_{l = 0}^{k - 1}x_{jl} - 1} \right)^{2} + \sum\limits_{(j,h) \in E}\sum\limits_{l
    = 0}^{k - 1}x_{jl}x_{hl}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{jl}
    \in \{ 0,1\},\qquad j = 0,\ldots,m,l = 0,\ldots,k - 1,\qquad} & & \qquad \\ \end{array}](img/file522.png
    "\begin{array}{rlrl} {\text{Minimize}\quad} & {\sum\limits_{j = 0}^{m}\left( {\sum\limits_{l
    = 0}^{k - 1}x_{jl} - 1} \right)^{2} + \sum\limits_{(j,h) \in E}\sum\limits_{l
    = 0}^{k - 1}x_{jl}x_{hl}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{jl}
    \in \{ 0,1\},\qquad j = 0,\ldots,m,l = 0,\ldots,k - 1,\qquad} & & \qquad \\ \end{array}")'
- en: where ![E](img/file327.png "E") is the set of edges of the graph. Notice that
    we do not need to square the terms ![{\sum}_{l = 0}^{k - 1}x_{jl}x_{hl}](img/file523.png
    "{\sum}_{l = 0}^{k - 1}x_{jl}x_{hl}") because they are always non-negative. If
    we find that the optimal solution of the problem is ![0](img/file12.png "0"),
    then the graph is ![k](img/file317.png "k")-colorable. Otherwise, it is not.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![E](img/file327.png "E") 是图的边集。注意，我们不需要对项 ![{\sum}_{l = 0}^{k - 1}x_{jl}x_{hl}](img/file523.png
    "{\sum}_{l = 0}^{k - 1}x_{jl}x_{hl}") 进行平方，因为它们总是非负的。如果我们发现问题的最优解是 ![0](img/file12.png
    "0")，那么图是 ![k](img/file317.png "k")-可着色的。否则，它不是。
- en: Exercise 3.7
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.7
- en: Consider a graph with vertices ![0,1,2](img/file524.png "0,1,2"), and ![3](img/file472.png
    "3"), and edges ![(0,1)](img/file305.png "(0,1)"), ![(0,2)](img/file306.png "(0,2)"),
    ![(1,3)](img/file525.png "(1,3)"), and ![(2,3)](img/file526.png "(2,3)"). Write
    the QUBO version of the problem of checking whether the graph is ![2](img/file302.png
    "2")-colorable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个有顶点![0,1,2](img/file524.png "0,1,2")和![3](img/file472.png "3")，以及边 ![(0,1)](img/file305.png
    "(0,1)"), ![(0,2)](img/file306.png "(0,2)"), ![(1,3)](img/file525.png "(1,3)"),
    和 ![(2,3)](img/file526.png "(2,3)") 的图。写出检查图是否![2](img/file302.png "2")-可着色的QUBO版本的问题。
- en: In the next subsection, we will study another optimization problem on graphs.
    Do you like traveling? Then, prepare yourself to optimize your travel plans with
    the help of QUBO formalism.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将研究图上的另一个优化问题。你喜欢旅行吗？那么，准备好利用QUBO形式化方法来优化你的旅行计划。
- en: 3.4.4 The Traveling Salesperson Problem
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.4 旅行商问题
- en: 'The **Traveling Salesperson Problem** (or, simply, **TSP**) is one of the most
    famous problems in combinatorial optimization. The goal of the problem is very
    simple to state: you need to find a route that goes through each of the cities
    in a given set once and only once while minimizing some global quantity (distance
    traveled, time spent, total cost...).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**旅行商问题**（或简称**TSP**）是组合优化中最著名的问题之一。问题的目标非常简单：你需要找到一个路线，通过给定集合中的每个城市一次且仅一次，同时最小化某个全局量（行驶距离、花费时间、总成本等）。'
- en: We can formulate the problem mathematically using graphs. In this formulation,
    we would be given a set of vertices ![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m")
    representing the cities, and, for each pair of vertices ![j](img/file258.png "j")
    and ![l](img/file514.png "l"), we would also be given the cost ![w_{jl}](img/file527.png
    "w_{jl}") of traveling from ![j](img/file258.png "j") to ![l](img/file514.png
    "l") (this cost does not need to be the same, in general, as ![w_{lj}](img/file528.png
    "w_{lj}")). We then need to find a **path** in the graph (that is, a set of edges
    such that the end of an edge is the beginning of the next one) that visits each
    vertex once and only once and that minimizes the sum of the costs of all the edges
    used.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用图来数学地表述这个问题。在这个表述中，我们将被给出一个由![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m")表示的城市集合的顶点集，并且对于每对顶点![j](img/file258.png
    "j")和![l](img/file514.png "l")，我们也会被给出从![j](img/file258.png "j")到![l](img/file514.png
    "l")的旅行成本![w_{jl}](img/file527.png "w_{jl}")（这个成本在一般情况下不需要与![w_{lj}](img/file528.png
    "w_{lj}")相同）。然后我们需要在图中找到一个**路径**（即一组边，其中一条边的终点是下一条边的起点）访问每个顶点一次，并且只访问一次，并且使所有边的成本总和最小化。
- en: To learn more…
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: As you have probably guessed, the TSP is ![NP](img/file2.png "NP")-hard (refer
    to *Chapter 15* in the book on combinatorial optimization by Korte and Vygen [[61](ch030.xhtml#Xkorte2012combinatorial)]
    for more details). In fact, given a graph, a set of costs for the edges and a
    value ![C](img/file234.png "C"), it is ![NP](img/file2.png "NP")-complete to decide
    whether there is a path that visits all the cities and has a cost less than or
    equal to ![C](img/file234.png "C").
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，TSP是![NP](img/file2.png "NP")-难（有关更多详细信息，请参阅Korte和Vygen的关于组合优化的书籍的第15章
    [[61](ch030.xhtml#Xkorte2012combinatorial)]）。事实上，给定一个图、边的成本集合和一个值![C](img/file234.png
    "C")，判断是否存在一条访问所有城市且成本小于或等于![C](img/file234.png "C")的路径是![NP](img/file2.png "NP")-完全的。
- en: For instance, in *Figure* *[*3.7*](#Figure3.7) we can see a TSP instance with
    four cities. The numbers that appear to label the edges are their costs. For simplicity,
    we have assumed that for every pair of vertices, the travel cost is, in this case,
    the same in both directions.*
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在*图* *[*3.7*](#Figure3.7)中，我们可以看到一个有四个城市的TSP实例。出现在标签边的数字是它们的成本。为了简化，我们假设对于每对顶点，在这个例子中，旅行成本在两个方向上都是相同的。
- en: '*![Figure 3.7: An example of the Traveling Salesperson Problem](img/file529.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*![图3.7：旅行商问题的示例](img/file529.jpg)*'
- en: '**Figure 3.7**: An example of the Traveling Salesperson Problem'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.7**：旅行商问题的示例'
- en: To formulate the TSP in the QUBO framework, we will define binary variables
    ![x_{jl}](img/file512.png "x_{jl}") that will indicate the order of visiting the
    different vertices. More concretely, if vertex ![j](img/file258.png "j") is the
    ![l](img/file514.png "l")-th in the tour, then ![x_{jl}](img/file512.png "x_{jl}")
    will be ![1](img/file13.png "1") and ![x_{jh}](img/file530.png "x_{jh}") will
    be ![0](img/file12.png "0") for ![h \neq l](img/file518.png "h \neq l"). Thus,
    for every vertex ![j](img/file258.png "j"), we need to impose the constraint
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在QUBO框架中表述TSP问题，我们将定义二进制变量![x_{jl}](img/file512.png "x_{jl}")，以指示访问不同顶点的顺序。更具体地说，如果顶点![j](img/file258.png
    "j")是旅行中的![l](img/file514.png "l")-th个，则![x_{jl}](img/file512.png "x_{jl}")将为![1](img/file13.png
    "1")，而![x_{jh}](img/file530.png "x_{jh}")将为![0](img/file12.png "0")，对于![h \neq
    l](img/file518.png "h \neq l")。因此，对于每个顶点![j](img/file258.png "j")，我们需要施加以下约束
- en: '![\sum\limits_{l = 0}^{m}x_{jl} = 1,](img/file531.png "\sum\limits_{l = 0}^{m}x_{jl}
    = 1,")'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![\sum\limits_{l = 0}^{m}x_{jl} = 1,](img/file531.png "\sum\limits_{l = 0}^{m}x_{jl}
    = 1,")'
- en: because every vertex needs to be visited exactly once. But we also need to impose
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个顶点都需要恰好访问一次。但我们还需要施加
- en: '![\sum\limits_{j = 0}^{m}x_{jl} = 1](img/file532.png "\sum\limits_{j = 0}^{m}x_{jl}
    = 1")'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![\sum\limits_{j = 0}^{m}x_{jl} = 1](img/file532.png "\sum\limits_{j = 0}^{m}x_{jl}
    = 1")'
- en: for every position ![l](img/file514.png "l"), because we can only visit one
    city at a time.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个位置![l](img/file514.png "l")，因为我们一次只能访问一个城市。
- en: If those two constraints are met, we will have a path that visits every vertex
    once and only once. However, that is not enough. We also want to minimize the
    total cost of the path, so we need an expression that gives us that cost in terms
    of the ![x_{jl}](img/file512.png "x_{jl}") variables. Notice that an edge ![(j,k)](img/file356.png
    "(j,k)") is used if and only if the vertices ![j](img/file258.png "j") and ![k](img/file317.png
    "k") are consecutive in the path. That is, if and only if there exists an ![l](img/file514.png
    "l") such that ![j](img/file258.png "j") is visited in position ![l](img/file514.png
    "l") and ![k](img/file317.png "k") is visited in position ![l + 1](img/file533.png
    "l + 1"). In that case, the cost of using the edge will be given by ![w_{jk}x_{jl}x_{kl
    + 1}](img/file534.png "w_{jk}x_{jl}x_{kl + 1}"), because ![x_{jl}x_{kl + 1} =
    1](img/file535.png "x_{jl}x_{kl + 1} = 1"). But if ![j](img/file258.png "j") and
    ![k](img/file317.png "k") are not consecutive in the path, then ![x_{jl}x_{kl
    + 1} = 0](img/file536.png "x_{jl}x_{kl + 1} = 0") for every ![l](img/file514.png
    "l"), which is also the cost of that path in our route — we are not using it,
    so we don’t pay for it!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足这两个约束条件，我们将得到一条访问每个顶点一次且仅一次的路径。然而，这还不够。我们还想最小化路径的总成本，因此我们需要一个表达式，用![x_{jl}](img/file512.png
    "x_{jl}")变量来表示这个成本。请注意，如果顶点![j](img/file258.png "j")和![k](img/file317.png "k")在路径中是连续的，则使用边![j](img/file258.png
    "j")和![k](img/file317.png "k")。也就是说，如果且仅存在一个![l](img/file514.png "l")，使得![j](img/file258.png
    "j")在位置![l](img/file514.png "l")被访问，而![k](img/file317.png "k")在位置![l + 1](img/file533.png
    "l + 1")被访问。在这种情况下，使用该边的成本将由![w_{jk}x_{jl}x_{kl + 1}](img/file534.png "w_{jk}x_{jl}x_{kl
    + 1}")给出，因为![x_{jl}x_{kl + 1} = 1](img/file535.png "x_{jl}x_{kl + 1} = 1")。但如果![j](img/file258.png
    "j")和![k](img/file317.png "k")在路径中不是连续的，那么对于每个![l](img/file514.png "l")，![x_{jl}x_{kl
    + 1} = 0](img/file536.png "x_{jl}x_{kl + 1} = 0")，这也是我们路线中该路径的成本——我们没有使用它，所以不需要为此付费！
- en: Thus, the total cost of the tour is given by
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，旅行的总成本由以下给出
- en: '![\sum\limits_{l = 0}^{m - 1}\sum\limits_{j = 0}^{m}\sum\limits_{k = 0}^{m}w_{jk}x_{jl}x_{kl
    + 1},](img/file537.png "\sum\limits_{l = 0}^{m - 1}\sum\limits_{j = 0}^{m}\sum\limits_{k
    = 0}^{m}w_{jk}x_{jl}x_{kl + 1},")'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![\sum\limits_{l = 0}^{m - 1}\sum\limits_{j = 0}^{m}\sum\limits_{k = 0}^{m}w_{jk}x_{jl}x_{kl
    + 1},](img/file537.png "\sum\limits_{l = 0}^{m - 1}\sum\limits_{j = 0}^{m}\sum\limits_{k
    = 0}^{m}w_{jk}x_{jl}x_{kl + 1},")'
- en: where we are assuming that ![w_{jj} = 0](img/file538.png "w_{jj} = 0") for ![j
    = 0,\ldots,m](img/file408.png "j = 0,\ldots,m") — staying in the same place costs
    nothing!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 其中我们假设对于![j = 0,\ldots,m](img/file408.png "j = 0,\ldots,m")，![w_{jj} = 0](img/file538.png
    "w_{jj} = 0")——停留在同一个地方不需要付费！
- en: Then, we can incorporate the constraints as penalty terms in the function to
    minimize and write the TSP problem as
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将约束作为惩罚项纳入最小化函数，并将TSP问题表述为
- en: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {\sum\limits_{l = 0}^{m - 1}\sum\limits_{j
    = 0}^{m}\sum\limits_{k = 0}^{m}w_{jk}x_{jl}x_{kl + 1} + B\left( {\sum\limits_{l
    = 0}^{m}x_{jl} - 1} \right)^{2} + B\left( {\sum\limits_{j = 0}^{m}x_{jl} - 1}
    \right)^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{jl} \in \{ 0,1\},\qquad
    j,l = 0,\ldots,m,\qquad} & & \qquad \\ \end{array}](img/file539.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {\sum\limits_{l = 0}^{m - 1}\sum\limits_{j = 0}^{m}\sum\limits_{k
    = 0}^{m}w_{jk}x_{jl}x_{kl + 1} + B\left( {\sum\limits_{l = 0}^{m}x_{jl} - 1} \right)^{2}
    + B\left( {\sum\limits_{j = 0}^{m}x_{jl} - 1} \right)^{2}\qquad} & & \qquad \\
    {\text{subject~to}\quad} & {x_{jl} \in \{ 0,1\},\qquad j,l = 0,\ldots,m,\qquad}
    & & \qquad \\ \end{array}")'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![\begin{array}{rlrl} {\text{Minimize}\quad} & {\sum\limits_{l = 0}^{m - 1}\sum\limits_{j
    = 0}^{m}\sum\limits_{k = 0}^{m}w_{jk}x_{jl}x_{kl + 1} + B\left( {\sum\limits_{l
    = 0}^{m}x_{jl} - 1} \right)^{2} + B\left( {\sum\limits_{j = 0}^{m}x_{jl} - 1}
    \right)^{2}\qquad} & & \qquad \\ {\text{subject~to}\quad} & {x_{jl} \in \{ 0,1\},\qquad
    j,l = 0,\ldots,m,\qquad} & & \qquad \\ \end{array}](img/file539.png "\begin{array}{rlrl}
    {\text{Minimize}\quad} & {\sum\limits_{l = 0}^{m - 1}\sum\limits_{j = 0}^{m}\sum\limits_{k
    = 0}^{m}w_{jk}x_{jl}x_{kl + 1} + B\left( {\sum\limits_{l = 0}^{m}x_{jl} - 1} \right)^{2}
    + B\left( {\sum\limits_{j = 0}^{m}x_{jl} - 1} \right)^{2}\qquad} & & \qquad \\
    {\text{subject~to}\quad} & {x_{jl} \in \{ 0,1\},\qquad j,l = 0,\ldots,m,\qquad}
    & & \qquad \\ \end{array}")'
- en: where ![B](img/file184.png "B") is chosen so that unfeasible solutions never
    achieve an optimal value. For instance, if we select
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![B](img/file184.png "B") 被选择，以确保不可行解永远不会达到最优值。例如，如果我们选择
- en: '![B = 1 + \sum\limits_{j,k = 0}^{m}w_{jk},](img/file540.png "B = 1 + \sum\limits_{j,k
    = 0}^{m}w_{jk},")'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![B = 1 + \sum\limits_{j,k = 0}^{m}w_{jk},](img/file540.png "B = 1 + \sum\limits_{j,k
    = 0}^{m}w_{jk},")'
- en: then those solutions that violate the constraints will get a penalty that is
    bigger than the cost of any valid tour and will not be selected as optimal.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 那些违反约束条件的解决方案将获得一个比任何有效旅行路线成本更大的惩罚，并且不会被选为最优解。
- en: Exercise 3.8
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 3.8
- en: Obtain the expression for the route cost in the TSP problem with the graph in
    *Figure* *[*3.7*](#Figure3.7).*
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图* *[*3.7*](#Figure3.7) 中，获取 TSP 问题中路线成本的公式。
- en: '*We have shown how to formulate several important problems in the QUBO formalism.
    But the ones that we have focused on are not, by any means, the only ones that
    these techniques can address. In the next subsection, we will give you a couple
    of hints of where to look for more.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们已经展示了如何使用 QUBO 公式来构建几个重要的问题。但我们所关注的这些问题绝不是这些技术可以解决的唯一问题。在下一小节中，我们将给出一些寻找更多问题的提示。'
- en: 3.4.5 Other problems and other formulations
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4.5 其他问题和其他公式
- en: In this chapter, we have introduced the Ising and QUBO models and we have shown
    how to use them to formulate combinatorial optimization problems. In fact, in
    the last part of the chapter, we have studied several famous problems, including
    binary linear programming and the Traveling Salesperson Problem, and we have given
    QUBO formulations for them.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了伊辛模型和 QUBO 模型，并展示了如何使用它们来构建组合优化问题。实际上，在本章的最后部分，我们研究了几个著名的问题，包括二进制线性规划和旅行商问题，并给出了它们的
    QUBO 公式。
- en: The possibility of using these frameworks to formulate optimization problems
    is not reduced to the examples that we have worked with. Other important problems
    that can be readily written as QUBO and Ising instances include finding cliques
    in graphs, determining whether a logic formula is satisfiable, and scheduling
    jobs under constraints. Using the techniques described in this chapter, you are
    now equipped to write your own formulations for these and other problems.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些框架来构建优化问题的可能性并不局限于我们所工作的例子。其他可以轻松写成 QUBO 和伊辛实例的重要问题包括在图中寻找团、确定逻辑公式是否可满足以及在约束条件下安排工作。使用本章中描述的技术，你现在可以为自己的这些问题和其他问题编写自己的公式。
- en: However, it is useful to have some references to problems that have already
    been formulated as QUBO instances to be used out of the box or to serve as inspiration
    if your problem doesn’t exactly fit any of them. A good survey of such formulations
    is the one compiled by Lucas [[65](ch030.xhtml#Xlucas2014ising)], which includes
    all 21 of Karp’s ![NP](img/file2.png "NP")-complete problems and more.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些已经作为 QUBO 实例构建的问题的参考文献是有用的，这些可以即插即用或作为你问题不符合其中任何一个时的灵感来源。这类公式的良好综述是 Lucas
    编制的 [[65](ch030.xhtml#Xlucas2014ising)]，它包括了 Karp 的所有 21 个 ![NP](img/file2.png
    "NP")-完全问题以及更多。
- en: An important thing that you should always keep in mind when using the QUBO framework
    is that, usually, there is more than just one way of formulating a problem. For
    example, sometimes it is straightforward to state a problem as a binary linear
    program and then use the transformations that we have studied to obtain a QUBO
    and, eventually, an Ising version of the problem. Nevertheless, it could be possible
    that with a different approach, you may find a more compact formulation that reduces,
    for instance, the number of variables or the length of the expression to minimize.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用QUBO框架时，你应该始终牢记的一个重要事情是，通常，解决问题的方式不止一种。例如，有时直接将问题表述为二元线性规划，然后使用我们研究过的转换方法来获得QUBO，最终得到问题的伊辛版本，这是很直接的。然而，也可能存在不同的方法，你可能会发现一个更紧凑的表述，例如减少变量的数量或最小化表达式的长度。
- en: In recent years, the comparison of alternative QUBO formulations of important
    combinatorial optimization problems has become a very active research area. It
    is good advice to keep an open mind (and an eye on the scientific literature)
    because, in many cases, choosing the right formulation can be a crucial factor
    to obtain better results when using quantum computers to solve optimization problems.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，对重要的组合优化问题的替代QUBO表述的比较已成为一个非常活跃的研究领域。保持开放的心态（并关注科学文献）是很好的建议，因为在许多情况下，选择正确的表述可能是获得更好结果的关键因素，尤其是在使用量子计算机解决优化问题时。
- en: To learn more…
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: A recent paper by Salehi, Glos, and Miszczak [[83](ch030.xhtml#Xsalehi2022unconstrained)]
    addresses the task of representing the TSP and some of its variants with QUBO
    formalism and studies how different formulations can affect the performance of
    quantum optimization algorithms.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Salehi、Glos和Miszczak最近的一篇论文[[83](ch030.xhtml#Xsalehi2022unconstrained)]探讨了使用QUBO形式化表示TSP及其一些变体，并研究了不同的表述如何影响量子优化算法的性能。
- en: Our next stop will be using actual quantum devices to solve the type of problem
    that we have been focusing on in this chapter. Get ready to learn how to use quantum
    annealers!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的目标将是使用实际的量子设备来解决本章所关注的类型的问题。准备好学习如何使用量子退火器！
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been devoted to introducing two different mathematical frameworks,
    the Ising model and the QUBO formalism, which allow us to write combinatorial
    optimization problems in a way that we will later be able to use to find approximate
    solutions with the help of quantum computers. We started with some simple examples
    and worked our way up to some famous problems such as graph coloring and the Traveling
    Salesperson Problem.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于介绍两种不同的数学框架，即伊辛模型和QUBO形式化，这使得我们能够以我们稍后能够使用量子计算机帮助找到近似解的方式编写组合优化问题。我们从一些简单的例子开始，逐步过渡到一些著名的问题，如图着色和旅行商问题。
- en: In order to achieve that, we studied different techniques that find wider applications
    in the process of writing optimization problems for quantum computers. We saw,
    for example, how to use slack variables and how to replace constraints with penalty
    terms. We also learned how to transform integer variables into a series of binary
    ones.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们研究了在不同过程中编写量子计算机优化问题的不同技术。例如，我们看到了如何使用松弛变量，以及如何用惩罚项替换约束。我们还学习了如何将整数变量转换为一系列二进制变量。
- en: After all that we have covered in this chapter, you are now prepared to write
    your own problems in the languages required by optimization algorithms that can
    run on quantum computers. The rest of the chapters in this part of the book will
    be devoted to learning how to implement and run those quantum optimization algorithms.
    In fact, in the next chapter, we will explain how to use a type of quantum computer
    called a **quantum annealer** to solve QUBO and Ising problems.*****************************************
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章所涵盖的所有内容之后，你现在已经准备好用可以在量子计算机上运行的优化算法所要求的语言编写自己的问题。本书本部分的其余章节将致力于学习如何实现和运行这些量子优化算法。实际上，在下一章中，我们将解释如何使用一种称为**量子退火器**的量子计算机类型来解决QUBO和伊辛问题。*****************************************
