- en: Creating Our First Julia App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Julia 应用程序
- en: Now that you have a working Julia installation and your IDE of choice is ready
    to run, it's time to put them to some good use. In this chapter, you'll learn
    how to apply Julia for data analysis—a domain that is central to the language,
    so expect to be impressed!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了有效的 Julia 环境，并且您选择的 IDE 已经准备好运行，是时候将它们用于一些有用的任务了。在本章中，您将学习如何将 Julia
    应用于数据分析——这是一个语言的核心领域，因此请期待给您留下深刻印象！
- en: We will learn to perform exploratory data analysis with Julia. In the process,
    we'll take a look at `RDatasets`, a package that provides access to over 700 learning
    datasets. We'll load one of them, the Iris flowers dataset, and we'll manipulate
    it using standard data analysis functions. Then we'll look more closely at the
    data by employing common visualization techniques. And finally, we'll see how
    to persist and (re)load our data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用 Julia 进行探索性数据分析。在这个过程中，我们将查看 `RDatasets`，这是一个提供超过 700 个学习数据集访问权限的包。我们将加载其中一个，即
    Iris 花卉数据集，并使用标准数据分析函数对其进行操作。然后，我们将通过采用常见的可视化技术更仔细地查看数据。最后，我们将了解如何持久化和（重新）加载数据。
- en: But, in order to do that, first we need to take a look at some of the language's
    most important building blocks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了做到这一点，我们首先需要查看语言的一些最重要的构建块。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Declaring variables (and constants)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明变量（和常量）
- en: Working with `Strings` of characters and `regular expressions`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理字符 `Strings` 和正则表达式
- en: Numbers and numeric types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字和数值类型
- en: Our first Julia data structures—`Tuple`, `Range`, and `Array`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一种 Julia 数据结构——`Tuple`、`Range` 和 `Array`
- en: '`*` Exploratory data analysis using the Iris flower dataset—`RDatasets` and
    core `Statistics`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 使用 Iris 花卉数据集进行探索性数据分析——`RDatasets` 和核心 `Statistics`'
- en: Quick data visualization with `Gadfly`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Gadfly` 快速进行数据可视化
- en: '`*` Saving and loading tabular data with `CSV` and `Feather`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 使用 `CSV` 和 `Feather` 保存和加载数据表'
- en: Interacting with MongoDB databases
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 MongoDB 数据库交互
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的包生态系统正在不断发展，并且每天都有新的包版本发布。大多数时候这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍在测试版（版本
    0.x）中，任何新版本都可能引入破坏性更改。因此，书中展示的代码可能无法正常工作。为了确保您的代码将产生与书中描述相同的结果，建议使用相同的包版本。以下是本章中使用的外部包及其特定版本：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，您需要运行：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the `Project.toml`
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过下载章节中提供的 `Project.toml` 文件，并使用 `pkg>` 实例化以下命令来安装所有使用的包：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining variables
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义变量
- en: We have seen in the previous chapter how to use the REPL in order to execute
    computations and have the result displayed back to us. Julia even lends a helping
    hand by setting up the `ans` variable, which automatically holds the last computed
    value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中看到，如何使用 REPL 来执行计算并将结果显示给我们。Julia 甚至通过设置 `ans` 变量来提供帮助，该变量自动保存最后一个计算值。
- en: But, if we want to write anything but the most trivial programs, we need to
    learn how to define variables ourselves. In Julia, a variable is simply a name
    associated to a value. There are very few restrictions for naming variables, and
    the names themselves have no semantic meaning (the language will not treat variables
    differently based on their names, unlike say Ruby, where a name that is all caps
    is treated as a constant).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想编写除了最简单的程序之外的内容，我们需要学习如何自己定义变量。在 Julia 中，变量只是一个与值相关联的名称。对变量命名有非常少的限制，并且名称本身没有语义意义（与
    Ruby 不同，Ruby 中所有大写的名称被视为常量，语言会根据名称的不同对待变量）。
- en: 'Let''s see some examples:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can follow along through the examples in the chapter by loading the accompanying
    Jupyter/IJulia notebook provided with this chapter's support files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过加载本章支持文件中提供的配套Jupyter/IJulia笔记本来跟随本章中的示例。
- en: 'The variables, names are case-sensitive, meaning that `ANSWER` and `answer`
    (and `Answer` and `aNsWeR`) are completely different things:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的名称是区分大小写的，这意味着`ANSWER`和`answer`（以及`Answer`和`aNsWeR`）是完全不同的：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unicode names (UTF-8-encoded) are also accepted as variables names:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也接受Unicode名称（UTF-8编码）作为变量名称：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember that you can type many Unicode math symbols by typing backslash (`\`)
    then the name of the symbol and then the *Tab* key. For example, \pi[*Tab*] will
    output π.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以通过输入反斜杠（`\`）然后输入符号的名称，然后按*Tab*键来输入许多Unicode数学符号。例如，\pi[*Tab*]将输出π。
- en: 'Emojis also work, if your terminal supports them:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的终端支持，表情符号也可以使用：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The only explicitly disallowed names for variables are the names of built-in
    Julia statements (`do`, `end`, `try`, `catch`, `if`, and `else`, plus a few more):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的唯一明确禁止的名称是内置Julia语句的名称（`do`、`end`、`try`、`catch`、`if`和`else`，以及一些其他名称）：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Attempting to access a variable that hasn''t been defined will result in an
    error:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试访问未定义的变量将导致错误：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's true that the language does not impose many restrictions, but a set of
    code style conventions is always useful—and even more so for an open source language.
    The Julia community has distilled a set of best practices for writing code. In
    regard to naming variables, the names should be lowercase and in just one word;
    word separation can be done with underscores (`_`), but only if the name would
    be difficult to read without them. For example, `myvar` versus `total_length_horizontal`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这种语言没有强加很多限制，但一套代码风格约定总是有用的——对于一个开源语言来说更是如此。Julia社区已经提炼了一套编写代码的最佳实践。在变量命名方面，名称应该是小写并且只包含一个单词；单词分隔可以使用下划线（`_`），但只有当没有它们名称难以阅读时才使用。例如，`myvar`与`total_length_horizontal`。
- en: Given that the degree of difficulty in reading a name is a subjective thing,
    I'm a bit split about this naming style. I normally prefer the crystal-clear clarity
    of separating at word boundaries. But nevertheless, it is better to follow the
    recommendation, given that function names in the Julia API adhere to it. By adhering
    to the same conventions, your code will be consistent throughout.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于读取名称的难度是一个主观问题，我对这种命名风格有点犹豫。我通常更喜欢在单词边界处分离的清晰度。但无论如何，遵循建议总是更好的，因为Julia API中的函数名称遵循它。通过遵循相同的约定，你的代码将保持一致性。
- en: Constants
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'Constants are variables that, once declared, can''t be changed. They are declared
    by prefixing them with the `const` keyword:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是一旦声明就不能更改的变量。它们通过在前面加上`const`关键字来声明：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Very importantly in Julia, constants are not concerned with their value, but
    rather with their *type*. It is a bit too early to discuss types in Julia, so
    for now it suffices to say that a type represents what kind of a value we''re
    dealing with. For instance, `"abc"` (within double quotes) is of type `String`,
    `''a''` (within single quotes) is of type `Char` , and `1000` is of type `Int`
    (because it''s an integer). Thus, in Julia, unlike most other languages, we can
    change the value assigned to a constant as long as the `type` remains the same.
    For instance, we can at first decide that eggs and milk are acceptable meal choices
    and go `vegetarian`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中非常重要的一点是，常量不关心它们的值，而是关心它们的*类型*。现在讨论Julia中的类型还为时过早，所以现在只需说，类型代表我们正在处理的价值类型。例如，`"abc"`（在双引号内）是`String`类型，`'a'`（在单引号内）是`Char`类型，`1000`是`Int`类型（因为它是一个整数）。因此，在Julia中，与大多数其他语言不同，只要类型保持不变，我们就可以更改分配给常量的值。例如，我们最初可以决定鸡蛋和牛奶是可接受的餐食选择，并改为`vegetarian`：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And we can change our mind later on, if we decide to go `vegan`. Julia will
    let it slide with just a warning:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定改为`vegan`，我们可以在以后改变主意。Julia会通过仅发出警告来允许这样做：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, attempting to say that `mealoption = 2` will result in an error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试将`mealoption = 2`赋值将会导致错误：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This makes sense, right? Who's ever heard of that kind of diet?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的，对吧？谁听说过那种饮食？
- en: 'However, the nuances can be more subtle than that, most notably when working
    with numbers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，细微差别可能比这更微妙，尤其是在处理数字时：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Julia doesn''t allow it because internally `10` and `10.00`, despite having
    the same arithmetical value, are values of different types (`10` is an integer,
    while `10.00` is a `float`). We''ll take a closer look at numeric types in just
    a moment, so it will all become clearer:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 不允许这样做，因为从内部来看，`10` 和 `10.00` 虽然具有相同的算术值，但它们是不同类型的值（`10` 是一个整数，而 `10.00`
    是一个 `float`）。我们将在稍后更详细地了解数值类型，这样一切都会变得清晰：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Thus, we need to pass the new value as `10.00`—a `float`, in order to obey the
    same type requirement.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将新值作为 `10.00`——一个 `float` 传递，以遵守相同的类型要求。
- en: Why are constants important?
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么常量很重要？
- en: It's mostly about performance. Constants can be especially useful as global
    values. Because global variables are long-lived and can be modified at any time
    and from any location in your code, the compiler is having a hard time optimizing
    them. If we tell the compiler that the value is constant and thus that the type
    of the value won't change, the performance problem can be optimized away.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要关乎性能。常量可以作为全局值特别有用。因为全局变量是长期存在的，并且可以在代码的任何位置和任何时候进行修改，编译器在优化它们时会有困难。如果我们告诉编译器该值是常量，因此该值的类型不会改变，性能问题就可以得到优化。
- en: Of course, just because constants alleviate some critical performance problems
    brought about by global variables, it doesn't mean that we are encouraged to use
    them. Global values in Julia, like in other languages, must be avoided whenever
    possible. Besides performance issues, they can create subtle bugs that are hard
    to catch and understand. Also, keep in mind that, since Julia allows changing
    the value of a constant, accidental modification becomes possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅因为常量可以缓解由全局变量引起的某些关键性能问题，并不意味着我们被鼓励使用它们。在 Julia 中，像在其他语言中一样，应尽可能避免使用全局值。除了性能问题之外，它们还可能创建难以捕捉和理解的微妙错误。此外，请记住，由于
    Julia 允许更改常量的值，意外的修改成为可能。
- en: Comments
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Common programming wisdom says the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的编程智慧如下：
- en: '"Code is read much more often than it is written, so plan accordingly."'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '"代码被阅读的次数远多于被编写的次数，因此要相应地计划。"'
- en: 'Code comments are a powerful tool that make the programs easier to understand
    later on. In Julia, comments are marked with the # sign. Single-line comments
    are denoted by a `#` and everything that follows this, until the end of the line,
    is ignored by the compiler. Multiline comments are enclosed between `#= ... =#`.
    Everything within the opening and the closing comment tags is also ignored by
    the compiler. Here is an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '代码注释是一种强大的工具，可以使程序在以后更容易理解。在 Julia 中，注释用 # 符号标记。单行注释由 `#` 表示，并且直到行尾的所有内容都会被编译器忽略。多行注释被
    `#= ... =#` 包围。在开闭注释标签之间的所有内容也会被编译器忽略。以下是一个示例：'
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous snippet, we can see both multiline and single-line comments
    in action. A single-line comment can also be placed at the beginning of the line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到多行和单行注释的实际应用。单行注释也可以放在行的开头。
- en: Strings
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A string represents a sequence of characters. We can create a string by enclosing
    the corresponding sequence of characters between double quotes, as shown in the
    following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串表示字符序列。我们可以通过在双引号之间包围相应的字符序列来创建字符串，如下所示：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If the string also includes quotes, we can escape these by prefixing them with
    a backslash `\`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串中也包含引号，我们可以通过在它们前面加上反斜杠 `\` 来转义这些引号：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Triple-quoted strings
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三引号字符串
- en: However, escaping can get messy, so there's a much better way of dealing with
    this—by using triple quotes `"""..."""`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，转义可能会变得混乱，所以有一个更好的处理方法——使用三引号 `"""..."""`。
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Within triple quotes, it is no longer necessary to escape the single quotes.
    However, make sure that the single quotes and the triple quotes are separated—or
    else the compiler will get confused:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在三引号内，不再需要转义单引号。但是，请确保单引号和三引号是分开的——否则编译器会感到困惑：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The triple quotes come with some extra special powers when used with multiline
    text. First, if the opening `"""` is followed by a newline, this newline is stripped
    from the string. Also, whitespace is preserved but the string is dedented to the
    level of the least-indented line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当与多行文本一起使用时，三引号带来了一些额外的特殊功能。首先，如果开头的 `"""` 后面跟着一个换行符，这个换行符将被从字符串中删除。此外，空白被保留，但字符串将被缩进到最不缩进的行的级别：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is how it looks in Jupyter/IJulia:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jupyter/IJulia 中看起来是这样的：
- en: '![](img/1eb65198-16e9-4b0e-9044-7cce9cd0bfce.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1eb65198-16e9-4b0e-9044-7cce9cd0bfce.png)'
- en: The longer arrow stands for a *Tab* (represented by a `\t` in the output), while
    the shorter arrow is a space. Note that each line had a space as the first character—but
    it was removed. The least indented line, the last one, was shifted to the left,
    removing all its whitespace and beginning with **Here**, while the remaining whitespace
    on the other lines was preserved (now beginning with a *Tab*).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 长箭头代表一个 *Tab*（在输出中由 `\t` 表示），而短箭头是一个空格。请注意，每一行都以一个空格作为开头——但它被移除了。最不缩进的行，即最后一行，被向左移动，移除了所有空白，并以
    **Here** 开头，而其他行上的剩余空白被保留（现在以 *Tab* 开头）。
- en: Concatenating strings
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串拼接
- en: 'Two or more strings can be joined together (concatenated) to form a single
    string by using the star `*` operator:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 两个或多个字符串可以通过使用星号 `*` 运算符拼接在一起，形成一个单独的字符串：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, we can invoke the `string` function, passing in all the words
    we want to concatenate:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以调用 `string` 函数，传入我们想要拼接的所有单词：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Concatenation works great with variables too:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 拼接也可以与变量很好地配合使用：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, again, we need to be careful when dealing with types (types are central
    to Julia, so this will be a recurring topic). Concatenation only works for strings:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，同样，我们在处理类型时需要小心（类型是 Julia 的核心，所以这将会是一个经常出现的话题）。拼接仅适用于字符串：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Performing the concatenation by invoking the `string` function does work even
    if not all the arguments are strings:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不是所有参数都是字符串，通过调用 `string` 函数进行拼接也是有效的：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Thus, `string` has the added advantage that it automatically converts its parameters
    to strings. The following example works too:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`string` 有一个额外的优势，它自动将参数转换为字符串。以下示例也适用：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But this does not:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不行：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is also a `String` method (with capital S). Remember that in Julia names
    are case-sensitive, so `string` and `String` are two different things. For most
    purposes we'll need the lowercase function, `string`. You can use Julia's help
    system to access the documentation for `String`, if you want to learn about it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `String` 方法（首字母大写）。请记住，在 Julia 中名称是区分大小写的，所以 `string` 和 `String` 是两件不同的事情。对于大多数用途，我们需要小写的函数
    `string`。如果您想了解 `String`，可以使用 Julia 的帮助系统来访问其文档。
- en: Interpolating strings
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串插值
- en: 'When creating longer, more complex strings, concatenation can be noisy and
    error-prone. For such cases, we''re better off using the `$` symbol to perform
    variable interpolation into strings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建更长的、更复杂的字符串时，拼接可能会很嘈杂且容易出错。对于这种情况，我们最好使用 `$` 符号将变量插值到字符串中：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'More complex expressions can be interpolated by wrapping them into `$(...)`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的表达式可以通过将其包裹在 `$(...)` 中进行插值：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here we invoke the `uppercase` function which changes all the letters of the
    string into their uppercase counterparts—and the `reverse` function which reverses
    the order of the letters in the word. Their output is then interpolated in a string.
    Between the `$(...)` boundaries, we can use any Julia code we want.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们调用了 `uppercase` 函数，它将字符串中的所有字母转换为大写字母——以及 `reverse` 函数，它反转单词中字母的顺序。它们的输出随后被插值到字符串中。在
    `$(...)` 边界内，我们可以使用任何我们想要的 Julia 代码。
- en: 'Just like the `string` function, interpolation takes care of converting the
    values to strings:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `string` 函数一样，插值会负责将值转换为字符串：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Manipulating strings
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'Strings can be treated as a list of characters, so we can index into them—that
    is, access the character at a certain position in the word:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以被当作字符列表来处理，因此我们可以对它们进行索引——也就是说，访问单词中某个位置的字符：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first character of the string `Nice to see you` is `N`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `Nice to see you` 的第一个字符是 `N`。
- en: Indexing in Julia is `1`-based, which means that the first element of a list
    is found at index 1\. This can be surprising if you've programmed before, given
    that most programming languages use `0`-based indexing. However, I assure you
    that `1`-based indexing makes for a very pleasant and straightforward coding experience.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中的索引是 `1`-based，这意味着列表的第一个元素位于索引 1。如果你之前编程过，这可能会让你感到惊讶，因为大多数编程语言使用 `0`-based
    索引。然而，我向你保证，`1`-based 索引会让编码体验非常愉快且直接。
- en: Julia has support for arrays with arbitrary indices, allowing, for example,
    to start numbering at `0`. However, arbitrary indexing is a more advanced feature
    that we won't cover here. If you are curious, you can check the official documentation
    at [https://docs.julialang.org/en/v1/devdocs/offset-arrays/](https://docs.julialang.org/en/v1/devdocs/offset-arrays/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 支持具有任意索引的数组，例如，可以从 `0` 开始编号。然而，任意索引是一个更高级的功能，我们在这里不会涉及。如果您对此好奇，可以查看官方文档[https://docs.julialang.org/en/v1/devdocs/offset-arrays/](https://docs.julialang.org/en/v1/devdocs/offset-arrays/)。
- en: 'We can also extract a part of the string (a substring) by indexing with a `range`,
    providing the starting and the ending positions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用 `range` 进行索引来提取字符串的一部分（子字符串），提供起始和结束位置：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is important to notice that indexing via a singular value returns a `Char` ,
    while indexing via a `range` returns a `String` (remember, for Julia these are
    two completely different things):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，通过单个值进行索引返回一个 `Char`，而通过 `range` 进行索引返回一个 `String`（记住，对于 Julia 来说，这是两件完全不同的事情）：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`N` is a `String` of just one letter, as indicated by its double quotes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`N` 是一个仅由一个字母组成的 `String`，正如其双引号所示：'
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`N` is a `Char`, as shown by the single quotes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`N` 是一个 `Char`，正如单引号所示：'
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: They are not equal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不相等。
- en: Unicode and UTF-8
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode 和 UTF-8
- en: 'In Julia, string literals are encoded using UTF-8\. UTF-8 is a variable-width
    encoding, meaning that not all characters are represented using the same number
    of bytes. For example, ASCII characters are encoded using a single byte—but other
    characters can use up to four bytes. This means that not every byte index into
    a UTF-8 string is necessarily a valid index for a corresponding character. If
    you index into a string at such an invalid byte index, an error will be thrown.
    Here is what I mean:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，字符串字面量使用 UTF-8 编码。UTF-8 是一种可变宽度编码，这意味着并非所有字符都使用相同数量的字节来表示。例如，ASCII
    字符使用单个字节编码——但其他字符可以使用多达四个字节。这意味着并非每个 UTF-8 字符串的字节索引都是对应字符的有效索引。如果您在无效的字节索引处索引字符串，将会抛出错误。以下是我的意思：
- en: '[PRE37]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can correctly retrieve the character at index `1`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以正确地检索索引 `1` 处的字符：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And at index `2`, we successfully get the `ø` character:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引 `2` 处，我们成功获取了 `ø` 字符：
- en: '[PRE39]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'However, `ø` has two bytes, so index `3` is used by `ø` as well and we cannot
    access the string at this position:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ø` 有两个字节，所以索引 `3` 也被 `ø` 使用，我们无法访问这个位置的字符串：
- en: '[PRE40]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The third letter, `r`, is found at position `4`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第三字母 `r` 在位置 `4` 被找到。
- en: 'Thus `ø` is a two-byte character that occupies the locations `2` and `3`—so
    the index `3` is invalid, matching the second byte of `ø`. The next valid index
    can be computed using `nextind(str, 2)`—but the recommended way is to use iteration
    over the characters (we''ll discuss `for` loops a bit later in this chapter):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 `ø` 是一个占用位置 `2` 和 `3` 的双字节字符——所以索引 `3` 是无效的，匹配 `ø` 的第二个字节。下一个有效索引可以使用 `nextind(str,
    2)` 来计算——但推荐的方式是使用字符迭代（我们将在本章稍后讨论 `for` 循环）：
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Because of variable-length encodings, the number of characters in a string
    is not necessarily the same as the last index (as you have seen, the third letter,
    `r`, was at index `4`):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可变长度编码，字符串中的字符数不一定与最后一个索引相同（如您所见，第三个字母 `r` 在索引 `4` 处）：
- en: '[PRE42]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For such cases, Julia provides the `end` keyword, which can be used as a shorthand
    for the last index. You can perform arithmetic and other operations with `end`,
    just like a normal value:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类情况，Julia 提供了 `end` 关键字，它可以作为最后一个索引的快捷方式。您可以使用 `end` 进行算术和其他操作，就像一个普通值一样：
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `end` value can be computed programmatically using the `endof(str)` function.
    Attempting to index outside the bounds of a string will result in a `BoundsError`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`end` 值可以使用 `endof(str)` 函数进行程序计算。尝试在字符串的界限之外进行索引将导致 `BoundsError`：'
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Regular expressions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Regular expressions are used for powerful pattern-matching of substrings within
    strings. They can be used to search for a substring in a string, based on patterns—and
    then to extract or replace the matches. Julia provides support for Perl-compatible
    regular expressions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式用于在字符串内部进行强大的子字符串模式匹配。它们可以根据模式在字符串中搜索子字符串，然后提取或替换匹配项。Julia 提供了对 Perl 兼容正则表达式的支持。
- en: The most common way to input regular expressions is by using the so-called **nonstandard
    string literals**. These look like regular double-quoted strings, but carry a
    special prefix. In the case of regular expressions, this prefix is `"r"`. The
    prefix provides for a different behavior, compared to a normal string literal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输入正则表达式的最常见方式是使用所谓的**非标准字符串字面量**。这些看起来像常规的双引号字符串，但带有特殊的前缀。在正则表达式的例子中，这个前缀是`"r"`。前缀提供了一种与普通字符串字面量不同的行为。
- en: For example, in order to define a regular string that matches all the letters,
    we can use `r"[a-zA-Z]*".`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了定义一个匹配所有字母的正则字符串，我们可以使用`r"[a-zA-Z]*"。`
- en: Julia provides quite a few nonstandard string literals—and we can even define
    our own if we want to. The most widely used are for regular expressions (`r"..."`),
    byte array literals (`b"..."`), version number literals (`v"..."`), and package
    management commands (`pkg"..."`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了相当多的非标准字符串字面量——如果我们想的话，我们甚至可以定义自己的。最广泛使用的是正则表达式（`r"..."`）、字节数组字面量（`b"..."`）、版本号字面量（`v"..."`）和包管理命令（`pkg"..."`）。
- en: 'Here is how we build a regular expression in Julia—it matches numbers between
    0 and 9:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在Julia中构建正则表达式——它匹配介于0和9之间的数字：
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our regular expression matches the substring `1970`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的正则表达式匹配子字符串`1970`。
- en: 'We can confirm that the nonstandard string literal `reg` is in fact a `Regex`
    and not a regular `String` by checking its `type` with the `typeof` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`typeof`函数检查其`type`来确认非标准字符串字面量`reg`实际上是一个`Regex`而不是一个普通的`String`：
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This gives away the fact that there''s also a `Regex` constructor available:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这揭示了还有一个`Regex`构造函数可用：
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The two constructs are similar:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个构造函数类似：
- en: '[PRE48]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Using the constructor can come in handy when we need to create regular expressions
    using more complex strings that might include interpolation or concatenation.
    But in general, the `r"..."` format is more used.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要使用更复杂的字符串创建正则表达式，可能包括插值或连接时，使用构造函数可能很有用。但通常，`r"..."`格式更常用。
- en: 'The behavior of the regular expression can be affected by using some combination
    of the flags `i`, `m`, `s`, and `x.` These modifiers must be placed right after
    the closing double quote mark:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一些组合的标志`i`、`m`、`s`和`x`，可以影响正则表达式的行为。这些修饰符必须放在关闭双引号标记之后：
- en: '[PRE49]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you might expect, `i` performs a case-insensitive pattern match. Without
    the `i` modifier, `match` returns `nothing`—a special value that does not print
    anything at the interactive prompt—to indicate that the regex does not match the
    given string.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，`i`执行不区分大小写的模式匹配。如果没有`i`修饰符，`match`返回`nothing`——一个特殊值，在交互式提示符中不打印任何内容，以指示正则表达式不匹配给定的字符串。
- en: 'These are the available modifiers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可用的修饰符：
- en: '`i`—case-insensitive pattern matching.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`—不区分大小写的模式匹配。'
- en: '`m`—treats string as multiple lines.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`—将字符串视为多行。'
- en: '`s`—treats string as single line.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`—将字符串视为单行。'
- en: '`x`—tells the regular expression parser to ignore most whitespace that is neither
    backslashed nor within a character class. You can use this to break up your regular
    expression into (slightly) more readable parts. The `#` character is also treated
    as a metacharacter introducing a comment, just as in ordinary code.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`—告诉正则表达式解析器忽略大多数既不是转义也不是在字符类内的空白。您可以使用此功能将正则表达式分成（稍微）更易读的部分。`#`字符也被视为元字符，引入注释，就像在普通代码中一样。'
- en: 'The `occursin` function is more concise if all we need is to check if a regex
    or a substring is contained in a string—if we don''t want to extract or replace
    the matches:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想检查正则表达式或子字符串是否包含在字符串中，而不想提取或替换匹配项，则`occursin`函数更为简洁：
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When a regular expression does match, it returns a `RegexMatch` object. These
    objects encapsulate how the expression matches, including the substring that the
    pattern matches and any captured substrings:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当正则表达式匹配时，它返回一个`RegexMatch`对象。这些对象封装了表达式的匹配方式，包括匹配的子字符串和任何捕获的子字符串：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We also have the option to specify the index at which to start the search:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定开始搜索的索引：
- en: '[PRE53]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s try something a bit more complex:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个稍微复杂一些的例子：
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The resultant `RegexMatch` object `m` exposes the following properties (or
    fields, in Julia''s lingo):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`RegexMatch`对象`m`公开以下属性（或在Julia的说法中，字段）：
- en: '`m.match` (`Why`, ) contains the entire substring that matched.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.match`（`Why`）包含匹配的整个子字符串。'
- en: '`m.captures` (an array of strings containing `Why`, `Why`, and `,` ) represents
    the captured substrings.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.captures`（一个包含`Why`、`Why`和`,`的字符串数组）表示捕获的子字符串。'
- en: '`m.offset`, the offset at which the whole match begins (in our case `1`).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.offset`，整个匹配开始的偏移量（在我们的例子中是 `1`）。'
- en: '`m.offsets`, the offsets of the captured substrings as an array of integers
    (for our example being `[1, 1, 4]`).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.offsets`，捕获子字符串的偏移量作为整数数组（在我们的例子中是 `[1, 1, 4]`）。'
- en: 'Julia does not provide a `g` modifier, for a *greedy* or *global* match. If
    you need all the matches, you can iterate over them using `eachmatch()`, with
    a construct like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 不提供 `g` 修饰符，用于 *贪婪* 或 *全局* 匹配。如果你需要所有匹配项，你可以使用 `eachmatch()` 函数遍历它们，如下所示：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or, alternatively, we can put all the matches in a list using `collect()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `collect()` 函数将所有匹配项放入一个列表中：
- en: '[PRE56]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For more info about regular expressions, check the official documentation at
    [https://docs.julialang.org/en/stable/manual/strings/#Regular-Expressions-1](https://docs.julialang.org/en/stable/manual/strings/#Regular-Expressions-1).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于正则表达式的信息，请查看官方文档：[https://docs.julialang.org/en/stable/manual/strings/#Regular-Expressions-1](https://docs.julialang.org/en/stable/manual/strings/#Regular-Expressions-1)。
- en: Raw string literals
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始字符串字面量
- en: 'If you need to define a string that does not perform interpolation or escaping,
    for example to represent code from another language that might contain `$` and
    `\` which can interfere with the Julia parser, you can use raw strings. They are
    constructed with `raw"..."` and create ordinary `String` objects that contain
    the enclosed characters exactly as entered, with no interpolation or escaping:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要定义一个不执行插值或转义的字符串，例如表示可能包含 `$` 和 `\` 的其他语言的代码，这些字符可能会干扰 Julia 解析器，你可以使用原始字符串。它们使用
    `raw"..."` 构造，并创建包含所包含字符的普通 `String` 对象，这些字符与输入的完全一致，没有插值或转义：
- en: '[PRE57]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Putting a `$` inside the string will cause Julia to perform interpolation and
    look for a variable called `will`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串中放置一个 `$` 将导致 Julia 执行插值并查找名为 `will` 的变量：
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: But by using a raw string, the `$` symbol will be ignored (or rather, automatically
    escaped, as you can see in the output).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，通过使用原始字符串，`$` 符号将被忽略（或者更确切地说，自动转义，如输出所示）。
- en: Numbers
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: Julia provides a broad range of primitive numeric types, together with the full
    range of arithmetic and bitwise operators and standard mathematical functions.
    We have at our disposal a rich hierarchy of numeric types, with the most generic
    being `Number`—which defines two subtypes, `Complex` and `Real`. Conversely, `Real`
    has four subtypes—`AbstractFloat`, `Integer`, `Irrational`, and `Rational`. Finally,
    `Integer` branches into four other subtypes—`BigInt`, `Bool`, `Signed`, and `Unsigned`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了广泛的原始数字类型，以及完整的算术和位运算符以及标准数学函数。我们有丰富的数字类型层次结构可供使用，其中最通用的是 `Number`——它定义了两个子类型，`Complex`
    和 `Real`。相反，`Real` 有四个子类型——`AbstractFloat`、`Integer`、`Irrational` 和 `Rational`。最后，`Integer`
    分支为四个其他子类型——`BigInt`、`Bool`、`Signed` 和 `Unsigned`。
- en: Let's take a look at the most important categories of numbers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看数字最重要的几个类别。
- en: Integers
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: 'Literal integers are represented simply as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 文本整数简单地表示如下：
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The default Integer type, called `Int`, depends on the architecture of the
    system upon which the code is executed. It can be either `Int32` or `Int64`. On
    my 64-bit system, I get it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的整数类型，称为 `Int`，取决于代码执行的系统架构。它可以是 `Int32` 或 `Int64`。在我的 64 位系统上，我得到它如下：
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `Int` type will reflect that, as it''s just an alias to either `Int32`
    or `Int64`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int` 类型将反映这一点，因为它只是 `Int32` 或 `Int64` 的别名：'
- en: '[PRE61]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Overflow behavior
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 溢出行为
- en: 'The minimum and maximum values are given by the `typemin()` and `typemax()`
    functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值和最大值由 `typemin()` 和 `typemax()` 函数给出：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Attempting to use values that go beyond the boundaries defined by the minimum
    and the maximum values will not throw an error (or even a warning), resulting
    instead in a wraparound behavior (meaning that it will jump over at the other
    end):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用超出最小值和最大值定义的边界之外的值不会抛出错误（甚至警告），而是导致环绕行为（意味着它会在另一端跳过）：
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Substracting `1` from the minimum value will return the maximum value instead:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从最小值减去 `1` 将返回最大值：
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The reverse is also `true`—adding `1` to the maximum value will return the minimum
    value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 反之亦然——将 `1` 添加到最大值将返回最小值。
- en: 'For working with values outside these ranges, we''ll use the `BigInt` type:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理这些范围之外的值，我们将使用 `BigInt` 类型：
- en: '[PRE65]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: No wraparound here; the result is what we expected.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有环绕；结果是我们所期望的。
- en: Floating-point numbers
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数
- en: 'Floating-point numbers are represented by numerical values separated by a dot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数由由点分隔的数值表示：
- en: '[PRE66]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'By default they are `Float64` values, but they can be converted to `Float32`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它们是 `Float64` 值，但可以转换为 `Float32`：
- en: '[PRE67]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To improve readability, the underscore (`_`) separator can be used with both
    integers and floats:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，下划线（`_`）分隔符可以与整数和浮点数一起使用：
- en: '[PRE68]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Rational numbers
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有理数
- en: 'Julia also provides a Rational number type. This allows us to work with exact
    ratios, instead of having to deal with the precision loss inherent in floats.
    Rational numbers are represented as their numerator and denominator values, separated
    by two forward slashes `//`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 还提供了有理数类型。这允许我们处理精确的比率，而不是必须处理浮点数固有的精度损失。有理数以它们的分子和分母值表示，用两个正斜杠 `//` 分隔：
- en: '[PRE69]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Rational numbers can be converted to other types, if there is no data loss:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有数据丢失，有理数可以转换为其他类型：
- en: '[PRE70]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Julia also includes support for Complex numbers. We won't discuss, them but
    you can read about the topic in the official documentation at [https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-Numbers-1](https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-Numbers-1).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 还包括对复数的支持。我们不会详细讨论它们，但你可以在官方文档中阅读有关该主题的内容，链接为[https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-Numbers-1](https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/#Complex-Numbers-1)。
- en: Numerical operators
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值运算符
- en: 'Julia supports the full range of arithmetic operators for its numeric types:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 支持其数值类型的完整范围的算术运算符：
- en: '`+`—(unary and binary plus)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` —（一元和二元加）'
- en: '`-`—(unary and binary minus)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` —（一元和二元减）'
- en: '`*`—(times)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` —（乘）'
- en: '`/`—(divide)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` —（除）'
- en: '`\`—(inverse divide)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\` —（倒数除）'
- en: '`^`—(power)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` —（幂）'
- en: '`%`—(remainder)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%` —（余数）'
- en: 'The language also supports handy update operators for each of these (`+=`,`-=`,`*=`,`/=`,`\=`,`÷=`,`%=`,and `^=`).
    Here they are in the wild:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 语言还支持每个这些的便捷更新运算符（`+=`,`-=`,`*=`,`/=`,`\=`,`÷=`,`%=`,和 `^=`）。这里它们是野生的：
- en: '[PRE71]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Numerical comparisons can be performed with the following set of operators:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下一组运算符执行数值比较：
- en: '`==`—(equality)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` —（相等）'
- en: '`!=` or `≠`—(inequality)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 或 `≠` —（不等）'
- en: '`<`—(less than)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` —（小于）'
- en: '`<=` or `≤`—(less than or equal to)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` 或 `≤` —（小于等于）'
- en: '`>`—(greater than)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` —（大于）'
- en: '`>=` or `≥`—(greater than or equal to)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` 或 `≥` —（大于等于）'
- en: 'In Julia, the comparisons can also be chained:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，比较也可以链式使用：
- en: '[PRE72]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Vectorized dot operators
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量化点操作符
- en: Julia defines corresponding *dot* operations for every binary operator. These
    are designed to work element-wise with collections of values (called **vectorized**).
    That is, the operator that is *dotted* is applied for each element of the collection.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 为每个二元运算符定义了相应的 *点* 操作。这些操作旨在逐元素与值集合（称为 **向量化**）一起工作。也就是说，被 *点* 的运算符应用于集合中的每个元素。
- en: 'In the following example, we''ll square each element of the `first_five_fib`
    collection:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将对 `first_five_fib` 集合中的每个元素进行平方：
- en: '[PRE73]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the previous example, `first_five_fib` was not touched and the resultant
    collection was returned, but *dotted* updating operators are also available, updating
    the values in place. They match the previously discussed update operators (with
    the added *dot*). For example, to update `first_five_fib` in place, we''d use
    the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`first_five_fib` 没有被修改，返回的结果集合，但还有 *点* 更新运算符也可用，它们在原地更新值。它们与之前讨论的更新运算符（增加了
    *点*）相匹配。例如，要就地更新 `first_five_fib`，我们会使用以下代码：
- en: '[PRE74]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Vectorized code is an important part of the language due to its readability
    and conciseness, but also because it provides important performance optimizations.
    For more details, check [https://docs.julialang.org/en/stable/manual/functions/#man-vectorized-1](https://docs.julialang.org/en/stable/manual/functions/#man-vectorized-1).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化代码是语言的一个重要部分，因为它具有可读性和简洁性，同时也因为它提供了重要的性能优化。更多详情，请查看[https://docs.julialang.org/en/stable/manual/functions/#man-vectorized-1](https://docs.julialang.org/en/stable/manual/functions/#man-vectorized-1)。
- en: There's more to it
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: This section barely scratches the surface. For a deeper dive into Julia's numeric
    types, read the official documentation at [https://docs.julialang.org/en/stable/manual/mathematical-operations/](https://docs.julialang.org/en/stable/manual/mathematical-operations/).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节只是触及了表面。要深入了解 Julia 的数值类型，请阅读官方文档[https://docs.julialang.org/en/stable/manual/mathematical-operations/](https://docs.julialang.org/en/stable/manual/mathematical-operations/)。
- en: Tuples
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are one of the simplest data types and data structures in Julia. They
    can have any length and can contain any kind of value—but they are immutable.
    Once created, a tuple cannot be modified. A tuple can be created using the literal
    tuple notation, by wrapping the comma-separated values within brackets `(...)`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是Julia中最简单的数据类型和结构之一。它们可以有任意长度，可以包含任何类型的值——但它们是不可变的。一旦创建，元组就不能修改。可以使用字面量元组表示法创建元组，通过在大括号`(...)`内包裹逗号分隔的值：
- en: '[PRE75]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In order to define a one-element tuple, we must not forget the trailing comma:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义一个只有一个元素的元组，我们一定不要忘记尾随的逗号：
- en: '[PRE76]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'But it''s OK to leave off the parenthesis:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但省略括号是可以的：
- en: '[PRE77]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can index into tuples to access their elements:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以索引元组来访问它们的元素：
- en: '[PRE78]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Vectorized *dot *operations also work with tuples:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化*点*操作也适用于元组：
- en: '[PRE79]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Named tuples
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名元组
- en: 'A named tuple represents a tuple with labeled items. We can access the individual
    components by label or by index:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组表示一个带有标签项的元组。我们可以通过标签或索引访问各个组件：
- en: '[PRE80]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Named tuples can be very powerful as they are similar to full-blown objects,
    but with the limitation that they are immutable.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组可以非常强大，因为它们类似于完整对象，但限制在于它们是不可变的。
- en: Ranges
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: 'We''ve seen ranges a bit earlier, when learning to index into `strings`. They
    can be as simple as the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前学习如何索引字符串时已经看到了范围。它们可以像以下这样简单：
- en: '[PRE81]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As with previous collections, we can index into ranges:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的集合一样，我们可以对范围进行索引：
- en: '[PRE82]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A range can be expanded into its corresponding values by using the splat operator,
    `"..."`. For example, we can splat it into a tuple:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用展开运算符`"..."`将范围展开为其对应的值。例如，我们可以将其展开成元组：
- en: '[PRE83]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can also splat it into a list:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将其展开成列表：
- en: '[PRE84]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The same is true for Tuples, which can also be splatted into lists, among other
    things: `[(1,2,3)...]`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于元组也是如此，它们还可以被展开成列表，以及其他东西：`[(1,2,3)...]`。
- en: 'We can see that the range steps in increments of one, by default. We can change
    that by passing it an optional step parameter. Here is an example of a range between
    `0` and `20` with a step of five:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，范围默认以增量为一的步长。我们可以通过传递一个可选的步长参数来改变它。以下是一个从`0`到`20`且步长为五的范围的例子：
- en: '[PRE85]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now our values go from `5` to `5`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的值从`5`到`5`。
- en: 'This opens the possibility to also go in descending order, by using a negative
    step:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这也打开了以负步长递减顺序前进的可能性：
- en: '[PRE86]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Ranges are not limited to integers—you''ve seen earlier a range of `chars`;
    and these are ranges of `floats`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 范围不仅限于整数——您之前已经看到了`chars`的范围；这些是`floats`的范围：
- en: '[PRE87]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can also use the `collect` function to expand the range into a list (an
    array):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`collect`函数将范围扩展到列表（数组）中：
- en: '[PRE88]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Arrays
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a data structure (and the corresponding *type*) that represents
    an ordered collection of elements. More specifically, in Julia, an array is a
    collection of objects stored in a multi-dimensional grid.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种数据结构（以及相应的*类型*），它表示一个有序的元素集合。更具体地说，在Julia中，数组是一个存储在多维网格中的对象的集合。
- en: Arrays can have any number of dimensions and are defined by their type and number
    of dimensions—`Array{Type, Dimensions}`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以有任意数量的维度，由它们的类型和维度数定义——`Array{Type, Dimensions}`。
- en: 'A one-dimensional array, also called a **vector**, can be easily defined using
    the array literal notation, the square brackets `[...]`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组，也称为**向量**，可以使用数组字面量表示法轻松定义，即方括号`[...]`：
- en: '[PRE89]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You can also constrain the type of the elements:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以约束元素的类型：
- en: '[PRE90]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'A two D array (also called a **matrix**) can be initialized using the same
    array literal notation, but this time without the commas:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组（也称为**矩阵**）可以使用相同的数组字面量表示法初始化，但这次不需要逗号：
- en: '[PRE91]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can add more rows using semicolons:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用分号添加更多行：
- en: '[PRE92]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Julia comes with a multitude of functions that can construct and initialize
    arrays with different values, such as `zeroes`, `ones`, `trues`, `falses`, `similar`,
    `rand, fill`, and more`.` Here are a few of these in action:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Julia附带了许多函数，可以构造和初始化具有不同值的数组，例如`zeroes`、`ones`、`trues`、`falses`、`similar`、`rand`、`fill`等。以下是一些实际应用的例子：
- en: '[PRE93]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`Array` elements can be accessed by their index, passing in a value for each
    dimension:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array`元素可以通过它们的索引访问，为每个维度传递一个值：'
- en: '[PRE94]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can also pass a colon (`:`) to select all indices within the entire dimension—or
    a range to define subselections:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以传递一个冒号（`:`）来选择整个维度内的所有索引——或者一个范围来定义子选择：
- en: '[PRE95]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This is how we select rows `1` to `3` and columns `3` to `5`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们选择行`1`到`3`和列`3`到`5`的方式：
- en: '[PRE96]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The solitary colon `:` stands for all—so here we pick all the rows and columns
    `3` to `5`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的冒号`:`代表所有——所以这里我们选择了行和列`3`到`5`：
- en: '[PRE97]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Another option is an `Array` of Booleans to select elements at its `true` indices.
    Here we select the rows corresponding to the `true` values and the columns `3`
    to `5`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是布尔数组`Array`来选择其`true`索引处的元素。在这里，我们选择了对应于`true`值的行和列`3`到`5`：
- en: '[PRE98]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In a similar way to indexing into an array, we can also assign values to the
    selected items:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组索引类似，我们也可以将值赋给选定的项：
- en: '[PRE99]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Iteration
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代
- en: 'The simplest way to iterate over an array is with the `for` construct:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数组的最简单方法是使用`for`构造：
- en: '[PRE100]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here''s an example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE101]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If you also need the index while iterating, Julia exposes the `eachindex(yourarray)`
    iterator:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还需要在迭代时获取索引，Julia提供了`eachindex(yourarray)`迭代器：
- en: '[PRE102]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Mutating arrays
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改数组
- en: 'We can add more elements to the end of a collection by using the `push!` function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`push!`函数向集合的末尾添加更多元素：
- en: '[PRE103]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note the ending exclamation mark `!` for the `push!` function. This is a perfectly
    legal function name in Julia. It is a convention to warn that the function is
    *mutating—*that is, it will modify the data passed as argument to it, instead
    of returning a new value.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`push!`函数结尾的感叹号`!`。这在Julia中是一个完全合法的函数名。这是一个约定，用来警告该函数是*修改性的*——也就是说，它将修改传递给它的数据，而不是返回一个新值。
- en: 'We can remove elements from the end of an `array` using `pop!`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pop!`从数组的末尾删除元素：
- en: '[PRE104]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The call to the `pop!` function has removed the last element of `arr` and returned
    it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`pop!`函数已经移除了`arr`的最后一个元素并返回了它。
- en: 'If we want to remove an element other than the last, we can use the `deleteat!`
    function, indicating the index that we want to be removed:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要删除除了最后一个元素之外的其他元素，我们可以使用`deleteat!`函数，表示要删除的索引：
- en: '[PRE105]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Finally, a word of warning when mutating arrays. In Julia, the arrays are passed
    to functions by reference. This means that the original array is being sent as
    the argument to the various mutating functions, and not its copy. Beware not to
    accidentally make unwanted modifications. Similarly, when assigning an array to
    a variable, a new reference is created, but the data is not copied. So for instance:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于修改数组有一个警告。在Julia中，数组是通过引用传递给函数的。这意味着原始数组被发送作为各种修改函数的参数，而不是它的副本。小心不要意外地做出不想要的修改。同样，当将数组赋给变量时，会创建一个新的引用，但数据不会被复制。所以例如：
- en: '[PRE106]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now we `pop` an element off `arr2`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从`arr2`中移除一个元素：
- en: '[PRE107]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'So, `arr2` looks like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`arr2`看起来是这样的：
- en: '[PRE108]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'But our original array was modified, too:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的原始数组也被修改了：
- en: '[PRE109]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Assigning `arr` to `arr2` does not copy the values of `arr` into `arr2` , it
    only creates a new binding (a new name) that points to the original `arr` array.
    To create a separate array with the same values, we need to use the `copy` function:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将`arr`赋给`arr2`并不会将`arr`的值复制到`arr2`中，它只创建了一个新的绑定（一个新的名称），指向原始的`arr`数组。要创建具有相同值的单独数组，我们需要使用`copy`函数：
- en: '[PRE110]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, if we `pop` an element off the copied array:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们从复制的数组中移除一个元素：
- en: '[PRE111]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Our original array is untouched:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始的数组没有改变：
- en: '[PRE112]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Only the copy was modified:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 只有副本被修改了：
- en: '[PRE113]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Comprehensions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合推导
- en: Array comprehensions provide a very powerful way to construct arrays. It is
    similar to the previously discussed array literal notation, but instead of passing
    in the actual values, we use a computation over an iterable object.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 数组推导提供了一种非常强大的构建数组的方法。它类似于之前讨论的数组字面量表示法，但不同之处在于我们不是传递实际值，而是使用对可迭代对象的计算。
- en: 'An example will make it clear:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子会使其更清楚：
- en: '[PRE114]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This can be read as—*for each element* `x` *within the range* `1` *to* `5`,
    *compute* `x+1` *and put the resultant value in the array*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以读作——对于范围`1`到`5`内的每个元素`x`，计算`x+1`并将结果值放入数组中。
- en: 'Just like with the *plain* array literals, we can constrain the type:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通的数组字面量一样，我们可以约束类型：
- en: '[PRE115]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Similarly, we can create multi-dimensional arrays:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以创建多维数组：
- en: '[PRE116]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Comprehensions can be filtered using the `if` keyword:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`if`关键字对集合进行过滤：
- en: '[PRE117]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In this case, we only kept the values where `x/2` was greater than `3`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只保留了`x/2`大于`3`的值。
- en: Generators
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: But the superpower of the comprehensions is activated when they are used for
    creating generators. Generators can be iterated to produce values on demand, instead
    of allocating an array and storing all the values in advance. You'll see what
    that means in a second.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当它们用于创建生成器时，集合的强大功能被激活了。生成器可以被迭代以按需产生值，而不是分配一个数组并在事先存储所有值。你将在下一秒看到这意味着什么。
- en: 'Generators are defined just like array comprehensions, but without the square
    brackets:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器定义的方式与数组推导式相同，但没有方括号：
- en: '[PRE118]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'They allow us to work with potentially infinite collections. Check the following
    example, where we want to print the numbers from one to one million with a cube
    less than or equal to `1_000`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 它们允许我们与可能无限大的集合一起工作。检查以下示例，我们想要打印出从一到一百万的数字，其立方小于或等于`1_000`：
- en: '[PRE119]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This computation uses significant resources because the comprehension creates
    the full array of 1 million items, despite the fact that we only iterate over
    its first nine elements.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算使用了大量的资源，因为理解创建了一个包含1百万个项目的完整数组，尽管我们只迭代了它的前九个元素。
- en: 'We can see that by benchmarking the code using the handy `@time` construct:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用方便的`@time`构造函数来基准测试代码：
- en: '[PRE120]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Over 10 MB of memory and almost 60,000 allocations. Compare this with using
    a generator:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 超过10 MB的内存和近60,000次分配。与使用生成器相比：
- en: '[PRE121]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Less than 1 MB and a quarter of the number of allocations. The difference will
    be even more dramatic if we increase from 1 million to 1 billion:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 不到1 MB和分配次数的四分之一。如果我们从1百万增加到10亿，差异将更加明显：
- en: '[PRE122]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Over 10 seconds and 7 GB of memory used!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 超过10秒和7 GB的内存使用！
- en: 'On the other hand, the generator runs practically in constant time:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，生成器几乎以恒定的时间运行：
- en: '[PRE123]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Exploratory data analysis with Julia
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Julia进行数据探索分析
- en: Now that you have a good understanding of Julia's basics, we can apply this
    knowledge to our first project. We'll start by applying **exploratory data analysis** (**EDA**)
    to the Iris flower dataset.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经很好地理解了Julia的基础知识，我们可以将这个知识应用到我们的第一个项目中。我们将首先通过**数据探索分析**（**EDA**）来应用爱丽丝花数据集。
- en: If you already have experience with data analysis, you might've used the Iris
    dataset before. If so, that's great! You'll be familiar with the data and the
    way things are done in your (previous) language of choice, and can now focus on
    the Julia way.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经对数据分析有经验，你可能之前已经使用过爱丽丝花数据集。如果是这样，那太好了！你将熟悉数据以及在你（之前）选择的语言中如何做事，现在可以专注于Julia的方式。
- en: On the contrary, if this is the first time you've  heard about the Iris flower
    dataset, no need to worry. This dataset is considered the `Hello World` of data
    science—and we'll take a good look at it using Julia's powerful toolbox. Enjoy!
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你第一次听说爱丽丝花数据集，无需担心。这个数据集被认为是数据科学的`Hello World`——我们将使用Julia强大的工具箱来仔细研究它。享受吧！
- en: The Iris flower dataset
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爱丽丝花数据集
- en: Also called **Fisher's Iris dataset**, it was first introduced in 1936 by British
    statistician and biologist Ronald Fisher. The dataset consists of 50 samples from
    each of three species of Iris flower (Iris setosa, Iris virginica, and Iris versicolor).
    It is sometimes called **Anderson's Iris dataset** because Edgar Anderson collected
    the data. Four features were measured—the length and the width of the sepals and
    petals (in centimeters).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为**费舍尔的爱丽丝花数据集**，它最初由英国统计学家和生物学家罗纳德·费舍尔在1936年介绍。该数据集由三个品种的爱丽丝花（Iris setosa、Iris
    virginica和Iris versicolor）的50个样本组成。有时它被称为**安德森的爱丽丝花数据集**，因为埃德加·安德森收集了这些数据。测量了四个特征——萼片和花瓣的长度和宽度（以厘米为单位）。
- en: Using the RDatasets package
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`RDatasets`包
- en: Finding good-quality data for learning, teaching, and statistical software development
    can be challenging. That's why the industry practically standardized the use of
    over 10,00 high-quality datasets. These were originally distributed with the statistical
    software environment R. Hence, they've been aptly named the `RDatasets`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找用于学习、教学和统计软件开发的高质量数据可能具有挑战性。这就是为什么该行业实际上已经标准化了超过10,000个高质量数据集的使用。这些数据集最初是与统计软件环境R一起分发的。因此，它们被恰当地命名为`RDatasets`。
- en: The Iris flower dataset is part of this collection. There are many ways to download
    it, but the most convenient is through the `RDatasets` package. This package provides
    an easy way for Julia users to experiment with most of the standard datasets available
    in R or included with R's most popular packages. Sounds great; let's add it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝花数据集是本集合的一部分。有多种方式可以下载它，但最方便的方式是通过`RDatasets`包。这个包为Julia用户提供了方便的方式来实验R中大多数标准数据集，或者包含在R最受欢迎的包中。听起来很棒；让我们添加它。
- en: 'First, switch to package management mode:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，切换到包管理模式：
- en: '[PRE124]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Once the package is added, let''s tell Julia that we want to use it:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了包，让我们告诉Julia我们想要使用它：
- en: '[PRE125]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We can peek at the included datasets by calling `RDatasets.datasets()`. It
    returns a list of all the 700+ datasets available with `RDatasets`. It includes
    details about the data package, the name of the dataset, its title (or info),
    number of rows, and number of columns. These are the first 20 rows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `RDatasets.datasets()` 来查看包含的数据集。它返回一个包含 `RDatasets` 中所有 700 多个数据集的列表。它包括数据包的详细信息、数据集的名称、标题（或信息）、行数和列数。以下是前
    20 行：
- en: '[PRE126]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The output is as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/0b2c6fea-7db3-4a7f-98a2-c1828440a299.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b2c6fea-7db3-4a7f-98a2-c1828440a299.png)'
- en: You can see that the datasets are part of a `Package`—we can use that to filter
    by it. The Iris flower dataset is part of the *datasets* package.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到数据集是 `Package` 的一部分——我们可以用它来过滤。Iris 花数据集是 *datasets* 包的一部分。
- en: 'All we have to do now is load the data:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要加载数据：
- en: '[PRE127]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The output is as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/24730ac1-e5b6-4be2-9a2c-f942cb6efd3b.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24730ac1-e5b6-4be2-9a2c-f942cb6efd3b.png)'
- en: The returned value is a `DataFrame` object with 150 rows and five columns—`SepalLength`,
    `SepalWidth`, `PetalLength`, `PetalWidth`, and `Species`, plus an automatically
    added id column called `Row`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是一个包含 150 行和五列的 `DataFrame` 对象——`SepalLength`（花萼长度）、`SepalWidth`（花萼宽度）、`PetalLength`（花瓣长度）、`PetalWidth`（花瓣宽度）和
    `Species`（物种），以及一个自动添加的名为 `Row` 的 id 列。
- en: Dataframes are the *de facto* standard for working with tabular data in Julia.
    They are a key part of Julia's data analysis toolset and we'll discuss them in
    detail in the next chapters. For now, it suffices to say that, as you can see
    in the previous examples, it represents a data structure that looks very much
    like a table or a spreadsheet.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: Dataframes 是 Julia 处理表格数据的 *de facto* 标准。它们是 Julia 数据分析工具集的关键部分，我们将在下一章中详细讨论它们。现在，只需说，正如你在前面的例子中看到的那样，它代表了一种类似于表格或电子表格的数据结构。
- en: 'You can programmatically retrieve the names of the columns using the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式编程地检索列名：
- en: '[PRE128]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'To check the size, use the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查大小，请使用以下方法：
- en: '[PRE129]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The result is a tuple that matches the number of rows and columns—`(rows, cols)`.
    Yep, as already established, `150` rows over `5` columns.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个与行数和列数相匹配的元组 `(rows, cols)`。是的，正如已经确立的，`150` 行跨越 `5` 列。
- en: 'Let''s take a look at the data:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据：
- en: '[PRE130]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The output is as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/7b78cf2e-e2e2-4e20-b09c-caa367d66762.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b78cf2e-e2e2-4e20-b09c-caa367d66762.png)'
- en: 'The `head` function shows the top six rows. Optionally, it takes a second parameter
    to indicate the number of rows: `head(iris, 10)`. There''s also its twin, `tail()`,
    which will display the bottom rows of the `DataFrame`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`head` 函数显示前六行。可选地，它接受第二个参数来指定行数：`head(iris, 10)`。还有一个它的双胞胎函数 `tail()`，它将显示
    `DataFrame` 的底部行：'
- en: '[PRE131]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The output is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/bf1d35bf-2af0-4fc5-87bb-ad0afa39d241.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf1d35bf-2af0-4fc5-87bb-ad0afa39d241.png)'
- en: 'In regard to the species present in the dataset, we see *setosa* in the head
    rows and *virginica* at the bottom. We should have three species, though, according
    to the description of the data. Let''s ask for a row count grouped by `Species`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据集中存在的物种，我们在头部行中看到 *setosa*，在底部看到 *virginica*。然而，根据数据的描述，我们应该有三个物种。让我们按 `Species`
    分组请求行数：
- en: '[PRE132]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The output is as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/6e36265b-8e7d-48e5-bf48-ec8d4e03c2b3.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e36265b-8e7d-48e5-bf48-ec8d4e03c2b3.png)'
- en: The `by` function takes three parameters—the dataset, the name of the column,
    and a grouping function—in this case, `nrow`, which computes the number of rows.
    We can see that the third species is *versicolor*, and for each of the species
    we have `50` records.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`by` 函数接受三个参数——数据集、列名和一个分组函数——在这个例子中，`nrow`，它计算行数。我们可以看到第三种物种是 *versicolor*，对于每种物种，我们都有
    `50` 条记录。'
- en: I'm sure you're wondering why, in the preceding example, the name of the column
    is prefixed by a colon "`:`". It is a `Symbol`. We'll discuss more about symbols
    when we learn about metaprogramming. For now, you can just think of symbols as
    identifiers or labels.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢肯定你一定想知道，在前面的例子中，为什么列名前面有一个冒号 "`:`"。这是一个 `Symbol`。当我们学习到元编程时，我们将更详细地讨论符号。现在，你只需将符号视为标识符或标签即可。
- en: Using simple statistics to better understand our data
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单统计来更好地理解我们的数据
- en: Now that it's clear how the data is structured and what is contained in the
    collection, we can get a better understanding by looking at some basic stats.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经清楚地了解了数据的结构以及集合中包含的内容，我们可以通过查看一些基本统计信息来更好地理解。
- en: 'To get us started, let''s invoke the `describe` function:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们开始，让我们调用 `describe` 函数：
- en: '[PRE133]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The output is as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/053e3457-e544-496c-aaad-f5cd1f81c961.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](img/053e3457-e544-496c-aaad-f5cd1f81c961.png)'
- en: This function summarizes the columns of the `iris` `DataFrame`. If the columns
    contain numerical data (such as `SepalLength`), it will compute the minimum, median,
    mean, and maximum. The number of missing and unique values is also included. The
    last column reports the type of data stored in the row.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数总结了 `iris` `DataFrame` 的列。如果列包含数值数据（如 `SepalLength`），它将计算最小值、中位数、平均值和最大值。还包括缺失值和唯一值的数量。最后一列报告存储在行中的数据类型。
- en: 'A few other stats are available, including the 25^(th) and the 75^(th) percentile,
    and the first and the last values. We can ask for them by passing an extra `stats`
    argument, in the form of an array of symbols:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他统计信息也是可用的，包括第 25 百分位和第 75 百分位，以及第一个和最后一个值。我们可以通过传递一个额外的 `stats` 参数来请求它们，该参数是一个符号数组的格式：
- en: '[PRE134]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The output is as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/0634a453-5f96-45eb-9df7-a0b496f89aa3.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0634a453-5f96-45eb-9df7-a0b496f89aa3.png)'
- en: Any combination of stats labels is accepted. These are all the options—`:mean`,
    `:std`, `:min`, `:q25`, `:median`, `:q75`, `:max`, `:eltype`, `:nunique`, `:first`,
    `:last`, and `:nmissing`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 接受任何组合的统计标签。这些都是所有选项——`:mean`、`:std`、`:min`、`:q25`、`:median`、`:q75`、`:max`、`:eltype`、`:nunique`、`:first`、`:last`
    和 `:nmissing`。
- en: 'In order to get all the stats, the special `:all` value is accepted:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取所有统计信息，接受特殊的 `:all` 值：
- en: '[PRE135]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The output is as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/35176292-d49a-4cfa-a733-5387879f8d0a.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35176292-d49a-4cfa-a733-5387879f8d0a.png)'
- en: 'We can also compute these individually by using Julia''s `Statistics` package.
    For example, to calculate the mean of the `SepalLength` column, we''ll execute
    the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用 Julia 的 `Statistics` 包单独计算这些值。例如，要计算 `SepalLength` 列的平均值，我们将执行以下操作：
- en: '[PRE136]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In this example, we use `iris[:SepalLength]` to select the whole column. The
    result, not at all surprisingly, is the same as that returned by the corresponding
    `describe()` value.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `iris[:SepalLength]` 来选择整个列。结果，毫不意外，与相应的 `describe()` 返回值相同。
- en: 'In a similar way we can compute the `median()`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以计算 `median()`：
- en: '[PRE137]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'And there''s (a lot) more, such as, for instance, the standard deviation `std()`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多（很多）内容，例如，例如，标准差 `std()`：
- en: '[PRE138]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Or, we can use another function from the `Statistics` package, `cor(),` in
    a simple script to help us understand how the values are correlated:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `Statistics` 包中的另一个函数 `cor()`，在简单的脚本中帮助我们了解值之间的相关性：
- en: '[PRE139]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Executing this snippet will produce the following output:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码片段将产生以下输出：
- en: '[PRE140]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The script iterates over each column of the dataset with the exception of `Species`
    (the last column, which is not numeric), and generates a basic correlation table.
    The table shows strong positive correlations between `SepalLength` and `PetalLength`
    (87.17%), `SepalLength` and `PetalWidth` (81.79%), and `PetalLength` and `PetalWidth`
    (96.28%). There is no strong correlation between `SepalLength` and `SepalWidth`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本遍历数据集的每一列，除了 `Species`（最后一列，不是数值类型），并生成一个基本的关联表。该表显示 `SepalLength` 与 `PetalLength`（87.17%）、`SepalLength`
    与 `PetalWidth`（81.79%）、以及 `PetalLength` 与 `PetalWidth`（96.28%）之间存在强烈的正相关。`SepalLength`
    与 `SepalWidth` 之间没有强烈的关联。
- en: 'We can use the same script, but this time employ the `cov()` function to compute
    the covariance of the values in the dataset:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的脚本，但这次使用 `cov()` 函数来计算数据集中值的协方差：
- en: '[PRE141]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'This code will generate the following output:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将生成以下输出：
- en: '[PRE142]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The output illustrates that `SepalLength` is positively related to `PetalLength`
    and `PetalWidth`, while being negatively related to `SepalWidth`. `SepalWidth`
    is negatively related to all the other values.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 输出说明了 `SepalLength` 与 `PetalLength` 和 `PetalWidth` 正相关，而与 `SepalWidth` 负相关。`SepalWidth`
    与所有其他值负相关。
- en: 'Moving on, if we want a random data sample, we can ask for it like this:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们想要一个随机数据样本，我们可以这样请求：
- en: '[PRE143]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Optionally, we can pass in the number of values to be sampled:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以传递要采样的值的数量：
- en: '[PRE144]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'We can convert one of the columns to an array using the following:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方法将某一列转换为数组：
- en: '[PRE145]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Or we can convert the whole `DataFrame` to a matrix:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将整个 `DataFrame` 转换为矩阵：
- en: '[PRE146]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Visualizing the Iris flowers data
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化鸢尾花数据
- en: Visualization is a powerful tool in exploratory data analysis, helping us to
    identify patterns that would otherwise be hard to spot just by looking at the
    numbers. Julia provides access to some excellent plotting packages that are very
    easy to set up and use.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是探索性数据分析中的强大工具，帮助我们识别仅通过查看数字难以发现的模式。Julia提供了访问一些出色的绘图包的途径，这些包非常容易设置和使用。
- en: We'll illustrate with some plots created with Gadfly.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用Gadfly创建的一些图表来举例说明。
- en: We'll start by adding Gadfly with `pkg> add "Gadfly"`and we'll continue with `julia>
    using Gadfly`. This will bring into scope Gadfly's `plot()`method. Now, let's
    find some interesting data to visualize.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过`pkg> add "Gadfly"`添加Gadfly，然后继续使用`julia> using Gadfly`。这将使Gadfly的`plot()`方法生效。现在，让我们找到一些有趣的数据来进行可视化。
- en: 'In the previous section, we have identified that there is a strong covariant
    relation between `SepalLength` and `PetalLength`. Let''s plot the data:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经确定`SepalLength`和`PetalLength`之间存在强烈的协变关系。让我们绘制这些数据：
- en: '[PRE147]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: At the time of writing, Gadfly support for Julia v1 was still incomplete. If
    that is still the case, the unstable yet working version of Gadfly can be installed
    using—`pkg> add Compose#master`, `Gadfly#master`, `Hexagon`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Gadfly对Julia v1的支持仍然不完整。如果情况仍然如此，可以使用不稳定但可工作的Gadfly版本安装——`pkg> add Compose#master`,
    `Gadfly#master`, `Hexagon`。
- en: 'Executing the `plot()` function will generate the following graph:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`plot()`函数将生成以下图形：
- en: '![](img/e5e56a6c-c9ce-481c-90b7-fd66be5bca88.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5e56a6c-c9ce-481c-90b7-fd66be5bca88.png)'
- en: Sure enough, the plot will indicate that `SepalLength` and `PetalLength` vary
    together for both Iris versicolor and Iris virginica. For Iris setosa, it's not
    that obvious, with `PetalLength` staying pretty much unchanged while the sepal
    length grows.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，该图将表明对于Iris versicolor和Iris virginica，`SepalLength`和`PetalLength`是共同变化的。对于Iris
    setosa，这并不那么明显，因为`PetalLength`基本保持不变，而萼片长度在增长。
- en: 'A box plot will confirm the same; the sepal length of Iris setosa has little
    variation:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图将确认相同的结果；Iris setosa的萼片长度变化很小：
- en: '[PRE148]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Plotting our values looks like this:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制值的样子如下：
- en: '![](img/71de0a21-e932-406e-9471-8b014ac3fda1.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71de0a21-e932-406e-9471-8b014ac3fda1.png)'
- en: 'I have a feeling that a histogram would be even better for illustrating the
    distribution of the `PetalLength`:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一种感觉，直方图将更好地说明`PetalLength`的分布：
- en: '[PRE149]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Generating a histogram using the `PetalLength` produces the following:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PetalLength`生成直方图会产生以下结果：
- en: '![](img/e9b3d8b8-1a4c-4786-943c-b6776713a4d7.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9b3d8b8-1a4c-4786-943c-b6776713a4d7.png)'
- en: 'If we visualize the `PetalWidth` values as a histogram, we''ll notice a similar
    pattern:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`PetalWidth`值可视化为直方图，我们会注意到类似的模式：
- en: '[PRE150]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The output is as follows:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/cbea6825-f0aa-4f35-b41e-51223b2c175f.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbea6825-f0aa-4f35-b41e-51223b2c175f.png)'
- en: 'Plotting the petal width and height for the three species should now provide
    a strong indication that, for example, we can successfully classify Iris setosa
    based on the two values:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制三种物种的花瓣宽度和高度图，现在应该能强烈表明，例如，我们可以根据这两个值成功地将鸢尾花属的Iris setosa进行分类：
- en: '[PRE151]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The output is as follows:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/28ab11d2-ba23-4f48-839c-eb529e1679f8.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28ab11d2-ba23-4f48-839c-eb529e1679f8.png)'
- en: Loading and saving our data
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和保存我们的数据
- en: Julia comes with excellent facilities for reading and storing data out of the
    box. Given its focus on data science and scientific computing, support for tabular-file
    formats (CSV, TSV) is first class.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Julia自带了出色的读取和存储数据的工具。鉴于其专注于数据科学和科学计算，对表格文件格式（CSV，TSV）的支持是一流的。
- en: Let's extract some data from our initial dataset and use it to practice persistence
    and retrieval from various backends.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的初始数据集中提取一些数据，并使用它来练习从各种后端进行持久化和检索。
- en: 'We can reference a section of a `DataFrame` by defining its bounds through
    the corresponding columns and rows. For example, we can define a new `DataFrame`
    composed only of the `PetalLength` and `PetalWidth` columns and the first three
    rows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义相应的列和行来引用`DataFrame`的某个部分。例如，我们可以定义一个新的`DataFrame`，它仅由`PetalLength`和`PetalWidth`列以及前三个行组成：
- en: '[PRE152]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The generic indexing notation is `dataframe[rows, cols]`, where `rows` can
    be a number, a range, or an `Array` of `boolean` values where `true` indicates
    that the row should be included:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通用索引符号是`dataframe[rows, cols]`，其中`rows`可以是数字、范围或`boolean`值的`Array`，其中`true`表示该行应被包含：
- en: '[PRE153]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Armed with this knowledge, let''s take a sample from our original dataset.
    It will include some 10% of the initial data and only the `PetalLength`, `PetalWidth`,
    and `Species` columns:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，让我们从原始数据集中抽取一个样本。它将包括大约 10% 的初始数据，以及 `PetalLength`、`PetalWidth` 和 `Species`
    列：
- en: '[PRE154]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: What just happened here? The secret in this piece of code is `rand(150) .<=
    0.1`. It does a lot—first, it generates an array of random `Float` values between
    0 and 1; then, it compares the array, element-wise, against 0.1 (which represents
    10% of 1); and finally, the resultant `Boolean` array is used to filter out the
    corresponding rows from the dataset. It's really impressive how powerful and succinct
    Julia can be!
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？这段代码的秘密在于 `rand(150) .<= 0.1`。它做了很多事情——首先，它生成一个介于 0 和 1 之间的随机 `Float`
    值数组；然后，它逐元素比较数组与 0.1（代表 1 的 10%）；最后，生成的 `Boolean` 数组用于从数据集中过滤出相应的行。Julia 的强大和简洁真的令人印象深刻！
- en: In my case, the result is a `DataFrame` with the preceding 10 rows, but your
    data will be different since we're picking random rows (and it's quite possible
    you won't have exactly 10 rows either).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，结果是包含前面 10 行的 `DataFrame`，但你的数据可能会有所不同，因为我们正在选择随机行（而且你也不一定有 exactly 10
    行）。
- en: Saving and loading using tabular file formats
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表格文件格式进行保存和加载
- en: 'We can easily save this data to a file in a tabular file format (one of CSV,
    TSV, and others) using the `CSV` package. We''ll have to add it first and then
    call the `write` method:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `CSV` 包轻松地将这些数据保存到表格文件格式（CSV、TSV 等之一）的文件中。我们首先需要添加它，然后调用 `write` 方法：
- en: '[PRE155]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'And, just as easily, we can read back the data from tabular file formats, with
    the corresponding `CSV.read` function:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 同样容易，我们可以使用相应的 `CSV.read` 函数从表格文件格式中读取数据：
- en: '[PRE156]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Just specifying the file extension is enough for Julia to understand how to
    handle the document (CSV, TSV), both when writing and reading.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 仅指定文件扩展名就足以让 Julia 理解如何处理文档（CSV、TSV），无论是写入还是读取。
- en: Working with Feather files
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Feather 文件
- en: Feather is a binary file format that was specially designed for storing data
    frames. It is fast, lightweight, and language-agnostic. The project was initially
    started in order to make it possible to exchange data frames between R and Python.
    Soon, other languages added support for it, including Julia.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Feather 是一种专门为存储数据框而设计的二进制文件格式。它快速、轻量级且语言无关。该项目最初启动是为了使 R 和 Python 之间交换数据框成为可能。很快，其他语言也添加了对它的支持，包括
    Julia。
- en: 'Support for Feather files does not come out of the box, but is made available
    through the homonymous package. Let''s go ahead and add it and then bring it into
    scope:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Feather 文件的支持不是默认提供的，但可以通过同名的包获得。让我们继续添加它并将其纳入作用域：
- en: '[PRE157]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Now, saving our `DataFrame` is just a matter of calling `Feather.write`:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存我们的 `DataFrame` 只需调用 `Feather.write`：
- en: '[PRE158]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Next, let''s try the reverse operation and load back our Feather file. We''ll
    use the counterpart `read` function:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试反向操作并重新加载我们的 Feather 文件。我们将使用对应的 `read` 函数：
- en: '[PRE159]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Yeah, that's our sample data all right!
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这正是我们的样本数据！
- en: In order to provide compatibility with other languages, the Feather format imposes
    some restrictions on the data types of the columns. You can read more about Feather
    in the package's official documentation at [https://juliadata.github.io/Feather.jl/latest/index.html](https://juliadata.github.io/Feather.jl/latest/index.html).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与其他语言提供兼容性，Feather 格式对列的数据类型施加了一些限制。你可以在包的官方文档中了解更多关于 Feather 的信息：[https://juliadata.github.io/Feather.jl/latest/index.html](https://juliadata.github.io/Feather.jl/latest/index.html)。
- en: Saving and loading with MongoDB
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 进行保存和加载
- en: Before closing this chapter, let's take a look at using a NoSQL backend for
    persisting and retrieving our data. Don't worry, we'll extensively cover interaction
    with relational databases in the upcoming chapters too.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭这一章之前，让我们看看如何使用 NoSQL 后端来持久化和检索我们的数据。别担心，我们将在接下来的章节中广泛介绍与关系型数据库的交互。
- en: In order to follow through this chapter, you'll need a working MongoDB installation.
    You can download and install the correct version for your operating system from
    the official website, at [https://www.mongodb.com/download-center?jmp=nav#community](https://www.mongodb.com/download-center?jmp=nav#community).
    I will use a Docker image which I installed and started up through Docker's Kitematic
    (available for download at [https://github.com/docker/kitematic/releases](https://github.com/docker/kitematic/releases)).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续本章内容，你需要一个可工作的MongoDB安装。你可以从官方网站下载并安装适用于你操作系统的正确版本，网址为[https://www.mongodb.com/download-center?jmp=nav#community](https://www.mongodb.com/download-center?jmp=nav#community)。我将使用一个通过Docker的Kitematic（可在[https://github.com/docker/kitematic/releases](https://github.com/docker/kitematic/releases)下载）安装并启动的Docker镜像。
- en: 'Next, we need to make sure to add the `Mongo` package. The package also has
    a dependency on `LibBSON`, which is automatically added. `LibBSON` is used for
    handling `BSON`, which stands for *Binary JSON*, a binary-encoded serialization
    of JSON-like documents. While we''re at it, let''s add the `JSON` package as well;
    we will need it. I''m sure you know how to do that by now—if not, here is a reminder:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保添加`Mongo`包。该包还依赖于`LibBSON`，它将自动添加。`LibBSON`用于处理`BSON`，即*二进制JSON*，类似于JSON的文档的二进制编码序列化。在此期间，让我们也添加`JSON`包；我们将需要它。我相信你现在知道如何做——如果不的话，这里有一个提醒：
- en: '[PRE160]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: At the time of writing, Mongo.jl support for Julia v1 was still a work in progress.
    This code was tested using Julia v0.6.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Mongo.jl对Julia v1的支持仍在进行中。此代码使用Julia v0.6进行了测试。
- en: 'Easy! Let''s let Julia know that we''ll be using all these packages:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！让我们让Julia知道我们将使用所有这些包：
- en: '[PRE161]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'We''re now ready to connect to MongoDB:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好连接到MongoDB：
- en: '[PRE162]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Once successfully connected, we can reference a `dataframes` collection in
    the `db` database:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功连接，我们就可以在`db`数据库中引用`dataframes`集合：
- en: '[PRE163]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Julia''s MongoDB interface uses dictionaries (a data structure called `Dict`
    in Julia) to communicate with the server. We''ll look at `dicts` in more detail
    in the next chapter. For now, all we need to do is to convert our `DataFrame`
    to such a `Dict`. The simplest way to do it is to sequentially serialize and then
    deserialize the `DataFrame` by using the `JSON` package. It generates a nice structure
    that we can later use to rebuild our `DataFrame`:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的MongoDB接口使用字典（在Julia中称为`Dict`的数据结构）与服务器通信。我们将在下一章中更详细地了解`dicts`。现在，我们只需要将我们的`DataFrame`转换为这样的`Dict`。最简单的方法是使用`JSON`包按顺序序列化和反序列化`DataFrame`。它生成一个很好的结构，我们可以稍后使用它来重建我们的`DataFrame`：
- en: '[PRE164]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Thinking ahead, to make any future data retrieval simpler, let''s add an identifier
    to our dictionary:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 提前思考，为了使未来的数据检索更简单，让我们在我们的字典中添加一个标识符：
- en: '[PRE165]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Now we can insert it into Mongo:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将其插入Mongo数据库中：
- en: '[PRE166]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'In order to retrieve it, all we have to do is query the Mongo database using
    the "id" field we''ve previously configured:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索它，我们只需使用之前配置的“id”字段查询Mongo数据库：
- en: '[PRE167]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'We get a `BSONObject`, which we need to convert back to a `DataFrame`. Don''t
    worry, it''s straightforward. First, we create an empty `DataFrame`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个`BSONObject`，我们需要将其转换回`DataFrame`。别担心，这很简单。首先，我们创建一个空的`DataFrame`：
- en: '[PRE168]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Then we populate it using the data we retrieved from Mongo:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用从Mongo检索到的数据填充它：
- en: '[PRE169]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: And that's it! Our data has been loaded back into a `DataFrame`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们的数据已经重新加载到`DataFrame`中。
- en: Summary
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Julia's intuitive syntax makes for a lean learning curve. The optional typing
    and the wealth of shorthand constructors result in readable, noise-free code,
    while the large collection of third-party packages makes accessing, manipulating,
    visualizing, plotting, and saving data a breeze.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Julia直观的语法使得学习曲线变得平缓。可选的类型和丰富的缩写构造函数使得代码可读、无噪声，而大量的第三方包使得访问、操作、可视化、绘图和保存数据变得轻而易举。
- en: Just by learning Julia's basic data structures and a few related functions,
    coupled with its powerful data manipulation toolset, we were able to implement
    an efficient data analysis workflow and extract valuable insight from the Iris
    flowers dataset. That was all we needed in order to perform efficient exploratory
    data analysis with Julia.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 只需学习Julia的基本数据结构和一些相关函数，再加上其强大的数据处理工具集，我们就能够实现高效的数据分析工作流程，并从Iris花朵数据集中提取有价值的见解。这正是我们使用Julia进行高效探索性数据分析所需的一切。
- en: In the next chapter, we'll continue our journey by learning how to build a web
    crawler. Web mining, the process of extracting information from the web, is an
    important part of data mining and a key component of data acquisition in general.
    Julia is a great choice when building web mining software, given not only its
    built-in performance and its rapid prototyping features, but also the availability
    of powerful libraries that cover everything, from HTTP clients, to DOM parsing,
    to text analysis.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的旅程，学习如何构建一个网络爬虫。网络挖掘，即从网络中提取信息的过程，是数据挖掘的重要组成部分，也是数据获取的关键环节。在构建网络挖掘软件时，Julia是一个极佳的选择，这不仅因为它内置的性能和快速原型设计功能，还因为其提供了覆盖从HTTP客户端到DOM解析再到文本分析的强大库。
