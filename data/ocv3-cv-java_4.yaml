- en: Chapter 4. Image Transforms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：图像变换
- en: This chapter covers the methods to change an image into an alternate representation
    of data in order to cover important problems of computer vision and image processing.
    Some examples of these methods are artifacts that are used to find image edges
    as well as transforms that help us find lines and circles in an image. In this
    chapter, we have covered stretch, shrink, warp, and rotate operations. A very
    useful and famous transform is Fourier, which transforms signals between the time
    domain and frequency domain. In OpenCV, you can find the **Discrete Fourier Transform**
    (**DFT**) and **Discrete Cosine Transform** (**DCT**). Another transform that
    we've covered in this chapter is related to integral images that allow rapid summing
    of sub regions, which is a very useful step in tracking faces algorithm. Besides
    this, you will also get to see distance transform and histogram equalization in
    this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了将图像转换为数据不同表示的方法，以涵盖计算机视觉和图像处理的重要问题。这些方法的一些示例是用于寻找图像边缘的伪影以及帮助我们找到图像中线条和圆的变换。在本章中，我们介绍了拉伸、收缩、扭曲和旋转操作。一个非常有用且著名的变换是傅里叶变换，它将信号在时域和频率域之间转换。在
    OpenCV 中，你可以找到**离散傅里叶变换**（**DFT**）和**离散余弦变换**（**DCT**）。本章我们还介绍了一种与积分图像相关的变换，它允许快速求和子区域，这在人脸追踪算法中是一个非常有用的步骤。此外，本章还将介绍距离变换和直方图均衡化。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Gradients and sobel derivatives
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梯度和 Sobel 导数
- en: The Laplace and canny transforms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉普拉斯和 Canny 变换
- en: The line and circle Hough transforms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线和圆 Hough 变换
- en: 'Geometric transforms: stretch, shrink, warp, and rotate'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何变换：拉伸、收缩、扭曲和旋转
- en: Discrete Fourier Transform (DFT) and Discrete Cosine Transform (DCT)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离散傅里叶变换 (DFT) 和离散余弦变换 (DCT)
- en: Integral images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数图像
- en: Distance transforms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离变换
- en: Histogram equalization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: By the end of this chapter, you will have learned a handful of transforms that
    will enable you to find edges, lines, and circles in images. Besides, you will
    be able to stretch, shrink, warp, and rotate images as well as you will be able
    to change the domain from the spatial domain to the frequency domain. Other important
    transforms used for face tracking will be covered in this chapter as well. Finally,
    distance transforms and histogram equalization will also be explored in detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会一些变换，这些变换将使你能够在图像中找到边缘、线和圆。此外，你将能够拉伸、收缩、扭曲和旋转图像，以及将域从空间域转换为频率域。本章还将涵盖用于人脸追踪的其他重要变换。最后，距离变换和直方图均衡化也将被详细探讨。
- en: The Gradient and Sobel derivatives
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 梯度与 Sobel 导数
- en: A key building block in computer vision is finding edges and this is closely
    related to finding an approximation to derivatives in an image. From basic calculus,
    it is known that a derivative shows the variation of a given function or an input
    signal with some dimension. When we find the local maximum of the derivative,
    this will yield regions where the signal varies the most, which for an image might
    mean an edge. Hopefully, there's an easy way to approximate a derivative for discrete
    signals through a kernel convolution. A convolution basically means applying some
    transforms to every part of the image. The most used transform for differentiation
    is the Sobel filter [1], which works for horizontal, vertical, and even mixed
    partial derivatives of any order.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉的一个关键构建块是寻找边缘，这与在图像中寻找导数的近似密切相关。从基本的微积分中我们知道，导数显示了给定函数或输入信号随某个维度的变化。当我们找到导数的局部最大值时，这将产生信号变化最大的区域，对于图像来说可能意味着边缘。希望有一种简单的方法可以通过核卷积来近似离散信号的导数。卷积基本上意味着将某些变换应用于图像的每一部分。最常用于微分的是
    Sobel 滤波器 [1]，它适用于水平、垂直甚至任何阶数的混合偏导数。
- en: 'In order to approximate the value for the horizontal derivative, the following
    sobel kernel matrix is convoluted with an input image:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了近似水平导数的值，以下 Sobel 核矩阵与输入图像进行卷积：
- en: '![The Gradient and Sobel derivatives](img/3972OS_04_12.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![梯度与 Sobel 导数](img/3972OS_04_12.jpg)'
- en: 'This means that, for each input pixel, the calculated value of its upper-right
    neighbor plus twice its right neighbor, plus its bottom-right neighbor, minus
    its upper-left neighbor, minus its left neighbor, minus its left-bottom neighbor
    will be calculated, yielding a resulting image. In order to use this operator
    in OpenCV, you can call Imgproc''s `Sobel` function according to the following
    signature:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，对于每个输入像素，将计算其右上角邻居的值加上两倍其右侧邻居的值，加上其右下角邻居的值，减去其左上角邻居的值，减去其左侧邻居的值，减去其左下角邻居的值，从而得到一个结果图像。为了在OpenCV中使用此算子，您可以按照以下签名调用Imgproc的`Sobel`函数：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `src` parameter is the input image and `dst` is the output. `Ddepth` is
    the output image''s depth and when this is assigned as `-1`, this has the same
    depth as the source. The `dx` and `dy` parameters will inform us about the order
    in each of these directions. When setting `dy` to `0` and `dx` to `1`, the kernel
    that we''ve used is the one mentioned in the preceding matrix. The example project
    `kernels` from this chapter shows a customizable look of these operators, as shown
    in the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`参数是输入图像，`dst`是输出。`Ddepth`是输出图像的深度，当将其设置为`-1`时，它将与源图像具有相同的深度。`dx`和`dy`参数将告诉我们每个方向中的顺序。当将`dy`设置为`0`，`dx`设置为`1`时，我们使用的核就是前面矩阵中提到的核。本章的示例项目`kernels`展示了这些算子的可定制外观，如下面的截图所示：'
- en: '![The Gradient and Sobel derivatives](img/3972OS_04_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![梯度与Sobel导数](img/3972OS_04_01.jpg)'
- en: The Laplace and Canny transforms
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉普拉斯和Canny变换
- en: 'Another quite useful operator to find edges is the Laplacian transformation.
    Instead of relying on the first order derivatives, OpenCV''s Laplacian transformation
    implements the discrete operator for the following function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的算子用于查找边缘的是拉普拉斯变换。而不是依赖于一阶导数，OpenCV的拉普拉斯变换实现了以下函数的离散算子：
- en: '![The Laplace and Canny transforms](img/3972OS_04_13.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![拉普拉斯和Canny变换](img/3972OS_04_13.jpg)'
- en: 'The matrix can be approximated to the convolution with the following kernel
    when using finite difference methods and a 3x3 aperture:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用有限差分方法和3x3窗口时，矩阵可以近似为以下核的卷积：
- en: '![The Laplace and Canny transforms](img/3972OS_04_14.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![拉普拉斯和Canny变换](img/3972OS_04_14.jpg)'
- en: 'The signature for the preceding function is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前述函数的签名如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While source and destination matrices are simple parameters, `ddepth` is the
    depth of the destination matrix. When you set this parameter to `-1`, it will
    have the same depth as the source image, although you might want more depth when
    you apply this operator. Besides this, there are overloaded versions of this method
    that receive an aperture size, a scale factor, and an adding scalar.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然源和目标矩阵是简单的参数，但`ddepth`是目标矩阵的深度。当您将此参数设置为`-1`时，它将与源图像具有相同的深度，尽管在应用此算子时您可能需要更多的深度。此外，此方法还有重载版本，它接收窗口大小、缩放因子和加法标量。
- en: 'Besides using the Laplacian method, you can also use the Canny algorithm, which
    is an excellent approach that was proposed by computer scientist John F. Canny,
    who optimized edge detection for low error rate, single identification, and correct
    localization. In order to fulfill it, the Canny algorithm applies a Gaussian to
    filter the noise, calculates intensity gradients through sobel, suppresses spurious
    responses, and applies double thresholds followed by a hysteresis that suppresses
    the weak and unconnected edges. For more information, check this paper [2]. The
    method''s signature is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用拉普拉斯方法外，您还可以使用Canny算法，这是一种由计算机科学家John F. Canny提出的优秀方法，他优化了边缘检测以实现低错误率、单次识别和正确定位。为了实现这一点，Canny算法应用高斯滤波器以过滤噪声，通过Sobel计算强度梯度，抑制虚假响应，并应用双阈值，随后通过滞后抑制弱和不连续的边缘。有关更多信息，请参阅这篇论文[2]。该方法签名如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `image` parameter is the input matrix, `edges` is the output image, `threshold1`
    is the first threshold for the hysteresis procedure (values smaller than this
    will be ignored), and `threshold2` is the high threshold for hysteresis (values
    higher than this will be considered as strong edges, while the smaller values
    and the ones higher than the low threshold will be checked for connection with
    strong edges). The aperture size is used for the Sobel operator when calculating
    the gradient and the `boolean` informs us which norm to use for the gradient.
    You can also check out the source code to use this operator in the kernel's project
    sample in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`参数是输入矩阵，`edges`是输出图像，`threshold1`是阈值化过程的第一阈值（小于此值的值将被忽略），而`threshold2`是阈值化过程的高阈值（高于此值的值将被视为强边缘，而较小的值和高于低阈值的值将检查与强边缘的连接）。孔径大小用于计算梯度时的Sobel算子，而`boolean`告诉我们使用哪个范数来计算梯度。您还可以查看源代码，以了解如何在内核的项目示例中使用此算子。'
- en: The line and circle Hough transforms
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直线和圆的霍夫变换
- en: In case you need to find straight lines or circles in an image, you can use
    Hough transforms, as they are very useful. In this section, we will cover OpenCV
    methods to extract them from your image.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在图像中找到直线或圆，可以使用霍夫变换，因为它们非常有用。在本节中，我们将介绍OpenCV方法来从您的图像中提取它们。
- en: The idea behind the original Hough line transform is that any point in a binary
    image could be part of a set of lines. Suppose each straight line could be parameterized
    by the *y =* *mx + b* line equation, where *m* is the line slope and *b* is the
    *y* axis intercept of this line. Now, we could iterate the whole binary image,
    storing each of the *m* and *b* parameters and checking their accumulation. The
    local maximum points of the *m* and *b* parameters would yield equations of straight
    lines that mostly appeared in the image. Actually, instead of using the slope
    and *y* axis interception point, we use the polar straight line representation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 原始霍夫线变换背后的思想是，二值图像中的任何点都可能是一组线条的一部分。假设每条直线都可以用直线方程 *y = mx + b* 来参数化，其中 *m*
    是直线的斜率，*b* 是这条线的 *y* 轴截距。现在，我们可以迭代整个二值图像，存储每个 *m* 和 *b* 参数并检查它们的累积。*m* 和 *b* 参数的局部最大值将产生在图像中出现的直线的方程。实际上，我们不是使用斜率和
    *y* 轴截距点，而是使用极坐标直线表示。
- en: 'Since OpenCV not only supports the standard Hough transform, but also the progressive
    probabilistic Hough transform for which the two functions are `Imgproc.HoughLines`
    and `Imgproc.HoughLinesP`, respectively. For detailed information, refer to [3].
    These functions'' signatures are explained as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于OpenCV不仅支持标准的霍夫变换，还支持渐进概率霍夫变换，其中两个函数分别是`Imgproc.HoughLines`和`Imgproc.HoughLinesP`。有关详细信息，请参阅[3]。这些函数的签名如下：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `hough` project from this chapter shows an example of the usage of them.
    The following is the code to retrieve lines from `Imgproc.HoughLines`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的`hough`项目展示了使用它们的示例。以下是从`Imgproc.HoughLines`检索线条的代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we need to apply the Hough transform over an edge image; therefore,
    the first two lines of the preceding code will take care of this. Then, the original
    image is cloned for display and a `Mat` object is created in the fourth line in
    order to keep the lines. In the last line, we can see the application of `HoughLines`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要在边缘图像上应用霍夫变换；因此，前两行代码将处理此问题。然后，原始图像被克隆以供显示，并在第四行创建一个`Mat`对象以保持线条。在最后一行，我们可以看到`HoughLines`的应用。
- en: 'The third parameter in `Imgproc.HoughLines` refers to the distance resolution
    of the accumulator in pixels, while the fourth parameter is the angle resolution
    of the accumulator in radians. The fifth parameter is the accumulator threshold,
    which means that only the lines with more than the specified amount of votes will
    be returned. The `lowThreshold` variable is tied to the scale slider in the example
    application for the user to experiment with it. It is important to observe that
    the lines are returned in the `lines` matrix, which has two columns in which each
    line returns the `rho` and `theta` parameters of the polar coordinates. These
    coordinates refer to the distance between the top-left corner of the image and
    the line rotation in radians, respectively. Following this example, you will find
    out how to draw the lines from the returned matrix. You can see the working of
    the Hough transform in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Imgproc.HoughLines`中的第三个参数指的是累加器在像素中的距离分辨率，第四个参数是累加器在弧度中的角度分辨率。第五个参数是累加器阈值，这意味着只有获得超过指定数量票数的线才会被返回。`lowThreshold`变量与示例应用程序中的缩放滑块相关联，以便用户可以对其进行实验。重要的是要注意，线被返回在`lines`矩阵中，该矩阵有两列，其中每条线返回极坐标的`rho`和`theta`参数。这些坐标分别指的是图像左上角与线的旋转之间的距离以及弧度。根据此示例，您将了解如何从返回的矩阵中绘制线。您可以在以下截图中看到霍夫变换的工作原理：'
- en: '![The line and circle Hough transforms](img/3972OS_04_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![线和圆霍夫变换](img/3972OS_04_02.jpg)'
- en: 'Besides having the standard Hough transform, OpenCV also offers a probabilistic
    Hough line transform as well as a circular version. Both the implementations are
    explored in the same `Hough` sample project, and the following screenshot shows
    the working of the circular version:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的霍夫变换外，OpenCV还提供了概率霍夫线变换以及圆形版本。这两个实现都在同一个`Hough`示例项目中进行了探索，以下截图显示了圆形版本的工作原理：
- en: '![The line and circle Hough transforms](img/3972OS_04_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![线和圆霍夫变换](img/3972OS_04_03.jpg)'
- en: Geometric transforms – stretch, shrink, warp, and rotate
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何变换 – 拉伸、收缩、扭曲和旋转
- en: While working with images and computer vision, it is very common that you will
    require the ability to preprocess an image using known geometric transforms, such
    as stretching, shrinking, rotation, and warping. The latter is the same as nonuniform
    resizing. These transforms can be realized through the multiplication of source
    points with a 2 x 3 matrix and they get the name of **affine transformations**
    while turning rectangles in parallelograms. Hence, they have the limitation of
    requiring the destination to have parallel sides. On the other hand, a 3 x 3 matrix
    multiplication represents perspective transforms. They offer more flexibility
    since they can map a 2D quadrilateral to another. The following screenshot shows
    a very useful application of this concept.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理图像和计算机视觉时，您通常会需要使用已知的几何变换来预处理图像，例如拉伸、收缩、旋转和扭曲。后者与非均匀缩放相同。这些变换可以通过将源点与2 x
    3矩阵相乘来实现，并且它们在将矩形转换为平行四边形时被称为**仿射变换**。因此，它们具有要求目标具有平行边的限制。另一方面，3 x 3矩阵的乘法表示透视变换。它们提供了更多的灵活性，因为它们可以将二维四边形映射到另一个四边形。以下截图显示了这一概念的一个非常有用的应用。
- en: 'Here, we will find out which is the perspective transform that maps the side
    of a building in a perspective view to its frontal view:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将找出哪个透视变换将建筑侧面的透视视图映射到其正面视图：
- en: '![Geometric transforms – stretch, shrink, warp, and rotate](img/3972OS_04_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![几何变换 – 拉伸、收缩、扭曲和旋转](img/3972OS_04_04.jpg)'
- en: Note that the input to this problem is the perspective photograph of the building,
    which is seen on the left-hand side of the preceding image, as well as the four
    corner points of the highlighted quadrilateral shape. The output is to the right
    and shows what a viewer would see if he/she looks at the side of the building.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该问题的输入是建筑物的透视照片，如图像左侧所示，以及突出显示的四边形形状的四个角点。输出在右侧，显示了如果观察者从建筑侧面看会看到的内容。
- en: 'Since affine transforms are a subset of perspective transformations, we will
    focus on the latter ones here. The code available for this example is in the `warps`
    project of this chapter. The main method used here is `warpPerspective` from `Imgproc`.
    It applies a perspective transformation to an input image. Here is the method
    signature for the `warpPerspective` method:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仿射变换是透视变换的子集，因此我们将重点关注后者。本例中可用的代码位于本章的 `warps` 项目中。这里使用的主要方法是 `Imgproc` 中的
    `warpPerspective`。它对输入图像应用透视变换。以下是 `warpPerspective` 方法的签名：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Mat src` parameter is, naturally, the input image, which is the left-hand
    side image in the preceding screenshot, while `dst Mat` is the image on the right-hand
    side; make sure you initialize this parameter before using the method. The not-so-straightforward
    parameter here is `Mat M`, which is the warping matrix. In order to calculate
    it, you can use the `getPerspectiveTransform` method from `Imgproc` as well. This
    method will calculate the perspective matrix from two sets of the four correlated
    2D points, the source and destination points. In our example, the source points
    are the ones that are highlighted on the left-hand side of the screenshot, while
    the destination points are the four corner points of the image to the right. These
    points can be stored through the `MatOfPoint2f` class, which stores the `Point`
    objects. The `getPerspectiveTransform` method''s signature is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat src` 参数自然是输入图像，即前一张截图中的左侧图像，而 `dst Mat` 是右侧的图像；在使用方法之前，请确保初始化此参数。这里不太直观的参数是
    `Mat M`，它是变换矩阵。为了计算它，你可以使用 `Imgproc` 中的 `getPerspectiveTransform` 方法。该方法将从两组相关的四个二维点（源点和目标点）计算透视矩阵。在我们的例子中，源点是截图左侧突出显示的点，而目标点是右侧图像的四个角点。这些点可以通过
    `MatOfPoint2f` 类存储，该类存储 `Point` 对象。`getPerspectiveTransform` 方法的签名如下：'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Mat src` and `Mat dst` are the same as the `MatOfPoint2f` class mentioned
    previously, which is a subclass of `Mat`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat src` 和 `Mat dst` 与之前提到的 `MatOfPoint2f` 类相同，它是 `Mat` 的子类。'
- en: 'In our example, we added a mouse listener to retrieve points clicked by the
    user. A detail to be kept in mind is that these points are stored in the order:
    top-left, top-right, bottom-left, and bottom-right. In the example application,
    the currently modified point can be chosen through four radio buttons above the
    images. The act of clicking and dragging listeners has been added to the code,
    so both approaches work.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们添加了一个鼠标监听器来检索用户点击的点。需要注意的一个细节是，这些点按照以下顺序存储：左上角、右上角、左下角和右下角。在示例应用程序中，可以通过图像上方的四个单选按钮选择当前修改的点。点击和拖动监听器的操作已经被添加到代码中，因此两种方法都可以工作。
- en: Discrete Fourier Transform and Discrete Cosine Transform
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离散傅里叶变换和离散余弦变换
- en: When dealing with image analysis, it would be very useful if you could change
    an image from the spatial domain, which is the image in terms of its *x* and *y*
    coordinates, to the frequency domain—the image decomposed in its high and low
    frequency components—so that you would be able to see and manipulate frequency
    parameters. This could come in handy in image compression because it is known
    that human vision is not much sensitive to high frequency signals as it is to
    low frequency signals. In this way, you could transform an image from the spatial
    domain to the frequency domain and remove high frequency components, reducing
    the required memory to represent the image and hence compressing it. An image
    frequency can be pictured in a better way by the next image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理图像分析时，如果你能够将图像从空间域（即以 *x* 和 *y* 坐标表示的图像）转换为频率域——图像分解为高频和低频成分——这将非常有用，这样你就能看到并操作频率参数。这在图像压缩中可能很有用，因为已知人类视觉对高频信号的敏感度不如对低频信号。通过这种方式，你可以将图像从空间域转换为频率域，并移除高频成分，从而减少表示图像所需的内存，进而压缩图像。下一张图像可以更好地展示图像频率。
- en: In order to change an image from the spatial domain to the frequency domain,
    the Discrete Fourier Transform can be used. As we might need to bring it back
    from the frequency domain to the spatial domain, another transform, which is the
    Inverse Discrete Fourier Transform, can be applied.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将图像从空间域转换为频率域，可以使用离散傅里叶变换。由于我们可能需要将其从频率域转换回空间域，因此可以应用另一个变换，即逆离散傅里叶变换。
- en: 'The formal definition of DFT is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: DFT的正式定义如下：
- en: '![Discrete Fourier Transform and Discrete Cosine Transform](img/3972OS_04_15.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![离散傅里叶变换和离散余弦变换](img/3972OS_04_15.jpg)'
- en: The `f(i,j)` value is the image in the spatial domain and `F(k,l)` is the image
    in the frequency domain. Note that `F(k,l)` is a complex function, which means
    that it has a real and an imaginary part. This way, it will be represented by
    two OpenCV `Mat` objects or by `Mat` with two channels. The easiest way to analyze
    a DFT is by plotting its magnitude and taking its logarithm, since values for
    the DFT can be in different orders of magnitude.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`f(i,j)` 的值是空间域中的图像，而 `F(k,l)` 是频率域中的图像。请注意，`F(k,l)` 是一个复函数，这意味着它有一个实部和虚部。因此，它将由两个
    OpenCV `Mat` 对象或具有两个通道的 `Mat` 对象表示。分析 DFT 最简单的方法是绘制其幅度并取其对数，因为 DFT 的值可以处于不同的数量级。'
- en: 'For instance, this is a pulse pattern, which is a signal that can come from
    zero, represented as black, to the top, represented as white, on its left, and
    its Fourier transform magnitude with the applied logarithm to its right:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个脉冲模式，它是一个可以从零（表示为黑色）到顶部（表示为白色）的左侧信号，其傅里叶变换幅度及其右侧应用的对数：
- en: '![Discrete Fourier Transform and Discrete Cosine Transform](img/3972OS_04_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![离散傅里叶变换和离散余弦变换](img/3972OS_04_05.jpg)'
- en: Looking back at the preceding DFT transform, we can think of `F(k,l)` as the
    value that would be yielded by multiplying each point of the spatial image with
    a base function, which is related to the frequency domain, and by summing the
    products. Remember that base functions are sinusoidal and they have increasing
    frequencies. This way, if some of the base functions oscillate at the same rate
    as the signal, it will be able to sum up to a big number, which will be seen as
    a white dot on the Fourier Transform image. On the other hand, if the given frequency
    is not present in the image, the oscillation and multiplication with the image
    will result in a small number, which won't be noticed in the Fourier Transform
    image.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾先前的 DFT 变换，我们可以将 `F(k,l)` 视为将空间图像的每个点与一个与频率域相关的基函数相乘，然后求和的结果。记住，基函数是正弦函数，它们具有递增的频率。这样，如果某些基函数的振荡速率与信号相同，它们将能够相加成一个很大的数，这在傅里叶变换图像上会显示为一个白点。另一方面，如果给定的频率在图像中不存在，振荡与图像的乘积将导致一个很小的数，这在傅里叶变换图像中不会被注意到。
- en: 'Another thing to observe from the equation is that `F(0,0)` will yield a base
    function that is always `1`. This way, `F(0,0)` will simply refer to the sum of
    all the pixels of the spatial image. We can also check whether `F(N-1, N-1)` corresponds
    to the base function related to the highest frequency in the image. Note that
    the previous image basically has a DC component, which would be the image mean
    and it could be checked from the white dot in the middle of the Discrete Fourier
    transform image. Besides, the image to the left could be seen as a series of pulses
    and hence it would have a frequency in the *x* axis, which can be noticed by the
    two dots near the central point in the Fourier Transform image to the right. Nonetheless,
    we will need to use multiple frequencies to approximate the pulse shape. In this
    way, more dots can be seen in the *x*-axis of the image to the right. The following
    screenshot gives more insight and helps you understand the Fourier analysis:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从方程中还可以观察到，`F(0,0)` 将产生一个始终为 `1` 的基本函数。这样，`F(0,0)` 就简单地指代了空间图像中所有像素的总和。我们还可以检查
    `F(N-1, N-1)` 是否对应于与图像最高频率相关的基函数。请注意，前面的图像基本上有一个直流分量，这将是图像的均值，可以从离散傅里叶变换图像中间的白点中检查出来。此外，左侧的图像可以看作是一系列脉冲，因此它将在
    *x* 轴上有一个频率，这可以通过右侧傅里叶变换图像中靠近中心点的两个点来注意到。然而，我们需要使用多个频率来近似脉冲形状。这样，在右侧图像的 *x*-轴上可以看到更多的点。下面的截图提供了更多的见解，并有助于您理解傅里叶分析：
- en: '![Discrete Fourier Transform and Discrete Cosine Transform](img/3972OS_04_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![离散傅里叶变换和离散余弦变换](img/3972OS_04_06.jpg)'
- en: Now, we will again check the DC level at the center of the DFT image, to the
    right, as a bright central dot. Besides, we can also check multiple frequencies
    in a diagonal pattern. An important piece of information that can be retrieved
    is the direction of spatial variation, which is clearly seen as bright dots in
    the DFT image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次检查 DFT 图像中心的直流电平，右侧作为一个明亮的中心点。此外，我们还可以以对角线模式检查多个频率。可以检索的重要信息之一是空间变化的方向，这在
    DFT 图像中清晰地显示为明亮的点。
- en: 'It is time to work on some code now. The following code shows you how to make
    room to apply the DFT. Remember, from the preceding screenshot, that the result
    of a DFT is complex. Besides, we need them stored as floating point values. This
    way, we first convert our 3-channel image to gray and then to a float. After this,
    we put the converted image and an empty `Mat` object into a list of mats, combining
    them into a single `Mat` object through the use of the `Core.merge` function,
    shown as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写一些代码了。以下代码展示了如何为应用DFT腾出空间。记住，从前面的截图可以看出，DFT的结果是复数。此外，我们需要将它们存储为浮点值。为此，我们首先将我们的三通道图像转换为灰度，然后转换为浮点。之后，我们将转换后的图像和一个空的`Mat`对象放入一个mats列表中，通过使用`Core.merge`函数将它们合并为一个单一的`Mat`对象，如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, it''s easy to apply an in-place Discrete Fourier Transform:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用原地离散傅里叶变换（DFT）变得容易：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In order to get some meaningful information, we will print the image, but first,
    we have to obtain its magnitude. In order to get it, we will use the standard
    way that we learned in school, which is getting the square root of the sum of
    the squares of the real and complex parts of numbers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取一些有意义的信息，我们将打印图像，但首先，我们必须获取其幅度。为了获取它，我们将使用我们在学校学到的标准方法，即获取数字实部和虚部平方和的平方根。
- en: 'Again, OpenCV has a function for this, which is `Core.magnitude`, whose signature
    is `magnitude(Mat x, Mat y, Mat magnitude)`, as shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，OpenCV有一个用于此目的的函数，即`Core.magnitude`，其签名是`magnitude(Mat x, Mat y, Mat magnitude)`，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before using `Core.magnitude`, just pay attention to the process of unpacking
    a DFT in the splitted mats using `Core.split`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Core.magnitude`之前，请注意使用`Core.split`在拆分的mats中解包DFT的过程。
- en: 'Since the values can be in different orders of magnitude, it is important to
    get the values in a logarithmic scale. Before doing this, it is important to add
    `1` to all the values in the matrix just to make sure we won''t get negative values
    when applying the `log` function. Besides this, there''s already an OpenCV function
    to deal with logarithms, which is `Core.log`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值可能处于不同的数量级，因此将值转换为对数尺度非常重要。在进行此操作之前，需要将矩阵中的所有值加1，以确保在应用`log`函数时不会得到负值。除此之外，OpenCV已经有一个处理对数运算的函数，即`Core.log`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, it is time to shift the image to the center, so that it''s easier to analyze
    its spectrum. The code to do this is simple and goes like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将图像移至中心，这样更容易分析其频谱。执行此操作的代码简单，如下所示：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As a last step, it''s important to normalize the image, so that it can be seen
    in a better way. Before we normalize it, it should be converted to CV_8UC1:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，对图像进行归一化非常重要，这样它才能以更好的方式被看到。在我们对其进行归一化之前，它应该被转换为CV_8UC1格式：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When using the DFT, it's often enough to calculate only half of the DFT when
    you deal with real-valued data, as is the case with images. This way, an analog
    concept called the Discrete Cosine Transform can be used. In case you want it,
    it can be invoked through `Core.dct`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理实值数据时，使用DFT通常只需要计算DFT的一半，就像图像一样。这样，可以使用一个称为离散余弦变换的类似概念。如果您需要，可以通过`Core.dct`来调用它。
- en: Integral images
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分图像
- en: 'Some face recognition algorithms, such as OpenCV''s face detection algorithm
    make heavy use of features like the ones shown in the following image:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人脸识别算法，如OpenCV的人脸检测算法，大量使用以下图像中所示的特征：
- en: '![Integral images](img/3972OS_04_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像](img/3972OS_04_07.jpg)'
- en: 'These are the so-called Haar-like features and they are calculated as the sum
    of pixels in the white area minus the sum of pixels in the black area. You might
    find this type of a feature kind of odd, but when training it for face detection,
    it can be built to be an extremely powerful classifier using only two of these
    features, as depicted in the following image:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为Haar-like特征，它们是白色区域像素总和减去黑色区域像素总和的计算结果。您可能会觉得这种特征有点奇怪，但在人脸检测的训练中，它可以构建成一个极其强大的分类器，仅使用这两个特征，如下面的图像所示：
- en: '![Integral images](img/3972OS_04_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像](img/3972OS_04_08.jpg)'
- en: In fact, a classifier that uses only the two preceding features can be adjusted
    to detect 100 percent of a given face training database with only 40 percent of
    false positives. Taking out the sum of all pixels in an image as well as calculating
    the sum of each area can be a long process. However, this process must be tested
    for each frame in a given input image, hence calculating these features fast is
    a requirement that we need to fulfill.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，仅使用前两个特征的分类器可以调整到检测给定面部训练数据库中的 100%，而只有 40% 的误报。从图像中取出所有像素的总和以及计算每个区域的总和可能是一个漫长的过程。然而，这个过程必须针对给定输入图像中的每一帧进行测试，因此快速计算这些特征是我们需要满足的要求。
- en: 'First, let''s define an integral image sum as the following expression:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个积分图像和为以下表达式：
- en: '![Integral images](img/3972OS_04_16.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像](img/3972OS_04_16.jpg)'
- en: 'For instance, if the following matrix represents our image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果以下矩阵代表我们的图像：
- en: '![Integral images](img/3972OS_04_17.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像](img/3972OS_04_17.jpg)'
- en: 'An integral image would be like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 积分图像将类似于以下内容：
- en: '![Integral images](img/3972OS_04_18.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像](img/3972OS_04_18.jpg)'
- en: 'The trick here follows from the following property:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧源于以下属性：
- en: '![Integral images](img/3972OS_04_19.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![积分图像](img/3972OS_04_19.jpg)'
- en: This means that in order to find the sum of a given rectangle bounded by the
    points `(x1,y1)`, `(x2,y1)`, `(x2,y2)`, and `(x1,y2)`, you just need to use the
    integral image at the point `(x2,y2)`, but you also need to subtract the points
    `(x1-1,y2)` from `(x2,y1-1)`. Also, since the integral image at `(x1-1, y1-1)`
    has been subtracted twice, we just need to add it once.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了找到由点 `(x1,y1)`、`(x2,y1)`、`(x2,y2)` 和 `(x1,y2)` 界定的给定矩形的和，你只需要使用点 `(x2,y2)`
    的积分图像，但你还需要从 `(x1-1,y2)` 到 `(x2,y1-1)` 的点中减去。此外，由于 `(x1-1, y1-1)` 的积分图像被减去了两次，我们只需要加一次。
- en: 'The following code will generate the preceding matrix and make use of `Imgproc.integral`
    to create the integral images:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将生成前面的矩阵并使用 `Imgproc.integral` 创建积分图像：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output of this program is like the one shown in the preceding matrices for
    A and Sum A.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出类似于前面矩阵中 A 和 Sum A 的输出。
- en: It is important to verify that the output is a 4 x 4 matrix because of the initial
    row and column of zeroes, which are used to make the computation efficient.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于初始行和列的零值，需要验证输出是一个 4 x 4 矩阵，因为这些零值被用来使计算更高效。
- en: Distance transforms
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离变换
- en: 'Simply put, a distance transform applied to an image will generate an output
    image whose pixel values will be the closest distance to a zero-valued pixel in
    the input image. Basically, they will have the closest distance to the background,
    given a specified distance measure. The following screenshot gives you an idea
    of what happens to the silhouette of a human body:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对一个图像应用距离变换将生成一个输出图像，其像素值将是输入图像中零值像素的最短距离。基本上，它们将具有给定的距离度量下的最短距离到背景。以下截图展示了人体轮廓会发生什么：
- en: '![Distance transforms](img/3972OS_04_09.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![距离变换](img/3972OS_04_09.jpg)'
- en: Human silhouette by J E Theriot
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由 J E Theriot 的人体轮廓
- en: This transform can be very useful in the process of getting the topological
    skeleton of a given segmented image as well as to produce blurring effects. Another
    interesting application of this transform is in the segmentation of overlapping
    objects, along with a watershed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变换在获取给定分割图像的拓扑骨架以及产生模糊效果的过程中非常有用。这种变换的另一个有趣应用是在分割重叠对象时，与分水岭一起使用。
- en: 'Generally, the distance transform is applied to an edge image, which results
    from a Canny filter. We are going to make use of Imgproc''s `distanceTransform`
    method, which can be seen in action in the `distance` project, which you can find
    in this chapter''s source code. Here are the most important lines of this example
    program:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，距离变换应用于由 Canny 滤波器生成的边缘图像。我们将使用 Imgproc 的 `distanceTransform` 方法，这在 `distance`
    项目中可以看到，该项目可以在本章的源代码中找到。以下是此示例程序中最重要的一些行：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Firstly, a Canny edge detector filter is applied to the input image. Then, a
    threshold with `THRESH_BINARY_INV` converts the edges to black and beans to white.
    Only then, the distance transform is applied. The first argument is the input
    image, the second one is the output matrix, and the third argument specifies how
    distances are calculated. In our example, `CVDIST_L2` means Euclidean, while other
    distances, such as `CVDIST_L1` or `CVDIST_L12`, among others exist. Since the
    output of `distanceTtransform` is a single channel 32 bit Float image, a conversion
    is required. Finally, we apply `Core.multiply` to increase the contrast.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对输入图像应用Canny边缘检测器过滤器。然后，使用`THRESH_BINARY_INV`阈值的转换将边缘变为黑色，豆子变为白色。只有在此之后，才应用距离变换。第一个参数是输入图像，第二个参数是输出矩阵，第三个参数指定了距离是如何计算的。在我们的例子中，`CVDIST_L2`表示欧几里得距离，而其他距离，如`CVDIST_L1`或`CVDIST_L12`等也存在。由于`distanceTransform`的输出是一个单通道32位浮点图像，需要进行转换。最后，我们应用`Core.multiply`来增强对比度。
- en: 'The following screenshot gives you a good idea of the whole process:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图为您提供了整个过程的良好理解：
- en: '![Distance transforms](img/3972OS_04_10.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![距离变换](img/3972OS_04_10.jpg)'
- en: Histogram equalization
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: The human visual system is very sensitive to contrast in images, which is the
    difference in the color and brightness of different objects. Besides, the human
    eye is a miraculous system that can feel intensities at the 10[16] light levels
    [4]. No wonder some sensors could mess up the image data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 人类视觉系统对图像中的对比度非常敏感，这是不同物体颜色和亮度的差异。此外，人眼是一个神奇的系统，可以在10[16]个光级上感受到强度[4]。难怪一些传感器可能会搞乱图像数据。
- en: When analyzing images, it is very useful to draw their histograms. They simply
    show you the lightness distribution of a digital image. In order to do that, you
    need to count the number of pixels with the exact lightness and plot that as a
    distribution graph. This gives us a great insight into the dynamic range of an
    image.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析图像时，绘制它们的直方图非常有用。它们简单地显示了数字图像的亮度分布。为了做到这一点，您需要计算具有确切亮度的像素数量，并将其作为分布图绘制出来。这使我们能够深入了解图像的动态范围。
- en: 'When a camera picture has been captured with a very narrow light range, it
    gets difficult to see the details in the shadowed areas or other areas with poor
    local contrast. Fortunately, there''s a technique to spread frequencies for uniform
    intensity distribution, which is called **histogram equalization**. The following
    image shows the same picture with their respective histograms before and after
    the histogram equalization technique is applied:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当相机图片以非常窄的光范围捕捉时，在阴影区域或其他局部对比度较差的区域看细节变得困难。幸运的是，有一种技术可以均匀分布强度，称为**直方图均衡化**。以下图像显示了在应用直方图均衡化技术前后，同一图片及其相应的直方图：
- en: '![Histogram equalization](img/3972OS_04_11.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![直方图均衡化](img/3972OS_04_11.jpg)'
- en: Note that the light values, located at the rightmost part of the upper histogram,
    are rarely used, while the middle range values are too tied. Spreading the values
    along the full range yields better contrast and details can be more easily perceived
    by this. The histogram equalized image makes better use of intensities that generate
    better contrast. In order to accomplish this task, a cumulative distribution can
    be used to remap the histogram to something that resembles a uniform distribution.
    Then, it's just a matter of checking where the points from the original histogram
    would be mapped to the uniform distribution through the use of a cumulative Gaussian
    distribution, for instance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，位于上方直方图最右侧的光值很少使用，而中间范围的光值过于集中。在整个范围内扩展这些值会产生更好的对比度，并且细节更容易被感知。直方图均衡化图像更好地利用了产生更好对比度的强度。为了完成这项任务，可以使用累积分布来重新映射直方图，使其类似于均匀分布。然后，只需检查原始直方图的点通过累积高斯分布等方法映射到均匀分布的位置即可。
- en: 'Now, the good part is that all these details have been wrapped in a simple
    call to OpenCV''s `equalizeHist` function. Here is the sample from the `histogram`
    project in this chapter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，好事是所有这些细节都封装在一个简单的OpenCV `equalizeHist`函数调用中。以下是本章“histogram”项目中的示例：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This piece of code simply converts the image to a single channel image; however,
    you can use `equalizeHist` on a color image as long as you treat each channel
    separately. The `Imgproc.equalizeHist` method outputs the corrected image following
    the previously mentioned concept.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是将图像转换为单通道图像；然而，只要将每个通道单独处理，你就可以在彩色图像上使用`equalizeHist`。`Imgproc.equalizeHist`方法按照之前提到的概念输出校正后的图像。
- en: References
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '*A 3x3 Isotropic Gradient Operator for Image Processing* presented at a talk
    at the Stanford Artificial Project in 1968, by I. Sobel and G. Feldman.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*《用于图像处理的3x3各向同性梯度算子》*，在1968年斯坦福人工项目演讲中提出，作者：I. Sobel 和 G. Feldman。'
- en: '*A Computational Approach To Edge Detection*, IEEE Trans. Pattern Analysis
    and Machine Intelligence, by Canny, J.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*《边缘检测的计算方法》*，IEEE Trans. Pattern Analysis and Machine Intelligence，作者：Canny,
    J.'
- en: '*Robust Detection of Lines Using the Progressive Probabilistic Hough Transform*,
    CVIU 78 1, by Matas, J. and Galambos, C., and Kittler, J.V. pp 119-137 (2000).'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*使用渐进概率Hough变换进行线的鲁棒检测*，CVIU 78 1，作者：Matas, J. 和 Galambos, C.，以及Kittler, J.V.
    第119-137页（2000年）。'
- en: '*Advanced High Dynamic Range Imaging: Theory and Practice*, CRC Press, by Banterle,
    Francesco; Artusi, Alessandro; Debattista, Kurt; Chalmers, Alan.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*高级高动态范围成像：理论与实践*，CRC Press，作者：Banterle, Francesco；Artusi, Alessandro；Debattista,
    Kurt；Chalmers, Alan。'
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the key aspects of computer vision's daily use. We started
    with the important edge detectors, where you gained the experience of how to find
    them through the Sobel, Laplacian, and Canny edge detectors. Then, we saw how
    to use the Hough transforms to find straight lines and circles. After that, the
    geometric transforms stretch, shrink, warp, and rotate were explored with an interactive
    sample. We then explored how to transform images from the spatial domain to the
    frequency domain using the Discrete Fourier analysis. After that, we showed you
    a trick to calculate Haar-like features fast in an image through the use of integral
    images. We then explored the important distance transforms and finished the chapter
    by explaining histogram equalization to you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了计算机视觉日常应用的关键方面。我们从重要的边缘检测器开始，通过Sobel、Laplacian和Canny边缘检测器，你获得了如何找到它们的经验。然后，我们看到了如何使用Hough变换来找到直线和圆。之后，通过一个交互式示例，我们探讨了几何变换拉伸、收缩、扭曲和旋转。接着，我们探讨了如何使用离散傅里叶分析将图像从空间域转换到频域。之后，我们展示了通过使用积分图像快速计算Haar特征的小技巧。然后，我们探讨了重要的距离变换，并在解释直方图均衡化后结束本章。
- en: Now, be ready to dive into machine learning algorithms, as we will cover how
    to detect faces in the next chapter. Also, you will learn how to create your own
    object detector and understand how supervised learning works in order to better
    train your classification trees.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，准备好深入机器学习算法，因为我们将介绍如何在下一章中检测人脸。你还将学习如何创建自己的对象检测器，并理解监督学习是如何工作的，以便更好地训练你的分类树。
