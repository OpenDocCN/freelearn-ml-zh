- en: Chapter 9. AdventureWorks Production – Neural Networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. AdventureWorks生产 - 神经网络
- en: One day you are sitting in your office, basking in the glow of your new-found
    rock star status at AdventureWorks when your boss knocks on the door. She says,
    "Since you did such a good job with the consumer-facing portion of our existing
    website, we want to know if you would be interested in working on an internally-facing
    greenfield project." You cut her off with a resounding, "Yes!" She smiles and
    continues, "Okay. The problem is in our production area. Management is very interested
    in how we can reduce our scrap amount. Every month we get a report from Excel
    that looks like this:"
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，你坐在办公室里，沉浸在你在AdventureWorks新获得的摇滚明星地位的光环中，这时你的老板敲响了门。她说：“既然你在我们现有网站的面向消费者的部分做得这么好，我们想知道你是否愿意参与一个内部绿色田野项目。”你响亮地打断她，“是的！”她微笑着继续说，“好的。问题是出在我们的生产区。管理层非常感兴趣我们如何减少我们的废品数量。每个月我们都会收到一份来自Excel的报告，看起来像这样：”
- en: '![AdventureWorks Production – Neural Networks](img/00123.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![AdventureWorks生产 - 神经网络](img/00123.jpeg)'
- en: '"The problem is that we don''t know what to do with this data. Production is
    a complex workflow with many variables that can impact whether an item gets scrapped.
    We are looking for two things:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “问题是，我们不知道如何处理这些数据。生产是一个复杂的流程，有许多变量可能会影响物品是否被废弃。我们正在寻找两件事：
- en: A way of identifying the items that most impact whether items get scrapped
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种识别对物品是否被废弃影响最大的项目的方法
- en: A tool that allows our planners to alter the key variables to play *what if…*
    and make changes to the production process"
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许我们的规划者改变关键变量以进行“如果……会怎样”的模拟并改变生产流程的工具
- en: You tell your boss okay. Since this is a greenfield application and you have
    been hearing the hype around ASP.NET Core 1.0, this seems like a great place to
    try it. Also, you have heard about one of the hot models in data science, neural
    networks, and want to see whether the reality matches the hype.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你告诉你的老板可以。由于这是一个绿色田野应用，而且你一直在听关于ASP.NET Core 1.0的炒作，这似乎是一个尝试它的绝佳地方。此外，你听说过数据科学中的一个热门模型，神经网络，并想知道现实是否与炒作相符。
- en: Neural networks
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络
- en: A relative latecomer to data science, neural networks attempt to have the computer
    imitate how the brain operates. The gray matter between our ears is very good,
    up to a point, at making connections and drawing inferences. The promise of neural
    networks is that if we can build models that are patterned after how our brain
    works, we can combine the speed of computers and the pattern-matching ability
    of our wetware to make a learning model that can provide insights that computers
    or humans alone might miss.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络是数据科学的一个相对较晚的参与者，试图让计算机模仿大脑的工作方式。我们耳朵之间的灰质在建立联系和推理方面非常好，直到一定程度。神经网络的前景是，如果我们能构建出模仿我们大脑工作方式的模型，我们就可以结合计算机的速度和湿件的模式匹配能力，创建一个可以提供洞察力，而计算机或人类单独可能错过的学习模型。
- en: Background
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: 'Neural networks takes their vocabulary from the actual brain; a neural network
    is a collection of neurons. If you remember from Biology 101 (or Crysis 2), the
    brain has billions of neurons that look more or less like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络从实际大脑中汲取词汇；神经网络是一系列神经元的集合。如果你还记得生物学101（或者《战争机器2》），大脑有数十亿个神经元，它们看起来或多或少是这样的：
- en: '![Background](img/00124.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![背景](img/00124.jpeg)'
- en: The axon terminal of one neuron connects to another neuron's dendrite. Since
    an individual neuron can have multiple dendrites and axon terminals, neurons can
    connect, and be connected to, numerous other neurons. The actual connection area
    between two neurons is called the synapse. Our brains use electrical signals to
    pass messages among neurons.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个神经元的轴突末端连接到另一个神经元的树突。由于单个神经元可以有多个树突和轴突末端，神经元可以连接，并被连接到许多其他神经元。两个神经元之间实际的连接区域被称为突触。我们的大脑使用电信号在神经元之间传递信息。
- en: '![Background](img/00125.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![背景](img/00125.jpeg)'
- en: Since we are modeling the human brain for neural networks, it stands to reason
    that we will use the same vocabulary. In a neural network, we have a series of
    inputs and an output. Between the inputs and outputs, there is a hidden layer
    comprising neurons. Any connection from the inputs into the hidden layer, among
    the neurons inside the hidden layer, and from the hidden layer to the output is
    called a synapse.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在为神经网络模拟人脑，因此我们可以合理地认为我们将使用相同的词汇。在神经网络中，我们有一系列输入和一个输出。在输入和输出之间，有一个由神经元组成的隐藏层。任何从输入到隐藏层、隐藏层内部的神经元之间，以及从隐藏层到输出的连接都被称为突触。
- en: '![Background](img/00126.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![背景](img/00126.jpeg)'
- en: Notice that every synapse connects only to the neurons (or output) to its immediate
    right. Data always flows in one direction in a neural network and synapses never
    connect to themselves or any other preceding neuron in the network. One more thing
    to note is that when the hidden layer has many neurons, it is called a deep belief
    network (or deep learning). We will not be covering deep belief networks in this
    book, though it is certainly something you might want to toss around the next
    time you are out bowling with friends.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个突触只连接到其右侧的神经元（或输出）。在神经网络中，数据总是单向流动，突触永远不会连接到自身或网络中的任何其他前一个神经元。还有一点需要注意，当隐藏层有多个神经元时，它被称为深度信念网络（或深度学习）。尽管如此，我们在这本书中不会涉及深度信念网络，尽管这确实是你下次和朋友打保龄球时可能会讨论的话题。
- en: 'In a neural network, the synapse has only one job. They form a connection from
    one neuron to the next, applying a weight to that connection. For example, Neuron
    1 activates the synapse with a weight of two, so that Neuron 2 receives an input
    of two:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在神经网络中，突触只有一个任务。它们从一个神经元形成连接到下一个神经元，并应用一个权重到这个连接上。例如，神经元1以两个权重激活突触，因此神经元2接收到的输入为两个：
- en: '![Background](img/00127.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![背景](img/00127.jpeg)'
- en: 'Neurons have a more complicated job. They take in the values from all of their
    input synapses, take input from something called a bias (I''ll get to that in
    a second), apply an activation function to the inputs, and then either output
    a signal or do nothing. The activation function can treat each input separately,
    combine them, or do a mixture of both. There are many kinds of activation functions,
    ranging from simple to mind-boggling. In this example, the inputs are added together:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 神经元有一个更复杂的工作。它们接收来自所有输入突触的值，从称为偏差的东西那里获取输入（我稍后会解释），对输入应用激活函数，然后输出一个信号或什么都不做。激活函数可以单独处理每个输入，也可以将它们组合起来，或者两者兼而有之。存在许多种类的激活函数，从简单到令人难以置信。在这个例子中，输入被相加：
- en: '![Background](img/00128.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![背景](img/00128.jpeg)'
- en: 'Some neural networks are smart enough to add and drop neurons as needed. For
    this book, we will not be doing anything like that—we will fix the number of neurons
    in each layer. Going back to some vocabulary that I dropped on you in the preceding
    paragraph, there are two kinds of inputs for any given activation function inside
    a neuron: the weights as transmitted by the synapses and the bias. The weights
    are a number that is assigned to the synapse, depending on the nature of the synapse,
    and does not change during the lifetime of the neural network. The bias is a global
    value that is assigned to all neurons (and output) which, unlike the weights,
    changes frequently. The machine learning component of the neural network is the
    many iterations that the computer does to create the best combination of weights
    and bias to give the optimal predictive score.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些神经网络足够智能，可以根据需要添加和删除神经元。对于这本书，我们不会做任何类似的事情——我们将固定每层的神经元数量。回到我在上一段中提到的词汇，对于神经元内的任何给定激活函数，有两种输入：通过突触传递的权重和偏差。权重是一个分配给突触的数字，它取决于突触的性质，并且在神经网络的整个生命周期中不会改变。偏差是一个分配给所有神经元（和输出）的全局值，与权重不同，它经常改变。神经网络中的机器学习组件是计算机所做的许多迭代，以创建最佳权重和偏差组合，从而给出最佳的预测分数。
- en: Neural network demo
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 神经网络演示
- en: 'With this mental model in place, let''s take a look at a neural network in
    action. Let''s look at a series of students who studied and drank beer before
    an exam and compare whether they passed that exam or not:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立这个心理模型之后，让我们看看神经网络的实际应用。让我们看看一系列在考试前学习和喝酒的学生，并比较他们是否通过了那次考试：
- en: '![Neural network demo](img/00129.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![神经网络演示](img/00129.jpeg)'
- en: 'Since we have two input (*x*) variables (**Hours Studying** and **Beers Drank**),
    our neural network will have two inputs. We have one dependent variable (**Passed?**)
    so our neural network will have one output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个输入变量（*x*，即**学习时间**和**喝啤酒量**），我们的神经网络将有两个输入。我们有一个因变量（**是否通过**），因此我们的神经网络将有一个输出：
- en: '![Neural network demo](img/00130.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![神经网络演示](img/00130.jpeg)'
- en: 'One thing to note is that the number of inputs depends on the range of values.
    So if we had a categorical input (such as male/female), we would have a number
    of inputs that correspond to the range of values in the category:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意，输入的数量取决于值的范围。所以如果我们有一个分类输入（例如男性/女性），我们将有一个与该类别值范围相对应的输入数量：
- en: '![Neural network demo](img/00131.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![神经网络演示](img/00131.jpeg)'
- en: Go into Visual Studio and create a new C# ASP.NET web application:![Neural network
    demo](img/00132.jpeg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 Visual Studio 并创建一个新的 C# ASP.NET 网络应用程序：![神经网络演示](img/00132.jpeg)
- en: In the next dialog box, select **ASP.NET 5 Templates** and change the authentication
    type to **No Authentication**. Note that the templates will probably change from
    ASP.NET 5 to ASP.NET Core 1 after the writing of this book. You can consider these
    two terms synonymously.![Neural network demo](img/00133.jpeg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个对话框中，选择 **ASP.NET 5 模板**并将身份验证类型更改为 **无身份验证**。请注意，在本书编写之后，模板可能会从 ASP.NET
    5 更改为 ASP.NET Core 1。你可以将这两个术语视为同义词。![神经网络演示](img/00133.jpeg)
- en: If everything code-gens as it should, you will get the following project:![Neural
    network demo](img/00134.jpeg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代码生成一切正常，你会得到以下项目：![神经网络演示](img/00134.jpeg)
- en: Next, let's add an F# Windows Library project:![Neural network demo](img/00135.jpeg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个 F# Windows 库项目：![神经网络演示](img/00135.jpeg)
- en: 'Once the F# project has been created, open up the NuGet Package Manager Console
    and install numl. Make sure that you are targeting the F# project for the NuGet
    installation:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了 F# 项目，打开 NuGet 包管理器控制台并安装 numl。确保你在为 NuGet 安装目标 F# 项目：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Neural network demo](img/00136.jpeg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![神经网络演示](img/00136.jpeg)'
- en: Rename `Scipt1.fsx` to `StudentNeuralNetwork.fsx`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Scipt1.fsx` 重命名为 `StudentNeuralNetwork.fsx`。
- en: 'Go to the script and replace everything in it with this code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往脚本并将其中的所有内容替换为以下代码：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you send this to the FSI, you will get the following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将这个项目发送到 FSI 时，你会得到以下结果：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you worked through the example in [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    this code will look familiar. The `Student` type has three properties: `Study`,
    `Beer`, and `Passed`. Note that `Passed` is marked as mutable because numl expects
    any prediction data type to be of the same type that was used when the model was
    created. Numl then mutates the response variable to whatever the model comes up
    with, so we have to use the mutable keyword. Alternative implementations would
    be to pass into the prediction function a type without that response variable
    or return a new instance so the value can be immutable. Feel free to contribute
    to the open source project if you feel strongly about this (I''ll see you there
    J).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了第 3 章（[更多 AdventureWorks 回归](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "第 3 章。更多冒险回归"）中的示例，这段代码看起来会很熟悉。`Student` 类型有三个属性：`Study`、`Beer` 和 `Passed`。请注意，`Passed`
    被标记为可变的，因为 numl 预期任何预测数据类型与创建模型时使用的类型相同。Numl 然后将响应变量更改为模型得出的任何值，因此我们必须使用可变关键字。另一种实现方式是将没有响应变量的类型传递给预测函数或返回一个新实例，这样值就可以是不可变的。如果你对此有强烈的看法，请随时为开源项目做出贡献（我会在那里见到你
    J）。
- en: 'In any event, the data is an array of instances of our students. We then create
    a descriptor of the `Student` type and a generator of a neural network. Notice
    that we know the generator''s `descriptor` property is mutable because we assign
    it using the `<-` symbol in this line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，数据是我们学生的实例数组。然后我们创建一个 `Student` 类型的描述符和一个神经网络的生成器。请注意，我们知道生成器的 `descriptor`
    属性是可变的，因为我们在这行代码中使用 `<-` 符号对其进行赋值：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we pass the generator to the learner and create the model. Under the
    hood, numl is scaling our data and running multiple instances of a neural network
    to determine the optimal solution. Once the generator has finished its work, it
    reports that it has an accuracy of 100%. We can then test our neural network with
    some new data. Go to the script and add this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将生成器传递给学习器并创建模型。在底层，numl 正在缩放我们的数据并运行多个神经网络的实例以确定最佳解决方案。一旦生成器完成其工作，它会报告其准确率为
    100%。然后我们可以用一些新数据测试我们的神经网络。前往脚本并添加以下内容：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you send this to the FSI, you will get this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个项目发送到 FSI 时，你会得到以下结果：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, our student who studies 7 hours and has 1 beer will pass the test.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的学生如果学习 7 小时并且喝了一杯啤酒就能通过考试。
- en: 'Neural network – try #1'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '神经网络 – 尝试 #1'
- en: 'With the theory out of the way, let''s see if neural networks can help us with
    AdventureWorks. As in [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    let''s see if we can use a business area expert to help us formulate some viable
    hypotheses. When we visit the manager of manufacturing, he says, "I think there
    are a couple of areas that you should look at. See if the production location
    has an impact. We have seven major locations":'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 理论问题解决之后，让我们看看神经网络是否可以帮助我们处理AdventureWorks。正如[第3章](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "第3章。更多AdventureWorks回归")中所述，*更多AdventureWorks回归*，让我们看看是否可以使用业务领域专家来帮助我们制定一些可行的假设。当我们访问制造经理时，他说：“我认为有几个领域你应该关注。看看生产位置是否有影响。我们共有七个主要位置”：
- en: '![Neural network – try #1](img/00137.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![神经网络 – 尝试#1](img/00137.jpeg)'
- en: '"I am curious if our **Paint** location generates more than expected defects
    because we have high turnover in that area."'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “我很想知道我们的**油漆**位置是否产生了比预期更多的缺陷，因为我们该区域的周转率很高。”
- en: '"Also, see if there is a relationship between vendors and products with defects.
    In some cases, we purchase parts for a single vendor; in other cases, we have
    two or three vendors supplying us parts. We don''t track which part came from
    which vendor when we build a bike, but perhaps you can find that certain vendors
    are associated with purchase orders that have defects."'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “此外，查看供应商和有缺陷的产品之间是否存在关系。在某些情况下，我们为单个供应商购买零件；在其他情况下，我们有两个或三个供应商为我们提供零件。在我们组装自行车时，我们没有跟踪哪个零件来自哪个供应商，但也许你可以发现某些供应商与有缺陷的采购订单相关联。”
- en: 'These seem like two good places to start, so let''s head over to the **Solution
    Explorer** and create a new script file called `AWNeuralNetwork.fsx` in the F#
    project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来是两个很好的起点，因此让我们前往**解决方案资源管理器**，在F#项目中创建一个名为`AWNeuralNetwork.fsx`的新脚本文件：
- en: '![Neural network – try #1](img/00138.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![神经网络 – 尝试#1](img/00138.jpeg)'
- en: 'Next, open up the NuGet Package Manager and enter this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开NuGet包管理器并输入以下内容：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, open the script file and enter this (note that the version number might
    be different for you):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开脚本文件并输入以下内容（注意，版本号可能因你而异）：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sending this to the REPL will give you the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL会得到以下结果：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let''s tackle the location hypothesis. Go to the script and enter the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理位置假设。转到脚本并输入以下内容：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sending this to the REPL gives you the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL会得到以下结果：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see we have a record type with each location as a field and an indicator
    if there was anything scrapped. The level of automacy for this data structure
    is work order. Each order might visit one or all of the locations and might have
    some scrap quantity. The `getWorkOrderFunction` takes the `WorkOrderLocation`
    table, where each location is a row in the table, and flattens into this `WorkOrderLocation`
    record type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们有一个记录类型，每个位置作为一个字段，以及一个表示是否有报废的指示器。这个数据结构的自动化程度是工作订单。每个订单可能访问一个或所有这些位置，并且可能有某些报废数量。`getWorkOrderFunction`函数接受`WorkOrderLocation`表，其中每个位置是表中的一行，并将其扁平化为`WorkOrderLocation`记录类型。
- en: 'Next, go back to the script and enter this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，回到脚本并输入以下内容：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL会得到以下结果：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is very much what you saw in [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*. We go to
    the database and pull in all the work orders and then map the locations into our
    `WorkOrderLocation` record. Notice that we are using the `PSeq` so that we can
    get a performance boost by making simultaneous calls to the database to get the
    locations for each work order.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与你在[第5章](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "第5章。时间到 – 获取数据")中看到的内容非常相似，*时间到 – 获取数据*。我们访问数据库并拉取所有工作订单，然后将位置映射到我们的`WorkOrderLocation`记录。请注意，我们使用`PSeq`，这样我们就可以通过同时调用数据库来获取每个工作订单的位置来提高性能。
- en: 'With the data local, let''s try out a neural network. Go into the script file
    and enter this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 数据本地化后，让我们尝试使用神经网络。进入脚本文件并输入以下内容：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Sending that to the REPL, after a long wait, will give you the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在长时间等待后，将此发送到REPL会得到以下结果：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, ugh, it does not look like the location can predict where defects might
    occur. As we saw in [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    sometimes you do not need a working model to make the experiment worthwhile. In
    this case, we can go back to the director and tell him that scraps are occurring
    all over his production location, not just in the painting (so much for blaming
    the new guy).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，呃，看起来位置并不能预测缺陷可能发生的地方。正如我们在 [第 3 章](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "第 3 章。更多 AdventureWorks 回归") "更多 AdventureWorks 回归" 中看到的，有时你不需要一个工作模型来使实验有价值。在这种情况下，我们可以回到导演那里，告诉他报废发生在他的整个生产地点，而不仅仅是喷漆（这样就把责任推给了新来的那个人）。
- en: 'Neural network – try #2'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '神经网络 – 尝试 #2'
- en: 'Let''s see if we can find anything using the director''s second hypothesis
    that certain vendors might have higher defect rates than others. Go back to the
    script and enter this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以使用导演的第二个假设来找到一些东西，即某些供应商可能比其他供应商的缺陷率更高。回到脚本中，输入以下内容：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you send it to the FSI, you will get the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到 FSI 后，你会得到以下内容：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `VendorProduct` record type should be familiar to you. The next code block
    creates an array of 1,000 random work order IDs. As we learned from the first
    experiment, neural networks take a long time to complete. We will look at some
    big-data solutions in the next chapter, but until then we'll do what data scientists
    have done for as long as they have done data science—take a sample of the larger
    dataset. Notice that we are using the `Array.Mapi` high-order function so that
    we can use the index value to locate the correct value in the work orders array.
    Unfortunately, we can't pass the index into the type provider and have it evaluate
    on the server, so the entire work order table is brought local so that we can
    use the index.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`VendorProduct` 记录类型你应该很熟悉。接下来的代码块创建了一个包含 1,000 个随机工作订单 ID 的数组。正如我们从第一个实验中学到的，神经网络需要很长时间才能完成。我们将在下一章中查看一些大数据解决方案，但在此之前，我们将做数据科学家一直做的事情——从更大的数据集中抽取样本。请注意，我们正在使用
    `Array.Mapi` 高阶函数，这样我们就可以使用索引值在工作订单数组中定位正确的值。不幸的是，我们无法将索引传递给类型提供者并在服务器上评估，因此整个工作订单表被带到本地，这样我们就可以使用索引。'
- en: 'Next, enter this into the script:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下内容输入到脚本中：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you send it to the FSI, after a bit of a wait, you will get the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到 FSI 后，稍作等待，你会得到以下内容：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first line is the `in` (`|=|`) operator that we ran across in [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "Chapter 5. Time Out – Obtaining Data"), *Time Out – Obtaining Data*. The next
    code block hydrates the `vendorData` array with the data from the 1,000 randomly
    selected work orders. Notice that there is some repetition because each work order
    will use several parts and each part might be supplied by a variety of vendors
    (in this case, called business entities).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是我们在 [第 5 章](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "第 5 章。时间到 – 获取数据") "时间到 – 获取数据" 中遇到的 `in` (`|=|`) 操作符。接下来的代码块使用从 1,000 个随机选择的工作订单中的数据填充
    `vendorData` 数组。请注意，由于每个工作订单将使用多个部件，而每个部件可能由各种供应商（在这种情况下，称为商业实体）提供，因此存在一些重复。
- en: 'With the data local, go into the script and enter this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据本地化后，进入脚本并输入以下内容：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you send it to the FSI, you will get the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到 FSI 后，你会得到以下内容：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, this is interesting. We have a very high accuracy rate. One wonders: is
    this because in the case of a single vendor for a product, all of the scrapped
    amount will be associated with them because they are the only ones. However, since
    a single vendor might supply multiple input products and those products might
    have different scrap rates, you can use the model to predict if a given vendor
    and a given product will have a scrap rate. Also, notice that instead of adding
    an input for each vendor and product (which would have made a very sparse data
    frame), there is one input for vendor and one for product. Although these can
    be considered categorical values, we can sacrifice some precision for this exercise.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这很有趣。我们有一个非常高的准确率。人们可能会想：这是否是因为在单一供应商的产品情况下，所有报废的量都将与他们相关，因为他们是唯一的。然而，由于单个供应商可能提供多个输入产品，而这些产品可能有不同的报废率，你可以使用该模型来预测特定供应商和特定产品是否会有报废率。此外，请注意，由于为每个供应商和产品添加一个输入（这将使数据帧非常稀疏），这里有一个供应商输入和一个产品输入。虽然这些可以被认为是分类值，但我们可以为了这个练习牺牲一些精度。
- en: The key thing about the neural network that you will want to remember is that
    the neural network can't tell you how it got its answer (very much like the human
    brain, no?). So the neural network won't report back which combination of vendors
    and products will lead to defects. To do that, you would need to use a different
    model.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住关于神经网络的关键点是，神经网络无法告诉你它是如何得到答案的（非常像人脑，不是吗？）。所以神经网络不会报告哪些供应商和产品的组合会导致缺陷。要做到这一点，你需要使用不同的模型。
- en: Building the application
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: With this neural network giving us enough of what we need, let's go ahead and
    build out our ASP.NET 5.0 application with the model. At the time of writing,
    ASP.NET 5.0 only supports C# so we will have to translate our F# into C# and port
    the code into the application. Once the other languages are supported by ASP.NET,
    we will update the sample code on the website.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个神经网络提供了我们所需的大部分信息，让我们继续构建我们的ASP.NET 5.0应用程序，并使用该模型。在撰写本文时，ASP.NET 5.0仅支持C#，因此我们必须将F#转换为C#并将代码移植到应用程序中。一旦其他语言被ASP.NET支持，我们将更新网站上的示例代码。
- en: If you are not familiar with C#, it is the most popular language on the .NET
    stack and is very similar to Java. C# is a general-purpose language that initially
    combined imperative and object-oriented language features. Lately, functional
    constructs have been bolted onto the language specifications. However, as the
    old carpenter axiom goes, "If it's a screw, use a screwdriver. If it's a nail,
    use a hammer." Since that's the case, you are much better served to do .NET functional
    programming with F#. I'll do my best in the next section to explain any differences
    in the C# implementation when we port the code over.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉C#，它是.NET堆栈中最流行的语言，并且与Java非常相似。C#是一种通用语言，最初结合了命令式和面向对象的语言特性。最近，函数式结构被添加到语言规范中。然而，正如老木匠的格言所说，“如果是螺丝，就用螺丝刀。如果是钉子，就用锤子。”既然如此，你最好用F#进行.NET函数式编程。在下一节中，我将尽力解释在将代码移植过来时C#实现中的任何差异。
- en: Setting up the models
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置模型
- en: 'You already have the boilerplate MVC site created. Open up NuGet Package Manager
    Console and install numl into it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有了创建好的MVC网站模板。打开NuGet包管理器控制台，将其安装到其中：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Setting up the models](img/00139.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![设置模型](img/00139.jpeg)'
- en: 'Next, create a folder called `Models` in the **Solution Explorer**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**解决方案资源管理器**中创建一个名为`Models`的文件夹：
- en: '![Setting up the models](img/00140.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![设置模型](img/00140.jpeg)'
- en: 'In that folder, add a new class file named `VendorProduct`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件夹中，添加一个名为`VendorProduct`的新类文件：
- en: '![Setting up the models](img/00141.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![设置模型](img/00141.jpeg)'
- en: 'Inside that file, replace all of the code with the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件中，将所有代码替换为以下内容：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can guess, this is the equivalent of the record type we create in F#.
    The only real difference is that the properties are mutable by default (so be
    careful). Go to the **Solution Explorer** and find the `Project.json` file. Open
    it and remove this entry in the `frameworks` section:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这相当于我们在F#中创建的记录类型。唯一的真正区别是属性默认可变（所以要小心）。转到**解决方案资源管理器**并找到`Project.json`文件。打开它，并在`frameworks`部分删除此条目：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This section should now look like the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分现在应如下所示：
- en: '![Setting up the models](img/00142.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![设置模型](img/00142.jpeg)'
- en: 'Go ahead and run the website to make sure it is good:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行网站以确保它正常工作：
- en: '![Setting up the models](img/00143.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![设置模型](img/00143.jpeg)'
- en: What we are doing is removing the site's dependency on .NET Core. Although numl
    does support .NET Core, we don't need it right now.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做的是移除网站对.NET Core的依赖。虽然numl支持.NET Core，但我们现在不需要它。
- en: 'If the site is up and running, let''s add the rest of our helper classes. Go
    back into the **Solution Explorer** and add a new class file named `Product.cs`.
    Go into that class and replace the existing code with this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网站正在运行，让我们添加我们剩余的辅助类。回到**解决方案资源管理器**，添加一个名为`Product.cs`的新类文件。进入该类，将现有代码替换为以下内容：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is another record-equivalent class which will be used when the user selects
    the `Product` they want to model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个记录等效类，当用户选择要建模的`Product`时将使用它。
- en: 'Go back to the **Solution Explorer** and add a new class file named `Vendor.cs`.
    Go into that class and replace the existing code with this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**解决方案资源管理器**并添加一个名为`Vendor.cs`的新类文件。进入该类，将现有代码替换为以下内容：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Like the `Product` class, this will be used to populate the select list for
    the user.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Product`类一样，这将用于填充用户的下拉列表。
- en: 'Go back into the **Solution Explorer** and add a new class file named `Repository.cs`.
    Go into that class and replace the existing code with the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**解决方案资源管理器**并添加一个名为 `Repository.cs` 的新类文件。进入该类并将现有代码替换为以下内容：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can probably guess, this is the class that calls out to the database.
    Since C# does not have type providers, we need to handwrite the ADO.NET code.
    We will need to add a reference to `System.Data` to make this code work. Go into
    the **References** in **Solution Explorer** and add it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能猜到的，这是调用数据库的类。由于 C# 没有类型提供者，我们需要手动编写 ADO.NET 代码。我们需要添加对 `System.Data` 的引用以使此代码工作。进入**解决方案资源管理器**中的**引用**并添加它：
- en: '![Setting up the models](img/00144.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![设置模型](img/00144.jpeg)'
- en: 'You can run the site again to make sure we are on the right track. In the **Solution
    Explorer**, add a class file called `NeuralNetwork.cs`. Replace all of its code
    with this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以再次运行网站以确保我们处于正确的轨道。在**解决方案资源管理器**中添加一个名为 `NeuralNetwork.cs` 的类文件。将其所有代码替换为以下内容：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This class does the heavy lifting of the neural network calculations for us.
    Notice that the class is data–agnostic, so it can be ported over to .NET Core
    easily. All we need is a collection of `VendorProducts` to be passed into the
    constructor for the neural network to calculate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类为我们执行了神经网络计算的重活。注意，这个类是数据无关的，因此它可以轻松地移植到 .NET Core。我们需要的只是一个 `VendorProducts`
    集合，将其传递给神经网络的构造函数进行计算。
- en: 'With all of these classes created, your solution explorer should look like
    this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了所有这些类后，您的解决方案资源管理器应该看起来像这样：
- en: '![Setting up the models](img/00145.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![设置模型](img/00145.jpeg)'
- en: You should be able to compile and run the website. Let's now implement a user
    interface for the neural network.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够编译并运行网站。现在让我们为神经网络实现一个用户界面。
- en: Building the UX
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建用户体验
- en: 'The following steps will guide you to build the UX:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您构建用户体验：
- en: 'Go into the **Solution Explorer** and select **AdventureWorks.ProcessAnalysisTool**.
    Navigate to **Add** | **New Item**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**解决方案资源管理器**并选择**AdventureWorks.ProcessAnalysisTool**。导航到**添加** | **新建项**：
- en: '![Building the UX](img/00146.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00146.jpeg)'
- en: 'In the next dialog, select **Class** and name it `Global.cs`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个对话框中，选择**类**并将其命名为 `Global.cs`：
- en: '![Building the UX](img/00147.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00147.jpeg)'
- en: 'Go to the `Global` class and replace all of the contents with the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `Global` 类并将所有内容替换为以下内容：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This class creates a new neural network for us. We can access the neural network's
    functions via the read-only property called `Neural Network`. Because it is marked
    static, the class will stay in memory as long as the application is running.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类为我们创建一个新的神经网络。我们可以通过名为 `Neural Network` 的只读属性访问神经网络的功能。因为它被标记为静态，所以只要应用程序在运行，这个类就会保留在内存中。
- en: 'Next, locate the `Startup.cs` file in the main site:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在主站点中找到 `Startup.cs` 文件。
- en: '![Building the UX](img/00148.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00148.jpeg)'
- en: 'Open the file and replace the constructor (called `Startup`) with this code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件并将构造函数（称为 `Startup`）替换为以下代码：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the website starts up, it will create a global neural network that all
    requests can use.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当网站启动时，它将创建一个所有请求都可以使用的全局神经网络。
- en: Next, locate the `HomeController` in the `Controllers` directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `Controllers` 目录中找到 `HomeController`。
- en: '![Building the UX](img/00149.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00149.jpeg)'
- en: 'Open that file and add this method to populate some drop lists of vendors and
    products:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 打开该文件并添加此方法以填充一些供应商和产品的下拉列表：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, add this method to run `Calculate` on the global neural network when
    the vendor and product are posted back to the server:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加此方法，在供应商和产品被发送回服务器时在全局神经网络上运行 `Calculate`：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you collapse to definitions, the `HomeController` will look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您折叠到定义，`HomeController` 将看起来像这样：
- en: '![Building the UX](img/00150.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00150.jpeg)'
- en: 'Next, go into **Solution Explorer** and navigate to **AdventureWorks.ProcessAnalysisTool**
    | **Views** | **Home**. Right-click on the folder and navigate to **Add** | **New
    Item**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入**解决方案资源管理器**并导航到**AdventureWorks.ProcessAnalysisTool** | **视图** | **主页**。右键单击文件夹并导航到**添加**
    | **新建项**：
- en: '![Building the UX](img/00151.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00151.jpeg)'
- en: 'In the next dialog box, select **MVC View Page** and name it `PredictScrap.cshtml`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个对话框中，选择**MVC 视图页面**并将其命名为 `PredictScrap.cshtml`：
- en: '![Building the UX](img/00152.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00152.jpeg)'
- en: 'Open this page and replace all of the contents with the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个页面并将所有内容替换为以下内容：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is the input form that will allow users to select vendors and products
    and see what the neural network will predict—whether this combination will have
    scrap. When you run the site and navigate to `localhost:port/home/PredictScrap`
    for the first time, you will see the droplists ready for you:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个输入表单，它将允许用户选择供应商和产品，并查看神经网络将预测什么——这个组合是否会有废料。当你第一次运行网站并导航到 `localhost:port/home/PredictScrap`
    时，你会看到为你准备好的下拉列表：
- en: '![Building the UX](img/00153.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00153.jpeg)'
- en: 'Select a vendor and a product and click on **Predict!**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个供应商和一个产品，然后点击 **预测**！：
- en: '![Building the UX](img/00154.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户体验](img/00154.jpeg)'
- en: We now have a fully functioning ASP .NET Core 1.0 website that uses a neural
    network to predict AdventureWorks scrap percentages. With this skeleton, we can
    hand the site off to a UX expert to make the site have a better look and feel—with
    the core functionality in place.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全运行的 ASP .NET Core 1.0 网站，该网站使用神经网络来预测 AdventureWorks 废料百分比。有了这个框架，我们可以将网站交给用户体验专家，使其外观和感觉更好——核心功能已经就位。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter broke some new ground. We dove into ASP.NET 5.0 for our website
    design. We used numl to create two neural networks: one that showed that there
    is no relationship between the area of the company and the scrap rate, and another
    that can be used to predict if there will be scrap based on the vendor and product.
    We then implemented the second model in our website.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开辟了一些新领域。我们深入研究了 ASP.NET 5.0 用于我们的网站设计。我们使用 numl 创建了两个神经网络：一个显示公司面积与废料率之间没有关系，另一个可以根据供应商和产品预测是否会有废料。然后我们在网站上实现了第二个模型。
