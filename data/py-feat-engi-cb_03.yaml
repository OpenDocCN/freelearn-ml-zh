- en: <st c="0">3</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">3</st>
- en: <st c="2">Transforming Numerical Variables</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">变换数值变量</st>
- en: <st c="34">The statistical methods that are used in data analysis make certain
    assumptions about the data.</st> <st c="131">For example, in the general linear
    model, it is assumed that the values of the dependent variable (the target) are
    independent, that there is a linear relationship between the target and the independent
    (predictor) variables, and that the residuals – that is, the difference between
    the predictions and the real values of the target – are normally distributed and
    centered at</st> `<st c="507">0</st>`<st c="508">. When these assumptions are
    not met, the resulting probabilistic statements might not be accurate.</st> <st
    c="608">To correct for failure in the assumptions and thus improve the performance
    of the models, we can transform variables before</st> <st c="732">the analysis.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34">在数据分析中使用的统计方法对数据做出某些假设。</st> <st c="131">例如，在一般线性模型中，假设因变量（目标）的值是独立的，目标变量与自变量（预测变量）之间存在线性关系，以及残差——即预测值与目标真实值之间的差异——是正态分布且以</st>
    `<st c="507">0</st>`<st c="508">为中心。当这些假设不成立时，产生的概率陈述可能不准确。</st> <st c="608">为了纠正假设失败并提高模型性能，我们可以在分析之前变换变量。</st>
    <st c="732">分析</st>
- en: <st c="745">When we transform a variable, we replace its original values with
    a function of that variable.</st> <st c="841">Transforming variables with mathematical
    functions helps reduce variable skewness, improves the value spread, and sometimes
    unmasks linear and additive relationships between predictors and the target.</st>
    <st c="1042">Commonly used mathematical transformations include the logarithm,
    reciprocal, power, and square and cube root transformations, as well as the Box-Cox
    and Yeo-Johnson transformations.</st> <st c="1225">This set of transformations</st>
    <st c="1253">is commonly referred</st> <st c="1273">to as</st> **<st c="1280">variance
    stabilizing transformations</st>**<st c="1316">. Variance stabilizing transformations
    intend to bring the distribution of the variable to a more symmetric – that is,
    Gaussian – shape.</st> <st c="1453">In this chapter, we will discuss when to use
    each transformation and then implement them using NumPy, scikit-learn,</st> <st
    c="1569">and Feature-engine.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="745">当我们变换一个变量时，我们用该变量的函数来替换其原始值。</st> <st c="841">使用数学函数变换变量有助于减少变量的偏度，提高值的分布范围，有时可以揭示预测变量与目标之间的线性关系和加性关系。</st>
    <st c="1042">常用的数学变换包括对数、倒数、幂、平方和立方根变换，以及Box-Cox和Yeo-Johnson变换。</st> <st c="1225">这一系列变换</st>
    <st c="1253">通常被称为</st> **<st c="1280">方差稳定变换</st>**<st c="1316">。方差稳定变换旨在将变量的分布调整为更对称——即高斯——的形状。</st>
    <st c="1453">在本章中，我们将讨论何时使用每种变换，然后使用NumPy、scikit-learn和Feature-engine来实现它们。</st>
- en: <st c="1588">This chapter contains the</st> <st c="1615">following recipes:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1588">本章包含以下内容：</st> <st c="1615">以下食谱：</st>
- en: <st c="1633">Transforming variables with the</st> <st c="1666">logarithm function</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1633">使用对数函数变换变量</st>
- en: <st c="1684">Transforming variables with the</st> <st c="1717">reciprocal function</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1684">使用倒数函数变换变量</st>
- en: <st c="1736">Using the square root to</st> <st c="1762">transform variables</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1736">使用平方根来</st> <st c="1762">变换变量</st>
- en: <st c="1781">Using</st> <st c="1788">power transformations</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1781">使用</st> <st c="1788">幂变换</st>
- en: <st c="1809">Performing</st> <st c="1821">Box-Cox transformatio</st><st c="1842">ns</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1809">执行</st> <st c="1821">Box-Cox变换</st><st c="1842">s</st>
- en: <st c="1845">Performing</st> <st c="1857">Yeo-Johnson transformatio</st><st
    c="1882">ns</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1845">执行</st> <st c="1857">Yeo-Johnson变换</st><st c="1882">s</st>
- en: <st c="1885">Transforming variables with the logarithm function</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1885">使用对数函数变换变量</st>
- en: <st c="1936">The</st> <st c="1940">logarithm function is a</st> <st c="1964">powerful
    transformation for dealing with positive data wi</st><st c="2022">th a right-skewed
    distribution (observations accumulate at lower values of the variable).</st> <st
    c="2113">A comm</st><st c="2119">on example is the</st> `<st c="2138">income</st>`
    <st c="2144">variable, with a heavy accumulation of values toward lower salaries.</st>
    <st c="2214">The logarithm transformation has a strong effect on the shape of
    the</st> <st c="2283">variable distribution.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1936">对数函数是处理具有右偏分布（观测值在变量的较低值处累积）的正数据的有力转换。</st> <st c="1964">一个常见的例子是</st>
    `<st c="2138">收入</st>` <st c="2144">变量，其值在较低工资处有大量累积。</st> <st c="2214">对数转换对变量分布的形状有强烈的影响。</st>
- en: <st c="2305">In this</st> <st c="2314">recipe, we will perform logarithmic transformation
    using NumPy, scikit-learn, and Feature-engine.</st> <st c="2412">We will also
    create a diagnostic plot function to evaluate the effect of the transformation
    on the</st> <st c="2511">variable distributi</st><st c="2530">on.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2305">在这个</st> <st c="2314">菜谱中，我们将使用 NumPy、scikit-learn 和 Feature-engine
    执行对数转换。</st> <st c="2412">我们还将创建一个诊断绘图函数来评估转换对变量分布的影响。</st>
- en: <st c="2534">Getting ready</st>
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2534">准备中</st>
- en: <st c="2548">To evaluate the variable distribution and understand whether a
    transformation improves value spread and stabilizes the variance, we can visually
    inspect the data w</st><st c="2712">ith histograms and</st> **<st c="2732">Quantile-Quantile</st>**
    <st c="2749">(</st>**<st c="2751">Q-Q</st>**<st c="2754">) plots.</st> <st c="2764">A
    Q-Q plot helps us determine whether two</st> <st c="2805">variables show a similar
    distribution.</st> <st c="2845">In a Q-Q plot, we plot the quantiles of one variable
    against the quantiles of the second variable.</st> <st c="2944">If we plot the
    quantiles of the variable of interest against the expected quantiles of the normal
    distribution, then we can determine whether our variable is also normally distributed.</st>
    <st c="3129">If the variable is normally distributed, the points in the Q-Q plot
    will fall along a</st> <st c="3215">45-degree diagonal.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2548">为了评估变量分布并了解转换是否改善了值分布并稳定了方差，我们可以通过直方图和**<st c="2732">分位数-分位数</st>**
    <st c="2749">(**<st c="2751">Q-Q</st>**<st c="2754">) 图来直观地检查数据。</st> <st c="2764">Q-Q
    图帮助我们确定两个</st> <st c="2805">变量是否显示出相似的分布。</st> <st c="2845">在 Q-Q 图中，我们绘制一个变量的分位数与另一个变量的分位数。</st>
    <st c="2944">如果我们绘制感兴趣变量的分位数与正态分布的预期分位数，那么我们可以确定我们的变量是否也是正态分布的。</st> <st c="3129">如果变量是正态分布的，Q-Q
    图中的点将沿着45度对角线。</st>
- en: <st c="3234">Note</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3234">注意</st>
- en: <st c="3239">A quantile is the value below which there is a certain fraction
    of data points in the distribution.</st> <st c="3340">Thus, the 20th quantile
    is the point in the distribution at which 20% of the observations fall below and
    80% above</st> <st c="3455">that va</st><st c="3462">lue.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3239">分位数是分布中低于某个分数的数据点的值。</st> <st c="3340">因此，第20个分位数是分布中20%的观测值低于且80%高于该值的点。</st>
- en: <st c="3467">How to do it...</st>
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3467">如何做到这一点...</st>
- en: <st c="3483">Let’s b</st><st c="3491">egin</st> <st c="3496">by importing the
    libr</st><st c="3518">aries and getting the</st> <st c="3541">dataset ready:</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3483">让我们首先</st><st c="3491">导入</st> <st c="3496">库并准备好</st> <st c="3518">数据集：</st>
- en: <st c="3555">Import the required Python libraries</st> <st c="3593">and dataset:</st>
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="3555">导入所需的 Python 库</st> <st c="3593">和数据集：</st>
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="3758">Let’s</st> <st c="3764">load the California housing dataset into
    a</st> <st c="3808">pandas DataFrame:</st>
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="3758">让我们</st> <st c="3764">将加利福尼亚住房数据集加载到一个</st> <st c="3808">pandas
    DataFrame：</st>
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="3889">Let’s explore the distributions of all the variables in the dataset
    by plotting histograms</st> <st c="3981">with pandas:</st>
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="3889">让我们通过绘制直方图来探索数据集中所有变量的分布</st> <st c="3981">使用 pandas:</st>
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="4038">In the following output, we can see that the</st> `<st c="4084">MedInc</st>`
    <st c="4090">variable shows</st> <st c="4106">a mild right-skewed distribution,
    var</st><st c="4143">iables such as</st> `<st c="4159">AveRooms</st>` <st c="4167">and</st>
    `<st c="4172">Population</st>` <st c="4182">are heavily right-skewed, and the</st>
    `<st c="4217">HouseAge</st>` <st c="4225">variable shows an even spread of values
    across</st> <st c="4273">its</st> <st c="4277">range:</st>
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="4038">在以下输出中，我们可以看到</st> `<st c="4084">MedInc</st>` <st c="4090">变量显示出轻微的右偏斜分布，变量</st><st
    c="4159">AveRooms</st>` <st c="4167">和</st> `<st c="4172">Population</st>` <st
    c="4182">严重右偏斜，而</st> `<st c="4217">HouseAge</st>` <st c="4225">变量在其</st> `<st
    c="4273">范围内</st>` <st c="4277">的值分布得更加均匀：</st>
- en: <st c="4283">figure 3</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4283">图 3</st>
- en: '![Figure 3.1 – Histograms with the distribution of the numerical variables](img/B22396_03_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 数值变量的分布直方图](img/B22396_03_01.jpg)'
- en: <st c="4684">Figure 3.1 – Histograms with the distribution of the numerical
    variables</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4684">图 3.1 – 数值变量的分布直方图</st>
- en: <st c="4756">To</st> <st c="4760">evaluate</st> <st c="4768">the effect of the
    transformation on the variable distribution</st><st c="4830">, we’ll create a
    f</st><st c="4848">unction that takes a DataFrame and a variable name as inputs
    and plots a histogram next to a</st> <st c="4942">Q-Q plot:</st>
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="4756">为了</st> <st c="4760">评估</st> <st c="4768">变换对变量分布的影响</st><st c="4830">，我们将创建一个函数，该函数接受
    DataFrame 和变量名作为输入，并在 Q-Q 图旁边绘制直方图：</st>
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="5221">Let’s</st> <st c="5228">plot the</st> <st c="5236">distribution
    of the</st> `<st c="5257">MedInc</st>` <st c="5263">variable with the function
    from</st> *<st c="5296">step 4</st>*<st c="5302">:</st>
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5221">让我们</st> <st c="5228">用</st> <st c="5236">步骤 4</st> <st c="5302">中的函数绘制</st>
    `<st c="5257">MedInc</st>` <st c="5263">变量的分布图：</st>
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="5334">The following output shows that</st> `<st c="5367">MedInc</st>`
    <st c="5373">has a</st> <st c="5380">right-skewed distr</st><st c="5398">ibution:</st>
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="5334">以下输出显示</st> `<st c="5367">MedInc</st>` <st c="5373">具有右偏斜的分布：</st>
- en: '![Figure 3.2 – A histogram and Q-Q plot of the MedInc variable](img/B22396_03_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – MedInc 变量的直方图和 Q-Q 图](img/B22396_03_02.jpg)'
- en: <st c="5547">Figure 3.2 – A histogram and Q-Q plot of the MedInc variable</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5547">图 3.2 – MedInc 变量的直方图和 Q-Q 图</st>
- en: <st c="5607">Now, let’s transform the data with</st> <st c="5643">the logarithm:</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5607">现在，让我们使用对数变换来转换数据：</st>
- en: <st c="5657">Firs</st><st c="5662">t, let’s mak</st><st c="5675">e a copy of
    the</st> <st c="5692">original DataFrame:</st>
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5657">首先，让我们复制原始 DataFrame：</st>
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="5727">We’ve</st> <st c="5734">created a copy so that we can modify the
    values in the copy and not in the original DataFrame, which we need for the rest
    of</st> <st c="5859">this recipe.</st>
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="5727">我们已经创建了一个副本，这样我们就可以修改副本中的值，而不是原始 DataFrame 中的值，这对于本食谱的其余部分是必需的。</st>
- en: <st c="5871">Note</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5871">注意</st>
- en: <st c="5876">If we execute</st> `<st c="5891">X_tf = X</st>` <st c="5899">instead
    of using pandas’</st> `<st c="5925">copy()</st>`<st c="5931">function,</st> `<st
    c="5942">X_tf</st>` <st c="5946">will not be a copy of the DataFrame; instead,
    it will be another view of the same data.</st> <st c="6035">Therefore, changes
    made in</st> `<st c="6062">X_tf</st>` <st c="6066">will be reflected in</st> `<st
    c="6088">X</st>` <st c="6089">as well.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5876">如果我们执行</st> `<st c="5891">X_tf = X</st>` <st c="5899">而不是使用 pandas
    的</st> `<st c="5925">copy()</st>`<st c="5931">函数，</st> `<st c="5942">X_tf</st>`
    <st c="5946">将不会是 DataFrame 的副本；相反，它将是相同数据的另一个视图。</st> <st c="6035">因此，在</st>
    `<st c="6062">X_tf</st>` <st c="6066">中做出的更改也会反映在</st> `<st c="6088">X</st>` <st
    c="6089">中。</st>
- en: <st c="6097">Let’s</st> <st c="6104">make a list with the variables that we
    want</st> <st c="6148">to transform:</st>
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6097">让我们</st> <st c="6104">创建一个包含我们想要转换的变量的列表：</st>
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="6219">Let’s apply the logarithmic transformation with NumPy to the variables
    from</st> *<st c="6296">step 7</st>* <st c="6302">a</st><st c="6304">nd capture
    the transformed variables in the</st> <st c="6348">new DataFrame:</st>
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6219">让我们使用 NumPy 对步骤 7 <st c="6296">中的变量应用对数变换，并将转换后的变量捕获在新 DataFrame
    中：</st>
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="6391">Note</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6391">注意</st>
- en: <st c="6396">Remember that the logarithm transformation can only be applied
    to strictly positive variables.</st> <st c="6492">If the variables have zero or
    negative values, sometimes, it is useful to add a constant to make those values
    positive.</st> <st c="6612">We could add a constant value of</st> `<st c="6645">1</st>`
    <st c="6647">using</st> `<st c="6653">X_tf[vars] = np.log(X[vars] +</st>` `<st
    c="6683">1)</st>`<st c="6685">.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6396">请记住，对数变换只能应用于严格正变量。</st> <st c="6492">如果变量有零或负值，有时，添加一个常数使这些值变为正是有用的。</st>
    <st c="6612">我们可以使用</st> `<st c="6645">1</st>` <st c="6647">添加一个常数值，使用</st> `<st
    c="6653">X_tf[vars] = np.log(X[vars] +</st>` `<st c="6683">1)</st>`<st c="6685">。</st>
- en: <st c="6686">Let’s check the distribution of</st> `<st c="6719">MedInc</st>`
    <st c="6725">after the transformation with the diagnostic function from</st> *<st
    c="6785">step 4</st>*<st c="6791">:</st>
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6686">让我们使用</st> *<st c="6785">步骤 4</st>*<st c="6791">中的诊断函数检查变换后</st>
    `<st c="6719">MedInc</st>` <st c="6725">的分布：</st>
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="6826">In the following output, we can see that the logarithmic transformation
    returned a more evenly distributed variable that better approximates the theoretical
    normal distribution in the</st> <st c="7011">Q-Q plot:</st>
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="6826">在以下输出中，我们可以看到对数变换返回了一个分布更均匀的变量，在</st> <st c="7011">Q-Q 图</st>中更好地逼近理论正态分布：</st>
- en: "![Figure 3.3 – A histogram and Q-Q plot of the MedInc variable after the logarithm\
    \ transformation\uFEFF](img/B22396_03_03.jpg)"
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 对数变换后 MedInc 变量的直方图和 Q-Q 图](img/B22396_03_03.jpg)'
- en: <st c="7187">Figure 3.3 – A histogram and Q-Q plot of the MedInc variable after
    the logarithm transformation</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7187">图 3.3 – 对数变换后 MedInc 变量的直方图和 Q-Q 图</st>
- en: <st c="7282">Go ahead</st> <st c="7292">an</st><st c="7294">d plot the other
    transformed variables to familiarize yourself with the effect of the logarithm
    transformation</st> <st c="7406">on distributions.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7282">继续</st> <st c="7292">并绘制其他转换变量，以便熟悉对数变换对分布的影响。</st> <st c="7406">。</st>
- en: <st c="7423">Now, let’s</st> <st c="7435">apply the logarithmic transformation</st>
    <st c="7472">with</st> `<st c="7477">scikit-learn</st>`<st c="7489">.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7423">现在，让我们</st> <st c="7435">使用</st> `<st c="7477">scikit-learn</st>`<st
    c="7489">应用对数变换。</st>
- en: <st c="7490">Let’s</st> <st c="7497">import</st> `<st c="7504">FunctionTransformer()</st>`<st
    c="7525">:</st>
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7490">让我们</st> <st c="7497">导入</st> `<st c="7504">FunctionTransformer()</st>`<st
    c="7525">：</st>
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="7581">Before we proceed, we need to take a copy of the original dataset,
    as we did in</st> *<st c="7662">step 6</st>*<st c="7668">.</st>
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="7581">在我们继续之前，我们需要复制原始数据集，就像我们在</st> *<st c="7662">步骤 6</st>*<st c="7668">中所做的那样。</st>
- en: <st c="7669">We’ll set up the transformer to apply the logarithm and to be able
    to revert the transformed variable to its</st> <st c="7779">original representation:</st>
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7669">我们将设置变压器以应用对数并能够将转换后的变量还原到其</st> <st c="7779">原始表示：</st>
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="7866">Note</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7866">注意</st>
- en: <st c="7871">If we set up</st> `<st c="7885">FunctionTransformer()</st>` <st
    c="7906">with the default parameter,</st> `<st c="7935">validate=False</st>`<st
    c="7949">, we don’t need to fit the transformer before transforming the data.</st>
    <st c="8018">If we set</st> `<st c="8028">validate</st>` <st c="8036">to</st>
    `<st c="8040">True</st>`<st c="8044">, the transformer will check the data input
    to the</st> `<st c="8095">fit</st>` <st c="8098">method.</st> <st c="8107">The
    latter is useful when fitting the transformer with a DataFrame so that it learns
    and stores the</st> <st c="8207">variable n</st><st c="8217">ames.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7871">如果我们设置</st> `<st c="7885">FunctionTransformer()</st>` <st c="7906">使用默认参数，</st>
    `<st c="7935">validate=False</st>`<st c="7949">，我们不需要在转换数据之前拟合变压器。</st> <st c="8018">如果我们设置</st>
    `<st c="8028">validate</st>` <st c="8036">为</st> `<st c="8040">True</st>`<st c="8044">，变压器将检查输入到</st>
    `<st c="8095">fit</st>` <st c="8098">方法的</st>数据。</st> <st c="8107">后者在用 DataFrame
    拟合变压器时很有用，以便它学习并存储</st> <st c="8207">变量名称。</st>
- en: <st c="8223">Let’s tr</st><st c="8232">ansform the positive variables from</st>
    *<st c="8269">step 7</st>*<st c="8275">:</st>
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8223">让我们将</st><st c="8232">从</st> *<st c="8269">步骤 7</st>*<st c="8275">转换正变量：</st>
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="8321">Note</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8321">注意</st>
- en: <st c="8326">Scikit-learn transformers return NumPy arrays and transform the
    entire DataFrame by default.</st> <st c="8420">In this case, we assigned the results
    of the array directly to our existing DataFrame.</st> <st c="8507">We can change
    the returned format through the</st> `<st c="8553">set_output</st>` <st c="8563">method
    and we can restrict the variables to transform</st> <st c="8618">with</st> `<st
    c="8623">ColumnTransformer()</st>`<st c="8642">.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8326">Scikit-learn 转换器返回 NumPy 数组，并默认转换整个 DataFrame。</st> <st c="8420">在这种情况下，我们将数组的输出结果直接赋值给现有的
    DataFrame。</st> <st c="8507">我们可以通过</st> `<st c="8553">set_output</st>` <st c="8563">方法更改返回的格式，并且我们可以通过</st>
    `<st c="8623">ColumnTransformer()</st>`<st c="8642">限制要转换的变量。</st>
- en: <st c="8643">Check</st> <st c="8650">the results of the transformation</st>
    <st c="8683">with the diagnostic function from</st> *<st c="8718">step 4</st>*<st
    c="8724">.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8643">使用</st> *<st c="8718">第4步</st>*<st c="8724">中的诊断函数检查转换的结果。</st>
- en: <st c="8725">Let’s now revert the transformation to the original</st> <st c="8778">variable
    representation:</st>
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8725">现在让我们将转换回原始</st> <st c="8778">变量表示：</st>
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="8857">If you check the distribution by executing</st> `<st c="8901">diagnostic_plots(X_tf,
    "MedInc")</st>`<st c="8933">, you should see a plot that is identical to that
    returned by</st> *<st c="8995">step 5</st>*<st c="9001">.</st>
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="8857">如果你通过执行</st> `<st c="8901">diagnostic_plots(X_tf, "MedInc")</st>`<st
    c="8933">来检查分布，你应该看到一个与</st> *<st c="8995">第5步</st>*<st c="9001">返回的相同的图表。</st>
- en: <st c="9002">Note</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9002">注意</st>
- en: '<st c="9007">To add a constant value to the variables, in case they are not
    strictly positive, use</st> `<st c="9094">transformer = FunctionTransformer(lambda
    x: np.log(x +</st>` `<st c="9149">1)</st><st c="9151">)</st>`<st c="9153">.</st>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="9007">为了给变量添加一个常数值，以防它们不是严格正的，请使用</st> `<st c="9094">transformer = FunctionTransformer(lambda
    x: np.log(x +</st>` `<st c="9149">1)</st><st c="9151">)</st>`<st c="9153">.</st>'
- en: <st c="9154">Now, let’s apply the logarithm transformation</st> <st c="9201">with
    Feature-</st><st c="9214">engine.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9154">现在，让我们使用特征-</st><st c="9201">引擎应用对数变换。</st>
- en: <st c="9222">Let’s import</st> <st c="9236">the</st> `<st c="9240">LogTransformer()</st>`<st
    c="9256">:</st>
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9222">让我们导入</st> <st c="9236">的</st> `<st c="9240">LogTransformer()</st>`<st
    c="9256">：</st>
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="9315">We’ll set up the transformer to transform the variables from</st>
    *<st c="9377">step 7</st>* <st c="9383">and then fit the transformer to</st> <st
    c="9416">the dataset:</st>
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9315">我们将设置转换器以转换第</st> *<st c="9377">7步</st>* <st c="9383">的变量，然后拟合转换器到</st>
    <st c="9416">数据集：</st>
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="9476">Note</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9476">注意</st>
- en: <st c="9481">If the</st> `<st c="9489">variables</st>` <st c="9498">argument
    is left as</st> `<st c="9519">None</st>`<st c="9523">,</st> `<st c="9525">LogTransformer()</st>`
    <st c="9541">applies the logarithm to all the numerical variables found during</st>
    `<st c="9608">fit()</st>`<st c="9613">. Alternatively, we can indicate which variables
    to modify, as we did in</st> *<st c="9686">step 15</st>*<st c="9693">.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9481">如果</st> `<st c="9489">变量</st>` <st c="9498">参数留为</st> `<st c="9519">None</st>`<st
    c="9523">，则</st> `<st c="9525">LogTransformer()</st>` <st c="9541">将对在</st> `<st
    c="9608">fit()</st>`<st c="9613">期间找到的所有数值变量应用对数。或者，我们可以指定要修改的变量，就像我们在</st> *<st
    c="9686">第15步</st>*<st c="9693">中所做的那样。</st>
- en: <st c="9694">Finally, let’s</st> <st c="9709">transform</st> <st c="9719">the
    data:</st>
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9694">最后，让我们</st> <st c="9709">转换</st> <st c="9719">数据：</st>
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`<st c="9752">X_tf</st>` <st c="9757">is a copy of the</st> `<st c="9775">X</st>`
    <st c="9776">DataFrame, where the variables from</st> *<st c="9813">step 7</st>*
    <st c="9819">are transformed with</st> <st c="9841">the logarithm.</st>'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="9752">X_tf</st>` <st c="9757">是</st> `<st c="9775">X</st>` <st c="9776">DataFrame的一个副本，其中第</st>
    *<st c="9813">7步</st>* <st c="9819">的变量已用对数进行转换。</st>'
- en: <st c="9855">We can also revert</st> <st c="9875">the transformed variables
    to their</st> <st c="9910">original representation:</st>
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9855">我们还可以将转换后的变量转换回它们的</st> <st c="9875">原始表示：</st>
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="9969">If you check the distribution of the variables after</st> *<st
    c="10023">step 17</st>*<st c="10030">, they should be identical to those of the</st>
    <st c="10073">original data.</st>
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="9969">如果你检查第</st> *<st c="10023">17步</st>*<st c="10030">后的变量的分布，它们应该与原始数据的分布相同。</st>
- en: <st c="10087">Note</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10087">注意</st>
- en: <st c="10092">Feature-engine has a dedicated transformer that adds constant
    values to the variables before the applying the logarithm transformation.</st>
    <st c="10229">Check the</st> *<st c="10239">There’s more…</st>* <st c="10252">section
    later in this recipe fo</st><st c="10284">r</st> <st c="10287">more details.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="10092">Feature-engine有一个专门的转换器，在应用对数变换之前向变量添加常数值。</st>` <st c="10229">在本方法的“*<st
    c="10239">更多内容…</st>*” <st c="10252">部分查看更多详细信息。</st>'
- en: <st c="10300">How it works...</st>
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的<st c="10300">...</st>
- en: <st c="10316">In this recipe, we applied the logarithm transformation to a subset
    of positive variables using NumPy, scikit-learn,</st> <st c="10434">and Feature-engine.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们使用NumPy、scikit-learn和Feature-engine对正变量子集应用了对数变换<st c="10316">。</st>
    <st c="10434">。</st>
- en: <st c="10453">To compare</st> <st c="10464">the effect of the transformation
    on the variable distribution, we created a diagnostic function to plot a histogram
    next to a Q-Q plot.</st> <st c="10601">To create the Q-Q plot, we used</st> `<st
    c="10633">scipy.stats.probplot()</st>`<st c="10655">, which plotted the quantiles
    of the variable of interest in the</st> *<st c="10720">y</st>* <st c="10721">axis
    versus the quantiles of a theoretical normal distribution, which we indicated
    by setting the</st> `<st c="10820">dist</st>` <st c="10824">parameter to</st>
    `<st c="10838">norm</st>` <st c="10842">in the</st> *<st c="10850">x</st>* <st
    c="10851">axis.</st> <st c="10858">We used</st> `<st c="10866">matplotlib</st>`
    <st c="10876">to display the plot by setting the</st> `<st c="10912">plot</st>`
    <st c="10916">parameter</st> <st c="10927">to</st> `<st c="10930">plt</st>`<st
    c="10933">.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较变换对变量分布的影响，我们创建了一个诊断函数来在Q-Q图旁边绘制直方图<st c="10453">。</st> <st c="10464">为了创建Q-Q图，我们使用了</st>
    `<st c="10633">scipy.stats.probplot()</st>`<st c="10655">，它绘制了感兴趣变量的分位数在</st>
    *<st c="10720">y</st>* <st c="10721">轴上与理论正态分布的分位数，我们在</st> *<st c="10850">x</st>*
    <st c="10851">轴上通过将</st> `<st c="10820">dist</st>` <st c="10824">参数设置为</st> `<st
    c="10838">norm</st>` <st c="10842">来表示。</st> <st c="10858">我们使用</st> `<st c="10866">matplotlib</st>`
    <st c="10876">通过将</st> `<st c="10912">plot</st>` <st c="10916">参数设置为</st> `<st
    c="10927">plt</st>`<st c="10933">来显示图表。</st>
- en: <st c="10934">With</st> `<st c="10940">plt.figure()</st>` <st c="10952">and</st>
    `<st c="10957">figsize</st>`<st c="10964">, we adjusted the size of the figure
    and, with</st> `<st c="11011">plt.subplot()</st>`<st c="11024">, we organized
    the two plots in</st> `<st c="11056">one</st>` <st c="11059">row with</st> `<st
    c="11069">two</st>` <st c="11072">columns – that is, one plot next to the other.</st>
    <st c="11120">The numbers within</st> `<st c="11139">plt.subplot()</st>` <st c="11152">indicated
    the number of rows, the number of columns, and the place of the plot in the figure,
    respectively.</st> <st c="11261">We placed the histogram in position 1 and the
    Q-Q plot in position 2 – that is, left and</st> <st c="11350">right, respe</st><st
    c="11362">ctively.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`<st c="10940">plt.figure()</st>` <st c="10952">和`<st c="10957">figsize</st>`<st
    c="10964">，我们调整了图表的大小，并通过`<st c="11011">plt.subplot()</st>`<st c="11024">，我们将两个图表组织在</st>
    `<st c="11056">一</st>` <st c="11059">行</st> `<st c="11069">两</st>` <st c="11072">列中——也就是说，一个图表紧挨着另一个。</st>
    <st c="11120">`<st c="11139">plt.subplot()</st>` <st c="11152">中的数字分别表示行数、列数和图表在图中的位置。</st>
    <st c="11261">我们将直方图放在位置1，将Q-Q图放在位置2——也就是说，左和</st> <st c="11350">右，分别。</st>
- en: <st c="11371">To test the</st> <st c="11384">function, we plotted a histogram
    and a Q-Q plot for the</st> `<st c="11440">MedInc</st>` <st c="11446">variable
    before t</st><st c="11464">he transformation and observed that</st> `<st c="11501">MedInc</st>`
    <st c="11507">was not normally distributed.</st> <st c="11538">Most observations
    were at the left of the histogram and the values deviated from the 45-degree line
    in the Q-Q plot at both ends of</st> <st c="11670">the distribution.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试该函数，我们在变换之前为`<st c="11440">MedInc</st>` <st c="11446">变量绘制了直方图和Q-Q图，并观察到</st>
    `<st c="11501">MedInc</st>` <st c="11507">不是正态分布。</st> <st c="11538">大多数观测值位于直方图的左侧，并且在分布两端的Q-Q图中，值偏离了45度线。</st>
- en: <st c="11687">Next, using</st> `<st c="11700">np.log()</st>`<st c="11708">,
    we applied the logarithm to a slice of the DataFrame with four positive variables.</st>
    <st c="11793">To evaluate the effect of the transformation, we plotted a histogram
    and Q-Q plot of the transformed</st> `<st c="11894">MedInc</st>` <st c="11900">variable.</st>
    <st c="11911">We observed that, after the logarithm transformation, the values
    were more centered in the histogram and that, in the Q-Q plot, they only deviated
    from the 45-degree line toward the ends of</st> <st c="12101">the distribution.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11687">接下来，使用</st> `<st c="11700">np.log()</st>`<st c="11708">，我们对包含四个正变量的
    DataFrame 的一个切片应用了对数。</st> <st c="11793">为了评估变换的效果，我们绘制了变换后</st> `<st c="11894">MedInc</st>`
    <st c="11900">变量的直方图和 Q-Q 图。</st> <st c="11911">我们观察到，在对数变换后，值在直方图中更加集中，而在 Q-Q
    图中，它们仅从 45 度线向分布的末端偏离。</st>
- en: <st c="12118">Next, we used the</st> `<st c="12137">FunctionTransformer()</st>`
    <st c="12158">from scikit-learn, which applies any user-defined function to a
    dataset.</st> <st c="12232">We passed</st> `<st c="12242">np.log()</st>` <st c="12250">as
    an argument to apply the logarithm transformation and NumPy’s</st> `<st c="12316">exp()</st>`
    <st c="12321">for the inverse transformation to</st> `<st c="12356">FunctionTransfomer()</st>`<st
    c="12376">. With the</st> `<st c="12387">transform()</st>` <st c="12398">method,
    we transformed a slice of the DataFrame with the positive variables by using the
    logarithm.</st> <st c="12499">With</st> `<st c="12504">inverse_transform()</st>`<st
    c="12523">, we reverted the variable values to their</st> <st c="12566">original
    representation.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12118">接下来，我们使用了 scikit-learn 的</st> `<st c="12137">FunctionTransformer()</st>`
    <st c="12158">，它可以将任何用户定义的函数应用于数据集。</st> <st c="12232">我们将</st> `<st c="12242">np.log()</st>`
    <st c="12250">作为参数传递以应用对数变换，并使用 NumPy 的</st> `<st c="12316">exp()</st>` <st c="12321">进行逆变换到</st>
    `<st c="12356">FunctionTransfomer()</st>`<st c="12376">。使用</st> `<st c="12387">transform()</st>`
    <st c="12398">方法，我们通过对数变换将 DataFrame 中正变量的一个切片进行了变换。</st> <st c="12499">使用</st>
    `<st c="12504">inverse_transform()</st>`<st c="12523">，我们将变量值还原到它们的</st> <st c="12566">原始表示形式。</st>
- en: <st c="12590">Finally, we used Feature-engine’s</st> `<st c="12625">LogTransformer()</st>`
    <st c="12641">and specified the variables to transform in a list using the</st>
    `<st c="12703">variables</st>` <st c="12712">argument.</st> <st c="12723">With</st>
    `<st c="12728">fit()</st>`<st c="12733">, the transformer checked that the variables
    were numerical and positive, and with</st> `<st c="12816">transform()</st>`<st
    c="12827">, it applied</st> `<st c="12840">np.log()</st>` <st c="12848">under
    the hood to transform the selected variables.</st> <st c="12901">With</st> `<st
    c="12906">inverse_transform()</st>`<st c="12925">, we reverted the transformed
    variables to their</st> <st c="12974">original</st> <st c="12982">representations.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12590">最后，我们使用了 Feature-engine 的</st> `<st c="12625">LogTransformer()</st>`
    <st c="12641">，并使用</st> `<st c="12703">variables</st>` <st c="12712">参数指定要变换的变量列表。</st>
    <st c="12723">使用</st> `<st c="12728">fit()</st>`<st c="12733">，变换器检查变量是否为数值且为正，而使用</st>
    `<st c="12816">transform()</st>`<st c="12827">，它内部应用了</st> `<st c="12840">np.log()</st>`
    <st c="12848">来变换选定的变量。</st> <st c="12901">使用</st> `<st c="12906">inverse_transform()</st>`<st
    c="12925">，我们将变换后的变量还原到它们的</st> <st c="12974">原始</st> <st c="12982">表示形式。</st>
- en: <st c="12999">There’s more…</st>
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12999">还有更多……</st>
- en: <st c="13013">Feature-engine has a</st> <st c="13034">dedicated</st> <st c="13044">transformer
    for adding a constant</st> <st c="13078">value to variables that are not strictly
    positive, before applying the logarithm:</st> `<st c="13161">LogCpTransformer()</st>`<st
    c="13179">.</st> `<st c="13181">LogCpTransformer()</st>` <st c="13199">can:</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13013">Feature-engine 有一个</st> <st c="13034">专门的</st> <st c="13044">变换器，用于在应用对数之前将常数值添加到不是严格正的变量中：</st>
    `<st c="13161">LogCpTransformer()</st>`<st c="13179">。</st> `<st c="13181">LogCpTransformer()</st>`
    <st c="13199">可以：</st>
- en: <st c="13204">Add the same constant to</st> <st c="13230">all variables</st>
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="13204">将相同的常数添加到</st> <st c="13230">所有变量</st>
- en: <st c="13243">Automatically identify and add the minimum value required to make
    the</st> <st c="13314">variables positive</st>
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="13243">自动识别并添加所需的最小值以使</st> <st c="13314">变量为正</st>
- en: <st c="13332">Add different values defined by the user to</st> <st c="13377">different
    variables.</st>
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="13332">将用户定义的不同值添加到</st> <st c="13377">不同的变量中。</st>
- en: <st c="13397">You can find a code implementation of</st> `<st c="13436">LogCpTransformer()</st>`
    <st c="13454">in this book’s GitHub</st> <st c="13477">repository:</st> [<st c="13489">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-1-logarithmic-t</st><st
    c="13635">ransformation.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-1-logarithmic-transformation.ipynb)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13397">您可以在本书的GitHub</st> <st c="13436">仓库中找到</st> `<st c="13436">LogCpTransformer()</st>`
    <st c="13454">的代码实现：</st> [<st c="13489">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-1-logarithmic-t</st><st
    c="13635">ransformation.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-1-logarithmic-transformation.ipynb)
- en: <st c="13655">Transforming variables with the reciprocal function</st>
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="13655">使用倒数函数转换变量</st>
- en: <st c="13707">The reciprocal function</st> <st c="13731">is defined as 1/x</st><st
    c="13749">. It is often useful when we have rati</st><st c="13787">os – that is,
    values resulting from the division of two variables.</st> <st c="13855">Examples
    of</st> <st c="13867">this are</st> **<st c="13876">population density</st>**
    <st c="13894">– that is, people per area – and, as we will see in this recipe,</st>
    **<st c="13960">house occupancy</st>** <st c="13975">– that is, the</st> <st c="13990">number
    of occupants</st> <st c="14011">per house.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13707">倒数函数</st> <st c="13731">定义为1/x</st><st c="13749">。当我们有比率时，它通常很有用，即两个变量的除法结果。</st>
    <st c="13787">这些例子包括</st> **<st c="13876">人口密度</st>** <st c="13894">，即每单位面积的人数，以及我们将在本配方中看到的**<st
    c="13960">房屋占用率</st>** <st c="13975">，即每户的人数。</st>
- en: <st c="14021">The reciprocal</st> <st c="14036">transformation is not defined
    for the</st> `<st c="14075">0</st>` <st c="14076">value, and although it is defined
    for negative values, it is mainly useful for transforming</st> <st c="14169">positive
    variables.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14021">倒数变换在</st> <st c="14036">0</st> <st c="14076">值上未定义，尽管对于负值是定义的，但它主要用于转换</st>
    <st c="14169">正变量。</st>
- en: <st c="14188">In this recipe, we will implement the reciprocal transformation
    using</st> `<st c="14259">NumPy</st>`<st c="14264">,</st> `<st c="14266">scikit-learn</st>`<st
    c="14278">, and</st> `<st c="14284">Feature-engine</st>`<st c="14298">, and compare
    its effect on variable distribution using his</st><st c="14357">tograms and a</st>
    <st c="14372">Q-Q plot</st><st c="14380">.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14188">在本配方中，我们将使用</st> `<st c="14259">NumPy</st>`<st c="14264">,</st>
    `<st c="14266">scikit-learn</st>`<st c="14278">和</st> `<st c="14284">Feature-engine</st>`<st
    c="14298">来实现倒数变换，并使用其直方图和Q-Q图比较其对变量分布的影响。</st>
- en: <st c="14381">How to do it...</st>
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14381">如何操作...</st>
- en: <st c="14397">Let’s</st> <st c="14403">begin by</st> <st c="14413">importing
    the libraries and getting the</st> <st c="14453">dataset ready:</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14397">让我们</st> <st c="14403">首先导入库并准备</st> <st c="14413">数据集：</st>
- en: <st c="14467">Import the required Python libraries</st> <st c="14505">and data:</st>
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14467">导入所需的Python库</st> <st c="14505">和数据：</st>
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="14667">Let’s load</st> <st c="14678">the California</st> <st c="14694">housing
    dataset:</st>
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14667">让我们加载</st> <st c="14678">加利福尼亚</st> <st c="14694">住房数据集：</st>
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="14774">To evaluate variable distributions, we’ll create a function that
    takes a DataFrame and a variable name as inputs and plots a histogram next to
    a</st> <st c="14920">Q-Q plot:</st>
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14774">为了评估变量分布，我们将创建一个函数，该函数接受DataFrame和变量名作为输入，并在Q-Q图旁边绘制直方图：</st>
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="15199">Now, le</st><st c="15207">t’s plot the distribution of the</st>
    `<st c="15240">AveOccup</st>` <st c="15249">variable, which specifies the average
    occupancy of</st> <st c="15301">the house:</st>
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="15199">现在，让我们绘制</st> `<st c="15240">AveOccup</st>` <st c="15249">变量的分布，该变量指定了房屋的平均占用情况：</st>
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="15343">The</st> `<st c="15348">AveOccup</st>` <st c="15356">variable</st>
    <st c="15366">shows a very strong</st> <st c="15385">right-skewed distribution,
    as show</st><st c="15420">n in the</st> <st c="15430">following output:</st>
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="15343">变量</st> `<st c="15348">AveOccup</st>` <st c="15356">显示了一个非常强的</st>
    <st c="15385">右偏分布，如下面的输出所示：</st>
- en: '![Figure 3.4 – A histogram and Q-Q plot of the AveOccup variable](img/B22396_03_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – AveOccup变量的直方图和Q-Q图](img/B22396_03_04.jpg)'
- en: <st c="15699">Figure 3.4 – A histogram and Q-Q plot of the AveOccup variable</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15699">图3.4 – AveOccup变量的直方图和Q-Q图</st>
- en: <st c="15761">Note</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15761">注意</st>
- en: <st c="15766">Th</st><st c="15769">e</st> `<st c="15772">AveOccup</st>` <st
    c="15780">variable</st> <st c="15789">refers to the average number of household
    members – that is, the ratio between t</st><st c="15870">he number of people and
    the nu</st><st c="15901">mber of houses in a certain area.</st> <st c="15936">This
    is a promising variable for a reciprocal transformation.</st> <st c="15998">You
    can find more details about the variables and the dataset by executing</st> `<st
    c="16073">data = fetch_california_housing()</st>` <st c="16106">followed</st>
    <st c="16116">by</st> `<st c="16119">print(data.DESCR)</st>`<st c="16136">.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15766">Th</st><st c="15769">e</st> `<st c="15772">AveOccup</st>` <st
    c="15780">变量</st> <st c="15789">指的是平均家庭人数 – 也就是说，在某个区域内的人数与房屋数量的比率。</st> <st c="15870">这是一个适合倒数变换的有前途的变量。</st>
    <st c="15936">您可以通过执行</st> `<st c="16073">data = fetch_california_housing()</st>`
    <st c="16106">然后</st> <st c="16116">执行</st> `<st c="16119">print(data.DESCR)</st>`<st
    c="16136">来找到更多关于变量和数据集的详细信息。</st>
- en: <st c="16137">Now, let’s apply the reciprocal transformation</st> <st c="16185">with
    NumPy.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16137">现在，让我们使用 NumPy 应用倒数变换</st> <st c="16185">。</st>
- en: <st c="16196">First, let’s make a copy of the original DataFrame so that we
    can modify the values in</st> <st c="16283">the copy and not in the original one,
    which we will need for the rest of</st> <st c="16357">this recipe:</st>
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="16196">首先，让我们复制原始 DataFrame，这样我们就可以修改副本中的值，而不是原始数据，这对于接下来的</st> <st c="16283">这个菜谱</st>
    <st c="16357">是必需的：</st>
- en: '[PRE21]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="16385">Note</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16385">注意</st>
- en: <st c="16390">Remember that executing</st> `<st c="16415">X_tf = X</st>` <st
    c="16423">instead of using pandas’</st> `<st c="16449">copy()</st>` <st c="16455">creates
    an additional view of the same data.</st> <st c="16501">Therefore, changes that
    are made in</st> `<st c="16537">X_tf</st>` <st c="16541">will be r</st><st c="16551">eflected
    in</st> `<st c="16564">X</st>` <st c="16565">as well</st><st c="16572">.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16390">记住，执行</st> `<st c="16415">X_tf = X</st>` <st c="16423">而不是使用 pandas
    的</st> `<st c="16449">copy()</st>` <st c="16455">会创建相同数据的额外视图。</st> <st c="16501">因此，在</st>
    `<st c="16537">X_tf</st>` <st c="16541">中做出的更改也会反映在</st> `<st c="16564">X</st>`
    <st c="16565">中</st><st c="16572">。</st>
- en: <st c="16573">Let’s</st> <st c="16579">apply the reciprocal transformation to
    the</st> `<st c="16623">AveOccup</st>` <st c="16631">variable:</st>
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="16573">让我们</st> <st c="16579">将倒数变换应用到</st> `<st c="16623">AveOccup</st>`
    <st c="16631">变量上：</st>
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="16692">Let’s check the distribution of the</st> `<st c="16729">AveOccup</st>`
    <st c="16737">variable after the transformation with the diagnostic function we
    created in</st> *<st c="16815">step 3</st>*<st c="16821">:</st>
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="16692">让我们使用我们在第3步中创建的诊断函数检查变换后的</st> `<st c="16729">AveOccup</st>` <st
    c="16737">变量分布：</st>
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="16858">Note</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16858">注意</st>
- en: <st c="16863">After the transformation,</st> `<st c="16890">AveOccup</st>` <st
    c="16898">is now the ratio of the number of houses and the number of people in
    a certain area – in other words, houses</st> <st c="17008">per citizen.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16863">变换后，</st> `<st c="16890">AveOccup</st>` <st c="16898">现在是某个区域内房屋数量与人口数量的比率
    – 也就是说，每</st> <st c="17008">位公民的房屋数量。</st>
- en: <st c="17020">Here, we can see a dramatic change in the distribution of the</st>
    `<st c="17083">AveOccup</st>` <st c="17091">variable after th</st><st c="17109">e</st>
    <st c="17112">reciprocal transformation:</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17020">在这里，我们可以看到经过倒数变换后</st> `<st c="17083">AveOccup</st>` <st c="17091">变量分布的显著变化：</st>
- en: "![Figure 3.5 – A histogram and Q-Q plot of the AveOccup variable after the\
    \ reciproc\uFEFFal transfo\uFEFFrmation](img/B22396_03_05.jpg)"
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 经过倒数变换后的 AveOccup 变量的直方图和 Q-Q 图](img/B22396_03_05.jpg)'
- en: <st c="17309">Figure 3.5 – A histogram and Q-Q plot of the AveOccup variable
    after the reciproc</st><st c="17390">al transfo</st><st c="17401">rmation</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17309">图3.5 – 经过倒数变换后的 AveOccup 变量的直方图和 Q-Q 图</st><st c="17390">的转换</st><st
    c="17401"></st>
- en: <st c="17409">Now, let’s apply</st> <st c="17427">the reciprocal transformation</st>
    <st c="17457">with</st> `<st c="17462">scikit-learn</st>`<st c="17474">.</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17409">现在，让我们使用</st> <st c="17427">scikit-learn</st> <st c="17457">应用倒数变换</st>。
- en: <st c="17475">Let’s import</st> <st c="17489">the</st> `<st c="17493">FunctionTransformer()</st>`<st
    c="17514">:</st>
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17475">让我们导入</st> <st c="17489">FunctionTransformer()</st> <st c="17514">：</st>
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="17570">Let’s set up the transformer by passing</st> `<st c="17611">np.reciprocal</st>`
    <st c="17624">as</st> <st c="17628">an argument:</st>
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17570">让我们通过传递</st> `<st c="17611">np.reciprocal</st>` <st c="17624">作为参数来设置转换器：</st>
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="17689">Note</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17689">注意</st>
- en: <st c="17694">By default,</st> `<st c="17707">FunctionTransformer()</st>` <st
    c="17728">does not need to be fit before tran</st><st c="17764">sforming</st>
    <st c="17774">the data.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17694">默认情况下，</st> `<st c="17707">FunctionTransformer()</st>` <st c="17728">在转换数据之前不需要拟合。</st>
- en: <st c="17783">Now, let’s</st> <st c="17795">make a copy of the orig</st><st
    c="17818">inal dataset and transform</st> <st c="17846">the variable:</st>
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17783">现在，让我们</st> <st c="17795">复制原始数据集并转换变量：</st>
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="17932">You can check the effect of the transformation using the function
    from</st> *<st c="18004">step 3</st>*<st c="18010">.</st>
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="17932">您可以使用</st> *<st c="18004">步骤 3</st>*<st c="18010">中的函数来检查转换的效果。</st>
- en: <st c="18011">Note</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18011">注意</st>
- en: <st c="18016">The inverse transformation of the reciprocal function is also
    the reciprocal function.</st> <st c="18104">Hence, if you re-apply</st> `<st c="18127">transform()</st>`
    <st c="18138">to the transformed data, you will revert it to its original representation.</st>
    <st c="18215">A better practice would be to set the</st> `<st c="18253">inverse_transform</st>`
    <st c="18270">parameter of the</st> `<st c="18288">FunctionTransformer()</st>`
    <st c="18309">to</st> `<st c="18313">np.reciprocal</st>` <st c="18326">as well.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18016">倒数函数的逆变换也是倒数函数。</st> <st c="18104">因此，如果您重新应用</st> `<st c="18127">transform()</st>`
    <st c="18138">到转换后的数据，您将将其还原为其原始表示。</st> <st c="18215">更好的做法是将</st> `<st c="18253">inverse_transform</st>`
    <st c="18270">参数的</st> `<st c="18288">FunctionTransformer()</st>` <st c="18309">设置为</st>
    `<st c="18313">np.reciprocal</st>` <st c="18326">。</st>
- en: <st c="18335">Now, let’s apply</st> <st c="18352">the reciprocal transformation</st>
    <st c="18383">with</st> `<st c="18388">feature-engine</st>`<st c="18402">.</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18335">现在，让我们使用</st> <st c="18352">倒数转换</st> <st c="18383">和</st> `<st
    c="18388">feature-engine</st>`<st c="18402">应用。</st>
- en: <st c="18403">Let’s import</st> <st c="18417">the</st> `<st c="18421">ReciprocalTransformer()</st>`<st
    c="18444">:</st>
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18403">让我们导入</st> <st c="18417">的 `<st c="18421">ReciprocalTransformer()</st>`<st
    c="18444">：</st>
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="18510">Let’s set up the transformer to modify the</st> `<st c="18554">AveOccup</st>`
    <st c="18562">variable and then fit it to</st> <st c="18591">the dataset:</st>
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18510">让我们设置转换器以修改</st> `<st c="18554">AveOccup</st>` <st c="18562">变量，并将其拟合到</st>
    <st c="18591">数据集：</st>
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="18662">Note</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18662">注意</st>
- en: <st c="18667">If the</st> `<st c="18675">variables</st>` <st c="18684">argument
    is set to</st> `<st c="18704">None</st>`<st c="18708">, the transformer applies
    the reciprocal function to</st> *<st c="18761">all the numerical variables</st>*
    <st c="18788">in the dataset.</st> <st c="18805">If some of the variables contain
    a</st> `<st c="18840">0</st>` <st c="18841">value, the transfo</st><st c="18860">rmer
    will rais</st><st c="18875">e</st> <st c="18878">an error.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18667">如果将</st> `<st c="18675">变量</st>` <st c="18684">参数设置为</st> `<st
    c="18704">None</st>`<st c="18708">，转换器将倒数函数应用于数据集中的所有数值变量。</st> <st c="18805">如果某些变量包含一个</st>
    `<st c="18840">0</st>` <st c="18841">值，转换器将引发一个错误。</st>
- en: <st c="18887">Let’s</st> <st c="18893">transform the selected variable in</st>
    <st c="18929">our dataset:</st>
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18887">让我们</st> <st c="18893">转换数据集中选择的变量：</st>
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`<st c="18964">ReciprocalTransformer()</st>` <st c="18988">will return a new
    pandas DataFrame containing the original variables, where the variable indicated
    in</st> *<st c="19091">step 12</st>* <st c="19098">is transform</st><st c="19111">ed
    with the</st> <st c="19124">reciprocal function.</st>'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="18964">ReciprocalTransformer()</st>` <st c="18988">将返回一个包含原始变量的新 pandas
    DataFrame，其中在</st> *<st c="19091">步骤 12</st>* <st c="19098">中指示的变量通过</st> <st
    c="19111">以下</st> <st c="19124">倒数函数进行转换。</st>'
- en: <st c="19144">How it works...</st>
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="19144">如何工作...</st>
- en: <st c="19160">In this recipe, we applied the reciprocal transformation using
    NumPy, scikit-learn,</st> <st c="19245">and Feature-engine.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19160">在这个菜谱中，我们使用了 NumPy、scikit-learn 和 Feature-engine 应用了倒数转换。</st>
- en: <st c="19264">To evaluate the variable distribution, we used the function to
    plot a histogram next to a Q-Q plot that we described in the</st> *<st c="19389">How
    it works…</st>* <st c="19402">section of the</st> *<st c="19418">Transforming
    variables with the logarithm function</st>* <st c="19468">recipe earlier in</st>
    <st c="19487">this chapter.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19264">为了评估变量分布，我们使用了函数来绘制一个直方图，旁边是一个 Q-Q 图，这是我们之前在本章的</st> *<st c="19389">如何工作…</st>*
    <st c="19402">部分中描述的。</st>
- en: <st c="19500">We plotted the histogram and Q-Q plot of the</st> `<st c="19546">AveOccup</st>`
    <st c="19554">variable, which showed a heavy right-skewed distribution; most of
    its values were at the left of the histogram and they deviated from the 45-degree
    line toward the right end of the distribution in the</st> <st c="19756">Q-Q plot.</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19500">我们绘制了`<st c="19546">AveOccup</st>` <st c="19554">变量的直方图和Q-Q图，这显示了严重的右偏分布；其大部分值位于直方图的左侧，并且在Q-Q图中偏离了向右端分布的45度线。</st>
- en: <st c="19765">To carry out the</st> <st c="19783">reciprocal transformation,
    we applied</st> `<st c="19821">np.reciprocal()</st>` <st c="19836">to the variable.</st>
    <st c="19854">After the transformation,</st> `<st c="19880">AveOccup</st>`<st
    c="19888">’s va</st><st c="19894">lues were more evenly d</st><st c="19918">istributed
    across the value range and followed the theoretical quantiles of the normal distribution
    in the Q-Q plot</st> <st c="20035">more closely.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19765">为了执行倒数变换，我们将</st> `<st c="19783">np.reciprocal()</st>` <st c="19821">应用于变量。</st>
    `<st c="19854">变换后，</st>` `<st c="19880">AveOccup</st>`<st c="19888">的值在值范围内分布得更均匀，并且在Q-Q图中更接近正态分布的理论分位数。</st>
- en: <st c="20048">Next, we used</st> `<st c="20063">np.reciprocal()</st>` <st c="20078">with
    scikit-learn’s</st> `<st c="20099">FunctionTransformer()</st>`<st c="20120">.
    The</st> `<st c="20126">transform()</st>` <st c="20137">method applied</st> `<st
    c="20153">np.reciprocal()</st>` <st c="20168">to</st> <st c="20172">the dataset.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20048">接下来，我们使用了</st> `<st c="20063">np.reciprocal()</st>` <st c="20078">与scikit-learn的`<st
    c="20099">FunctionTransformer()</st>`<st c="20120">。`<st c="20126">transform()</st>`
    <st c="20137">方法将`<st c="20153">np.reciprocal()</st>` <st c="20168">应用于</st> <st
    c="20172">数据集。</st>
- en: <st c="20184">Note</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20184">注意</st>
- en: <st c="20189">To restrict the effect of</st> `<st c="20216">FunctionTransformer()</st>`
    <st c="20237">to a group of variables, use the</st> `<st c="20271">ColumnTransformer()</st>`<st
    c="20290">. To change the output to a pandas DataFrame, set the transform output</st>
    <st c="20361">to pandas.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20189">为了将</st> `<st c="20216">FunctionTransformer()</st>` <st c="20237">的影响限制在一组变量上，使用</st>
    `<st c="20271">ColumnTransformer()</st>`<st c="20290">。要将输出更改为pandas DataFrame，设置转换输出</st>
    `<st c="20361">为pandas。</st>
- en: <st c="20371">Finally, we</st> <st c="20383">used Feature-engine’s</st> `<st
    c="20406">ReciprocalTransformer()</st>` <st c="20429">to specifically modify one
    variable.</st> <st c="20467">With</st> `<st c="20472">fit()</st>`<st c="20477">,
    the transformer checked that the variable was numerical.</st> <st c="20536">With</st>
    `<st c="20541">transform()</st>`<st c="20552">, the transformer applied</st> `<st
    c="20578">np.reciprocal()</st>` <st c="20593">under the hood to transform</st>
    <st c="20622">the variable.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20371">最后，我们</st> <st c="20383">使用了Feature-engine的</st> `<st c="20406">ReciprocalTransformer()</st>`
    <st c="20429">来特别修改一个变量。</st> <st c="20467">使用</st> `<st c="20472">fit()</st>`<st
    c="20477">，转换器检查该变量是否为数值型。</st> <st c="20536">使用</st> `<st c="20541">transform()</st>`<st
    c="20552">，转换器在内部应用了`<st c="20578">np.reciprocal()</st>` <st c="20593">来转换</st>
    <st c="20622">该变量。</st>
- en: <st c="20635">Feature-engine’s</st> `<st c="20653">ReciprocalTransformer()</st>`
    <st c="20676">provides functionality to revert the variable to its original representation
    out of the box via the</st> `<st c="20777">inverse_transform()</st>` <st c="20796">method.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20635">Feature-engine的`<st c="20653">ReciprocalTransformer()</st>` <st
    c="20676">提供了通过`<st c="20777">inverse_transform()</st>` <st c="20796">方法直接将变量恢复到其原始表示的功能。</st>
- en: <st c="20804">Note</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20804">注意</st>
- en: <st c="20809">Using the transformers from scikit-learn or Feature-engine, instead
    of NumPy’s</st> `<st c="20889">reciprocal()</st>` <st c="20901">function, allows
    us to apply the reciprocal function as an additional step of a feature engineering
    pipeline within the</st> `<st c="21022">Pipeline</st>` <st c="21030">object</st>
    <st c="21038">from scikit-learn.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20809">使用scikit-learn或Feature-engine的转换器，而不是NumPy的`<st c="20889">reciprocal()</st>`
    <st c="20901">函数，允许我们在scikit-learn的`<st c="21022">Pipeline</st>` <st c="21030">对象</st>
    <st c="21038">中应用倒数函数作为特征工程管道的额外步骤。</st>
- en: <st c="21056">The difference</st> <st c="21072">between</st> `<st c="21080">FunctionTransformer()</st>`
    <st c="21101">and</st> `<st c="21106">ReciprocalTransformer()</st>` <st c="21129">is
    that the first one can apply any user-specified transformation, whereas the latter
    only applies the reciprocal function.</st> <st c="21254">scikit-learn returns
    NumPy arrays by default and transforms all variables in the dataset.</st> <st
    c="21344">Feature-engine’s transformer, on the other hand, returns pandas DataFrames
    and can modif</st><st c="21432">y subsets of variables within the data</st> <st
    c="21471">without using</st> <st c="21486">additional classes.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21056">`FunctionTransformer()`</st> <st c="21072">和</st> `<st c="21106">ReciprocalTransformer()`</st>`
    <st c="21129">之间的区别在于，前者可以应用任何用户指定的变换，而后者仅应用倒数函数。</st> `<st c="21254">scikit-learn
    默认返回 NumPy 数组，并转换数据集中的所有变量。</st> `<st c="21344">另一方面，Feature-engine 的转换器返回 pandas
    DataFrame，并且可以在不使用</st> `<st c="21486">额外类</st>` <st c="21471">的情况下修改数据中的变量子集。</st>
- en: <st c="21505">Using the square root to transform variables</st>
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="21505">使用平方根变换变量</st>
- en: <st c="21550">The</st> <st c="21554">square root transformation,</st> **<st
    c="21583">√x</st>**<st c="21585">, as well as its variations, the Anscombe transformation,</st>
    **<st c="21643">√(x+3/8)</st>**<st c="21651">, and the Freeman-Tukey transf</st><st
    c="21681">ormation,</st> **<st c="21692">√x + √(x+1)</st>**<st c="21703">, are
    variance stabilizing transformations that transform a variable with a P</st><st
    c="21780">oisson distribution into one with an approximately standard Gaussian
    distribution.</st> <st c="21864">The square root transformation is a form of power
    transformation where the exponent is</st> **<st c="21951">1/2</st>** <st c="21954">and
    is only defined for</st> <st c="21979">positive values.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21550">平方根变换，**<st c="21583">√x</st>**<st c="21585">，以及其变体，Anscombe 变换，**<st
    c="21643">√(x+3/8)</st>**<st c="21651">，以及 Freeman-Tukey 变换，**<st c="21692">√x
    + √(x+1)</st>**<st c="21703">，都是方差稳定变换，可以将具有泊松分布的变量转换为具有近似标准高斯分布的变量。</st> `<st
    c="21864">平方根变换是一种幂变换形式，其中指数为</st> **<st c="21951">1/2</st>** <st c="21954">，并且仅对</st>
    `<st c="21979">正值</st>` <st c="21979">定义。</st>
- en: <st c="21995">The</st> <st c="21999">Poisson distribution is a probability distribution
    that indicates the number of times an event is likely to occur.</st> <st c="22115">In
    other words, it is a count distribution.</st> <st c="22159">It is right-skewed
    and its variance equals its mean.</st> <st c="22212">Examples of variables that
    could follow a Poisson distribution are the number of financial items of a customer,
    such as the number of current accounts or credit cards, the number of passengers
    in a vehicle, and the number of occupants in</st> <st c="22450">a household.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21995">泊松分布是一种概率分布，表示事件可能发生的次数。</st> `<st c="22115">换句话说，它是一种计数分布。</st>
    `<st c="22159">它是右偏斜的，其方差等于其均值。</st> `<st c="22212">可能遵循泊松分布的变量示例包括客户的金融项目数量，例如当前账户或信用卡的数量，车辆中的乘客数量，以及家庭中的居住者数量。</st>
- en: <st c="22462">In this recipe, we will implement square root transformations
    using Num</st><st c="22534">Py, scikit-learn,</st> <st c="22553">and Feature-engine.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22462">在这个配方中，我们将使用 NumPy、scikit-learn 和 Feature-engine 实现平方根变换。</st>
- en: <st c="22572">How to do it...</st>
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="22572">如何实现...</st>
- en: <st c="22588">We’ll start</st> <st c="22601">by creating a dataset with two
    variables whose values are drawn from a</st> <st c="22672">Poisson distribution:</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22588">我们将</st> <st c="22601">首先创建一个包含两个变量的数据集，这两个变量的值是从</st> `<st c="22672">泊松分布</st>`
    <st c="22672">中抽取的：</st>
- en: <st c="22693">Let’s begin by importing the</st> <st c="22723">necessary libraries:</st>
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="22693">让我们首先导入必要的库：</st>
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="22810">Let’s</st> <st c="22817">create a DataFrame with two variables
    drawn from a Poisson distribution with mean values of</st> `<st c="22909">2</st>`
    <st c="22910">and</st> `<st c="22915">3</st>`<st c="22916">, respectively, and</st>
    `<st c="22936">10000</st>` <st c="22941">observations:</st>
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="22810">让我们</st> <st c="22817">创建一个包含两个变量的 DataFrame，这两个变量分别从均值为</st>
    `<st c="22909">2</st>` <st c="22910">和</st> `<st c="22915">3</st>`<st c="22916">的泊松分布中抽取，并且</st>
    `<st c="22936">10000</st>` <st c="22941">个观测值：</st>
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="23079">Let’s create a function that takes a</st> <st c="23117">DataFrame
    and a variab</st><st c="23139">le name as inputs and plots a bar graph with the
    number of observations per value next to a</st> <st c="23232">Q-Q plot:</st>
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="23079">让我们创建一个函数，它接受一个</st> `<st c="23117">DataFrame</st>` <st c="23139">和一个变量名作为输入，并在Q-Q图旁边绘制一个条形图，显示每个值的观测数：</st>
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="23537">Let’s create a bar plot and a Q-Q plot for one of the variables
    in the data using the function from</st> *<st c="23638">step 3</st>*<st c="23644">:</st>
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="23537">让我们使用第3步中的函数为数据中的一个变量创建条形图和Q-Q图：</st>
- en: '[PRE33]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="23678">Here, we can see t</st><st c="23697">he Poisson distribution in</st>
    <st c="23725">the output:</st>
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23678">在这里，我们可以看到输出中的泊松分布：</st><st c="23697"></st>
- en: "![Figure 3.6 – The bar and Q-Q pl\uFEFFots of the counts1 variable](img/B22396_03_06.jpg)"
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – counts1变量的条形图和Q-Q图](img/B22396_03_06.jpg)'
- en: <st c="23866">Figure 3.6 – The bar and Q-Q pl</st><st c="23897">ots of the counts1
    variable</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23866">图3.6 – counts1变量的条形图和Q-Q图</st><st c="23897"></st>
- en: <st c="23925">Now, let’s</st> <st c="23937">make a copy of</st> <st c="23952">the</st>
    <st c="23955">dataset:</st>
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="23925">现在，让我们</st> `<st c="23937">复制</st>` `<st c="23952">数据集：</st>`
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="23982">Let’s apply the</st> <st c="23998">square root transformation
    to</st> <st c="24029">both variables:</st>
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="23982">让我们将平方根转换应用于</st> `<st c="23998">两个变量：</st>`
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="24112">Let’s round the values to two decimals for a</st> <st c="24158">nicer
    visualization:</st>
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24112">让我们将值四舍五入到两位小数，以便更好地可视化：</st>
- en: '[PRE36]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="24254">Let’s plot the distribution of</st> `<st c="24286">counts1</st>`
    <st c="24293">after</st> <st c="24300">the transformation:</st>
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24254">让我们绘制转换后</st> `<st c="24286">counts1</st>` <st c="24293">的分布图：</st>
- en: '[PRE37]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="24354">We see a more</st> **<st c="24369">stabilized</st>** <st c="24379">variance,
    as the dots in the Q-Q plot foll</st><st c="24422">ow the 45-degree diagonal</st>
    <st c="24449">more closely:</st>
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="24354">我们看到方差更加</st> **<st c="24369">稳定</st>** <st c="24379">，因为Q-Q图中的点更紧密地遵循45度对角线：</st>
- en: "![Figure 3.7 – The bar and Q-Q plots of the counts1 variable after th\uFEFF\
    e square root transformation](img/B22396_03_07.jpg)"
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – counts1变量平方根转换后的条形图和Q-Q图](img/B22396_03_07.jpg)'
- en: <st c="24667">Figure 3.7 – The bar and Q-Q plots of the counts1 variable after
    th</st><st c="24734">e square root transformation</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24667">图3.7 – counts1变量平方根转换后的条形图和Q-Q图</st><st c="24734"></st>
- en: <st c="24763">Now, let’s</st> <st c="24775">apply the square root</st> <st c="24796">transformation</st>
    <st c="24812">with</st> `<st c="24817">scikit-learn</st>`<st c="24829">.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24763">现在，让我们</st> `<st c="24775">应用</st>` `<st c="24796">平方根</st>` `<st
    c="24812">转换</st>` `<st c="24817">scikit-learn</st>`<st c="24829">。</st>
- en: <st c="24830">Let’s import</st> `<st c="24844">FunctionTransformer()</st>` <st
    c="24865">and set up it to perform a square</st> <st c="24900">root transformation:</st>
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24830">让我们导入</st> `<st c="24844">FunctionTransformer()</st>` <st c="24865">并将其设置为执行平方根转换：</st>
- en: '[PRE38]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="25049">Note</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25049">注意</st>
- en: <st c="25054">If we wanted to round the values as we did in</st> *<st c="25101">step
    7</st>*<st c="25107">, we can set up the transformer using</st> `<st c="25145">transformer
    = FunctionTransformer(func=lambda x:</st>` `<st c="25194">np.round(np.sqrt(x),
    2))</st>`<st c="25218">.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25054">如果我们想像第7步中那样四舍五入值，我们可以使用以下方式设置转换器：</st> `<st c="25145">transformer
    = FunctionTransformer(func=lambda x:</st>` `<st c="25194">np.round(np.sqrt(x),
    2))</st>`<st c="25218">。</st>
- en: <st c="25219">Let’s make a copy of the data and transform</st> <st c="25264">the
    variables:</st>
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25219">让我们复制数据并转换</st> `<st c="25264">变量：</st>`
- en: '[PRE39]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="25330">Go ahead and check the result of the transformation as we did
    in</st> *<st c="25396">step 8</st>*<st c="25402">.</st>
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25330">像我们在第8步中做的那样，检查转换的结果：</st>
- en: <st c="25403">To apply</st> <st c="25412">the square root with Feature-engine
    instead, we use the</st> `<st c="25469">PowerTransformer()</st>` <st c="25487">with
    an exponent</st> <st c="25505">of 0.5:</st>
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25403">要使用Feature-engine应用平方根，我们使用指数为0.5的</st> `<st c="25469">PowerTransformer()</st>`
    <st c="25487">：</st>
- en: '[PRE40]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="25607">Next, we</st> <st c="25617">fit the transformer to</st> <st c="25640">the
    data:</st>
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25607">接下来，我们将转换器拟合到</st> `<st c="25640">数据：</st>`
- en: '[PRE41]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="25664">Note</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25664">注意</st>
- en: <st c="25669">The transformer automatically identifies the numerical variables,
    which we can explore by</st> <st c="25760">executing</st> `<st c="25770">root_t.variables_</st>`<st
    c="25787">.</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25669">转换器会自动识别数值变量，我们可以通过执行 `<st c="25770">root_t.variables_</st>`<st
    c="25787">.</st> 来探索这些变量。</st>
- en: <st c="25788">Finally, let’s transform</st> <st c="25814">the data:</st>
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25788">最后，让我们对数据进行变换：</st> <st c="25814">。</st>
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`<st c="25852">PowerTransformer()</st>` <st c="25871">returns a panda</st><st
    c="25887">s DataFrame with the</st> <st c="25909">transformed variables.</st>'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="25852">PowerTransformer()</st>` <st c="25871">返回一个包含变换变量的 panda DataFrame。</st>'
- en: <st c="25931">How it works…</st>
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="25931">它是如何工作的…</st>
- en: <st c="25945">In this recipe, we applied the square root transformation using
    NumPy, scikit-learn,</st> <st c="26031">and Feature-engine.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25945">在这个步骤中，我们使用了 NumPy、scikit-learn 和 Feature-engine 应用了平方根变换。</st>
- en: <st c="26050">We used NumPy’s</st> `<st c="26067">sqrt()</st>` <st c="26073">function
    either directly or within scikit-learn’s</st> `<st c="26124">FunctionTrasnformer()</st>`
    <st c="26145">to determine the variables’ square root.</st> <st c="26187">Alternatively,
    we used Feature-engine’s</st> `<st c="26227">PowerTransformer()</st>`<st c="26245">,
    setting the exponent to 0.5, that of the square root function.</st> <st c="26310">NumPy
    modified the variables directly.</st> <st c="26349">The transformers of scikit-learn
    and Feature-engine modified the var</st><st c="26417">iables when calling the</st>
    `<st c="26442">transform()</st>` <st c="26453">method.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26050">我们使用了 NumPy 的 `<st c="26067">sqrt()</st>` <st c="26073">函数，或者在其内部通过
    scikit-learn 的 `<st c="26124">FunctionTransformer()</st>` <st c="26145">来确定变量的平方根。</st>
    <st c="26187">或者，我们使用了 Feature-engine 的 `<st c="26227">PowerTransformer()</st>`<st
    c="26245">，将指数设置为 0.5，即平方根函数的指数。</st> <st c="26310">NumPy 直接修改了变量。</st> <st c="26349">scikit-learn
    和 Feature-engine 的转换器在调用 `<st c="26442">transform()</st>` <st c="26453">方法时修改了变量。</st>
- en: <st c="26461">Using power transformations</st>
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="26461">使用幂变换</st>
- en: <st c="26489">Power functions</st> <st c="26506">are mathematical transformations
    that follow the</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msup><mi>X</mi><mrow><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>d</mi><mi>a</mi></mrow></msup></mrow></mrow></math>](img/15.png)
    <st c="26555"><st c="26562">format, where lambda can take any value.</st> <st
    c="26603">The square and</st> <st c="26617">cube root transformations are special
    cases of power transformations where lambda is 1/2 or 1/3, respectively.</st>
    <st c="26729">The challenge resides in finding the value for the lambda parameter.</st>
    <st c="26798">The Box-Cox transformation, which</st> <st c="26831">is a generalization
    of the power transformations, finds the optimal lambda value via maximum likelihood.</st>
    <st c="26937">We will discuss the Box-Cox transformation in the following recipe.</st>
    <st c="27005">In practice, we will try different lambda values and visually inspect
    the variable distribution to determine which one offers the best transformation.</st>
    <st c="27156">In general, if the data is right-skewed – that is, if observations
    accumulate toward lower values – we use a lambda value that is smaller than 1,
    while if the data is left-skewed – that is, there are more observations around
    higher values – then we use a lambda value that is greater</st> <st c="27440">than
    1.</st></st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26489">幂函数</st> <st c="26506">是遵循以下</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><msub><mi>X</mi><mi>t</mi></msub><mo>=</mo><msup><mi>X</mi><mrow><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>d</mi><mi>a</mi></mrow></msup></mrow></mrow></math>](img/15.png)
    <st c="26555"><st c="26562">格式的数学变换，其中 lambda 可以取任何值。</st> <st c="26603">平方和立方根变换是
    lambda 分别为 1/2 或 1/3 的幂变换的特殊情况。</st> <st c="26729">挑战在于找到 lambda 参数的值。</st> <st
    c="26798">Box-Cox 变换，它是幂变换的推广，通过最大似然法找到最优的 lambda 值。</st> <st c="26937">我们将在下面的步骤中讨论
    Box-Cox 变换。</st> <st c="27005">在实践中，我们将尝试不同的 lambda 值，并通过视觉检查变量分布来确定哪个提供了最佳的变换。</st>
    <st c="27156">一般来说，如果数据是右偏斜的——也就是说，如果观测值累积在较低值附近——我们使用小于 1 的 lambda 值，而如果数据是左偏斜的——也就是说，在较高值附近的观测值更多——那么我们使用大于
    1 的 lambda 值。</st> <st c="27440">。</st>
- en: <st c="27447">In this recipe, we will carry out power transformations u</st><st
    c="27505">sing NumPy, scikit-learn,</st> <st c="27532">an</st><st c="27534">d
    Feature-engine.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27447">在这个步骤中，我们将使用 NumPy、scikit-learn 和 Feature-engine 执行幂变换。</st>
- en: <st c="27552">How to do it...</st>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27552">如何操作...</st>
- en: <st c="27568">Let’s begin by importing</st> <st c="27594">the libraries and
    getting the</st> <st c="27624">dataset ready:</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27568">让我们首先导入</st> <st c="27594">库和准备数据集：</st>
- en: <st c="27638">Import the required Python libraries</st> <st c="27676">and classes:</st>
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27638">导入所需的Python库和类：</st>
- en: '[PRE43]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="27894">Let’s load the California housing dataset into a</st> <st c="27944">pandas
    DataFrame:</st>
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27894">让我们将加利福尼亚住房数据集加载到一个</st> <st c="27944">pandas DataFrame中：</st>
- en: '[PRE44]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="28026">To evaluate variable distributions, we’ll create a function that
    takes a DataFrame and a</st> <st c="28115">variable name as inputs and plots a
    histogram next to a</st> <st c="28172">Q-Q plot:</st>
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28026">为了评估变量分布，我们将创建一个函数，该函数接受DataFrame和变量名作为输入，并在Q-Q图旁边绘制直方图：</st>
    <st c="28115"></st> <st c="28172"></st>
- en: '[PRE45]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="28451">Let’s plot the distribution of the</st> `<st c="28487">Population</st>`
    <st c="28497">variable with the</st> <st c="28516">previous function:</st>
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28451">让我们使用之前的函数绘制</st> `<st c="28487">Population</st>` <st c="28497">变量的分布图：</st>
- en: '[PRE46]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="28568">In the plots returned by the previous command, we can see t</st><st
    c="28628">hat</st> `<st c="28633">Population</st>` <st c="28643">is heavily skewed
    to</st> <st c="28665">the right:</st>
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28568">在之前命令返回的图表中，我们可以看到</st> `<st c="28633">Population</st>` <st c="28643">严重向右倾斜：</st>
- en: "![Figure 3.8 – A histogram and \uFEFFQ-Q plot of the Population variable](img/B22396_03_08.jpg)"
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 变量Population的直方图和Q-Q图](img/B22396_03_08.jpg)'
- en: <st c="28903">Figure 3.8 – A histogram and</st> <st c="28932">Q-Q plot of the
    Population variable</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28903">图3.8 – 变量Population的直方图和</st> <st c="28932">Q-Q图</st>
- en: <st c="28967">Now, let’s</st> <st c="28979">apply a power transformation to
    the</st> `<st c="29015">MedInc</st>` <st c="29021">and</st> `<st c="29026">Population</st>`
    <st c="29036">variables.</st> <st c="29048">As both are skewed to the right, an
    exponent smaller than</st> *<st c="29106">1</st>* <st c="29107">might return a
    better spread of the</st> <st c="29144">variable values.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28967">现在，让我们对</st> <st c="28979">MedInc</st> <st c="29015">和</st> `<st
    c="29026">Population</st>` <st c="29036">变量应用幂变换。</st> <st c="29048">由于两者都向右倾斜，指数小于</st>
    *<st c="29106">1</st>* <st c="29107">可能会使变量值分布更广。</st>
- en: <st c="29160">Let’s capture the variables to transform in</st> <st c="29205">a
    list:</st>
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29160">让我们将需要变换的变量放入</st> <st c="29205">一个列表中：</st>
- en: '[PRE47]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <st c="29249">Let’s make a copy of the DataFrame and then apply a power transformation
    to the variables from</st> *<st c="29345">step 5,</st>* <st c="29352">where the
    exponent</st> <st c="29372">is</st> `<st c="29375">0.3</st>`<st c="29378">:</st>
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29249">让我们复制DataFrame，然后对从*<st c="29345">步骤5</st>，* <st c="29352">（其中指数为</st>
    `<st c="29375">0.3</st>`<st c="29378">）</st>的变量应用幂变换。</st>
- en: '[PRE48]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <st c="29442">Note</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29442">注意</st>
- en: <st c="29447">With</st> `<st c="29453">np.power()</st>`<st c="29463">, we can
    apply any power transformation by changing the value of the exponent in the second
    position of</st> <st c="29567">the function.</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29447">使用</st> `<st c="29453">np.power()</st>`<st c="29463">，我们可以通过改变函数第二位指数的值来应用任何幂变换。</st>
- en: <st c="29580">Let’s examine the change in the distribution</st> <st c="29626">of</st>
    `<st c="29629">Population</st>`<st c="29639">:</st>
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29580">让我们检查</st> `<st c="29629">Population</st>`<st c="29639">的分布变化：</st>
- en: '[PRE49]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <st c="29678">As shown in the plots returned by the previous command,</st> `<st
    c="29735">Population</st>` <st c="29745">is now more evenly distributed across
    the value range and follows the quan</st><st c="29820">tiles of the normal distribution</st>
    <st c="29854">more closely:</st>
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29678">如之前命令返回的图表所示，</st> `<st c="29735">Population</st>` <st c="29745">现在在值范围内分布更均匀，并且更接近正态分布的量级：</st>
- en: "![Figure 3.9 – A histogram and Q-Q plot of the Populatio\uFEFFn variable after\
    \ the transformation](img/B22396_03_09.jpg)"
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 变量Population变换后的直方图和Q-Q图](img/B22396_03_09.jpg)'
- en: <st c="30015">Figure 3.9 – A histogram and Q-Q plot of the Populatio</st><st
    c="30069">n variable after the transformation</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30015">图3.9 – 变量Population变换后的直方图和Q-Q图</st><st c="30069"></st>
- en: <st c="30105">Now, let’s apply a</st> <st c="30124">power transformation</st>
    <st c="30146">with scikit-learn.</st>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30105">现在，让我们使用scikit-learn应用幂变换。</st>
- en: <st c="30164">Let’s set up</st> `<st c="30178">FunctionTransformer()</st>` <st
    c="30199">with a power transformation with an exponent</st> <st c="30245">of</st>
    `<st c="30248">0.3</st>`<st c="30251">:</st>
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30164">让我们设置</st> `<st c="30178">FunctionTransformer()</st>` <st c="30199">并使用指数转换，指数为</st>
    <st c="30245">0.3</st><st c="30251">：</st>
- en: '[PRE50]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: <st c="30315">Let’s make a copy of the DataFrame and transform the variables
    from</st> *<st c="30384">step 5</st>*<st c="30390">:</st>
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30315">让我们复制 DataFrame 并将变量从</st> *<st c="30384">步骤 5</st>*<st c="30390">转换：</st>
- en: '[PRE51]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <st c="30462">That’s it – we can now examine the variable distribution.</st>
    <st c="30521">Finally, let’s perform an exponential transformation</st> <st c="30574">with
    Feature-engine.</st>
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30462">这就完成了 – 我们现在可以检查变量分布。</st> <st c="30521">最后，让我们使用 Feature-engine
    执行指数转换。</st>
- en: <st c="30594">Let’s set up</st> `<st c="30608">PowerTransformer()</st>` <st
    c="30626">with an exponent of</st> `<st c="30647">0.3</st>` <st c="30650">to transform
    the variables from</st> *<st c="30683">step 5</st>*<st c="30689">. Then, we’ll
    fit it to</st> <st c="30713">the data:</st>
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30594">让我们设置</st> `<st c="30608">PowerTransformer()</st>` <st c="30626">并使用指数</st>
    `<st c="30647">0.3</st>` <st c="30650">来转换变量，从</st> *<st c="30683">步骤 5</st>*<st
    c="30689">。然后，我们将它拟合到</st> <st c="30713">数据：</st>
- en: '[PRE52]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <st c="30794">Note</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30794">注意</st>
- en: <st c="30799">If we don’t define the variables to transform,</st> `<st c="30847">PowerTransformer()</st>`
    <st c="30865">will select and transform all of the numerical variables in</st>
    <st c="30926">the DataFrame.</st>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30799">如果我们没有定义要转换的变量，</st> `<st c="30847">PowerTransformer()</st>` <st
    c="30865">将选择并转换 DataFrame 中的所有数值变量。</st>
- en: <st c="30940">Finally, let’s transform those</st> <st c="30972">two variables:</st>
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30940">最后，让我们转换这些</st> <st c="30972">两个变量：</st>
- en: '[PRE53]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <st c="31014">The transformer</st> <st c="31031">returns a DataFrame containing
    the original variables, where the two variables specified in</st> *<st c="31122">step
    5</st>* <st c="31129">are transformed with the</st> <st c="31155">po</st><st c="31157">wer
    function.</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31014">该转换器</st> <st c="31031">返回一个包含原始变量的 DataFrame，其中在</st> *<st c="31122">步骤
    5</st>* <st c="31129">中指定的两个变量已使用转换函数进行转换。</st>
- en: <st c="31171">How it works...</st>
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="31171">它是如何工作的...</st>
- en: <st c="31187">In this recipe, we applied power transformations using NumPy,
    scikit-learn,</st> <st c="31264">and Feature-engine.</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31187">在这个菜谱中，我们使用了 NumPy、scikit-learn 和 Feature-engine 来应用幂转换。</st>
- en: <st c="31283">To apply power functions with NumPy, we applied the</st> `<st
    c="31336">power()</st>` <st c="31343">method to the slice of the dataset containing
    the variables to transform.</st> <st c="31418">To apply this transformation with
    scikit-learn, we set up the</st> `<st c="31480">FunctionTransformer()</st>`<st
    c="31501">with</st> `<st c="31507">np.power()</st>` <st c="31517">within a</st>
    `<st c="31527">lambda</st>` <st c="31533">function, using</st> `<st c="31550">0.</st><st
    c="31552">3</st>` <st c="31554">as the exponent.</st> <st c="31572">To apply power
    functions with Feature-engine, we set up the</st> `<st c="31632">PowerTransformer()</st>`
    <st c="31650">with a list of the variables to transform and an exponent</st> <st
    c="31709">of</st> `<st c="31712">0.3</st>`<st c="31715">.</st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31283">要使用 NumPy 应用幂函数，我们对包含要转换的变量的数据集切片应用了</st> `<st c="31336">power()</st>`
    <st c="31343">方法。</st> <st c="31418">要使用 scikit-learn 应用此转换，我们设置了</st> `<st c="31480">FunctionTransformer()</st>`<st
    c="31501">，并在一个</st> `<st c="31527">lambda</st>` <st c="31533">函数中使用</st> `<st
    c="31550">0.</st><st c="31552">3</st>` <st c="31554">作为指数。</st> <st c="31572">要使用
    Feature-engine 应用幂函数，我们设置了</st> `<st c="31632">PowerTransformer()</st>` <st c="31650">，其中包含要转换的变量列表和指数</st>
    <st c="31709">0.3</st><st c="31715">。</st>
- en: <st c="31716">scikit-learn and Feature-engine transformers applied the transformation
    when we called the</st> `<st c="31808">transform()</st>` <st c="31819">method.</st>
    <st c="31828">scikit-learn’s</st> `<st c="31843">FunctionTransformer()</st>` <st
    c="31864">modifies the entire dataset and returns NumPy arrays by default.</st>
    <st c="31930">To return pandas DataFrames, we need to set the transform output
    to pandas, and to apply the transformation to specific variables, we can use</st>
    `<st c="32072">ColumnTransformer()</st>`<st c="32091">. Feature-engine’s</st>
    `<st c="32110">PowerTransformer()</st>`<st c="32128">, on the other hand, can
    apply the transformation to a subset of variables out of</st> <st c="32210">the
    box, returning pandas DataFrames</st> <st c="32247">by default</st><st c="32257">.</st>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31716">当我们调用</st> `<st c="31808">transform()</st>` <st c="31819">方法时，scikit-learn和Feature-engine转换器应用了转换。</st>
    <st c="31828">scikit-learn的</st> `<st c="31843">FunctionTransformer()</st>` <st
    c="31864">修改整个数据集，并默认返回NumPy数组。</st> <st c="31930">要返回pandas DataFrames，我们需要将转换输出设置为pandas，并且要应用转换到特定变量，我们可以使用</st>
    `<st c="32072">ColumnTransformer()</st>`<st c="32091">。另一方面，Feature-engine的</st>
    `<st c="32110">PowerTransformer()</st>`<st c="32128">可以将转换应用于数据集的子集，默认返回pandas
    DataFrames</st><st c="32247">。</st>
- en: <st c="32258">Performing Box-Cox transformations</st>
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="32258">执行Box-Cox转换</st>
- en: <st c="32293">The Box-Cox transformation</st> <st c="32320">is a generalization
    of the power family of transformations and is defined</st> <st c="32395">as follows:</st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32293">Box-Cox转换</st> <st c="32320">是幂变换家族的推广，定义为以下：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>λ</mi><mo>)</mo></mrow></msup><mo>=</mo><mfrac><mrow><mo>(</mo><msup><mi>y</mi><mi>λ</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mi>λ</mi></mfrac><mi>i</mi><mi>f</mi><mi>λ</mi><mo>≠</mo><mn>0</mn></mrow></mrow></math>](img/16.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>λ</mi><mo>)</mo></mrow></msup><mo>=</mo><mfrac><mrow><mo>(</mo><msup><mi>y</mi><mi>λ</mi></msup><mo>−</mo><mn>1</mn><mo>)</mo></mrow><mi>λ</mi></mfrac><mi>i</mi><mi>f</mi><mi>λ</mi><mo>≠</mo><mn>0</mn></mrow></mrow></math>](img/16.png)'
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>λ</mi><mo>)</mo></mrow></msup><mo>=</mo><mi>log</mi><mfenced
    open="(" close=")"><mi>y</mi></mfenced><mi>i</mi><mi>f</mi><mi>λ</mi><mo>=</mo><mn>0</mn></mrow></mrow></math>](img/17.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msup><mi>y</mi><mrow><mo>(</mo><mi>λ</mi><mo>)</mo></mrow></msup><mo>=</mo><mi>log</mi><mfenced
    open="(" close=")"><mi>y</mi></mfenced><mi>i</mi><mi>f</mi><mi>λ</mi><mo>=</mo><mn>0</mn></mrow></mrow></math>](img/17.png)'
- en: <st c="32450">Here,</st> *<st c="32456">y</st>* <st c="32457">is the</st> <st
    c="32465">variable and</st> *<st c="32478">λ</st>* <st c="32479">is the transformation
    parameter.</st> <st c="32513">It includes important special cases of transformations,
    such as untransformed</st> *<st c="32591">(λ = 1)</st>*<st c="32598">, the logarithm</st>
    *<st c="32614">(λ = 0)</st>*<st c="32621">, the reciprocal</st> *<st c="32638">(λ
    = - 1)</st>*<st c="32647">, the square root (when</st> *<st c="32671">λ</st>*
    *<st c="32672">= 0.5</st>*<st c="32677">, it applies a scaled and shifted version
    of the square root function), and the</st> <st c="32757">cube root.</st>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32450">在这里，</st> *<st c="32456">y</st>* <st c="32457">是变量，</st> *<st
    c="32478">λ</st>* <st c="32479">是转换参数。</st> <st c="32513">它包括变换的重要特殊情况，例如未转换的</st>
    *<st c="32591">(λ = 1)</st>*<st c="32598">，对数</st> *<st c="32614">(λ = 0)</st>*<st
    c="32621">，倒数</st> *<st c="32638">(λ = - 1)</st>*<st c="32647">，平方根（当</st> *<st
    c="32671">λ</st>* *<st c="32672">= 0.5</st>*<st c="32677">时，它应用了一个缩放和移位的平方根函数版本），以及立方根。</st>
- en: <st c="32767">The Box-Cox transformation evaluates several values of</st> *<st
    c="32823">λ</st>* <st c="32824">using the maximum likelihood and selects the</st>
    *<st c="32870">λ</st>* <st c="32871">parameter that returns the</st> <st c="32899">best
    transformation.</st>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32767">Box-Cox转换评估了多个</st> *<st c="32823">λ</st>* <st c="32824">值，使用最大似然估计并选择返回最佳转换的</st>
    *<st c="32870">λ</st>* <st c="32871">参数。</st>
- en: <st c="32919">In this recipe, we will perform the Box-Cox transformation using
    scikit-learn</st> <st c="32998">a</st><st c="32999">nd Feature-engine.</st>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32919">在本教程中，我们将使用scikit-learn和Feature-engine执行Box-Cox转换</st> <st c="32998">a</st><st
    c="32999">nd Feature-engine.</st>
- en: <st c="33017">Note</st>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33017">注意</st>
- en: <st c="33022">The Box-Cox transformation can only be used on positive variables.</st>
    <st c="33090">If your variables have negative values, try the Yeo-Johnson transformation,
    which is described in the next recipe,</st> *<st c="33205">Performing Yeo-Johnson
    transformation</st>*<st c="33242">. Alternatively, you can shift the variable
    distributi</st><st c="33296">on by adding a constant befo</st><st c="33325">re</st>
    <st c="33329">the transformation.</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33022">Box-Cox 转换只能用于正变量。</st> <st c="33090">如果你的变量有负值，尝试使用下一道菜谱中描述的
    Yeo-Johnson 转换，</st> *<st c="33205">执行 Yeo-Johnson 转换</st>*<st c="33242">。或者，你可以在转换之前通过添加一个常数来移动变量的分布。</st>
- en: <st c="33348">How to do it...</st>
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="33348">如何做到这一点...</st>
- en: <st c="33364">Let’s begin by importing the necessary libraries and getting the</st>
    <st c="33430">dataset ready:</st>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33364">让我们首先导入必要的库并准备好数据集：</st> <st c="33430">数据集：</st>
- en: <st c="33444">Import the required Python libraries</st> <st c="33482">and classes:</st>
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="33444">导入所需的 Python 库</st> <st c="33482">和类：</st>
- en: '[PRE54]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: <st c="33726">Let’s load the California housing dataset into a</st> <st c="33776">pandas
    DataFrame:</st>
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="33726">让我们将加利福尼亚住房数据集加载到一个</st> <st c="33776">pandas DataFrame：</st>
- en: '[PRE55]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <st c="33858">Let’s</st> <st c="33864">drop the</st> `<st c="33874">Latitude</st>`
    <st c="33882">and</st> `<st c="33887">Longitude</st>` <st c="33896">variables:</st>
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="33858">让我们</st> <st c="33864">删除</st> `<st c="33874">纬度</st>` <st c="33882">和</st>
    `<st c="33887">经度</st>` <st c="33896">变量：</st>
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <st c="33970">Let’s inspect the variable distributions</st> <st c="34012">with
    histograms:</st>
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="33970">让我们用直方图检查变量分布：</st> <st c="34012">直方图：</st>
- en: '[PRE57]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <st c="34088">In the following output, we can see that the</st> `<st c="34134">MedInc</st>`
    <st c="34140">variable shows a mild right-skewed distribution, variables such
    as</st> `<st c="34208">AveRooms</st>` <st c="34216">and</st> `<st c="34221">Population</st>`
    <st c="34231">are heavily right-skewed, and the</st> `<st c="34266">HouseAge</st>`
    <st c="34274">variabl</st><st c="34282">e shows an even spread of values across</st>
    <st c="34323">its range:</st>
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34088">在以下输出中，我们可以看到</st> `<st c="34134">中位数收入</st>` <st c="34140">变量显示出轻微的右偏分布，</st>
    `<st c="34208">平均房间数</st>` <st c="34216">和</st> `<st c="34221">人口</st>` <st c="34231">变量严重右偏，而</st>
    `<st c="34266">房屋年龄</st>` <st c="34274">变量在其范围内显示出值的均匀分布：</st>
- en: '![Figure 3.10 – Histograms of the numerical variables](img/B22396_03_10.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 数值变量的直方图](img/B22396_03_10.jpg)'
- en: <st c="34643">Figure 3.10 – Histograms of the numerical variables</st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34643">图 3.10 – 数值变量的直方图</st>
- en: <st c="34694">Let’s</st> <st c="34700">capture the variable names in a list
    since we will use these in the</st> <st c="34769">follo</st><st c="34774">wing
    step:</st>
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34694">让我们</st> <st c="34700">将变量名捕获到一个列表中，因为我们将在下一步中使用这些变量：</st> <st
    c="34769">以下步骤：</st>
- en: '[PRE58]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <st c="34813">Let’s create a function that will plot Q-Q plots for all the variables
    in the data in two rows with three</st> <st c="34920">plots each:</st>
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34813">让我们创建一个函数，该函数将为数据中的所有变量绘制 Q-Q 图，每行三个图：</st> <st c="34920">每个图：</st>
- en: '[PRE59]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <st c="35231">Now, let’s display the Q-Q plots using the</st> <st c="35275">preceding
    function:</st>
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35231">现在，让我们使用前面的函数显示 Q-Q 图：</st> <st c="35275">函数：</st>
- en: '[PRE60]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <st c="35309">By looking</st> <st c="35321">at the following plots, we can corrobora</st><st
    c="35361">te that the variables are not</st> <st c="35392">normally distributed:</st>
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35309">通过查看以下图表，我们可以证实变量不是正态分布的：</st>
- en: '![Figure 3.11 – Q-Q plots of the numerical variables](img/B22396_03_11.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 数值变量的 Q-Q 图](img/B22396_03_11.jpg)'
- en: <st c="35950">Figure 3.11 – Q-Q plots of the numerical variables</st>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35950">图 3.11 – 数值变量的 Q-Q 图</st>
- en: <st c="36000">Next, let’s carry</st> <st c="36018">out the Box-Cox transformation</st>
    <st c="36050">using scikit-learn.</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36000">接下来，让我们使用 scikit-learn 执行 Box-Cox 转换：</st>
- en: <st c="36069">Let’s set up</st> `<st c="36083">PowerTransformer()</st>` <st
    c="36101">to apply the Box-Cox transformation and fit it to the data so that it
    finds the optimal</st> *<st c="36190">λ</st>* <st c="36191">parameter:</st>
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36069">让我们设置</st> `<st c="36083">PowerTransformer()</st>` <st c="36101">以应用
    Box-Cox 转换并将其拟合到数据中，以便找到最优的</st> *<st c="36190">λ</st> <st c="36191">参数：</st>
- en: '[PRE61]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: <st c="36323">Note</st>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36323">注意</st>
- en: <st c="36328">To avoid data leakage, the</st> *<st c="36356">λ</st>* <st c="36357">parameter
    should be learned from the train set and then used to transform the train and
    test sets.</st> <st c="36457">Thus, remember to split your data into train and
    tes</st><st c="36509">t sets before</st> <st c="36524">fitting</st> `<st c="36532">PowerTransformer()</st>`<st
    c="36550">.</st>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36328">为了避免数据泄露，</st> *<st c="36356">λ</st>* <st c="36357">参数应该从训练集中学习，然后用于转换训练集和测试集。</st>
    <st c="36457">因此，在拟合 `<st c="36532">PowerTransformer()</st>`<st c="36550">之前，请记住将您的数据分为训练集和测试集。</st>
- en: <st c="36551">Now, let’s transform</st> <st c="36573">the dataset:</st>
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36551">现在，让我们转换</st> <st c="36573">数据集：</st>
- en: '[PRE62]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <st c="36617">Note</st>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36617">注意</st>
- en: <st c="36622">scikit-learn’s</st> `<st c="36638">PowerTransformer()</st>` <st
    c="36656">stores the learned lambdas in its</st> `<st c="36691">lambdas_</st>`
    <st c="36699">attribute, which you can display by</st> <st c="36736">executing</st>
    `<st c="36746">transformer.lambdas_</st>`<st c="36766">.</st>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36622">scikit-learn 的</st> `<st c="36638">PowerTransformer()</st>` <st
    c="36656">将学习到的 lambda 值存储在其</st> `<st c="36691">lambdas_</st>` <st c="36699">属性中，您可以通过执行</st>
    `<st c="36736">transformer.lambdas_</st>`<st c="36766">.</st>来显示它。
- en: <st c="36767">Let’s inspect the distributions of the transformed data</st> <st
    c="36824">with histograms:</st>
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36767">让我们使用直方图检查转换数据的分布：</st>
- en: '[PRE63]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: <st c="36903">In the following output, we can see that the variables’</st> <st
    c="36959">values are more evenly spread across</st> <st c="36997">their ranges:</st>
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36903">在以下输出中，我们可以看到变量的</st> <st c="36959">值在其范围内分布得更均匀：</st>
- en: '![Figure 3.12 – Histograms of the variables after the transformation](img/B22396_03_12.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 变量变换后的直方图](img/B22396_03_12.jpg)'
- en: <st c="37302">Figure 3.12 – Histograms of the variables after the transformation</st>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37302">图 3.12 – 变量变换后的直方图</st>
- en: <st c="37368">Now, let’s return</st> <st c="37387">Q-Q plots of the</st> <st
    c="37404">transformed variables:</st>
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37368">现在，让我们返回转换变量的</st> <st c="37387">Q-Q 图：</st>
- en: '[PRE64]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: <st c="37444">In the following output, we can see that, after the transformation,
    the variables follo</st><st c="37532">w the theoretical normal distribution</st>
    <st c="37571">more closely:</st>
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37444">在以下输出中，我们可以看到，经过转换后，变量更接近理论正态分布：</st><st c="37532">:</st>
- en: "![Figure 3.13 – Q-Q plots o\uFEFFf the variables after the transformation](img/B22396_03_13.jpg)"
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 变量变换后的 Q-Q 图](img/B22396_03_13.jpg)'
- en: <st c="38093">Figure 3.13 – Q-Q plots o</st><st c="38118">f the variables after
    the transformation</st>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38093">图 3.13 – 变量变换后的 Q-Q 图</st><st c="38118">:</st>
- en: <st c="38159">Now, let’s</st> <st c="38170">implement the Box-Cox transformation</st>
    <st c="38208">with Feature-engine.</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38159">现在，让我们使用 Feature-engine 实现 Box-Cox 转换：</st>
- en: <st c="38228">Let’s set up</st> `<st c="38242">BoxCoxTransformer()</st>` <st
    c="38261">to transform all the variables in the dataset and then fit it to</st>
    <st c="38327">the data:</st>
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38228">让我们设置</st> `<st c="38242">BoxCoxTransformer()</st>` <st c="38261">以转换数据集中的所有变量，并将其拟合到</st>
    <st c="38327">数据：</st>
- en: '[PRE65]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: <st c="38373">Now, let’s go ahead and transform</st> <st c="38408">the variables:</st>
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38373">现在，让我们继续转换</st> <st c="38408">变量：</st>
- en: '[PRE66]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: <st c="38446">The transformation returns a pandas DataFrame containing</st>
    <st c="38504">the</st> <st c="38508">modified variables.</st>
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38446">转换返回一个包含</st> <st c="38504">修改后的变量</st> <st c="38508">的 pandas
    DataFrame。</st>
- en: <st c="38527">Note</st>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38527">注意</st>
- en: '`<st c="38532">PowerTransformer()</st>` <st c="38551">from scikit-learn will
    transform the entire dataset.</st> <st c="38605">On the other hand,</st> `<st
    c="38624">BoxCoxTransformer()</st>` <st c="38643">from Feature-engine can modify
    a subset of the variables, if we pass their names in a list to the</st> `<st c="38742">variables</st>`
    <st c="38751">parameter when setting up the transformer.</st> <st c="38795">If
    the</st> `<st c="38802">variables</st>` <st c="38811">parameter is set to</st>
    `<st c="38832">None</st>`<st c="38836">, the transformer will transform all numerical
    variables seen</st> <st c="38898">during</st> `<st c="38905">fit()</st>`<st c="38910">.</st>'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="38532">scikit-learn 的 PowerTransformer()</st>` <st c="38551">将转换整个数据集。</st>
    <st c="38605">另一方面，</st> `<st c="38624">Feature-engine 的 BoxCoxTransformer()</st>`
    <st c="38643">可以修改数据集的子集，如果我们将其名称列表传递给设置转换器时的</st> `<st c="38742">variables</st>`
    <st c="38751">参数。</st> <st c="38795">如果将</st> `<st c="38802">variables</st>` <st
    c="38811">参数设置为</st> `<st c="38832">None</st>`<st c="38836">，转换器将在 `<st c="38898">fit()</st>`<st
    c="38905">过程中转换所有遇到的数值变量。</st>'
- en: <st c="38911">The</st> <st c="38916">optimal lambdas for the Box-Cox transformation
    are stored in the</st> `<st c="38981">lambda_dict_</st>` <st c="38993">attribute.</st>
    <st c="39005">Let’s</st> <st c="39011">inspect them:</st>
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38911">Box-Cox变换的最优lambda值存储在</st> `<st c="38981">lambda_dict_</st>`
    <st c="38993">属性中。</st> <st c="39005">让我们</st> <st c="39011">检查它们：</st>
- en: '[PRE67]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: <st c="39041">The output of the previous command is</st> <st c="39080">the following:</st>
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39041">上一条命令的输出如下：</st> <st c="39080">以下：</st>
- en: '[PRE68]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <st c="39294">Now you know how to implement the Box-Co</st><st c="39335">x transformation
    with two different</st> <st c="39372">Python libraries.</st>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39294">现在您知道了如何使用两个不同的Python库实现Box-Cox变换。</st>
- en: <st c="39389">How it works...</st>
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="39389">它是如何工作的...</st>
- en: <st c="39405">scikit-learn’s</st> `<st c="39421">PowerTransformer()</st>` <st
    c="39439">can apply both Box-Cox and Yeo-Johnson transformations, so we specified
    the transformation when setting up the transformer by passing the b</st>`<st c="39579">ox-cox</st>`
    <st c="39586">string.</st> <st c="39595">Next, we fit the transformer to the data
    so that the transformer learned the optimal lambdas for each variable.</st> <st
    c="39707">The learned lambdas were stored in the</st> `<st c="39746">lambdas_</st>`
    <st c="39754">attribute.</st> <st c="39766">Finally, we used the</st> `<st c="39787">transform()</st>`
    <st c="39798">method to transform</st> <st c="39819">the variables.</st>
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39405">scikit-learn的</st> `<st c="39421">PowerTransformer()</st>` <st
    c="39439">可以应用Box-Cox和Yeo-Johnson变换，因此我们在设置变换器时通过传递b</st>`<st c="39579">ox-cox</st>`
    <st c="39586">字符串来指定了变换。</st> <st c="39595">接下来，我们将变换器拟合到数据中，以便变换器学习每个变量的最优lambda值。</st>
    <st c="39707">学习到的lambda值存储在</st> `<st c="39746">lambdas_</st>` <st c="39754">属性中。</st>
    <st c="39766">最后，我们使用了</st> `<st c="39787">transform()</st>` <st c="39798">方法来变换</st>
    <st c="39819">变量。</st>
- en: <st c="39833">Note</st>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39833">注意</st>
- en: <st c="39838">Remember that to return DataFrames instead of arrays, you need
    to specify the transform output through the</st> `<st c="39946">set_output()</st>`
    <st c="39958">method.</st> <st c="39967">You can apply the transformation to a
    subset of values by using</st> <st c="40031">the</st> `<st c="40035">ColumnTransformer()</st>`<st
    c="40054">.</st>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39838">记住，要返回DataFrames而不是数组，您需要通过</st> `<st c="39946">set_output()</st>`
    <st c="39958">方法指定变换输出。</st> <st c="39967">您可以通过使用</st> `<st c="40031">the</st>`
    <st c="40035">ColumnTransformer()</st>`<st c="40054">将变换应用于值的一个子集。</st>
- en: <st c="40055">Finally, we applied the Box-Cox transformation using Feature-engine.</st>
    <st c="40125">We initialized</st> `<st c="40140">BoxCoxTransformer()</st>`<st
    c="40159">, leaving</st> <st c="40168">the parameter</st> `<st c="40183">variables</st>`
    <st c="40192">set the</st> `<st c="40201">None</st>`<st c="40205">. Due to this,
    the transformer automatically found the numerical variables in the data during</st>
    `<st c="40299">fit()</st>`<st c="40304">. We fit the transformer to the data so
    that it learned the optimal lambdas per variable, which were stored in</st> `<st
    c="40415">lambda_dict_</st>`<st c="40427">, and transformed the variables using
    the</st> `<st c="40469">transform()</st>` <st c="40480">method.</st> <st c="40489">Feature-engine’s</st>
    `<st c="40506">BoxCoxTransformer()</st>` <st c="40525">can take the entire DataFrame
    a</st><st c="40557">s input and it yet mo</st><st c="40579">dify only the</st>
    <st c="40594">selected variables.</st>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40055">最后，我们使用Feature-engine应用了Box-Cox变换。</st> <st c="40125">我们初始化了</st>
    `<st c="40140">BoxCoxTransformer()</st>`<st c="40159">，将参数</st> `<st c="40168">variables</st>`
    <st c="40192">设置为</st> `<st c="40201">None</st>`<st c="40205">。因此，变换器在</st> `<st
    c="40299">fit()</st>`<st c="40304">过程中自动找到了数据中的数值变量。</st> 我们将变换器拟合到数据中，以便它学习每个变量的最优lambda值，这些值存储在</st>
    `<st c="40415">lambda_dict_</st>`<st c="40427">中，并使用</st> `<st c="40469">transform()</st>`
    <st c="40480">方法变换变量。</st> <st c="40489">Feature-engine的</st> `<st c="40506">BoxCoxTransformer()</st>`
    <st c="40525">可以接受整个DataFrame作为输入，并且它只修改了</st> <st c="40557">选定的变量。</st>
- en: <st c="40613">There’s more…</st>
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="40613">还有更多...</st>
- en: <st c="40627">We can apply the Box-Cox transformation with the SciPy library.</st>
    <st c="40692">For a code implementation, visit this book’s GitHub</st> <st c="40744">repository:</st>
    [<st c="40756">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variabl</st><st
    c="40863">e-transformation/Recipe-5-Box-Cox-transformation.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-5-Box-Cox-transformation.ipynb)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40627">我们可以使用 SciPy 库应用 Box-Cox 转换。</st> <st c="40692">有关代码实现，请访问本书的
    GitHub</st> <st c="40744">存储库：</st> [<st c="40756">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variabl</st><st
    c="40863">e-transformation/Recipe-5-Box-Cox-transformation.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch03-variable-transformation/Recipe-5-Box-Cox-transformation.ipynb)
- en: <st c="40918">Performing Yeo-Johnson transformations</st>
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="40918">执行 Yeo-Johnson 转换</st>
- en: <st c="40957">The</st> <st c="40962">Yeo-Johnson transformation is an extension
    of the Box-Cox transformation that is no longer constrained to positive values.</st>
    <st c="41085">In other words, the Yeo-Johnson transformation can be used on variables
    with zero and negative values, as well as positive values.</st> <st c="41216">These
    transformations are defined</st> <st c="41250">as follows:</st>
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40957">The</st> <st c="40962">Yeo-Johnson 转换是 Box-Cox 转换的扩展，不再局限于正值。</st>
    <st c="41085">换句话说，Yeo-Johnson 转换可以用于具有零值和负值的变量，以及正值。</st> <st c="41216">这些转换的定义如下：</st>
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>λ</mml:mi></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>λ</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/18.png)<st
    c="41261"><st c="41274">; if λ ≠ 0 and X >= 0</st></st>'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>λ</mml:mi></mml:mrow></mml:msup><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>λ</mml:mi></mml:mrow></mml:mfrac></mml:math>](img/18.png)<st
    c="41261"><st c="41274">; 如果 λ ≠ 0 且 X >= 0</st></st>'
- en: <st c="41295">ln(X + 1 ); if λ = 0 and X >= 0</st>
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41250">ln(X + 1); 如果 λ = 0 且 X >= 0</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>−</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><msup><mrow><mo>(</mo><mo>−</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></mfrac></mstyle></mrow></mrow></math>](img/19.png)<st
    c="41327"><st c="41329">; if λ ≠ 2 and X < 0</st></st>'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>−</mo><mstyle
    scriptlevel="+1"><mfrac><mrow><msup><mrow><mo>(</mo><mo>−</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></mfrac></mstyle></mrow></mrow></math>](img/19.png)<st
    c="41327"><st c="41329">; 如果 λ ≠ 2 且 X < 0</st></st>'
- en: <st c="41349">-ln(-X + 1); if λ = 2 and X < 0</st>
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41349">-ln(-X + 1); 如果 λ = 2 且 X < 0</st>
- en: <st c="41381">When the</st> <st c="41391">variable has only positive values,
    then the Yeo-Johnson transformation is like the Box-Cox transformation of the
    variable plus one.</st> <st c="41523">If the variable has only negative values,
    then the Yeo-Johnson transformation is like the Box-Cox transformation of the
    negative of the variable plus one, at the power of</st> *<st c="41694">2- λ</st>*<st
    c="41698">. If the variable has a mix of positive and negative values, the Yeo-Johnson
    transformation applies different powers to the positive and</st> <st c="41835">negative
    values.</st>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41381">当</st> <st c="41391">变量只有正值时，Yeo-Johnson 转换类似于变量加一的 Box-Cox 转换。</st>
    <st c="41523">如果变量只有负值，那么 Yeo-Johnson 转换类似于变量负值加一的 Box-Cox 转换，其幂为 *<st c="41694">2-
    λ</st>*<st c="41698">。如果变量既有正值又有负值，Yeo-Johnson 转换将对正负值应用不同的幂。</st>
- en: <st c="41851">In this recipe, we will perform the Yeo-Johns</st><st c="41897">on
    transfo</st><st c="41908">rmation using scik</st><st c="41927">it-learn</st> <st
    c="41937">and Feature-engine.</st>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41851">在这个菜谱中，我们将使用 scikit-learn 和 Feature-engine 执行 Yeo-Johnson 转换。</st>
- en: <st c="41956">How to do it...</st>
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="41956">如何操作...</st>
- en: <st c="41972">Let’s begin</st> <st c="41984">by importing the necessary libraries
    and getting the</st> <st c="42038">dataset ready:</st>
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41972">让我们首先</st> <st c="41984">导入必要的库并准备</st> <st c="42038">数据集：</st>
- en: <st c="42052">Import the required Python libraries</st> <st c="42090">and classes:</st>
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="42052">导入所需的Python库</st>` `<st c="42090">和类：</st>`'
- en: '[PRE69]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: <st c="42338">Let’s load the California housing dataset into a pandas DataFrame
    and then drop the</st> `<st c="42423">Latitude</st>` <st c="42431">and</st> `<st
    c="42436">Longitude</st>` <st c="42445">variables:</st>
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="42338">让我们将加利福尼亚住房数据集加载到pandas DataFrame中，然后删除</st>` `<st c="42423">纬度</st>`
    `<st c="42431">和</st>` `<st c="42436">经度</st>` `<st c="42445">变量：</st>`'
- en: '[PRE70]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: <st c="42584">Note</st>
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="42584">注意</st>`'
- en: <st c="42589">We can evaluate the variable distribution with histograms and
    Q-Q plots, as we did in</st> *<st c="42676">steps 4</st>* <st c="42683">to</st>
    *<st c="42687">7</st>* <st c="42688">of the</st> *<st c="42696">Performing Box-Cox</st>*
    *<st c="42715">transformations</st>* <st c="42730">recipe.</st>
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="42589">我们可以使用直方图和Q-Q图来评估变量分布，就像我们在</st>` *<st c="42676">步骤4</st>` `<st
    c="42683">到</st>` *<st c="42687">步骤7</st>` `<st c="42688">的</st>` *<st c="42696">执行Box-Cox变换</st>`
    `<st c="42715">食谱</st>` `<st c="42730">中做的那样。</st>`'
- en: <st c="42738">Now, let’s</st> <st c="42750">apply the Yeo-Johnson transformation</st>
    <st c="42787">with scikit-learn.</st>
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="42738">现在，让我们</st>` `<st c="42750">使用scikit-learn应用Yeo-Johnson变换：</st>`'
- en: <st c="42805">Let’s set up</st> `<st c="42819">PowerTransformer()</st>` <st
    c="42837">with the</st> `<st c="42847">yeo-johnson</st>` <st c="42858">transformation:</st>
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="42805">让我们使用</st>` `<st c="42819">PowerTransformer()</st>` `<st c="42837">和</st>`
    `<st c="42847">yeo-johnson</st>` `<st c="42858">变换</st>` `<st c="42847">设置：</st>`'
- en: '[PRE71]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: <st c="42981">Let’s</st> <st c="42988">fit the transformer to</st> <st c="43011">the
    data:</st>
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="42981">让我们</st>` `<st c="42988">将转换器拟合到</st>` `<st c="43011">数据：</st>`'
- en: '[PRE72]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <st c="43039">Note</st>
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="43039">注意</st>`'
- en: <st c="43044">The</st> *<st c="43049">λ</st>* <st c="43050">parameter should
    be learned from the train set and then used to transform the train and test sets.</st>
    <st c="43150">Thus, remember to separate your data into train and test sets before</st>
    <st c="43219">fitting</st> `<st c="43227">PowerTransformer()</st>`<st c="43245">.</st>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="43044">*<st c="43049">λ</st>* 参数应该从训练集中学习，然后用于转换训练集和测试集。</st>` `<st
    c="43150">因此，在拟合</st>` `<st c="43227">PowerTransformer()</st>` `<st c="43245">之前，请记住将您的数据分为训练集和测试集。</st>`'
- en: <st c="43246">Now, let’s transform</st> <st c="43268">the dataset:</st>
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="43246">现在，让我们转换</st>` `<st c="43268">数据集：</st>`'
- en: '[PRE73]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: <st c="43312">Note</st>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="43312">注意</st>`'
- en: '`<st c="43317">PowerTransformer()</st>` <st c="43336">stores the learned parameters
    in its</st> `<st c="43374">lambda_</st>` <st c="43381">attribute, which you can
    return by</st> <st c="43417">executing</st> `<st c="43427">transformer.lambdas_</st>`<st
    c="43447">.</st>'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="43317">PowerTransformer()</st>` `<st c="43336">将学习到的参数存储在其</st>` `<st
    c="43374">lambda_</st>` `<st c="43381">属性中，您可以通过执行</st>` `<st c="43417">transformer.lambdas_</st>`
    `<st c="43447">来返回它。</st>`'
- en: <st c="43448">Let’s inspect the distributions of the transformed data</st> <st
    c="43505">with histograms:</st>
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="43448">让我们使用直方图检查转换数据的分布：</st>` `<st c="43505">：</st>`'
- en: '[PRE74]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: <st c="43584">In the following output, we can see that the variables’ values
    are more evenly spread across</st> <st c="43678">their ranges:</st>
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="43584">在以下输出中，我们可以看到变量的值在其范围内分布得更均匀：</st>` `<st c="43678">：</st>`'
- en: '![Figure 3.14 – Histograms of the variables after the yeo-Johnson transformation](img/B22396_03_14.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – yeo-Johnson变换后变量的直方图](img/B22396_03_14.jpg)'
- en: <st c="43883">Figure 3.14 – Histograms of the variables after the yeo-Johnson
    transformation</st>
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="43883">图3.14 – yeo-Johnson变换后变量的直方图</st>`'
- en: <st c="43961">Finally, let’s implement</st> <st c="43986">the Yeo-Johnson transformation</st>
    <st c="44018">with Feature-engine.</st>
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="43961">最后，让我们使用Feature-engine实现Yeo-Johnson变换：</st>` `<st c="43986">：</st>`'
- en: <st c="44038">Let’</st><st c="44043">s set up</st> `<st c="44053">YeoJohnsonTransformer()</st>`
    <st c="44076">to transform all numerical variables and then fit it to</st> <st
    c="44133">the data:</st>
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="44038">让我们设置</st>` `<st c="44043">YeoJohnsonTransformer()</st>` `<st
    c="44076">来转换所有数值变量，然后将其拟合到</st>` `<st c="44133">数据：</st>`'
- en: '[PRE75]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: <st c="44183">Note</st>
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="44183">注意</st>`'
- en: <st c="44188">If the</st> `<st c="44196">variables</st>` <st c="44205">argument
    is left set to</st> `<st c="44230">None</st>`<st c="44234">, the transformer selects
    and transforms all the numerical variables in the dataset.</st> <st c="44319">Alternatively,
    we can pass the names of the variables to modify in</st> <st c="44386">a list.</st>
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`<st c="44188">变量</st>` `<st c="44196">参数</st>` `<st c="44205">设置为</st>`
    `<st c="44230">None</st>` `<st c="44234">，转换器将选择并转换数据集中所有数值变量。</st>` `<st c="44319">或者，我们可以传递一个列表来修改变量的名称。</st>
- en: <st c="44393">Compared to</st> `<st c="44406">PowerTransformer()</st>` <st c="44424">from
    scikit-learn, Feature-engine’s transformer can take the entire DataFrame as an
    argument of the</st> `<st c="44525">fit()</st>` <st c="44530">and</st> `<st c="44535">transform()</st>`
    <st c="44546">methods, and yet it will only modify the</st> <st c="44588">selected
    variables.</st>
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44393">与 scikit-learn 中的</st> `<st c="44406">PowerTransformer()</st>`
    <st c="44424">相比，Feature-engine 的转换器可以将整个 DataFrame 作为</st> `<st c="44525">fit()</st>`
    <st c="44530">和</st> `<st c="44535">transform()</st>` <st c="44546">方法的参数，并且它只会修改</st>
    <st c="44588">选定的变量。</st>
- en: <st c="44607">Let’s transform</st> <st c="44623">the variables:</st>
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="44607">让我们转换</st> <st c="44623">变量：</st>
- en: '[PRE76]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`<st c="44662">YeoJohnsonTransformer()</st>` <st c="44686">stores the best
    parameters per variable in its</st> `<st c="44734">lambda_dict_</st>` <st c="44746">attribute,
    which we can display</st> <st c="44779">as follows:</st>'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="44662">YeoJohnsonTransformer()</st>` <st c="44686">将每个变量的最佳参数存储在其</st>
    `<st c="44734">lambda_dict_</st>` <st c="44746">属性中，我们可以如下显示：</st>'
- en: '[PRE77]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: <st c="44807">The previous command returns the</st> <st c="44841">following
    dictionary:</st>
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44807">前一个命令返回以下字典：</st> <st c="44841">以下字典：</st>
- en: '[PRE78]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: <st c="45062">Now you know</st> <st c="45075">how to implement the Yeo-John</st><st
    c="45105">son transformation with two different open</st> <st c="45149">source
    libraries.</st>
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45062">现在你知道了</st> <st c="45075">如何使用两个不同的开源库实现 Yeo-John</st><st c="45105">son
    变换。</st>
- en: <st c="45166">How it works...</st>
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="45166">它是如何工作的...</st>
- en: <st c="45182">In this recipe, we applied the Yeo-Johnson transformation using</st>
    `<st c="45247">scikit-learn</st>` <st c="45259">and</st> `<st c="45264">Feature-engine</st>`<st
    c="45278">.</st>
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45182">在这个菜谱中，我们使用了</st> `<st c="45247">scikit-learn</st>` <st c="45259">和</st>
    `<st c="45264">Feature-engine</st>`<st c="45278">实现了 Yeo-Johnson 变换。</st>
- en: '`<st c="45279">scikit-learn</st>`<st c="45292">’s</st> `<st c="45296">PowerTransformer()</st>`
    <st c="45314">can apply both Box-Cox and Yeo-Johnson transformations, so we specified
    the transformation with the</st> `<st c="45415">yeo-johnson</st>` <st c="45426">string.</st>
    <st c="45435">The</st> `<st c="45439">standardize</st>` <st c="45450">argument
    allowed us to determine whether we wanted to standardize (scale) the transformed
    values.</st> <st c="45549">Next, we fit the transformer to the DataFrame so that
    it learned the optimal lambdas for each variable.</st> `<st c="45653">PowerTransformer()</st>`
    <st c="45671">stored the learned lambdas in its</st> `<st c="45706">lambdas_</st>`
    <st c="45714">attribute.</st> <st c="45726">Finally, we used the</st> `<st c="45747">transform()</st>`
    <st c="45758">method to return the transformed variables.</st> <st c="45803">We
    set the transform output to</st> `<st c="45834">pandas</st>` <st c="45840">to
    return DataFrames after</st> <st c="45868">the transformation.</st>'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="45279">scikit-learn</st>`<st c="45292">的</st> `<st c="45296">PowerTransformer()</st>`
    <st c="45314">可以应用 Box-Cox 和 Yeo-Johnson 变换，因此我们使用</st> `<st c="45415">yeo-johnson</st>`
    <st c="45426">字符串指定了变换。</st> <st c="45435">标准化的参数允许我们确定是否想要标准化（缩放）变换后的值。</st>
    <st c="45549">接下来，我们将转换器拟合到 DataFrame 中，以便它学习每个变量的最佳 lambda 值。</st> `<st c="45653">PowerTransformer()</st>`
    <st c="45671">将学习到的 lambda 值存储在其</st> `<st c="45706">lambdas_</st>` <st c="45714">属性中。</st>
    <st c="45726">最后，我们使用了</st> `<st c="45747">transform()</st>` <st c="45758">方法来返回变换后的变量。</st>
    <st c="45803">我们将变换输出设置为</st> `<st c="45834">pandas</st>` <st c="45840">在变换后返回
    DataFrames。</st>'
- en: <st c="45887">After that, we</st> <st c="45903">applied the Yeo-Johnson transformation
    using Feature-engine.</st> <st c="45964">We set up</st> `<st c="45974">YeoJohnsonTransformer()</st>`
    <st c="45997">so that it transforms all numerical variables seen during</st> `<st
    c="46056">fit()</st>`<st c="46061">. We fitted the transformer to the data so
    that it learned the optimal lambdas per variable, which were stored in</st> `<st
    c="46175">lambda_dict_</st>`<st c="46187">, and finally transformed the variables
    using the</st> `<st c="46237">transform()</st>` <st c="46248">method.</st> <st
    c="46257">Feature-engine’s</st> `<st c="46274">YeoJohnnsonTransformer()</st>`
    <st c="46298">can take the entire DataFrame</st> <st c="46328">as input, yet it
    wil</st><st c="46349">l only transform the</st> <st c="46371">selected variables.</st>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用Feature-engine应用了Yeo-Johnson转换。<st c="45974">我们设置了</st> `<st c="45974">YeoJohnsonTransformer()</st>`
    <st c="45997">，以便它在`fit()`<st c="46056">过程中转换所有数值变量。</st> 我们将转换器拟合到数据中，使其学习每个变量的最佳lambda值，这些值存储在`<st
    c="46175">lambda_dict_</st>`<st c="46187">中，并最终使用`<st c="46237">transform()</st>`
    <st c="46248">方法转换变量。</st> `<st c="46257">Feature-engine的</st>` `<st c="46274">YeoJohnnsonTransformer()</st>`
    <st c="46298">可以接受整个DataFrame作为输入，但它只会转换选定的变量。</st>
- en: <st c="46390">There’s more…</st>
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="46390">还有更多...</st>
- en: <st c="46404">We can apply the Yeo-Johnson transformation with the SciPy library.</st>
    <st c="46473">For a code implementation, visit this book’s GitHub</st> <st c="46525">repository:</st>
    [<st c="46537">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Second-Edition/blob/main/ch03-variable-transformation/Recipe-6-Yeo-Johnson-transformation.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Second-Edition/blob/main/ch03-variable-transformation/Recipe-6-Yeo-Johnson-transformation.ipynb)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46404">我们还可以使用SciPy库应用Yeo-Johnson转换。</st> <st c="46473">有关代码实现，请访问本书的GitHub存储库：</st>
    [<st c="46537">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Second-Edition/blob/main/ch03-variable-transformation/Recipe-6-Yeo-Johnson-transformation.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Second-Edition/blob/main/ch03-variable-transformation/Recipe-6-Yeo-Johnson-transformation.ipynb)
