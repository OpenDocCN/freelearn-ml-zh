- en: Chapter 5. Time Out – Obtaining Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 休息时间 – 获取数据
- en: In this chapter, we are going to break from looking at various machine learning
    models. Instead, we are going to revisit some of the issues that I glossed over
    in [Chapter 2](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 2. AdventureWorks Regression"), *AdventureWorks Regression*, [Chapter
    3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055 "Chapter 3. More
    AdventureWorks Regression"), *More AdventureWorks Regression*, and [Chapter 4](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "Chapter 4. Traffic Stops – Barking Up the Wrong Tree?"), *Traffic Stops – Barking
    Up the Wrong Tree?*. We are going to look at different ways in which we can obtain
    data using Visual Studio and type providers. We will then look at how type providers
    help us solve problems of missing data, how we can use parallelism to speed up
    our data extraction, and how we can use type providers on secured web services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从查看各种机器学习模型转向。相反，我们将回顾我在[第2章](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "第2章. AdventureWorks 回归")、*AdventureWorks 回归*、[第3章](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "第3章. 更多 AdventureWorks 回归")、*更多 AdventureWorks 回归*和[第4章](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "第4章. 交通拦截 – 是否走错了路？")、*交通拦截 – 是否走错了路？*中略过的一些问题。我们将探讨使用 Visual Studio 和类型提供者获取数据的不同方法。然后，我们将探讨类型提供者如何帮助我们解决缺失数据的问题，我们将如何使用并行性来加速我们的数据提取，以及我们如何在受保护的Web服务上使用类型提供者。
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'One of the underappreciated skills that a data scientist must possess is the
    ability to gather and assimilate heterogeneous data. Heterogeneous data is data
    from different sources, structures, and formats. Heterogeneous stands in contrast
    to homogenous data which assumes that all of the data that is imported is the
    same as all of the other data that may already exist. When the data scientist
    gets heterogeneous data, one of the first things they will do is transform the
    data to a point that it can be combined with the other data. The most common shape
    of that transformation is the **data frame**—sometimes called the *rectangle*
    because the columns are attributes and the rows are the data. For example, here
    is a data frame that we have seen earlier:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家必须具备的一项被低估的技能是收集和整合异构数据的能力。异构数据来自不同的来源、结构和格式。异构与同质数据相对立，同质数据假设所有导入的数据都与可能已经存在的其他数据相同。当数据科学家获得异构数据时，他们首先会做的事情之一是将数据转换到可以与其他数据结合的程度。这种转换的最常见形式是
    **数据帧**——有时被称为 *矩形*，因为列是属性，行是数据。例如，这里是一个我们之前见过的数据帧：
- en: '![Overview](img/00070.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![概述](img/00070.jpeg)'
- en: Ideally, each frame has a unique key that allows it to be combined with other
    data frames. In this case, **ProductID** is the primary key. If you are thinking
    that this is a lot like RDBMS theory—you are right.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每个数据帧都有一个独特的键，允许它与其他数据帧结合。在这种情况下，**ProductID** 是主键。如果你认为这很像RDBMS理论——你是对的。
- en: One of the bigger differences between a research analysts and a line of business
    developer is how they approach using data in their project. For the software engineer,
    data elements must be meticulously defined, created, and tracked. For the research
    analyst, all of that mental effort is noise that is tangential to solving the
    problem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 研究分析师和业务开发者之间的一大区别在于他们如何在其项目中使用数据。对于软件工程师来说，数据元素必须被细致地定义、创建和跟踪。而对于研究分析师来说，所有这些精神努力都是与解决问题无关的噪音。
- en: This is where the power of type providers comes in. Instead of spending any
    effort on extracting data, we spend our time transforming, shaping, and analyzing
    it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是类型提供者力量的体现。我们不是花费精力去提取数据，而是花费时间对其进行转换、塑造和分析。
- en: SQL Server providers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL Server 提供者
- en: Even though there is lots of buzz surrounding `no-sql` databases like MongoDb
    and unstructured data stores like *data lakes* (or *data swamps*, depending on
    your point of view), a significant percentage of data that our industry works
    with is still stored in relational databases. As we have seen in prior chapters,
    the data scientist must be able to effectively communicate with relational databases
    using SQL. However, we also saw that F# offers the ability to use something called
    a type provider to access SQL Server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管围绕像MongoDb这样的`no-sql`数据库和无结构数据存储如*数据湖*（或根据你的观点，*数据沼泽*）有很多炒作，但我们行业处理的大量数据仍然存储在关系数据库中。正如我们在前面的章节中看到的，数据科学家必须能够使用SQL有效地与关系数据库进行通信。然而，我们也看到了F#提供使用称为类型提供者来访问SQL
    Server的能力。
- en: Non-type provider
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非类型提供者
- en: Let's go back to the SQL that was used in [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    to bring down the Average Orders, Average Reviews, and List Price for individual
    customers and see how to do it differently. Go into Visual Studio and create an
    F# Windows Library called `TypeProviders`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[第3章](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055 "第3章。更多AdventureWorks回归")中使用的SQL，以降低单个客户的平均订单、平均评论和列表价格，并看看如何以不同的方式完成。进入Visual
    Studio并创建一个名为`TypeProviders`的F# Windows库。
- en: Notice that I am using .NET Framework 4.5.2\. The framework's minor version
    does not matter, as long as it is 4.x. It is important to note that you cannot
    use type providers with **Portable Class Libraries** (**PCLs**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我正在使用.NET Framework 4.5.2。框架的次要版本并不重要，只要它是4.x即可。重要的是要注意，你不能在**可移植类库**（**PCLs**）中使用类型提供者。
- en: '![Non-type provider](img/00071.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![非类型提供者](img/00071.jpeg)'
- en: 'Once Visual Studio generates the files for you, go ahead and delete `Library1.fs`
    and remove all the contents of `Script1.fsx`. Rename `Scipt1.fsx` to `SqlServerProviders.fsx`.
    Next, add a reference to `System.Transactions`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Visual Studio为你生成文件，请删除`Library1.fs`并移除`Script1.fsx`中的所有内容。将`Scipt1.fsx`重命名为`SqlServerProviders.fsx`。接下来，添加对`System.Transactions`的引用：
- en: '![Non-type provider](img/00072.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![非类型提供者](img/00072.jpeg)'
- en: 'Go into `SqlServerProviders.fsx` and add this code (you can copy it from [Chapter
    3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055 "Chapter 3. More
    AdventureWorks Regression"), *More AdventureWorks Regression*, it is identical):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`SqlServerProviders.fsx`并添加以下代码（你可以从[第3章](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "第3章。更多AdventureWorks回归")复制，*更多AdventureWorks回归*，它们是相同的）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are 52 lines of total code here, 26 of which are SQL inside the string
    called `query`. This seems like a lot of work for something that appears to be
    pretty basic. Also, if we want to change our output rectangle, we would have to
    rewrite this SQL and hope we got it right. Also, we now need to know some fairly
    advanced SQL even though we don't care one whit that the data is stored in a SQL
    Server database. How can type providers help us here?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里总共有52行代码，其中26行是字符串`query`中的SQL。这似乎是做一件看似基本的事情所做的大量工作。此外，如果我们想更改我们的输出矩形，我们就必须重写这个SQL并希望我们做得正确。此外，尽管我们根本不在乎数据是否存储在SQL
    Server数据库中，我们现在需要了解一些相当高级的SQL。类型提供者如何帮助我们在这里？
- en: SqlProvider
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SqlProvider
- en: 'Go back into Visual Studio, open up the nugget package manager, and enter this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Visual Studio，打开NuGet包管理器，并输入以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, go into the script file and add this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入脚本文件并添加以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**Warning**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: Type Providers are constantly changing their version number. Therefore, `SQLProvider.0.0.11`
    will fail unless you edit it. To determine the correct version, go into the packages
    folder in your solution and look at the path.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者不断更改它们的版本号。因此，`SQLProvider.0.0.11`将失败，除非你编辑它。为了确定正确的版本，进入你的解决方案中的包文件夹并查看路径。
- en: 'Once you put in the correct version of the provider, you might get a dialog
    box that looks like this (this is from the last chapter):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入了正确的提供者版本，你可能会得到一个类似这样的对话框（这是上一章的内容）：
- en: '![SqlProvider](img/00073.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![SqlProvider](img/00073.jpeg)'
- en: 'Click on **Enable**. Heading back to the script, go ahead and enter the following
    code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**启用**。返回脚本，输入以下代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Enter the following code in the script file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本文件中输入以下代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sending that to the FSI gives us the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到FSI后，我们得到以下结果：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a couple of things to notice here. First, we are sending a query
    (sometimes referred to as a *computational expression*) to the type provider.
    In this case, we are selecting all customers where the `storeId` is greater than
    `0`—the individual customers. The expression is everything between the `{}` symbols.
    Notice that it is LINQ-syntax, because it is LINQ. If you are not familiar, LINQ
    stands for **language Integrated Query** and is a language within a language—it
    allows for querying capabilities to be placed inside your .NET language of choice.
    The other thing to notice is that the results of the expression are piped to our
    familiar F# `Seq` type. This means we can get any result from the expression and
    use `Seq` to further shape or refine the data. To see this in action, enter this
    into the script file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。首先，我们向类型提供者发送一个查询（有时被称为*计算表达式*）。在这种情况下，我们选择所有`storeId`大于`0`的客户——个人客户。表达式是`{}`符号之间的所有内容。注意，它是LINQ语法，因为它是LINQ。如果你不熟悉，LINQ代表**语言集成查询**，它是一种语言内的语言——它允许将查询功能放置在你的.NET语言选择中。另一件需要注意的事情是，表达式的结果被管道化到我们熟悉的F#
    `Seq`类型。这意味着我们可以从表达式中获取任何结果，并使用`Seq`进一步塑造或精炼数据。要看到这一点，请将以下内容输入到脚本文件中：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you send it to the FSI, you should see an array of product IDs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到FSI时，你应该会看到一个产品ID数组：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Going back to the code, we are joining three tables from the **AdventureWorks**
    database together via their foreign keys:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码，我们通过外键将来自**AdventureWorks**数据库的三个表连接在一起：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the next line, we are selecting only those customers that are in the customers''
    table that we created previously. Notice that we are using the F# `in` operator
    of `|=|`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们只选择那些在我们之前创建的客户表中存在的客户。注意，我们正在使用F#的`in`运算符`|=|`：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we are selecting only the product IDs and then pulling down all of
    the values and then selecting the unique values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只选择产品ID，然后拉取所有值，然后选择唯一值：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s keep going and see what else we can do. Enter the following into the
    script:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看我们还能做什么。将以下内容输入到脚本中：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sending this to the REPL we see:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们看到：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this block of code, we are pulling down all the reviews. We are then grouping
    the reviews by `productId`. From there, we can sum up the ratings and the count
    of the number of reviews (using `Seq.length`). We can then divide the total ratings
    amount by the number of reviews and get the average review for each `productId`.
    Finally, we throw in a `Seq.sortBy` and pipe it to an array. All of this F# code
    should be familiar as it is very similar to how we manipulated data in [Chapter
    2](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055 "Chapter 2. AdventureWorks
    Regression"), *AdventureWorks Regression*, [Chapter 3](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 3. More AdventureWorks Regression"), *More AdventureWorks Regression*,
    and [Chapter 4](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "Chapter 4. Traffic Stops – Barking Up the Wrong Tree?"), *Traffic Stops – Barking
    Up the Wrong Tree?*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们拉取所有评论。然后我们按`productId`对评论进行分组。从那里，我们可以汇总评分和评论数量的总和（使用`Seq.length`）。然后我们可以将总评分量除以评论数量，得到每个`productId`的平均评论。最后，我们加入一个`Seq.sortBy`并将其管道化到一个数组中。所有这些F#代码都应该很熟悉，因为它与我们如何在[第2章](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "第2章。AdventureWorks回归")、*AdventureWorks回归*、[第3章](part0029_split_000.html#RL0A2-a18db0be6c20485ba81f22e43ca13055
    "第3章。更多AdventureWorks回归")、*更多AdventureWorks回归*和[第4章](part0032_split_000.html#UGI01-a18db0be6c20485ba81f22e43ca13055
    "第4章。交通拦截——走错了路？")、*交通拦截——走错了路？*中处理数据非常相似。
- en: 'Next, let''s create a data frame (sometimes called a *rectangle* of data if
    you are geometrically inclined) of prices for each product:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为每个产品创建一个价格数据框（如果你有几何倾向，有时也称为*数据矩形*）：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Sending that to the REPL, you should see the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，你应该会看到以下内容：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code does not introduce anything new. We pull down all of the products
    that are in our array, take the `productId` and `list price`, sort it, and send
    it to an array. Finally, enter the following into the script file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有引入任何新内容。我们拉取数组中所有的产品，获取`productId`和`list price`，对其进行排序，然后发送到一个数组中。最后，将以下内容输入到脚本文件中：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Sending this to the REPL gives us the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们得到以下结果：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a pretty sizable code block so it can look daunting. What we are doing
    is first pulling down all of the `SalesOrderHeaders` and `SalesOrderDetails` as
    a tuple select (`soh,sod`). We then pipe that set into a `Seq.map` that returns
    a sequence of a tuple that has three elements: `ProductId`, `OrderQty`, and `CustomerId
    |> Seq.map(fun (soh,sod) -> sod.ProductId, sod.OrderQty, soh.CustomerId)`. From
    there we pipe those tuples into a `groupBy` for the `ProductId |> Seq.groupBy(fun
    (pid,q,cid) -> pid)`. From there, we go a bit crazy. Take a look at the next line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当大的代码块，看起来可能会让人感到畏惧。我们所做的是首先将所有的 `SalesOrderHeaders` 和 `SalesOrderDetails`
    作为元组选择（`soh,sod`）拉下来。然后我们将这个集合通过 `Seq.map` 转换成一个元组序列，该序列包含三个元素：`ProductId`、`OrderQty`
    和 `CustomerId`（`Seq.map(fun (soh,sod) -> sod.ProductId, sod.OrderQty, soh.CustomerId)`）。从那里，我们将这些元组通过
    `groupBy` 分组到 `ProductId`（`Seq.groupBy(fun (pid,q,cid) -> pid)`）。从那里，我们开始变得有些疯狂。看看下一行：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hopefully, you remember the discussion about `GroupBy`, so you realize that
    the input is a tuple of `ProductId` and an array of the three-item tuple of (`ProductId`,
    `OrderQty`, and `CustomerId`). We create a new three-item tuple that has `ProductId`,
    the sum of the `OrderQty`, and yet another tuple that has the `CustomerId` and
    a sequence of the distinct `customerId` items.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你记得关于 `GroupBy` 的讨论，这样你就会意识到输入是一个包含 `ProductId` 和三个项元组数组（`ProductId`、`OrderQty`
    和 `CustomerId`）的元组。我们创建一个新的三项元组，包含 `ProductId`、`OrderQty` 的总和，以及另一个包含 `CustomerId`
    和不同 `customerId` 项序列的元组。
- en: 'When we pipe this to the next line, we take the length of that last tuple (`CustomerId,`
    Array of `CustomerIds`) as that is the number of unique customers that ordered
    the product. The three-item tuple is `ProductId`, `SumOfQuantityOrdered`, and
    `CountOfUniqueCustomersThatOrdered`. Since that is a bit verbose, I used the standard
    tuple notation of `(pid, q, c)`, where `q` is SumOfQuan`t`ityOrdered and `c` is
    `CountOfUniqueCustomersThatOrdered`. This tuple is then piped to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这个通过到下一行时，我们取最后一个元组（`CustomerId,` `CustomerIds` 数组）的长度，因为这是订购该产品的唯一客户数量。这个三项元组是
    `ProductId`、`SumOfQuantityOrdered` 和 `CountOfUniqueCustomersThatOrdered`。由于这有点冗长，我使用了标准的元组表示法
    `(pid, q, c)`，其中 `q` 是 `SumOfQuantityOrdered`，`c` 是 `CountOfUniqueCustomersThatOrdered`。这个元组随后通过到以下：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now get the average number of orders for each product. We then finish
    off with a sort and send it to an array. We now have three arrays of tuples:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以得到每个产品的平均订单数量。然后我们完成排序并发送到一个数组。现在我们有三个元组数组：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Ideally, we can then combine these into one array that has `ProductId`, `AverageNumberOfOrders`,
    `AverageReviews`, and `PriceOfProduct`. To do that, you might think that we can
    just zip these three arrays up. Go into the script and enter the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们可以将这些合并成一个包含 `ProductId`、`AverageNumberOfOrders`、`AverageReviews` 和
    `PriceOfProduct` 的数组。为了做到这一点，你可能认为我们可以直接将这些三个数组连接起来。进入脚本并输入以下内容：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you send it to the FSI, you will see something disappointing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到 FSI 时，你会看到一些令人失望的内容：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The arrays are not matching up. Apparently, some products do not have any ratings.
    What we need is a way to join these three arrays into one array and have the join
    occur on the `ProductId`. Although we could go back and play around with our `where`
    clauses in the LINQ expressions, there is an alternative way.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数组没有匹配。显然，有些产品没有任何评分。我们需要一种方法将这些三个数组连接成一个数组，并且连接发生在 `ProductId` 上。虽然我们可以回到 LINQ
    表达式中的 `where` 子句并尝试调整，但有一个替代方法。
- en: Deedle
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Deedle
- en: 'Go into the script file and enter the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 进入脚本文件并输入以下代码：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we did earlier, you will have to make sure the version numbers match. When
    you send it to the REPL, you will see the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，你必须确保版本号匹配。当你将其发送到 REPL 时，你会看到以下内容：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What we have done is loaded **Deedle**. Deedle is a neat library created for
    time-series analysis. Let''s see if Deedle can help us with our unbalanced array
    issue. The first thing we want to do is to take our array of tuples and turn them
    into data frames. Enter this into the script:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是加载了 **Deedle**。Deedle 是一个为时间序列分析创建的 neat 库。让我们看看 Deedle 是否能帮助我们解决不平衡数组问题。我们首先想要做的是将我们的元组数组转换为数据框。将以下内容输入到脚本中：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Sending this to the FSI, you will see something like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个发送到 FSI，你会看到如下内容：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s rename `Item1` and `Item2` to something that has a bit more meaning
    and make the first vector of the fame the primary key of the frame. Enter the
    following into the script file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 `Item1` 和 `Item2` 重命名为更有意义的东西，并将 fame 的第一个向量作为帧的主键。将以下内容输入到脚本文件中：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code should be fairly self-explanatory. We are creating a function called
    `adjustFrame` that takes in two arguments: a data frame and an array of strings
    that will become the header values. We apply the headers via the first pipe, make
    the first column (`ProductId`) the `primaryKey` via the second pipe, and then
    sort the frame via the third pipe. We then apply this function to our three data
    frames: orders, prices, and reviews. Notice that we are using the tick notation.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该是相当直观的。我们正在创建一个名为 `adjustFrame` 的函数，它接受两个参数：一个数据框和一个字符串数组，这些字符串将成为标题值。我们通过第一个管道应用标题，通过第二个管道将第一列（`ProductId`）设置为
    `primaryKey`，然后通过第三个管道对数据框进行排序。然后我们将此函数应用于我们的三个数据框：订单、价格和评论。请注意，我们正在使用计时符号。
- en: 'From there, we can now combine the frames based on their key. Go to the script
    file and add this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们现在可以根据它们的键来组合数据框。转到脚本文件并添加以下内容：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Sending this to the FSI, you should see the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到 FSI，你应该看到以下内容：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Cool huh? Deedle is a very powerful library that you can use in a variety of
    scenarios.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 酷吧？Deedle 是一个非常强大的库，您可以在各种场景中使用它。
- en: Going back to our original task, we now have two different ways to pull data
    out from a database and transform it. When you do a side-by-side comparison of
    the ADO.NET SQL ways and the type-provider approach, there are some pretty strong
    arguments to be made to use the type provider method. First, `SqlDataProvider`
    is designed for most of the popular relational databases out there. If you moved
    your **AdventureWorks** database from MS SQL Server to MySql, all you would have
    to change is the connection string and all the code would be the same. Second,
    consider that there is no SQL in the type provider implementation. Instead, we
    are using an F# computational expression to pick what tables and what records
    we want. This means we don't have to know any SQL and we have even more portability.
    If we move our AdventureWorks database to a NoSQL database like Mongo or DocumentDb,
    we would have to swap out a type provider and then change our connection string.
    Finally, consider our approach to the data using the type provider. We do not
    have to build any classes ahead of time to put our data into, as types are automatically
    generated for us.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的原始任务，我们现在有两种不同的方式从数据库中提取数据并进行转换。当你对 ADO.NET SQL 方法和类型提供程序方法进行横向比较时，有一些相当有力的论据可以支持使用类型提供程序方法。首先，`SqlDataProvider`
    是为大多数流行的关系数据库设计的。如果你将你的 **AdventureWorks** 数据库从 MS SQL Server 移动到 MySql，你只需要更改连接字符串，所有代码都会保持不变。其次，考虑到类型提供程序实现中没有
    SQL。相反，我们正在使用 F# 计算表达式来选择我们想要的表和记录。这意味着我们不需要知道任何 SQL，我们甚至有更多的可移植性。如果我们将 AdventureWorks
    数据库移动到类似 Mongo 或 DocumentDb 的 NoSQL 数据库，我们只需要更换类型提供程序并更改连接字符串。最后，考虑我们使用类型提供程序的方法。我们不需要提前构建任何类来将数据放入，因为类型会自动为我们生成。
- en: Also, since we are bringing down small chunks of data to the client that are
    then transformed, we can run each step of our though process independently. I
    can't emphasize how important that is; we are extracting and transforming the
    data with small viewable steps that align with our thought process. We can spend
    our mental energy and time focusing on the problem at hand and not wading through
    the syntax of a language we may or may not be comfortable with. The downside of
    the type provider method is that it may be slower than the ADO.NET approach because
    there is less opportunity to hand-adjust query optimization. In this case, we
    are doing ad hoc data exploration and analysis on a small dataset so the performance
    differences are minor. However, even if it was a large dataset, I would still
    follow the software engineering mantra of, "Make it right. Then make it fast."
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们将小块数据传送到客户端，然后对其进行转换，因此我们可以独立运行我们的思维过程的每一步。我无法强调这一点的重要性；我们正在通过与我们思维过程一致的小步骤提取和转换数据。我们可以将我们的精神能量和时间集中在手头的问题上，而不是在可能或不熟悉的语言的语法中挣扎。类型提供程序方法的缺点是它可能比
    ADO.NET 方法慢，因为调整查询优化的机会较少。在这种情况下，我们正在对小型数据集进行即席数据探索和分析，因此性能差异很小。然而，即使是一个大型数据集，我仍然会遵循软件工程的格言：“先做对，再做快。”
- en: MicrosoftSqlProvider
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicrosoftSqlProvider
- en: Before we leave our discussion on type providers, I want to show another type
    provider that is built upon Entity Framework 7 that has a lot of promise, especially
    when you want to start using type providers as a replacement to your current ORM.
    It is called the `EntityFramework.MicrosoftSqlServer` type provider.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对类型提供者的讨论之前，我想展示另一个基于 Entity Framework 7 构建的类型提供者，它有很多潜力，尤其是在你想开始使用类型提供者作为当前
    ORM 的替代品时。它被称为 `EntityFramework.MicrosoftSqlServer` 类型提供者。
- en: 'Go back to Visual Studio, open the package manager console and enter the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Visual Studio，打开包管理控制台，并输入以下内容：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, go to your script file and enter the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到你的脚本文件并输入以下内容：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Yes, I know that is a lot, but you only have to enter this once and you don''t
    have to bring it over to your `.fs` file. If you don''t want to copy and paste
    this code over to your script, you can just install all of Entity Framework, and
    these packages will be available. In any event, enter the following into the script
    file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道这有很多，但你只需要输入一次，而且你不需要将它带到你的 `.fs` 文件中。如果你不想将这段代码复制粘贴到你的脚本中，你只需安装所有 Entity
    Framework，这些包就会可用。无论如何，将以下内容输入到脚本文件中：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Go back to the script file and enter the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 返回脚本文件并输入以下内容：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you send this to the FSI, you will see the `SalesOrderheader` Entity Framework
    type in all its glory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个发送到 FSI 时，你会看到所有荣耀的 `SalesOrderheader` Entity Framework 类型：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The implications are that anything you do with Entity Framework, you can do
    with the type provider—with no upfront code. No templates, no designers, no nothin'.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，你可以用类型提供者做任何用 Entity Framework 做的事情——无需前置代码。没有模板，没有设计器，什么都没有。
- en: 'Let''s press on and see how the type provider handles null. Go into the script
    and enter the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看类型提供者如何处理空值。进入脚本并输入以下内容：
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you send this to the FSI, you will see something like the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这段代码发送到 FSI 时，你会看到以下类似的内容：
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice that we have to use `System.Nullable<int>` in the `where` condition
    to account for the fact that `ProductSubcategoyID` is nullable on the database.
    This leads to one small *gotcha* with using the type provider. You can''t use
    the out of the box `|=|` operator to search for an array of values. For example,
    if you sent the following to the REPL:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须在 `where` 条件中使用 `System.Nullable<int>` 来考虑 `ProductSubcategoyID` 在数据库中是可空的。这导致使用类型提供者时有一个小
    *陷阱*。你不能使用现成的 `|=|` 操作符来搜索值数组。例如，如果你将以下内容发送到 REPL：
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You will get the following back:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下结果：
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We now need to create an array of nullable ints. Will that work?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建一个可空整数的数组。这会起作用吗？
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alas, no:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 唉，没有：
- en: '[PRE39]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So there are a couple of ways out of this problem. Option number 1, is that
    you can create a function. Enter the following into your script file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，有几种方法可以解决这个问题。选项 1 是，你可以创建一个函数。将以下内容输入到你的脚本文件中：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Sending this to the FSI gives you the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个发送到 FSI 会给你以下结果：
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There is no new code here. We created a function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的代码。我们创建了一个函数。
- en: 'But wait! There''s more! Go back to the script file and enter the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！还有更多！返回脚本文件并输入以下内容：
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So what is this line of code?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码是什么意思？
- en: '[PRE43]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is a function named `|=|` that takes in two parameters: the `id` to search
    and the array that gets searched. This function is called an *infix* operator
    because we are assigning symbols to stand in for a more descriptive name. Consider
    how the `+` operator stands in for *Add*. With that infix operator in place, we
    can go back and make our syntax more intuitive here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为 `|=|` 的函数，它接受两个参数：要搜索的 `id` 和要搜索的数组。这个函数被称为 *中缀* 操作符，因为我们正在将符号分配给更描述性的名称。考虑一下
    `+` 操作符代表 *加法*。有了这个中缀操作符，我们可以回到这里并使我们的语法更直观：
- en: '[PRE44]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There is one more option to consider: just ditching the extra function and
    inlining `Array.contains`. Go back to the script and enter this in:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个选项可以考虑：就是放弃额外的函数，并将 `Array.contains` 内联。返回脚本并输入以下内容：
- en: '[PRE45]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Sending this to the REPL gives us the expected return:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个发送到 REPL 给我们预期的返回结果：
- en: '[PRE46]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So we have three different ways to handle the problem. Do we pick the named
    function, the in-fix operator, or the in-line function? In this case, I would
    pick the in-fix operator because we are replacing an existing operator that should
    work and makes the line the most readable. Others might disagree and you have
    to be prepared as a data scientist to be able to read other people's code, so
    it is good that you are familiar with all three ways.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有三种不同的方式来处理这个问题。我们是选择命名函数、中缀运算符，还是内联函数？在这种情况下，我会选择中缀运算符，因为我们正在替换一个应该工作并使行最易读的现有运算符。其他人可能不同意，你必须准备好作为一个数据科学家能够阅读其他人的代码，所以熟悉所有三种方式是很好的。
- en: SQL Server type provider wrap up
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL Server类型提供者总结
- en: 'I have already highlighted two SQL type providers in this chapter. There are
    actually five different type providers that you can use when accessing SQL databases
    that I know of, and there are certainly more. When you first start using F#, you
    might be confused about which one to use. For your reference, here is my basic
    run down:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在本章中突出显示了两个SQL类型提供者。实际上，我知道有五种不同的类型提供者，你可以在访问SQL数据库时使用，而且肯定还有更多。当你刚开始使用F#时，你可能会对使用哪一个感到困惑。为了你的参考，以下是我的基本概述：
- en: '`FSharp.Data.TypeProviders.SqlServerProvider`: This is a part of Visual Studio
    install, is supported by Microsoft, and no new development is going on. Since
    this is the end of life, you would not want to use this.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSharp.Data.TypeProviders.SqlServerProvider`: 这是Visual Studio安装的一部分，由Microsoft支持，目前没有新的开发工作在进行。由于这是生命周期的结束，你不会想使用这个。'
- en: '`FSharp.Data.TypeProviders.EntityFrameworkProvider`: This is a part of Visual
    Studio install, is supported by Microsoft, and no new development is going on.
    It is good for vanilla databases.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSharp.Data.TypeProviders.EntityFrameworkProvider`: 这是Visual Studio安装的一部分，由Microsoft支持，目前没有新的开发工作在进行。它非常适合纯数据库。'
- en: '`FSharp.Data.SqlClient`: This was created by the community. It is a very stable
    way to pass SQL commands to the server. It does not support LINQ-style computational
    expressions. It is good for CRUD-based F# operations.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSharp.Data.SqlClient`: 这是由社区创建的。这是一种非常稳定的方式来将SQL命令传递到服务器。它不支持LINQ风格的计算表达式。它非常适合基于CRUD的F#操作。'
- en: '`FSharp.Data.SqlProvider`: This was created by the community in pre-release,
    so there is some instability. It is very good for doing LINQ-style computation
    expressions. It supports different RDMS like Oracle, MySQL, and SQL Server.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSharp.Data.SqlProvider`: 这是在预发布阶段由社区创建的，所以有一些不稳定性。它非常适合进行LINQ风格的计算表达式。它支持不同的RDMS，如Oracle、MySQL和SQL
    Server。'
- en: '`FSharp.EntityFramework.MicrosoftSqlServer`: This was created by the community.
    It is in its very early stages, but holds tons of promise to be a great replacement
    to traditional ORM coding. It is good for doing LINQ-style computation expressions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FSharp.EntityFramework.MicrosoftSqlServer`: 这是由社区创建的。它处于非常初级的阶段，但有很大的潜力成为传统ORM编码的绝佳替代品。它非常适合进行LINQ风格的计算表达式。'
- en: Non SQL type providers
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非SQL类型提供者
- en: Type providers are not just for relational database management systems. In fact,
    there are JSON type providers, XML type providers, CSV type providers, the list
    goes on. Let's take a look at a couple and see how we can use them to make some
    really interesting data frames based on heterogeneous data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者不仅用于关系数据库管理系统。实际上，还有JSON类型提供者、XML类型提供者、CSV类型提供者，等等。让我们看看几个，看看我们如何使用它们来创建一些基于异构数据的有意思的数据框。
- en: 'Go into Visual Studio and add a new script file called `NonSqlTypeProviders.fsx`.
    At the top, bring in all of the references that we''ll be using and open up the
    needed libraries:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 进入Visual Studio，添加一个名为`NonSqlTypeProviders.fsx`的新脚本文件。在顶部，引入我们将使用的所有引用并打开所需的库：
- en: '[PRE47]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Send it to the REPL to make sure you have all of the needed libraries. In the
    script, add the following code to bring in data from our AdventureWorks SQL Server
    database. You will notice that I am piping straight to Deedle''s dataframe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到REPL以确保你有所有需要的库。在脚本中添加以下代码以从我们的AdventureWorks SQL Server数据库中获取数据。你会注意到我直接将数据管道到Deedle的数据框中：
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Go back to the script and add some data that is stored in a CSV file from Yahoo
    Finance. In this case, it is the change in daily stock price for the Dow Jones
    Industrial Average:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 回到脚本中，添加一些存储在Yahoo Finance CSV文件中的数据。在这种情况下，这是道琼斯工业平均指数的每日股价变化：
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Send it to the REPL to get the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到REPL以获取以下内容：
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Go back to the script and add some data that is served up by an API in JSON
    format from Quandl. In this case, it is the number of sunspots recorded by the
    Royal Observatory in Belgium.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回到脚本，并添加一些由Quandl API以JSON格式提供的数据。在这种情况下，是比利时皇家天文台记录的太阳黑子数量。
- en: '[PRE51]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When you send it to the FSI, you should get something like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到FSI时，你应该会得到以下类似的结果：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, go back to the script and join all three data frames:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到脚本并将所有三个数据帧合并：
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Sending that to the REPL gives:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL会得到：
- en: '[PRE54]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll leave the process of creating a model to see if there is a relationship
    among the Down Jones Price Change and the number of sunspots on the amount of
    Sales by Day up to the reader. Before you get too carried away, you might want
    to consider this website about data elements that have no relation but are correlated
    ([http://tylervigen.com/spurious-correlations](http://tylervigen.com/spurious-correlations)).
    I think this is my favorite one:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建模型的过程留给读者，看看道琼斯价格变动和每日销售数量之间是否存在关系。在你过于沉迷之前，你可能想要考虑这个关于没有关系但相关联的数据元素网站([http://tylervigen.com/spurious-correlations](http://tylervigen.com/spurious-correlations))。我认为这是我最喜欢的一个：
- en: '![Non SQL type providers](img/00074.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![非SQL类型提供者](img/00074.jpeg)'
- en: Combining data
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并数据
- en: 'Sometimes the data that you obtain from a source system is incomplete. Consider
    this dataset of crash locations that was obtained from the State Department of
    Transportation office:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有时从源系统获得的数据可能是不完整的。考虑这个从州交通部办公室获得的交通事故位置数据集：
- en: '![Combining data](img/00075.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![合并数据](img/00075.jpeg)'
- en: Notice that latitude and longitude are missing and that location does not use
    a normal address/city/state pattern. Rather, it is **OnRoad**, **Miles**, **FromRoad**,
    and **TowardRoad**. Unfortunately, this is fairly common when getting data from
    public entities—systems may have been built before lat/lon became mainstream and
    the system's addressing might be designed to only work inside the system. This
    means we need a way to figure out the latitude and longitude from this atypical
    addressing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到纬度和经度缺失，并且位置不使用正常的地址/城市/州模式。相反，它是**OnRoad**、**Miles**、**FromRoad**和**TowardRoad**。不幸的是，当从公共实体获取数据时，这种情况相当普遍——系统可能是在纬/经成为主流之前建立的，系统的地址设计可能只适用于系统内部。这意味着我们需要一种方法来确定这种非典型地址的纬度和经度。
- en: If you pull the source code down from the site, you will see a couple of script
    files. The first is called `BingGeocode`. This is a script that goes out to the
    Bing maps API and returns a geolocation for a given address. The key thing is
    that, although Bing does not recognize **OnRoad**/**FromRoad**/**TowardRoad**,
    it does recognize cross streets. Therefore, we can take a sample from the crash
    dataset of incidents that happened at or near intersections—which we can determine
    from the **OnRoad**/**FromRoad** as long as the **Miles** value is fairly low.
    In fact, 90 percent of the records are within a quarter mile of an intersection.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从网站上拉取源代码，你会看到几个脚本文件。第一个叫做`BingGeocode`。这是一个脚本，它会调用必应地图API并为给定的地址返回地理位置。关键在于，尽管必应不识别**OnRoad**/**FromRoad**/**TowardRoad**，但它确实识别交叉街道。因此，我们可以从事故数据集中抽取样本，这些事故发生在或接近交叉口——只要**Miles**值相对较低，我们就可以从**OnRoad**/**FromRoad**中确定这一点。事实上，90%的记录都在交叉口四分之一英里范围内。
- en: 'If you inspect the code, you will see that there is nothing particularly new
    here. We use the JSON type provider to make the call to Bing, and we parse the
    results, using the `Option` type to return none or some Geolocation. If you want
    to run this on your machine, we will need to sign up for the Bing Map API developer
    program here ([https://www.bingmapsportal.com/](https://www.bingmapsportal.com/))
    and put your value into the `apiKey`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查代码，你会看到这里没有什么特别新的东西。我们使用JSON类型提供者调用必应，并解析结果，使用`Option`类型返回无或某些地理位置。如果你想在自己的机器上运行这个，我们需要在这里注册必应地图API开发者计划([https://www.bingmapsportal.com/](https://www.bingmapsportal.com/))并将你的值放入`apiKey`：
- en: '[PRE55]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the solution, there is another script file that does the actual heavy lifting
    of pulling the original crash data from the database, updating it with the latitude
    and longitude, and then putting it back into the database. This script file is
    called `UpdateCrashLatLon.fsx`. If you look at the code, the first part pulls
    down crashes that happened in the same town as the traffic stops and occurred
    within a quarter mile of an intersection. It then creates an address string that
    is passed to the Bing geocode file and creates a frame with the ID and the latitude
    and longitude. We then filter that Array with only the values that returned as
    some:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中，还有一个脚本文件负责从数据库中提取原始事故数据，更新其经纬度，并将其放回数据库。这个脚本文件名为`UpdateCrashLatLon.fsx`。如果你查看代码，第一部分会下载发生在与交通停止地点相同的城镇内，且距离交叉口四分之一英里以内的事故。然后它创建一个地址字符串，传递给Bing地理编码文件，并创建一个包含ID和经纬度的框架。然后我们只过滤出返回值为some的值。
- en: '[PRE56]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There is one new line of code in this script: `#load "BingGeocode.fsx"`. This
    adds a reference to the script file we already created, so we can go ahead and
    invoke the `getGeocode()` function.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中增加了一行新代码：`#load "BingGeocode.fsx"`。这为脚本文件添加了一个引用，因此我们可以继续调用`getGeocode()`函数。
- en: 'Before we update the database with our data, I wrote a script to write the
    data to the local disk:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用数据更新数据库之前，我编写了一个脚本将数据写入本地磁盘：
- en: '[PRE57]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As the comment says, Bing throttles how many requests you can make per hour.
    The last thing you want is to have to re-query Bing because you are experimenting
    with the data and get a 401 error back because you are at your limit. Rather,
    it is much better to bring it local once and work off a local copy.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如注释所述，Bing限制了每小时可以发送的请求数量。你最不希望的事情就是在实验数据时需要重新查询Bing，因为你达到了限制，然后收到401错误。相反，最好是将数据一次性本地化，然后基于本地副本进行工作。
- en: 'With the data local, we can then pull down each record from the database that
    we want to update, update the lat/long, and write it back to the database:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 数据本地化后，我们就可以从数据库中拉取我们想要更新的每条记录，更新经纬度，并将其写回数据库：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Parallelism
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行处理
- en: 'I want to show you one more trick that will greatly speed up your data extraction—parallelism.
    My machine has four cores, but only one core is being used in the prior example
    when making the API calls to Bing. It would be much faster if I could use all
    of the cores and make the requests in parallel. F# makes this a snap. As a demonstration,
    I re-queried Bing for the first 200 crash records and wrote the time out to the
    FSI:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向你展示一个能大大加快数据提取速度的技巧——并行处理。我的机器有四个核心，但在先前的例子中，当调用Bing的API时，只有一个核心被使用。如果我能使用所有核心并行发送请求，将会快得多。F#让这变得非常简单。作为一个演示，我重新查询了前200条事故记录，并将时间输出到FSI：
- en: '[PRE59]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When I ran it, it took 33 seconds:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行它时，耗时33秒：
- en: '[PRE60]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, I added this code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我添加了以下代码：
- en: '[PRE61]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Notice that the only change was adding a reference to `Collections.Array.Parallel`
    and then considering the following line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，唯一的改变是添加了对`Collections.Array.Parallel`的引用，然后考虑以下这一行：
- en: '[PRE62]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Change this line to the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一行改为以下内容：
- en: '[PRE63]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When I ran it, I saw this in the FSI:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行它时，我在FSI中看到了以下内容：
- en: '[PRE64]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So I got a 3x speed improvement by changing one line. Because F# was built from
    the ground-up with parallelism and async in mind, it is very easy to take advantage
    of these concepts. The other languages have these features bolted on and can be
    very cumbersome to use and often can lead to race conditions or worse.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，通过改变一行代码，我实现了3倍的速度提升。因为F#是从底层构建时就考虑了并行性和异步操作，所以利用这些概念非常容易。其他语言则是将这些特性附加上去，使用起来可能会非常繁琐，而且经常会导致竞态条件或更糟糕的情况。
- en: There is one more thing to note when you are pulling mass data from a web service.
    Unless you explicitly code it, you have no real way of monitoring the progress.
    I often pop open Fiddler ([http://www.telerik.com/fiddler](http://www.telerik.com/fiddler))
    and monitor the HTTP traffic to see how things are progressing.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当从网络服务中提取大量数据时，还有一点需要注意。除非你明确编码，否则你实际上没有真正的方法来监控进度。我经常打开Fiddler（[http://www.telerik.com/fiddler](http://www.telerik.com/fiddler)）来监控HTTP流量，以查看进度情况。
- en: '![Parallelism](img/00076.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![并行处理](img/00076.jpeg)'
- en: JSON type provider – authentication
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON类型提供者 – 认证
- en: The JSON type provider is a very handy tool, but there is a limitation to its
    out of the box implementation—it assumes that the web service does not have any
    authentication or the authentication token is part of the query string. Some datasets
    are not like that—in fact most web services use headers for authentication. Fortunately,
    there is a way to code around this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: JSON类型提供者是一个非常实用的工具，但它的默认实现存在一个限制——它假设网络服务没有认证或者认证令牌是查询字符串的一部分。有些数据集并不是这样——事实上，大多数网络服务使用头部进行认证。幸运的是，有一种方法可以绕过这个限制。
- en: 'Consider this open dataset—the NOAA archives ([http://www.ncdc.noaa.gov/cdo-web/webservices/v2](http://www.ncdc.noaa.gov/cdo-web/webservices/v2)).
    If you look at the solution that comes with the chapter, there is a script file
    called `GetWeatherData.fsx`. In this script, I picked a single zip code for the
    town where the traffic stops and crashes occurred and pulled down the daily precipitation:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个公开数据集——NOAA档案([http://www.ncdc.noaa.gov/cdo-web/webservices/v2](http://www.ncdc.noaa.gov/cdo-web/webservices/v2))。如果你查看章节中附带解决方案，有一个名为`GetWeatherData.fsx`的脚本文件。在这个脚本中，我选择了一个小镇的交通停止和事故发生的单个邮政编码，并下载了每日降水量：
- en: '[PRE65]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'There is one thing new here. I am using the JSON type provider but the authorization
    token needs to be in the header of the request. Since the JSON type provider does
    not allow you to set headers, you need to pull the data down via the `System.Net.WebClient`
    class (where you can set the `auth` token in the header) and then use the JSON
    type provider to parse the results. You can see that I am using `Parse()` and
    not `Load()` in the following line to accomplish that:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一件新事物。我正在使用JSON类型提供者，但授权令牌需要放在请求的头部。由于JSON类型提供者不允许你设置头部，你需要通过`System.Net.WebClient`类（你可以在其中设置`auth`令牌在头部）下载数据，然后使用JSON类型提供者来解析结果。你可以看到，在下面的行中，我使用的是`Parse()`而不是`Load()`来完成这个任务：
- en: '[PRE66]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Just like the geolocation data, I then pushed the data frame to disk because
    the number of requests are limited:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像地理位置数据一样，我将数据帧推送到磁盘，因为请求数量有限：
- en: '[PRE67]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Also, like the data geolocation data, you can do this on your machine but you
    will need an `apiToken`. You can go to the NOAA developer website to apply for
    one. I also added the data as a table on the SQL Server so you don''t have to
    pull the data from the source code to write the remaining code in the chapter.
    Go into the active `kmeans.fsx` script file and enter this to get the data from
    the database:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，就像数据地理位置数据一样，你可以在你的机器上做这件事，但你将需要一个`apiToken`。你可以访问NOAA开发者网站申请一个。我还将数据添加到了SQL
    Server上的一个表格中，这样你就不需要从源代码中拉取数据来编写章节中剩余的代码。进入活动的`kmeans.fsx`脚本文件，输入以下内容以从数据库中获取数据：
- en: '[PRE68]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When you send it to the FSI, you will get the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将其发送到FSI时，你会得到以下内容：
- en: '[PRE69]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: If you ask a data scientist what they like least about their day, they will
    tell you meetings, building slide decks, and munging data in no particular order.
    Although F# type providers can't help you with meetings and building slide decks,
    it can decrease the amount of time spent obtaining and cleaning data. Although
    not completely frictionless, type providers can help you with relational and non-relational
    data stores and enable you to spend more time with the "fun" parts of data science.
    Speaking of which, let's jump back into the fun with KNN and Naïve Bayes modeling.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问数据科学家他们最不喜欢他们的一天中的什么，他们会告诉你会议、制作幻灯片和按无特定顺序整理数据。尽管F#类型提供者不能帮助你处理会议和制作幻灯片，但它可以减少获取和清理数据所需的时间。尽管不是完全无摩擦，类型提供者可以帮助你处理关系型和非关系型数据存储，并使你能够有更多时间投入到数据科学的“有趣”部分。说到这里，让我们回到KNN和朴素贝叶斯建模的乐趣中吧。
