- en: Chapter 8. Tracking Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：跟踪对象
- en: In this chapter, we will explore the vast topic of object tracking, which is
    the process of locating a moving object in a movie or video feed from a camera.
    Real-time object tracking is a critical task in many computer vision applications
    such as surveillance, perceptual user interfaces, augmented reality, object-based
    video compression, and driver assistance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨对象跟踪这一广泛的主题，它是从电影或视频输入中定位移动对象的过程。实时对象跟踪是许多计算机视觉应用（如监控、感知用户界面、增强现实、基于对象的视频压缩和驾驶员辅助）中的关键任务。
- en: Tracking objects can be accomplished in several ways, with the optimal technique
    being largely dependent on the task at hand. We will learn how to identify moving
    objects and track them across frames.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪对象可以通过多种方式完成，最佳技术很大程度上取决于手头的任务。我们将学习如何识别移动对象并在帧之间跟踪它们。
- en: Detecting moving objects
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测移动对象
- en: The first task that needs to be accomplished for us to be able to track anything
    in a video is to identify those regions of a video frame that correspond to moving
    objects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够跟踪视频中的任何物体，我们需要完成的第一项任务是识别视频帧中对应于移动对象的区域。
- en: There are many ways to track objects in a video, all of them fulfilling a slightly
    different purpose. For example, you may want to track anything that moves, in
    which case differences between frames are going to be of help; you may want to
    track a hand moving in a video, in which case Meanshift based on the color of
    the skin is the most appropriate solution; you may want to track a particular
    object of which you know the aspect, in which case techniques such as template
    matching will be of help.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频中跟踪对象有许多方法，它们都满足略微不同的目的。例如，你可能想跟踪任何移动的物体，在这种情况下，帧之间的差异将有所帮助；你可能想跟踪视频中移动的手，在这种情况下，基于皮肤颜色的Meanshift是最合适的解决方案；你可能想跟踪一个你知道其外观的特定对象，在这种情况下，模板匹配等技术将有所帮助。
- en: Object tracking techniques can get quite complex, let's explore them in the
    ascending order of difficulty, starting from the simplest technique.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目标跟踪技术可能相当复杂，让我们按难度递增的顺序来探讨它们，从最简单的技术开始。
- en: Basic motion detection
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本运动检测
- en: The first and most intuitive solution is to calculate the differences between
    frames, or between a frame considered "background" and all the other frames.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最直观的解决方案是计算帧之间的差异，或者计算一个被认为是“背景”的帧与所有其他帧之间的差异。
- en: 'Let''s look at an example of this approach:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种方法的一个例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the necessary imports, we open the video feed obtained from the default
    system camera, and we set the first frame as the background of the entire feed.
    Each frame read from that point onward is processed to calculate the difference
    between the background and the frame itself. This is a trivial operation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成必要的导入之后，我们打开从默认系统相机获取的视频输入，并将第一帧设置为整个输入的背景。从那时起读取的每一帧都会被处理，以计算背景与帧本身的差异。这是一个简单的操作：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before we get to do that, though, we need to prepare our frame for processing.
    The first thing we do is convert the frame to grayscale and blur it a bit:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始之前，我们需要为处理准备我们的帧。我们首先做的事情是将帧转换为灰度并稍微模糊一下：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may wonder about the blurring: the reason why we blur the image is that,
    in each video feed, there''s a natural noise coming from natural vibrations, changes
    in lighting, and the noise generated by the camera itself. We want to smooth this
    noise out so that it doesn''t get detected as motion and consequently get tracked.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对模糊处理感到好奇：我们模糊图像的原因是，在每一帧视频输入中，都存在来自自然振动、光照变化以及相机本身产生的自然噪声。我们希望平滑这些噪声，以免它们被检测为运动并随之被追踪。
- en: 'Now that our frame is grayscaled and smoothed, we can calculate the difference
    compared to the background (which has also been grayscaled and smoothed), and
    obtain a map of differences. This is not the only processing step, though. We''re
    also going to apply a threshold, so as to obtain a black and white image, and
    dilate the image so holes and imperfections get normalized, like so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将帧转换为灰度并平滑处理，我们可以计算与背景（背景也已被转换为灰度并平滑处理）的差异，并获得差异图。但这不是唯一的处理步骤。我们还将应用一个阈值，以获得黑白图像，并膨胀图像，以便将孔洞和不完美之处标准化，如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that eroding and dilating can also act as a noise filter, much like the
    blurring we applied, and that it can also be obtained in one function call using
    `cv2.morphologyEx`, we show both steps explicitly for transparency purposes. All
    that is left to do at this point is to find the contours of all the white blobs
    in the calculated difference map, and display them. Optionally, we only display
    contours for rectangles greater than an arbitrary threshold, so tiny movements
    are not displayed. Naturally, this is up to you and your application needs. With
    a constant lighting and a very noiseless camera, you may wish to have no threshold
    on the minimum size of the contours. This is how we display the rectangles:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，腐蚀和膨胀也可以作为噪声过滤器，就像我们应用的模糊一样，并且也可以通过一个函数调用使用`cv2.morphologyEx`获得，我们明确展示这两个步骤是为了透明度。此时，我们剩下的唯一任务是找到计算差异图中所有白色团块的轮廓，并将它们显示出来。可选地，我们只显示大于任意阈值的矩形轮廓，这样就不会显示微小的移动。当然，这取决于您和您的应用需求。在恒定照明和非常无噪声的摄像头下，您可能希望没有轮廓最小尺寸的阈值。这就是我们显示矩形的方式：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'OpenCV offers two very handy functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了两个非常实用的函数：
- en: '`cv2.findContours`: This function computes the contours of subjects in an image'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.findContours`：此函数计算图像中主体的轮廓'
- en: '`cv2.boundinRect`: This function calculates their bounding box'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cv2.boundinRect`：此函数计算它们的边界框'
- en: 'So there you have it, a basic motion detector with rectangles around subjects.
    The final result is something like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是它了，一个带有主体周围矩形的简单运动检测器。最终结果可能像这样：
- en: '![Basic motion detection](img/image00242.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![基本运动检测](img/image00242.jpeg)'
- en: For such a simple technique, this is quite accurate. However, there are a few
    drawbacks that make this approach unsuitable for all business needs, most notably
    the fact that you need a first "default" frame to set as a background. In situations
    such as—for example—outdoor cameras, with lights changing quite constantly, this
    process results in a quite inflexible approach, so we need a bit more intelligence
    into our system. That's where background subtractors come into play.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样简单的技术，这相当准确。然而，有一些缺点使得这种方法不适合所有商业需求，最值得注意的是，您需要一个“默认”的第一帧来设置为背景。在例如户外摄像头等情况下，灯光变化相当频繁，这个过程导致了一种相当不灵活的方法，因此我们需要在我们的系统中加入更多的智能。这就是背景减除器发挥作用的地方。
- en: Background subtractors – KNN, MOG2, and GMG
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景减除器 – KNN、MOG2和GMG
- en: OpenCV provides a class called `BackgroundSubtractor`, which is a handy way
    to operate foreground and background segmentation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个名为`BackgroundSubtractor`的类，这是一种方便操作前景和背景分割的方法。
- en: This works similarly to the GrabCut algorithm we analyzed in [Chapter 3](part0023.xhtml#aid-LTSU1
    "Chapter 3. Processing Images with OpenCV 3"), *Processing Images with OpenCV
    3*, however, `BackgroundSubtractor` is a fully fledged class with a plethora of
    methods that not only perform background subtraction, but also improve background
    detection in time through machine learning and lets you save the classifier to
    a file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第3章](part0023.xhtml#aid-LTSU1 "第3章。使用OpenCV 3处理图像")中分析的GrabCut算法类似，即*使用OpenCV
    3处理图像*，然而，`BackgroundSubtractor`是一个功能齐全的类，拥有众多方法，不仅执行背景减除，而且通过机器学习提高背景检测的速度，并允许您将分类器保存到文件中。
- en: 'To familiarize ourselves with `BackgroundSubtractor`, let''s look at a basic
    example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉`BackgroundSubtractor`，让我们看看一个基本示例：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s go through this in order. First of all, let''s talk about the background
    subtractor object. There are three background subtractors available in OpenCV
    3: **K-Nearest Neighbors** (**KNN**), **Mixture of Gaussians** (**MOG2**), and
    **Geometric Multigrid** (**GMG**), corresponding to the algorithm used to compute
    the background subtraction.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序来讲解。首先，让我们谈谈背景减除对象。在OpenCV 3中，有三种背景减除器可供选择：**K-最近邻**（**KNN**）、**高斯混合模型**（**MOG2**）和**几何多重网格**（**GMG**），它们分别对应于计算背景减除所使用的算法。
- en: You may remember that we already elaborated on the topic of foreground and background
    detection in [Chapter 5](part0043.xhtml#aid-190861 "Chapter 5. Detecting and Recognizing
    Faces"), *Depth Estimation and Segmentation*, in particular when we talked about
    GrabCut and Watershed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，我们在[第5章](part0043.xhtml#aid-190861 "第5章。检测和识别人脸")中已经详细讨论了前景和背景检测的主题，即*深度估计和分割*，特别是当我们谈到GrabCut和Watershed时。
- en: So why do we need the `BackgroundSubtractor` classes? The main reason behind
    this is that `BackgroundSubtractor` classes are specifically built with video
    analysis in mind, which means that the OpenCV `BackgroundSubtractor` classes "learn"
    something about the environment with every frame. For example, with GMG, you can
    specify the number of frames used to initialize the video analysis, with the default
    being 120 (roughly 5 seconds with average cameras). The constant aspect about
    the `BackgroundSubtractor` classes is that they operate a comparison between frames
    and they store a history, which allows them to improve motion analysis results
    as time passes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们需要 `BackgroundSubtractor` 类呢？背后的主要原因是 `BackgroundSubtractor` 类是专门为视频分析构建的，这意味着
    OpenCV 的 `BackgroundSubtractor` 类会随着每一帧学习有关环境的一些信息。例如，使用 GMG，你可以指定用于初始化视频分析的帧数，默认为120（大约是平均相机的5秒）。`BackgroundSubtractor`
    类的恒定特性是它们在帧之间进行比较并存储历史记录，这使得它们随着时间的推移改进运动分析结果。
- en: 'Another fundamental (and frankly, quite amazing) feature of the `BackgroundSubtractor`
    classes is the ability to compute shadows. This is absolutely vital for an accurate
    reading of video frames; by detecting shadows, you can exclude shadow areas (by
    thresholding them) from the objects you detected, and concentrate on the real
    features. It also greatly reduces the unwanted "merging" of objects. An image
    comparison will give you a good idea of the concept I''m trying to illustrate.
    Here''s a sample of background subtraction without shadow detection:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundSubtractor` 类的另一个基本（而且坦白说，相当惊人）的特性是计算阴影的能力。这对于准确读取视频帧至关重要；通过检测阴影，你可以通过阈值化排除检测到的物体中的阴影区域，并专注于真实特征。这也大大减少了物体之间不想要的“合并”。图像比较将给你一个很好的概念，即我想说明的概念。以下是没有阴影检测的背景减除的示例：'
- en: '![Background subtractors – KNN, MOG2, and GMG](img/image00243.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![背景减除器 – KNN、MOG2 和 GMG](img/image00243.jpeg)'
- en: 'Here''s an example of shadow detection (with shadows thresholded):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个阴影检测（阴影已阈值化）的示例：
- en: '![Background subtractors – KNN, MOG2, and GMG](img/image00244.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![背景减除器 – KNN、MOG2 和 GMG](img/image00244.jpeg)'
- en: 'Note that shadow detection isn''t absolutely perfect, but it helps bring the
    object contours back to the object''s original shape. Let''s take a look at a
    reimplemented example of motion detection utilizing `BackgroundSubtractorKNN`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，阴影检测并不绝对完美，但它有助于将物体轮廓恢复到物体的原始形状。让我们看看使用 `BackgroundSubtractorKNN` 重新实现的运动检测示例：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a result of the accuracy of the subtractor, and its ability to detect shadows,
    we obtain a really precise motion detection, in which even objects that are next
    to each other don''t get merged into one detection, as shown in the following
    screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于减除器的准确性和检测阴影的能力，我们得到了非常精确的运动检测，即使相邻的物体也不会合并成一个检测，如下面的截图所示：
- en: '![Background subtractors – KNN, MOG2, and GMG](img/image00245.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![背景减除器 – KNN、MOG2 和 GMG](img/image00245.jpeg)'
- en: That's a remarkable result for fewer than 30 lines of code!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在少于30行代码的情况下取得的显著成果！
- en: 'The core of the entire program is the `apply()` method of the background subtractor;
    it computes a foreground mask, which can be used as a basis for the rest of the
    processing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序的核心是背景减除器的 `apply()` 方法；它计算前景掩码，这可以作为后续处理的基础：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once a foreground mask is obtained, we can apply a threshold: the foreground
    mask has white values for the foreground and gray for shadows; thus, in the thresholded
    image, all pixels that are not almost pure white (244-255) are binarized to 0
    instead of 1.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得前景掩码，我们可以应用一个阈值：前景掩码对前景使用白色值，对阴影使用灰色值；因此，在阈值图像中，所有几乎不是纯白色的像素（244-255）都被二值化为0而不是1。
- en: 'From there, we proceed with the same approach we adopted for the basic motion
    detection example: identifying objects, detecting contours, and drawing them on
    the original frame.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们继续使用与基本运动检测示例相同的方法：识别物体、检测轮廓，并在原始帧上绘制它们。
- en: Meanshift and CAMShift
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均值漂移和 CAMShift
- en: Background subtraction is a really effective technique, but not the only one
    available to track objects in a video. Meanshift is an algorithm that tracks objects
    by finding the maximum density of a discrete sample of a probability function
    (in our case, a region of interest in an image) and recalculating it at the next
    frame, which gives the algorithm an indication of the direction in which the object
    has moved.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 背景减除是一种非常有效的技术，但并不是跟踪视频中物体的唯一方法。Meanshift是一种通过寻找概率函数（在我们的情况下，是图像中的感兴趣区域）的离散样本的最大密度并重新计算它来跟踪物体的算法，在下一帧中，这为算法提供了物体移动方向的指示。
- en: This calculation gets repeated until the centroid matches the original one,
    or remains unaltered even after consecutive iterations of the calculation. This
    final matching is called **convergence**. For reference, the algorithm was first
    described in the paper, *The estimation of the gradient of a density function,
    with applications in pattern recognition*, *Fukunaga K. and Hoestetler L.*, *IEEE*,
    *1975*, which is available at [http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=1055330&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1055330](http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=1055330&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1055330)
    (note that this paper is not free for download).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算会重复进行，直到质心与原始质心匹配，或者即使经过连续的计算迭代后保持不变。这种最终的匹配称为**收敛**。为了参考，该算法最初在论文《密度函数梯度的估计及其在模式识别中的应用》中描述，作者为Fukunaga
    K.和Hoestetler L.，发表在IEEE，1975年，可在[http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=1055330&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1055330](http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=1055330&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1055330)（请注意，这篇论文不可免费下载）。
- en: 'Here''s a visual representation of this process:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个过程的视觉表示：
- en: '![Meanshift and CAMShift](img/image00246.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Meanshift和CAMShift](img/image00246.jpeg)'
- en: Aside from the theory, Meanshift is very useful when tracking a particular region
    of interest in a video, and this has a series of implications; for example, if
    you don't know a priori what the region you want to track is, you're going to
    have to manage this cleverly and develop programs that dynamically start tracking
    (and cease tracking) certain areas of the video, depending on arbitrary criteria.
    One example could be that you operate object detection with a trained SVM, and
    then start using Meanshift to track a detected object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了理论之外，Meanshift在跟踪视频中的特定感兴趣区域时非常有用，这有一系列的影响；例如，如果你事先不知道你想要跟踪的区域是什么，你将不得不巧妙地管理它，并开发出能够根据任意标准动态开始跟踪（并停止跟踪）视频的某些区域的程序。一个例子可能是你使用训练好的SVM进行对象检测，然后开始使用Meanshift来跟踪检测到的对象。
- en: Let's not make our life complicated from the very beginning, though; let's first
    get familiar with Meanshift, and then use it in more complex scenarios.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要一开始就使生活变得复杂；首先让我们熟悉一下Meanshift，然后再在更复杂的场景中使用它。
- en: 'We will start by simply marking a region of interest and keeping track of it,
    like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先简单地标记一个感兴趣的区域，并跟踪它，如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, I supplied the HSV values for tracking some shades of
    lilac, and here''s the result:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我提供了跟踪某些紫罗兰色调的HSV值，这里是结果：
- en: '![Meanshift and CAMShift](img/image00247.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Meanshift和CAMShift](img/image00247.jpeg)'
- en: If you ran the code on your machine, you'd notice how the Meanshift window actually
    looks for the specified color range; if it doesn't find it, you'll just see the
    window wobbling (it actually looks a bit impatient). If an object with the specified
    color range enters the window, the window will then start tracking it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的机器上运行了这段代码，你会注意到Meanshift窗口实际上是如何寻找指定的颜色范围的；如果找不到，你只会看到窗口在摇摆（它实际上看起来有点不耐烦）。如果具有指定颜色范围的物体进入窗口，窗口就会开始跟踪它。
- en: Let's examine the code so that we can fully understand how Meanshift performs
    this tracking operation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下代码，以便我们可以完全理解Meanshift是如何执行这个跟踪操作的。
- en: Color histograms
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色直方图
- en: 'Before showing the code for the preceding example, though, here is a not-so-brief
    digression on color histograms and the two very important built-in functions of
    OpenCV: `calcHist` and `calcBackProject`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示前一个示例的代码之前，这里有一个关于颜色直方图和OpenCV的两个非常重要的内置函数`calcHist`和`calcBackProject`的简短讨论。
- en: The function, `calcHist`, calculates color histograms of an image, so the next
    logical step is to explain the concept of color histograms. A color histogram
    is a representation of the color distribution of an image. On the *x* axis of
    the representation, we have color values, and on the *y* axis, we have the number
    of pixels corresponding to the color values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `calcHist` 计算图像的颜色直方图，因此下一个逻辑步骤是解释颜色直方图的概念。颜色直方图是图像颜色分布的表示。在表示的 *x* 轴上，我们有颜色值，而在
    *y* 轴上，我们有对应于颜色值的像素数量。
- en: 'Let''s look at a visual representation of this concept, hoping the adage, "a
    picture speaks a thousand words", will apply in this instance too:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个概念的可视表示，希望谚语“一图胜千言”也适用于这个例子：
- en: '![Color histograms](img/image00248.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![颜色直方图](img/image00248.jpeg)'
- en: The picture shows a representation of a color histogram with one column per
    value from 0 to 180 (note that OpenCV uses H values 0-180\. Other systems may
    use 0-360 or 0-255).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图片展示了颜色直方图的表示，每列代表从 0 到 180 的一个值（请注意，OpenCV 使用 H 值 0-180。其他系统可能使用 0-360 或 0-255）。
    |
- en: Aside from Meanshift, color histograms are used for a number of different and
    useful image and video processing operations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Meanshift 之外，颜色直方图还用于许多不同且有用的图像和视频处理操作。
- en: The calcHist function
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: calcHist 函数
- en: 'The `calcHist()` function in OpenCV has the following Python signature:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 中的 `calcHist()` 函数具有以下 Python 签名：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The description of the parameters (as taken from the official OpenCV documentation)
    are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的描述（如从官方 OpenCV 文档中获取）如下：
- en: '| Parameter | Description |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `images` | This parameter is the source arrays. They all should have the
    same depth, `CV_8U` or `CV_32F` , and the same size. Each of them can have an
    arbitrary number of channels. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `images` | 此参数是源数组。它们都应该具有相同的深度，`CV_8U` 或 `CV_32F`，并且具有相同的大小。每个数组都可以有任意数量的通道。
    |'
- en: '| `channels` | This parameter is the list of the `dims` channels used to compute
    the histogram. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `channels` | 此参数是用于计算直方图的 `dims` 通道列表。 |'
- en: '| `mask` | This parameter is the optional mask. If the matrix is not empty,
    it must be an 8-bit array of the same size as `images[i]`. The nonzero mask elements
    mark the array elements counted in the histogram. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `mask` | 此参数是可选的掩码。如果矩阵不为空，它必须是一个与 `images[i]` 相同大小的 8 位数组。非零掩码元素标记了在直方图中计数的数组元素。
    |'
- en: '| `histSize` | This parameter is the array of histogram sizes in each dimension.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `histSize` | 此参数是每个维度的直方图大小的数组。 |'
- en: '| `ranges` | This parameter is the array of the `dims` arrays of the histogram
    `bin` boundaries in each dimension. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `ranges` | 此参数是每个维度的直方图 `bin` 边界数组的 `dims` 数组。 |'
- en: '| `hist` | This parameter is the output histogram, which is a dense or sparse
    `dims` (dimensional) array. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `hist` | 此参数是输出直方图，它是一个密集或稀疏的 `dims`（维度）数组。 |'
- en: '| `accumulate` | This parameter is the accumulation flag. If it is set, the
    histogram is not cleared in the beginning when it is allocated. This feature enables
    you to compute a single histogram from several sets of arrays, or to update the
    histogram in time. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `accumulate` | 此参数是累积标志。如果设置此标志，则在分配时不会清除直方图。此功能使您能够从多个数组集中计算单个直方图，或者实时更新直方图。
    |'
- en: 'In our example, we calculate the histograms of the region of interest like
    so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们像这样计算感兴趣区域的直方图：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This can be interpreted as the calculation of color histograms for an array
    of images containing only the region of interest in the HSV space. In this region,
    we compute only the image values corresponding to the mask values not equal to
    0, with `18` histogram columns, and with each histogram having `0` as the lower
    boundary and `180` as the upper boundary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以解释为计算包含仅包含 HSV 空间中感兴趣区域的图像数组的颜色直方图。在这个区域，我们仅计算对应于掩码值不等于 0 的图像值，使用 `18` 个直方图列，并且每个直方图的边界为
    `0`（下限）和 `180`（上限）。
- en: This is rather convoluted to describe but, once you have familiarized yourself
    with the concept of a histogram, the pieces of the puzzle should click into place.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当复杂来描述，但一旦您熟悉了直方图的概念，拼图碎片应该就会对齐。
- en: The calcBackProject function
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: calcBackProject 函数
- en: The other function that covers a vital role in the Meanshift algorithm (but
    not only this) is `calcBackProject`, which is short for **histogram back** **projection**
    (calculation). A histogram back projection is so called because it takes a histogram
    and projects it back onto an image, with the result being the probability that
    each pixel will belong to the image that generated the histogram in the first
    place. Therefore, `calcBackProject` gives a probability estimation that a certain
    image is equal or similar to a model image (from which the original histogram
    was generated).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Meanshift算法（但不仅限于此）中扮演关键角色的另一个函数是`calcBackProject`，简称**直方图反向** **投影**（计算）。直方图反向投影之所以被称为如此，是因为它将直方图投影回图像上，结果是每个像素属于最初生成直方图的图像的概率。因此，`calcBackProject`给出了一个概率估计，即某个图像等于或类似于模型图像（从该图像生成了原始直方图）。
- en: Again, if you thought `calcHist` was a bit convoluted, `calcBackProject` is
    probably even more complex!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你认为`calcHist`有点复杂，那么`calcBackProject`可能更加复杂！
- en: In summary
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结来说
- en: The `calcHist` function extracts a color histogram from an image, giving a statistical
    representation of the colors in an image, and `calcBackProject` helps in calculating
    the probability of each pixel of an image belonging to the original image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`calcHist`函数从一个图像中提取颜色直方图，给出图像中颜色的统计表示，而`calcBackProject`有助于计算图像中每个像素属于原始图像的概率。'
- en: Back to the code
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到代码
- en: 'Let''s get back to our example. First our usual imports, and then we mark the
    initial region of interest:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。首先是我们常用的导入，然后我们标记初始感兴趣区域：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we extract and convert the ROI to HSV color space:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提取并将ROI转换为HSV颜色空间：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we create a mask to include all pixels of the ROI with HSV values between
    the lower and upper bounds:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个掩码，包括ROI中所有在上下限之间的HSV值的像素：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we calculate the histograms of the ROI:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算ROI的直方图：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After the histograms are calculated, the values are normalized to be included
    within the range 0-255.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图计算完成后，值被归一化，以便包含在0-255的范围内。
- en: 'Meanshift performs a number of iterations before reaching convergence; however,
    this convergence is not assured. So, OpenCV allows us to pass so-called termination
    criteria, which is a way to specify the behavior of Meanshift with regard to terminating
    the series of calculations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Meanshift在达到收敛之前会进行多次迭代；然而，这种收敛并不保证。因此，OpenCV允许我们传递所谓的终止条件，这是一种指定Meanshift在终止一系列计算方面的行为的方式：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this particular case, we're specifying a behavior that instructs Meanshift
    to stop calculating the centroid shift after ten iterations or if the centroid
    has moved at least 1 pixel. That first flag (`EPS` or `CRITERIA_COUNT`) indicates
    we're going to use either of the two criteria (count or "epsilon", meaning the
    minimum movement).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们指定了一个行为，指示Meanshift在十次迭代后停止计算质心偏移，或者如果质心至少移动了1个像素。第一个标志（`EPS`或`CRITERIA_COUNT`）表示我们将使用两个标准之一（计数或“epsilon”，即最小移动）。
- en: 'Now that we have a histogram calculated, and termination criteria for Meanshift,
    we can start our usual infinite loop, grab the current frame from the camera,
    and start processing it. The first thing we do is switch to HSV color space:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了直方图，并且有了Meanshift的终止条件，我们可以开始我们通常的无穷循环，从摄像头中获取当前帧，并开始处理它。我们首先做的事情是切换到HSV颜色空间：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have an HSV array, we can operate the long awaited histogram back
    projection:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了HSV数组，我们可以进行期待已久的直方图反向投影：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result of `calcBackProject` is a matrix. If you printed it to console,
    it looks more or less like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`calcBackProject`的结果是一个矩阵。如果你将它打印到控制台，看起来大致如下：'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each pixel is represented with its probability.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个像素都用其概率来表示。
- en: 'This matrix can the finally be passed into Meanshift, together with the track
    window and the termination criteria as outlined by the Python signature of `cv2.meanShift`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵最终可以传递给Meanshift，同时还有由`cv2.meanShift`的Python签名概述的跟踪窗口和终止条件：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So here it is:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是它：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we calculate the new coordinates of the window, draw a rectangle to
    display it in the frame, and then show it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算窗口的新坐标，画一个矩形来在帧中显示它，然后显示它：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it. You should by now have a good idea of color histograms, back projections,
    and Meanshift. However, there remains one issue to be resolved with the preceding
    program: the size of the window does not change with the size of the object in
    the frames being tracked.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。到现在为止，你应该对颜色直方图、反向投影和 Meanshift 有了一个很好的了解。然而，前一个程序仍然存在一个问题需要解决：窗口的大小不会随着被跟踪帧中对象的大小而改变。
- en: One of the authorities in computer vision and author of the seminal book, *Learning
    OpenCV*, *Gary Bradski*, *O'Reilly*, published a paper in 1988 to improve the
    accuracy of Meanshift, and described a new algorithm called **Continuously Adaptive
    Meanshift** (**CAMShift**), which is very similar to Meanshift but also adapts
    the size of the track window when Meanshift reaches convergence.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机视觉领域的权威人士，也是开创性书籍《Learning OpenCV》的作者 *Gary Bradski*，*O'Reilly*，于 1988 年发表了一篇论文，以提高
    Meanshift 的准确性，并描述了一种名为 **连续自适应均值漂移**（**CAMShift**）的新算法，该算法与 Meanshift 非常相似，但在
    Meanshift 达到收敛时也会自适应调整跟踪窗口的大小。
- en: CAMShift
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CAMShift
- en: While CAMShift adds complexity to Meanshift, the implementation of the the preceding
    program using CAMShift is surprisingly (or not?) similar to the Meanshift example,
    with the main difference being that, after the call to `CamShift`, the rectangle
    is drawn with a particular rotation that follows the rotation of the object being
    tracked.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CAMShift 为 Meanshift 增加了复杂性，但使用 CAMShift 实现的前一个程序与 Meanshift 示例惊人地（或不是吗？）相似，主要区别在于在调用
    `CamShift` 之后，矩形以特定的旋转方式绘制，该旋转方式跟随被跟踪对象的旋转。
- en: 'Here''s the code reimplemented with CAMShift:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 CAMShift 重新实现的代码：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The difference between the CAMShift code and the Meanshift one lies in these
    four lines:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CAMShift 代码与 Meanshift 代码之间的区别在于这四行：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The method signature of `CamShift` is identical to Meanshift.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`CamShift` 的方法签名与 Meanshift 相同。'
- en: The `boxPoints` function finds the vertices of a rotated rectangle, while the
    polylines function draws the lines of the rectangle on the frame.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`boxPoints` 函数找到旋转矩形的顶点，而 `polylines` 函数在帧上绘制矩形的线条。'
- en: 'By now, you should be familiar with the three approaches we adopted for tracking
    objects: basic motion detection, Meanshift, and CAMShift.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该熟悉我们采用的跟踪对象的三种方法：基本运动检测、Meanshift 和 CAMShift。
- en: 'Let''s now explore another technique: the Kalman filter.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索另一种技术：卡尔曼滤波器。
- en: The Kalman filter
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡尔曼滤波器
- en: The Kalman filter is an algorithm mainly (but not only) developed by Rudolf
    Kalman in the late 1950s, and has found practical application in many fields,
    particularly navigation systems for all sorts of vehicles from nuclear submarines
    to aircrafts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔曼滤波器是一种主要（但不仅限于）由鲁道夫·卡尔曼在 1950 年代后期开发的算法，并在许多领域找到了实际应用，尤其是在从核潜艇到飞机的各种车辆的导航系统中。
- en: The Kalman filter operates recursively on streams of noisy input data (which
    in computer vision is normally a video feed) to produce a statistically optimal
    estimate of the underlying system state (the position inside the video).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔曼滤波器对噪声输入数据流（在计算机视觉中通常是视频流）进行递归操作，以产生对底层系统状态（视频中的位置）的统计最优估计。
- en: Let's take a quick example to conceptualize the Kalman filter and translate
    the preceding (purposely broad and generic) definition into plainer English. Think
    of a small red ball on a table, and imagine you have a camera pointing at the
    scene. You identify the ball as the subject to be tracked, and flick it with your
    fingers. The ball will start rolling on the table, following the laws of motion
    we're familiar with.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速举一个例子来概念化卡尔曼滤波器，并将前一个（故意宽泛和通用）定义翻译成更简单的英语。想象一下桌子上一个小红球，并想象你有一个指向场景的相机。你确定球是跟踪的主题，并用手指弹它。球将在桌子上滚动，遵循我们熟悉的运动定律。
- en: 'If the ball is rolling at a speed of 1 meter per second (1 m/s) in a particular
    direction, you don''t need the Kalman filter to estimate where the ball will be
    in 1 second''s time: it will be 1 meter away. The Kalman filter applies these
    laws to predict an object''s position in the current video frame based on observations
    gathered in the previous frames. Naturally, the Kalman filter cannot know about
    a pencil on the table deflecting the course of the ball, but it can adjust for
    this kind of unforeseeable event.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球以每秒 1 米的速度（1 m/s）沿特定方向滚动，你不需要卡尔曼滤波器来估计 1 秒后球的位置：它将在 1 米之外。卡尔曼滤波器将这些定律应用于根据前一帧收集的观测数据来预测当前视频帧中对象的位置。自然地，卡尔曼滤波器无法知道桌子上铅笔如何改变球的轨迹，但它可以调整这种不可预见的事件。
- en: Predict and update
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测和更新
- en: 'From the preceding description, we gather that the Kalman filter algorithm
    is divided into two phases:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的描述中，我们了解到卡尔曼滤波器算法分为两个阶段：
- en: '**Predict**: In the first phase, the Kalman filter uses the covariance calculated
    up to the current point in time to estimate the object''s new position'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测**：在第一阶段，卡尔曼滤波器使用到当前时间点计算出的协方差来估计对象的新位置'
- en: '**Update**: In the second phase, it records the object''s position and adjusts
    the covariance for the next cycle of calculations'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：在第二阶段，它记录对象的位置并调整下一次计算周期的协方差'
- en: 'This adjustment is—in OpenCV terms—a correction, hence the API of the `KalmanFilter`
    class in the Python bindings of OpenCV is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCV术语中，这种调整是一种校正，因此OpenCV Python绑定的`KalmanFilter`类的API如下：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can deduce that, in our programs, we will call `predict()` to estimate the
    position of an object, and `correct()` to instruct the Kalman filter to adjust
    its calculations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以推断，在我们的程序中，我们将调用`predict()`来估计对象的位置，并调用`correct()`来指示卡尔曼滤波器调整其计算。
- en: An example
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 举例说明
- en: 'Ultimately, we will aim to use the Kalman filter in combination with CAMShift
    to obtain the highest degree of accuracy and performance. However, before we go
    into such levels of complexity, let''s analyze a simple example, specifically
    one that seems to be very common on the Web when it comes to the Kalman filter
    and OpenCV: mouse tracking.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将旨在将卡尔曼滤波器与CAMShift结合使用，以获得最高程度的准确性和性能。然而，在我们进入这种复杂程度之前，让我们分析一个简单的例子，特别是当涉及到卡尔曼滤波器和OpenCV时，在网络上似乎非常常见的例子：鼠标跟踪。
- en: 'In the following example, we will draw an empty frame and two lines: one corresponding
    to the actual movement of the mouse, and the other corresponding to the Kalman
    filter prediction. Here''s the code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将绘制一个空帧和两条线：一条对应于鼠标的实际移动，另一条对应于卡尔曼滤波器的预测。以下是代码：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As usual, let''s analyze it step by step. After the packages import, we create
    an empty frame, of size 800 x 800, and then initialize the arrays that will take
    the coordinates of the measurements and predictions of the mouse movements:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，让我们一步一步地分析。在包导入之后，我们创建一个800 x 800大小的空帧，然后初始化将存储鼠标移动测量和预测坐标的数组：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we declare the mouse move `Callback` function, which is going to handle
    the drawing of the tracking. The mechanism is quite simple; we store the last
    measurements and last prediction, correct the Kalman with the current measurement,
    calculate the Kalman prediction, and finally draw two lines, from the last measurement
    to the current and from the last prediction to the current:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明鼠标移动的`Callback`函数，该函数将处理跟踪的绘制。机制相当简单；我们存储最后测量和最后预测，使用当前测量来校正卡尔曼滤波器，计算卡尔曼预测，并最终绘制两条线，一条从最后测量到当前测量，另一条从最后预测到当前：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next step is to initialize the window and set the `Callback` function.
    OpenCV handles mouse events with the `setMouseCallback` function; specific events
    must be handled using the first parameter of the `Callback` (event) function that
    determines what kind of event has been triggered (click, move, and so on):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是初始化窗口并设置`Callback`函数。OpenCV使用`setMouseCallback`函数处理鼠标事件；必须使用`Callback`函数的第一个参数（事件）来处理特定事件，该参数确定已触发的事件类型（点击、移动等）：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we''re ready to create the Kalman filter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建卡尔曼滤波器：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Kalman filter class takes optional parameters in its constructor (from
    the OpenCV documentation):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔曼滤波器类在其构造函数中接受可选参数（来自OpenCV文档）：
- en: '`dynamParams`: This parameter states the dimensionality of the state'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamParams`: 此参数表示状态的维度'
- en: '`MeasureParams`: This parameter states the dimensionality of the measurement'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeasureParams`: 此参数表示测量的维度'
- en: '`ControlParams`: This parameter states the dimensionality of the control'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ControlParams`: 此参数表示控制的维度'
- en: '`vector.type`: This parameter states the type of the created matrices that
    should be `CV_32F` or `CV_64F`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vector.type`: 此参数表示创建的矩阵的类型，应为`CV_32F`或`CV_64F`'
- en: I found the preceding parameters (both for the constructor and the Kalman properties)
    to work very well.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现前面的参数（构造函数和卡尔曼属性）工作得非常好。
- en: 'From this point on, the program is straightforward; every mouse movement triggers
    a Kalman prediction, both the actual position of the mouse and the Kalman prediction
    are drawn in the frame, which is continuously displayed. If you move your mouse
    around, you''ll notice that, if you make a sudden turn at high speed, the prediction
    line will have a wider trajectory, which is consistent with the momentum of the
    mouse movement at the time. Here''s a sample result:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，程序很简单；每次鼠标移动都会触发一个Kalman预测，实际鼠标位置和Kalman预测都会在帧中绘制，并持续显示。如果你移动鼠标，你会注意到，如果你以高速突然转弯，预测线将有一个更宽的轨迹，这与当时鼠标移动的动量是一致的。以下是一个示例结果：
- en: '![An example](img/image00249.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例](img/image00249.jpeg)'
- en: A real-life example – tracking pedestrians
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个现实生活中的例子——跟踪行人
- en: Up to this point, we have familiarized ourselves with the concepts of motion
    detection, object detection, and object tracking, so I imagine you are anxious
    to put this newfound knowledge to good use in a real-life scenario. Let's do just
    that by examining the video feed of a surveillance camera and tracking pedestrians
    in it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经熟悉了运动检测、目标检测和目标跟踪的概念，所以我想你一定渴望将这些新获得的知识应用于现实场景。让我们通过检查监控摄像头的视频流并跟踪其中的行人来实现这一点。
- en: First of all, we need a sample video; if you download the OpenCV source, you
    will find the perfect video file for this purpose in `<opencv_dir>/samples/data/768x576.avi`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个样本视频；如果你下载了OpenCV源代码，你将在`<opencv_dir>/samples/data/768x576.avi`中找到用于此目的的完美视频文件。
- en: Now that we have the perfect asset to analyze, let's start building the application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了完美的分析资产，让我们开始构建应用。
- en: The application workflow
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用工作流程
- en: 'The application will adhere to the following logic:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用将遵循以下逻辑：
- en: Examine the first frame.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查第一帧。
- en: Examine the following frames and perform background subtraction to identify
    pedestrians in the scene at the start of the scene.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以下帧，并执行背景减法以识别场景开始时的行人。
- en: Establish an ROI per pedestrian, and use Kalman/CAMShift to track giving an
    ID to each pedestrian.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个行人建立一个ROI，并使用Kalman/CAMShift跟踪，为每个行人分配一个ID。
- en: Examine the next frames for new pedestrians entering the scene.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查下一帧中进入场景的新行人。
- en: If this were a real-world application, you would probably store pedestrian information
    to obtain information such as the average permanence of a pedestrian in the scene
    and most likely routes. However, this is all beyond the remit of this example
    application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个现实世界的应用，你可能需要存储行人信息以获取有关场景中行人平均停留时间和最可能路线等信息。然而，这些都超出了这个示例应用的范围。
- en: In a real-world application, you would make sure to identify new pedestrians
    entering the scene, but for now, we'll focus on tracking those objects that are
    in the scene at the start of the video, utilizing the CAMShift and Kalman filter
    algorithms.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，你需要确保识别进入场景的新行人，但到目前为止，我们将专注于跟踪视频开始时场景中的对象，利用CAMShift和Kalman滤波算法。
- en: You will find the code for this application in `chapter8/surveillance_demo/`
    of the code repository.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码仓库的`chapter8/surveillance_demo/`目录中找到这个应用的代码。
- en: A brief digression – functional versus object-oriented programming
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简短地偏离一下——函数式编程与面向对象编程
- en: Although most programmers are either familiar (or work on a constant basis)
    with **Object-oriented Programming** (**OOP**), I have found that, the more the
    years pass, the more I prefer **Functional Programming** (**FP**) solutions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数程序员要么熟悉（或经常工作于）**面向对象编程**（**OOP**），但我发现，随着年岁的增长，我越来越偏好**函数式编程**（**FP**）解决方案。
- en: For those not familiar with the terminology, FP is a programming paradigm adopted
    by many languages that treats programs as the evaluation of mathematical functions,
    allows functions to return functions, and permits functions as arguments in a
    function. The strength of FP does not only reside in what it can do, but also
    in what it can avoid, or aims at avoiding side-effects and changing states. If
    the topic of functional programming has sparked an interest, make sure to check
    out languages such as Haskell, Clojure, or ML.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉术语的人来说，FP是一种被许多语言采用的编程范式，它将程序视为数学函数的评估，允许函数返回函数，并允许函数作为函数的参数。FP的强大之处不仅在于它能做什么，还在于它能避免什么，或者旨在避免副作用和状态改变。如果函数式编程的话题激起了你的兴趣，确保查看Haskell、Clojure或ML等语言。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What is a side-effect in programming terms? You can define a side effect as
    any function that changes any value that does not depend on the function's input.
    Python, along with many other languages, is susceptible to causing side-effects
    because—much like, for example, JavaScript—it allows access to global variables
    (and sometimes this access to global variables can be accidental!).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，副作用是什么？你可以将副作用定义为任何改变任何不依赖于函数输入值的函数。Python，以及许多其他语言，容易产生副作用，因为——就像例如
    JavaScript 一样——它允许访问全局变量（有时这种访问全局变量的方式可能是意外的！）。
- en: Another major issue encountered with languages that are not purely functional
    is the fact that a function's result will change over time, depending on the state
    of the variables involved. If a function takes an object as an argument—for example—and
    the computation relies on the internal state of that object, the function will
    return different results according to the changes in the object's state. This
    is something that very typically happens in languages, such as C and C++, in functions
    where one or more of the arguments are references to objects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在非纯函数式语言中遇到的主要另一个问题是，函数的结果会随时间变化，这取决于涉及的变量的状态。如果一个函数接受一个对象作为参数——例如——并且计算依赖于该对象的内部状态，那么函数将根据对象状态的改变返回不同的结果。这在像
    C 和 C++ 这样的语言中很典型，在这些语言中，一个或多个参数是对象的引用。
- en: Why this digression? Because so far I have illustrated concepts using mostly
    functions; I did not shy away from accessing global variables where this was the
    simplest and most robust approach. However, the next program we will examine will
    contain OOP. So why do I choose to adopt OOP while advocating FP? Because OpenCV
    has quite an opinionated approach, which makes it hard to implement a program
    with a purely functional or object-oriented approach.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么离题？因为到目前为止，我主要使用函数来阐述概念；我没有回避在简单且最稳健的方法下访问全局变量。然而，我们将要检查的下一个程序将包含面向对象编程（OOP）。那么，为什么我选择在提倡函数式编程的同时采用
    OOP？因为 OpenCV 有一种相当有偏见的做法，这使得很难用纯函数式或面向对象的方法实现程序。
- en: For example, any drawing function, such as `cv2.rectangle` and `cv2.circle`,
    modifies the argument passed into it. This approach contravenes one of the cardinal
    rules of functional programming, which is to avoid side-effects and changing states.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何绘图函数，如 `cv2.rectangle` 和 `cv2.circle`，都会修改传入它的参数。这种方法违反了函数式编程的一条基本规则，即避免副作用和状态改变。
- en: 'Out of curiosity, you could—in Python—redeclare the API of these drawing functions
    in a way that is more FP-friendly. For example, you could rewrite `cv2.rectangle`
    like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 出于好奇，你可以在 Python 中以更符合函数式编程的方式重新声明这些绘图函数的 API。例如，你可以这样重写 `cv2.rectangle`：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This approach—while computationally more expensive due to the `copy()` operation—allows
    the explicit reassignment of a frame, like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法——由于 `copy()` 操作而计算成本更高——允许显式地重新分配一个帧，如下所示：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To conclude this digression, I will reiterate a belief very often mentioned
    in all programming forums and resources: there is no such thing as the best language
    or paradigm, only the best tool for the job in hand.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这次离题，我将重申在所有编程论坛和资源中经常提到的一个信念：没有所谓的最佳语言或范式，只有最适合当前任务的工具。
- en: So let's get back to our program and explore the implementation of a surveillance
    application, tracking moving objects in a video.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回到我们的程序，并探索监控应用程序的实现，该程序在视频中跟踪移动对象。
- en: The Pedestrian class
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Pedestrian` 类'
- en: The main rationale behind the creation of a `Pedestrian` class is the nature
    of the Kalman filter. The Kalman filter can predict the position of an object
    based on historical observations and correct the prediction based on the actual
    data, but it can only do that for one object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Pedestrian` 类的主要理由是卡尔曼滤波器的性质。卡尔曼滤波器可以根据历史观察预测对象的位置，并根据实际数据纠正预测，但它只能对单个对象这样做。
- en: As a consequence, we need one Kalman filter per object tracked.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要为每个跟踪的对象使用一个卡尔曼滤波器。
- en: So the `Pedestrian` class will act as a holder for a Kalman filter, a color
    histogram (calculated on the first detection of the object and used as a reference
    for the subsequent frames), and information about the region of interest, which
    will be used by the CAMShift algorithm (the `track_window` parameter).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Pedestrian` 类将作为卡尔曼滤波器、颜色直方图（在对象的首次检测时计算，并用作后续帧的参考）以及感兴趣区域信息的持有者，这些信息将由
    CAMShift 算法（`track_window` 参数）使用。
- en: Furthermore, we store the ID of each pedestrian for some fancy real-time info.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们存储每个行人的ID以获取一些花哨的实时信息。
- en: 'Let''s take a look at the `Pedestrian` class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Pedestrian`类：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At the core of the program lies the background subtractor object, which lets
    us identify regions of interest corresponding to moving objects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的核心是背景减除对象，它使我们能够识别与移动对象相对应的兴趣区域。
- en: When the program starts, we take each of these regions and instantiate a `Pedestrian`
    class, passing the ID (a simple counter), and the frame and track window coordinates
    (so we can extract the **Region of Interest** (**ROI**), and, from this, the HSV
    histogram of the ROI).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，我们取这些区域中的每一个并实例化一个`Pedestrian`类，传递ID（一个简单的计数器）和帧以及跟踪窗口坐标（这样我们可以提取**感兴趣区域**（**ROI**），以及从该ROI的HSV直方图）。
- en: 'The constructor function (`__init__` in Python) is more or less an aggregation
    of all the previous concepts: given an ROI, we calculate its histogram, set up
    a Kalman filter, and associate it to a property (`self.kalman`) of the object.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数（Python中的`__init__`）基本上是所有先前概念的聚合：给定一个ROI，我们计算其直方图，设置卡尔曼滤波器，并将其关联到对象的属性（`self.kalman`）。
- en: In the `update` method, we pass the current frame and convert it to HSV so that
    we can calculate the back projection of the pedestrian's HSV histogram.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们传递当前帧并将其转换为HSV，这样我们就可以计算行人的HSV直方图的反向投影。
- en: We then use either CAMShift or Meanshift (depending on the argument passed;
    Meanshift is the default if no arguments are passed) to track the movement of
    the pedestrian, and correct the Kalman filter for that pedestrian with the actual
    position.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用CAMShift或Meanshift（根据传递的参数；如果没有传递参数，则默认为Meanshift）来跟踪行人的移动，并使用实际位置来校正该行人的卡尔曼滤波器。
- en: We also draw both CAMShift/Meanshift (with a surrounding rectangle) and Kalman
    (with a dot), so you can observe Kalman and CAMShift/Meanshift go nearly hand
    in hand, except for sudden movements that cause Kalman to have to readjust.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还绘制了CAMShift/Meanshift（带有周围矩形）和卡尔曼（带有点），这样你可以观察到卡尔曼和CAMShift/Meanshift几乎手牵手，除了突然的移动会导致卡尔曼需要重新调整。
- en: Lastly, we print some pedestrian information on the top-left corner of the image.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在图像的左上角打印一些行人信息。
- en: The main program
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主程序
- en: Now that we have a `Pedestrian` class holding all specific information for each
    object, let's take a look at the main function in the program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含每个对象所有特定信息的`Pedestrian`类，让我们来看看程序中的主要函数。
- en: 'First, we load a video (it could be a webcam), and then we initialize a background
    subtractor, setting 20 frames as the frames affecting the background model:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载一个视频（可以是网络摄像头），然后初始化一个背景减除器，将20帧设置为影响背景模型：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We also create the main display window, and then set up a pedestrians dictionary
    and a `firstFrame` flag, which we''re going to use to allow a few frames for the
    background subtractor to build history, so it can better identify moving objects.
    To help with this, we also set up a frame counter:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了主显示窗口，并设置了一个行人字典和一个`firstFrame`标志，我们将使用这些来允许背景减除器建立一些历史记录，以便更好地识别移动对象。为此，我们还设置了一个帧计数器：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we start the loop. We read camera frames (or video frames) one by one:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始循环。我们逐个读取相机帧（或视频帧）：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We let `BackgroundSubtractorKNN` build the history for the background model,
    so we don''t actually process the first 20 frames; we only pass them into the
    subtractor:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让`BackgroundSubtractorKNN`为背景模型建立历史记录，所以我们实际上不处理前20帧；我们只将它们传递给减除器：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then we process the frame with the approach explained earlier in the chapter,
    by applying a process of dilation and erosion on the foreground mask so as to
    obtain easily identifiable blobs and their bounding boxes. These are obviously
    moving objects in the frame:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用本章前面解释的方法处理帧，通过在前景掩码上应用膨胀和腐蚀过程，以便获得易于识别的blob及其边界框。这些在帧中显然是移动对象：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the contours are identified, we instantiate one pedestrian per contour
    for the first frame only (note that I set a minimum area for the contour to further
    denoise our detection):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦识别出轮廓，我们只为第一帧实例化每个轮廓一个行人（注意，我设置了轮廓的最小面积以进一步去噪我们的检测）：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, for each pedestrian detected, we perform an `update` method passing the
    current frame, which is needed in its original color space, because the pedestrian
    objects are responsible for drawing their own information (text and Meanshift/CAMShift
    rectangles, and Kalman filter tracking):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个检测到的行人，我们执行一个 `update` 方法，传递当前帧，这是在原始颜色空间中需要的，因为行人对象负责绘制它们自己的信息（文本和Meanshift/CAMShift
    矩形，以及卡尔曼滤波跟踪）：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We set the `firstFrame` flag to `False`, so we don''t instantiate any more
    pedestrians; we just keep track of the ones we have:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `firstFrame` 标志设置为 `False`，这样我们就不创建更多的行人；我们只是跟踪我们已有的：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we show the result in the display window. The program can be exited
    by pressing the *Esc* key:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在显示窗口中展示结果。可以通过按下 *Esc* 键退出程序：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There you have it: CAMShift/Meanshift working in tandem with the Kalman filter
    to track moving objects. All being well, you should obtain a result similar to
    this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，CAMShift/Meanshift 与卡尔曼滤波协同工作以跟踪移动对象。如果一切顺利，你应该得到类似的结果：
- en: '![The main program](img/image00250.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![主程序](img/image00250.jpeg)'
- en: In this screenshot, the blue rectangle is the CAMShift detection and the green
    rectangle is the Kalman filter prediction with its center at the blue circle.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，蓝色矩形是 CAMShift 检测到的区域，绿色矩形是带有蓝色圆圈中心的卡尔曼滤波预测：
- en: Where do we go from here?
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们接下来该做什么？
- en: 'This program constitutes a basis for your application domain''s needs. There
    are many improvements that can be made building on the program above to suit an
    application''s additional requirements. Consider the following examples:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序构成了满足你应用领域需求的基础。可以在上述程序的基础上进行许多改进，以满足应用程序的额外要求。考虑以下示例：
- en: You could destroy a pedestrian object if Kalman predicts its position to be
    outside the frame
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果卡尔曼预测行人的位置在帧外，你可以销毁行人对象
- en: You could check whether each detected moving object is corresponding to existing
    pedestrian instances, and if not, create an instance for it
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以检查每个检测到的移动对象是否对应于现有的行人实例，如果不是，为其创建一个实例
- en: You could train an SVM and operate classification on each moving object to establish
    whether or not the moving object is of the nature you intend to track (for instance,
    a dog might enter the scene but your application requires to only track humans)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以训练一个 SVM 并对每个移动对象进行分类，以确定移动对象是否是你想要跟踪的性质（例如，一只狗可能进入场景，但你的应用程序只需要跟踪人类）
- en: Whatever your needs, hopefully this chapter will have provided you with the
    necessary knowledge to build applications that satisfy your requirements.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的需求如何，希望这一章能为你提供构建满足你要求的应用程序所需的知识。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the vast and complex topic of video analysis and tracking
    objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了视频分析和跟踪对象的广泛而复杂的话题。
- en: We learned about video background subtraction with a basic motion detection
    technique that calculates frame differences, and then moved to more complex and
    efficient tools such as `BackgroundSubtractor`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了使用基本运动检测技术进行视频背景减法，该技术通过计算帧差来计算，然后转向更复杂和高效的工具，如 `BackgroundSubtractor`。
- en: 'We then explored two very important video analysis algorithms: Meanshift and
    CAMShift. In the course of this, we talked in detail about color histograms and
    back projections. We also familiarized ourselves with the Kalman filter, and its
    usefulness in a computer vision context. Finally, we put all our knowledge together
    in a sample surveillance application, which tracks moving objects in a video.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了两个非常重要的视频分析算法：Meanshift 和 CAMShift。在这个过程中，我们详细讨论了颜色直方图和反向投影。我们还熟悉了卡尔曼滤波，及其在计算机视觉环境中的有用性。最后，我们将所有知识汇总到一个示例监控应用程序中，该应用程序跟踪视频中的移动对象。
- en: Now that our foundation in OpenCV and machine learning is solidifying, we are
    ready to tackle artificial neural networks and dive deeper into artificial intelligence
    with OpenCV and Python in the next chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 OpenCV 和机器学习的理解已经巩固，我们准备在下一章中处理人工神经网络，并更深入地使用 OpenCV 和 Python 探索人工智能。
