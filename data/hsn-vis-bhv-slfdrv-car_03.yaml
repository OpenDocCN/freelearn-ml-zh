- en: '*Chapter 2*: Understanding and Working with Signals'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：理解和处理信号'
- en: In this chapter, you will learn about several different signal types that you
    are likely to see when integrating the sensors that you have chosen for your project.
    You will also learn about the various signal architectures, and the chapter will
    help you choose the one that is most appropriate for your application. Each has
    its pitfalls, protocols, and prescriptions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，你将了解你可能在集成你为项目选择的各种传感器时遇到的不同信号类型。你还将了解各种信号架构，本章将帮助你选择最适合你应用的一个。每个都有其陷阱、协议和规定。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Signal types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号类型
- en: Analog verus digital
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟与数字
- en: Serial data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行数据
- en: CAN
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CAN
- en: UDP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP
- en: TCP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP
- en: By the end of this chapter, you will be able to apply your understanding of
    each protocol. You will be able to decode the serial data of various protocols
    by hand to aid in debugging signals. Most importantly, you will have the knowledge
    required to help you apply open source tools to do the heavy lifting for you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够应用你对每个协议的理解。你将能够手动解码各种协议的串行数据以帮助调试信号。最重要的是，你将拥有应用开源工具为你做繁重工作的知识。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To execute the instructions in this chapter, you need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章中的指令，你需要以下条件：
- en: Basic electrical circuit knowledge (about voltage, current, and resistance)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本电气电路知识（关于电压、电流和电阻）
- en: Binary, hexadecimal, and ASCII programming knowledge
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制、十六进制和 ASCII 编程知识
- en: Oscilloscope experience for probing sensor signals
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示波器探测传感器信号的经验
- en: 'The code for the chapter can be found at:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2)'
- en: 'The Code in Action videos for this chapter can be found here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码实战”视频可以在以下位置找到：
- en: '[https://bit.ly/2HpFqZa](https://bit.ly/2HpFqZa)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/2HpFqZa](https://bit.ly/2HpFqZa)'
- en: Understanding signal types
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解信号类型
- en: You will encounter many different signal types when integrating sensors, actuators,
    and controllers for a self-driving car. You will need an understanding of the
    strengths and weaknesses of each type to help you select the correct devices to
    integrate. The next few sections will cover all the details regarding each signal
    type and arm you with the knowledge to make the right choices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你集成自动驾驶汽车的传感器、执行器和控制器时，你会遇到许多不同的信号类型。你需要了解每种类型的优缺点，以帮助你选择正确的设备进行集成。接下来的几节将涵盖每种信号类型的所有细节，并为你提供做出正确选择的知识。
- en: 'Here are the basic signal types that you will encounter in robotics and self-driving
    cars:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你在机器人和自动驾驶汽车中会遇到的基本信号类型：
- en: Serial
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行
- en: Parallel
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行
- en: Analog
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟
- en: Digital
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Single-ended
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单端
- en: Differential
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差分
- en: In the next section, you will learn the difference between analog and digital
    signals.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习模拟信号和数字信号之间的区别。
- en: Analog versus digital
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟与数字
- en: The first thing to remember is that we live in an analog world. Nothing is instantaneous
    and everything is continuous. This is the reason why we can't teleport, sadly!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要记住的是，我们生活在一个模拟的世界。没有什么是一瞬间发生的，一切都是连续的。这也是我们无法瞬间移动的原因，遗憾的是！
- en: 'Similarly, analog signals are continuous and everchanging; they don''t jump
    instantaneously but instead smoothly transition from one state to another. A prime
    example of an analog signal is the old **Amplitude Modulation** (**AM**) radio.
    You can see in the following figure how the smooth data signal is modulated onto
    a smooth carrier wave to create the smooth AM signal. Here, the pitch is represented
    by how quickly the amplitude is changing and the volume is represented by how
    great the amplitude is:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，模拟信号是连续且不断变化的；它们不会瞬间跳跃，而是平滑地从一种状态过渡到另一种状态。一个典型的模拟信号例子是古老的**调幅**（**AM**）收音机。你可以在下面的图中看到，平滑的数据信号是如何调制到平滑的载波上以创建平滑的
    AM 信号。在这里，音调由振幅变化的快慢表示，音量由振幅的大小表示：
- en: '![Figure 2.1 – Analog signal example](img/B16322_02_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 模拟信号示例](img/B16322_02_01.jpg)'
- en: Figure 2.1 – Analog signal example
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 模拟信号示例
- en: 'In contrast, a digital signal is one that is sampled at known points in time.
    When the signal is sampled, it is checked to see whether it is above or below
    a certain threshold, which will determine whether it is a logic `0` or `1`. You
    can see an example of this in the following figure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，数字信号是在已知的时间点采样的。当信号被采样时，它会检查是否高于或低于某个阈值，这将决定它是逻辑`0`还是`1`。你可以在下面的图中看到这个例子：
- en: '![Figure 2.2 – Digital signal example](img/B16322_02_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 数字信号示例](img/B16322_02_02.jpg)'
- en: Figure 2.2 – Digital signal example
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 数字信号示例
- en: Analog hides in the digital
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟隐藏在数字中
- en: Although we talk about digital as jumping from one state to another, it really
    isn't. It is just changing very quickly but in an analog fashion. We simply choose
    to sample it in the middle of a pulse. The world is always analog, but sometimes
    we interpret it digitally.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们谈论数字是从一种状态跳到另一种状态，但实际上并不是。它只是非常快速地变化，但以模拟的方式。我们只是选择在脉冲中间采样它。世界总是模拟的，但有时我们以数字的方式解释它。
- en: If you look carefully at the following figure, you see the analog nature that
    hides in the corners!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察下面的图，你会看到隐藏在角落中的模拟特性！
- en: '![Figure 2.3 – Digital signal oscilloscope – before and after signal has run](img/B16322_02_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 数字信号示波器 – 信号运行前后](img/B16322_02_03.jpg)'
- en: Figure 2.3 – Digital signal oscilloscope – before and after signal has run
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 数字信号示波器 – 信号运行前后
- en: Do you see it? Although this is supposed to be a sharp transition between voltages,
    you can see the rounding of what should be square corners. This is due to the
    fact that nothing in nature is instantaneous and everything transitions smoothly
    from one state to another.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了吗？尽管这应该是电压之间的尖锐过渡，但你可以看到本应是方形角落的圆润。这是因为自然界中没有什么是瞬间的，一切都是从一种状态平滑过渡到另一种状态。
- en: In the next section, you will learn the difference between serial and parallel
    data transfer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习串行和并行数据传输之间的区别。
- en: Serial versus parallel
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 串行与并行
- en: Serial data is probably the most ubiquitous type of data transfer. It is how
    we as humans are accustomed to communicating. You are doing it right now as you
    read this. Serial communication simply means that data is transmitted and received
    one unit at a time (as opposed to several units of data being transmitted in parallel).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 串行数据可能是最普遍的数据传输类型。这是我们人类习惯于沟通的方式。你现在就在这样做，当你阅读这段文字时。串行通信简单来说就是数据一次传输和接收一个单元（与并行传输多个数据单元相对）。
- en: In the case of reading this book, your eyes are processing each word by scanning
    each line of text from left to right, then proceeding back to the beginning of
    the next line and continuing. You are processing a serial stream of words that
    are used to communicate some thoughts and ideas. Conversely, imagine if you could
    read the book several lines at a time. This would be considered parallel data
    transfer and it would be awesome!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书的情况下，你的眼睛通过从左到右扫描每一行文本来逐字处理，然后回到下一行的开头并继续。你正在处理一个用于传达某些思想和观点的单词序列流。相反，想象一下如果你一次能读几行。这将被认为是并行数据传输，那将是非常棒的！
- en: The unit of data that is used in computing is the bit, which is a binary representation
    for on or off, more commonly 1 or 0.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中使用的单位是位，它是对开或关的二进制表示，更常见的是1或0。
- en: 'Parallel data transfer was popular in the early years of computing since it
    allowed the simultaneous transfer of bits across multiple (usually 8) wires, which
    greatly increased data transfer speeds. This speed comes at several costs. More
    wires mean more weight, cost, and noise. Since the multiple wires are usually
    next to each other, you get a lot of noise induced on adjacent wires, known as
    crosstalk. This noise leads to shorter distances of transmission. The following
    figure illustrates how 8 bits are transferred serially versus in parallel:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 并行数据传输在计算机的早期年份很受欢迎，因为它允许通过多个（通常是8个）电线同时传输位，这大大提高了数据传输速度。这种速度是以几个代价为代价的。更多的电线意味着更多的重量、成本和噪音。由于这些多根电线通常相邻，你会在相邻的电线中产生大量的噪声，这被称为串扰。这种噪声导致传输距离缩短。以下图示了8位是串行传输还是并行传输：
- en: '![Figure 2.4 – Serial versus parallel](img/B16322_02_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 串行与并行](img/B16322_02_04.jpg)'
- en: Figure 2.4 – Serial versus parallel
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 串行与并行
- en: Now you can see a single wire is dedicated to each bit. This was fine in early
    computing when 8 bits were being sent, but you can imagine how quickly this becomes
    unmanageable when you consider 32- and 64-bit data. Thankfully, once protocol
    speeds increased, it became clear that serial transfer was far cheaper and simpler
    to integrate. That is not to say that parallel data transfer doesn't still exist;
    it does in applications where speed is paramount.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到每根线都专门用于每个位。在早期计算中，当发送8位时，这没问题，但你可以想象，当考虑32位和64位数据时，这会变得多么难以管理。幸运的是，随着协议速度的提高，很明显串行传输要便宜得多，也更容易集成。这并不是说并行数据传输不存在；它确实存在于速度至关重要的应用中。
- en: There are several types of serial data protocols, such as UART, I2C, SPI, Ethernet,
    and CAN. You will get an introduction to each of them in the next few sections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的串行数据协议，如UART、I2C、SPI、以太网和CAN。在接下来的几节中，你将了解它们的介绍。
- en: Universal Asynchronous Receive and Transmit (UART)
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用异步接收和发送（UART）
- en: UART is a very common protocol, thanks to its simplicity and cost. Many low
    data rate applications will use it to transmit and receive data. A common application
    of UART that you will see in self-driving applications is time synchronization
    to GPS. A message from a GPS receiver containing all the position and time information
    will be sent to a lidar, camera, radar, or other sensor to synchronize them to
    **Coordinated Universal Time** (**UTC**).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: UART是一个非常常见的协议，得益于其简单性和成本效益。许多低数据速率的应用程序会使用它来传输和接收数据。在自动驾驶应用中，你将看到UART的一个常见应用是时间同步到GPS。一个包含所有位置和时间信息的GPS接收器消息将被发送到激光雷达、摄像头、雷达或其他传感器，以将它们同步到**协调世界时**（**UTC**）。
- en: Pardon me, I think your acronym is mixed up
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，我想你的缩写搞混了。
- en: The French and the English couldn't agree on the acronym, so rather than CUT
    in English or **TUC** (**Temps Universel Coordonné**) in French, they mixed it
    up for both to not favor either language. If I can't have it my way, neither can
    you! Voilà, UTC is born!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 法国人英语人无法就缩写达成一致，所以与其在英语中使用CUT或法语中使用**TUC**（**Temps Universel Coordonné**），他们决定两者都混用，以不偏袒任何一种语言。如果我不能按照我的方式来，你也不能！就这样，UTC诞生了！
- en: 'Okay, so what does UART look like? The first thing you need to understand is
    that the protocol is asynchronous, meaning that a clock signal (wire) is not needed.
    Instead, the two devices must each have pretty good internal clocks to keep time
    for themselves. Right, so no clock wire needed; but what wires do you need? You
    only need two wires: one to transmit and one to receive. As such, the two devices
    need to agree on some ground rules before they start the game:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么UART看起来是什么样子？首先你需要理解的是，该协议是异步的，这意味着不需要时钟信号（线）。相反，两个设备各自必须拥有相当好的内部时钟来为自己计时。对，所以不需要时钟线；但你需要什么线？你只需要两根线：一根用于传输，一根用于接收。因此，在开始游戏之前，两个设备需要就一些基本规则达成一致：
- en: '**Baud rate**: This sets the number of bits per second that will be exchanged
    between the devices. In other words, it is the duration of the bit count. Common
    baud rates are 9,600, 19,200, 38,400, 57,600, 115,200, 128,000, and 256,000.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**波特率**：这设置了设备之间每秒交换的位数。换句话说，它是位计数的时间长度。常见的波特率有9,600、19,200、38,400、57,600、115,200、128,000和256,000。'
- en: '**Data bits**: This sets the number of bits in a data frame for the payload
    (data).'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据位**：这设置了数据帧中用于有效载荷（数据）的位数。'
- en: '**Parity**: This sets whether you will have a parity bit in the packet. This
    can be used to verify the integrity of the message received. This is done by counting
    the number of 1s in the data frame and setting the parity bit to 0 for an even
    number of 1s or 1 for an odd number of 1s.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**奇偶校验位**：这决定了数据包中是否会有奇偶校验位。这可以用来验证接收到的消息的完整性。这是通过计算数据帧中1的数量来完成的，如果1的数量是偶数，则将奇偶校验位设置为0，如果是奇数，则设置为1。'
- en: '**Stop bits**: This sets the number of stop bits signifying the end of a packet.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**停止位**：这设置了表示数据包结束的停止位数。'
- en: '**Flow control**: This sets whether you will be using hardware flow control.
    This is not as common since it requires two additional wires for **Ready To Send**
    (**RTS**) and **Clear To Send** (**CTS**).'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**流量控制**：这设置了你是否会使用硬件流量控制。这并不常见，因为它需要额外的两根线用于**准备发送**（**RTS**）和**清除发送**（**CTS**）。'
- en: Great, we have the ground rules. Now let's see what a packet looks like and
    then decode one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经有了基本规则。现在让我们看看数据包的样子，然后再解码一个。
- en: 'The following figure illustrates the structure of a packet for a UART message.
    You can see we start with exactly one start bit (low), followed by 5 to 9 data
    bits, followed by the parity bit if one is in the rules, and finally the stop
    bit(s) (1 to 2, high). The idle state is often the high voltage state representing
    a `1` with the active state usually low, representing a `0`. This is a normal
    polarity. You can reverse the polarity if needed, as long as you lay the ground
    rules ahead of time:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了 UART 消息数据包的结构。你可以看到我们从一个精确的起始比特（低电平）开始，然后是 5 到 9 个数据比特，如果规则中有奇偶校验位，则跟随奇偶校验位，最后是停止比特（1
    到 2 个，高电平）。空闲状态通常是高电压状态，表示一个 `1`，而活动状态通常是低电平，表示一个 `0`。这是一个正常极性。如果需要，你可以反转极性，只要事先设定好规则：
- en: '![Figure 2.5 – UART packet structure](img/B16322_02_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – UART 数据包结构](img/B16322_02_05.jpg)'
- en: Figure 2.5 – UART packet structure
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – UART 数据包结构
- en: 'The following is an example signal trace showing how to decode the bits with
    eight data bits, no parity, and one stop bit. We begin in the idle (high) state,
    then the packet begins with a low voltage position. This signifies that the following
    eight bits are the data. Next, we see five counts of high voltage, signifying
    five 1 bits, followed by three counts of low voltage, signifying three 0 bits.
    You should know that UART messages are sent with the least significant bit first,
    meaning the lowest binary value or 20 position, followed by the 21 position, then
    the 22 position, and so on. So, if you reorder them into a human-readable format,
    your data message is 0 0 0 1 1 1 1 1; translated into decimal, that would be 31
    or 1F in hexadecimal. There is a great resource at [https://www.mathsisfun.com/binary-decimal-hexadecimal.html](https://www.mathsisfun.com/binary-decimal-hexadecimal.html)
    for different base number systems, such as binary, decimal, and hexadecimal. There
    is another handy resource for decoding ASCII characters from binary at [http://www.asciitable.com/](http://www.asciitable.com/):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例信号波形，展示了如何使用八个数据比特、无奇偶校验和一个停止比特来解码比特。我们从空闲（高电平）状态开始，然后数据包以低电压位开始。这意味着接下来的八个比特是数据。接下来，我们看到五个高电压计数，表示五个
    1 比特，然后是三个低电压计数，表示三个 0 比特。你应该知道 UART 消息是以最低有效位首先发送的，意味着最低的二进制值或 20 位，然后是 21 位，然后是
    22 位，依此类推。所以，如果你将它们重新排列成人类可读的格式，你的数据消息是 0 0 0 1 1 1 1 1；转换成十进制，那将是 31 或十六进制的 1F。有关不同基数系统（如二进制、十进制和十六进制）的丰富资源，请参阅
    [https://www.mathsisfun.com/binary-decimal-hexadecimal.html](https://www.mathsisfun.com/binary-decimal-hexadecimal.html)。还有另一个方便的资源，用于从二进制解码
    ASCII 字符 [http://www.asciitable.com/](http://www.asciitable.com/)：
- en: '![Figure 2.6 – UART example bits](img/B16322_02_06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – UART 示例比特](img/B16322_02_06.jpg)'
- en: Figure 2.6 – UART example bits
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – UART 示例比特
- en: Easter Egg
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋白质
- en: Take out your decoder ring. It's time to learn the meaning of life, the universe,
    and everything...
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 拿出你的解码环。现在是学习生命、宇宙和万物意义的时候了...
- en: '![](img/B16322_02_Art1.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16322_02_Art1.png)'
- en: Excellent, now you know how to decode UART serial messages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，现在你知道如何解码 UART 串行消息了。
- en: Okay, so you may ask, *UART is so simple, why would I use anything else?* Let's
    go over some pros and cons of UART.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以你可能想知道，*UART 如此简单，我为什么要使用其他任何东西呢？* 让我们来看看 UART 的优缺点。
- en: 'The pros are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 优点如下：
- en: Cheap
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便宜
- en: Full duplex (send and receive at the same time)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全双工（同时发送和接收）
- en: Asynchronous (no clock line)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步（没有时钟线）
- en: Simple, with only two wires between each device
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单，每个设备之间只有两根线
- en: Parity for error checking
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇偶校验用于错误检查
- en: Widely used
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛使用
- en: 'The cons are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: Maximum bits per frame of nine bits.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个数据包的最大比特数为九比特。
- en: Device clocks must be within 10% of each other.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备时钟必须在彼此的 10% 以内。
- en: It is slow by modern standards, with standard bit rates ranging from 9,600-230,400
    bits per second.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照现代标准，它的速度较慢，标准波特率从每秒 9,600 到 230,400 比特不等。
- en: Requires a direct connection between each device rather than a bus architecture.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在每个设备之间建立直接连接，而不是总线架构。
- en: Some overhead with start and stop bits, demanding complex hardware for transmitting
    and receiving.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始和停止比特有一些开销，需要复杂的硬件来发送和接收。
- en: 'If you would like to gain experience with UART and Python, the simplest device
    for you to test UART communication on, will be an Arduino. If you have one, great!
    You can then jump directly to the documentation on PySerial and start communicating
    with your Arduino. If you don''t have an Arduino, you can find an example emulator
    code for practicing in the book''s repository, in the `Chapter 2` folder:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过Python获得UART的经验，你可以测试UART通信的最简单设备是Arduino。如果你有，太好了！然后你可以直接跳转到PySerial的文档，开始与你的Arduino进行通信。如果你没有Arduino，你可以在本书的仓库中找到一个示例模拟器代码，在`第2章`文件夹中：
- en: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2](https://github.com/PacktPublishing/Hands-On-Vision-and-Behavior-for-Self-Driving-Cars/tree/master/Chapter2)'
- en: Next, you will learn about two different standards that use UART messages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将了解使用UART消息的两种不同标准。
- en: Differential versus single-ended
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 差分与单端
- en: UART signals can be transmitted in a few different ways. The two most common
    are **Recommended Standard 232** (**RS-232**) and **Recommended Standard 422**
    (**RS-422**).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: UART信号可以通过几种不同的方式传输。最常见的是**推荐标准232**（**RS-232**）和**推荐标准422**（**RS-422**）。
- en: 'RS-232 is a single-ended signal, meaning that its voltage is compared directly
    to the electrical ground of the system (0 V). The following figure depicts a single-ended
    signal:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: RS-232是一种单端信号，意味着它的电压直接与系统的电气地（0 V）比较。以下图显示了单端信号：
- en: '![Figure 2.7 – Single-ended line](img/B16322_02_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 单端线](img/B16322_02_07.jpg)'
- en: Figure 2.7 – Single-ended line
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 单端线
- en: 'In contrast, RS-422 is a differential signal, meaning the voltage is compared
    across the two wires independent of the electrical ground of the system:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，RS-422是一种差分信号，意味着电压是在系统电气地（地线）独立比较的：
- en: '![Figure 2.8 – Differential line](img/B16322_02_08.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 差分线](img/B16322_02_08.jpg)'
- en: Figure 2.8 – Differential line
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 差分线
- en: Now for storytime...
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是故事时间...
- en: 'Once upon a time, the signal was born, with one mission: to take messages from
    its senders to the far-off lands where receivers live. The world is full of goblins
    and ghosts that are conspiring against our hero signals. These goblins and ghosts
    trip and mangle our poor friend the signal. The longer the signal travels on its
    journey, the more these bad actors will sneak in and wreak havoc. Generally, on
    short sojourns, the signal is unaffected and passes through the enchanted forest
    relatively undisturbed. However, the longer the journey, the more the signal needs
    to find tricks, friends, and guardians to get to its receiver safely.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从前，信号诞生了，它有一个使命：将发送者的信息传递到接收者居住的遥远之地。世界上充满了鬼怪，它们正在密谋对付我们的英雄信号。这些鬼怪和幽灵绊倒并扭曲了我们可怜的朋友信号。信号在旅途中行进得越远，这些坏蛋就越能偷偷潜入并造成破坏。一般来说，在短途旅行中，信号不受影响，相对无干扰地穿过魔法森林。然而，旅程越长，信号就越需要找到技巧、朋友和守护者，才能安全地到达接收器。
- en: So, who are these ghosts and goblins? They are electromagnetic fields and induced
    currents. You see, any time a ghost electromagnetic field moves near the signal's
    path (wire), it spawns a goblin (current) on the path. This goblin in turn uses
    its magical powers to stretch and shrink the signal's arms until it arrives at
    its destination, where the receiver sees the signal's arms as shorter or longer
    than they should be.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些鬼怪和幽灵是谁呢？它们是电磁场和感应电流。你看，每当一个幽灵电磁场靠近信号的路径（电线）时，它就会在路径上产生一个鬼怪（电流）。这个鬼怪随后使用它的魔法力量拉伸和收缩信号的臂，直到它到达目的地，接收器看到的信号的臂比它们应有的要短或长。
- en: 'But have no fear – the tricks, friends, and guardians are here! The signal
    has a great little trick to thwart the ghosts and goblins, but first it must spawn
    a doppelganger: we''ll call it the langis (that''s *signal* backward). The langis
    and the signal twist around each other on their way to the receiver. This confuses
    the ghosts and causes them to spawn two equal but opposite goblins that unwittingly
    smash into each other and vanish before they can use their magical powers.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但不必害怕——技巧、朋友和守护者都在这里！信号有一个很好的小技巧来挫败鬼怪，但首先它必须产生一个双胞胎：我们可以称之为langis（这是*信号*的倒写）。langis和信号在前往接收器的路上相互缠绕。这使鬼怪困惑，导致它们产生两个相等但相反的鬼怪，它们无意中撞在一起并消失，在它们能够使用魔法力量之前。
- en: The other trick the langis and the signal have is that they promise to always
    hold hands and move together on their journey no matter what goblins strike them.
    So, when they arrive at their destination, the receiver just measures the distance
    between the langis and the signal to get the message!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是langis和信号都承诺无论遇到什么小妖精，他们都会始终手牵手一起旅行。所以，当他们到达目的地时，接收器只需测量langis和信号之间的距离来获取信息！
- en: 'Okay, so what does this fairy tale look like in real life? Rather than having
    only one transmit wire, you instead use two wires. You then set one wire to be
    your high voltage (V+) and the other to be your low voltage (V-). Now when comparing
    the signals on the receiver side, you measure the voltage difference between V+
    and V- to determine whether you have a high or low signal. The following figure
    shows a single-ended signal (1a) and a differential signal (1b):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么这个童话在现实生活中是什么样子呢？你不会只有一个传输线，而是使用两条线。然后你将一条线设置为高电压（V+），另一条线设置为低电压（V-）。现在当比较接收端的信号时，你测量V+和V-之间的电压差以确定你是否有高或低信号。以下图显示了单端信号（1a）和差分信号（1b）：
- en: '![Figure 2.9 – Single-ended versus differential signal](img/B16322_02_09.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 单端信号与差分信号](img/B16322_02_09.jpg)'
- en: Figure 2.9 – Single-ended versus differential signal
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 单端信号与差分信号
- en: 'This has the wonderful effect of having any induced noise affect both V+ and
    V- similarly, so that when you measure the difference between V+ and V-, it is
    unchanged from how it was when it was sent. The following figure illustrates what
    this looks like:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个美妙的效果，即任何感应噪声都会以相同的方式影响V+和V-，所以当你测量V+和V-之间的差异时，它不会改变它发送时的状态。以下图展示了这种情况：
- en: '![Figure 2.10 – Noise on a differential line](img/B16322_02_10.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 差分线的噪声](img/B16322_02_10.jpg)'
- en: Figure 2.10 – Noise on a differential line
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 差分线的噪声
- en: 'The other trick was to twist the two wires of a differential pair around each
    other. This has the effect of canceling any induced currents in the wires. The
    following illustration shows the difference between straight cables and twisted
    pair cable currents. You can see that at each twist, the wires switch sides, so
    the noise current is alternating at each twist, effectively canceling itself out:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是将差分对的两个线绕在一起。这会抵消线中任何感应电流。以下插图显示了直通电缆和绞合对电缆电流之间的差异。你可以看到，在每次绞合时，线会交换位置，因此噪声电流在每次绞合时交替，从而有效地相互抵消：
- en: '![Figure 2.11 – Noise cancellation on differential twisted pair cable](img/B16322_02_11.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 差分绞合对电缆的噪声消除](img/B16322_02_11.jpg)'
- en: Figure 2.11 – Noise cancellation on differential twisted pair cable
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 差分绞合对电缆的噪声消除
- en: So, what does this all mean for you when choosing between single-ended and differential?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当你选择单端和差分时，这一切对你意味着什么呢？
- en: 'Here is a comparison table to help:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个比较表以供参考：
- en: '![Table 2.1](img/B16322_Table_01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![表2.1](img/B16322_Table_01.jpg)'
- en: Table 2.1
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1
- en: In the next section, you will learn about another form of serial communication
    that speeds things up a bit, along with some other very handy benefits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解另一种形式的串行通信，它可以使事情加快一些，还有一些非常实用的好处。
- en: I2C
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I2C
- en: '**I2C**, or I2C, is short for **Inter-Integrated Circuit** and is another serial
    data transfer protocol with a few cool new features. More on those in a bit. I2C
    is commonly used to communicate between components on a single **Printed Circuit
    Board** (**PCB**). It boasts data rates of 100-400 kHz, which is generally supported,
    and the specification even has room for up to 5 MHz communication, although this
    is not commonly supported on many devices.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**I2C**，或称I2C，代表**互集成电路**，是另一种具有一些酷炫新特性的串行数据传输协议。更多关于这些内容稍后介绍。I2C通常用于在单个**印刷电路板**（**PCB**）上的组件之间进行通信。它声称数据传输速率为100-400
    kHz，这通常得到支持，规范甚至为高达5 MHz的通信留有空间，尽管这在许多设备上并不常见得到支持。'
- en: 'You may ask, "Why use I2C? UART is already very simple and easy." Well, I2C
    adds some very cool features that you don''t have with UART. Recall that UART
    requires two wires connected between each device, which means you need a connector
    for each device that you want to communicate with. This quickly spins an unmanageable
    web of wires when you want several devices interconnected. You also don''t have
    the concept of master or slave in UART, since devices talk directly to each other
    on separate Tx and Rx lines. You can see an example of a fully connected UART
    architecture in the following figure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“为什么使用 I2C？UART 已经非常简单和容易了。” 好吧，I2C 添加了一些非常酷的特性，这些特性在 UART 中是没有的。回想一下，UART
    需要在每个设备之间连接两根线，这意味着你需要为每个你想与之通信的设备准备一个连接器。当你想要连接多个设备时，这会迅速变成一个难以管理的线网。此外，在 UART
    中，也没有主从设备的概念，因为设备直接在各自的 Tx 和 Rx 线上相互交谈。以下图示将展示一个完全连接的 UART 架构的例子：
- en: '![Figure 2.12 – Fully connected UART network](img/B16322_02_12.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 完全连接的 UART 网络](img/B16322_02_12.jpg)'
- en: Figure 2.12 – Fully connected UART network
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 完全连接的 UART 网络
- en: 'I2C to the rescue! I2C also uses only two wires: a **Serial Clock Wire** (**SCL**)
    and a **Serial Data Wire** (**SDA**) – more on how these work later. It uses these
    two wires to set up a new architecture between devices, a bus. A bus is simply
    a set of shared wires that transmits a signal to all devices attached to them.
    The following illustration will help us understand this better:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 来拯救！I2C 也只使用两根线：一根**串行时钟线**（**SCL**）和一根**串行数据线**（**SDA**）——稍后我们将详细介绍这些是如何工作的。它使用这两根线来在设备之间设置一个新的架构，即总线。总线简单地说是一组共享的线，将信号传输到所有连接到它们的设备。以下插图将帮助我们更好地理解这一点：
- en: '![Figure 2.13 – I2C bus architecture](img/B16322_02_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – I2C 总线架构](img/B16322_02_13.jpg)'
- en: Figure 2.13 – I2C bus architecture
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – I2C 总线架构
- en: This allows multiple devices to talk to each other without requiring dedicated
    lines from each device to every other device it needs to talk with.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许多个设备之间相互交谈，而不需要每个设备到它需要与之交谈的每个其他设备的专用线路。
- en: 'You might be thinking, *How can everyone be talking on the same lines and understand
    anything?* The I2C protocol implements the concept of master and slave devices.
    A master controls the flow of communication by announcing to everyone, *Hey, listen
    up everyone, I am talking to RasPi1, please acknowledge you are there, then send
    me data!* The master then gives control to RasPi1, who quickly shouts, *I''m here
    and have understood the request! Here is the data you requested; please acknowledge
    you received it*. The master then says, *Got it!* Then the process starts over.
    The following figure is a timing diagram of an I2C exchange:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，*大家怎么能都在同一条线上说话并且理解任何东西呢？* I2C 协议实现了主从设备的概念。主设备通过向所有人宣布来控制通信流程，*嘿，大家注意了，我在和
    RasPi1 说话，请确认你在那里，然后发送数据给我！* 然后，主设备将控制权交给 RasPi1，它迅速喊道，*我在这里，已经理解了请求！这是你请求的数据；请确认你已收到*。然后主设备说，*收到了！*
    然后这个过程重新开始。以下是一个 I2C 交换的时序图：
- en: '![Figure 2.14 – I2C timing diagram](img/B16322_02_14.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – I2C 时序图](img/B16322_02_14.jpg)'
- en: Figure 2.14 – I2C timing diagram
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – I2C 时序图
- en: Let's walk through a communication sequence. The sequence begins with the master
    pulling the SDA line low followed by pulling the SCL line low. This signifies
    the start condition. The next series of 7-10 bits (depending on your settings)
    is the address of the slave that is being spoken to. The next bit, the R/W bit,
    instructs the slave to either write to (logical 0) or read from (logical 1) its
    memory register. The bit that follows the R/W is the acknowledge (ACK) bit. This
    is set by the slave that is being addressed if it heard, understood, acknowledged,
    and will respond to the request. The master will then continue generating pulses
    on the SCL line while either the slave or the master starts placing data on the
    eight data bits on the SDA.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个通信序列来了解一下。这个序列从主设备将 SDA 线拉低，然后是 SCL 线拉低开始。这标志着开始条件。接下来的 7-10 位（取决于你的设置）是正在交谈的从设备的地址。下一个位，R/W
    位，指示从设备要么写入（逻辑 0）要么从（逻辑 1）其内存寄存器读取。R/W 位之后的位是确认（ACK）位。如果被寻址的从设备听到了、理解了、确认了，并且将响应请求，那么它就会设置这个位。然后主设备将在
    SCL 线上继续生成脉冲，同时从设备或主设备开始将数据放置在 SDA 上的八个数据位上。
- en: Bigger bits first
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 大位在前
- en: Contrary to UART, bits are transmitted MSB first in I2C.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 UART 相反，I2C 中的位是先传输 MSB（最高有效位）。
- en: For example, if the R/W bit was set to 0, the slave would receive the data being
    placed on the SDA and write it to memory. Immediately following the eight data
    bits, the slave will pull the SDA line low for one clock count to acknowledge
    that it received the data, stored it, and is ready to give back control of the
    SDA line to the master. At this point, the master pulls the SDA back low. Finally,
    to stop the sequence, the master will release the SCL followed by the SDA.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果R/W位被设置为0，从设备将接收放置在SDA上的数据并将其写入内存。紧随八位数据之后，从设备将SDA线拉低一个时钟周期以确认它已接收数据、存储数据并准备好将SDA线的控制权交还给主设备。此时，主设备将SDA线拉低。最后，为了停止序列，主设备将释放SCL，然后是SDA。
- en: When so many devices can be talking on the bus at the same time, it is important
    to have some rules to ensure that there is no clashing. I2C achieves this by using
    an *open-drain* system, which simply means that any master or slave can only pull
    the line to ground. The idle states of the SCL and SDA are held in the high voltage
    state through pull-up resistors. This can be seen in *Figure 2.13* with the resistors
    connected to VDD. When a master or slave wants to send data, they pull the line
    to ground (or open the drain). This ensures that you will never have one device
    driving the line high while another is driving it low.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当这么多设备可以同时通过总线进行通信时，有一些规则来确保不会发生冲突是很重要的。I2C通过使用*开漏*系统来实现这一点，这仅仅意味着任何主设备或从设备都只能将线路拉到地。SCL和SDA的空闲状态通过上拉电阻保持在高电压状态。这可以在*图2.13*中看到，电阻连接到VDD。当主设备或从设备想要发送数据时，它们将线路拉到地（或打开漏极）。这确保了你永远不会有一个设备驱动线路高电平，而另一个设备驱动低电平。
- en: Another interesting feature of the I2C protocol is that not only can there be
    multiple slave devices on the bus, but there can also be multiple masters. Here,
    you'll ask, *But wait, you said the master controls the flow. How will we know
    who is in control?* The genius in this architecture is that every device is connected
    to the same lines (bus), so they can all see what is happening at any given time.
    So, if two masters are trying to control the bus at nearly the same time, the
    first one to pull the SDA line low wins! The other master backs off and becomes
    a temporary slave. There is a case when two masters pull low at the exact same
    time and it is unclear who has control. In this case, arbitration begins. The
    first master to release to high on the SDA loses arbitration and becomes a slave.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: I2C协议的另一个有趣特性是，总线不仅可以有多个从设备，还可以有多个主设备。在这里，你会问，“等等，你说主设备控制流量。我们将如何知道谁在控制？”这个架构的精髓在于每个设备都连接到相同的线路（总线），因此它们都可以在任何给定时间看到正在发生的事情。所以，如果有两个主设备几乎同时尝试控制总线，第一个将SDA线拉低的设备获胜！另一个主设备退让并成为临时从设备。有一种情况是两个主设备同时将SDA线拉低，此时不清楚谁有控制权。在这种情况下，将开始仲裁。第一个释放SDA线到高电平的主设备将失去仲裁权并成为从设备。
- en: Easter Egg
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 复活节彩蛋
- en: If a hen and a half lay an egg and a half in a day and a half, how many eggs
    will half a dozen hens lay in half a dozen days? Decode the following signal for
    the answer!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一只半的母鸡在一天半的时间里下了一只半的蛋，那么半打母鸡在半打天里会下多少蛋？解码以下信号以获取答案！
- en: '![](img/B16322_02_Art2.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16322_02_Art2.png)'
- en: Here is a summary of the benefits and disadvantages of I2C.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是I2C的优缺点总结。
- en: 'These are the benefits:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是优点：
- en: A multiple-master, multiple-slave architecture, up to 1,024 devices in 10-bit
    address mode
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多主多从架构，最多支持1,024个设备在10位地址模式下。
- en: Bus-based with only two wires (SCL and SDA) required
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于总线的，只需要两条线（SCL和SDA）
- en: Speeds of up to 5 MHz
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度高达5 MHz
- en: Inexpensive
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格低廉
- en: Message acknowledgment
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息确认
- en: 'These are the disadvantages:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是缺点：
- en: Half-duplex, cannot transmit and receive at the same time.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半双工，不能同时发送和接收。
- en: Overhead of start, stop, and acknowledge conditions reduces throughput.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始、停止和确认条件的开销降低了吞吐量。
- en: The pull-up resistors limit clock speed, eat up PCB space, and increase power
    dissipation.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉上电阻限制了时钟速度，消耗了PCB空间，并增加了功耗。
- en: Short maximum wire lengths (1 cm–2 m) dependent on capacitance, resistance,
    and speed.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短的最大线缆长度（1 cm–2 m）取决于电容、电阻和速度。
- en: You have learned a lot about I2C, which has armed you with even more knowledge
    about dealing with serial data. In the next section, you will learn about yet
    another serial communication protocol with a bit more spunk but traded for something
    else.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了很多关于I2C的知识，这使你拥有了更多关于处理串行数据的知识。在下一节中，你将学习另一种带有更多活力的串行通信协议，但为此牺牲了其他一些东西。
- en: SPI
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPI
- en: '**Serial Peripheral Interface** (**SPI**) is a serial transmission link used
    primarily in microcontrollers to link peripherals such as USB, memory, and onboard
    sensors. Its main advantage is its speed and the simplicity of is implementation.
    SPI is not commonly used for sensors that you will be using in your self-driving
    car applications, but it is worth knowing a bit about in case you come across
    it. It is a full-duplex link with four wires used: SCLK, MOSI, MISO, and SS. The
    following illustration will help as we talk through their functions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**串行外设接口**（**SPI**）是一种主要用于微控制器的串行传输链路，用于连接外围设备，如 USB、内存和板载传感器。它的主要优势是速度和实现的简单性。SPI
    不常用于你在自动驾驶汽车应用中使用的传感器，但如果你遇到它，了解一些相关信息是有价值的。它是一个全双工链路，使用四根线：SCLK、MOSI、MISO 和 SS。以下插图将有助于我们讨论它们的功能：'
- en: '![Figure 2.15 – SPI connection diagram](img/B16322_02_15.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – SPI 连接图](img/B16322_02_15.jpg)'
- en: Figure 2.15 – SPI connection diagram
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – SPI 连接图
- en: SPI is a synchronous serial link that uses a master clock signal (SCLK), much
    like what you learned about in I2C. The clock rate is typically in the region
    of 6-12.5 MHz, which is also its bit rate. The data is passed between devices
    on the **Master Out Slave In** (**MOSI**) and **Master In Slave Out** (**MISO**)
    lines. MOSI, MISO, and SCLK can be used as a bus architecture, much like I2C.
    The final wire is the **Slave Select** (**SS**) wire. This is pulled low to notify
    the slave connected to it that it should listen to the coming message.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 是一个同步串行链路，使用主时钟信号（SCLK），这与你在 I2C 中学到的类似。时钟速率通常在 6-12.5 MHz 之间，这也是它的比特率。数据在
    **主设备输出从设备输入**（**MOSI**）和 **主设备输入从设备输出**（**MISO**）线上传递。MOSI、MISO 和 SCLK 可以用作总线架构，就像
    I2C 一样。最后一根线是 **从机选择**（**SS**）线。这条线被拉低以通知连接到它的从机，它应该监听即将到来的消息。
- en: 'This contrasts with I2C, which sent the slave address the information about
    which slave to listen for. As you can see in *Figure 2.15*, a separate wire and
    pin must be dedicated to each slave that is added to the system (denoted by *SS1*,
    *SS2*, and *SS3* in the figure). The hardware used to implement SPI is quite simple
    and usually relies on shift-registers. *What is a shift-register?* you say. Well,
    this is a simple memory register that holds a certain number of bits, say, eight.
    Each time a new bit is brought in from one side, a bit from the other side is
    pushed out. The following figure illustrates how this works in SPI:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 I2C 相比，I2C 会发送从机地址以及要监听哪个从机的信息。正如你在 *图 2.15* 中可以看到的，必须为系统添加的每个从机分配一条单独的线和引脚（图中用
    *SS1*、*SS2* 和 *SS3* 表示）。用于实现 SPI 的硬件相当简单，通常依赖于移位寄存器。你可能会问：“什么是移位寄存器？” 好吧，这是一个简单的内存寄存器，可以存储一定数量的位，比如八位。每次从一侧引入一个新位时，另一侧就会推出一个位。以下图示说明了这在
    SPI 中的工作原理：
- en: '![Figure 2.16 – SPI shift register](img/B16322_02_16.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – SPI 移位寄存器](img/B16322_02_16.jpg)'
- en: Figure 2.16 – SPI shift register
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – SPI 移位寄存器
- en: 'SPI data transfer is very simple since there is only one master allowed on
    the bus. The following figure helps to illustrate how SCK, MOSI, MISO, and SS
    are used to conduct the transfer of data in full duplex:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于总线上只允许有一个主设备，SPI 数据传输非常简单。以下图示有助于说明如何使用 SCK、MOSI、MISO 和 SS 来进行全双工数据传输：
- en: '![Figure 2.17 – SPI timing diagram](img/B16322_02_17.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – SPI 时序图](img/B16322_02_17.jpg)'
- en: Figure 2.17 – SPI timing diagram
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – SPI 时序图
- en: The master pulls the SS line low, which lets the target slave know, *Hey, SS1,
    this message is for you, please be ready to receive.* Then the master sends clock
    pulses on the SCK line that tell the slave when they should sample the data coming
    on MOSI. If it has been predetermined that the slave should send something back,
    the master then follows with SCK pulses for when the slave should send data on
    the MISO line. Since there are two lines, MISO and MOSI, these two transactions
    can happen at the same time using shift-register format.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 主设备将 SS 线拉低，这样目标从机就会知道：“嘿，SS1，这条消息是给你的，请准备好接收。” 然后，主设备在 SCK 线上发送时钟脉冲，告诉从机何时应该采样
    MOSI 上传来的数据。如果已经预定从机需要发送一些信息，主设备随后会跟随 SCK 脉冲，告诉从机何时应该在 MISO 线上发送数据。由于有两条线，MISO
    和 MOSI，这两个事务可以使用移位寄存器格式同时发生。
- en: SPI is not standardized like UART or I2C in terms of protocol. Because of this,
    you will need to consult the interface control documents for the devices that
    you want to connect to determine the specific commands, register sizes, clock
    modes, and so on that are required to operate the device.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 在协议方面不像 UART 或 I2C 那样标准化。因此，你需要查阅你想要连接的设备的接口控制文档，以确定操作该设备所需的特定命令、寄存器大小、时钟模式等。
- en: You can see there is no overhead in SPI as there was in UART and I2C. There
    are no start bits, addresses, stop bits, acknowledge bits, or any other overhead.
    It is pure, sweet, high-speed data. On the other hand, there is a lot more programming
    and prearranged setup needed to communicate between two devices. SPI also can
    drive high and low on the data lines, allowing to slew faster from a `0` to a
    `1`, which leads to the faster transmission rate discussed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，与 UART 和 I2C 相比，SPI 中没有开销。没有起始位、地址、停止位、确认位或其他开销。它是纯粹、甜美、高速的数据。另一方面，在两个设备之间进行通信需要更多的编程和预先安排的设置。SPI
    还可以在数据线上驱动高低电平，允许更快地从 `0` 到 `1` 的转换，这导致了之前讨论的更快传输速率。
- en: So, let's summarize the pros and cons.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下优缺点。
- en: 'These are the pros:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是优点：
- en: Fast data rates of 6-12.5 MHz
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6-12.5 MHz 的快速数据速率
- en: Full-duplex communication
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全双工通信
- en: Simple shift-register hardware can be used
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用简单的移位寄存器硬件
- en: Multiple slaves
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个从设备
- en: Bus architecture
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总线架构
- en: 'These are the cons:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是缺点：
- en: Single master only
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个主设备
- en: Four wires needed, plus a slave select wire for each slave.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要 4 根线，每增加一个从设备还需要一个从设备选择线。
- en: Short transmission length dependent on speed, impedance, and capacitance with
    a max estimated at 3 m
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输长度短，取决于速度、阻抗和电容，最大估计为 3 米
- en: In the next section, we will discuss a very common protocol that is used in
    nearly every vehicle on the road! Start your engines!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一种在几乎所有道路上行驶的车辆中都使用的非常常见的协议！发动引擎吧！
- en: Framed-based serial protocols
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于帧的串行协议
- en: Up until now, we have been discussing protocols that have fairly small message
    sizes in the region of 8-10 bits. What if you want to send more? In the next few
    sections, you will learn about protocols that support larger message sizes and
    package them into frames or packets.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论那些在 8-10 位范围内的消息大小相对较小的协议。如果你想要发送更多的消息呢？在接下来的几节中，你将了解到支持更大消息大小并将它们打包成帧或数据包的协议。
- en: 'You will learn about the following protocols:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解到以下协议：
- en: CAN
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CAN
- en: 'Ethernet: UDP and TCP'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网：UDP 和 TCP
- en: Understanding CAN
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 CAN
- en: '**Controller Area Network** (**CAN**) is a message-based protocol that was
    developed, by Bosch, to reduce the number of wires connecting the ever-growing
    number of microcontrollers and **Electronic Control Units** (**ECUs**) in vehicles.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器局域网络** (**CAN**) 是一种基于消息的协议，由博世公司开发，旨在减少连接车辆中不断增长的微控制器和 **电子控制单元** (**ECUs**)
    所需的线缆数量。'
- en: It is a bus-based protocol with two wires acting as a differential pair, CAN-HI
    and CAN-LO. You learned about differential pairs in the *Single-ended versus differential*
    section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于总线的协议，由两根作为差分对的线组成，即 CAN-HI 和 CAN-LO。你在 *单端与差分* 部分学习了差分对。
- en: Ghost and goblins
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 幽灵和鬼怪
- en: Do you recall the trick we used to provide safe passage to the langis and the
    signal on their journey? There is a real *twist* to that story.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们用来为 langis 和信号提供安全通道的那个技巧吗？这个故事中有一个真正的 *转折*。
- en: 'CAN is a feature-packed protocol that is very robust, reliable, and rapid.
    Here are some of the features of the protocol:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: CAN 是一个功能丰富的协议，非常健壮、可靠且快速。以下是该协议的一些特性：
- en: Decentralized multi-master communication
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散式多主通信
- en: Prioritized messages
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级消息
- en: Bus arbitration
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总线仲裁
- en: Remote terminal request
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程终端请求
- en: Data integrity with cyclic redundancy checks
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环冗余校验的数据完整性
- en: Flexible expandable network
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活可扩展的网络
- en: Centralized diagnostics and configuration
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式诊断和配置
- en: EMI noise rejection through a twisted differential pair
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扭绞差分对抑制电磁干扰噪声
- en: 'The CAN bus architecture is devilishly simple and is illustrated in the following
    figure:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: CAN 总线架构非常简单，如下图所示：
- en: '![Figure 2.18 – CAN bus architecture](img/B16322_02_18.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – CAN 总线架构](img/B16322_02_18.jpg)'
- en: Figure 2.18 – CAN bus architecture
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – CAN 总线架构
- en: You can see that nodes may be added anywhere on the bus inside of the bus terminations,
    Rterm. A consideration when connecting a node is the unterminated stub length,
    which the standard recommends keeping below 0.3 m.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到节点可以添加在总线内部的任何位置，包括在总线终端Rterm内部。连接节点时需要考虑的是未终止的引线长度，标准建议将其保持在0.3米以下。
- en: 'Now let''s see how bits are transmitted on the CAN HI and CAN LO differential
    twisted pair lines. The figure that follows illustrates the dominant and recessive
    voltages of the CAN protocol:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看位是如何在CAN HI和CAN LO差分双绞线上传输的。以下图说明了CAN协议的主导和隐含电压：
- en: Zero to hero
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从零到英雄
- en: '`0` rules the bus with its dominant differential voltage rising up above the
    minimum threshold.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`0` 以其主导的差分电压上升至最小阈值以上来统治总线。'
- en: One and done
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一劳永逸
- en: '`1` sleeps on the bus with its recessive differential voltage, which lies below
    the minimum threshold.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`1` 以其隐含的差分电压在总线上休眠，该电压低于最小阈值。'
- en: '![Figure 2.19 – CAN dominant and recessive voltages](img/B16322_02_19.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19 – CAN主导和隐含电压](img/B16322_02_19.jpg)'
- en: Figure 2.19 – CAN dominant and recessive voltages
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 – CAN主导和隐含电压
- en: By EE JRW – ow[n work, CC BY-SA 4.0, https://commons.wikimedia.org/w/in](https://commons.wikimedia.org/w/index.php?curid=55237229)dex.php?curid=55237229
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过EE JRW – ow[n work, CC BY-SA 4.0, https://commons.wikimedia.org/w/in](https://commons.wikimedia.org/w/index.php?curid=55237229)dex.php?curid=55237229
- en: 'Now that you see how bits are placed on the bus, let''s look at the CAN frame
    structure. This will be useful if you find yourself debugging or reading CAN bus
    traffic. The following figure depicts the segments of a CAN frame:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了位是如何放置在总线上的，让我们来看看CAN帧结构。如果你发现自己正在调试或读取CAN总线流量，这将很有用。以下图显示了CAN帧的各个部分：
- en: '![Figure 2.20 – CAN message format](img/B16322_02_20.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20 – CAN消息格式](img/B16322_02_20.jpg)'
- en: Figure 2.20 – CAN message format
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 – CAN消息格式
- en: CAN frames begin with a `0`, which is the dominant differential voltage. This
    may sound a bit similar to what you learned in UART communication, which also
    started with a logical `0`. Much like in UART, the SOF bit in CAN is a transition
    from an idle state to an active one. Unlike UART, however, the active and dominant
    state is a high voltage state.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: CAN帧以`0`开始，这是主导的差分电压。这听起来可能有点类似于你在UART通信中学到的，UART也是以逻辑`0`开始的。与UART类似，CAN中的SOF位是从空闲状态到活动状态的转换。然而，与UART不同的是，活动状态和主导状态是高电压状态。
- en: Following the SOF bit is the arbitration field. This can be thought of as the
    ECU's functional address (for example, the steering module, oxygen sensor, lidar
    sensor, and so on).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在SOF位之后是仲裁字段。这可以被认为是ECU的功能地址（例如，转向模块、氧传感器、激光雷达传感器等）。
- en: Less is best
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 少即是多
- en: ECUs with a smaller address in the arbitration fields are considered higher
    priority in the CAN protocol. The smaller address will win the arbitration when
    two or more devices start transmitting at the same time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在仲裁字段中地址较小的ECU在CAN协议中被认为是优先级较高的。当两个或多个设备同时开始传输时，较小的地址将赢得仲裁。
- en: The next bit is the `1`, the recessive state.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个位是`1`，隐含状态。
- en: The next six bits are the **Data Length Code** (**DLC**) section of the frame,
    which says how long the upcoming data field will be. The data for a CAN message
    can be 0 to 8 bytes in length.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的六位是帧的**数据长度码**（**DLC**）部分，它说明了即将到来的数据字段将有多长。CAN消息的数据长度可以是0到8字节。
- en: Immediately following the DLC is the data, which can be 0-64 (0-8 bytes) bits
    in length.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着DLC的是数据，其长度可以是0-64位（0-8字节）。
- en: Bit order
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 位顺序
- en: CAN sends its information with the MSB first.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: CAN 以 MSB（最高有效位）优先发送其信息。
- en: Next is the **Cyclic Redundancy Check** (**CRC**) field, which is 15 bits long
    and is used for error checking the message. The sending ECU performs a checksum
    calculation on the data field and places this in the CRC field. Once the receiving
    ECU gets the frame, it runs the same checksum calculation on the data field and
    verifies that it matches the CRC field in the received frame. The CRC is immediately
    followed by the CRC delimiter field to give it separation from the ACK bit.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**循环冗余校验**（**CRC**）字段，长度为15位，用于检查消息中的错误。发送ECU对数据字段进行校验和计算，并将其放置在CRC字段中。一旦接收ECU接收到帧，它将在数据字段上运行相同的校验和计算，并验证它是否与接收帧中的CRC字段匹配。CRC字段紧随其后的是CRC定界符字段，以将其与ACK位分开。
- en: The `1` recessive so that any receiving ECU can acknowledge receipt of the error-free
    data during this bit interval. The ACK bit is followed by the ACK delimiter to
    allow for any timing difference that overruns the ACK bit.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`1`位是隐性的，这样任何接收ECU都可以在位间隔期间确认接收到无错误的数据。ACK位后面跟着ACK定界符，以允许任何超出ACK位的时序差异。'
- en: Finally, the `1` bits, which indicate – you guessed it – the end of the frame.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`1`位，表示 – 您猜对了 – 帧的结束。
- en: 'Okay, one more thing: there is an **Inter Frame Space** (**IFS**), which is
    defined by the CAN controller of the system.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，还有一件事：存在一个**帧间空间**（**IFS**），它由系统的CAN控制器定义。
- en: Sweet – that was long. Don't worry, though; CAN is a very well-supported protocol
    and there are plenty of software and hardware modules that you can find that will
    do the heavy lifting for you. You will likely only need to dust this knowledge
    off when things aren't working right and you pull out the old oscilloscope to
    probe the CAN bus and verify that messages are transmitting properly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这已经很长了。不过不用担心；CAN是一个非常受支持的协议，您可以找到大量的软件和硬件模块来为您做繁重的工作。您可能只有在事情不正常时才需要翻出老式的示波器来探测CAN总线并验证消息是否正确传输。
- en: Let's recap the pros and cons of the CAN bus protocol.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下CAN总线协议的优缺点。
- en: 'These are the pros:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是优点：
- en: Decentralized multi-master communication
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化多主通信
- en: Prioritized messages
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级消息
- en: Bus arbitration
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总线仲裁
- en: RTR
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTR
- en: Data integrity with CRCs
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CRC进行数据完整性
- en: Flexible, expandable network
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活、可扩展的网络
- en: Centralized diagnostics and configuration
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中式诊断和配置
- en: EMI noise rejection through a twisted differential pair
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过双绞差分对抑制EMI噪声
- en: Maximum cable length of 40 m
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大电缆长度为40米
- en: 'This is the only con, really:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上只有一个缺点：
- en: Careful attention to the wiring bus terminations and stub lengths is needed.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要仔细注意布线总线端子和跳线长度。
- en: In the next section, you will learn about the most ubiquitous networking protocols
    used in modern times, both in cars and at home.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解现代汽车和家庭中使用的最普遍的网络协议。
- en: Ethernet and internet protocols
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以太网和互联网协议
- en: 'Ethernet is a framework of protocols and layers that is used in modern networking
    in nearly every application you interact with today. Ethernet is in your home,
    the train you ride, the plane you fly in, and definitely in your self-driving
    car. It consists of both the physical and protocol standards for network-based
    communication. It all starts with the **Open Systems Interconnection** (**OSI**)
    model of the different layers. The following figure illustrates the seven layers
    of the OSI model and what each layer is tasked with:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网是一个由协议和层组成的框架，在现代网络中被用于几乎与您互动的每个应用中。以太网存在于您的家中，您乘坐的火车上，您乘坐的飞机上，当然也包括您的自动驾驶汽车中。它包括基于网络的通信的物理和协议标准。一切始于不同层的**开放系统互连**（**OSI**）模型。以下图示说明了OSI模型的七层及其每一层的任务：
- en: '![Figure 2.21 – The seven layers of the OSI model](img/B16322_02_21.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21 – OSI模型的七层](img/B16322_02_21.jpg)'
- en: Figure 2.21 – The seven layers of the OSI model
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – OSI模型的七层
- en: 'Each of these layers has its own protocol for processing data. It all starts
    with the raw data, or bits, at the application layer. The data gets processed
    at each layer to be passed onto the next layer. Each layer wraps the previous
    layer''s frame into a new frame, which is why the model shows the frames getting
    larger and larger. The following figure illustrates the protocols at each layer:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都有自己的协议来处理数据。一切始于应用层的原始数据或比特。数据在每一层被处理，以便传递到下一层。每一层将前一层的帧包装成一个新的帧，这就是为什么模型显示了帧越来越大。以下图示说明了每一层的协议：
- en: '![Figure 2.22 – Protocols of the OSI model](img/B16322_02_22.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图2.22 – OSI模型的协议](img/B16322_02_22.jpg)'
- en: Figure 2.22 – Protocols of the OSI model
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 – OSI模型的协议
- en: We could spend an entire book talking about the details of each layer and protocol.
    Instead, we will focus on two protocols (UDP and TCP) that you will encounter
    when working with sensors and actuators in a self-driving car.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花整整一本书的时间来讨论每一层和协议的细节。相反，我们将专注于您在自动驾驶汽车中与传感器和执行器一起工作时将遇到的两种协议（UDP和TCP）。
- en: Understanding UDP
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解UDP
- en: '**User Datagram Protocol** (**UDP**) is a very popular protocol for sensors
    such as lidars, cameras, and radars. It is a connection-less protocol. *Wait –
    if it''s connection-less, how is it sending data?* Connection-less, in this sense,
    just means that the protocol doesn''t verify that it can reach the destination
    before it sends data. UDP lives on the transport layer of the OSI model. You can
    see in the following figure that the transport layer is the first layer to add
    a header:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据报协议**（**UDP**）是激光雷达、摄像头和雷达等传感器非常流行的协议。它是一个无连接协议。*等等——如果它是无连接的，它是如何发送数据的？*
    在这个意义上，无连接只是意味着在发送数据之前，该协议不会验证它是否能够到达目的地。UDP存在于OSI模型的传输层。你可以在以下图中看到，传输层是第一个添加头部的一层：'
- en: '![Figure 2.23 – UDP on the transport layer](img/B16322_02_23.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图2.23 – 传输层上的UDP](img/B16322_02_23.jpg)'
- en: Figure 2.23 – UDP on the transport layer
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 – 传输层上的UDP
- en: If you were sending a gift to someone, what would you want them to know about
    the gift so that they could be confident that it was intended for them and was
    not swapped for someone else's gift? You might say something like, *Tenretni Olleh,
    I am sending you this luxurious pair of rainbow pajamas in size large and I hope
    they fit. Please try them on.* This is exactly what the UDP header's function
    is. It stores the source port, the destination port, the length of the data including
    the header, and finally a checksum. The checksum is simply a number that is created
    with an algorithm before the data is sent to ensure that when it is received,
    the data is intact and not corrupted. This is done by running the same algorithm
    on the received data and comparing the number generated to the checksum value.
    This is akin to sending a picture of the pajamas that were sent to Tenretni so
    they knew they received the correct gift.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要给某人送礼物，你希望他们知道关于礼物的哪些信息，以便他们可以确信礼物是给他们的，而不是被换成别人的礼物？你可能会说些像，“Tenretni Olleh，我正在给你发送一套大号奢华彩虹睡衣，希望它们合身。请试穿一下。”这正是UDP头部的作用。它存储源端口、目的端口、包括头部在内的数据长度，最后是一个校验和。校验和只是一个在发送数据之前用算法创建的数字，以确保当它被接收时，数据是完整的且未被损坏。这是通过在接收数据上运行相同的算法，并将生成的数字与校验和值进行比较来完成的。这就像给Tenretni发送所发送睡衣的图片，这样他们就知道他们收到了正确的礼物。
- en: 'The following figure illustrates the fields within a UDP header and the actual
    message itself:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了UDP头部内的字段以及实际的消息本身：
- en: '![Figure 2.24 – UDP header fields](img/B16322_02_24.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图2.24 – UDP头部字段](img/B16322_02_24.jpg)'
- en: Figure 2.24 – UDP header fields
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 – UDP头部字段
- en: Port, plugs, and sockets
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 端口、插头和插座
- en: A port in the Ethernet protocol can be thought of like a power socket in your
    wall. You plug different devices into the sockets, such as lamps and TVs. Each
    plug, once connected, serves a specific device power. Similarly, a port is where
    a digital socket is created for a specific device or protocol to send and/or receive
    data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在以太网协议中，一个端口可以类比为墙上的电源插座。你将不同的设备插入插座，例如灯具和电视。每个插座一旦连接，就为特定的设备提供电源。同样，端口是创建用于特定设备或协议发送和/或接收数据的一个数字插座。
- en: 'The UDP header is always 8 bytes (64 bits), while the data (message) can be
    up to 65,507 bytes in length. The following figure is a relevant example, to self-driving
    cars, of the data (message) field size of a UDP packet from a popular family of
    high-resolution lidar sensors:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: UDP头部始终是8字节（64位），而数据（消息）的长度可以达到65,507字节。以下图示是一个相关示例，展示了来自一个流行的超高分辨率激光雷达传感器系列的UDP数据包的数据（消息）字段大小：
- en: '![Figure 2.25 – Ouster lidar UDP data structure](img/B16322_02_25.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图2.25 – Ouster激光雷达UDP数据结构](img/B16322_02_25.jpg)'
- en: Figure 2.25 – Ouster lidar UDP data structure
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25 – Ouster激光雷达UDP数据结构
- en: You can see from this, if you carefully multiply all the bytes, that you get
    389 words * 4 bytes/word * 16 azimuths/packet = 24,896 bytes/packet. This is well
    within the data limit size of a UDP packet, 65,507 bytes. In order to send this
    data over UDP, what must the lidar sensor append to this data? You guessed it
    – there needs to be a UDP header with the 8 bytes of source, destination, data
    length, and checksum information.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里你可以看到，如果你仔细地将所有字节相乘，你会得到389个单词 * 4字节/单词 * 16个方位/数据包 = 24,896字节/数据包。这完全在UDP数据包的数据限制大小范围内，65,507字节。为了通过UDP发送这些数据，激光雷达传感器需要附加什么数据？你已经猜到了——需要有一个包含源、目的、数据长度和校验和信息的UDP头部。
- en: UDP is often used for streaming-type devices such as lidar sensors, cameras,
    and radars since it does not make sense to resend data if it is not received.
    Imagine you didn't receive a few azimuths in the lidar sensor example. Would it
    be useful to you to have that data resent to you? Probably not, since whatever
    the lasers bounced off is now in the past and likely in a different position.
    Another reason to use UDP for such devices is that due to the high data rates,
    it would slow things down tremendously to have to resend lost or corrupted data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: UDP通常用于流式设备，如激光雷达传感器、摄像头和雷达，因为如果数据没有收到，重新发送数据是没有意义的。想象一下，在激光雷达传感器示例中，你没有收到几个方位角。你会希望重新发送那些数据给你吗？可能不会，因为激光反射的任何东西现在都过去了，并且可能处于不同的位置。使用UDP的另一个原因是，由于数据速率高，如果需要重新发送丢失或损坏的数据，这将极大地减慢速度。
- en: In the next section, we will discuss a protocol that will address cases where
    you might want to ensure that there is a three-way handshake for each packet of
    data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个协议，该协议将解决你可能想要确保每个数据包都进行三次握手的情况。
- en: Understanding TCP
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解TCP
- en: If you were going to send a command to turn the steering wheel of your self-driving
    car, would you be okay if the command never made it, was wrong, or corrupted?
    Would you be okay if you didn't know whether the steering actuator received the
    command? Probably not!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算发送一个命令来转动自动驾驶汽车的转向盘，你会不会对命令从未到达、错误或损坏的情况感到满意？你会对不知道转向执行器是否收到命令的情况感到满意吗？可能不会！
- en: 'This is where **Transmission Control Protocol** (**TCP**) can serve you! TCP
    operates similarly to UDP...well, actually, it''s completely different. Unlike
    UDP, TCP is a connection-based protocol. This means that each time you want to
    send data, you need to do a three-way handshake. This is done through a process
    known as SYN-SYN/ACK-ACK. Let''s break that down to understand it better:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**传输控制协议**（**TCP**）能为你服务的地方！TCP的操作方式类似于UDP...实际上，它完全不同。与UDP不同，TCP是一种基于连接的协议。这意味着每次你想发送数据时，你都需要进行三次握手。这是通过一个称为SYN-SYN/ACK-ACK的过程来完成的。让我们将其分解以更好地理解：
- en: SYN – The client sends a SYN (synchronization) packet with a randomly selected
    initial sequence number (`x`), which is used to count the bytes that are being
    sent. It also sets the SYN bit flag to `1` (more on this later).
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN – 客户端发送一个带有随机选择的初始序列号（`x`）的SYN（同步）数据包，该序列号用于计算发送的字节数。它还将SYN位标志设置为`1`（稍后会有更多介绍）。
- en: 'SYN/ACK – The server receives the SYN packet:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN/ACK – 服务器接收到SYN数据包：
- en: It increments `x` by one. This becomes the acknowledgement (ACK) number (`x+1`),
    which is the number of the next byte it expects.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将`x`增加1。这成为确认（ACK）编号（`x+1`），这是它期望接收的下一个字节的编号。
- en: It then sends a SYN/ACK packet back to the client with the ACK number as well
    as the server's own randomly selected sequence number (`y`).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它向客户端发送一个带有ACK编号以及服务器自己随机选择的序列号（`y`）的SYN/ACK数据包。
- en: 'ACK – The client receives the SYN/ACK packet with the ACK number (`x+1`) and
    server sequence number (`y`):'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACK – 客户端接收到带有ACK编号（`x+1`）和服务器序列号（`y`）的SYN/ACK数据包：
- en: It increments the server's initial sequence number to `y+1`.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将服务器的初始序列号增加到`y+1`。
- en: It sends an ACK packet with the ACK number (`y+1`) and ACK bit flag set to `1`
    back to the server to establish the connection.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它向服务器发送一个带有ACK编号（`y+1`）和ACK位标志设置为`1`的ACK数据包以建立连接。
- en: 'The following diagram illustrates the connection sequence:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了连接序列：
- en: '![Figure 2.26 – TCP connection sequence diagram](img/B16322_02_26.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图2.26 – TCP连接序列图](img/B16322_02_26.jpg)'
- en: Figure 2.26 – TCP connection sequence diagram
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26 – TCP连接序列图
- en: Now the connection is established and data can begin to flow. Each packet that
    is sent will be followed by an ACK packet with the number of bytes received plus
    one, indicating that the packet was received intact and what byte number it expects
    next. The sequence number is incremented by one for SYN and SYN/ACK packets and
    by the number of bytes of payload received for ACK packets.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在连接已经建立，数据可以开始流动。每个发送的数据包都将跟随一个ACK数据包，其中包含接收到的字节数加1，表示数据包已完整接收，并指出它期望接收的下一个字节编号。对于SYN和SYN/ACK数据包，序列号增加1，对于ACK数据包，增加接收到的有效载荷字节数。
- en: 'You can already see that in order to do all this, the header is going to need
    more fields than with UDP. The following figure illustrates the fields of a TCP
    header:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到，为了完成所有这些，头部将需要比UDP更多的字段。以下图表说明了TCP头部的字段：
- en: '![Figure 2.27 – TCP header fields](img/B16322_02_27.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图2.27 – TCP头部字段](img/B16322_02_27.jpg)'
- en: Figure 2.27 – TCP header fields
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27 – TCP 头字段
- en: 'Let''s unpack each field and its purpose:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个字段及其用途进行解析：
- en: '**Source port**: This is the port the packet is sent from. This is usually
    a randomly assigned port number.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源端口**：这是数据包发送的端口。这通常是一个随机分配的端口号。'
- en: '`22`. A list of well-known ports can be found at this link: [https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`22`。可以在以下链接找到知名端口的列表：[https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)'
- en: '**Sequence number**: This is the number of the first byte being sent in the
    payload; or, for SYN and SYN/ACK packets, it is the randomly selected initial
    sequence number.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列号**：这是有效载荷中第一个发送的字节的编号；对于 SYN 和 SYN/ACK 数据包，它是随机选择的初始序列号。'
- en: '**Acknowledgment number**: This is the number of bytes that have been received
    plus one, indicating the next byte number expected.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确认号**：这是已接收的字节数加一，表示预期的下一个字节编号。'
- en: '**Data offset**: This is the length of the TCP header, that is, the offset
    before the payload.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据偏移**：这是 TCP 头的长度，即有效载荷之前的偏移量。'
- en: '**Reserved**: These are bits that are unused but reserved for future protocol
    improvements.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保留**：这些是未使用但为未来协议改进预留的位。'
- en: '`0` or `1`). This is used to mark a packet as urgent.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`0` 或 `1`)。这用于标记数据包为紧急。
- en: '`ACK` bit flag, which is set to `1` when a valid acknowledgment number is being
    sent.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACK` 位标志，当发送有效的确认号时设置为 `1`。'
- en: '`1` when the data should be pushed to the application immediately.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据应立即推送到应用程序时设置为 `1`。
- en: '`1` when the connection needs to be reset.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当连接需要重置时设置为 `1`。
- en: '`1` when the SYN-SYN/ACK connection establishment process is initiated. It
    indicates that there is a valid sequence number in the sequence number field.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当初始化 SYN-SYN/ACK 连接建立过程时设置为 `1`。它表示序列号字段中有一个有效的序列号。
- en: '`1` when the connection should be closed after all data is sent.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有数据发送后应关闭连接时设置为 `1`。
- en: '**Window**: This is the size of the buffer that the receiving end can accept
    before losing data.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗口**：这是接收端在丢失数据之前可以接受的缓冲区大小。'
- en: '`payload+header` that is used to verify that the data received is valid and
    unchanged.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`payload+header` 用于验证接收到的数据是否有效且未更改。'
- en: '`URG` bit flag is set to `1`.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URG` 位标志设置为 `1`。'
- en: TCP uses all this header information for the task of ensuring that all data
    is received, verified, and acknowledged. If data is ever missed, the last valid
    sequence number can be used to resend the data. Now you can send your steering
    commands over Ethernet with confidence, knowing that you won't go careening off
    a cliff!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 使用所有这些头部信息来确保所有数据都被接收、验证和确认。如果数据丢失，可以使用最后一个有效的序列号重新发送数据。现在您可以自信地通过以太网发送转向命令，知道您不会冲下悬崖！
- en: Cars use CAN, mostly...
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车主要使用 CAN...
- en: Although we used steering as an example for TCP here, you will typically find
    that vehicle control commands are sent using CAN bus over Ethernet bus from the
    factory. Increasingly, though, self-driving car creators are relying on Ethernet
    for its higher data throughput and security. There is talk of moving to Ethernet
    bus for factory vehicles in the future. Military aircraft have already started
    doing so!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里以转向为例说明了 TCP，但您通常会发现在工厂中，车辆控制命令是通过以太网总线从 CAN 总线发送的。然而，越来越多的自动驾驶汽车创造者正依赖以太网，因为它具有更高的数据吞吐量和安全性。未来，人们讨论将工厂车辆迁移到以太网总线。军用飞机已经开始了这样的行动！
- en: 'Okay – goodness, that was a lot to take in. Do not worry, though: now that
    you have seen this once and understand it, you can rely on open source tools to
    parse through this in the future. Where you will find this useful is when things
    start going wrong and you need to debug the traffic flow of your data.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧——天哪，这有很多东西要理解。不过，不用担心：现在您已经看了一次并理解了，您就可以依赖开源工具在将来解析这些信息了。您会发现这很有用，当事情开始出错并且您需要调试数据流时。
- en: Speaking of which, Wireshark is a fantastic tool for **sniffing** Ethernet packets
    on your network and seeing the flow of information for debugging and testing.
    You can find all the information you need on installation and use at [https://www.wireshark.org/](https://www.wireshark.org/).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这个，Wireshark 是一款用于在您的网络上**嗅探**以太网数据包并查看信息流以进行调试和测试的出色工具。您可以在 [https://www.wireshark.org/](https://www.wireshark.org/)
    找到有关安装和使用的所有信息。
- en: As you can see, TCP is a powerful protocol for connection-based, highly reliable,
    and secure data transfer. Now get out there and start using the Ethernet protocol
    with the open source tools listed at the end of this chapter!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，TCP 是一种强大的基于连接的、高度可靠且安全的协议。现在，出去开始使用本章末尾列出的开源工具使用以太网协议吧！
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations, you have completed your quest with your new friends, the langis
    and the signal! You have had quite an adventure! You battled ghosts and goblins
    in the form of electromagnetic waves and induced currents. You learned so much
    along the way about serial versus parallel data transfer; digital versus analog
    signals; and protocols such as UART, I2C, SPI, CAN, UDP, and TCP and their secret
    decoder rings! You are now armed with the knowledge you will need when integrating
    sensors and actuators into your real self-driving car.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经和你的新朋友——langis和信号一起完成了你的任务！你经历了一段相当刺激的冒险！你与以电磁波和感应电流形式出现的鬼怪战斗。在旅途中，你学到了很多关于串行与并行数据传输；数字与模拟信号；以及UART、I2C、SPI、CAN、UDP和TCP等协议及其秘密解码环的知识！你现在拥有了将传感器和执行器集成到你的真实自动驾驶汽车中所需的知识。
- en: In the next chapter, you will learn how to use OpenCV to detect lanes on the
    road, a vital skill to ensure the safe and legal operation of your self-driving
    car!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用 OpenCV 检测道路上的车道，这是确保你的自动驾驶汽车安全合法运行的重要技能！
- en: Questions
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'After reading this chapter, you should be able to answer the following questions:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你应该能够回答以下问题：
- en: How many wires does each protocol require and what are their names?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个协议需要多少根线，它们的名称是什么？
- en: What are two methods to reduce noise in a signal?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些方法可以减少信号中的噪声？
- en: What is the difference between serial and parallel data transmission?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 串行和并行数据传输有什么区别？
- en: Which protocols use a bus architecture?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些协议使用总线架构？
- en: Which protocols have a clock signal?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些协议包含时钟信号？
- en: What protocol is used widely to send GPS information to other sensors?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个协议被广泛用于将 GPS 信息发送到其他传感器？
- en: Further reading
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Texas Instruments Controller Area Network Physical Layer Requirements ([http://www.ti.com/lit/an/slla270/slla270.pdf?HQS=slla270-aaj&ts=1589256007656](http://www.ti.com/lit/an/slla270/slla270.pdf?HQS=slla270-aaj&ts=1589256007656))
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 德州仪器公司控制器局域网物理层要求（[http://www.ti.com/lit/an/slla270/slla270.pdf?HQS=slla270-aaj&ts=1589256007656](http://www.ti.com/lit/an/slla270/slla270.pdf?HQS=slla270-aaj&ts=1589256007656)）
- en: Texas Instruments Introduction to the Controller Area Network (CAN) ([http://www.ti.com/lit/an/sloa101b/sloa101b.pdf](http://www.ti.com/lit/an/sloa101b/sloa101b.pdf))
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 德州仪器公司关于控制器局域网（CAN）的介绍（[http://www.ti.com/lit/an/sloa101b/sloa101b.pdf](http://www.ti.com/lit/an/sloa101b/sloa101b.pdf)）
- en: Universal Asynchronous Receiver and Transmitter (UART) ([https://ieeexplore.ieee.org/document/7586376](https://ieeexplore.ieee.org/document/7586376))
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用异步接收器/发送器（UART）([https://ieeexplore.ieee.org/document/7586376](https://ieeexplore.ieee.org/document/7586376)）
- en: Understanding the I2C Bus ([http://www.ti.com/lit/an/slva704/slva704.pdf?&ts=1589265769229](http://www.ti.com/lit/an/slva704/slva704.pdf?&ts=1589265769229))
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 I2C 总线（[http://www.ti.com/lit/an/slva704/slva704.pdf?&ts=1589265769229](http://www.ti.com/lit/an/slva704/slva704.pdf?&ts=1589265769229)）
- en: Open source protocol tools
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源协议工具
- en: 'You can also refer to the following resources to learn more about the tools
    for programming with the protocols covered:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以参考以下资源，了解更多关于使用这些协议进行编程的工具：
- en: '`PySerial` ([https://pypi.org/project/pyserial/](https://pypi.org/project/pyserial/))
    for UART (RS-232, RS-422, RS-485)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PySerial` ([https://pypi.org/project/pyserial/](https://pypi.org/project/pyserial/))
    用于 UART（RS-232、RS-422、RS-485）'
- en: '`python-periphery` ([https://python-periphery.readthedocs.io/en/latest/index.html](https://python-periphery.readthedocs.io/en/latest/index.html))
    for UART, I2C, SPI, and more'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python-periphery` ([https://python-periphery.readthedocs.io/en/latest/index.html](https://python-periphery.readthedocs.io/en/latest/index.html))
    用于 UART、I2C、SPI 等'
- en: '`smbus2` ([https://pypi.org/project/smbus2/](https://pypi.org/project/smbus2/))
    for I2C'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smbus2` ([https://pypi.org/project/smbus2/](https://pypi.org/project/smbus2/))
    用于 I2C'
- en: '`spidev` ([https://pypi.org/project/spidev/](https://pypi.org/project/spidev/))
    for SPI'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spidev` ([https://pypi.org/project/spidev/](https://pypi.org/project/spidev/))
    用于 SPI'
- en: '`python-can` ([https://pypi.org/project/python-can/](https://pypi.org/project/python-can/))
    for CAN'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python-can` ([https://pypi.org/project/python-can/](https://pypi.org/project/python-can/))
    用于 CAN'
- en: '`socket` ([https://docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html))
    for Ethernet TCP, UDP, and more'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket` ([https://docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html))
    用于以太网 TCP、UDP 等'
