- en: Chapter 4. Counting the Pixels with Histograms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 使用直方图计数像素
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下食谱：
- en: Computing an image histogram
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算图像直方图
- en: Applying look-up tables to modify the image's appearance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用查找表以修改图像的外观
- en: Equalizing the image histogram
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡图像直方图
- en: Backprojecting a histogram to detect specific image content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将直方图回投影以检测特定图像内容
- en: Using the mean shift algorithm to find an object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用均值漂移算法寻找物体
- en: Retrieving similar images using the histogram comparison
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用直方图比较检索相似图像
- en: Counting pixels with integral images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用积分图像计数像素
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: An image is composed of pixels of different values (colors). The distribution
    of pixel values across an image constitutes an important characteristic of that
    image. This chapter introduces the concept of image histograms. You will learn
    how to compute a histogram and how to use it to modify an image's appearance.
    Histograms can also be used to characterize an image's content and detect specific
    objects or textures in an image. Some of these techniques will be presented in
    this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由不同值的像素（颜色）组成。图像中像素值的分布构成了该图像的重要特征。本章介绍了图像直方图的概念。您将学习如何计算直方图以及如何使用它来修改图像的外观。直方图还可以用于表征图像的内容并检测图像中的特定对象或纹理。本章将介绍一些这些技术。
- en: Computing an image histogram
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算图像直方图
- en: An image is made of pixels that have different values. For example, in a 1-channel
    gray-level image, each pixel has an integer value between 0 (black) and 255 (white).
    Depending on the picture content, you will find different amounts of each gray
    shade laid out inside the image.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由具有不同值的像素组成。例如，在1通道灰度图像中，每个像素都有一个介于0（黑色）和255（白色）之间的整数值。根据图片内容，您将在图像内部找到不同数量的每种灰度色调。
- en: A **histogram** is a simple table that gives you the number of pixels that have
    a given value in an image (or sometimes, a set of images). The histogram of a
    gray-level image will, therefore, have 256 entries (or bins). Bin 0 gives you
    the number of pixels that have the value 0, bin 1 gives you the number of pixels
    that have the value 1, and so on. Obviously, if you sum all of the entries of
    a histogram, you should get the total number of pixels. Histograms can also be
    normalized so that the sum of the bins equals 1\. In this case, each bin gives
    you the percentage of pixels that have this specific value in the image.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**直方图**是一个简单的表格，它给出了图像中具有给定值的像素数量（有时，是一组图像）。因此，灰度图像的直方图将有256个条目（或桶）。桶0给出了值为0的像素数量，桶1给出了值为1的像素数量，依此类推。显然，如果您将直方图的条目总和，您应该得到像素总数。直方图也可以归一化，使得桶的总和等于1。在这种情况下，每个桶给出了图像中具有此特定值的像素的百分比。'
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first three recipes of this chapter will use the following image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前三个食谱将使用以下图像：
- en: '![Getting ready](img/image_04_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/image_04_001.jpg)'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Computing a histogram with OpenCV can be easily done by using the `cv::calcHist`
    function. This is a general function that can compute the histogram of multiple
    channel images of any pixel value type and range. Here, we will make this one
    simpler to use by specializing a class for the case of 1-channel gray-level images.
    For other types of image, you can always directly use the `cv::calcHist` function,
    which offers you all the flexibility required. The next section will explain each
    of its parameters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenCV计算直方图可以通过使用`cv::calcHist`函数轻松完成。这是一个通用函数，可以计算任何像素值类型和范围的多个通道图像的直方图。在这里，我们将通过为1通道灰度图像的情况专门化一个类来简化其使用。对于其他类型的图像，您始终可以直接使用`cv::calcHist`函数，它提供了您所需的所有灵活性。下一节将解释其每个参数。
- en: 'For now, the initialization of our specialized class looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们专门化类的初始化如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the defined member variables, computing a gray-level histogram can then
    be accomplished using the following method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义的成员变量，可以通过以下方法计算灰度级直方图：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, your program simply needs to open an image, create a `Histogram1D` instance,
    and call the `getHistogram` method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的程序只需打开一个图像，创建一个`Histogram1D`实例，并调用`getHistogram`方法：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `histo` object here is a simple one-dimensional array with `256` entries.
    Therefore, you can read each bin by simply looping over this array:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`histo`对象是一个简单的包含`256`个条目的单维数组。因此，您可以通过简单地遍历这个数组来读取每个桶：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the image shown at the start of this chapter, some of the displayed values
    would read as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章开头所示图像，一些显示的值如下：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is obviously difficult to extract any intuitive meaning from this sequence
    of values. For this reason, it is often convenient to display a histogram as a
    function, for example, using bar graphs. The following methods create such a graph:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从这一系列值中提取任何直观意义都是困难的。因此，通常方便以函数的形式显示直方图，例如使用条形图。以下方法可以创建这样的图形：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using the `getImageOfHistogram` method, you can obtain an image of the histogram
    function in the form of a bar graph that is drawn using lines:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getImageOfHistogram`方法，你可以获得直方图函数的图像，该图像以条形图的形式绘制，使用线条：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result is the following image:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是以下图像：
- en: '![How to do it...](img/image_04_002.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_04_002.jpg)'
- en: 'From the preceding histogram, it can be seen that the image exhibits a large
    peak of mid-gray level values and a good quantity of darker pixels. Coincidentally,
    these two groups mostly correspond to, respectively, the background and foreground
    of the image. This can be verified by thresholding the image at the transition
    between these two groups. A convenient OpenCV function can be used for this, namely
    the `cv::threshold` function, which was introduced in the previous chapter. Here,
    to create our binary image, we threshold the image at the minimum value just before
    it increases toward the high peak of the histogram (gray value `70`):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的直方图可以看出，图像显示出中灰度值的大峰值和大量较暗的像素。巧合的是，这两个组主要分别对应图像的背景和前景。这可以通过在这两个组之间的过渡处对图像进行阈值处理来验证。可以使用方便的OpenCV函数来完成此操作，即上一章中介绍的`cv::threshold`函数。在这里，为了创建我们的二值图像，我们在直方图向高峰值增加之前的最小值处对图像进行阈值处理（灰度值`70`）：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The resulting binary image clearly shows you the background/foreground segmentation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的二值图像清楚地显示了背景/前景分割：
- en: '![How to do it...](img/image_04_004.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_04_004.jpg)'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `cv::calcHist` function has many parameters to permit its use in many contexts,
    which are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::calcHist`函数有许多参数，允许它在许多上下文中使用，如下所示：'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Most of the time, your histogram will be one of a single 1-channel or 3-channel
    image. However, the function allows you to specify a multiple-channel image distributed
    over several images (that is, several `cv::Mat`). This is why an array of input
    images is the first parameter of this function. The sixth parameter, `dims`, specifies
    the dimensionality of the histogram, for example, 1 for a 1D histogram. Even if
    you are analyzing a multichannel image, you do not have to use all its `channels`
    in the computation of the histogram. The channels to be considered are listed
    in the `channel` array that has the specified dimensionality. In our class implementation,
    this single channel is channel `0` by default. The histogram itself is described
    by the number of bins in each dimension (this is the `histSize` array of integers)
    and by the minimum (inclusive) and maximum (exclusive) values in each dimension
    (given by the `ranges` array of 2-element arrays). It is also possible to define
    a non-uniform histogram (the second-last parameter would be set to `false` in
    that case), in which case, you need to specify the limits of each bin.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你的直方图将是一张单通道或三通道图像。然而，该函数允许你指定一个分布在多个图像（即多个`cv::Mat`）上的多通道图像。这就是为什么输入图像数组是该函数的第一个参数。第六个参数`dims`指定了直方图的维度，例如，对于一维直方图，为1。即使你正在分析多通道图像，你也不必在直方图的计算中使用其所有`channels`。要考虑的通道列在具有指定维度的`channel`数组中。在我们的类实现中，这个单通道默认为通道`0`。直方图本身由每个维度的bin数量（这是整数的`histSize`数组）以及每个维度的最小（包含）和最大（不包含）值（由2元素数组的`ranges`数组给出）描述。还可以定义非均匀直方图（在这种情况下，第二个最后一个参数将设置为`false`），在这种情况下，你需要指定每个bin的界限。
- en: As with many OpenCV functions, a mask can be specified, indicating which pixels
    you want to include in the count (all pixels for which the mask value is `0` are
    then ignored). Two additional parameters can be specified, both of which are Boolean
    values. The first one indicates whether the histogram is uniform or not (`true`
    is the default). The second allows you to accumulate the result of several histogram
    computations. If this last parameter is `true`, then the pixel count of the image
    will be added to the current values found in the input histogram. This is useful
    when you want to compute the histogram of a group of images.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多 OpenCV 函数一样，可以指定一个掩码，表示你想要包含在计数中的像素（掩码值为 `0` 的所有像素将被忽略）。还可以指定两个额外的参数，它们都是布尔值。第一个参数指示直方图是否均匀（默认值为
    `true`）。第二个参数允许你累积多个直方图计算的结果。如果最后一个参数为 `true`，则图像的像素计数将添加到当前输入直方图中的值。当你想要计算一组图像的直方图时，这很有用。
- en: 'The resulting histogram is stored in a `cv::Mat` instance. Indeed, the `cv::Mat`
    class can be used to manipulate general N-dimensional matrices. Recall from [Chapter
    2](ch02.html "Chapter 2. Manipulating Pixels") , *Manipulating Pixels*, that this
    class has defined the `at` method for matrices of dimension 1, 2, and 3\. This
    is why we were able to write the following code when accessing each bin of the
    1D histogram in the `getHistogramImage` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果直方图存储在一个 `cv::Mat` 实例中。实际上，`cv::Mat` 类可以用来操作通用的 N 维矩阵。回想一下 [第 2 章](ch02.html
    "第 2 章。操作像素")，*操作像素*，这个类为 1、2 和 3 维矩阵定义了 `at` 方法。这就是为什么我们能够在 `getHistogramImage`
    方法中访问 1D 直方图的每个分箱时编写以下代码：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the values in the histogram are stored as `float` values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直方图中的值以 `float` 类型存储。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `Histogram1D` class presented in this recipe has simplified the `cv::calcHist`
    function by restricting it to a 1D histogram. This is useful for gray-level images,
    but what about color images?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中介绍的 `Histogram1D` 类通过将其限制为 1D 直方图简化了 `cv::calcHist` 函数。这对于灰度图像很有用，但对于彩色图像呢？
- en: Computing histograms of color images
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算彩色图像的直方图
- en: 'Using the same `cv::calcHist` function, we can compute histograms of multichannel
    images. For example, a class that computes histograms of color BGR images can
    be defined as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的 `cv::calcHist` 函数，我们可以计算多通道图像的直方图。例如，一个计算彩色 BGR 图像直方图的类可以定义如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this case, the histogram will be three-dimensional. Therefore, we need to
    specify a range for each of the three dimensions. In the case of our BGR image,
    the three channels have the same `[0,255]` range. With the arguments thus prepared,
    the color histogram is computed by the following method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，直方图将是三维的。因此，我们需要为三个维度中的每一个指定一个范围。在我们的 BGR 图像中，三个通道具有相同的 `[0,255]` 范围。准备好这些参数后，通过以下方法计算颜色直方图：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A three-dimensional `cv::Mat` instance is returned. When a histogram of `256`
    bins is selected, this matrix has `(256)^3` elements, which represents more than
    16 million entries. In many applications, it would be better to reduce the number
    of bins in the computation of the histogram. It is also possible to use the `cv::SparseMat`
    data structure, which is designed to represent large sparse matrices (that is,
    matrices with very few non-zero elements) without consuming too much memory. The
    `cv::calcHist` function has a version that returns one such matrix. It is, therefore,
    simple to modify the previous method in order to use `cv::SparseMatrix`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个三维的 `cv::Mat` 实例。当选择 `256` 个分箱的直方图时，这个矩阵有 `(256)^3` 个元素，这代表超过 1600 万条记录。在许多应用中，减少直方图计算中的分箱数量会更好。也可以使用
    `cv::SparseMat` 数据结构，它被设计用来表示大型稀疏矩阵（即具有非常少非零元素的矩阵），而不会消耗太多内存。`cv::calcHist` 函数有一个版本返回这样一个矩阵。因此，为了使用
    `cv::SparseMatrix`，修改先前的方 法非常简单：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The histogram in this case is three-dimensional, which makes it more difficult
    to represent. A possible option to illustrate the color distribution in an image
    could be by showing the individual R, G, and B histograms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，直方图是三维的，这使得它更难以表示。一种可能的选项是通过显示单个 R、G 和 B 直方图来展示图像中的颜色分布。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Backprojecting a histogram to detect specific image content* recipe later
    in this chapter makes use of color histograms in order to detect specific image
    content
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章后面的 *将直方图反投影以检测特定图像内容* 菜单使用颜色直方图来检测特定图像内容
- en: Applying look-up tables to modify the image's appearance
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用查找表以修改图像的外观
- en: Image histograms capture the way a scene is rendered using the available pixel
    intensity values. By analyzing the distribution of the pixel values over an image,
    it is possible to use this information to modify and possibly improve an image.
    This recipe explains how we can use a simple mapping function, represented by
    a look-up table, to modify the pixel values of an image. As we will see, look-up
    tables are often produced from histogram distributions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图像直方图捕捉了场景使用可用的像素强度值的方式。通过分析图像上像素值的分布，可以使用这些信息来修改和可能改进图像。本菜谱解释了我们可以如何使用一个简单的映射函数，即查找表，来修改图像的像素值。正如我们将看到的，查找表通常由直方图分布生成。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A **look-up table** is a simple one-to-one (or many-to-one) function that defines
    how pixel values are transformed into new values. It is a 1D array with, in the
    case of regular gray-level images, `256` entries. Entry `i` of the table gives
    you the new intensity value of the corresponding gray level, which is expressed
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找表**是一个简单的单对单（或一对多）函数，它定义了像素值如何转换成新的值。它是一个1D数组，在常规灰度图像的情况下，有`256`个条目。表中的条目`i`给出了相应灰度的新的强度值，其表达式如下：'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `cv::LUT` function in OpenCV applies a look-up table to an image in order
    to produce a new image. Since look-up tables are often built from histograms,
    we have added this function to our `Histogram1D` class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中的`cv::LUT`函数将查找表应用于图像以产生一个新的图像。由于查找表通常由直方图构建，我们已将此函数添加到我们的`Histogram1D`类中：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'When a look-up table is applied to an image, it results in a new image in which
    the pixel intensity values have been modified as prescribed by the look-up table.
    A simple transformation could be defined as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当查找表应用于图像时，它会产生一个新的图像，其中像素强度值已根据查找表进行修改。一个简单的转换可以定义为以下：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This transformation simply inverts the pixel intensities, that is, intensity
    `0` becomes `255`, `1` becomes `254`, and so on up to `255` that becomes `0`.
    Applying such a look-up table to an image will produce the negative of the original
    image.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换简单地反转了像素强度，即强度`0`变为`255`，`1`变为`254`，以此类推，直到`255`变为`0`。将此类查找表应用于图像将产生原始图像的负片。
- en: 'With the image in the previous recipe, the result is seen here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个菜谱中的图像，结果如下所示：
- en: '![How it works...](img/image_04_005.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_04_005.jpg)'
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Look-up tables are useful for any application in which all pixel intensities
    are given a new intensity value. The transformation, however, has to be global;
    that is, all pixels of each intensity value must undergo the same transformation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查找表在所有像素强度都赋予新强度值的应用中非常有用。然而，这种转换必须是全局的；也就是说，每个强度值的所有像素都必须经历相同的转换。
- en: Stretching a histogram to improve the image contrast
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过拉伸直方图来提高图像对比度
- en: It is possible to improve an image's contrast by defining a look-up table that
    modifies the original image's histogram. For example, if you observe the histogram
    of the image shown in the first recipe of this chapter, you will notice that there
    are practically no pixels in the image with a value higher than `200`. We can,
    therefore, stretch the histogram in order to produce an image with an expanded
    contrast. To do so, the procedure uses a percentile threshold that defines the
    percentage of pixels that can be assigned the minimum intensity value (`0`) and
    the maximum intensity value (`255`) in the stretched image.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个修改原始图像直方图的查找表，可以改善图像的对比度。例如，如果你观察本章第一个菜谱中显示的图像的直方图，你会注意到实际上没有像素的值高于`200`。因此，我们可以拉伸直方图以产生具有扩展对比度的图像。为此，该程序使用一个百分位数阈值来定义在拉伸图像中可以分配最小强度值（`0`）和最大强度值（`255`）的像素百分比。
- en: 'We must, therefore, find the lowest (`imin`) and the highest (`imax`) intensity
    values so that we have the required number of pixels below or above the specified
    percentile. This is accomplished by the following loops (where `hist` is the computed
    1D histogram):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须找到最低的（`imin`）和最高的（`imax`）强度值，以确保我们有足够的像素数位于或高于指定的百分位数。这是通过以下循环（其中`hist`是计算出的1D直方图）实现的：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The intensity values can then be remapped so that the `imin` value is repositioned
    at intensity `0` and the `imax` value is assigned the value of `255`. The in-between
    `i` intensities are simply linearly remapped, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 强度值可以被重新映射，以便`imin`值重新定位到强度`0`，而`imax`值被分配值为`255`。中间的`i`强度值简单地线性重新映射，如下所示：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting stretched image with a percentile cut-off of 1% is then as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后具有1%百分位截断的拉伸图像如下所示：
- en: '![Stretching a histogram to improve the image contrast](img/image_04_006.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![拉伸直方图以改善图像对比度](img/image_04_006.jpg)'
- en: 'The expanded histogram then looks as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展后的直方图看起来如下所示：
- en: '![Stretching a histogram to improve the image contrast](img/image_04_007.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![拉伸直方图以改善图像对比度](img/image_04_007.jpg)'
- en: Applying a look-up table to color images
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将查找表应用于彩色图像
- en: 'In [Chapter 2](ch02.html "Chapter 2. Manipulating Pixels") , *Manipulating
    Pixels*, we defined a color-reduction function that modifies the BGR values of
    an image in order to reduce the number of possible colors. We did this by looping
    through the image''s pixels and applying the color-reduction function to each
    of them. In fact, it would be much more efficient to precompute all color reductions
    and then modify each pixel by using a look-up table. This is indeed very easy
    to accomplish from what we learned in this recipe. The new color-reduction function
    would then be written as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 操作像素")，*操作像素*中，我们定义了一个颜色减少函数，该函数通过修改图像的BGR值来减少可能的颜色数量。我们通过遍历图像的像素并对每个像素应用颜色减少函数来实现这一点。实际上，通过预计算所有颜色减少并使用查找表修改每个像素将更加高效。这正是我们从本菜谱中学到的东西。新的颜色减少函数将如下所示：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The color-reduction scheme is correctly applied here because when a one-dimensional
    look-up table is applied to a multichannel image, then the same table is individually
    applied to all channels. When a look-up table has more than one dimension, then
    it must be applied to an image with the same number of channels.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，颜色减少方案被正确应用，因为当一维查找表应用于多通道图像时，该表将单独应用于所有通道。当查找表具有多个维度时，则必须将其应用于具有相同通道数的图像。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe, *Equalizing the image histogram*, shows you another way to
    improve the image contrast
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个菜谱，*均衡化图像直方图*，展示了另一种提高图像对比度的方法
- en: Equalizing the image histogram
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 均衡化图像直方图
- en: In the previous recipe, we showed you how the contrast of an image can be improved
    by stretching a histogram so that it occupies the full range of the available
    intensity values. This strategy indeed constitutes an easy fix that can effectively
    improve the quality of an image. However, in many cases, the visual deficiency
    of an image is not that it uses a too-narrow range of intensities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们向您展示了如何通过拉伸直方图来改善图像对比度，使其占据所有可用强度值的完整范围。这种策略确实是一种简单的解决方案，可以有效地提高图像质量。然而，在许多情况下，图像的视觉缺陷并不是它使用了过于狭窄的强度范围。
- en: Rather, it is that some intensity values are used much more frequently than
    others. The histogram shown in the first recipe of this chapter is a good example
    of this phenomenon. The middle-gray intensities are indeed heavily represented,
    while darker and brighter pixel values are rather rare. One possible way to improve
    the quality of an image could therefore be to make equal use of all available
    pixel intensities. This is the idea behind the concept of **histogram equalization**,
    that is making the image histogram as flat as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，是因为某些强度值的使用频率远高于其他值。本章第一道菜谱中显示的直方图是这种现象的一个很好的例子。中间灰度强度确实有很高的代表性，而较暗和较亮的像素值则相对罕见。因此，提高图像质量的一种可能方法可能是使所有可用的像素强度得到均衡使用。这正是**直方图均衡化**概念背后的想法，即尽可能使图像直方图变得平坦。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'OpenCV offers an easy-to-use function that performs histogram equalization.
    It is called as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个易于使用的函数，用于执行直方图均衡化。它的调用方式如下：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After applying it on our image, the following image is obtained:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的图像上应用它之后，得到以下图像：
- en: '![How to do it...](img/image_04_008.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_04_008.jpg)'
- en: 'This equalized image has the following histogram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个均衡化图像具有以下直方图：
- en: '![How to do it...](img/image_04_009.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_04_009.jpg)'
- en: Of course, the histogram cannot be perfectly flat because the look-up table
    is a global many-to-one transformation. However, it can be seen that the general
    distribution of the histogram is now more uniform than the original one.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，直方图不可能完全平坦，因为查找表是一个全局的多对一转换。然而，可以看出，直方图的一般分布现在比原始的更均匀。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In a perfectly uniform histogram, all bins would have an equal number of pixels.
    This implies that 50 percent of the pixels should have an intensity lower than
    `128` (the median intensity value), 25 percent should have an intensity lower
    than `64`, and so on. This observation can be expressed using the rule that in
    a uniform histogram, `p%` of the pixels must have an intensity value lower than
    or equal to `255*p%`. The rule used to equalize a histogram is that the mapping
    of intensity `i` should be at the intensity that corresponds to the percentage
    of pixels that have an intensity value below `i`. Therefore, the required look-up
    table can be built from the following equation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完全均匀的直方图中，所有桶都将具有相同数量的像素。这意味着50%的像素应该具有低于 `128`（中值强度值）的强度，25%应该具有低于 `64`
    的强度，依此类推。这个观察结果可以用以下规则表示：在一个均匀的直方图中，`p%` 的像素必须具有低于或等于 `255*p%` 的强度值。均衡直方图的规则是，强度
    `i` 的映射应该对应于具有低于 `i` 的强度值的像素百分比。因此，所需的查找表可以从以下方程式构建：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `p[i]` is the number of pixels that have an intensity lower than or equal
    to `i`. The `p[i]` function is often referred to as a cumulative histogram, that
    is it is a histogram that contains the count of pixels lower than or equal to
    a given intensity instead of containing the count of pixels that have a specific
    intensity value. Recall that `image.total()` returns the number of pixels in an
    image, so `p[i]/image.total()` is a percentage of pixels.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`p[i]` 是强度低于或等于 `i` 的像素数量。`p[i]` 函数通常被称为累积直方图，也就是说，它是一个包含低于或等于给定强度的像素计数的直方图，而不是包含具有特定强度值的像素计数。回想一下，`image.total()`
    返回图像中的像素数量，所以 `p[i]/image.total()` 是像素的百分比。
- en: Generally, the histogram equalization greatly improves the image's appearance.
    However, depending on the visual content, the quality of the result can vary from
    image to image.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，直方图均衡化大大改善了图像的外观。然而，根据视觉内容的不同，结果的质量可能因图像而异。
- en: Backprojecting a histogram to detect specific image content
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用直方图反向投影检测特定图像内容
- en: A histogram is an important characteristic of an image's content. If you look
    at an image area that shows a particular texture or a particular object, then
    the histogram of this area can be seen as a function that gives the probability
    that a given pixel belongs to this specific texture or object. In this recipe,
    you will learn how the concept of **histogram backprojection** can be advantageously
    used to detect specific image content.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是图像内容的一个重要特征。如果你观察一个显示特定纹理或特定对象的图像区域，那么这个区域的直方图可以看作是一个函数，它给出了给定像素属于这个特定纹理或对象的概率。在这个菜谱中，你将学习如何有利地使用**直方图反向投影**的概念来检测特定的图像内容。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Suppose you have an image and you wish to detect specific content inside it
    (for example, in the following image, the clouds in the sky). The first thing
    to do is to select a region of interest that contains a sample of what you are
    looking for. This region is the one inside the rectangle drawn on the following
    test image:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个图像，并且你希望在图像中检测特定的内容（例如，在以下图像中，天空中的云）。首先要做的事情是选择一个包含你正在寻找的样本的兴趣区域。这个区域就是以下测试图像中画出的矩形内的区域：
- en: '![How to do it...](img/image_04_010.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_04_010.jpg)'
- en: 'In our program, the region of interest is obtained as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，感兴趣的区域是通过以下方式获得的：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You then extract the histogram of this ROI. This is easily accomplished using
    the `Histogram1D` class defined in the first recipe of this chapter, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你提取这个感兴趣区域（ROI）的直方图。这可以通过使用本章第一道菜谱中定义的 `Histogram1D` 类轻松完成，如下所示：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By normalizing this histogram, we obtain a function that gives us the probability
    that a pixel of a given intensity value belongs to the defined area, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过归一化这个直方图，我们得到一个函数，它给出了给定强度值的像素属于定义区域的概率，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Backprojecting a histogram consists of replacing each pixel value in an input
    image with its corresponding probability value read in the normalized histogram.
    An OpenCV function performs this task as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 反向投影直方图包括将输入图像中的每个像素值替换为其在归一化直方图中读取的对应概率值。OpenCV函数按以下方式执行此任务：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `result` is the following probability map. For better readability, we display
    the negative of the `result` image, with probability of belonging to the reference
    area ranging from bright (low probability) to dark (high probability):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`result` 是以下概率图。为了提高可读性，我们显示 `result` 图像的负值，属于参考区域的概率从亮（低概率）到暗（高概率）：'
- en: '![How to do it...](img/image_04_011.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_04_011.jpg)'
- en: 'If we apply a threshold on this image, we obtain the most probable cloud pixels:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这张图像应用阈值，我们就能获得最可能的云像素：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result is shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下截图所示：
- en: '![How to do it...](img/image_04_012.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_04_012.jpg)'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding result is disappointing because, in addition to the clouds, other
    areas have been wrongly detected as well. It is important to understand that the
    probability function has been extracted from a simple gray-level histogram. Many
    other pixels in the image share the same intensities as the cloud pixels, and
    pixels of the same intensity are replaced with the same probability value when
    backprojecting the histogram. One solution to improve the detection result would
    be to use the color information. However, in order to do this, we need to modify
    the call to `cv::calBackProject`. This will be explained in the *There's more...*
    section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结果令人失望，因为除了云层外，其他区域也被错误地检测到了。重要的是要理解，概率函数是从简单的灰度直方图中提取出来的。图像中许多其他像素与云像素具有相同的强度，并且在反向投影直方图时，相同强度的像素被替换为相同的概率值。为了提高检测结果，一个解决方案是使用颜色信息。然而，为了做到这一点，我们需要修改对
    `cv::calBackProject` 的调用。这将在 *还有更多...* 部分中解释。
- en: The `cv::calBackProject` function is similar to the `cv::calcHist` function.
    The values associated with a pixel refer to one bin of a (potentially multi-dimensional)
    histogram. But instead of incrementing the bin count, the `cv::calBackProject`
    function assigns to the corresponding pixel in the output backprojection image
    the value read in that bin. The first parameter of this function specifies the
    input images (most of the time, only one). You then need to list the channel numbers
    you wish to use. The histogram that is passed to the function is, this time, an
    input parameter; its dimension should match the one of the channel list arrays.
    As with `cv::calcHist`, the ranges parameter specifies the bin boundaries of the
    input histogram in the form of an array of float arrays, each specifying the range
    (minimum and maximum values) of each channel.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::calBackProject` 函数与 `cv::calcHist` 函数类似。与像素相关联的值指的是一个（可能的多维）直方图的某个bin。但与增加bin计数不同，`cv::calBackProject`
    函数将读取该bin中的值分配给输出反向投影图像中的相应像素。此函数的第一个参数指定输入图像（大多数情况下，只有一个）。然后你需要列出你希望使用的通道号。传递给函数的直方图这次是一个输入参数；其维度应与通道列表数组相匹配。与
    `cv::calcHist` 类似，范围参数指定输入直方图的bin边界，形式为一个float数组的数组，每个数组指定每个通道的范围（最小值和最大值）。'
- en: The resulting output is an image containing the computed probability map. Since
    each pixel is replaced by the value found in the histogram at the corresponding
    bin position, the resulting image has values between `0.0` and `1.0` (assuming
    a normalized histogram has been provided as input). A last parameter allows you
    to optionally rescale these values by multiplying them by a given factor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出是一个包含计算出的概率图的图像。由于每个像素都被替换为在对应bin位置读取的直方图中的值，因此结果图像的值在 `0.0` 和 `1.0` 之间（假设已提供归一化直方图作为输入）。最后一个参数允许你选择性地通过乘以给定因子来重新缩放这些值。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's now see how we can use the color information in the histogram backprojection
    algorithm.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下我们如何使用直方图反向投影算法中的颜色信息。
- en: Backprojecting color histograms
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向投影颜色直方图
- en: 'Multidimensional histograms can also be backprojected onto an image. Let''s
    define a class that encapsulates the backprojection process. We first define the
    required attributes and initialize the data as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 多维直方图也可以反向投影到图像上。让我们定义一个封装反向投影过程的类。我们首先定义所需的属性并初始化数据如下：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A `threshold` attribute used to create the binary map showing the detection
    result is introduced. If this parameter is set to a negative value, the raw probability
    map will be returned. The input histogram is normalized (this is, however, not
    required) as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了一个`threshold`属性，用于创建显示检测结果的二值图。如果此参数设置为负值，将返回原始概率图。输入直方图已归一化（这虽然是可选的），如下所示：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To backproject the histogram, you simply need to specify the image, the range
    (we assumed here that all channels have the same range), and the list of channels
    used. The `find` method performs the backprojection. Two versions of this method
    are available; the first one that uses the three channels of the image calls the
    more general version:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行直方图反向投影，您只需指定图像、范围（我们在这里假设所有通道的范围相同），以及使用的通道列表。`find`方法执行反向投影。此方法有两种版本；第一个使用图像的三个通道的版本调用更通用的版本：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s now use a BGR histogram on the color version of the image we used previously
    (see the book''s website to see this image in color). This time, we will try to
    detect the blue sky area. We will first load the color image, define the region
    of interest, and compute the 3D histogram on a reduced color space, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用之前使用的图像的颜色版本的BGR直方图（查看书籍网站以查看此图像的颜色）。这次，我们将尝试检测蓝色天空区域。我们首先加载彩色图像，定义感兴趣的区域，并在减少的颜色空间上计算3D直方图，如下所示：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, you compute the histogram and use the `find` method to detect the sky
    portion of the image, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您计算直方图并使用`find`方法检测图像的天空部分，如下所示：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result of the detection on the color version of the image in the previous
    section is seen here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节中图像颜色版本的检测结果如下：
- en: '![Backprojecting color histograms](img/image_04_013.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![反向投影颜色直方图](img/image_04_013.jpg)'
- en: The BGR color space is generally not the best one to identify color objects
    in an image. Here, to make it more reliable, we reduced the number of colors before
    computing the histogram (remember that the original BGR space counts more than
    16 million colors). The histogram extracted represents the typical color distribution
    for a sky area. Try to backproject it on another image. It should also detect
    the sky portion. Note that using a histogram built from multiple sky images should
    increase the accuracy of this detection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: BGR颜色空间通常不是在图像中识别颜色对象的最佳选择。在这里，为了使其更加可靠，我们在计算直方图之前减少了颜色的数量（记住，原始的BGR空间包含超过1600万种颜色）。提取的直方图代表了天空区域的典型颜色分布。尝试将其投影到另一张图像上。它也应该检测到天空部分。请注意，使用由多个天空图像构建的直方图可以提高这种检测的准确性。
- en: In this case, computing a sparse histogram would have been better in terms of
    memory usage. You should be able to redo this exercise using `cv::SparseMat` this
    time. Also, if you are looking for a bright-colored object, using the hue channel
    of the HSV color space would probably be more efficient. In other cases, the use
    of the chromaticity components of a perceptually uniform space (such as L*a*b*)
    might constitute a better choice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，从内存使用角度来看，计算稀疏直方图会更好。您应该能够使用`cv::SparseMat`重做这个练习。此外，如果您正在寻找颜色鲜艳的对象，使用HSV颜色空间的色调通道可能会更有效。在其他情况下，使用感知均匀空间（如L*a*b*）的色度分量可能是一个更好的选择。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the mean shift algorithm to find an object* recipe uses the HSV color
    space to detect an object in an image. This is one of the many alternative solutions
    you can use in the detection of some image content.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用均值漂移算法寻找对象*配方使用HSV颜色空间在图像中检测对象。这是您可以在某些图像内容检测中使用的许多替代解决方案之一。'
- en: The last two recipes of [Chapter 3](ch03.html "Chapter 3. Processing the Colors
    of an Image"), *Processing the Colors of an Image*, discusses the different color
    spaces that you could use for histogram backprojection.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 处理图像的颜色")的最后两个配方，*处理图像的颜色*，讨论了您可以使用直方图反向投影的不同颜色空间。'
- en: Using the mean shift algorithm to find an object
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用均值漂移算法寻找对象
- en: The result of a histogram backprojection is a probability map that expresses
    the probability that a given piece of image content is found at a specific image
    location. Suppose we now know the approximate location of an object in an image;
    the probability map can be used to find the exact location of the object. The
    most probable location will be the one that maximizes this probability inside
    a given window. Therefore, if we start from an initial location and iteratively
    move around in an attempt to increase the local probability measure, it should
    be possible to find the exact object location. This is what is accomplished by
    the **mean shift algorithm**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图反向投影的结果是一个概率图，表示给定图像内容在特定图像位置被找到的概率。假设我们现在知道图像中一个物体的近似位置；概率图可以用来找到物体的确切位置。最可能的位置将是最大化给定窗口内该概率的位置。因此，如果我们从一个初始位置开始，并迭代地移动以尝试增加局部概率度量，应该可以找到物体的确切位置。这正是**均值漂移算法**所实现的。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Suppose we have identified an object of interest here, a baboon''s face, as
    shown in the following image:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在这里识别了一个感兴趣的物体，即狒狒的脸，如下面的图像所示：
- en: '![How to do it...](img/image_04_015.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_04_015.jpg)'
- en: 'This time, we will describe this object by using the hue channel of the HSV
    color space. This means that we need to convert the image into an HSV one and
    then extract the hue channel and compute the 1D hue histogram of the defined ROI.
    Refer to the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用HSV颜色空间的色调通道来描述这个对象。这意味着我们需要将图像转换为HSV图像，然后提取色调通道并计算定义的ROI的1D色调直方图。参考以下代码：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As can be seen, the hue histogram is obtained using a convenient method that
    we have added to our `ColorHistogram` class as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，色调直方图是通过我们添加到`ColorHistogram`类中的一个便捷方法获得的：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The resulting histogram is then passed to our `ContentFinder` class instance,
    as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果直方图随后传递到我们的`ContentFinder`类实例，如下所示：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s now open a second image, where we want to locate the new baboon''s face
    position. This image needs to be converted to the HSV space first, and then we
    backproject the histogram of the first image. Refer to the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开第二张图像，我们想要定位新的狒狒脸位置。这张图像首先需要转换为HSV空间，然后我们反向投影第一张图像的直方图。参考以下代码：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, from an initial rectangular area (that is, the position of the baboon''s
    face in the initial image), the `cv::meanShift` algorithm of OpenCV will update
    the `rect` object at the new baboon''s face location, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从一个初始矩形区域（即初始图像中狒狒脸的位置），OpenCV的`cv::meanShift`算法将更新`rect`对象到新的狒狒脸位置，如下所示：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The initial (red) and new (green) face locations are displayed here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了初始（红色）和新的（绿色）脸部位置：
- en: '![How to do it...](img/image_04_017.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_04_017.jpg)'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we used the hue component of the HSV color space in order to
    characterize the object we were looking for. We made this choice because the baboon's
    face has a very distinctive pink color; consequently, the pixels' hue should make
    the face easily identifiable. The first step, therefore, is to convert the image
    to the HSV color space. The hue component is the first channel of the resulting
    image when the `CV_BGR2HSV` flag is used. This is an 8-bit component that varies
    from `0` to `180` (with `cv::cvtColor`, the converted image is of the same type
    as the source image). In order to extract the hue image, the 3-channel HSV image
    is split into three 1-channel images using the `cv::split` function. The three
    images are inserted into a `std::vector` instance, and the hue image is the first
    entry of the vector (that is, at index `0`).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了HSV颜色空间的色调分量来描述我们正在寻找的对象。我们做出这个选择是因为狒狒的脸有一种非常独特的粉红色；因此，像素的色调应该使脸部容易识别。因此，第一步是将图像转换为HSV颜色空间。当使用`CV_BGR2HSV`标志时，色调分量是结果图像的第一个通道。这是一个从`0`到`180`（使用`cv::cvtColor`转换的图像与源图像类型相同）的8位分量。为了提取色调图像，使用`cv::split`函数将3通道HSV图像分割成三个1通道图像。这三个图像被插入到一个`std::vector`实例中，色调图像是向量的第一个条目（即索引`0`）。
- en: When using the hue component of a color, it is always important to take its
    saturation into account (which is the second entry of the vector). Indeed, when
    the saturation of a color is low, the hue information becomes unstable and unreliable.
    This is due to the fact that for low-saturated color, the B, G, and R components
    are almost equal. This makes difficult to determine the exact color that is represented.
    Consequently, we decided to ignore the hue component of colors with low saturation.
    That is, they are not counted in the histogram (using the `minSat`, parameter
    which masks out pixels with saturation below this threshold in the `getHueHistogram`
    method).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用颜色的色调分量时，始终需要考虑其饱和度（这是向量的第二个元素）。确实，当颜色的饱和度低时，色调信息变得不稳定和不可靠。这是由于对于低饱和度颜色，B、G和R分量几乎相等。这使得很难确定所表示的确切颜色。因此，我们决定忽略低饱和度颜色的色调分量。也就是说，它们不计入直方图（使用`minSat`参数，在`getHueHistogram`方法中屏蔽掉饱和度低于此阈值的像素）。
- en: 'The mean shift algorithm is an iterative procedure that locates the local maxima
    of a probability function. It does this by finding the centroid, or weighted mean,
    of the data point inside a predefined window. The algorithm then moves the window
    center to the centroid location and repeats the procedure until the window center
    converges to a stable point. The OpenCV implementation defines two stopping criteria:
    a maximum number of iterations (`MAX_ITER`) and a window center displacement value
    below which the position is considered to have converged to a stable point (`EPS`).
    These two criteria are stored in a `cv::TermCriteria` instance. The `cv::meanShift`
    function returns the number of iterations that have been performed. Obviously,
    the quality of the result depends on the quality of the probability map provided
    on the given initial position. Note that here, we used a histogram of colors to
    represent an image''s appearance; it is also possible to use histograms of other
    features to represent the object (for example, a histogram of edge orientation).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 均值漂移算法是一种迭代过程，用于定位概率函数的局部极大值。它是通过找到预定义窗口内数据点的质心，或加权平均值来实现的。然后，算法将窗口中心移动到质心位置，并重复此过程，直到窗口中心收敛到一个稳定点。OpenCV实现定义了两个停止标准：最大迭代次数（`MAX_ITER`）和窗口中心位移值，低于此值的位移认为位置已经收敛到一个稳定点（`EPS`）。这两个标准存储在`cv::TermCriteria`实例中。`cv::meanShift`函数返回已执行的迭代次数。显然，结果的质量取决于在给定初始位置提供的概率图的质量。注意，在这里，我们使用颜色直方图来表示图像的外观；也可以使用其他特征的直方图来表示对象（例如，边缘方向的直方图）。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The mean shift algorithm has been largely used for visual tracking. [Chapter
    13](ch13.html "Chapter 13. Tracking Visual Motion") , *Tracking Visual Motion*,
    will explore the problem of object tracking in more detail
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值漂移算法已被广泛用于视觉跟踪。[第13章](ch13.html "第13章。跟踪视觉运动")，《跟踪视觉运动》，将更详细地探讨对象跟踪的问题。
- en: 'The mean shift algorithm has been introduced in the article *Mean Shift: A
    robust approach toward feature space analysis* by *D. Comaniciu and P. Meer* in
    *IEEE transactions on Pattern Analysis and Machine Intelligence*, volume 24, number
    5, May 2002'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值漂移算法在文章《均值漂移：一种稳健的特征空间分析方法》中被介绍，该文章由D. Comaniciu和P. Meer撰写，发表在《IEEE Transactions
    on Pattern Analysis and Machine Intelligence》杂志第24卷第5期，2002年5月。
- en: OpenCV also offers an implementation of the **CamShift** algorithm, which is
    an improved version of the mean shift algorithm in which the size and the orientation
    of the window can change
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV还提供了一个**CamShift**算法的实现，这是均值漂移算法的改进版本，其中窗口的大小和方向可以改变。
- en: Retrieving similar images using the histogram comparison
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用直方图比较检索相似图像
- en: Content-based image retrieval is an important problem in computer vision. It
    consists of finding a set of images that present content that is similar to a
    given query image. Since we have learned that histograms constitute an effective
    way to characterize an image's content, it makes sense to think that they can
    be used to solve the **content-based** image **retrieval** problem.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的图像检索是计算机视觉中的一个重要问题。它包括找到一组图像，这些图像呈现的内容与给定的查询图像相似。由于我们已经了解到直方图是表征图像内容的一种有效方式，因此认为它们可以用来解决**基于内容**的图像**检索**问题。
- en: The key here is to be able to measure the similarity between two images by simply
    comparing their histograms. A measurement function that will estimate how different,
    or how similar, two histograms are will need to be defined. Various such measures
    have been proposed in the past, and OpenCV proposes a few of them in its implementation
    of the `cv::compareHist` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于能够通过简单地比较它们的直方图来测量两张图像之间的相似度。一个测量函数将需要定义，以估计两个直方图有多不同，或者有多相似。过去已经提出了各种这样的度量，OpenCV在其`cv::compareHist`函数的实现中提出了一些。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to compare a reference image with a collection of images and find
    the ones that are the most similar to this query image, we created an `ImageComparator`
    class. This class contains a reference to a query image and an input image, together
    with their histograms. In addition, since we will perform the comparison using
    color histograms, the `ColorHistogram` class is used inside our `ImageComparator`
    class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将参考图像与一系列图像进行比较，并找到与查询图像最相似的图像，我们创建了一个`ImageComparator`类。这个类包含一个查询图像和一个输入图像的引用，以及它们的直方图。此外，由于我们将使用颜色直方图进行比较，我们在`ImageComparator`类内部使用了`ColorHistogram`类：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To get a reliable similarity measure, the histogram should be computed over
    a reduced number of bins. Therefore, the class allows you to specify the number
    of bins to be used in each BGR channel. The query image is specified using an
    appropriate setter that also computes the reference histogram, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得可靠的相似度度量，直方图应该在减少的bins数量上计算。因此，这个类允许你指定每个BGR通道中使用的bins数量。查询图像通过一个适当的setter指定，该setter还会计算参考直方图，如下所示：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, a `compare` method compares the reference image with a given input
    image. The following method returns a score that indicates how similar the two
    images are:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个`compare`方法比较参考图像与给定的输入图像。以下方法返回一个分数，表示两个图像的相似度：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding class can be used to retrieve images that are similar to a given
    query image. A reference image is provided to the class instance as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类可以用来检索与给定查询图像相似的图像。以下是如何将参考图像提供给类实例：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, the query image we used is the color version of the beach image shown
    in the *Backprojecting a histogram to detect specific image content* recipe earlier
    in the chapter. This image was compared to the following series of images. The
    images are shown in order from the most similar to the least similar:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的查询图像是本章前面在*将直方图反投影以检测特定图像内容*食谱中显示的海滩图像的颜色版本。这幅图像与以下一系列图像进行了比较。图像按从最相似到最不相似的顺序显示：
- en: '![How to do it...](img/image_04_018.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_04_018.jpg)'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Most histogram comparison measures are based on bin-by-bin comparisons. This
    is why it is important to work with a reduced histogram that will combine neighboring
    color into the same bin when measuring the similarity of two color histograms.
    The call to `cv::compareHist` is straightforward. You just input the two histograms
    and the function returns the measured distance. The specific measurement method
    you want to use is specified using a flag. In the `ImageComparator` class, the
    intersection method is used (with the `cv::HISTCMP_INTERSECT` flag). This method
    simply compares, for each bin, the two values in each histogram and keeps the
    minimum one. The similarity measure, then, is the sum of these minimum values.
    Consequently, two images that have histograms with no colors in common would get
    an intersection value of `0`, while two identical histograms would get a value
    that is equal to the total number of pixels.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数直方图比较度量都是基于bin-by-bin的比较。这就是为什么在测量两个颜色直方图的相似度时，与一个减少的直方图一起工作很重要，该直方图会将相邻的颜色组合到同一个bin中。调用`cv::compareHist`很简单。你只需输入两个直方图，函数就会返回测量的距离。你想要使用的特定测量方法通过一个标志来指定。在`ImageComparator`类中，使用的是交集方法（使用`cv::HISTCMP_INTERSECT`标志）。这种方法简单地比较每个bin中每个直方图的两个值，并保留最小的一个。相似度度量，然后，是这些最小值的总和。因此，两个没有共同颜色的直方图的图像将得到一个交集值为`0`，而两个相同的直方图将得到一个等于总像素数的值。
- en: The other available methods are the Chi-Square measure (the `cv::HISTCMP_CHISQR`
    flag), which sums the normalized square difference between the bins; the correlation
    method (the `cv::HISTCMP_CORREL` flag), which is based on the normalized cross-correlation
    operator used in signal processing to measure the similarity between two signals;
    and the Bhattacharyya measure (the `cv::HISTCMP_BHATTACHARYYA` flag) and Kullback-Leibler
    divergence (the `cv::HISTCMP_KL_DIV` flag), both used in statistics to estimate
    the similarity between two probabilistic distributions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的方法包括卡方度量（`cv::HISTCMP_CHISQR`标志），它计算桶之间归一化平方差的和；相关方法（`cv::HISTCMP_CORREL`标志），它基于在信号处理中用于测量两个信号之间相似性的归一化互相关算子；以及Bhattacharyya度量（`cv::HISTCMP_BHATTACHARYYA`标志）和Kullback-Leibler散度（`cv::HISTCMP_KL_DIV`标志），两者都用于统计学中估计两个概率分布之间的相似性。
- en: See also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The OpenCV documentation provides a description of the exact formulas used in
    the different histogram comparison measures.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV文档提供了不同直方图比较度量中使用的确切公式的描述。
- en: Earth Mover Distance is another popular histogram comparison method. It is implemented
    in OpenCV as the `cv::EMD` function. The main advantage of this method is that
    it takes into account the values found in adjacent bins to evaluate the similarity
    of two histograms. It is described in the article *The Earth Mover's Distance
    as a Metric for Image Retrieval* by *Y. Rubner, C. Tomasi, and L. J. Guibas in
    Int. Journal of Computer Vision*, Volume 40, No 2, 2000, pp. 99-121.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地球迁移距离是另一种流行的直方图比较方法。它在OpenCV中作为`cv::EMD`函数实现。这种方法的主要优点是它考虑了相邻桶中找到的值来评估两个直方图的相似性。它由Y.
    Rubner、C. Tomasi和L. J. Guibas在《国际计算机视觉杂志》第40卷第2期，2000年，第99-121页的论文《The Earth Mover's
    Distance as a Metric for Image Retrieval》中描述。
- en: Counting pixels with integral images
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用积分图像计数像素
- en: 'In the previous recipes, we learned that a histogram is computed by going through
    all the pixels of an image and cumulating a count of how often each intensity
    value occurs in this image. We have also seen that, sometimes, we are only interested
    in computing our histogram in a certain area of the image. In fact, having to
    accumulate a sum of pixels inside an image''s subregion is a common task in many
    computer vision algorithms. Now, suppose you have to compute several such histograms
    over multiple regions of interest inside your image. All these computations could
    rapidly become very costly. In such a situation, there is a tool that can drastically
    improve the efficiency of counting pixels over image subregions: the integral
    image.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们了解到直方图是通过遍历图像中的所有像素并累计每个强度值在此图像中出现的频率来计算的。我们还看到，有时我们只对在图像的某个特定区域内计算我们的直方图感兴趣。实际上，在图像的子区域内累计像素总和是许多计算机视觉算法中的常见任务。现在，假设你必须在图像中多个感兴趣区域内计算多个这样的直方图。所有这些计算可能会迅速变得非常昂贵。在这种情况下，有一个工具可以极大地提高在图像子区域内计数像素的效率：积分图像。
- en: Integral images have been introduced as an efficient way of summing pixels in
    image regions of interest. They are widely used in applications that involve,
    for example, computations over sliding windows at multiple scales.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 积分图像被引入作为一种在图像感兴趣区域中求和像素的高效方法。它们在涉及例如在多个尺度上滑动窗口的计算的应用中得到了广泛的应用。
- en: This recipe will explain the principle behind integral images. Our objective
    here is to show how pixels can be summed over a rectangular region by using only
    three arithmetic operations. Once we have learned this concept, the *There's more...*
    section of this recipe will show you two examples where integral images can be
    advantageously used.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将解释积分图像背后的原理。我们的目标是展示如何仅使用三个算术运算来对矩形区域内的像素进行求和。一旦我们掌握了这个概念，本食谱的“还有更多...”部分将展示两个例子，说明积分图像如何被有利地使用。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This recipe will play with the following picture, in which a region of interest
    showing a girl on her bike is identified:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将使用以下图片进行操作，其中识别出一个感兴趣的区域，显示一个女孩骑自行车：
- en: '![How to do it...](img/image_04_021.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](img/image_04_021.jpg)'
- en: 'Integral images are useful when you need to sum pixels over several image areas.
    Normally, if you wish to get the sum of all pixels over a region of interest,
    you would write the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要对多个图像区域内的像素进行求和时，积分图像非常有用。通常情况下，如果你希望获取感兴趣区域内所有像素的总和，你会编写以下代码：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `cv::sum` function simply loops over all the pixels of the region and accumulates
    the sum. Using an integral image, this can be achieved using only three additive
    operations. However, first you need to compute the integral image, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::sum` 函数简单地遍历该区域的全部像素并累加总和。使用积分图像，这可以通过仅使用三次加法操作来实现。然而，首先你需要计算积分图像，如下所示：'
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As will be explained in the next section, the same result can be obtained using
    this simple arithmetic expression on the computed integral image, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如下一节所述，可以通过在计算出的积分图像上使用这个简单的算术表达式获得相同的结果，如下所示：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both approaches give you the same result. However, computing the integral image
    is costly, since you have to loop over all the image pixels. The key is that once
    this initial computation is done, you will only need to add four values to get
    a sum over a region of interest no matter what the size of this region is. Integral
    images then become advantageous to use when multiple such pixel sums have to be
    computed over multiple regions of different sizes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会给出相同的结果。然而，计算积分图像是昂贵的，因为你必须遍历所有图像像素。关键是，一旦完成这个初始计算，你只需要添加四个值就可以得到对感兴趣区域的求和，无论这个区域的大小如何。因此，当需要计算多个不同大小区域的多个像素总和时，积分图像的使用就变得有利。
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous section, you were introduced to the concept of integral images
    through a brief demonstration of the magic behind them, that is, how they can
    be used to cheaply compute the sum of pixels inside rectangular regions. To understand
    how they work, let's now define what an integral image is. An integral image is
    obtained by replacing each pixel with the value of the sum of all the pixels located
    inside the upper-left quadrant delimited by this pixel. The integral image can
    be computed by scanning the image once. Indeed, the integral value of a current
    pixel is given by the integral value of the pixel above this current pixel plus
    the value of the cumulative sum of the current line. The integral image is therefore
    a new image containing pixel sums. To avoid overflows, this image is usually an
    image of `int` values (`CV_32S`) or `float` values (`CV_32F`).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你通过一个简要的演示介绍了积分图像的概念，展示了其背后的魔法，即它们如何被用来以低成本计算矩形区域内的像素总和。为了理解它们是如何工作的，现在让我们定义什么是积分图像。积分图像是通过将每个像素替换为位于由该像素所围成的左上象限内所有像素的总和来获得的。积分图像可以通过扫描图像一次来计算。确实，当前像素的积分值是由当前像素上方的像素的积分值加上当前行的累积和的值。因此，积分图像是一个包含像素总和的新图像。为了避免溢出，这个图像通常是一个
    `int` 值的图像（`CV_32S`）或 `float` 值的图像（`CV_32F`）。
- en: 'For example, in the following figure, pixel A in this integral image would
    contain the sum of the pixels contained inside the upper-left corner area, which
    is identified with a double-hatched pattern:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的图中，这个积分图像中的像素 **A** 将包含包含在上左角区域内的像素总和，该区域用双虚线图案标识：
- en: '![How it works...](img/image_04_022.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/image_04_022.jpg)'
- en: 'Once the integral image has been computed, any summation over a rectangular
    region can be easily obtained through four pixel accesses, and here is why. Referring
    to the preceding figure, we can see that the sum of the pixels inside the region
    delimited by the pixels **A**, **B**, **C**, and **D** can be obtained by reading
    the integral value at pixel **D**, from which you subtract the values of the pixels
    over **B** and to the left-hand side of **C**. However, by doing so, you have
    subtracted twice the sum of pixels located in the upper-left corner of **A**;
    this is why you have to re-add the integral sum at **A**. Formally, then, the
    sum of pixels inside **A**, **B**, **C**, and **D** is given by `A-B-C+D`. If
    we use the `cv::Mat` method to access pixel values, this formula translates to
    the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出了积分图像，任何对矩形区域的求和都可以通过四次像素访问轻松获得，原因如下。参考前面的图示，我们可以看到，像素 **A**、**B**、**C**
    和 **D** 所围区域的像素总和可以通过读取像素 **D** 的积分值来获得，然后从这个值中减去像素 **B** 和 **C** 左侧的像素值。然而，这样做会减去
    **A** 的左上角像素总和的两倍；这就是为什么你必须重新加上 **A** 的积分和。形式上，**A**、**B**、**C** 和 **D** 内部像素的总和由
    `A-B-C+D` 给出。如果我们使用 `cv::Mat` 方法来访问像素值，这个公式可以转换为以下形式：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The complexity of this computation is, therefore, constant, no matter what the
    size of the region of interest is. Note that, for simplicity, we used the `at`
    method of the `cv::Mat` class, which is not the most efficient way to access pixel
    values (see [Chapter 2](ch02.html "Chapter 2. Manipulating Pixels") , *Manipulating
    Pixels*). This aspect will be discussed in the *There's more...* section of this
    recipe, which presents two applications that benefit from the efficiency of the
    integral image concept.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种计算的复杂度是常数，无论感兴趣的区域大小如何。请注意，为了简单起见，我们使用了`cv::Mat`类的`at`方法，这不是访问像素值最有效的方法（参见[第2章](ch02.html
    "第2章. 操作像素")，*操作像素*）。这个问题将在本食谱的“更多内容...”部分进行讨论，该部分介绍了两个受益于积分图像概念效率的应用。
- en: There's more...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Integral images are used whenever multiple pixel summations must be performed.
    In this section, we will illustrate the use of integral images by introducing
    the concept of adaptive thresholding. Integral images are also useful for the
    efficient computation of histograms over multiple windows. This is also explained
    in this section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当必须执行多个像素求和时，会使用积分图像。在本节中，我们将通过介绍自适应阈值化的概念来说明积分图像的使用。积分图像对于在多个窗口上高效计算直方图也非常有用。这一点在本节中也有解释。
- en: Adaptive thresholding
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自适应阈值化
- en: 'Applying a threshold on an image in order to create a binary image could be
    a good way to extract the meaningful elements of an image. Suppose that you have
    the following image of a book:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建二值图像并对图像中的有意义元素进行提取，对图像应用阈值可能是一个好方法。假设你有一张书的以下图像：
- en: '![Adaptive thresholding](img/image_04_025.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![自适应阈值化](img/image_04_025.jpg)'
- en: 'Since you are interested in analyzing the text in this image, you apply a threshold
    to this image as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你对分析图像中的文本感兴趣，你将按照以下方式对这张图像应用阈值：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You obtain the following result:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下结果：
- en: '![Adaptive thresholding](img/image_04_026.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![自适应阈值化](img/image_04_026.jpg)'
- en: In fact, no matter what value you choose for the threshold, in some parts of
    the image you get missing text, whereas in other parts, the text disappears under
    the shadow. To overcome this problem, one possible solution consists of using
    a local threshold that is computed from each pixel's neighborhood. This strategy
    is called **adaptive thresholding**, and it consists of comparing each pixel with
    the mean value of the neighboring pixels. Pixels that clearly differ from their
    local mean will then be considered as outliers and will be cut off by the thresholding
    process.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，无论你选择什么阈值值，在图像的某些部分你会得到缺失的文本，而在其他部分，文本则被阴影所掩盖。为了克服这个问题，一个可能的解决方案是使用从每个像素的邻域计算出的局部阈值。这种策略被称为**自适应阈值化**，它包括将每个像素与相邻像素的均值进行比较。然后，与局部均值明显不同的像素将被视为异常值，并通过阈值化过程被截断。
- en: 'Adaptive thresholding, therefore, requires the computation of a local mean
    around every pixel. This requires multiple image window summations that can be
    computed efficiently through the integral image. Consequently, the first step
    is to compute the following integral image:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，自适应阈值化需要计算每个像素周围的局部均值。这需要通过积分图像高效地计算多个图像窗口的求和。因此，第一步是计算以下积分图像：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can go through all the pixels and compute the mean over a square neighborhood.
    We could use our `IntegralImage` class to do so, but this one uses the inefficient
    `at` method for pixel access. This time, let''s get efficient by looping over
    the image using the pointers, as we learned in [Chapter 2](ch02.html "Chapter 2. Manipulating
    Pixels") , *Manipulating Pixels*. This loop looks as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以遍历所有像素，并在一个正方形邻域内计算均值。我们可以使用我们的`IntegralImage`类来做这件事，但这个类使用效率低下的`at`方法来访问像素。这次，让我们通过使用指针遍历图像来提高效率，正如我们在[第2章](ch02.html
    "第2章. 操作像素")，*操作像素*中学习的那样。这个循环看起来如下所示：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this example, a neighborhood of size `21x21` is used. To compute each mean,
    we need to access the four integral pixels that delimit the square neighborhood:
    two located on the line pointed by `idata1` and two on the line pointed by `idata2`.
    The current pixel is compared to the computed mean, from which we subtract a threshold
    value (here, set to `10`); this is to make sure that rejected pixels clearly differ
    from their local mean. The following binary image is then obtained:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，使用了一个大小为 `21x21` 的邻域。为了计算每个均值，我们需要访问界定正方形邻域的四个整数像素：两个位于由 `idata1` 指向的线上，另外两个位于由
    `idata2` 指向的线上。当前像素与计算出的均值进行比较，然后从中减去一个阈值值（此处设置为 `10`）；这是为了确保被拒绝的像素与它们的局部均值明显不同。随后得到以下二值图像：
- en: '![Adaptive thresholding](img/image_04_028.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![自适应阈值](img/image_04_028.jpg)'
- en: 'Clearly, this is a much better result than the one we got using a fixed threshold.
    Adaptive thresholding is a common image-processing technique. As such, it is also
    implemented in OpenCV as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这比我们使用固定阈值得到的结果要好得多。自适应阈值是一种常见的图像处理技术。因此，它也被 OpenCV 如下实现：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This function call produces exactly the same result as the one we obtained using
    our integral image. In addition, instead of using the local mean for thresholding,
    this function allows you to use a Gaussian weighted sum (the method flag would
    be `cv::ADAPTIVE_THRESH_GAUSSIAN_C`) in this case. It is interesting to note that
    our implementation is slightly faster than the `cv::adaptiveThreshold` call.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用产生的结果与我们使用积分图像得到的结果完全相同。此外，与使用局部均值进行阈值化不同，此函数允许您在这种情况下使用高斯加权和（方法标志为 `cv::ADAPTIVE_THRESH_GAUSSIAN_C`）。值得注意的是，我们的实现比
    `cv::adaptiveThreshold` 调用略快。
- en: 'Finally, it is worth mentioning that we can also write an adaptive thresholding
    procedure by using the OpenCV image operators. This would be done as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是，我们还可以通过使用 OpenCV 图像运算符来编写自适应阈值过程。这将是以下步骤：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Image filtering will be covered in [Chapter 6](ch06.html "Chapter 6. Filtering
    the Images") , *Filtering the Images*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图像滤波将在 [第 6 章](ch06.html "第 6 章。滤波图像")，*滤波图像* 中介绍。
- en: Visual tracking using histograms
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用直方图的视觉跟踪
- en: As we learned in the previous recipes, a histogram constitutes a reliable global
    representation of an object's appearance. In this section, we will demonstrate
    the usefulness of integral images by showing you how we can locate an object in
    an image by searching for an image area that presents a histogram similar to a
    target object. We accomplished this in the *Using the mean shift algorithm to
    find an object* recipe by using the concepts of histogram backprojection and local
    search through mean shift. This time, we will find our object by performing an
    explicit search for regions of similar histograms over the full image.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的食谱中所学，直方图构成了对象外观的可靠全局表示。在本节中，我们将通过向您展示我们如何通过搜索与目标对象具有相似直方图的图像区域来定位图像中的对象来展示积分图像的有用性。我们通过使用直方图反向投影和通过均值漂移进行局部搜索的
    *使用均值漂移算法查找对象* 食谱实现了这一点。这次，我们将通过在整幅图像上执行对具有相似直方图区域的显式搜索来找到我们的对象。
- en: In the special case where an integral image is used on a binary image made of
    `0` and `1` values, the integral sum gives you the number of pixels that have
    a value of `1` inside the specified region. We will exploit this fact in this
    recipe to compute the histogram of a gray-level image.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在特殊情况下，当在由 `0` 和 `1` 值组成的二值图像上使用积分图像时，积分和给出了指定区域内具有 `1` 值的像素数量。我们将利用这一事实在本食谱中计算灰度图像的直方图。
- en: 'The `cv::integral` function also works for multichannel images. You can take
    advantage of this fact to compute histograms of image subregions using integral
    images. You simply need to convert your image into a multichannel image made of
    binary planes; each of these planes is associated to a bin of your histogram and
    shows you which pixels have a value that falls into this bin. The following function
    creates such multiplane images from a gray-level one:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::integral` 函数也适用于多通道图像。您可以利用这一事实，通过积分图像来计算图像子区域的直方图。您只需将您的图像转换为由二值平面组成的多通道图像；每个平面都与直方图的一个箱相关联，并显示哪些像素的值落在这个箱中。以下函数从一个灰度图像创建这样的多平面图像：'
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The integral image computations can also be encapsulated into one convenient
    template class as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 整数图像的计算也可以封装到一个方便的模板类中，如下所示：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We now want to find where the girl on the bicycle, whom we identified in the
    previous image, is in a subsequent image. Let''s first compute the histogram of
    the girl in the original image. We can accomplish this using the `Histogram1D`
    class we built in the recipe *Computing an image histogram* of this chapter. Here,
    we produce a 16-bin histogram as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要找到在上一张图像中识别出的骑自行车的女孩在后续图像中的位置。让我们首先计算原始图像中女孩的直方图。我们可以使用本章的食谱“计算图像直方图”中构建的`Histogram1D`类来完成此操作。在这里，我们生成一个16箱直方图，如下所示：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding histogram will be used as a referential representation to locate
    the target object (the girl on her bike) in a subsequent image.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的直方图将被用作参考表示，以在后续图像中定位目标对象（骑自行车的女孩）。
- en: 'Suppose that the only information we have is that the girl is moving more or
    less horizontally across the image. Since we will have many histograms to compute
    at various locations, we compute the integral image as a preliminary step. Refer
    to the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们唯一的信息是女孩在大约水平方向上移动。由于我们将在不同的位置计算许多直方图，我们将计算积分图像作为初步步骤。参考以下代码：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To perform the search, we loop over a range of possible locations and compare
    the current histogram with the referential one. Our goal is to find the location
    with the most similar histogram. Refer to the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行搜索，我们在可能的范围中循环遍历，并将当前直方图与参考直方图进行比较。我们的目标是找到具有最相似直方图的位置。参考以下代码：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The location with the most similar histogram is then identified as followings:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后识别具有最相似直方图的位置如下：
- en: '![Visual tracking using histograms](img/image_04_031.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![使用直方图进行视觉跟踪](img/image_04_031.jpg)'
- en: The white rectangle represents the search area. Histograms of all windows that
    fit inside this area have been computed. We kept the window size constant, but
    it could have been a good strategy to also search for slightly smaller or larger
    windows in order to take into account the eventual changes in scale. Note that
    in order to limit the complexity of this computation, the number of bins in the
    histograms to be computed should be kept low. In our example, we reduced this
    to `16` bins. Consequently, plane `0` of this multiplane image contains a binary
    image that shows you all pixels that have a value between `0` and `15`, while
    plane `1` shows you pixels with values between `16` and `31`, and so on.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 白色矩形表示搜索区域。所有适合该区域的窗口的直方图已经计算完成。我们保持了窗口大小不变，但寻找稍微小一些或大一些的窗口可能是一个好的策略，以便考虑可能的尺度变化。请注意，为了限制计算的复杂性，要计算的直方图中的箱数应保持较低。在我们的例子中，我们将这个数字减少到`16`个箱。因此，多平面图像的平面`0`包含一个二值图像，显示所有介于`0`和`15`之间的像素，而平面`1`显示介于`16`和`31`之间的像素，以此类推。
- en: The search for an object consisted of computing the histograms of all windows
    of the given size over a predetermined range of pixels. This represents the computation
    of `3200` different histograms that have been efficiently computed from our integral
    image. All the histograms returned by our `IntegralImage` class are contained
    in a `cv::Vec` object (because of the use of the `at` method). We then use the
    `cv::compareHist` function to identify the most similar histogram (remember that
    this function, like most OpenCV functions, can accept either the `cv::Mat` or
    `cv::Vec` object through the convenient `cv::InputArray` generic parameter type).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的搜索包括计算给定大小窗口在预定像素范围内的直方图。这代表了从我们的积分图像中高效计算出的`3200`个不同直方图的计算。我们`IntegralImage`类返回的所有直方图都包含在一个`cv::Vec`对象中（由于使用了`at`方法）。然后我们使用`cv::compareHist`函数来识别最相似的直方图（记住，这个函数，像大多数OpenCV函数一样，可以通过方便的`cv::InputArray`泛型参数类型接受`cv::Mat`或`cv::Vec`对象）。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 8](ch08.html "Chapter 8. Detecting Interest Points") , *Detecting
    Interest Points*, will present the SURF operator that also relies on the use of
    integral images'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章. 检测兴趣点")，*检测兴趣点*，将介绍也依赖于积分图像使用的SURF算子'
- en: The *Finding objects and faces with a cascade of Haar features* recipe in[Chapter
    14](ch14.html "Chapter 14. Learning from Examples"), *Learning from Examples, *presents
    the Haar features that are computed using integral images
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章. 从示例中学习")中的*使用Haar特征级联查找对象和面部*食谱，*从示例中学习*，介绍了使用积分图像计算的Haar特征'
- en: The *Applying morphological operators on gray-level images* recipe in [Chapter
    5](ch05.html "Chapter 5. Transforming Images with Morphological Operations"),
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章中的应用形态算子于灰度图像的配方](ch05.html "第5章。使用形态学操作变换图像"),'
- en: '*Transforming Images with Morphological Operations*, presents an operator that
    can produce results similar to the presented adaptive thresholding technique'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*使用形态学操作变换图像*，介绍了一个可以产生与所提出的自适应阈值技术类似结果的算子'
- en: The article *Robust Fragments-based Tracking using the Integral Histogram* by
    *A. Adam*, *E. Rivlin*, and *I. Shimshoni* in the *Proceedings of the International
    Conference on Computer Vision and Pattern Recognition*, 2006, pp. 798-805, describes
    an interesting approach that uses integral images to track objects in an image
    sequence
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*A. Adam*、*E. Rivlin*和*I. Shimshoni*在2006年*国际计算机视觉和模式识别会议论文集*中发表的*基于鲁棒片段的跟踪使用积分直方图*一文，描述了一种使用积分图像在图像序列中跟踪对象的有意思的方法
