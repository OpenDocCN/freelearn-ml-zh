- en: Modules, Packages, and Data Type Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块、包和数据类型概念
- en: This chapter discusses several organizational techniques for developing large-scale
    applications. Believe it or not, this is often something that is easily overlooked.
    When developing applications, we typically focus on building data types, functions,
    control flows, and so on. It is equally important, however, to organize the code
    properly so that it is clean and maintainable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了开发大型应用程序的几种组织技术。信不信由你，这通常是容易被忽视的事情。在开发应用程序时，我们通常专注于构建数据类型、函数、控制流等。然而，正确组织代码同样重要，以便它既干净又易于维护。
- en: In the later part of this chapter, we will introduce Julia's type system. Data
    types are the most fundamental building blocks of any application. Julia's type
    system is one of its strongest features when compared to other programming languages.
    A solid understanding of the type system will enable us to achieve better designs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后期部分，我们将介绍 Julia 的类型系统。数据类型是任何应用程序最基本的建设模块。与其它编程语言相比，Julia 的类型系统是其最强大的特性之一。对类型系统的深入了解将使我们能够实现更好的设计。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The growing pains of developing applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发应用程序的成长之痛
- en: Working with namespaces, modules, and packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与命名空间、模块和包一起工作
- en: Managing package dependencies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理包依赖
- en: Designing abstract types and concrete types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计抽象类型和具体类型
- en: Understanding parametric types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解参数化类型
- en: Converting between data types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据类型之间进行转换
- en: By the end of the chapter, you should know how to create your own packages,
    divide code into separate modules, and start creating new data types for your
    application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该知道如何创建自己的包，将代码划分为独立的模块，并为你的应用程序开始创建新的数据类型。
- en: Let's go!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample source code from this chapter is located at [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码位于 [https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-on-Design-Patterns-and-Best-Practices-with-Julia/tree/master/Chapter02)。
- en: The code is tested in a Julia 1.3.0 environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 Julia 1.3.0 环境中进行了测试。
- en: The growing pains of developing applications
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发应用程序的成长之痛
- en: '"Start where you are. Use what you have. Do what you can. "'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '"从你所在之处开始。利用你所拥有的。做你能做的。"'
- en: '- Arthur Ashe'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '- 亚瑟·阿什'
- en: Everyone's journey is different. Julia is a versatile, dynamic programming language
    that can be used in many interesting use cases. More specifically, you can use
    it to easily code and solve a problem without thinking too much about system architecture
    and design. This is often sufficient for small research projects; however, when
    a project becomes more critical to the business, or when you have to harden a
    proof of concept into a production environment, it requires better organization,
    architecture, and design so that the project or application can live longer and
    be more maintainable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人的旅程都是不同的。Julia 是一种多才多艺、动态的编程语言，可以用于许多有趣的用例。更具体地说，你可以用它轻松地编码和解决问题，而不必过多地考虑系统架构和设计。这对于小型研究项目通常是足够的；然而，当项目对业务变得更为关键，或者你必须将一个概念验证硬化为生产环境时，它需要更好的组织、架构和设计，以便项目或应用程序能够更长久地生存并更易于维护。
- en: What kinds of project do we typically deal with? Let's explore some examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常处理哪些类型的项目？让我们探索一些例子。
- en: Data science projects
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据科学项目
- en: A typical data science project starts with the idea of learning from a set of
    data and making a prediction. A lot of the upfront work goes into data collection,
    data cleaning, data analysis, and visualization. Then, data is further digested
    into features as inputs a machine learning model. The process up until this point
    is called *data engineering*. The data scientist then chooses one or more machine
    learning models and keeps on refining and tuning the model to arrive at a good
    level of accuracy for the predictive model. This process is called *model development*.
    When the model is ready for production, it is deployed and sometimes a frontend
    is created for the end user. The final process is referred to as *model deployment*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的数据科学项目从从一组数据中学习并做出预测的想法开始。大量的前期工作都投入到数据收集、数据清洗、数据分析以及可视化中。然后，数据被进一步转化为特征，作为机器学习模型的输入。直到这一点的过程被称为*数据工程*。然后，数据科学家选择一个或多个机器学习模型，并不断优化和调整模型，以达到预测模型的良好准确度。这个过程被称为*模型开发*。当模型准备好投入生产时，它就会被部署，有时还会为最终用户创建一个前端。最后的过程被称为*模型部署*。
- en: The data engineering and model development processes can be interactive at the
    beginning, but they usually end up getting automated. That's because the process
    needs to be repeatable and the results have to be consistent. Data scientists
    may use a variety of tools during development, ranging from a number of Jupyter
    notebooks to a suite of related libraries and programs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据工程和模型开发过程在开始时可能是交互式的，但通常最终会自动化。这是因为过程需要可重复，结果必须一致。数据科学家在开发过程中可能会使用各种工具，从多个Jupyter笔记本到一系列相关的库和程序。
- en: When a predictive model becomes production-ready, it can be deployed as a web
    service so that it can be used to make real-time predictions. At this point, the
    model needs to have a life cycle and be maintained, just like any other production
    software.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个预测模型准备好投入生产时，它可以作为一个网络服务部署，以便用于进行实时预测。在这个阶段，模型需要有一个生命周期并得到维护，就像任何其他生产软件一样。
- en: Enterprise applications
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业应用程序
- en: People developing enterprise applications have a different mindset. Unlike data
    science projects, software engineers typically know upfront what they need to
    build the system. They also know whether they have to live with certain assumptions
    and policies. For example, the technology stack may already be known when the
    project starts. Other factors that may already be familiar include the system
    architecture that will be used, which cloud vendor will be utilized, what database
    the application must integrate with, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开发企业应用程序的人有不同的思维方式。与数据科学项目不同，软件工程师通常一开始就知道他们需要构建系统所需的内容。他们还知道是否必须接受某些假设和政策。例如，当项目开始时，技术栈可能已经确定。其他可能已经熟悉的因素包括将要使用的系统架构、将利用的云服务提供商、应用程序必须集成的数据库等。
- en: Enterprise applications typically require a rich business domain object model.
    Data objects are created, manipulated, and transferred to different layers of
    the application. The system architecture may include a user interface, a middle
    tier, and a database backend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序通常需要一个丰富的业务领域对象模型。数据对象被创建、操作，并传输到应用程序的不同层。系统架构可能包括用户界面、中间层和数据库后端。
- en: Enterprise applications also tend to require a high level of integration with
    other systems. For example, a trading system used by an investment firm is typically
    hooked up to an accounting system, a trade-settlement system, a reporting system,
    and so on. As such, these applications are often designed to handle both *data
    at rest* (for example, data stored in a database) or *data in motion* (for example,
    data being streamed to another system). Furthermore, data movement may happen
    in real-time or as an overnight batch process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序通常也需要与其他系统进行高度集成。例如，一家投资公司使用的交易系统通常连接到会计系统、交易结算系统、报告系统等。因此，这些应用程序通常被设计为处理静态数据（例如，存储在数据库中的数据）或动态数据（例如，被流式传输到另一个系统的数据）。此外，数据移动可能发生在实时或作为夜间批量处理。
- en: Adapting to growth
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应增长
- en: No matter what kind of application you develop, it should not be hard to recognize
    growing pains.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你开发什么类型的应用程序，都不应该难以识别成长的痛苦。
- en: 'For a data science project, the following signs typically indicate a growth-related
    problem:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据科学项目，以下迹象通常表明与增长相关的问题：
- en: <q><q>"My notebook is getting too long. I often have to scroll up and down to
    understand what I have done before and what I'm doing now. There are too many
    variables created in between and I'm losing track of what they mean and how they
    are used."</q></q>
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q><q>"我的笔记本变得越来越长。我经常不得不上下滚动以理解我之前做了什么以及我现在在做什么。中间创建了太多的变量，我正在失去追踪它们的意义以及它们是如何被使用的。”</q></q>
- en: <q>"The data structure is too complex. I was working on a data frame and have
    transformed it in ten different ways. I have now lost track of which transformed
    version represents what, and why they were needed in the first place."</q>
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q>"数据结构太复杂了。我正在处理一个数据框，已经以十种不同的方式进行了转换。我现在已经失去了追踪哪种转换版本代表什么，以及为什么最初需要它们。”</q>
- en: <q>"I have saved a bunch of machine learning models on disk, and I'm losing
    track of how each one was trained and what assumptions were made for each of those
    models."</q>
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q>"我在磁盘上保存了许多机器学习模型，但我正在失去追踪每个模型是如何训练的以及为每个模型所做出的假设。”</q>
- en: <q>"I have too much code scattered across many notebooks. Some code is duplicated
    or tweaked for a slightly different purpose. I am unable to achieve consistent
    results."</q>
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q>"我的代码散布在许多笔记本中。一些代码被重复或稍作修改用于不同的目的。我无法实现一致的结果。”</q>
- en: 'As for an enterprise application, similar symptoms may surface:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于企业应用程序，可能也会出现类似的症状：
- en: <q>*"The application logic is too complicated, and there is a huge component
    performing too many functions."*</q>
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q>"应用程序逻辑太复杂了，有一个组件执行了太多的功能。”</q>
- en: <q>*"It's becoming difficult to add new features without breaking existing functions."*</q>
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q>"在不破坏现有功能的情况下添加新功能变得越来越困难。”</q>
- en: <q>*"It takes a lot of time for a new person to comprehend the code in this
    module and it seems that the same person has to relearn it again every now and
    then." *</q>
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <q>"新来的人理解这个模块中的代码需要花费很多时间，而且似乎同一个人每隔一段时间就必须重新学习它。”</q>
- en: It's not fun to handle unorganized code and data. If you find yourself uttering
    some of the preceding phrases, it may be a good time to rethink your strategy
    and start organizing your program properly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 处理无组织代码和数据并不有趣。如果你发现自己正在说出前面的一些短语，那么可能是时候重新思考你的策略，并开始正确地组织你的程序了。
- en: Now, let's start our learning journey by organizing code better with Julia.
    As we are working at a high level, we will introduce the concept of namespaces,
    and we will go over how to create modules and packages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用 Julia 更好地组织代码来开始我们的学习之旅。由于我们正在处理一个高层次的问题，我们将介绍命名空间的概念，并概述如何创建模块和包。
- en: Working with namespaces, modules, and packages
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与命名空间、模块和包一起工作
- en: The Julia ecosystem lives on a namespace; in fact, this is the only way we can
    keep things in order. Why do I say that? The reason is that namespaces are used
    to logically separate fragments of source code so that they can be developed independently
    without affecting each other. If I define a function in one namespace, I will
    still be able to define another function in a different namespace even though
    both functions have the same name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 生态系统生活在命名空间中；事实上，这是我们保持事物有序的唯一方式。为什么我会这么说呢？原因在于命名空间被用来逻辑上分离源代码的片段，这样它们就可以独立开发，而不会相互影响。如果我在一个命名空间中定义了一个函数，我仍然可以在不同的命名空间中定义另一个具有相同名称的函数。
- en: In Julia, namespaces are created using modules and submodules. In order to manage
    distribution and dependencies, modules are generally organized as packages. There
    is a standard directory structure for Julia packages. Although the top level directory
    structure is well defined, the programmer still has a lot of freedom in organizing
    source files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，命名空间是通过模块和子模块创建的。为了管理分布和依赖关系，模块通常被组织成包。Julia 包有一个标准的目录结构。尽管顶层目录结构定义得很好，但程序员在组织源文件方面仍有很大的自由度。
- en: 'In this section, we will explore the following topics:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下主题：
- en: Understanding and using namespaces
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用命名空间
- en: How to create modules and packages
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建模块和包
- en: How to create submodules
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建子模块
- en: How to organize files in a module
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在模块中组织文件
- en: Let's learn about each in detail in the following sections.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将详细学习每个主题。
- en: Understanding namespaces
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命名空间
- en: What is a namespace? Let's try a real-life example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是什么？让我们通过一个现实生活中的例子来尝试理解。
- en: 'Every language has its own set of words as defined in its dictionary. When
    people from different cultures talk to each other, they often end up in amusing
    situations. Consider these examples:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言都有其字典中定义的一组词汇。当来自不同文化的人互相交谈时，他们经常会陷入有趣的情况。考虑以下例子：
- en: '**Conversation 1**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**对话 1**:'
- en: American: *Your pants look dirty. You should change them.*
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国人：*你的裤子看起来很脏。你应该换一下。*
- en: British: *Do you mean my trousers? My underpants are... quite clean and well!*
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英国人：*你是说我裤子吗？我的内衣...相当干净和整洁！*
- en: '**Conversation 2**:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**对话 2**:'
- en: American: *These biscuits are yummy!*
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国人：*这些饼干很美味！*
- en: British: *Where? Where are the cookies...?*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英国人：*在哪里？饼干在哪里...？*
- en: '**Conversation 3**:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**对话 3**:'
- en: American: *I want to get back in shape and have tried many trainers but none
    of them are good.*
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国人：*我想恢复体型，已经尝试过很多教练，但没有一个好的。*
- en: British: *Have you tried the new running ones from Nike? I found them comfortable
    enough for my daily jogging routines.*
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英国人：*你试过耐克的新跑步鞋了吗？我觉得它们对我日常慢跑足够舒适。*
- en: 'In fact, you don''t even need to be from a different culture to experience
    this problem. Sometimes the same word already has different meanings depending
    on the context. For example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你甚至不需要来自不同的文化才能体验到这个问题。有时，同一个词在不同的语境中已经有了不同的含义。例如：
- en: Pool - swimming pool or a group of things?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游泳池 - 游泳池还是一组东西？
- en: Squash - the vegetable or the sport?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 南瓜 - 蔬菜还是运动？
- en: Current - electrical current or a flow of water?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电流 - 电流还是水流？
- en: 'There is no way that we can enforce a single vocabulary across all domains
    because of ambiguities such as these. Fortunately, computer scientists are smart
    and long ago solved the problem as it pertains to their field: to distinguish
    two different meanings for a single word, we can just prefix the word with the
    respective context. Using the examples from the preceding list, we can qualify
    each word as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些模糊性，我们无法在所有领域强制使用单一词汇表。幸运的是，计算机科学家很聪明，很久以前就解决了他们领域的问题：为了区分一个词的两个不同含义，我们只需在词前加上相应的上下文。使用前面列表中的例子，我们可以这样限定每个词：
- en: '`Facility.Pool` and `Grouping.Pool`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Facility.游泳池` 和 `Grouping.游泳池`'
- en: '`Vegetable.Squash` and `Sport.Squash`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vegetable.南瓜` 和 `Sport.壁球`'
- en: '`Electricity.Current` and `Liquid.Current`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Electricity.电流` 和 `Liquid.水流`'
- en: The prefix is known as a **namespace**. Now that the words are qualified with
    their respective namespaces, they are no longer ambiguous and have a clear meaning.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀被称为**命名空间**。现在，这些词已经通过各自的命名空间进行了限定，它们不再模糊，具有明确的意义。
- en: In Julia, namespaces are created using modules, which we will learn about in
    the following section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，命名空间是通过模块创建的，我们将在下一节中学习。
- en: Creating modules and packages
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块和包
- en: 'Modules are used to create new namespaces. In Julia, creating a module is as
    simple as wrapping your code around a module block, like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 模块用于创建新的命名空间。在 Julia 中，创建模块就像将你的代码包裹在一个模块块中一样简单，如下所示：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In general, modules are created for the purpose of sharing and reuse, and the
    best way to achieve this is to organize code in Julia packages. A Julia package
    is a directory and file structure for maintaining module definitions, test scripts,
    documentation, and related data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模块是为了共享和重用而创建的，实现这一点的最佳方式是将代码组织在 Julia 包中。一个 Julia 包是一个用于维护模块定义、测试脚本、文档和相关数据的目录和文件结构。
- en: There is a standard directory structure and convention for Julia packages; however,
    it would be a hassle to manually configure a new program in the same structure
    every single time. Fortunately, there are some open source tools that automatically
    create the structure for a new package. Without officially endorsing any specific
    tool, I have chosen the `PkgTemplates` package for demonstration, as follows.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 包有一个标准的目录结构和约定；然而，每次手动配置相同结构的新程序都会很麻烦。幸运的是，有一些开源工具可以自动为新包创建结构。虽然不正式推荐任何特定的工具，但我选择了
    `PkgTemplates` 包进行演示，如下所示。
- en: 'If you have not installed the `PkgTemplates` package before, it can be installed
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有安装 `PkgTemplates` 包，可以按照以下方式安装：
- en: '![](img/177bd713-5ae8-47e5-ab7b-67e5ff272b4c.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/177bd713-5ae8-47e5-ab7b-67e5ff272b4c.png)'
- en: 'Once it is installed, we can use it to create our sample module. The first
    step is to create a `Template` object, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以用它来创建我们的示例模块。第一步是创建一个 `Template` 对象，如下所示：
- en: '![](img/eb89662a-b5ca-41e7-ae6a-a7a2de47d8b1.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb89662a-b5ca-41e7-ae6a-a7a2de47d8b1.png)'
- en: Basically, the `template` object contains some default values that will be used
    to create new packages. Then, creating a new package is easy as calling the `generate`
    function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`template` 对象包含一些默认值，这些值将用于创建新包。然后，创建新包就像调用 `generate` 函数一样简单。
- en: '![](img/034a707f-5a03-497d-8f2f-27f698a6c75a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/034a707f-5a03-497d-8f2f-27f698a6c75a.png)'
- en: By default, the package generator creates the new directory in the `~/.julia/dev` folder,
    but it is customizable with the `dir` keyword argument of the `Template` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，包生成器在 `~/.julia/dev` 文件夹中创建新目录，但可以使用 `Template` 对象的 `dir` 关键字参数进行自定义。
- en: 'The `generate` command is used to create a new package called `Calculator`.
    It automatically creates a directory with the following package structure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate` 命令用于创建一个名为 `Calculator` 的新包。它将自动创建一个具有以下包结构的目录：'
- en: '![](img/835fcfff-df65-4c60-aa95-ae1f86787a7f.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/835fcfff-df65-4c60-aa95-ae1f86787a7f.png)'
- en: At this time, you can start editing the `Calculator.jl` file and replace the
    file contents with your own source code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始编辑 `Calculator.jl` 文件，并用你自己的源代码替换文件内容。
- en: If you are new to Julia, make sure that you check out the `Revise` package,
    which allows you to edit source code and have your working environment updated
    automatically. Your productivity using Julia will be increased by a factor of
    10, guaranteed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触 Julia，请确保查看 `Revise` 包，它允许你编辑源代码并自动更新工作环境。使用 Julia 的生产力将提高 10 倍，这是有保证的。
- en: 'Let''s work on the `Calculator` module by implementing some financial calculations.
    Over the course of this example, we will learn how to manage the accessibility
    of variables and functions from external clients. Our initial code is set up as
    follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一些财务计算来工作在 `Calculator` 模块上。在这个过程中，我们将学习如何管理外部客户端对变量和函数的可访问性。我们的初始代码设置如下：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code should be saved to the `Calculator.jl` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该保存到 `Calculator.jl` 文件中。
- en: Defining functional behavior
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义功能行为
- en: 'Our `Calculator` module defines two functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Calculator` 模块定义了两个函数：
- en: The `interest` function is used to calculate the interest for a deposit amount,
    `amount`, with the specified interest rate, `rate`, for a full investment period.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interest` 函数用于计算存款金额 `amount` 的利息，该利息具有指定的利率 `rate`，用于整个投资期。'
- en: The `rate` function is used to calculate the interest rate for which you can
    invest the deposit amount, `amount`, and receive the interest amount, `interest`.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate` 函数用于计算可以投资存款金额 `amount` 并获得利息金额 `interest` 的利率。'
- en: Remember that *interest* and *rate* may mean completely different things outside
    the context of Calculator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 `Calculator` 的上下文之外，*interest* 和 *rate* 可能意味着完全不同的事情。
- en: Exporting functions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出函数
- en: 'Functions defined inside a module are not exposed to the outside world. To
    expose them, the `interest` and `rate` functions can be exported using the `export`
    statement, so that users of this module can easily bring them into their own namespace:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部定义的函数不会暴露给外部世界。为了暴露它们，可以使用 `export` 语句导出 `interest` 和 `rate` 函数，这样模块的使用者就可以轻松地将它们引入自己的命名空间：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the functions are exported, they will be available in the client''s scope
    where the module is loaded with the `using` keyword. Let''s try to reference these
    functions from the Julia REPL before loading the module:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导出函数，它们将在使用 `using` 关键字加载模块的客户端作用域中可用。让我们在加载模块之前尝试从 Julia REPL 引用这些函数：
- en: '![](img/8d3547c1-2da3-459b-ba38-fa4348fb7395.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d3547c1-2da3-459b-ba38-fa4348fb7395.png)'
- en: 'Because we have not loaded the `Calculator` package yet, neither `interest`
    nor `rate` is defined. Let''s bring them in now:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未加载 `Calculator` 包，因此 `interest` 和 `rate` 都未定义。现在让我们将它们引入：
- en: '![](img/8fd33db8-3cc2-4e47-9f4a-8266bf7cb817.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fd33db8-3cc2-4e47-9f4a-8266bf7cb817.png)'
- en: 'When the `using` statement is executed, all symbols exported from the module
    are brought into the current namespace. From the Julia REPL, the current module
    is called `Main`, as shown in the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 `using` 语句时，模块导出的所有符号都会被引入当前命名空间。从 Julia REPL 来看，当前模块被称为 `Main`，如下面的图所示：
- en: '![](img/b733c478-b700-461d-bcf0-98fc25ecf660.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b733c478-b700-461d-bcf0-98fc25ecf660.png)'
- en: 'It is possible for us to bring in a subset of the names by qualifying the `using`
    statement with specific names. Let''s restart the Julia REPL and try again:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `using` 语句中指定特定名称来引入名称的子集。让我们重新启动 Julia REPL 并再次尝试：
- en: '![](img/e97eb30f-7c68-4700-9719-a9fae5a37214.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e97eb30f-7c68-4700-9719-a9fae5a37214.png)'
- en: 'In this case, only the `interest` function was brought into the `Main` module:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有`interest`函数被引入了`Main`模块：
- en: '![](img/f2e18976-1d12-49a5-8efa-3dfc7af6f50d.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2e18976-1d12-49a5-8efa-3dfc7af6f50d.png)'
- en: 'There are actually several ways to import names from another module into the
    current namespace. For the sake of simplicity, we can summarize them as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有几种方法可以将另一个模块中的名称导入当前命名空间。为了简化，我们可以总结如下：
- en: '![](img/18043909-0fa4-4c6b-a480-5684bb7b8a64.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18043909-0fa4-4c6b-a480-5684bb7b8a64.png)'
- en: As you can see, there are four ways (namely, 1, 2, 4, and 5 in the preceding
    table) to bring the `interest` function into the current namespace. There are
    some subtleties in choosing between `using` and `import` statements. A good rule
    of thumb is to use the `using` statement when you are using the functionality,
    but choose the `import` statement when you need to extend the functionality from
    the module. Extending functions from another package is a key language feature
    of Julia, and you will learn more about that from various examples in this book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有四种方法（即前表中的1、2、4和5）可以将`interest`函数引入当前命名空间。在`using`和`import`语句之间进行选择有一些细微差别。一个好的经验法则是当你使用功能时使用`using`语句，但在需要从模块扩展功能时选择`import`语句。从另一个包扩展函数是Julia的关键语言特性之一，你将在本书的各种示例中了解更多关于这一点。
- en: Resolving conflicts
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决冲突
- en: 'The picture, however, is not always rosy. Let''s imagine that the main program
    needs to use another module called `Rater`, which provides rating services for
    online books. In this scenario, the main program may try to take functions from
    both modules, as shown in the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并不总是如此美好。让我们想象一下，主程序需要使用另一个名为`Rater`的模块，该模块为在线书籍提供评级服务。在这种情况下，主程序可能会尝试从两个模块中获取函数，如下所示：
- en: '![](img/d613a4b5-acb6-4b92-9867-1c0497a68c1c.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d613a4b5-acb6-4b92-9867-1c0497a68c1c.png)'
- en: 'But, *Houston, we have a problem!* The `rate` function was brought in from
    the `Calculator` module, but it happens to be in conflict with the other one from
    the `Rater` module. Julia automatically detects this conflict on first use, prints
    a warning, and, from then on, requires the programmer to use their fully qualified
    names to access either function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，*休斯顿，我们遇到麻烦了!* 从`Calculator`模块引入的`rate`函数与来自`Rater`模块的另一个函数发生了冲突。Julia在首次使用时会自动检测这种冲突，打印警告，并且从那时起要求程序员使用它们的完全限定名称来访问任一函数：
- en: '![](img/411c28b3-6330-42cc-8014-97a9a8c37aea.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/411c28b3-6330-42cc-8014-97a9a8c37aea.png)'
- en: 'If you are not happy with this, especially the ugly-looking warning, then there
    is an alternative. First, you can ask yourself whether both `rate` functions are
    actually needed in the main program. If only one `rate` function is needed, then
    just bring one into scope so that there is no more conflict:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此不满意，特别是丑陋的警告，那么有一个替代方案。首先，你可以问问自己是否在主程序中真的需要两个`rate`函数。如果只需要一个`rate`函数，那么只需将其引入作用域，这样就不会再有冲突：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From my experience, bringing specific names into the current namespace is indeed
    the best choice for most use cases. The reason for this is that it will be immediately
    obvious which functions you depend on. Such dependency is also self-documented
    in the code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，将特定名称引入当前命名空间确实是大多数用例的最佳选择。原因在于这将立即清楚地表明你依赖哪些函数。这种依赖关系在代码中也是自我文档化的。
- en: 'Occasionally, you may need to use both `rate` functions. In such cases, you
    can solve the problem by using the regular `import` statement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要同时使用两个`rate`函数。在这种情况下，你可以通过使用常规的`import`语句来解决问题：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This way, it only loads the packages and does not bring any name into the current
    namespace. You can now refer to both `rate` functions with their fully qualified
    names—that is, `Calculator.rate` and `Rater.rate`. After creating these modules,
    let's move on to see how to create submodules.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，它只会加载包，而不会将任何名称引入当前命名空间。现在，你可以使用它们的完全限定名称来引用这两个`rate`函数——即`Calculator.rate`和`Rater.rate`。在创建这些模块之后，让我们继续看看如何创建子模块。
- en: Creating submodules
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子模块
- en: When a module becomes too large, it may make sense to split it into smaller
    parts so that it's easier to develop and maintain. One way to solve this problem
    is to create submodules.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块变得太大时，将其拆分成更小的部分可能是有意义的，这样更容易开发和维护。解决这个问题的方法之一是创建子模块。
- en: 'Creating submodules is convenient as they are just defined within the scope
    of the parent module. Let''s say we organize the `Calculator` module with two
    submodules—`Mortgage` and `Banking`. These submodules can be defined in separate
    files and can be included directly into the parent module. Consider the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子模块很方便，因为它们只是在父模块的作用域内定义。假设我们使用两个子模块——`Mortgage`和`Banking`来组织`Calculator`模块。这些子模块可以在单独的文件中定义，并且可以直接包含到父模块中。考虑以下代码：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Submodules, just like regular modules, are also defined using module blocks. The
    source code for `Mortgage` looks just like a regular module definition:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块，就像常规模块一样，也是使用模块块定义的。`Mortgage`的源代码看起来就像一个常规模块定义：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because the source code from `Mortgage` is included inside the `Calculator` module
    block, it forms a nested structure. The usage of submodules is the same as that
    of any regular module, except that you have to reference them via the parent module.
    In this case, you'd use `Calculator.Mortgage` or `Calculator.Banking`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Calculator`模块块中包含了`Mortgage`的源代码，因此它形成了一个嵌套结构。子模块的使用与任何常规模块相同，只是你必须通过父模块来引用它们。在这种情况下，你会使用`Calculator.Mortgage`或`Calculator.Banking`。
- en: Using submodules is an effective way to separate code for larger codebases.
    Next, we will go over how to organize source code in a module.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子模块是分离大型代码库代码的有效方法。接下来，我们将介绍如何在模块中组织源代码。
- en: Organizing files in a module
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模块中组织文件
- en: 'The source code for modules is typically organized as multiple source files.
    Although there is no hard and fast rule about how source files are organized,
    the following are useful guidelines:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的源代码通常组织为多个源文件。尽管没有关于如何组织源文件的硬性规则，但以下是一些有用的指导原则：
- en: '**Coupling**: Highly coupled functions should be placed in the same file. Doing
    so allows less context switching when editing source files. For example, when
    you change the signature of a function, all callers of that function may need
    to be updated. Ideally, you would want to minimize the *blast radius* and not
    have to change many files.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耦合度**：高度耦合的函数应放在同一个文件中。这样做可以在编辑源文件时减少上下文切换。例如，当你更改一个函数的签名时，该函数的所有调用者可能都需要更新。理想情况下，你希望最小化*影响范围*，并且不需要更改许多文件。'
- en: '**File size**: Having more than a few hundred lines of code in a single file
    could be a warning sign. If the code inside the file is all tightly coupled, then
    it may be better to redesign the system to reduce coupling.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件大小**：一个文件中包含超过几百行代码可能是一个警告信号。如果文件内的代码都是紧密耦合的，那么可能最好重新设计系统以减少耦合度。'
- en: '**Ordering**:Julia loads the source files in the order in which you include
    them. As data types and utility functions are usually shared, it is better to
    save them in a `types.jl` and `utils.jl` file respectively and include them at
    the beginning of the module.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：Julia按照你包含它们的顺序加载源文件。由于数据类型和实用函数通常是共享的，因此最好将它们分别保存在`types.jl`和`utils.jl`文件中，并在模块的开始处包含它们。'
- en: Similarly, the same considerations apply when organizing test scripts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在组织测试脚本时，也应考虑相同的因素。
- en: By now, we have learned how to create new namespaces using modules and submodules.
    More conveniently, a module is organized in a package so that it can be reused
    from an application. Once we have created multiple packages, it is unavoidable
    that they may have to depend on each other. It is important that we know how to
    handle these dependencies properly; this will be our primary topic in the next
    section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何使用模块和子模块创建新的命名空间。更方便的是，模块被组织在一个包中，这样它就可以在应用程序中被重用。一旦我们创建了多个包，它们之间相互依赖是不可避免的。了解如何正确处理这些依赖关系非常重要；这将是下一节的主要内容。
- en: Managing package dependencies
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理包依赖
- en: The Julia ecosystem has a rich set of open source packages. When packages are
    designed with a single objective, they can be reused more easily; however, working
    with a large codebase is not an easy task because it is more likely to depend
    on third-party packages. It takes a considerable amount of time and effort for
    a developer to maintain and manage these dependencies in order to avoid *dependency
    hell.*
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Julia生态系统有一套丰富的开源包。当包设计有一个单一目标时，它们可以更容易地被重用；然而，处理大型代码库并不是一件容易的事情，因为它更有可能依赖于第三方包。开发者需要花费相当多的时间和精力来维护和管理这些依赖关系，以避免*依赖地狱*。
- en: It is important to understand that dependencies exist not just between packages,
    but also between specific versions of packages. Luckily, the Julia language has
    strong support for semantic versioning, which can help solve a lot of problems.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，依赖关系不仅存在于包之间，还存在于特定版本的包之间。幸运的是，Julia语言对语义版本控制有很强的支持，这可以帮助解决很多问题。
- en: 'In this section, we will cover the following topics:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下主题：
- en: Understanding the semantic versioning scheme
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解语义版本控制方案
- en: Specifying dependencies for Julia packages
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定Julia包的依赖项
- en: Avoiding circular dependencies
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免循环依赖
- en: Now, let's take a quick look at the semantic versioning scheme.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速了解一下语义版本控制方案。
- en: Understanding the semantic versioning scheme
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解语义版本控制方案
- en: Semantic versioning ([https://semver.org/](https://semver.org/)) is a scheme
    developed by Tom Preston-Werner, most famously known as the co-founder and CTO
    of GitHub. Semantic versioning serves a very specific purpose, which is to provide
    the meaning—that is, the semantics—of version number changes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制([https://semver.org/](https://semver.org/))是由Tom Preston-Werner开发的方案，他最著名的是GitHub的联合创始人和CTO。语义版本控制服务于一个非常具体的目的，即为版本号变化提供意义——即语义。
- en: When we use a third-party package and it is upgraded, how do we know whether
    our application needs to be updated? What kind of risk are we taking if we just
    upgrade the dependent package without doing any testing with our own application?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用第三方包并且它被升级时，我们如何知道我们的应用程序是否需要更新？如果我们只是升级依赖包而不对我们的应用程序进行任何测试，我们将承担什么样的风险？
- en: Before semantic versioning, it was almost always a guess. A more diligent and
    risk-averse developer, however, would at least examine the release notes of the
    dependent package, try to figure out whether there are any breaking changes, then
    take proper actions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义版本控制之前，几乎总是猜测。然而，一个更加勤奋且风险规避的开发者至少会检查依赖包的发布说明，试图找出是否有任何破坏性更改，然后采取适当的行动。
- en: 'Here, we will quickly summarize how semantic versioning works. First of all,
    a version number is constructed using the following components:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将简要总结语义版本控制是如何工作的。首先，版本号是由以下组件构成的：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we wish, the version number can be followed by a release tag and a build
    number at the end:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，版本号可以在末尾后跟一个发布标签和一个构建号：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Every part of the version number reveals a meaning:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 版本号的每一部分都揭示了其含义：
- en: The `major` release number, when changed, means that a major change has been
    introduced in this release that is incompatible with the previous release. It
    is highly risky for applications to incorporate the new release as existing functions
    will likely break.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`主要`版本号发生变化时，意味着在这个版本中引入了与上一个版本不兼容的重大更改。对于应用程序来说，引入新版本的风险非常高，因为现有的功能很可能会中断。
- en: The `minor` release number, when changed, means that there are nonbreaking enhancements
    in this release. It is moderately risky for applications to incorporate the new
    release because previous functions should, at least in theory, continue to work
    as they are.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`次要`版本号发生变化时，意味着在这个版本中有非破坏性的增强。对于应用程序来说，引入新版本的风险是适度的，因为之前的函数至少在理论上应该继续按原样工作。
- en: The `patch `release number, when changed, means that there are nonbreaking bug
    fixes in this release. The risk is low for applications to incorporate the new
    release.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`补丁`版本号发生变化时，意味着在这个版本中有非破坏性的错误修复。对于应用程序来说，引入新版本的风险是低的。
- en: The `pre-release` tag, when present, indicates a pre-release candidate, such
    as alpha, beta, or **release candidates** (**RCs**). The release is considered
    unstable and applications should never use it in a production environment.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存在时，`预发布`标签表示预发布候选，如alpha、beta或**发布候选**（**RCs**）。该发布被视为不稳定，应用程序永远不应该在生产环境中使用它。
- en: The `build` tag is considered to be meta information and can be ignored.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`构建`标签被视为元信息，可以忽略。'
- en: Note that semantic versioning is only useful when all packages use it properly.
    Semantic versioning is like a common language that package developers can use
    to easily indicate the impact of their changes when making new releases.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有当所有包都正确使用语义版本控制时，它才有用。语义版本控制就像是一种通用语言，包开发者可以使用它来轻松地表明他们在发布新版本时所做的更改的影响。
- en: The Julia package ecosystem encourages semantic versioning. Next, we will take
    a look at how the Julia package manager, `Pkg`, handles dependencies using semantic
    versioning.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Julia包生态系统鼓励使用语义版本控制。接下来，我们将看看Julia包管理器`Pkg`如何使用语义版本控制处理依赖项。
- en: While Julia encourages semantic versioning, many open source packages still
    have a pre-1.0 version number, even though they can be quite stable for production
    use. A major version number of zero is special—it basically means that every new
    release is breaking.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Julia鼓励使用语义版本控制，但许多开源包仍然带有1.0之前的版本号，尽管它们在生产使用中可能相当稳定。零主版本号是特殊的——它基本上意味着每个新版本都是破坏性的。
- en: As the Julia language matures, more package authors will mark their packages
    as 1.0, and the situation regarding package compatibility will get better over
    time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Julia语言的成熟，越来越多的包作者将他们的包标记为1.0，随着时间的推移，包兼容性问题将会得到改善。
- en: Specifying dependencies for Julia packages
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Julia包指定依赖项
- en: We can tell when a package depends on another by examining the `using` or `import`
    keywords in the source files; however, the Julia runtime environment is designed to
    be more explicit by tracking the dependencies. Such information is stored in the
    `Project.toml` file in the package directory. In addition, a `Manifest.toml` file
    in the same directory contains more information about the complete dependency
    tree. These files are written in the TOML file format. Although it is easy enough
    to edit these files by hand, the `Pkg` package manager's **command-line interface**
    (**CLI**) could be used to manage dependencies more easily.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查源文件中的 `using` 或 `import` 关键字来判断一个包是否依赖于另一个包；然而，Julia运行时环境被设计为更明确，通过跟踪依赖项。此类信息存储在包目录中的
    `Project.toml` 文件中。此外，同一目录下的 `Manifest.toml` 文件包含了关于完整依赖树的更多信息。这些文件使用TOML文件格式编写。尽管手动编辑这些文件足够简单，但可以使用
    `Pkg` 包管理器的**命令行界面**（**CLI**）更轻松地管理依赖项。
- en: 'To add a new dependent package, you just need to carry out the following steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个新的依赖包，你只需要执行以下步骤：
- en: Start the Julia REPL.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Julia交互式解释器。
- en: Enter `Pkg` mode by pressing the `]` key.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 `]` 键进入 `Pkg` 模式。
- en: Activate the project environment using the `activate` command.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `activate` 命令激活项目环境。
- en: Add the dependent package using the `add` command.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `add` 命令添加依赖包。
- en: 'For example, let''s add the `SaferIntegers` package to our `Calculator` package
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们按照以下方式将 `SaferIntegers` 包添加到我们的 `Calculator` 包中：
- en: '![](img/e8c5fc8f-485e-42e0-a194-598c14a5c072.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8c5fc8f-485e-42e0-a194-598c14a5c072.png)'
- en: 'Let''s first examine the contents of the `Project.toml` file, as shown in the
    following screenshot. The funny-looking hash code `88634af6-177f-5301-88b8-7819386cfa38`
    represents the **universal unique identifier** (**UUID**) of the `SaferIntegers`
    package. Note that there is no version number specified for the `SaferIntegers`
    package, even though we know version 2.5.0 was installed from the preceding output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查一下 `Project.toml` 文件的内容，如下所示截图所示。这个看起来很奇怪的哈希码 `88634af6-177f-5301-88b8-7819386cfa38`
    代表了 `SaferIntegers` 包的**通用唯一标识符**（**UUID**）。请注意，`SaferIntegers` 包没有指定版本号，尽管我们知道从前面的输出中安装了版本2.5.0：
- en: '![](img/778c2259-af10-43c5-99e8-e53da5bf2a96.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/778c2259-af10-43c5-99e8-e53da5bf2a96.png)'
- en: 'The `Manifest.toml` file contains the complete dependency tree of the package.
    First, we find the following section regarding our `SaferIntegers` dependency:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Manifest.toml` 文件包含了该包的完整依赖树。首先，我们找到以下关于我们的 `SaferIntegers` 依赖项的部分：'
- en: '![](img/60ef38e3-b502-4fd8-8ebc-1b217dd07336.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60ef38e3-b502-4fd8-8ebc-1b217dd07336.png)'
- en: 'Note that the `SaferIntegers` package now has a specific version. `2.5.0`,
    in the manifest file. Why? It''s because the manifest is designed to capture the
    exact version information for all directly dependent *and* indirectly dependent
    packages. A second observation is that officially bundled packages, such as `Serialization`,
    `Sockets`, and `Test`, do not carry version numbers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`SaferIntegers` 包现在在清单文件中有特定的版本。`2.5.0`。为什么？这是因为清单被设计用来捕获所有直接依赖和间接依赖包的确切版本信息。第二个观察结果是，官方捆绑的包，如
    `Serialization`、`Sockets` 和 `Test`，没有版本号：
- en: '![](img/7d0528b9-751f-476d-b2fd-1d2edb42a5b5.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d0528b9-751f-476d-b2fd-1d2edb42a5b5.png)'
- en: These packages do not have version numbers because they are always released
    with the Julia binary. Their actual versions are pretty much determined by the
    specific Julia version.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包没有版本号，因为它们总是与Julia二进制文件一起发布。它们的实际版本基本上由特定的Julia版本决定。
- en: 'It is important to realize that neither `Project.toml` and `Manifest.toml`
    contains any versioning compatibility information, even though we know version
    2.5.0 of `SaferInteger` was installed. To specify compatibility constraints, we
    can manually edit the `Project.toml` file using the semantic versioning scheme.
    For example, if we know that `Calculator` is compatible with `SaferIntegers` version
    1.1.1 and later, then we can add this requirement to the `[compat]` section of
    the `Project.toml` file, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，尽管我们知道安装了`SaferInteger`的版本2.5.0，但`Project.toml`和`Manifest.toml`文件中都不包含任何版本兼容性信息。为了指定兼容性约束，我们可以使用语义版本控制方案手动编辑`Project.toml`文件。例如，如果我们知道`Calculator`与`SaferIntegers`版本1.1.1及以后兼容，那么我们可以在`Project.toml`文件的`[compat]`部分添加此要求，如下所示：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This compatibility setting provides the necessary information for the Julia
    package manager to ensure that at least `SaferIntegers` version 1.1.1 is installed
    in order to use the `Calculator` package. Since the package manager is sensitive
    to semantic versioning, the preceding setting means that `Calculator` can work
    with all versions of `SaferIntegers` from 1.1.1 to the latest 1.*x*.*y* version,
    right up to 2.0\. In mathematical notation, the range of compatible versions is
    [1.1.1, 2.0.0), where 2.0.0 is excluded.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此兼容性设置提供了Julia包管理器所需的信息，以确保至少安装了`SaferIntegers`版本1.1.1，以便使用`Calculator`包。由于包管理器对语义版本控制敏感，前面的设置意味着`Calculator`可以与从1.1.1到最新1.*x*.*y*版本的所有`SaferIntegers`版本一起工作，直到2.0。在数学表示法中，兼容版本的范围是[1.1.1,
    2.0.0)，其中2.0.0被排除。
- en: Now, what if `SaferIntegers` is improved and the package owner decides to release
    2.0.0? Well, because the major version number has advanced from 1 to 2, we have
    to expect breaking changes. If we don't do anything, the latest version, 2.0.0,
    will never be installed in the `Calculator` environment because we specifically
    implemented an exclusive upper bound of 2.0.0.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设`SaferIntegers`得到了改进，并且包所有者决定发布2.0.0版本？嗯，因为主版本号从1提升到了2，我们不得不期待会有破坏性变化。如果我们不采取任何行动，最新的版本2.0.0将永远不会安装到`Calculator`环境中，因为我们明确实现了2.0.0的排他性上限。
- en: 'Let''s say that, after thorough examination and testing, we conclude that `Calculator`
    is not affected by any breaking changes from `SaferIntegers` 2.0.0\. In that case,
    we can just make a small change to our `Project.toml` file, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 假设经过彻底的审查和测试，我们得出结论，`Calculator`不受`SaferIntegers` 2.0.0的任何破坏性变化的影响。在这种情况下，我们只需对`Project.toml`文件进行微小修改，如下所示：
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This line specifies the *union* of these two compatible version ranges:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行指定了这两个兼容版本范围的**并集**：
- en: The `1.1.1` specification indicates that the package is compatible with `SaferIntegers`
    versions [1.1.1, 2.0.0]
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.1.1`指定表示该包与`SaferIntegers`版本[1.1.1, 2.0.0]兼容'
- en: The `2.0` specification indicates that the package is compatible with `SaferIntegers`
    versions [2.0.0, 3.0.0]
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.0`指定表示该包与`SaferIntegers`版本[2.0.0, 3.0.0]兼容'
- en: Such information is important. If the `Calculator` package is used by someone
    who has an environment pinned to `SaferIntegers` version 1.1.1, then we know that
    `Calculator` is still compatible in that environment and can be loaded in it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的信息很重要。如果有人使用`Calculator`包，并且其环境锁定在`SaferIntegers`版本1.1.1，那么我们知道`Calculator`在该环境中仍然兼容，并且可以加载它。
- en: The package manager is actually very flexible, and it implements a few more
    version-specifier formats. You can refer to of `Pkg` reference manual for more
    information ([https://julialang.github.io/Pkg.jl/v1/compatibility/#Version-specifier-format-1](https://julialang.github.io/Pkg.jl/v1/compatibility/#Version-specifier-format-1)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器实际上非常灵活，并实现了几种更多的版本指定格式。您可以参考`Pkg`参考手册了解更多信息（[https://julialang.github.io/Pkg.jl/v1/compatibility/#Version-specifier-format-1](https://julialang.github.io/Pkg.jl/v1/compatibility/#Version-specifier-format-1)）。
- en: It is important to specify compatibility between packages. By using the `Pkg`
    interface and editing the `Project.toml` file manually, we can manage dependencies
    properly, and the package manager will help us maintain the working environment
    in working order.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 指定包之间的兼容性很重要。通过使用`Pkg`接口和手动编辑`Project.toml`文件，我们可以正确管理依赖关系，并且包管理器将帮助我们保持工作环境处于良好状态。
- en: However, sometimes, we may run into tricky dependency issues—for example, circular
    dependencies. We will look at how to handle such situations next.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们可能会遇到棘手的依赖性问题——例如，循环依赖。我们将在下一节中探讨如何处理此类情况。
- en: Avoiding circular dependencies
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免循环依赖
- en: Circular dependencies are problematic. To understand why, consider the following
    example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖是有问题的。为了理解为什么，考虑以下示例。
- en: 'Let''s say we have five packages (A, B, C, D, and E) with the following dependencies:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有五个包（A、B、C、D和E），它们具有以下依赖关系：
- en: A depends on B and C
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A依赖于B和C
- en: C depends on D and E
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C依赖于D和E
- en: E depends on A
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E依赖于A
- en: To illustrate these graphically, we can create a diagram where we can use an
    arrow notation to indicate dependencies between components. The direction of the
    arrow indicates the direction of the dependency.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了图形化地说明这些，我们可以创建一个图表，其中我们可以使用箭头符号来表示组件之间的依赖关系。箭头的方向表示依赖的方向。
- en: '![](img/7e342d9b-ae0c-4d31-898c-90aa805106e9.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e342d9b-ae0c-4d31-898c-90aa805106e9.png)'
- en: What's the problem?
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: Clearly there is a cycle, as A depends on C, C depends on E, and E depends on
    A. What is the problem with a cycle like this? Say that you have to make a change
    in package C that is supposed to be backward-compatible. To properly test the
    system with this change, we must make sure that C continues to have proper functionality
    given its dependencies. Now, if we trace this down the dependency chain, we must
    test C with D and E, and as E depends on A, we must include A as well. Now that
    A is included, we must include B and C. Because of the cycle, we now have to test
    all of the packages!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，存在一个循环，因为A依赖于C，C依赖于E，而E又依赖于A。这种循环有什么问题呢？假设你需要在包C中进行一个应该向后兼容的更改。为了正确测试这个更改后的系统，我们必须确保C在其依赖项的条件下继续具有适当的功能。现在，如果我们沿着依赖链追踪，我们必须用D和E测试C，因为E依赖于A，所以我们必须包括A。现在A被包括在内，我们必须包括B和C。由于循环的存在，我们现在必须测试所有包！
- en: How do we fix this?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？
- en: The *acyclic dependency principle* states that dependencies between packages
    must be a **directed acyclic graph** (**DAG**)—that is, the dependency graph must
    have no cycle. If we do see a cycle in the graph, then it is a sign of a design
    problem.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*无环依赖原则*指出，包之间的依赖必须是**有向无环图**（DAG）——也就是说，依赖图必须没有环。如果我们确实在图中看到了环，那么这是一个设计问题的迹象。'
- en: When we encounter such a problem, we must refactor the code so that the specific
    dependent function is moved to a separate package. In this example, suppose that
    there's some code in package A that is used by the package internally and also
    used by package E. This dependency is basically E -> A.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到这样的问题时，我们必须重构代码，以便将特定的依赖函数移动到单独的包中。在这个例子中，假设包A中有些代码被包内部使用，同时也被包E使用。这种依赖基本上是E
    -> A。
- en: 'We can then take this code and move it to a new package F. After this change,
    packages A and E would both depend on package F, effectively removing the cyclic
    dependency:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将此代码移动到新的包F中。在此更改之后，包A和E都将依赖于包F，从而有效地消除循环依赖：
- en: '![](img/bace0bad-d9f9-42a8-96f2-5f798342b34a.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bace0bad-d9f9-42a8-96f2-5f798342b34a.png)'
- en: After this refactoring, when we make changes to C, we can just test the package
    with its dependencies, which would be D, E, and F only. Packages A and B can both
    be excluded.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在此重构之后，当我们对C进行更改时，我们只需测试带有其依赖项的包，这将仅限于D、E和F。包A和B都可以排除。
- en: In this section, we learned how to leverage semantic versioning to clearly communicate
    the impact of new versions of a package. We can use the `Project.toml` file to
    specify the compatibility of the current package with its dependent packages.
    We also reviewed a technique for resolving circular dependencies.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何利用语义版本控制来清楚地传达包新版本的影响。我们可以使用`Project.toml`文件来指定当前包与其依赖包的兼容性。我们还回顾了解决循环依赖的技术。
- en: Now we know this, we will look into how to design and develop data types in
    Julia.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这个，我们将探讨如何在Julia中设计和开发数据类型。
- en: Designing abstract and concrete types
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计抽象和具体类型
- en: Julia's type system is the foundation of many of its language features, such
    as multiple dispatches. In this section, we will learn about both abstract types
    and concrete types, how to design and use them, and how they are different from
    other mainstream object-oriented programming languages.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的类型系统是其许多语言特性的基础，例如多分派。在本节中，我们将了解抽象类型和具体类型，以及如何设计和使用它们，以及它们与其他主流面向对象编程语言的不同之处。
- en: 'In this section, we will cover the following topics:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下主题：
- en: Designing abstract types
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计抽象类型
- en: Designing concrete types
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计具体类型
- en: Understanding `isa` and `<:` operators
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`isa`和`<:`运算符
- en: Understanding the difference between abstract and concrete types
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象类型和具体类型之间的区别
- en: Let's first take a look at abstract types.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看抽象类型。
- en: Designing abstract types
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计抽象类型
- en: Similar to many other objected-oriented programming languages, Julia supports
    a hierarchy of abstract types. Abstract types are typically used to model real-world
    data concepts; for example, an `Animal` could be an abstract type for a cat or
    dog, and a `Vehicle` can be an abstract type for a car, truck, or bus. Being able
    to group types together and give the group a single name allows Julia programmers
    to apply generic code that is common to those types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他面向对象编程语言类似，Julia支持抽象类型的层次结构。抽象类型通常用于建模现实世界的数据概念；例如，`Animal`可以是一个猫或狗的抽象类型，而`Vehicle`可以是一个汽车、卡车或公共汽车的抽象类型。能够将类型分组并给这个组一个单一的名字，使得Julia程序员可以应用适用于这些类型的通用代码。
- en: Abstract types are often conveniently defined in a type hierarchy for a specific
    domain. We can describe the relationship between abstract types as *parent–child*,
    or more technically, an *is-a-subtype-of* relationship. The terminology for the
    parent type and child type is *supertype* and *subtype* respectively.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型通常方便地定义在特定领域的类型层次结构中。我们可以将抽象类型之间的关系描述为“父-子”，或者更技术性地，一个“是子类型于”的关系。父类型和子类型的术语分别是“超类型”和“子类型”。
- en: A unique feature of Julia's design, unlike the majority of other languages,
    is that abstract types are defined without any fields. For this reason, abstract
    types do not specify how data is actually stored in the memory. It may seem somewhat
    restrictive at first glance, but as we learn more about Julia, it will seem more
    natural when used in this design. As a result, abstract types are used solely
    to model behaviors for a set of objects rather than to specify how data is stored.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Julia设计的一个独特特性，与大多数其他语言不同，是抽象类型在没有任何字段的情况下定义。因此，抽象类型不指定数据实际上是如何存储在内存中的。乍一看可能有些限制，但随着我们对Julia了解得更多，当用于这种设计时，它将显得更加自然。因此，抽象类型仅用于为对象集合建模行为，而不是指定数据是如何存储的。
- en: The Rectangle and Square object model is a classic example of how things can
    break down when an abstract type is allowed to define data fields. Suppose that
    we were able to define a Rectangle with `width` and `height` fields. A Square
    is a kind of Rectangle, so intuitively, we should be able to model Square as a
    subtype of Rectangle. But we soon get into trouble because a square does not need
    two fields to store the length of its sides; we should rather use a single `side
    length` field instead. Therefore, inheriting fields from supertypes makes no sense
    in this case. We will discuss this case with more details in [Chapter 12](97049a94-ad30-452a-bbb0-296d9438c886.xhtml),
    *Inheritance and Variance*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形和正方形对象模型是当允许抽象类型定义数据字段时事物可能崩溃的一个经典例子。假设我们能够定义一个具有`width`和`height`字段的矩形。正方形是一种矩形，所以直观上，我们应该能够将正方形建模为矩形的子类型。但很快我们就遇到了麻烦，因为正方形不需要两个字段来存储其边的长度；我们更应该使用一个单独的`边长`字段。因此，在这种情况下从超类型继承字段是没有意义的。我们将在[第12章](97049a94-ad30-452a-bbb0-296d9438c886.xhtml)“继承和变异性”中更详细地讨论这个案例。
- en: In the following sections, we will work through an example of building an abstract
    type hierarchy.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过一个构建抽象类型层次结构的示例来进行分析。
- en: A personal asset type hierarchy example
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个个人资产类型层次结构的示例
- en: 'Let''s say we are building a financial application that keeps track of a user''s
    wealth, which may include various types of asset. The following diagram shows
    a hierarchy of abstract types and their parent–child relationship. In this design,
    an Asset may be a Property, an Investment, or just Cash types. A Property can
    be a House or an Apartment. An Investment could be FixedIncome or Equity. As a
    convention, in order to indicate that they are abstract types rather than concrete
    types, we have chosen to italicize their names in the boxes:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个财务应用程序，该程序跟踪用户的财富，这可能包括各种类型的资产。以下图表显示了抽象类型及其父-子关系层次结构。在这个设计中，资产可能是一个房产、一项投资，或者仅仅是现金类型。房产可以是房子或公寓。投资可能是固定收益或股票。作为一个惯例，为了表明它们是抽象类型而不是具体类型，我们在框中斜体化了它们的名称：
- en: '![](img/b7da5c2a-c584-4a21-9b10-7f1a79716530.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7da5c2a-c584-4a21-9b10-7f1a79716530.png)'
- en: 'To create an abstract type hierarchy, we can use the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个抽象类型层次结构，我们可以使用以下代码：
- en: '[PRE11]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `<:` symbol represents an *is-a-subtype-of* relationship. So, the `Property`
    type is a subtype of `Asset`, the `Equity` type is a subtype of `Investment`,
    and so on.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`<:`符号代表一个“是子类型于”的关系。所以，`Property`类型是`Asset`的子类型，`Equity`类型是`Investment`的子类型，等等。'
- en: While the `Asset` abstract type seems to be at the top level of the hierarchy
    in reality, it also has a supertype called `Any`, which is implicit when no supertype
    is specified and an abstract type is defined. The `Any` code phrase is the top-level
    supertype in Julia.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在现实中`Asset`抽象类型似乎位于层次结构的顶层，但它还有一个名为`Any`的超类型，当没有指定超类型且定义了抽象类型时是隐含的。`Any`是Julia中的顶级超类型。
- en: Navigating the type hierarchy
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航类型层次结构
- en: 'Julia provides some convenient functions to navigate the type hierarchy. To
    find the subtypes of an existing type, we can use the `subtypes` function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了一些方便的函数来导航类型层次结构。要找到现有类型的子类型，我们可以使用`subtypes`函数：
- en: '![](img/46c834e8-6832-49ec-a7e2-66dec5643acb.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46c834e8-6832-49ec-a7e2-66dec5643acb.png)'
- en: Similarly, to find the supertype of an existing type, we can use the `supertype`
    function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要找到现有类型的超类型，我们可以使用`supertype`函数。
- en: '![](img/870c1fbb-1100-4662-bdce-4cd1780f0767.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/870c1fbb-1100-4662-bdce-4cd1780f0767.png)'
- en: 'Sometimes, it''s convenient to see the complete hierarchy in a tree format.
    Julia comes with no standard function that we can use to achieve this, but we
    can easily create one ourselves using a recursion technique, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，以树形格式查看完整的层次结构很方便。Julia没有提供标准函数供我们使用来实现这一点，但我们可以使用递归技术轻松地自己创建一个，如下所示：
- en: '[PRE12]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function can be quite convenient for new Julia users. In fact, I have the
    code saved in my `startup.jl` file so that it is loaded into the REPL automatically.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数对于新的Julia用户来说可能非常方便。实际上，我已经将代码保存在我的`startup.jl`文件中，以便它可以在REPL启动时自动加载。
- en: The `startup.jl` file is a user-customized script that is located in the `$HOME/.julia/config`
    directory. It can be used to store any code or functions that the user wants to
    run every time the REPL is started.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`startup.jl`文件是一个用户自定义的脚本，位于`$HOME/.julia/config`目录中。它可以用来存储用户希望在REPL每次启动时运行的任何代码或函数。'
- en: 'We can now display the personal asset type hierarchy easily, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以轻松地显示个人资产类型层次结构，如下所示：
- en: '![](img/1512d6f8-9ade-4901-8631-6c4cfce05b6b.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1512d6f8-9ade-4901-8631-6c4cfce05b6b.png)'
- en: Note that this function can only display a hierarchy of types that have already
    been loaded into memory. Now that we have defined abstract types, we should be
    able to associate functions with them. Let's do that next.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此函数只能显示已加载到内存中的类型层次结构。现在我们已经定义了抽象类型，我们应该能够将函数与它们关联起来。让我们接下来这样做。
- en: Defining functions for abstract types
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义抽象类型的函数
- en: So far, all we have done is create a hierarchy of related concepts. With that
    limited knowledge, we can still define some functions to model behaviors. But
    how is this useful when we have no concrete data elements? When dealing with abstract
    types, we could just focus on specific behavior and the possible interaction between
    them. Let's continue with the example and see what kinds of function we can add.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切只是创建了一个相关概念层次结构。有了这些有限的知识，我们仍然可以定义一些函数来模拟行为。但是，当我们没有具体数据元素时，这有什么用呢？在处理抽象类型时，我们只需关注特定的行为以及它们之间可能存在的交互。让我们继续这个例子，看看我们可以添加哪些类型的函数。
- en: Descriptive functions
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述函数
- en: 'Although it does not sound very interesting, we can define functions that are
    solely based on the type itself:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这听起来可能不太有趣，但我们可以定义仅基于类型的函数：
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if we ever call `describe` with a data element that has a supertype of `Property`,
    then the description method for `Property` will be invoked accordingly. As we
    did not define any description function with the `Cash` type, when `describe`
    is called with a `Cash` data element it will return the description from the higher-level
    type, `Asset`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用具有`Property`超类型的数据元素调用`describe`，那么将相应地调用`Property`的描述方法。由于我们没有为`Cash`类型定义任何描述函数，当用`Cash`数据元素调用`describe`时，它将返回更高层次类型`Asset`的描述。
- en: Because we have not defined any concrete types yet, we cannot prove the claim
    here that the `describe` function for a `Cash` object will resort to the `describe(a::Asset) `method.
    As it is a simple thing to do, I encourage the reader to do this as an exercise
    after reading this chapter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未定义任何具体类型，我们无法证明这里关于`Cash`对象的`describe`函数将回退到`describe(a::Asset)`方法的说法。尽管这是一个简单的事情，我鼓励读者在阅读本章后将其作为练习来做。
- en: Functional behavior
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数行为
- en: 'The reason to have a hierarchy is to create an abstraction about common behaviors
    for types. For example, the `Apartment` and `House` types have the same supertype, `Property`.
    This is intentional because they both represent some kind of physical dwelling
    at a certain location. So, we can define a function for any `Property` as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有层次结构的原因是为了创建关于类型常见行为的抽象。例如，`Apartment`和`House`类型有相同的超类型`Property`。这是故意的，因为它们都代表在某个位置上的某种物理住宅。因此，我们可以为任何`Property`定义一个函数，如下所示：
- en: '[PRE14]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may ask, *What have we done?* We have just implemented a function that
    does nothing but return an error! Well, believe it or not, defining this function
    actually serves several purposes:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，*我们做了什么？* 我们刚刚实现了一个什么也不做只是返回错误的函数！好吧，信不信由你，定义这个函数实际上有几个目的：
- en: It makes it clear that any concrete subtype of `Property` must implement the `location` function.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这清楚地表明，任何`Property`的具体子类型都必须实现`location`函数。
- en: At runtime, if the `location` function is not defined for the respective concrete
    type, then this particular function will be called and a reasonable error will
    be thrown so that the programmer can correct the bug.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，如果相应的具体类型没有定义`location`函数，那么这个特定的函数将被调用，并抛出一个合理的错误，以便程序员可以纠正错误。
- en: The document string right above the function definition contains a useful description
    that concrete subtypes of `Property` should implement.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数定义上方紧邻的文档字符串包含了一个有用的描述，说明`Property`的具体子类型应该实现什么。
- en: 'Alternatively, we can define an empty function instead:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以定义一个空函数：
- en: '[PRE15]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What is the difference between an empty function and one that throws an error?
    For this empty function, there will be no runtime error if the concrete type does
    not implement this function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 空函数和抛出错误的函数之间有什么区别？对于这个空函数，如果具体类型没有实现这个函数，则不会出现运行时错误。
- en: Interaction between objects
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象之间的交互
- en: 'It is also useful to define interactions between abstract types. Now that we
    know that every `Property` should have a location, we can define a function that
    calculates the walking distance between any two properties, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 定义抽象类型之间的交互也是有用的。既然我们知道每个`Property`都应该有一个位置，我们可以定义一个函数来计算任意两个属性之间的步行距离，如下所示：
- en: '[PRE16]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The logic completely lives in the abstract types! We have not even defined any
    concrete types, and yet we are able to develop generic code that works for any
    concrete subtypes of `Property` going forward.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑完全存在于抽象类型中！我们甚至还没有定义任何具体类型，但我们仍然能够开发出适用于`Property`任何具体子类型的通用代码。
- en: The power of the Julia language allows us to define these behaviors at this level
    of abstraction. For a moment, let's imagine what we would have to do if we were
    not allowed to define functions at this level and could only implement logic with
    specific concrete types. In this case, we would have to define a separate `walking_distance`
    function for every combination of different types of properties. It would be too
    mundane and boring for programmers!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Julia语言的力量允许我们在这一抽象级别定义这些行为。让我们想象一下，如果我们不允许在这一级别定义函数，而只能使用特定的具体类型实现逻辑，我们会做什么。在这种情况下，我们必须为不同类型属性的每一种组合定义一个单独的`walking_distance`函数。这对程序员来说将是过于平凡和无聊的！
- en: Now that we understand how abstract types work, let's continue our journey and
    take a look at how to create concrete types in Julia.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了抽象类型的工作原理，让我们继续我们的旅程，看看如何在Julia中创建具体类型。
- en: Designing concrete types
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计具体类型
- en: 'A concrete type is used to define how data is organized. In Julia, there are
    two kinds of concrete type:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类型用于定义数据是如何组织的。在Julia中，有两种类型的具体类型：
- en: Primitive type
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型
- en: Composite type
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合类型
- en: Primitive types carry pure bits. Julia's `Base` package comes with a variety
    of primitive types—signed/unsigned integers that are 8-, 16-, 32-, 64-, or 128-bits
    wide. Currently, Julia only supports primitive types with numbers of bits that
    are multiples of 8\. For example, it is possible to define a 256-bit integer type
    (32 bytes) if we have a use case that requires very large integers. How to do
    this is outside the scope of this book. If you feel that this is an interesting
    project, you can consult Julia's source code on GitHub and see how existing primitive
    types are implemented. The Julia language is indeed largely written in Julia itself!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型携带纯比特。Julia的`Base`包包含各种基本类型——8位、16位、32位、64位或128位的有符号/无符号整数。目前，Julia只支持位数是8的倍数的基本类型。例如，如果我们有一个需要非常大的整数的用例，我们可以定义一个256位整数类型（32字节）。如何做到这一点超出了本书的范围。如果你觉得这是一个有趣的项目，你可以查阅GitHub上的Julia源代码，看看现有的基本类型是如何实现的。事实上，Julia语言的大部分代码是用Julia本身编写的！
- en: Composite types are defined by a set of named fields. Grouping fields into a
    single type allows easier reasoning, sharing, and manipulation. Composite types
    may be designated a specific supertype or defaulted to `Any`. Fields can also
    be annotated with their own types, if you wish, and types can be either abstract
    or concrete. When type information is absent for fields, they default to `Any`,
    which means that the field can hold objects of any type.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型由一组命名字段定义。将字段分组到单个类型中可以更容易地进行推理、共享和操作。复合类型可以指定一个特定的超类型或默认为`Any`。字段也可以根据需要注解其自己的类型，类型可以是抽象的或具体的。当字段的类型信息不存在时，它们默认为`Any`，这意味着该字段可以持有任何类型的对象。
- en: We will focus on composite types in this section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中重点关注复合类型。
- en: Designing composite types
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计复合类型
- en: 'Composite types are defined with the `struct` keyword. Let''s carry on the
    example from the preceding abstract type section and continue building our personal
    asset type hierarchy. We will now create a concrete type called `Stock` as a subtype
    of `Equity`. To keep things simple, we will just represent a stock as a trading
    symbol and the name of the company:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型使用`struct`关键字定义。让我们继续从上一个抽象类型部分中的例子，并继续构建我们的个人资产类型层次结构。现在，我们将创建一个名为`Stock`的具体类型，作为`Equity`的子类型。为了保持简单，我们只需将股票表示为交易符号和公司名称：
- en: '[PRE17]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can instantiate a composite type using the standard constructor, which just
    takes all the fields as an argument:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准构造函数实例化复合类型，它只需将所有字段作为参数：
- en: '![](img/545e24c6-ce93-4e1c-b2f9-686f0dd99ca2.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/545e24c6-ce93-4e1c-b2f9-686f0dd99ca2.png)'
- en: 'Now, since `Stock` is a subtype of `Equity`, which is a subtype of `Investment`,
    which in turn is a subtype of `Asset`, we should obey the *contract* that we set
    forth earlier by defining the `describe` function:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`Stock`是`Equity`的子类型，而`Equity`又是`Investment`的子类型，`Investment`又是`Asset`的子类型，因此我们应该遵守我们之前提出的*契约*，通过定义`describe`函数：
- en: '[PRE18]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `describe` function just returns a string representation of the stock with
    both the trading symbol and company name.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`函数只是返回股票的字符串表示，包括交易符号和公司名称。'
- en: Immutability
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: 'Composite types are by default immutable. This means that their fields are
    not changeable after the object is created. Immutability is a good thing as it
    eliminates surprises when system behavior changes unexpectedly because of data
    modification. We can easily prove that the concrete `Stock` type that we created
    in the last section is immutable:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型默认是不可变的。这意味着在对象创建后，它们的字段不可更改。不可变性是好事，因为它消除了由于数据修改而意外改变系统行为时的惊喜。我们可以轻松证明我们在上一节中创建的具体`Stock`类型是不可变的：
- en: '![](img/4f1204bf-2ab9-42db-9062-f702f1ff2902.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f1204bf-2ab9-42db-9062-f702f1ff2902.png)'
- en: 'That''s great! Now, the immutability guarantee actually stops at the field
    level. If the type contains a field and the field''s own type is mutable, then
    changing the underlying data is allowed. Let''s try a different example by creating
    a new composite type called `BasketOfStocks`, which is used to hold a vector (that
    is, a one-dimensional array) of stocks and the reason that we are holding them:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 那太好了！现在，不可变性的保证实际上只到字段级别。如果一个类型包含一个字段，并且该字段的类型是可变的，那么改变底层数据是被允许的。让我们通过创建一个新的复合类型`BasketOfStocks`来尝试一个不同的例子，这个类型用于存储股票的向量（即一维数组）以及我们持有它们的原因：
- en: '[PRE19]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s just create an object for testing:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只创建一个对象进行测试：
- en: '![](img/0d66f128-0e67-49d1-98a0-fd4dad278a33.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d66f128-0e67-49d1-98a0-fd4dad278a33.png)'
- en: 'As we already know, `BasketOfStocks` is an immutable type, so we cannot change
    any of the fields in it; however, let''s see if we can take away one of the stocks
    from the `stocks` field:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，`BasketOfStocks`是一个不可变类型，所以我们不能改变它中的任何字段；然而，让我们看看我们是否可以从`stocks`字段中移除一支股票：
- en: '![](img/0d506cfe-1b10-4719-991e-ebf2fbe83fca.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d506cfe-1b10-4719-991e-ebf2fbe83fca.png)'
- en: Here, we just call the `pop!` function directly on the `stocks` object, and
    it will happily take away half of the presents for my wife! Let me repeat—the
    immutability guarantee does not have any effect on the underlying fields.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是直接在`stocks`对象上调用`pop!`函数，它会愉快地拿走我妻子一半的礼物！让我重复一遍——不可变性保证对底层字段没有任何影响。
- en: This behavior is by design. The programmer should be cautious about making any
    assumptions about immutability.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是按设计进行的。程序员应该谨慎对待对不可变性的任何假设。
- en: Mutability
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性
- en: 'In some situations, we may actually want an object to be mutable. The immutability
    constraint can be removed easily by just adding the `mutable` keyword in front
    of the type definition. To make the `Stock` type mutable, we do the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能实际上希望对象是可变的。可以通过在类型定义前添加`mutable`关键字轻松地移除不可变性约束。为了使`Stock`类型可变，我们做以下操作：
- en: '[PRE20]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s try to update the `name` field in a hypothetical case where Apple
    changes its company name:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试在一个假设的情况下更新`name`字段，假设苹果公司更改了其公司名称：
- en: '![](img/4dc50ddf-bca3-47e9-ac35-e09e0ecbdb12.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4dc50ddf-bca3-47e9-ac35-e09e0ecbdb12.png)'
- en: The `name` field has been updated as we wish. Note that, when a type is declared
    mutable, all of its fields become mutable. So, in this case, we would be allowed
    to change the symbol as well. Depending on the situation, such behavior may or
    may not be desirable. In [Chapter 8](6b565339-641f-444c-ad42-f8ff7998001b.xhtml),
    *Robustness Patterns*, we will go over some design patterns that we can use to
    build a more robust solution.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`字段已经按我们的意愿更新。请注意，当一个类型被声明为可变时，它的所有字段都变为可变。因此，在这种情况下，我们也可以更改符号。根据情况，这种行为可能是或可能不是期望的。在[第8章](6b565339-641f-444c-ad42-f8ff7998001b.xhtml)，*鲁棒性模式*中，我们将讨论一些我们可以用来构建更稳健解决方案的设计模式。'
- en: Mutable or immutable?
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变或不可变？
- en: 'As you can see, mutable objects seem more flexible and give us good performance.
    But if that''s the case, then why wouldn''t we want everything to be mutable by
    default? There are a couple of reasons:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，可变对象似乎更灵活，并且提供了良好的性能。但如果是这样，那么为什么我们不想让所有东西默认都是可变的呢？有几个原因：
- en: Immutable objects are easier to handle. Because the data in the object is fixed
    and never changes, a function that operates on these objects will always return
    consistent results. That is a very nice property to have because there are no
    surprises. And if we build a function that caches calculation results from such
    objects, the cache will always be good and return consistent results.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变对象更容易处理。因为对象中的数据是固定的，永远不会改变，所以对这些对象进行操作的函数将始终返回一致的结果。这是一个非常好的特性，因为没有惊喜。如果我们为这样的对象构建一个缓存计算结果的函数，缓存将始终良好并返回一致的结果。
- en: Mutable objects are more difficult to work with in a multi-threaded application.
    Let's say that a function is reading from a mutable object, but the content of
    the object is modified by another function from a different thread. Then the current
    function may produce incorrect results. In order to ensure consistency, the programmer
    must use a locking technique to synchronize the read/write operations to the object.
    Having to handle such a concurrent situation makes the code more complex and difficult
    to test.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变对象在多线程应用程序中更难处理。假设一个函数正在从可变对象中读取，但该对象的内容被来自不同线程的另一个函数修改。那么当前函数可能会产生错误的结果。为了确保一致性，程序员必须使用锁定技术来同步对对象的读写操作。必须处理这种并发情况使得代码更加复杂且难以测试。
- en: On the other hand, mutability could be useful for high-performance use cases
    because memory allocation is a relatively expensive operation. We can reduce the
    system overhead by reusing allocated memory over and over again.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可变性对于高性能用例可能很有用，因为内存分配是一个相对昂贵的操作。我们可以通过反复重用分配的内存来减少系统开销。
- en: All things considered, immutable objects are usually the better choice.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有因素，不可变对象通常是更好的选择。
- en: Supporting multiple types using Union types
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用联合类型支持多种类型
- en: 'Sometimes, we need to support multiple types in a field. This can be done using
    a `Union` type, which is defined as a type that can accept any specified types.
    To define a `Union` type, we can just enclose the types within curly braces after
    the `Union` keyword. For example, the `Union` type of `Int64` and `BigInt` can
    be defined as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在字段中支持多种类型。这可以通过使用`Union`类型来实现，它被定义为可以接受任何指定类型的类型。要定义一个`Union`类型，我们可以在`Union`关键字之后用花括号包围类型。例如，`Int64`和`BigInt`的`Union`类型可以定义如下：
- en: '[PRE21]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These `Union` types are quite useful when you need to incorporate data types
    that come from different data type hierarchies. Let''s extend our personal asset
    example further. For instance, say that we need to incorporate some exotic items
    into our data model, which may include things such as art pieces, antiques, paintings,
    and so on. These new concepts may have already been modeled with a different type
    hierarchy, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要整合来自不同数据类型层次的数据类型时，这些`Union`类型非常有用。让我们进一步扩展我们的个人资产示例。例如，假设我们需要将一些异国物品纳入我们的数据模型中，这可能包括艺术品、古董、绘画等等。这些新概念可能已经被不同的类型层次所建模，如下所示：
- en: '[PRE22]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As it turns out, my wife likes to collect paintings, and so I can just generalize
    the `BasketOfStock` type as `BasketOfThings`, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我的妻子喜欢收集绘画，所以我可以将`BasketOfStock`类型泛化为`BasketOfThings`，如下所示：
- en: '[PRE23]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The things inside the vector can be `Stock` or `Painting`. Remember that Julia
    is a strongly typed language, and it is important that the compiler knows what
    kinds of data type can fit into an existing field. Let''s see how it works:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 向量中的物品可以是`Stock`或`Painting`。记住，Julia是一种强类型语言，编译器知道哪些数据类型可以适合现有的字段是非常重要的。让我们看看它是如何工作的：
- en: '![](img/6bf242c2-9abf-4aaf-9e6a-6d3cdda92221.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6bf242c2-9abf-4aaf-9e6a-6d3cdda92221.png)'
- en: To create a vector that contains either `Painting` or `Stock`, we just specify
    the element type of the array in front of the square brackets, as in `Union{Painting,Stock}[stock,
    monalisa]`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含`Painting`或`Stock`的向量，我们只需在方括号前指定数组的元素类型，如`Union{Painting,Stock}[stock,
    monalisa]`。
- en: 'The syntax for `Union` types can be very verbose, especially when there are
    more than two types, so it is quite common for a constant to be defined with a
    meaningful name that represents the `Union` type:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union`类型的语法可能非常冗长，尤其是当类型超过两个时，因此定义一个具有表示`Union`类型的有意义的名称的常量是很常见的：'
- en: '[PRE24]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, `Thing` is much easier to read than `Union{Painting,Stock}`.
    Another benefit is that the `Union` type may be referenced in many parts of the
    source code. When we need to add more types later—for instance, an `Antique` type—then
    we only need to change it in one place, which is the definition of `Thing`. This
    means that the code can be maintained more easily.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Thing`比`Union{Painting,Stock}`更容易阅读。另一个好处是`Union`类型可以在源代码的许多部分被引用。当我们需要稍后添加更多类型时——例如，一个`Antique`类型——我们只需要在一个地方更改它，即`Thing`的定义。这意味着代码可以更容易地维护。
- en: In this section, although we have chosen to use concrete types such as `Stock`
    and `Painting` for our example, there is no reason why we cannot use abstract
    types such as `Asset` and `Art` for the `Union` type.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，尽管我们选择了使用如`Stock`和`Painting`这样的具体类型作为示例，但我们没有理由不能使用如`Asset`和`Art`这样的抽象类型来定义`Union`类型。
- en: Another common usage of the `Union` type is to incorporate `Nothing` as a valid
    value for a field. This can be achieved by declaring a field with the `Union{T,Nothing} `type,
    where `T` is the real data type that we want to use. In that case, the field can
    be assigned with a real value or just `Nothing`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union`类型的另一个常见用法是将`Nothing`作为字段的合法值。这可以通过声明一个具有`Union{T,Nothing}`类型的字段来实现，其中`T`是我们想要使用的实际数据类型。在这种情况下，该字段可以分配一个真实值或只是`Nothing`。'
- en: Next, we will continue to learn how to work with type operators.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续学习如何使用类型运算符。
- en: Working with type operators
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型运算符
- en: Julia's data types are first-class citizens themselves. This means that you
    can assign them to variables, pass them to functions, and manipulate them in various
    ways. We will take a look at two commonly used operators in the following sections.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的数据类型本身就是一等公民。这意味着你可以将它们分配给变量，传递给函数，并以各种方式操作它们。在接下来的几节中，我们将探讨两个常用的运算符。
- en: The isa operator
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`isa`运算符'
- en: 'The `isa` operator can be used to determine whether a value is a subtype of
    a type. For example, look at the following code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`isa`运算符可以用来确定一个值是否是某个类型的子类型。例如，看看下面的代码：'
- en: '![](img/65d7f375-620b-46fc-a9fb-0a0facbcce16.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65d7f375-620b-46fc-a9fb-0a0facbcce16.png)'
- en: 'Let me explain each of these results:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下这些结果：
- en: The number `1` is an instance of the `Int` type, so it returns `true`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字 `1` 是 `Int` 类型的实例，因此返回 `true`。
- en: Because `Float64` is a different concrete type, it returns `false`.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `Float64` 是一个不同的具体类型，所以它返回 `false`。
- en: Because `Int` is a subtype of `Signed`, which is a subtype of `Integer`, which
    is a subtype of `Real`, it returns `true`.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 `Int` 是 `Signed` 的子类型，而 `Signed` 是 `Integer` 的子类型，`Integer` 是 `Real` 的子类型，所以它返回
    `true`。
- en: The `isa` operator could be useful for checking types in a function that accepts
    generic type arguments. For example, if the function can only work with `Real`
    numbers, then it may throw an error when a `Complex` value is passed by accident.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`isa` 操作符对于检查接受泛型类型参数的函数中的类型可能很有用。例如，如果函数只能处理 `Real` 数值，那么当意外传递一个 `Complex`
    值时，它可能会抛出错误。'
- en: The <: operator
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<:` 操作符'
- en: 'The *is-a-subtype-of* operator, `<:`, is used to determine whether a type is
    a subtype of another type. Taking the third example from the preceding section,
    we can check whether `Int` is indeed a subtype of `Real` as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*is-a-subtype-of* 操作符 `<:` 用于确定一个类型是否是另一个类型的子类型。从上一节中的第三个例子来看，我们可以检查 `Int`
    是否确实是 `Real` 的子类型，如下所示：'
- en: '![](img/f1e081da-8d13-4fe2-8da1-0f2d9adf8a34.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1e081da-8d13-4fe2-8da1-0f2d9adf8a34.png)'
- en: 'Sometimes the developer may be confused about the usage of the `isa` and `<:`
    operators because they are very similar. We can keep in mind that `isa` checks
    a *value* against a type, and `<:` checks a *type* against another type. The document
    string for these operators is actually quite helpful. From the Julia REPL, type
    a `?` character and enter the operator to find the documentation:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有时开发者可能会对 `isa` 和 `<:` 操作符的用法感到困惑，因为它们非常相似。我们可以记住，`isa` 检查一个 *值* 是否与一个类型匹配，而
    `<:` 检查一个 *类型* 是否与另一个类型匹配。这些操作符的文档字符串实际上非常有帮助。从 Julia REPL 中，输入一个 `?` 字符并输入操作符以查找文档：
- en: '![](img/59b3c143-4d6f-491b-9347-d4fbc226f65c.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59b3c143-4d6f-491b-9347-d4fbc226f65c.png)'
- en: As it turns out, both `isa` and `<:` are just functions, but they can also be
    used as infix operators.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`isa` 和 `<:` 都是函数，但它们也可以用作中缀操作符。
- en: These operators are quite useful for type-checking purposes; for example, we
    can throw an exception from a constructor function if the arguments being passed
    do not have the right types. They can also be used to execute different logic
    dynamically based upon the types being passed to a function.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符对于类型检查非常有用；例如，我们可以在构造函数中抛出异常，如果传递的参数没有正确的类型。它们还可以根据传递给函数的类型动态执行不同的逻辑。
- en: Abstract types and concrete types are the fundamental building blocks for data
    types in Julia. It may be worth looking at a quick summary of the differences
    between them. Next, we will look at specific details.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型和具体类型是 Julia 中数据类型的根本构建块。快速了解它们之间的差异可能是有益的。接下来，我们将探讨具体细节。
- en: Differences between abstract and concrete types
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类型和具体类型的差异
- en: 'Having discussed abstract types and concrete types, you may be wondering how
    they differ from each other. We can summarize their differences in the following
    table:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了抽象类型和具体类型之后，你可能想知道它们之间有什么不同。我们可以以下表总结它们的不同之处：
- en: '| **Property** | **Abstract Type** | **Concrete Type** |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **抽象类型** | **具体类型** |'
- en: '| --- | --- | --- |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Has a supertype? | Yes | Yes |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 有超类型？ | 是 | 是 |'
- en: '| Allows subtypes? | Yes | No |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 允许子类型？ | 是 | 否 |'
- en: '| Contains data fields? | No | Yes |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 包含数据字段？ | 否 | 是 |'
- en: '| First class? | Yes | Yes |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 一等类型？ | 是 | 是 |'
- en: '| Can be part of a `Union` type? | Yes | Yes |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 可以是 `Union` 类型的一部分？ | 是 | 是 |'
- en: For abstract types, we can build a hierarchy of types. The top-level type is
    just `Any`. Abstract types cannot contain any data fields as they are used to
    represent concepts rather than data storage. Abstract types are first-class, meaning
    that they can be stored and passed around, and there are functions that work with
    them—for example, the `isa` and `<:` operators.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对于抽象类型，我们可以构建一个类型层次结构。顶层类型只是 `Any`。抽象类型不能包含任何数据字段，因为它们是用来表示概念而不是数据存储的。抽象类型是一等类型，这意味着它们可以被存储和传递，并且有与它们一起工作的函数——例如，`isa`
    和 `<:` 操作符。
- en: A concrete type is associated with an abstract type as a supertype. If the supertype
    is not specified, then it is assumed to be `Any`. A concrete type does not allow
    subtypes. This means that every concrete type must be final, and would be a leaf
    node in a type hierarchy. Concrete types are also first class, just like abstract
    types.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 具体类型与抽象类型相关联，作为超类型。如果没有指定超类型，则默认为 `Any`。具体类型不允许子类型。这意味着每个具体类型都必须是最终的，并且会在类型层次结构中成为叶节点。具体类型也是一等类型，就像抽象类型一样。
- en: Both abstract types and concrete types can be referred to in a `Union` type.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型和具体类型都可以在 `Union` 类型中引用。
- en: What we just mentioned may be surprising to people who come from an object-oriented
    programming background. First, you may wonder why concrete types do not allow
    subtypes. Second, you may wonder why abstract types can't be defined with fields.
    This design is actually intentional and was debated heavily by the core Julia
    development team. The debate is related to behavioral inheritance versus structural
    inheritance, which will be discussed in [Chapter 12](97049a94-ad30-452a-bbb0-296d9438c886.xhtml),
    *Inheritance and Variance*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才提到的内容可能会让来自面向对象编程背景的人感到惊讶。首先，你可能想知道为什么具体类型不允许子类型。其次，你可能想知道为什么抽象类型不能定义字段。这种设计实际上是故意的，并且核心
    Julia 开发团队进行了激烈的辩论。辩论与行为继承与结构继承有关，这将在第 12 章[继承和变异性](97049a94-ad30-452a-bbb0-296d9438c886.xhtml)中讨论。
- en: Now, let's switch gear and go over the parametric type feature of the Julia
    language.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转换一下，来看看 Julia 语言的参数化类型特性。
- en: Working with parametric types
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与参数化类型一起工作
- en: One of the most powerful features of the Julia language is the ability to parameterize
    types. It is actually quite difficult to find any Julia package that does not
    use this feature. Parametric types allow the software designer to generalize types,
    and let the Julia runtime automatically compile to the concrete version based
    on the specified parameters.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 语言最强大的特性之一是能够参数化类型。实际上，很难找到不使用这个特性的任何 Julia 包。参数化类型允许软件设计者泛化类型，并让 Julia
    运行时根据指定的参数自动编译到具体版本。
- en: Let's take a look at how this works with composite and abstract types.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看复合类型和抽象类型是如何工作的。
- en: Working with parametric composite types
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与参数化复合类型一起工作
- en: When designing composite types, we should assign each field a type. Oftentimes,
    we don't really care exactly what those types are, as long as the type provides
    the functionality that we want.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计复合类型时，我们应该为每个字段分配一个类型。通常，我们并不真的关心这些类型是什么，只要类型提供了我们想要的功能即可。
- en: 'A classic example would be numeric types. The concept of numbers is simple:
    basically the same as we were taught in elementary school. In practice, many numeric
    types are implemented in computer systems because of the different physical storage
    and representations of data.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的例子是数值类型。数字的概念很简单：基本上就像我们在小学学的那样。在实践中，由于数据的不同物理存储和表示，许多数值类型在计算机系统中得到实现。
- en: 'By default, Julia ships with the following numeric types; concrete types are
    darker:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Julia 随带以下数值类型；具体类型较暗：
- en: '![](img/ed69deaa-7703-4d91-9dd5-072bd38fe537.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed69deaa-7703-4d91-9dd5-072bd38fe537.png)'
- en: 'Do you remember when we designed a composite type to represent a stock in an
    investment portfolio earlier in this chapter? Let''s revisit that example here:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在本章前面设计了一个复合类型来表示投资组合中的股票吗？让我们在这里回顾一下这个例子：
- en: '[PRE25]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If I have to hold some stocks in my brokerage account, then I should also keep
    track of the number of shares that I own. To do this, I can define a new type
    called `StockHolding`, as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我必须在我的经纪账户中持有一些股票，那么我也应该跟踪我拥有的股票数量。为此，我可以定义一个新的类型，称为 `StockHolding`，如下所示：
- en: '[PRE26]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `Int` data type is by default aliased to either `Int64` or `Int32`, depending
    on whether you are using the 64-bit or 32-bit version of Julia. This seems reasonable
    just to get started, but what if we need to support fractional shares for a different
    use case? In that case, we can just change the type of `quantity` to `Float64`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Int` 数据类型被别名到 `Int64` 或 `Int32`，这取决于你是否在使用 Julia 的 64 位或 32 位版本。这看起来只是为了开始而合理，但如果我们需要支持不同用例的分数份额怎么办？在这种情况下，我们只需将
    `quantity` 的类型改为 `Float64`：
- en: '[PRE27]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We basically widen the type of `quantity` field to a type that supports both
    integer and floating-point values. It may be a reasonable approach, but if we
    need to support both `Int` and `Float64` types, then we would have to maintain
    two slightly different types. Sadly, if we do create two different types, then
    it becomes a maintenance nightmare.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上将`quantity`字段的类型扩展到支持整数和浮点值的类型。这可能是一个合理的方法，但如果我们需要同时支持`Int`和`Float64`类型，那么我们就必须维护两种略有不同的类型。遗憾的是，如果我们创建了两种不同的类型，那么维护工作就会变得非常困难。
- en: 'To make it more flexible, we can redesign the `StockHolding` type with a parameter:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加灵活，我们可以通过一个参数重新设计`StockHolding`类型：
- en: '[PRE28]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The symbol `T` inside the curly braces is called a *type parameter*. It serves
    as a placeholder that can be used as a type in any of the fields.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号内的符号`T`被称为*类型参数*。它作为一个占位符，可以在任何字段中用作类型。
- en: Now, we have the best of both worlds. The `StockHolding{Int}` type refers to
    the type that contains a `quantity` field of the `Int` type. Likewise, the `StockHolding{Float64}`
    refers to the type that contains a `quantity` field of the `Float64` type.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了两者之优。`StockHolding{Int}`类型指的是包含`Int`类型`quantity`字段的类型。同样，`StockHolding{Float64}`指的是包含`Float64`类型`quantity`字段的类型。
- en: 'In practice, the `T` type parameter can only be a numeric type, so we could
    further qualify `T` as any subtype of `Real`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`T`类型参数只能是一个数值类型，因此我们可以进一步将`T`限定为`Real`的任何子类型：
- en: '[PRE29]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here's how we read this—*the* `StockHolding` *type contains a stock and a quantity
    of the *`T` *type that is a subtype of* `Real`. The second part of the sentence
    is important; it means that we can create a new `StockHolding` with the type of `quantity`
    as `Float16`, `Float32`, `Float64`, `Int8`, `Int16`, `Int32`, and so on.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以理解了——*StockHolding*类型包含一个股票和一个类型为*`T`*的*子类型*`Real`的数量。句子的后半部分很重要；这意味着我们可以创建一个新类型的`StockHolding`，其`quantity`类型可以是`Float16`、`Float32`、`Float64`、`Int8`、`Int16`、`Int32`等等。
- en: 'Let''s try instantiating the `StockHolding` object with different kinds of
    type parameter, such as `Int`, `Float64`, and `Rational`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用不同的类型参数实例化`StockHolding`对象，例如`Int`、`Float64`和`Rational`：
- en: '![](img/481f7308-e43e-4b20-86e5-12f09c65965f.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/481f7308-e43e-4b20-86e5-12f09c65965f.png)'
- en: We can see that different `StockHolding{T}` types are created automatically
    according to the argument that was passed to the constructor.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，根据传递给构造函数的参数，会自动创建不同的`StockHolding{T}`类型。
- en: 'Another use of parametric types is to enforce the consistency of field types.
    Suppose that we want to design another kind of stock-holding object to track the
    price and market value of the holding. Let''s call it `StockHolding2` to avoid
    confusion with the preceding one. The following is what it looks like:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化类型的另一个用途是强制字段类型的统一性。假设我们想要设计另一种股票持有对象来跟踪持有物的价格和市场价值。让我们称它为`StockHolding2`以避免与前一个混淆。下面是它的样子：
- en: '[PRE30]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Knowing that the type for `quantity` may not be the same as the type for `price`
    and `marketvalue`, we have added a new type parameter, `P`. Now, we can instantiate
    a `StockHolding2` object that contains an integer quantity while having floating-point
    values for price and market value fields:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 知道`quantity`的类型可能不同于`price`和`marketvalue`的类型，我们添加了一个新的类型参数，`P`。现在，我们可以实例化一个包含整数数量的`StockHolding2`对象，而价格和市场价值字段为浮点值：
- en: '![](img/debf66c0-e43e-44a2-a70c-0dc844f8b4d0.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/debf66c0-e43e-44a2-a70c-0dc844f8b4d0.png)'
- en: Note that the type is `StockHolding2{Int64, Float64}`, as shown in the preceding
    screenshot. In this case, the type parameter `T` is `Int64` and the parameter `P`
    is `Float64`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型是`StockHolding2{Int64, Float64}`，如前一个截图所示。在这种情况下，类型参数`T`是`Int64`，参数`P`是`Float64`。
- en: 'As we declared that both the `price` and `marketvalue` fields must be of the
    same type, `P`, does Julia enforce this rule for us? Let''s give it a try:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们声明了`price`和`marketvalue`字段必须具有相同的类型`P`，Julia会为我们强制执行这条规则吗？让我们试一试：
- en: '![](img/a65ab845-d29f-49cc-a4a8-8eb6448603ee.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a65ab845-d29f-49cc-a4a8-8eb6448603ee.png)'
- en: '*Yes, it does!* We correctly received an error because we passed a `Float64`
    value for `price`, but an `Int64` for `marketvalue`. Let''s take a closer look
    at the error message, which revealed what the system expects. The closest candidate
    function for `StockHolding2` takes a `P` type for the third and fourth arguments,
    where `P` is any subtype of `AbstractFloat`. Because `In64` is not a subtype of
    `AbstractFloat`, there is no match and so an error was thrown.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*是的，确实如此!* 我们正确地收到了一个错误，因为我们为 `price` 传递了一个 `Float64` 值，但为 `marketvalue` 传递了一个
    `Int64`。让我们仔细看看错误信息，它揭示了系统期望的内容。对于 `StockHolding2` 的最接近的候选函数接受第三个和第四个参数的 `P` 类型，其中
    `P` 是 `AbstractFloat` 的任何子类型。因为 `Int64` 不是 `AbstractFloat` 的子类型，所以没有匹配，因此抛出了错误。'
- en: Parametric types can be abstract as well. We will go over this next.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化类型也可以是抽象的。我们将在下一节中讨论这一点。
- en: Working with parametric abstract types
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与参数化抽象类型一起工作
- en: 'Abstract types can be enhanced in the same way that composite types can be
    parameterized. Let''s continue with the preceding example. Suppose that we want
    to build an abstract type called `Holding` that keeps track of a `P` type that
    is used by its subtypes. We can code it as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型可以像复合类型一样被增强。让我们继续前面的例子。假设我们想要构建一个名为 `Holding` 的抽象类型，它跟踪其子类型使用的 `P` 类型。我们可以这样编写代码：
- en: '[PRE31]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, every subtype of `Holding{P}` must also take a  `P` type parameter. As
    an example, we can create two new types —`StockHolding3{T,P}` and `CashHolding{P}`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Holding{P}` 的每个子类型也必须接受一个 `P` 类型参数。例如，我们可以创建两个新的类型——`StockHolding3{T,P}`
    和 `CashHolding{P}`：
- en: '[PRE32]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can examine how these types are related as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下检查这些类型之间的关系：
- en: '![](img/18a9dd07-410b-4a41-a02a-b4a485ef45a2.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18a9dd07-410b-4a41-a02a-b4a485ef45a2.png)'
- en: 'Let''s create a new `StockHolding3` object:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 `StockHolding3` 对象：
- en: '![](img/41285d50-bf70-4fac-a6e1-4455b4b3895e.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41285d50-bf70-4fac-a6e1-4455b4b3895e.png)'
- en: As expected, the `certificate_in_the_safe` object is a subtype of `Holding{Float64}`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`certificate_in_the_safe` 对象是 `Holding{Float64}` 的子类型。
- en: 'Note that, when a type is parameterized, each variation is considered as a
    separate type that is unrelated to the others, except that they have a common
    supertype. As an example, `Holding{Int}` is a different type from `Holding{Float64}`,
    but they are both subtypes of `Holding`. Let''s quickly prove this to ourselves:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当一个类型被参数化时，每个变体都被视为一个独立的类型，它们之间没有关联，除了它们有一个共同的超类型。例如，`Holding{Int}` 和 `Holding{Float64}`
    是不同的类型，但它们都是 `Holding` 的子类型。让我们快速证明这一点：
- en: '![](img/6371c808-59b0-463e-ba85-59b974c893e8.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6371c808-59b0-463e-ba85-59b974c893e8.png)'
- en: In summary, Julia comes with a very rich type system that a programmer can use
    to reason how each type relates to other types. Abstract types allow us to define
    behaviors in a hierarchy of relationships, and concrete types are used to define
    how data is stored. Parametric types are used to extend existing types to variations
    of field types. All of these language constructs allow the programmer to model
    data and behavior effectively.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Julia 提供了一个非常丰富的类型系统，程序员可以使用它来推理每个类型与其他类型之间的关系。抽象类型允许我们在关系层次结构中定义行为，而具体类型用于定义数据的存储方式。参数化类型用于将现有类型扩展到字段类型的变体。所有这些语言结构都允许程序员有效地建模数据和行为。
- en: Next, we will look into data type conversions and how they apply to functions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨数据类型转换及其如何应用于函数。
- en: Conversion between data types
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型之间的转换
- en: We often need to convert data from one type to another in order to leverage
    existing library functions. A great working example would be the standard numerical
    data types. It is a common use case to convert a piece of date from an integer
    to a floating-point number in most mathematical functions.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要将数据从一种类型转换为另一种类型，以便利用现有的库函数。一个很好的工作示例是标准的数值数据类型。在大多数数学函数中，将一个整数日期转换为浮点数是一个常见的用例。
- en: In this section, we will learn about how data type conversion is performed in
    Julia. As it turns out, data type conversions are expected to be implemented explicitly;
    however, a set of rules has been implemented so that some conversions are automatically
    invoked.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在 Julia 中执行数据类型转换。实际上，数据类型转换预计将被显式实现；然而，已经实现了一套规则，以便某些转换可以自动调用。
- en: Performing simple data type conversion
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行简单的数据类型转换
- en: 'There are two ways to convert a value from one data type to another. The obvious
    choice is to construct a new object from an existing value. For example, we can
    construct a `Float64` object from a rational number as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值从一种数据类型转换为另一种数据类型有两种方法。显然的选择是从现有值构造一个新对象。例如，我们可以如下从有理数构造一个`Float64`对象：
- en: '![](img/fbf568bb-125b-42cc-af66-b9c3d1011b10.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbf568bb-125b-42cc-af66-b9c3d1011b10.png)'
- en: 'Another way is to use the `convert` function:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`convert`函数：
- en: '![](img/7d6cb216-8e5b-4ee5-b537-343c21953ebf.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d6cb216-8e5b-4ee5-b537-343c21953ebf.png)'
- en: Either way works fine. There is an advantage from using the `convert` function
    when considering performance optimization, as we will explain later in this section.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式都行得通。当考虑性能优化时，使用`convert`函数有一个优点，我们将在本节后面解释。
- en: Beware of lossy conversions
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小心有损转换
- en: When it comes to conversion, it is important to consider whether the conversion
    is lossless or lossy. In general, it is expected that data type conversion is
    lossless, which means that, when you convert from one type to another and back,
    you get the same value.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到转换时，考虑转换是有损还是无损是很重要的。一般来说，数据类型转换是无损的，这意味着当你从一个类型转换到另一个类型，然后再转换回来时，你会得到相同的值。
- en: 'Because of the numerical representation of floating-point numbers, such perfect
    conversion is not always possible. For example, let''s try to convert `1//3` to `Float64` and
    then convert it back to `Rational`:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点数的数值表示，这种完美的转换并不总是可能的。例如，让我们尝试将`1//3`转换为`Float64`，然后再将其转换回`Rational`：
- en: '![](img/b944aeed-5ed8-4231-8af0-40dea9469ebf.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b944aeed-5ed8-4231-8af0-40dea9469ebf.png)'
- en: 'Because of a rounding error, it is not possible to reconstruct `1//3` after
    it was converted to a `Float64` type. The problem is not restricted to the `Rational`
    type. We can easily break this again by converting the value from an `Int64` to
    a `Float64` and back, as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 由于舍入误差，在将`1//3`转换为`Float64`类型后，无法重建它。这个问题不仅限于`Rational`类型。我们可以通过将值从`Int64`转换为`Float64`然后再转换回来，轻松地再次破坏它，如下所示：
- en: '![](img/015472e3-fb61-42d6-8c91-77ce98cc730f.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](img/015472e3-fb61-42d6-8c91-77ce98cc730f.png)'
- en: 'We can see that there is a loss of precision here. While we may not be very
    satisfied with these results, there is really not much that we can do here as
    long as we use the `Float64` type. The `Float64` type is implemented according
    to the IEEE 754 floating-point specification, and it is expected to carry precision
    errors. If you need more precision, you can use `BigFloat` instead, which solves
    this particular problem:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里存在精度损失。虽然我们可能对这些结果不太满意，但只要我们使用`Float64`类型，实际上我们真的无能为力。`Float64`类型是根据IEEE
    754浮点规范实现的，并且预期会存在精度误差。如果您需要更高的精度，可以使用`BigFloat`代替，这可以解决这个特定问题：
- en: '![](img/bc94641d-6994-4e4a-aa7d-23590048ec62.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc94641d-6994-4e4a-aa7d-23590048ec62.png)'
- en: When handling floating-point values, we should be cautious about precision issues.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理浮点数时，我们应该小心精度问题。
- en: Understanding numeric type conversions
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数值类型转换
- en: Julia does not automatically perform conversion on data types for safety reasons.
    Every conversion must be explicitly defined by the programmer.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 由于安全原因不会自动在数据类型上执行转换。每个转换都必须由程序员显式定义。
- en: 'To make it easier for everyone, Julia already contains conversion functions
    for numeric types by default. For instance, you can find this interesting piece
    of code from the `Base` package:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让每个人更容易理解，Julia 默认已经包含了用于数值类型的转换函数。例如，您可以从`Base`包中找到这段有趣的代码：
- en: '[PRE33]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Both functions take the first argument of the `Type{T}` type, where `T` is a
    subtype of `Number`. Valid values include all standard numeric types, such as
    `Int64`, `Int32`, `Float64`, `Float32`, and so on.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都接受`Type{T}`类型的第一个参数，其中`T`是`Number`的子类型。有效的值包括所有标准数值类型，如`Int64`、`Int32`、`Float64`、`Float32`等。
- en: 'Let''s try to understand these two functions further:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步了解这两个函数：
- en: The first function says that it's as easy as returning the argument `x` itself
    when we want to convert `x` from the `T` type and to the `T` type (the same type)
    as long as `T` is a subtype of `Number`. This can be considered a performance
    optimization because there is really no need to do any conversion when the target
    type is the same as the input.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数表示，当我们想要将`x`从`T`类型转换为`T`类型（相同的类型）时，只要`T`是`Number`的子类型，我们就可以简单地返回参数`x`本身。这可以被认为是一种性能优化，因为当目标类型与输入类型相同时，实际上没有必要进行任何转换。
- en: The second function is a little more interesting. In order to convert `x`, which
    is a subtype of `Number`, to type `T`, which is also a subtype of `Number`, it
    just calls the constructor of the `T` type with `x`. In other words, this function
    can handle the conversion of any `Number` type to another type that is a subtype
    of `Number`.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个函数稍微有趣一些。为了将 `x`（它是 `Number` 的子类型）转换为类型 `T`（它也是 `Number` 的子类型），它只是调用 `T`
    类型的构造函数并传递 `x`。换句话说，这个函数可以处理任何 `Number` 类型到 `Number` 子类型的转换。
- en: You may wonder why we don't just use the constructor in the first place. This
    is because the `convert` function is designed to be invoked automatically for
    various common use cases. As you can see from what we looked at previously, this
    extra indirection also allows us to bypass the constructor when conversion is
    unnecessary.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们一开始不直接使用构造函数。这是因为 `convert` 函数被设计为在多种常见用例中自动调用。正如我们之前所看到的，这种额外的间接性也允许我们在转换不必要时绕过构造函数。
- en: When does `convert` get called? The answer is that Julia does not automatically
    do that, except for a few scenarios. We will explore these scenarios in the next
    section.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert` 在何时被调用？答案是 Julia 不会自动这样做，除了少数几种情况。我们将在下一节中探讨这些情况。'
- en: Reviewing the rules for automatic conversion
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查自动转换的规则
- en: 'As data type conversion is a fairly standard operation, Julia is designed to
    automatically call the `convert` function in the following scenarios:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据类型转换是一个相当标准的操作，Julia 被设计为在以下场景中自动调用 `convert` 函数：
- en: Assigning a value to an array converts the value to the array's element type.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值赋给数组会将该值转换为数组的元素类型。
- en: Assigning a value to a field of an object converts the value to the declared
    type of the field.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值赋给对象的字段会将值转换为该字段的声明类型。
- en: Constructing an object with `new` converts the value to the object's declared
    field type.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `new` 构造对象会将值转换为对象的声明字段类型。
- en: Assigning a value to a variable with a declared type converts the value to that
    type
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值赋给具有声明类型的变量会将该值转换为该类型
- en: A function with a declared return type converts its return value to that type.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明返回类型的函数会将它的返回值转换为该类型。
- en: Passing a value to `ccall` converts the value to the corresponding argument
    type.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `ccall` 传递值会将该值转换为相应的参数类型。
- en: Let's confirm that these are indeed working as advertised.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认这些功能确实按预期工作。
- en: 'Case 1: Assigning a value to an array'
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况 1：将值赋给数组
- en: 'In the following example, assigning the `1` value to a `Float64` array would
    convert the former into a floating-point value, `1.0`:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，将 `1` 值赋给 `Float64` 数组会将前者转换为浮点值，`1.0`：
- en: '![](img/1dea2c68-d2ee-42cb-99c7-2715fa241ec1.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dea2c68-d2ee-42cb-99c7-2715fa241ec1.png)'
- en: 'Case 2: Assigning a value to a field of an object'
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况 2：将值赋给对象的字段
- en: 'In the following example, the `Foo` struct accepts a `Float64` field. When
    the field is assigned a value of `2`, it is converted to `2.0`:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Foo` 结构体接受一个 `Float64` 字段。当字段被赋予 `2` 的值时，它会被转换为 `2.0`：
- en: '![](img/3d131da0-5931-403d-b326-ca428f788a07.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d131da0-5931-403d-b326-ca428f788a07.png)'
- en: 'Case 3: Constructing an object with the new function'
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况 3：使用 new 函数构造对象
- en: 'In the following example, the `Foo` constructor automatically converts `1`
    to `1.0` when creating the `Foo` object:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Foo` 构造函数在创建 `Foo` 对象时会自动将 `1` 转换为 `1.0`：
- en: '![](img/8105a156-8030-40f9-9a7f-8b503350c50e.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8105a156-8030-40f9-9a7f-8b503350c50e.png)'
- en: 'Case 4: Assigning to a variable that has a declared type'
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况 4：将值赋给具有声明类型的变量
- en: 'In the following example, the local variable `x` is declared as a `Float64`
    type. When it is assigned the `1` value, it is converted to `1.0`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，局部变量 `x` 被声明为 `Float64` 类型。当它被赋予 `1` 值时，它会被转换为 `1.0`：
- en: '![](img/dedf63f0-4e75-4ede-b457-c0157334d8da.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dedf63f0-4e75-4ede-b457-c0157334d8da.png)'
- en: 'Case 5: Function has a declared return type'
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况 5：函数具有声明返回类型
- en: 'In the following example, the `foo` function is declared to return a `Float64`
    value. Even though the `return` statement says `1`, it is converted to `1.0` before
    it is returned:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`foo` 函数被声明为返回一个 `Float64` 值。尽管 `return` 语句说 `1`，但在返回之前它会被转换为 `1.0`：
- en: '![](img/1e667993-c8ba-49ba-bade-fa8f21030db4.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e667993-c8ba-49ba-bade-fa8f21030db4.png)'
- en: 'Case 6: Passing a value to ccall'
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情况 6：向 ccall 传递值
- en: 'In the following example, the `exp` function from the C library is used to
    calculate the exponent of a number. It expects a `Float64` value as an argument,
    so when the value of `2` is passed to `ccall`, it is converted to `2.0` before
    being passed to the C function:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，使用了C库中的`exp`函数来计算一个数的指数。它期望一个`Float64`值作为参数，因此当将值`2`传递给`ccall`时，它会在传递给C函数之前转换为`2.0`：
- en: '![](img/20fc4eaa-ee41-437e-a192-5f2a61730f26.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20fc4eaa-ee41-437e-a192-5f2a61730f26.png)'
- en: 'All that is good, but something seems to be missing. What about the most common
    use case: passing an argument to a function? Wouldn''t it be called if Julia auto-converts
    the arguments as well? The answer may be a little surprising. Let''s look at this
    in more detail in the following sections.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好，但似乎缺少了什么。最常见的情况：向函数传递一个参数怎么办？Julia在自动转换参数时不会调用它吗？答案可能有点令人惊讶。让我们在接下来的章节中更详细地探讨这个问题。
- en: Understanding the rules for function dispatches
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数分派规则
- en: Julia is a strongly typed language, which means that the programmer has to be
    very clear about the types being passed around. A function can only be called
    (also known as dispatched) when the types of its arguments are matched properly.
    A proper match can be defined as one that matches exactly (same type) or when
    the argument being passed is a subtype of what is expected in the function's signature.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: Julia是一种强类型语言，这意味着程序员必须非常清楚正在传递的类型。只有当函数参数的类型匹配正确时，才能调用（也称为分派）函数。适当的匹配可以定义为完全匹配（相同类型）或当传递的参数是函数签名中期望的类型的一个子类型时。
- en: 'To illustrate this, let''s create a function that doubles the value of its
    argument of the `AbstractFloat `type. We will use our `subtypetree` utility function
    to quickly find out its subtypes:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们创建一个函数，该函数将其`AbstractFloat`类型的参数值加倍。我们将使用我们的`subtypetree`实用函数来快速找出其子类型：
- en: '![](img/0914d4c3-d9f0-4530-9ce4-0e59adb27ef7.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0914d4c3-d9f0-4530-9ce4-0e59adb27ef7.png)'
- en: 'What happens if we pass an integer to the function? Well, it doesn''t work
    too well:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向函数传递一个整数会发生什么？嗯，它不太好用：
- en: '![](img/c9dab163-8585-4866-91fe-0dcdef913ba3.png)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9dab163-8585-4866-91fe-0dcdef913ba3.png)'
- en: 'Naively, we may think that the system should auto-convert the argument to `Float64`
    and then double the value. Well, it does not. It is not a conversion issue. To
    get that effect, we could obviously write another function that takes an `Int`
    argument, then converts it to `Float64`, and calls the original function. But
    the code would look exactly the same, and it''s a duplication of effort. This
    problem can be solved by just writing the function more generically:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 天真地，我们可能认为系统应该自动将参数转换为`Float64`然后加倍该值。但是，它并没有这样做。这不是一个转换问题。为了达到这个效果，我们可以显然地写另一个函数，它接受一个`Int`参数，然后将其转换为`Float64`，并调用原始函数。但是代码看起来完全一样，这是重复劳动。这个问题可以通过编写更通用的函数来解决：
- en: '![](img/1c90dabc-789b-4b96-9784-b5cccfab5487.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c90dabc-789b-4b96-9784-b5cccfab5487.png)'
- en: 'If we feel that the argument has to be a `Number`, then we can restrict it
    again as such:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们认为参数必须是`Number`，那么我们可以再次将其限制为这样的类型：
- en: '![](img/88d30233-35fd-4f07-a172-2010d57b28ee.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88d30233-35fd-4f07-a172-2010d57b28ee.png)'
- en: What we choose to do here depends on how flexible we want the function to be.
    The benefit of specifying an abstract type, such as `Number`, is that we feel
    sure the function will work well for any type that implements the behavior set
    down by `Number`. On the other hand, if we leave it as untyped in the function
    definition, then we open up the possibility for other objects to be passed to
    the function as long as the `*` operator is defined.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里选择做什么取决于我们希望函数有多灵活。指定一个抽象类型，如`Number`的好处是我们确信该函数将很好地适用于实现`Number`定义的行为的任何类型。另一方面，如果我们将函数定义中的它留为未指定类型，那么只要定义了`*`运算符，就可以将其他对象传递给函数。
- en: In this section, we have learned about how data type conversion can be performed
    in Julia. In certain scenarios, Julia can also automatically convert numeric types.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在Julia中执行数据类型转换。在某些情况下，Julia还可以自动转换数值类型。
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started discussing the importance of organizing source code
    for larger applications. We explored in detail how to establish namespaces and
    how to implement them using modules and submodules. To manage package dependencies,
    we introduced the concept of semantic versioning and learned how to use it properly
    with Julia's package manager.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始讨论了为大型应用程序组织源代码的重要性。我们详细探讨了如何建立命名空间以及如何使用模块和子模块来实现它们。为了管理包依赖，我们介绍了语义版本化的概念，并学习了如何使用Julia的包管理器正确地使用它。
- en: Then, we went over the details of how to design an abstract type hierarchy and
    define functions for abstract types. We also discussed concrete types and the
    concepts of immutability and mutability. We demonstrated how to use union types
    when working with data types from different abstract type hierarchies. We looked
    at two common operators (`isa` and *is-a-subtype-of*) for data types. To further
    reuse data types, we introduced parametric types and looked at how they apply
    to both concrete types and abstract types.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了如何设计抽象类型层次结构并定义抽象类型的函数。我们还讨论了具体类型以及不可变性和可变性的概念。我们演示了在处理来自不同抽象类型层次结构的数据类型时如何使用联合类型。我们考察了两种常见的数据类型运算符（`isa`和*is-a-subtype-of*）。为了进一步重用数据类型，我们介绍了参数化类型，并探讨了它们如何应用于具体类型和抽象类型。
- en: Finally, we looked at the `convert` function in Julia and how it is invoked
    automatically under certain circumstances. We learned how Julia’s function dispatch
    works and how to make a function more flexible by accepting broader abstract types
    in its arguments.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了Julia中的`convert`函数及其在特定情况下自动调用的方式。我们学习了Julia的函数分派是如何工作的，以及如何通过接受更广泛的抽象类型作为参数来使函数更加灵活。
- en: At this point, you should have a good understanding about how to organize code
    and designing your own data types.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对如何组织代码和设计自己的数据类型有了很好的理解。
- en: In the next chapter, we will look at how to define application behavior using
    functions and Julia's multiple-dispatch facility.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用函数和Julia的多重分派功能来定义应用程序的行为。
- en: Questions
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Go through the following questions to test your understanding of the subjects
    in this chapter.  The answers are provided at the back of the book:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下问题来测试你对本章主题的理解。答案在书的后面提供：
- en: How do we create a new namespace?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何创建一个新的命名空间？
- en: How do we expose the functions of a module to the outside world?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将模块的函数暴露给外部世界？
- en: How do we reference the proper function when the same function name is exported
    from different packages?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当同一个函数名从不同的包中导出时，我们如何引用正确的函数？
- en: When do we separate code into multiple modules?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在何时将代码分成多个模块？
- en: Why is semantic versioning important in managing package dependencies?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么语义版本化在管理包依赖时很重要？
- en: How is defining functional behavior for abstract types useful?
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为抽象类型定义功能性行为有什么用？
- en: When should we make a type mutable?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在何时使类型可变？
- en: How are parametric types useful?
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数化类型有什么用？
