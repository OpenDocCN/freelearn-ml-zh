- en: Recommendation Engines with Apache Mahout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Apache Mahout的推荐引擎
- en: 'Recommendation engines are one of the most applied data science approaches
    in startups today. There are two principal techniques for building a recommendation
    system: content-based filtering and collaborative filtering. The content-based
    algorithm uses the properties of the items to find items with similar properties.
    Collaborative filtering algorithms take user ratings, or other user behaviors,
    and make recommendations based on what users with similar behaviors liked or purchased.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐引擎是目前初创公司中最常用的数据科学方法之一。构建推荐系统有两种主要技术：基于内容的过滤和协同过滤。基于内容的算法使用项目的属性来找到具有相似属性的项目。协同过滤算法使用用户评分或其他用户行为，并根据具有相似行为的用户喜欢或购买的项目来做出推荐。
- en: In this chapter, we will first explain the basic concepts required to understand
    recommendation engine principles, and then we will demonstrate how to utilize
    Apache Mahout's implementation of various algorithms in order to quickly get a
    scalable recommendation engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将解释理解推荐引擎原理所需的基本概念，然后我们将展示如何利用Apache Mahout实现的各种算法来快速构建可扩展的推荐引擎。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to build a recommendation engine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建推荐引擎
- en: Getting Apache Mahout ready
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备Apache Mahout
- en: The content-based approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的推荐方法
- en: The collaborative filtering approach
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协同过滤方法
- en: By the end of this chapter, you will have learned about the kind of recommendation
    engine that is appropriate for our problem and how to quickly implement that engine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解适合我们问题的推荐引擎类型以及如何快速实现该引擎。
- en: Basic concepts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本概念
- en: Recommendation engines aim at showing users items of interest. What makes them
    different from search engines is the relevant content usually appears on a website
    without having been requested, and users don't have to build queries, as recommendation
    engines observe the users' actions and construct the queries for users without
    their knowledge.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐引擎的目标是向用户展示感兴趣的项目。它们与搜索引擎的不同之处在于，相关内容通常在网站上出现，而无需用户请求，用户也不需要构建查询，因为推荐引擎会观察用户的行为并在用户不知情的情况下为用户构建查询。
- en: 'Arguably, the most well-known example of a recommendation engine is [www.amazon.com](http://www.amazon.com),
    which provides personalized recommendation in a number of ways. The following
    screenshot shows an example of Customers Who Bought This Item Also Bought. As
    you will see later on, this is an example of collaborative item-based recommendation,
    where items similar to a particular item are recommended:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，最著名的推荐引擎例子是[www.amazon.com](http://www.amazon.com)，它以多种方式提供个性化推荐。以下截图显示了“购买此商品的用户也购买了”的示例。正如你稍后将会看到的，这是一个基于项目的协同过滤推荐的例子，其中推荐了与特定项目相似的项目：
- en: '![](img/bc5d5436-b9f5-42ba-8642-1f2bb6e0e6e3.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc5d5436-b9f5-42ba-8642-1f2bb6e0e6e3.png)'
- en: In this section, we will introduce key concepts related to understanding and
    building recommendation engines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍与理解构建推荐引擎相关的关键概念。
- en: Key concepts
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键概念
- en: 'Recommendation engines require the following pieces of input in order to make
    recommendations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐引擎需要以下输入来做出推荐：
- en: Item information, described with attributes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目信息，用属性描述
- en: A user profile, such as age range, gender, location, friends, and so on
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户资料，例如年龄范围、性别、位置、朋友等
- en: User interactions, in the form of rating, browsing, tagging, comparing, saving,
    and emailing
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户交互，包括评分、浏览、标记、比较、保存和电子邮件
- en: The context where the items will be displayed; for example, the item's category
    and the item's geographical location
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目将显示的上下文；例如，项目的类别和项目的地理位置
- en: 'This input is then combined by the recommendation engine to help obtain the
    following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输入随后会被推荐引擎结合使用，以帮助获取以下信息：
- en: Users who bought, watched, viewed, or bookmarked this item also bought, watched,
    viewed, or bookmarked
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买、观看、查看或收藏此项目的用户也购买了、观看、查看或收藏
- en: Items similar to this item
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与此项目相似的项目
- en: Other users you may know
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能认识的其他用户
- en: Other users who are similar to you
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你相似的其他用户
- en: Now, let's take a closer look at how this combination works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看这种组合是如何工作的。
- en: User-based and item-based analysis
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户和基于项目的分析
- en: Building a recommendation engine depends on whether the engine searches for
    related items or users when trying to recommend a particular item.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 构建推荐引擎取决于引擎在尝试推荐特定物品时是搜索相关物品还是用户。
- en: In item-based analysis, the engine focuses on identifying items that are similar
    to a particular item, while in user-based analysis, users similar to the particular
    user are determined first. For example, users with the same profile information
    (age, gender, and so on) or action history (bought, watched, viewed, and so on)
    are determined, and then the same items are recommended to other, similar users.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于物品的分析中，引擎专注于识别与特定物品相似的物品，而在基于用户的分析中，首先确定与特定用户相似的用户。例如，确定具有相同配置文件信息（年龄、性别等）或行为历史（购买、观看、查看等）的用户，然后向其他类似用户推荐相同的物品。
- en: Both approaches require us to compute a similarity matrix, depending on whether
    we're analyzing item attributes or user actions. Let's take a deeper look at how
    this is done.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都需要我们计算一个相似度矩阵，这取决于我们是分析物品属性还是用户行为。让我们深入了解这是如何完成的。
- en: Calculating similarity
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算相似度
- en: 'There are three fundamental approaches to calculating similarity, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 计算相似度有三种基本方法，如下所示：
- en: Collaborative filtering algorithms take user ratings or other user behaviors
    and make recommendations based on what users with similar behaviors liked or purchased
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协同过滤算法通过用户评分或其他用户行为，根据具有相似行为的用户喜欢或购买的内容进行推荐
- en: The content-based algorithm uses the properties of the items to find items with
    similar properties
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于内容的算法使用物品的特性来寻找具有相似特性的物品
- en: A hybrid approach combines collaborative and content-based filtering
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合方法结合了协同过滤和基于内容的过滤
- en: Let's take a look at each approach in detail in the following sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将详细探讨每种方法。
- en: Collaborative filtering
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: '**Collaborative filtering** is based solely on user ratings or other user behaviors,
    making recommendations based on what users with similar behaviors liked or purchased.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**协同过滤**仅基于用户评分或其他用户行为，根据具有相似行为的用户喜欢或购买的内容进行推荐。'
- en: A key advantage of collaborative filtering is that it does not rely on item
    content, and therefore, it is capable of accurately recommending complex items,
    such as movies, without understanding the item itself. The underlying assumption
    is that people that agreed in the past will agree in the future, and that they
    will like similar kinds of items to what they liked in the past.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤的一个关键优势是它不依赖于物品内容，因此能够准确地推荐复杂物品，如电影，而不需要了解物品本身。其基本假设是，过去达成共识的人将来也会达成共识，并且他们将会喜欢与过去相似类型的物品。
- en: A major disadvantage of this approach is the so-called cold start, meaning that
    if we want to build an accurate collaborative filtering system, the algorithm
    often needs a large amount of user ratings. This usually takes collaborative filtering
    out of the first version of the product, and it is introduced later, when a decent
    amount of data has been collected.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个主要缺点是所谓的冷启动问题，这意味着如果我们想构建一个准确的协同过滤系统，算法通常需要大量的用户评分。这通常会将协同过滤排除在产品的第一版之外，并在收集到一定量的数据后引入。
- en: Content-based filtering
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: Content-based filtering, on the other hand, is based on a description of items
    and a profile of a user's preferences, which is combined as follows. First, the
    items are described with attributes, and to find similar items, we measure the
    distances between items using a distance measure, such as the cosine distance
    or Pearson coefficient (there is more about distance measures in [Chapter 1](11a9489b-c4dd-4544-ace8-f84533d8fd7c.xhtml),
    *Applied Machine Learning Quick Start*). Now, the user profile enters the equation.
    Given the feedback about the kinds of items the user likes, we can introduce weights,
    specifying the importance of a specific item attribute. For instance, the Pandora
    Radio streaming service applies content-based filtering to create stations, using
    more than 400 attributes. A user initially picks a song with specific attributes,
    and, by providing feedback, important song attributes are emphasized.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，基于内容的过滤是基于项目描述和用户偏好配置文件的，它们如下组合。首先，项目用属性进行描述，为了找到相似的项目，我们使用距离度量（如余弦距离或皮尔逊系数）来测量项目之间的距离（关于距离度量，请参阅[第1章](11a9489b-c4dd-4544-ace8-f84533d8fd7c.xhtml)，《应用机器学习快速入门》）。现在，用户配置文件进入方程。给定用户喜欢的项目类型的反馈，我们可以引入权重，指定特定项目属性的重要性。例如，Pandora流媒体服务应用基于内容的过滤来创建电台，使用超过400个属性。用户最初选择具有特定属性的曲目，并通过提供反馈，强调重要的歌曲属性。
- en: Initially, this approach needs very little information on user feedback; thus,
    it effectively avoids the cold start issue.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，这种方法对用户反馈信息的需求非常少；因此，它有效地避免了冷启动问题。
- en: Hybrid approach
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合方法
- en: Now, between collaborative and content-based, which one should you choose? Collaborative
    filtering is able to learn user preferences from a user's actions regarding one
    content source, and use them across other content types. Content-based filtering
    is limited to recommending content of the same type that the user is already using.
    This provides value in certain use cases; for example, recommending news articles
    based on news browsing is useful, but it is much more useful if different sources,
    such as books and movies, can be recommended based on news browsing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在协作式和基于内容的推荐之间，你应该选择哪一个？协作式过滤能够从用户针对一个内容源的行为中学习用户偏好，并将这些偏好应用于其他内容类型。基于内容的过滤仅限于推荐用户已经使用过的同一类型的内容。这在某些用例中提供了价值；例如，基于新闻浏览推荐新闻文章是有用的，但如果可以根据新闻浏览推荐不同来源的内容，如书籍和电影，那就更有用了。
- en: Collaborative filtering and content-based filtering are not mutually exclusive;
    they can be combined to be more effective in some cases. For example, Netflix
    uses collaborative filtering to analyze the searching and watching patterns of
    similar users, as well as content-based filtering to offer movies that share characteristics
    with films that the user has rated highly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 协作式过滤和基于内容的过滤不是相互排斥的；在某些情况下，它们可以结合使用，以更有效。例如，Netflix使用协作式过滤来分析类似用户的搜索和观看模式，以及基于内容的过滤来提供与用户高度评价的电影具有相似特征的电影。
- en: 'There is a wide variety of hybridization techniques: weighted, switching, and
    mixed, feature combination, feature augmentation, cascade, meta-level, and so
    on. Recommendation systems are an active area in the machine learning and data
    mining community, with special tracks on data science conferences. A good overview
    of techniques is summarized in the paper *Toward the Next Generation of Recommender
    Systems: A Survey of the State-of-the-Art and Possible Extensions,* by Adomavicius
    and Tuzhilin (2005), where the authors discuss different approaches and underlying
    algorithms, and provide references to further papers. To get more technical and
    understand all of the tiny details when a particular approach makes sense, you
    should look at the book edited by Ricci, et al.: *Recommender Systems Handbook*
    (First Edition, 2010, *S*pringer-Verlag, New York).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种各样的混合技术：加权、切换、混合、特征组合、特征增强、级联、元级等。推荐系统是机器学习和数据挖掘社区中的一个活跃领域，在数据科学会议上设有专门的轨道。Adomavicius和Tuzhilin在2005年的论文《迈向下一代推荐系统：对现有技术和可能扩展的调查》中对技术进行了很好的概述，其中作者讨论了不同的方法和底层算法，并提供了进一步论文的参考文献。为了更深入地了解特定方法何时合理，并理解所有细微的细节，你应该查看Ricci等人编辑的书籍：《推荐系统手册》（第一版，2010年，*Springer-Verlag*，纽约）。
- en: Exploitation versus exploration
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索与利用
- en: In recommendation systems, there is always a trade-off between recommending
    items that fall into the user's sweet spot, based on what we already know about
    the user (**exploitation**), and recommending items that don't fall into the user's
    sweet spot, with the aim to expose the user to some novelties (**exploration**).
    Recommendation systems with little exploration will only recommend items that
    are consistent with the previous user ratings, thus preventing showing items outside
    of their current bubble. In practice, the serendipity of getting new items out
    of the user's sweet spot is often desirable, leading to a pleasant surprise, and
    potentially, the discovery of new sweet spots.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在推荐系统中，总是存在一种权衡，即在基于我们已知用户信息推荐符合用户喜好的项目（**利用**）和推荐不符合用户喜好的项目，旨在让用户接触一些新奇之处（**探索**）之间。缺乏探索的推荐系统只会推荐与之前用户评分一致的项目，从而防止展示用户当前泡泡之外的项目。在实践中，从用户喜好的泡泡之外获得新项目的惊喜往往是非常受欢迎的，这可能导致令人愉快的惊喜，甚至可能发现新的喜好的区域。
- en: In this section, we discussed the essential concepts required to start building
    recommendation engines. Now, let's take a look at how to actually build one with
    Apache Mahout.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了开始构建推荐引擎所需的基本概念。现在，让我们看看如何使用 Apache Mahout 实际构建一个推荐引擎。
- en: Getting Apache Mahout
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 Apache Mahout
- en: Mahout was introduced in [Chapter 2](6fd557d7-2807-4a6d-8f93-d7c4ca094b7e.xhtml),
    *Java Libraries and Platforms for Machine Learning*, as a scalable machine learning
    library. It provides a rich set of components with which you can construct a customized
    recommendation system from a selection of algorithms. The creators of Mahout say
    that it is designed to be enterprise-ready; it's designed for performance, scalability,
    and flexibility.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mahout 在 [第 2 章](6fd557d7-2807-4a6d-8f93-d7c4ca094b7e.xhtml)，“Java 机器学习库和平台”中被介绍为一个可扩展的机器学习库。它提供了一套丰富的组件，您可以使用这些组件从算法选择中构建定制的推荐系统。Mahout
    的创造者表示，它被设计为适用于企业；它旨在性能、可扩展性和灵活性。 '
- en: 'Mahout can be configured to run in two flavors: with or without Hadoop, and
    for a single machine and distributed processing, respectively. We will focus on
    configuring Mahout without Hadoop. For more advanced configurations and further
    uses of Mahout, I would recommend two recent books: *Learning Apache Mahout,*
    by *C*handramani Tiwary, Packt Publishing, and *Learning Apache Mahout Classification,*
    by Ashish Gupta, Packt Publishing.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Mahout 可以配置为以两种方式运行：带有或没有 Hadoop，以及对于单机和分布式处理。我们将专注于配置不带 Hadoop 的 Mahout。对于更高级的配置和
    Mahout 的进一步使用，我推荐两本近期出版的书籍：由 Chandramani Tiwary 编著的 *Learning Apache Mahout*，Packt
    出版，以及 Ashish Gupta 编著的 *Learning Apache Mahout Classification*，Packt 出版。
- en: As Apache Mahout's build and release system is based on Maven, you will need
    to learn how to install it. We will look at the most convenient approach; using
    Eclipse with the Maven plugin.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Apache Mahout 的构建和发布系统基于 Maven，您需要学习如何安装它。我们将查看最方便的方法；使用带有 Maven 插件的 Eclipse。
- en: Configuring Mahout in Eclipse with the Maven plugin
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Eclipse 中使用 Maven 插件配置 Mahout
- en: 'You will need a recent version of Eclipse, which can be downloaded from its
    home page ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)).
    In this book, we will use Eclipse Luna. Open Eclipse and start a new Maven Project
    with the default settings, as shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个较新的 Eclipse 版本，可以从其主页下载（[https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/)）。在本书中，我们将使用
    Eclipse Luna。打开 Eclipse 并使用默认设置启动一个新的 Maven 项目，如图所示：
- en: '![](img/d0f0d765-b4d9-4f6b-9e91-da68d83c8b55.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0f0d765-b4d9-4f6b-9e91-da68d83c8b55.png)'
- en: 'The New Maven project screen will appear, as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将会显示新的 Maven 项目屏幕，如图所示：
- en: '![](img/09486760-7963-446f-a3a7-a8f436d10cbc.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09486760-7963-446f-a3a7-a8f436d10cbc.png)'
- en: 'Now, we need to tell the project to add the Mahout JAR file and its dependencies
    to the project. Locate the `pom.xml` file and open it with the text editor (left-click
    on Open With | Text Editor), as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉项目添加 Mahout JAR 文件及其依赖项。定位到 `pom.xml` 文件，并使用文本编辑器打开它（左键单击“打开方式”|“文本编辑器”），如图所示：
- en: '![](img/ad5a51b9-7f0e-44ad-a6bc-0cd4695675ef.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad5a51b9-7f0e-44ad-a6bc-0cd4695675ef.png)'
- en: 'Locate the line starting with `<dependencies>` and add the following code in
    the next line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到以 `<dependencies>` 开头的行，并在下一行添加以下代码：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's it; Mahout has been added, and we are ready to begin.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；Mahout 已经添加，我们准备开始。
- en: Building a recommendation engine
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建推荐引擎
- en: To demonstrate both the content-based filtering and collaborative filtering
    approaches, we'll build a book recommendation engine.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示基于内容的过滤和协同过滤方法，我们将构建一个书籍推荐引擎。
- en: Book ratings dataset
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 书籍评分数据集
- en: 'In this chapter, we will work with a book ratings dataset (Ziegler et al.,
    2005) that was collected in a four-week crawl. It contains data on 278,858 members
    of the Book-Crossing website and 1,157,112 ratings, both implicit and explicit,
    referring to 271,379 distinct ISBNs. User data is anonymized, but with demographic
    information. The dataset is taken from [Improving Recommendation Lists Through
    Topic Diversification](http://www2.informatik.uni-freiburg.de/~dbis/Publications/05/WWW05.html),
    *C*ai-Nicolas Ziegler, Sean M. McNee, Joseph A. Konstan, Georg Lausen: *Proceedings
    of the 14th International World Wide Web Conference* (WWW ''05)*,* May 10-14,
    2005, Chiba, Japan ([http://www2.informatik.uni-freiburg.de/~cziegler/BX/](http://www2.informatik.uni-freiburg.de/~cziegler/BX/)).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将使用一个书籍评分数据集（Ziegler et al., 2005），该数据集是在四周的爬取中收集的。它包含了Book-Crossing网站278,858名成员的数据和1,157,112个评分，包括隐式和显式评分，涉及271,379个不同的ISBN。用户数据被匿名化，但包含人口统计信息。数据集来自[Cai-Nicolas
    Ziegler, Sean M. McNee, Joseph A. Konstan, Georg Lausen: *Proceedings of the 14th
    International World Wide Web Conference* (WWW ''05)](http://www2.informatik.uni-freiburg.de/~dbis/Publications/05/WWW05.html)，*C*ai-Nicolas
    Ziegler，Sean M. McNee，Joseph A. Konstan，Georg Lausen：*第十四届国际万维网会议论文集*（WWW ''05）*，2005年5月10日至14日，日本千叶（[http://www2.informatik.uni-freiburg.de/~cziegler/BX/](http://www2.informatik.uni-freiburg.de/~cziegler/BX/)）。'
- en: 'The Book-Crossing dataset is comprised of three files, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Book-Crossing数据集由三个文件组成，如下：
- en: '`BX-Users`: This contains the users. Note that user IDs (User-ID) have been
    anonymized and mapped to integers. Demographic data is provided (Location and
    Age) if available. Otherwise, these fields contain null values.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BX-Users`：这个文件包含用户信息。请注意，用户ID（User-ID）已经被匿名化并映射到整数。如果可用，提供人口统计信息（位置和年龄）。否则，这些字段包含空值。'
- en: '`BX-Books`: Books are identified by their respective ISBNs. Invalid ISBNs have
    already been removed from the dataset. Moreover, some content-based information
    is given (Book-Title, Book-Author, Year-Of-Publication, and Publisher), which
    has been obtained from Amazon Web Services. Note that in the case of several authors,
    only the first author is provided. URLs linking to cover images are also given,
    appearing in three different flavors (Image-URL-S, Image-URL-M, and Image-URL-L),
    referring to small, medium, and large URLs. These URLs point to the Amazon website.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BX-Books`：书籍通过其相应的ISBN进行标识。无效的ISBN已经从数据集中删除。此外，还提供了一些基于内容的信息（Book-Title，Book-Author，Year-Of-Publication，和Publisher），这些信息是从亚马逊网络服务获得的。请注意，在多个作者的情况下，只提供第一个作者。还提供了链接到封面图片的URL，有三种不同的格式（Image-URL-S，Image-URL-M，和Image-URL-L），分别指小、中、大URL。这些URL指向亚马逊网站。'
- en: '`BX-Book-Ratings`: This contains the book rating information. Ratings (Book-Rating)
    are either explicit, expressed on a scale of 1-10 (with higher values denoting
    higher appreciation), or implicit, expressed by 0.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BX-Book-Ratings`：这个文件包含书籍评分信息。评分（Book-Rating）要么是显式的，表示在1-10的刻度上（数值越高表示越受欣赏），要么是隐式的，用0表示。'
- en: Loading the data
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载数据
- en: 'There are two approaches to loading the data, according to where the data is
    stored: a file or database. First, we will take a detailed look at how to load
    the data from a file, including how to deal with custom formats. At the end, we
    will quickly take a look at how to load the data from a database.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据存储的位置（文件或数据库），有两种加载数据的方法：首先，我们将详细探讨如何从文件加载数据，包括如何处理自定义格式。最后，我们将快速查看如何从数据库加载数据。
- en: Loading data from a file
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件加载数据
- en: 'Loading data from a file can be achieved with the `FileDataModel` class. We
    will be expecting a comma-delimited file, where each line contains a `userID`,
    an `itemID`, an optional `preference` value, and an optional `timestamp`, in the
    same order, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`FileDataModel`类从文件加载数据。我们期望的是一个逗号分隔的文件，其中每行包含一个`userID`，一个`itemID`，一个可选的`preference`值和一个可选的`timestamp`，顺序如下：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An optional preference accommodates applications with binary preference values,
    that is, the user either expresses a preference for an item or not, without a
    degree of preference; for example, with a like or dislike.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可选的偏好设置可以适应具有二元偏好值的程序，也就是说，用户要么表达对一个项目的偏好，要么不表达，没有偏好程度；例如，用喜欢或不喜欢表示。
- en: A line that begins with a hash (`#`) or an empty line will be ignored. It is
    also acceptable for the lines to contain additional fields, which will be ignored.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以井号（`#`）或空行开始的行将被忽略。这些行也可以包含额外的字段，这些字段将被忽略。
- en: 'The `DataModel` class assumes the following types:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataModel`类假定以下类型：'
- en: The `userID` and `itemID` can be parsed as `long`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userID`和`itemID`可以被解析为`long`'
- en: The `preference` value can be parsed as `double`
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preference`值可以被解析为`double`'
- en: The `timestamp` can be parsed as `long`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timestamp`可以被解析为`long`'
- en: 'If you are able to provide the dataset in the preceding format, you can simply
    use the following line to load the data:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能够以先前格式提供数据集，您可以使用以下行加载数据：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class is not intended to be used for very large amounts of data; for example,
    tens of millions of rows. For that, a JDBC-backed `DataModel` and a database are
    more appropriate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类不适用于处理大量数据；例如，数千万行。对于这种情况，一个基于JDBC的`DataModel`和数据库更为合适。
- en: In the real world, however, we cannot always ensure that the input data supplied
    to us contains only integer values for `userID` and `itemID`. For example, in
    our case, `itemID` corresponds to ISBN book numbers, which uniquely identify items,
    but these are not integers, and the `FileDataModel` default won't be suitable
    to process our data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实世界中，我们并不能总是确保提供给我们的输入数据只包含`userID`和`itemID`的整数值。例如，在我们的案例中，`itemID`对应于ISBN书号，这些书号唯一标识项目，但它们不是整数，`FileDataModel`的默认设置将不适合处理我们的数据。
- en: Now, let's consider how to deal with a case where our `itemID` is a string.
    We will define our custom data model by extending `FileDataModel` and overriding
    the long `readItemIDFromString(String)` method in order to read the `itemID` as
    a string and convert it into `long`, and return a unique `long` value. To convert
    a `String` into a unique `long`, we'll extend another Mahout `AbstractIDMigrator`
    helper class, which is designed exactly for this task.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑如何处理我们的`itemID`是一个字符串的情况。我们将通过扩展`FileDataModel`并重写长`readItemIDFromString(String)`方法来定义我们的自定义数据模型，以便将`itemID`作为字符串读取并将其转换为`long`，并返回一个唯一的`long`值。为了将`String`转换为唯一的`long`，我们将扩展另一个Mahout的`AbstractIDMigrator`辅助类，该类正是为此任务设计的。
- en: 'Now, let''s look at how `FileDataModel` is extended:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何扩展`FileDataModel`：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Other useful methods that can be overridden are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以覆盖的其他有用方法如下：
- en: '`readUserIDFromString(String value)`, if user IDs are not numeric'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readUserIDFromString(String value)`，如果用户ID不是数字'
- en: '`readTimestampFromString(String value)`, to change how `timestamp` is parsed'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readTimestampFromString(String value)`，以改变`timestamp`的解析方式'
- en: 'Now, let''s take a look at how `AbstractIDMIgrator` is extended:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何扩展`AbstractIDMIgrator`：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we have everything in place, and we can load our dataset with the following
    code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了所有东西，我们可以使用以下代码加载数据集：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This provides the total number of users and items as output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了用户和项目的总数作为输出：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are ready to move on and start making recommendations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好继续前进并开始制作推荐。
- en: Loading data from a database
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库加载数据
- en: Alternatively, we can load the data from a database using one of the JDBC data
    models. In this chapter, we will not dive into the detailed instructions of how
    to set up a database, connections, and so on, but we will give a sketch of how
    this can be done.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用JDBC数据模型之一从数据库加载数据。在本章中，我们不会深入介绍如何设置数据库、连接等详细说明，但我们将给出如何做到这一点的概要。
- en: 'Database connectors have been moved to a separate package, `mahout-integration`;
    hence, we have to add the package to our `dependency` list. Open the `pom.xml`
    file and add the following `dependency`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接器已被移动到单独的包`mahout-integration`中；因此，我们必须将此包添加到我们的`dependency`列表中。打开`pom.xml`文件并添加以下`dependency`：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Consider that we want to connect to a MySQL database. In this case, we will
    also need a package that handles database connections. Add the following to the
    `pom.xml` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们想要连接到MySQL数据库。在这种情况下，我们还需要一个处理数据库连接的包。将以下内容添加到`pom.xml`文件中：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we have all of the packages, so we can create a connection. First, let''s
    initialize a `DataSource` class with connection details, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了所有的包，因此我们可以创建一个连接。首先，让我们使用以下方式初始化一个带有连接详情的`DataSource`类：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Mahout integration implements `JDBCDataModel` to various databases that can
    be accessed via JDBC. By default, this class assumes that there is a `DataSource`
    available under the JNDI name, `jdbc/taste`, which gives access to a database
    with a
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Mahout集成实现了`JDBCDataModel`，以便通过JDBC访问各种数据库。默认情况下，此类假定在JNDI名称`jdbc/taste`下有一个可用的`DataSource`，它提供了访问数据库的权限，
- en: '`taste_preferences` table, with the following schema:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`taste_preferences`表，具有以下模式：'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A database-backed data model is initialized as follows. In addition to the
    DB connection object, we can specify the custom table name and the table column
    names, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基于数据库的数据模型初始化如下。除了DB连接对象外，我们还可以指定自定义表名和表列名，如下所示：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In-memory databases
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存数据库
- en: Last, but not least, the data model can be created on the fly and held in memory.
    A database can be created from an array of preferences, which will hold user ratings
    for a set of items.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，数据模型可以即时创建并保存在内存中。可以从偏好数组创建一个数据库，它将保存一组物品的用户评分。
- en: 'We can proceed as follows. First, we create a `FastByIdMap` hash map of preference
    arrays, `PreferenceArray`, which stores an array of preferences:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下步骤进行。首先，我们创建一个偏好数组`PreferenceArray`的`FastByIdMap`哈希表，它存储了一个偏好数组：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we can create a new preference array for a user that will hold their
    ratings. The array must be initialized with a size parameter that reserves that
    many slots in the memory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为用户创建一个新的偏好数组，该数组将保存他们的评分。数组必须使用大小参数初始化，以在内存中预留这么多槽位：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we set the user ID for the current preference at the position `0`. This
    will actually set the user ID for all preferences:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们将当前偏好的用户ID设置在位置`0`。这实际上会将所有偏好的用户ID都设置好：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Set an `itemID` for the current preference at the position `0`, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将`itemID`设置为`0`位置的当前偏好，如下所示：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set the preference value for the preference at `0`, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将偏好值设置为`0`位置的偏好，如下所示：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Continue for other item ratings, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式继续对其他物品评分：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, add the user `preferences` to the hash map:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将用户的`preferences`添加到哈希表中：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preference hash map can now be used to initialize `GenericDataModel`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用偏好哈希表来初始化`GenericDataModel`：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code demonstrates how to add two preferences for a single user; in a practical
    application, you'll want to add multiple preferences for multiple users.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了如何为单个用户添加两个偏好；在实际应用中，你可能需要为多个用户添加多个偏好：
- en: Collaborative filtering
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: The recommendation engines in Mahout can be built with the `org.apache.mahout.cf.taste`
    package, which was formerly a separate project called `Taste`, and has continued to
    be developed in Mahout.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Mahout中的推荐引擎可以使用`org.apache.mahout.cf.taste`包构建，该包之前是一个名为`Taste`的独立项目，并且一直在Mahout中继续开发。
- en: A Mahout-based collaborative filtering engine takes the users' preferences for
    items (tastes) and returns the estimated preferences for other items. For example,
    a site that sells books or CDs could easily use Mahout to figure out the CDs that
    a customer might be interested in listening to, with the help of previous purchase
    data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Mahout的协同过滤引擎通过用户的物品偏好（口味）并返回其他物品的估计偏好。例如，一个销售书籍或CD的网站可以很容易地使用Mahout来找出顾客可能感兴趣的CD，借助之前的购买数据。
- en: 'Top-level packages define the Mahout interfaces to the following key abstractions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最高级别的包定义了Mahout接口到以下关键抽象：
- en: '**DataModel**: This represents a repository of information about users and
    their preferences for items'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DataModel**：这代表了一个关于用户及其对物品偏好的信息库'
- en: '**UserSimilarity**: This defines a notion of similarity between two users'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UserSimilarity**：这定义了两个用户之间相似性的概念'
- en: '**ItemSimilarity**: This defines a notion of similarity between two items'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ItemSimilarity**：这定义了两个物品之间相似性的概念'
- en: '**UserNeighborhood**: This computes neighboring users for a given user'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UserNeighborhood**：这为给定用户计算邻近用户'
- en: '**Recommender**: This recommends items for the user'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Recommender**：这为用户推荐物品'
- en: 'A general structure of the preceding concepts is shown in the following diagram:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述概念的一般结构如下所示：
- en: '![](img/4e64495c-df83-4e76-84b8-0150cf124ea9.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e64495c-df83-4e76-84b8-0150cf124ea9.png)'
- en: User-based filtering
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户的过滤
- en: 'The most basic user-based collaborative filtering can be implemented by initializing
    the previously described components, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的基于用户的协同过滤可以通过初始化之前描述的组件来实现，如下所示：
- en: 'First, load the data model:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，加载数据模型：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, define how to calculate how the users are correlated; for example, using
    the Pearson correlation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义如何计算用户之间的相关性；例如，使用皮尔逊相关系数：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, define how to tell which users are similar, that is, the users that are
    close to each other, according to their ratings:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义如何根据用户的评分来判断哪些用户是相似的，即彼此靠近的用户：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can initialize a `GenericUserBasedRecommender` default engine with
    the data for `model`, `neighborhood`, and similar objects, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`model`、`neighborhood`和类似对象的数据初始化一个`GenericUserBasedRecommender`默认引擎，如下所示：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That''s it. Our first basic recommendation engine is ready. Let''s discuss
    how to invoke recommendations. First, let''s print the items that the user has
    already rated, along with ten recommendations for that user:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们的第一个基本推荐引擎已经准备好了。让我们讨论如何调用推荐。首先，让我们打印出用户已经评价的项目，以及为该用户提供的十个推荐项目：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will provide the following recommendations, along with their scores, as
    output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下推荐，包括它们的分数：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Item-based filtering
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于项目的过滤
- en: The `ItemSimilarity` attribute is the most important point to discuss here.
    Item-based recommenders are useful, as they can take advantage of something very
    fast; they base their computations on item similarity, not user similarity, and
    item similarity is relatively static. It can be precomputed, instead of recomputed
    in real time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要讨论的最重要的一点是`ItemSimilarity`属性。基于项目的推荐器很有用，因为它们可以利用一些非常快速的东西；它们基于项目相似性进行计算，而不是用户相似性，并且项目相似性相对静态。它可以预先计算，而不是实时重新计算。
- en: 'Thus, it''s strongly recommended that you use `GenericItemSimilarity` with
    precomputed similarities, if you''re going to use this class. You can use `PearsonCorrelationSimilarity`,
    too, which computes similarities in real time, but you will probably find this
    painfully slow for large amounts of data:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，强烈建议您在使用此类时使用预计算的相似性的`GenericItemSimilarity`。您也可以使用`PearsonCorrelationSimilarity`，它实时计算相似性，但您可能会发现对于大量数据来说这非常慢：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The resulting list returns a set of items that are similar to a particular item
    that we selected.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的列表将返回一组与我们选定的特定项目相似的项目。
- en: Adding custom rules to recommendations
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向推荐中添加自定义规则
- en: 'It often happens that some business rules require us to boost the score of
    the selected items. In the book dataset, for example, if a book is recent, we
    want to give it a higher score. That''s possible by using the `IDRescorer` interface,
    as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会有一些业务规则要求我们提高所选项目的分数。例如，在书籍数据集中，如果一本书是新的，我们希望给它一个更高的分数。这可以通过使用`IDRescorer`接口来实现，如下所示：
- en: '`rescore(long, double)` takes the `itemId` and original score as an argument
    and returns a modified score'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rescore(long, double)`接受`itemId`和原始分数作为参数，并返回一个修改后的分数。'
- en: '`isFiltered(long)` returns `true` to exclude a specific item from the recommendations,
    or `false`, otherwise'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFiltered(long)`返回`true`以排除推荐中的特定项目，或者返回`false`。'
- en: 'Our example can be implemented as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例可以如下实现：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'An instance of `IDRescorer` is provided when invoking `recommender.recommend`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`recommender.recommend`时提供了一个`IDRescorer`实例：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Evaluation
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: You might be wondering how to make sure that the returned recommendations make
    any sense. The only way to really be sure about how effective recommendations
    are is to use A/B testing in a live system, with real users. For example, the
    A group receives a random item as a recommendation, while the B group receives
    an item that's recommended by our engine.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何确保返回的推荐是有意义的。真正确保推荐有效性的唯一方法是在实际系统中使用A/B测试，并使用真实用户。例如，A组收到一个随机项目作为推荐，而B组收到我们引擎推荐的项。
- en: As this is not always possible (nor practical), we can get an estimate with
    offline statistical evaluation. One way to proceed is to use k-fold cross-validation,
    which was introduced in [Chapter 1](11a9489b-c4dd-4544-ace8-f84533d8fd7c.xhtml),
    *Applied Machine Learning Quick Start*. We partition a dataset into multiple sets;
    some are used to train our recommendation engine, and the rest are used to test
    how well it recommends items to unknown users.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这并不总是可能（也不实用），我们可以通过离线统计分析来获得一个估计值。一种进行的方法是使用[第1章](11a9489b-c4dd-4544-ace8-f84533d8fd7c.xhtml)中介绍的k折交叉验证，*《应用机器学习快速入门》*。我们将数据集划分为多个集合；一些用于训练我们的推荐引擎，其余的用于测试推荐引擎对未知用户推荐项目的效果。
- en: Mahout implements the `RecommenderEvaluator` class, which splits a dataset in
    two parts. The first part (90%, by default) is used to produce recommendations,
    while the rest of the data is compared against estimated preference values in
    order to test the match. The class does not accept a `recommender` object directly;
    you need to build a class that's implementing the `RecommenderBuilder` interface
    instead, which builds a `recommender` object for a given `DataModel` object that
    is then used for testing. Let's take a look at how this is implemented.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Mahout实现了`RecommenderEvaluator`类，它将数据集分成两部分。第一部分（默认为90%）用于生成推荐，而其余数据则与估计的偏好值进行比较，以测试匹配度。该类不接受`recommender`对象直接；你需要构建一个实现`RecommenderBuilder`接口的类，该类为给定的`DataModel`对象构建一个`recommender`对象，然后用于测试。让我们看看这是如何实现的。
- en: 'First, we create a class that implements the `RecommenderBuilder` interface.
    We need to implement the `buildRecommender` method, which will return a `recommender`,
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个实现`RecommenderBuilder`接口的类。我们需要实现`buildRecommender`方法，它将返回一个`recommender`，如下所示：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have a class that returns a recommender object, we can initialize
    a `RecommenderEvaluator` instance. The default implementation of this class is
    the `AverageAbsoluteDifferenceRecommenderEvaluator` class, which computes the
    average absolute difference between the predicted and actual ratings for users.
    The following code shows how to put the pieces together and run a hold-out test:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个返回推荐对象类的类，我们可以初始化一个`RecommenderEvaluator`实例。这个类的默认实现是`AverageAbsoluteDifferenceRecommenderEvaluator`类，它计算预测评分和实际评分之间的平均绝对差异。以下代码展示了如何组合这些部分并运行一个保留测试：
- en: 'First, load a data model, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，加载一个数据模型，如下所示：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, initialize an `evaluator` instance, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化一个`evaluator`实例，如下所示：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Initialize the `BookRecommender` object, implementing the `RecommenderBuilder`
    interface, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化实现`RecommenderBuilder`接口的`BookRecommender`对象，如下所示：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, call the `evaluate()` method, which accepts the following parameters:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`evaluate()`方法，它接受以下参数：
- en: '`RecommenderBuilder`: This is the object implementing the `RecommenderBuilder`
    that can build the `recommender` to test'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecommenderBuilder`：这是实现`RecommenderBuilder`的对象，可以构建用于测试的`recommender`'
- en: '`DataModelBuilder`: This indicates the `DataModelBuilder` to use; if null,
    a default `DataModel` implementation will be used'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataModelBuilder`：这表示要使用的`DataModelBuilder`；如果为null，将使用默认的`DataModel`实现'
- en: '`DataModel`: This is the dataset that will be used for testing'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataModel`：这是用于测试的数据集'
- en: '`trainingPercentage`: This indicates the percentage of each user''s preferences
    to use to produce recommendations; the rest are compared to estimated preference
    values in order to evaluate the performance of the `recommender`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trainingPercentage`：这表示用于生成推荐的每个用户的偏好百分比；其余的与估计的偏好值进行比较，以评估`recommender`的性能'
- en: '`evaluationPercentage`: This is the percentage of users to be used in the evaluation'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`evaluationPercentage`：这是用于评估的用户百分比'
- en: 'The method is called as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法调用如下：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The method returns a `double`, where `0` represents the best possible evaluation,
    meaning that the recommender perfectly matches user preferences. In general, the
    lower the value, the better the match.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个`double`类型的值，其中`0`代表最佳可能的评估，意味着推荐器完美匹配用户偏好。一般来说，值越低，匹配度越好。
- en: Online learning engine
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线学习引擎
- en: In any online platform, the new users will continue increasing. The previously
    discussed approach works well for the existing user. It is expensive to create
    a recommendation instance for every new user that's added. We cannot ignore the
    users that have been added to the system after the recommendation engine is made.
    To cope with situations that are similar to this, Apache Mahout has the ability
    of adding a temporary user to a data model.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何在线平台上，新用户将持续增加。之前讨论的方法对现有用户效果良好。为每个新增用户创建推荐实例的成本很高。我们不能忽视在推荐引擎制作后添加到系统中的用户。为了应对类似这种情况，Apache
    Mahout具有将临时用户添加到数据模型的能力。
- en: 'The general setup is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一般设置如下：
- en: Periodically recreate the whole recommendation using current data (for example,
    each day or hour, depending on how long it takes)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期使用当前数据重新创建整个推荐（例如，每天或每小时，具体取决于所需时间）
- en: Always check whether the user exists in the system before going for a recommendation
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行推荐之前，始终检查用户是否存在于系统中
- en: If the user exists, then complete the recommendations
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户存在，则完成推荐
- en: If the user does not exist, create a temporary user, fill in the preferences,
    and do the recommendation
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户不存在，创建一个临时用户，填写偏好，然后进行推荐
- en: The first step seems to be tricky, in regards to how frequently the whole recommendation
    is to be generated using the current data. If the system is huge, memory constraints
    will be there, because when the new recommender is being generated, the old, working
    recommender should be held in memory, so the request is being served from the
    old copy until the new recommender is ready.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步似乎有些棘手，因为它涉及到使用当前数据生成整个推荐的频率。如果系统很大，内存限制将会存在，因为当新的推荐器正在生成时，旧的、正在工作的推荐器应该保留在内存中，以便在新的推荐器准备好之前，请求由旧副本提供服务。
- en: 'As for the temporary users, we can wrap our data model with a `PlusAnonymousConcurrentUserDataModel`
    instance. This class allows us to obtain a temporary user ID; the ID must later
    be released so that it can be reused (there''s a limited number of such IDs).
    After obtaining the ID, we have to fill in the preferences, and then we can proceed
    with the recommendation, as always:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 至于临时用户，我们可以用`PlusAnonymousConcurrentUserDataModel`实例包装我们的数据模型。这个类允许我们获取一个临时用户ID；该ID必须稍后释放以便可以重用（这类ID的数量有限）。在获取ID后，我们必须填写偏好，然后我们可以像往常一样进行推荐：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Content-based filtering
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内容的过滤
- en: 'Content-based filtering is out of the scope of the Mahout framework, mainly
    because it is up to you to decide how to define similar items. If we want to do
    a content-based item similarity, we need to implement our own `ItemSimilarity`.
    For instance, in our book''s dataset, we might want to make up the following rule
    for book similarity:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基于内容的过滤不在Mahout框架的范围内，主要是因为如何定义相似项目取决于你。如果我们想进行基于内容的项目相似度，我们需要实现自己的`ItemSimilarity`。例如，在我们的书籍数据集中，我们可能想要为书籍相似度制定以下规则：
- en: If the genres are the same, add `0.15` to `similarity`
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果流派相同，将`0.15`加到`相似度`
- en: If the author is the same, add `0.50` to `similarity`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果作者相同，将`0.50`加到`相似度`
- en: 'We can now implement our own `similarity` measure, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实施自己的`相似度`度量，如下所示：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can then use this `ItemSimilarity`, instead of something like `LogLikelihoodSimilarity`,
    or other implementations with a `GenericItemBasedRecommender`. That's about it.
    This is as far as we have to go to perform content-based recommendations in the
    Mahout framework.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个`ItemSimilarity`，而不是像`LogLikelihoodSimilarity`或其他带有`GenericItemBasedRecommender`的实现。这就是全部。这就是我们在Mahout框架中执行基于内容推荐所必须做的。
- en: What we saw here is one of the simplest forms of content-based recommendation.
    Another approach would be to create a content-based profile of users, based on
    a weighted vector of item features. The weights denote the importance of each
    feature to the user, and can be computed from individually-rated content vectors.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是基于内容推荐的最简单形式之一。另一种方法是根据项目特征的加权向量创建用户的内容配置文件。权重表示每个特征对用户的重要性，并且可以从单独评分的内容向量中计算得出。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the basic concept of recommendation engines,
    the differences between collaborative and content-based filtering, and how to
    use Apache Mahout, which is a great basis for creating recommenders, as it is
    very configurable and provides many extension points. We looked at how to pick
    the right configuration parameter values, set up rescoring, and evaluate the recommendation
    results.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了推荐引擎的基本概念，协作过滤和基于内容过滤之间的区别，以及如何使用Apache Mahout，这是一个创建推荐器的绝佳基础，因为它非常可配置，并提供了许多扩展点。我们探讨了如何选择正确的配置参数值，设置重新评分，并评估推荐结果。
- en: With this chapter, we have completed our overview of the data science techniques
    that are used to analyze customer behavior, which started with customer relationship
    prediction in [Chapter 4](6ac8d4de-1e7f-4f60-9cf0-93ab2fe55e4d.xhtml), *Customer
    Relationship Prediction with Ensembles*, and continued with affinity analytics
    in [Chapter 5](21e9de6d-720b-416a-bb9c-4c16541d97a9.xhtml), *Affinity Analysis*.
    In the next chapter, we will move on to other topics, such as fraud and anomaly
    detection.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们完成了对用于分析客户行为的数据科学技术的概述，这始于第4章中关于客户关系预测的讨论，即*使用集成进行客户关系预测*，并继续到第5章的亲和力分析，即*亲和力分析*。在下一章中，我们将转向其他主题，例如欺诈和异常检测。
