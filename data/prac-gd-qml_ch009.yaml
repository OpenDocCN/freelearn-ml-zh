- en: Chapter 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: The Tools of the Trade in Quantum Computing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算中的工具
- en: '*Give us the tools, and we will finish the job.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*提供工具，我们就能完成任务。*'
- en: — Winston Churchill
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: — 温斯顿·丘吉尔
- en: We are all very much looking forward to having a ”Q1 Pro” quantum chip in our
    laptops, but — much to our regret — the technology is not there just yet. Nevertheless,
    we do have some actual quantum computers that, with their limitations, are able
    to execute quantum algorithms. And, furthermore, our good old classical computers
    can actually do a very decent job at simulating ideal quantum computers, at least
    for a low number of qubits.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都非常期待在我们的笔记本电脑中拥有一个“Q1 Pro”量子芯片，但——遗憾的是——这项技术尚未成熟。尽管如此，我们确实有一些实际的量子计算机，尽管它们有局限性，但能够执行量子算法。此外，我们那些老式的经典计算机实际上在模拟理想量子计算机方面做得相当不错，至少对于少量量子位来说是这样。
- en: In this chapter, we will explore the tools that allow us to implement quantum
    algorithms using the quantum circuit model and run them on simulators or on real
    quantum hardware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨允许我们使用量子电路模型实现量子算法并在模拟器或真实量子硬件上运行的工具。
- en: 'We will begin by going through some of the most widely-used quantum software
    frameworks and platforms out there. Then, we will see how to work with the two
    software frameworks that we are going to use more extensively throughout this
    book: Qiskit and PennyLane.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍一些最广泛使用的量子软件框架和平台。然后，我们将了解如何使用本书中将更广泛使用的两个软件框架：Qiskit和PennyLane。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: 'Tools for quantum computing: a non-exhaustive overview'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子计算工具：非详尽概述
- en: Working with Qiskit
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qiskit
- en: Working with PennyLane
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PennyLane
- en: After reading this chapter, you will have a broad perspective on the range of
    software tools and platforms available for quantum computing. Moreover, you will
    know how to implement and execute quantum algorithms — both on simulators and
    real quantum hardware — using Qiskit and PennyLane.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将对量子计算可用的软件工具和平台有一个广泛的了解。此外，您将知道如何使用Qiskit和PennyLane在模拟器和真实量子硬件上实现和执行量子算法。
- en: '2.1 Tools for quantum computing: a non-exhaustive overview'
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 量子计算工具：非详尽概述
- en: 'In this book, we will work mostly with two quantum frameworks: **Qiskit** and
    **PennyLane**. These frameworks are powerful, very widely used, and are backed
    by strong user communities, but they are by no means the only interesting options
    available. There is currently a plethora of wonderful software frameworks for
    quantum computing, so much so that it can sometimes feel overwhelming!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将主要使用两个量子框架：**Qiskit**和**PennyLane**。这些框架功能强大，非常广泛使用，并且拥有强大的用户社区支持，但它们绝不是唯一有趣的选择。目前有大量的量子计算软件框架，以至于有时会让人感到不知所措！
- en: 2.1.1 A non-exhaustive survey of frameworks and platforms
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.1 框架和平台的非详尽调查
- en: In this section, we will briefly go through some of the most popular frameworks
    out there. Most of these frameworks are free, both as in *free beer* and as in
    *free* *speech*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍一些最受欢迎的框架。这些框架大多数都是免费的，无论是作为*免费啤酒*还是作为*自由* *言论*。
- en: '**Quirk**: We can begin with a simple yet powerful simulator of quantum circuits:
    Quirk ([https://algassert.com/quirk](https://algassert.com/quirk)). Unlike all
    the other frameworks that we will discuss, this one does not work with code, but
    with a graphical user interface that runs as a web application. This makes it
    ideal for running demonstrations of algorithms or for quick prototyping.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quirk**：我们可以从一个简单但强大的量子电路模拟器开始：Quirk ([https://algassert.com/quirk](https://algassert.com/quirk))。与其他所有我们将讨论的框架不同，这个框架不使用代码，而是使用一个作为网络应用程序运行的图形用户界面。这使得它非常适合运行算法演示或快速原型设计。'
- en: file:///C:/Users/ketank/AppData/Local/Temp/sigil-PiDscY/file290.png![PIC](img/file285.png)
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: file:///C:/Users/ketank/AppData/Local/Temp/sigil-PiDscY/file290.png![PIC](img/file285.png)
- en: With Quirk, you can build quantum circuits arranging gates with a **drag-and-drop
    interface**. It includes the most common quantum gates, in addition to a handful
    of custom gates that are used for the demonstration of some algorithms. You can
    have a look at *Figure* [*2.1.1*](#a-non-exhaustive-survey-of-frameworks-and-platforms)
    to see Quirk in action.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Quirk，您可以通过**拖放界面**构建量子电路。它包括最常见的量子门，以及一些用于算法演示的定制门。您可以通过查看*图* [*2.1.1*](#a-non-exhaustive-survey-of-frameworks-and-platforms)
    来了解Quirk的实际应用。
- en: '**Q# and Microsoft’s QDK**: Most quantum software frameworks rely on a **host**
    classical programming language (usually **Python**). **Q#** (read as ”*Q* *sharp*”)
    is an exception to this rule: it is a purpose-built programming language for quantum
    computing developed at Microsoft. This language is used in Microsoft’s **Quantum
    Development Kit** (**QDK**) ([https://azure.microsoft.com/en-us/resources/development-kit/quantum-computing/](https://azure.microsoft.com/en-us/resources/development-kit/quantum-computing/)),
    which includes several simulators for running quantum algorithms and assessing
    their performance. With the QDK, you can also send your quantum algorithms to
    real quantum computers using **Azure** **Quantum**.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Q# 和微软的 QDK**：大多数量子软件框架都依赖于一个 **宿主** 经典编程语言（通常是 **Python**）。**Q#**（读作 “*Q*
    *sharp*”）是这一规则的例外：它是微软开发的专门用于量子计算的语言。这种语言用于微软的 **量子开发工具包**（**QDK**）([https://azure.microsoft.com/en-us/resources/development-kit/quantum-computing/](https://azure.microsoft.com/en-us/resources/development-kit/quantum-computing/))，其中包含几个用于运行量子算法和评估其性能的模拟器。使用
    QDK，你还可以使用 **Azure Quantum** 将你的量子算法发送到真实的量子计算机。'
- en: In addition to this, Microsoft provides solutions that enable Q# to run interactively
    and to be inter-operable with other programming languages such as Python. Moreover,
    the Azure Quantum service, which allows you to run quantum algorithms on real
    hardware, also works with other quantum software frameworks.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，微软还提供了使 Q# 能够交互式运行并与其他编程语言（如 Python）互操作性的解决方案。此外，允许你在真实硬件上运行量子算法的 Azure Quantum
    服务也与其他量子软件框架兼容。
- en: '**QuEST**. The **Quantum Exact Simulation Toolkit** (**QuEST**) ([https://quest.qtechtheory.org/](https://quest.qtechtheory.org/))
    is a simulation framework written in **C++** and built with performance in mind.
    With it, you can write a single implementation of a quantum algorithm that can
    be compiled into binary code, yielding a program that will simulate the algorithm.
    Using this framework, you can be *closer to the metal* and make sure that all
    the hardware resources available are used in an optimal way. This makes QuEST
    a very interesting choice for hardware-intensive simulations with a large number
    of qubits. In other words, if you ever wanted to test how many qubits your computer
    was able to handle, QuEST might be the way to go (you might want to have a fire
    extinguisher at hand though, just in case things get hot!).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QuEST**。**量子精确模拟工具包**（**QuEST**）([https://quest.qtechtheory.org/](https://quest.qtechtheory.org/))
    是一个用 **C++** 编写的模拟框架，注重性能。使用它，你可以编写一个量子算法的单个实现，该实现可以编译成二进制代码，生成一个模拟算法的程序。使用这个框架，你可以更接近底层硬件，并确保所有可用的硬件资源都得到最佳利用。这使得
    QuEST 成为大量量子比特硬件密集型模拟的一个非常有吸引力的选择。换句话说，如果你曾经想测试你的计算机能够处理多少量子比特，QuEST 可能是可行的选择（不过，你可能需要准备一个灭火器，以防万一事情变得很热！）。'
- en: 'The source code for QuEST is freely available online: ([https://github.com/quest-kit/QuEST](https://github.com/quest-kit/QuEST)).
    It is mostly C and C++ code that you can use on any device.'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: QuEST 的源代码可在网上免费获取：([https://github.com/quest-kit/QuEST](https://github.com/quest-kit/QuEST))。它主要是
    C 和 C++ 代码，可以在任何设备上使用。
- en: '**Cirq** ([https://quantumai.google/cirq](https://quantumai.google/cirq)) is
    a quantum software framework developed at **Google** that uses Python as a host
    language. It can be used to design quantum algorithms and to simulate them on
    a classical device or send them to real quantum hardware. Furthermore, Cirq is
    integrated in [TensorFlow Quantum](https://www.tensorflow.org/quantum) ([https://www.tensorflow.org/quantum](https://www.tensorflow.org/quantum)),
    Google’s framework for quantum machine learning.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cirq** ([https://quantumai.google/cirq](https://quantumai.google/cirq)) 是由
    **Google** 开发的量子软件框架，它使用 Python 作为宿主语言。它可以用来设计量子算法，并在经典设备上模拟或在真实量子硬件上发送它们。此外，Cirq
    集成在 [TensorFlow Quantum](https://www.tensorflow.org/quantum) ([https://www.tensorflow.org/quantum](https://www.tensorflow.org/quantum))
    中，这是 Google 的量子机器学习框架。'
- en: '**Qiskit** ([https://qiskit.org/](https://qiskit.org/)) is **IBM**’s quantum
    framework. It relies on Python as a host language and provides a wide range of
    simulators as well as allowing the submission of algorithms to IBM’s real quantum
    hardware. In addition to this, Qiskit provides an extensive library of quantum
    circuits and algorithms, many of which we will use in this book!'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qiskit** ([https://qiskit.org/](https://qiskit.org/)) 是 **IBM** 的量子框架。它依赖于
    Python 作为宿主语言，并提供了一系列模拟器，同时允许将算法提交到 IBM 的真实量子硬件。除此之外，Qiskit 还提供了一整套量子电路和算法库，其中许多我们将在本书中使用！'
- en: In particular, when it comes to machine learning, Qiskit includes some interesting
    models with the tools necessary to train and execute them; and it also provides
    a **PyTorch** interface for the training of quantum machine learning models (we
    will explore Qiskit and all its secrets in detail in the following section).
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尤其是在机器学习方面，Qiskit包括一些有趣的模型，以及训练和执行它们的工具；它还提供了用于训练量子机器学习模型的**PyTorch**接口（我们将在下一节详细探讨Qiskit及其所有秘密）。
- en: '**PennyLane** ([https://pennylane.ai/](https://pennylane.ai/)) is a quantum
    framework built specifically for quantum machine learning, but it can perfectly
    be used as a general-purpose quantum computing framework. It is quite a newcomer
    to the quantum programming scene and it is being developed at **Xanadu**. Like
    Qiskit, it uses Python as a host language. Any quantum algorithms written in PennyLane
    can be sent to real quantum computers and executed in a broad collection of simulators.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PennyLane** ([https://pennylane.ai/](https://pennylane.ai/)) 是一个专门为量子机器学习构建的量子框架，但它也可以完美地用作通用量子计算框架。它是量子编程场景中的新来者，由**Xanadu**开发。像Qiskit一样，它使用Python作为宿主语言。在PennyLane中编写的任何量子算法都可以发送到真实的量子计算机上并在广泛的模拟器中执行。'
- en: PennyLane is one of the best frameworks out there when it comes to inter-operability.
    Thanks to a wide collection of **plugins**, you can export PennyLane circuits
    to other frameworks and execute them there — taking advantage of some of the features
    that these other frameworks may have.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: PennyLane是现有框架中最好的框架之一，当涉及到互操作性时。多亏了一大批**插件**，你可以将PennyLane电路导出到其他框架并在那里执行它们——利用这些其他框架可能具有的一些功能。
- en: When it comes to machine learning, PennyLane provides some built-in tools, but
    it is also highly inter-operable with classical machine learning frameworks such
    as **scikit-learn**, **Keras**, **TensorFlow**, and **PyTorch**. We will discuss
    this framework in detail later in this chapter.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在机器学习方面，PennyLane提供了一些内置工具，但它也与经典机器学习框架如**scikit-learn**、**Keras**、**TensorFlow**和**PyTorch**高度互操作。我们将在本章后面详细讨论这个框架。
- en: '**Ocean** ([https://docs.ocean.dwavesys.com/en/stable/](https://docs.ocean.dwavesys.com/en/stable/))
    is a Python library developed by the Canadian company **D-Wave**. In contrast
    with the other software packages that we have mentioned so far, Ocean’s goal is
    not the implementation and execution of quantum circuits. Instead, this library
    allows you to define instances of combinatorial optimization problems of different
    types and to solve them both with classical algorithms and on D-Wave’s **quantum
    annealers** (special quantum computers that are not general-purpose but oriented
    to solving optimization problems).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ocean** ([https://docs.ocean.dwavesys.com/en/stable/](https://docs.ocean.dwavesys.com/en/stable/))
    是加拿大公司**D-Wave**开发的Python库。与其他我们之前提到的软件包不同，Ocean的目标不是量子电路的实现和执行。相反，这个库允许你定义不同类型的组合优化问题的实例，并用经典算法以及D-Wave的**量子退火器**（专门用于解决优化问题的特殊量子计算机）来解决这些问题。'
- en: 'Starting in *Chapter* *[*3*](ch011.xhtml#x1-590003), *QUBO: Quadratic Unconstrained
    Binary* *Optimization*, we will introduce the concepts that we will need in order
    to understand how to define problems with Ocean. And in *Chapter* *[*4*](ch012.xhtml#x1-750004),
    *Quantum Adiabatic Computing and Quantum Annealing*, we will learn how to use
    Ocean in all its glory, both to solve these optimization problems with classical
    algorithms and, of course, with quantum algorithms in actual quantum computers!**'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从**第3章**[*3*](ch011.xhtml#x1-590003)，**“QUBO：二次无约束二进制优化”**开始，我们将介绍理解如何使用Ocean定义问题的概念。在第4章**[*4*](ch012.xhtml#x1-750004)，**“量子绝热计算和量子退火”**中，我们将学习如何全面使用Ocean，无论是用经典算法解决这些优化问题，还是在实际的量子计算机上用量子算法！**
- en: '**To learn more…'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**了解更多...'
- en: The source code (and binaries, if any) for these frameworks can be downloaded
    from their official websites. For detailed installation instructions for Qiskit,
    Pennylane, and Ocean, you can refer to *Appendix* *[*D*](ch027.xhtml#x1-240000D),
    *Installing the Tools*.*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架的源代码（以及如果有，二进制文件）可以从它们的官方网站下载。有关Qiskit、PennyLane和Ocean的详细安装说明，请参阅**附录****[*D*](ch027.xhtml#x1-240000D)，**“安装工具”**。
- en: '**   **Amazon Braket**: Amazon Web Services offers Amazon Braket ([https://aws.amazon.com/braket/](https://aws.amazon.com/braket/)),
    a paid cloud service that makes it possible to use a wide range of implementations
    of real quantum computers. In order to execute code on these computers, they provide
    their own *device-agnostic SDK*, but they also fully support PennyLane and Qiskit,
    and there are even plugins to work with Ocean ([https://amazon-braket-ocean-plugin-python.readthedocs.io/](https://amazon-braket-ocean-plugin-python.readthedocs.io/)).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon Braket**：亚马逊网络服务提供Amazon Braket ([https://aws.amazon.com/braket/](https://aws.amazon.com/braket/))，这是一种付费云服务，使得使用各种真实量子计算机的实现成为可能。为了在这些计算机上执行代码，他们提供了自己的*设备无关的SDK*，但他们也完全支持PennyLane和Qiskit，甚至还有插件可以与Ocean
    ([https://amazon-braket-ocean-plugin-python.readthedocs.io/](https://amazon-braket-ocean-plugin-python.readthedocs.io/))）一起工作。'
- en: 2.1.2 Qiskit, PennyLane, and Ocean
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1.2 Qiskit、PennyLane和Ocean
- en: As we have just seen, there is an abundant range of choices when it comes to
    software frameworks for quantum computing, and this might make you wonder why
    we are going to stick with Qiskit, PennyLane, and Ocean. Of course, this is not
    a choice made at random; we have a bunch of good reasons!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，在量子计算软件框架方面有丰富的选择，这可能会让你想知道为什么我们要坚持使用Qiskit、PennyLane和Ocean。当然，这并不是一个随机的选择；我们有充分的理由！
- en: 'Regarding Qiskit, it is just massive: the level of built-in algorithms and
    functionalities that it includes is simply unmatched. And not only that, but it
    also has a very strong community of users and it is supported by most quantum
    hardware providers out there. In other words, Qiskit could easily be considered
    a *lingua franca* of quantum computing.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Qiskit，它非常庞大：它包含的内置算法和功能水平是无可匹敌的。不仅如此，它还拥有一个非常强大的用户社区，并且得到了大多数量子硬件提供商的支持。换句话说，Qiskit可以很容易地被认为是量子计算的*通用语言*。
- en: PennyLane, on the contrary, is not as widely used a framework as Qiskit (at
    least for now), but we believe that it is one of the most promising newcomers
    to the world of quantum computing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，PennyLane不像Qiskit那样被广泛使用（至少目前是这样），但我们相信它是量子计算领域最有前途的新来者之一。
- en: In particular, when it comes to quantum machine learning, it is very hard to
    say that there is anything better than PennyLane. On the one hand, PennyLane simply
    runs very smoothly and is beautifully documented and, on the other, its interoperability
    with other quantum and **Machine Learning** (**ML**) frameworks knows no rival.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在量子机器学习方面，很难说有什么比PennyLane更好的东西。一方面，PennyLane运行非常顺畅，并且有精美的文档，另一方面，它与其它量子以及**机器学习**（**ML**）框架的互操作性无人能敌。
- en: This is why we believe that Qiskit and PennyLane are better choices than, for
    instance, **Q#** or **Cirq** (which, of course, are also great frameworks on their
    own). Regarding QuEST, it is true that the performance of the simulators provided
    by Qiskit and PennyLane may not be as good as the performance that QuEST would
    yield. But we should also take into account that QuEST is not nearly as user-friendly
    as Qiskit or PennyLane, and it lacks many of their features; for instance, QuEST
    does not have any built-in tools or interfaces for training quantum machine learning
    models. In any case, we should remark that while running circuits on the simulators
    bundled in Qiskit and PennyLane may not be as efficient as running them in QuEST,
    for our purposes, the performance that we can get with them is more than good
    enough! Nevertheless, if you are still eager to get the performance boost that
    QuEST could give you, you should know that there is a community plugin that allows
    PennyLane to work with the QuEST simulator.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们相信Qiskit和PennyLane比例如**Q#**或**Cirq**（当然，它们本身也是优秀的框架）是更好的选择。至于QuEST，确实，Qiskit和PennyLane提供的模拟器的性能可能不如QuEST提供的性能好。但我们也应该考虑到，QuEST的用户友好性远不如Qiskit或PennyLane，并且缺少它们许多功能；例如，QuEST没有内置的工具或接口用于训练量子机器学习模型。无论如何，我们应该指出，虽然在使用Qiskit和PennyLane捆绑的模拟器上运行电路可能不如在QuEST上运行效率高，但对我们来说，我们可以从中获得的性能已经足够好了！尽管如此，如果你仍然渴望获得QuEST可以提供的性能提升，你应该知道有一个社区插件允许PennyLane与QuEST模拟器一起工作。
- en: Finally, we have chosen Ocean because it is completely unique in that it probably
    is the only software package that lets you work with **quantum** **annealers**,
    both to define problems and to run them on actual quantum hardware. It is also
    very easy to learn…at least once you understand how to define combinatorial optimization
    problems in the **Ising** and QUBO models. But don’t worry; we will extensively
    study those frameworks in *Chapter* *[*3*](ch011.xhtml#x1-590003), *QUBO:* *Quadratic
    Unconstrained Binary Optimization*, and, by *Chapter* *[*4*](ch012.xhtml#x1-750004),
    *Quantum* *Adiabatic Computing and Quantum Annealing*, we will be more than ready
    to write our very first programs using Ocean.**
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们选择了Ocean，因为它在这一点上完全独特，可能是唯一一个允许你与**量子****退火器**一起工作的软件包，既可以定义问题，也可以在实际量子硬件上运行它们。它也非常容易学习……至少在你理解了如何在**伊辛**和QUBO模型中定义组合优化问题之后。但别担心；我们将在*第*[*3*](ch011.xhtml#x1-590003)章*QUBO:*
    *二次无约束二进制优化*中广泛研究这些框架，到*第*[*4*](ch012.xhtml#x1-750004)章*量子* *绝热计算和量子退火*时，我们将准备好编写我们第一个使用Ocean的程序。
- en: '**At this point, we have a good global understanding of the current landscape
    of tools for quantum computing. In the upcoming sections, we will take our first
    steps in using them, and we shall begin with Qiskit.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**在此阶段，我们对量子计算当前工具的格局有了很好的全局理解。在接下来的章节中，我们将迈出使用它们的第一步，并且我们将从Qiskit开始。**'
- en: 2.2 Working with Qiskit
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 使用Qiskit
- en: In this section, we will learn how to work with the Qiskit framework. We will
    first discuss the general structure of Qiskit, and then we will study how to implement
    quantum circuits in Qiskit using quantum gates and measurements. Then, we will
    explore how to run these circuits using the simulators provided by Qiksit and
    also real quantum computers available for free thanks to IBM. This section is
    key, for we will use Qiskit extensively in this book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Qiskit框架。我们首先将讨论Qiskit的一般结构，然后我们将研究如何在Qiskit中使用量子门和测量来实现量子电路。接着，我们将探讨如何使用Qiskit提供的模拟器和IBM提供的免费真实量子计算机来运行这些电路。本节至关重要，因为在这本书中我们将广泛使用Qiskit。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Quantum computing is a rapidly-evolving field…and so are its software frameworks!
    We are going to work with **version 0.39.2** of Qiskit. Keep in mind that, if
    you are using a different version, things may have changed. In case of doubt,
    you should always refer to the documentation ([https://qiskit.org/documentation/](https://qiskit.org/documentation/)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算是一个快速发展的领域……以及它的软件框架！我们将使用Qiskit的**版本0.39.2**。请记住，如果你使用的是不同版本，事情可能会有所变化。如果有疑问，你应该始终参考文档([https://qiskit.org/documentation/](https://qiskit.org/documentation/))。
- en: 2.2.1 An overview of the Qiskit framework
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.1 Qiskit框架概述
- en: The Qiskit framework [[102](ch030.xhtml#XQiskit)] consists of the components
    depicted in *Figure* [*2.1*](#Figure2.1). At the very foundation of Qiskit lies
    **Qiskit Terra**. This package is responsible for handling quantum circuits and
    providing the necessary tools for constructing them. It also includes a basic
    Python-based simulator (**BasicAer**) and it can work with the **IBM Quantum provider**
    to execute circuits on IBM’s quantum hardware.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit框架[[102](ch030.xhtml#XQiskit)]由*图*[*2.1*](#Figure2.1)中展示的组件组成。Qiskit的基石是**Qiskit
    Terra**。这个包负责处理量子电路并提供构建它们所需的工具。它还包括一个基于Python的基本模拟器（**BasicAer**），并且它可以与**IBM量子提供商**一起工作，在IBM的量子硬件上执行电路。
- en: '![Figure 2.1: Components of the Qiskit framework](img/file286.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：Qiskit框架的组件](img/file286.jpg)'
- en: '**Figure 2.1**: Components of the Qiskit framework'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.1**：Qiskit框架的组件'
- en: Qiskit Aer is built on top of Qiskit Terra, and it provides a suite of high-performance
    quantum simulators written in **C++** and designed to use hardware resources more
    efficiently.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit Aer建立在Qiskit Terra之上，并提供了一套用**C++**编写的性能高效的量子模拟器，旨在更有效地使用硬件资源。
- en: 'We can think of Qiskit Aer and Terra as the core of the Qiskit framework; they
    are included when you do a simple installation of Qiskit. In addition to these
    components, however, there are still a few more:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Qiskit Aer和Terra视为Qiskit框架的核心；它们在安装Qiskit时被包含在内。然而，除了这些组件之外，还有一些其他组件：
- en: '**Qiskit Machine Learning** implements some well-known quantum machine learning
    algorithms that are suitable for **NISQ** devices. We will extensively work with
    this package in *Part* *[*III*](ch016.xhtml#x1-138000III), *A Match Made in* *Heaven:
    Quantum Machine Learning*, of this book. This package also provides an optional
    interface with **PyTorch** that can be utilized in the training of quantum machine
    learning models.*'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qiskit Machine Learning**实现了一些适合**NISQ**设备的知名量子机器学习算法。我们将在本书的*第*[*III*](ch016.xhtml#x1-138000III)，*天堂之配：量子机器学习*[*III*]中广泛使用这个包。此包还提供了一个可选的与**PyTorch**的接口，可用于量子机器学习模型的训练。'
- en: '**   **Qiskit Optimization** implements some quantum optimization algorithms.
    We will work with them in *Part* *[*II*](ch010.xhtml#x1-58000II), *When Time is
    Gold:* *Tools for Quantum Optimization*, of this book.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qiskit Optimization**实现了一些量子优化算法。我们将在本书的*第*[*II*](ch010.xhtml#x1-58000II)，*时间即金钱：量子优化工具*[*II*]中使用它们。'
- en: '**   This book focuses on quantum machine learning and quantum optimization,
    but quantum computing has more exciting applications in other specific fields.
    Two good examples are the natural sciences, in particular, quantum physics and
    chemistry, and finance. You can find some algorithms related to problems in these
    fields in the **Qiskit** **Nature** and **Qiskit Finance** packages. As an interesting
    fact, you should know that the possibility of doing more efficient computations
    for quantum-mechanical systems was one of the initial motivations for exploring
    the idea of quantum computing in the first place. We will briefly explore some
    of these applications in *Chapter* *[*7*](ch015.xhtml#x1-1190007), *VQE:* *Variational
    Quantum Eigensolver*.*'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**本书重点介绍量子机器学习和量子优化，但量子计算在其他特定领域有更多令人兴奋的应用。两个很好的例子是自然科学，特别是量子物理和化学，以及金融。你可以在**Qiskit
    Nature**和**Qiskit Finance**包中找到一些与这些领域问题相关的算法。有趣的是，你应该知道，为量子力学系统进行更有效的计算的可能性是探索量子计算想法的最初动机之一。我们将在*第*[*7*](ch015.xhtml#x1-1190007)，*变分量子本征值求解器*[*7*]中简要探讨一些这些应用。'
- en: '**   **Qiskit Experiments** provides a range of tools for working with noisy
    quantum computers, that is, current quantum devices that are subject to different
    types of errors and external noise, to characterize, benchmark, and calibrate
    them.'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Qiskit Experiments**提供了一系列用于与有噪声的量子计算机工作的工具，即当前受不同类型错误和外部噪声影响的量子设备，用于表征、基准测试和校准它们。'
- en: Lastly, **Qiskit Metal** and **Qiskit Dynamics** are the most recent additions
    to Qiskit. Qiskit Metal can be used to design real quantum devices, while Qiskit
    Dynamics provides tools to work with models of quantum systems.***
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**Qiskit Metal**和**Qiskit Dynamics**是Qiskit最近添加的两个新功能。Qiskit Metal可用于设计真实的量子设备，而Qiskit
    Dynamics提供了用于与量子系统模型一起工作的工具。***
- en: '**Exercise 2.1'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习2.1'
- en: Follow the instructions in *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing
    the Tools*, to do a full installation of **version 0.39.2** of the Qiskit package.*
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 按照附录*[*D*](ch027.xhtml#x1-240000D)，*安装工具*中的说明，安装Qiskit包的**版本0.39.2**。
- en: '*Once you have installed Qiskit, you can load it in Python running `import`
    `qiskit`. If you want to check the version of Qiskit that you are running, you
    might be tempted to look for it in `qiskit``.``__version__`, but that would give
    you the version of the Qiskit Terra package, not that of Qiskit itself! If you
    want to find the version of the Qiskit framework, you will have to access `qiskit``.``__qiskit_version__`.
    That will give you a dictionary with the versions of all the components of Qiskit
    (including Qiskit itself). Hence, the version of Qiskit will be `qiskit``.``__qiskit_version__``[``’``qiskit``’``]`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦安装了Qiskit，你可以在Python运行中通过`import` `qiskit`来加载它。如果你想检查你正在运行的Qiskit版本，你可能想通过`qiskit``.``__version__`来查找它，但那样会给你Qiskit
    Terra包的版本，而不是Qiskit本身的版本！如果你想找到Qiskit框架的版本，你将不得不访问`qiskit``.``__qiskit_version__`。这将给你一个包含Qiskit所有组件版本（包括Qiskit本身）的字典。因此，Qiskit的版本将是`qiskit``.``__qiskit_version__``[``’``qiskit``’``]`。'
- en: To learn more…
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息…
- en: Qiskit is updated quite frequently. To stay up to date with the new features,
    we recommend you visit [https://qiskit.org/documentation/release_notes.html](https://qiskit.org/documentation/release_notes.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit更新得很频繁。为了跟上新功能，我们建议你访问[https://qiskit.org/documentation/release_notes.html](https://qiskit.org/documentation/release_notes.html)。
- en: Now that we are all set up, it is time for us to build some circuits with our
    feet on the Terra!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了，是时候用我们的脚踩在Terra上构建一些电路了！
- en: 2.2.2 Using Qiskit Terra to build quantum circuits
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.2 使用Qiskit Terra构建量子电路
- en: 'In order to get started, let us, first of all, import Qiskit as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们首先按照以下方式导入Qiskit：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice how in the preceding subsection we imported Qiskit with `import` `qiskit`
    to be able to check its version number. For the remainder of this chapter, we
    will assume that Qiskit has been imported as `from` `qiskit` `import` `*`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前一个子节中，我们是如何使用`import qiskit`导入Qiskit来检查其版本号的。在本章的剩余部分，我们将假设Qiskit已经被导入为`from
    qiskit import *`。
- en: We will now explore how to implement quantum algorithms (in the form of quantum
    circuits) using Qiskit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探索如何使用Qiskit实现量子算法（以量子电路的形式）。
- en: Initializing circuits
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化电路
- en: 'In Qiskit, circuits are represented as objects of the `QuantumCircuit` class.
    When we initialize such an object, we may give some optional arguments depending
    on how many qubits and bits we want our circuit to have. For example, if we want
    our circuit to have `n` qubits, we may invoke `QuantumCircuit``(``n``)`. If we
    also want it to have `m` classical bits to store the results of measuring our
    qubits, we can run `QuantumCircuit``(``n``,` `m``)`. Once we have a quantum circuit
    object, we can get an ASCII representation of it in the terminal by calling the
    `draw` method. For instance, if we executed `QuantumCircuit``(2,2).``draw``()`,
    we would get the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qiskit中，电路被表示为`QuantumCircuit`类的对象。当我们初始化这样的对象时，我们可以根据我们希望电路有多少个量子位和比特来提供一些可选参数。例如，如果我们希望我们的电路有`n`个量子位，我们可以调用`QuantumCircuit(n)`。如果我们还希望它有`m`个经典比特来存储测量量子位的结果，我们可以运行`QuantumCircuit(n,
    m)`。一旦我们有一个量子电路对象，我们可以通过调用`draw`方法在终端中获取它的ASCII表示。例如，如果我们执行了`QuantumCircuit(2,2).draw()`，我们会得到以下结果：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, in this representation we can only see the names of the qubits and
    the bits that we have created, for that is all that we have in our circuit so
    far.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个表示中，我们只能看到我们创建的量子位和比特的名称，因为到目前为止，我们电路中只有这些。
- en: These ASCII representations are fine, but we can all agree that they are not
    necessarily very stylish. If you want to get something more fancy, you can pass
    the optional argument `’``mpl``’` (short for **matplotlib**) to `draw`. Keep in
    mind that, if you use Python on your terminal rather than in a **Jupyter notebook**
    (old school for the win!), you might also have to use `draw``(``’``mpl``’``,`
    `interactive` `=` `True``)`. However, this might not work if your environment
    doesn’t support graphical user interfaces.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些ASCII表示是好的，但我们都可以同意，它们并不一定非常时尚。如果你想得到更花哨的东西，你可以将可选参数`’mpl’`（代表**matplotlib**）传递给`draw`。记住，如果你在终端上使用Python而不是在**Jupyter笔记本**（老式笔记本获胜！）中，你可能还必须使用`draw(‘mpl’,
    interactive=True)`。然而，如果您的环境不支持图形用户界面，这可能不起作用。
- en: 'Qubits and classical bits in Qiskit are grouped in quantum and classical **registers**.
    By default, when you create a circuit `QuantumCircuit``(``n``,` `m``)`, Qiskit
    groups your qubits in a quantum register `q` and your bits in a classical register
    `c`. You may however want to have a different arrangement of registers or you
    may want to give them different names. In order to do this, you can create your
    own registers, which will be objects of the `QuantumRegister` and `ClassicalRegister`
    classes. When initializing these registers, you are free to specify some `size`
    and `name` parameters. Once you have created some quantum and classical registers
    `reg_1`,…,`reg_n`, you can stack them in a circuit with a call of the form `QuantumCircuit``(``reg_1``,...,``reg_n``)`.
    In this way, we could execute the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qiskit中，量子位和经典比特被分组在量子寄存器和经典寄存器中。默认情况下，当你创建一个电路`QuantumCircuit(n, m)`时，Qiskit会将你的量子位分组在量子寄存器`q`中，你的比特分组在经典寄存器`c`中。然而，你可能想要不同的寄存器排列，或者你可能想要给它们不同的名称。为了做到这一点，你可以创建自己的寄存器，这些寄存器将是`QuantumRegister`和`ClassicalRegister`类的对象。在初始化这些寄存器时，你可以自由指定一些`size`和`name`参数。一旦你创建了一些量子寄存器和经典寄存器`reg_1`，…，`reg_n`，你可以在电路中通过调用`QuantumCircuit(reg_1,
    ..., reg_n)`将它们堆叠起来。这样，我们可以执行以下代码：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And we would get the following result if we ran `qc``.``draw``()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`qc.draw()`，我们会得到以下结果：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Quantum gates
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量子门
- en: We now have a circuit with a bunch of qubits — not a bad way to get started!
    By default, all those qubits will be initialized to a state, ![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle"), but, of course, if we want to get some computing done,
    we better be able to bring some quantum gates to the table.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含许多量子比特的电路——这是一个不错的入门方式！默认情况下，所有这些量子比特都将初始化为状态![\left| 0 \right\rangle](img/file6.png
    "\left| 0 \right\rangle")，但当然，如果我们想进行一些计算，我们最好能够将一些量子门放到桌面上。
- en: The way you add quantum gates to a circuit `qc` is by executing methods of that
    circuit. For instance, if you want to apply an ![X](img/file9.png "X") gate on
    the first qubit of the circuit `qc`, you can just run `qc``.``x``(0)`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行电路`qc`的方法来向电路`qc`添加量子门。例如，如果你想对电路`qc`的第一个量子比特应用![X](img/file9.png "X")门，你可以直接运行`qc``.``x``(0)`。
- en: Important note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As is often the case in Python, quantum bits in a circuit are 0-indexed! This
    means that the first qubit will be labeled as 0, the second as 1, and so on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Python中经常发生的那样，电路中的量子比特是0索引的！这意味着第一个量子比特将被标记为0，第二个为1，依此类推。
- en: When we have different quantum registers in a circuit, we can still refer to
    qubits by their indices. The qubits of the first register that we added will have
    the first indices, the subsequent indices will correspond to the qubits of the
    second register, and so on and so forth. Classical registers and quantum registers
    are fully independent in this matter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在电路中具有不同的量子寄存器时，我们仍然可以通过它们的索引来引用量子比特。我们添加的第一个寄存器的量子比特将具有第一个索引，后续的索引将对应于第二个寄存器的量子比特，依此类推。在这一点上，经典寄存器和量子寄存器是完全独立的。
- en: This, however, can be somewhat inconvenient if we have many registers, but don’t
    worry, Qiskit has got you covered. While referring to gates by their index can
    be convenient, we can also refer to them directly! Let us say that we have a setup
    like the previous one, with the circuit `qc` with quantum registers `qreg1` and
    `qreg2`. Running `qc``.``x``(2)` would have the same effect as executing `qc``.``x``(``qreg2``[0])`.
    Moreover, if we called `qc``.``x``(``qreg1``)`, that would be the same as applying
    both `qc``.``x``(0)` and `qc``.``x``(1)` one after the other.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们有很多寄存器，这可能会有些不方便，但不用担心，Qiskit已经为你准备好了。虽然通过索引引用门可能很方便，但我们也可以直接引用它们！假设我们有一个像之前那样的设置，电路`qc`带有量子寄存器`qreg1`和`qreg2`。运行`qc``.``x``(2)`会产生与执行`qc``.``x``(``qreg2``[0])`相同的效果。此外，如果我们调用`qc``.``x``(``qreg1``)`，那将等同于依次应用`qc``.``x``(0)`和`qc``.``x``(1)`。
- en: The following are the Qiskit methods for applying some of the most common one-qubit
    gates (the ones that we studied in *Sections* *[*1.3.3*](ch008.xhtml#x1-240001.3.3)
    and *[*1.3.4*](ch008.xhtml#x1-250001.3.4)) on a qubit `q0`:**
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些Qiskit方法，用于在量子比特`q0`上应用一些最常见的单量子比特门（我们在*章节* *[*1.3.3*](ch008.xhtml#x1-240001.3.3)
    和 *[*1.3.4*](ch008.xhtml#x1-250001.3.4) 中研究过的那些）：
- en: '***   In order to apply one of the Pauli gates, ![X](img/file9.png "X"), ![Y](img/file11.png
    "Y"), or ![Z](img/file8.png "Z"), we can call `x``(``q0``)`, `y``(``q0``)`, or
    `z``(``q0` `)` respectively.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用Pauli门之一，![X](img/file9.png "X")，![Y](img/file11.png "Y")，或![Z](img/file8.png
    "Z")，我们可以分别调用`x``(``q0``)`，`y``(``q0``)`，或`z``(``q0` `)`。
- en: The method `h``(``q0` `)` can be used to apply a Hadamard gate.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`h``(``q0` `)`可以用来应用Hadamard门。
- en: We can apply rotation gates ![R_{X}](img/file118.png "R_{X}"), ![R_{Y}](img/file119.png
    "R_{Y}"), or ![R_{Z}](img/file120.png "R_{Z}") parametrized by `theta` with the
    `rx``(``theta``,``q0``)`, `ry``(``theta``,``q0``)`, or `rz``(``theta``,``q0` `)`
    methods respectively.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`theta`参数化的旋转门![R_{X}](img/file118.png "R_{X}")，![R_{Y}](img/file119.png
    "R_{Y}")，或![R_{Z}](img/file120.png "R_{Z}")，分别通过`rx``(``theta``,` `q0``)`，`ry``(``theta``,`
    `q0``)`，或`rz``(``theta``,` `q0` `)`方法应用。
- en: We can apply the universal one-qubit gate ![U(\theta,\varphi,\lambda)](img/file287.png
    "U(\theta,\varphi,\lambda)") parametrized by `theta`, `phi`, and `lambd` as `u``(``theta``,`
    `phi``,` `lambd``,` `q0` `)`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将由`theta`，`phi`和`lambd`参数化的通用单量子比特门![U(\theta,\varphi,\lambda)](img/file287.png
    "U(\theta,\varphi,\lambda)")作为`u``(``theta``,` `phi``,` `lambd``,` `q0` `)`应用。
- en: Of course, we also have methods for multi-qubit gates. Most notably, a controlled
    ![X](img/file9.png "X"), ![Y](img/file11.png "Y"), ![Z](img/file8.png "Z"), or
    ![H](img/file10.png "H") gate with control qubit `q0` on a target `qt` can be
    applied with the `cx``(``q0``,` `qt``)`, `cy``(``q0``,` `qt``)`, `cz``(``q0``,`
    `qt``)`, and `ch``(``q0``,` `qt``)` methods respectively. In full analogy, a controlled
    rotation gate ![R_{X}](img/file118.png "R_{X}"), ![R_{Y}](img/file119.png "R_{Y}"),
    or ![R_{Z}](img/file120.png "R_{Z}") parametrized by a value `theta` can be added
    with the `crx``(``theta``,` `q0``,` `qt``)`, `cry``(``theta``,` `q0``,` `qt``)`,
    and `crz``(``theta``,` `q0``,` `qt``)` methods, where, as before, `q0` represents
    the control qubit and `qt` the target one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也有多量子比特门的方法。最值得注意的是，一个受控![X](img/file9.png "X")、![Y](img/file11.png "Y")、![Z](img/file8.png
    "Z")或![H](img/file10.png "H")门，控制量子比特`q0`在目标`qt`上，可以通过`cx``(``q0``,` `qt``)`、`cy``(``q0``,`
    `qt``)`、`cz``(``q0``,` `qt``)`和`ch``(``q0``,` `qt``)`方法分别应用。在完全类似的情况下，一个由值`theta`参数化的受控旋转门![R_{X}](img/file118.png
    "R_{X}")、![R_{Y}](img/file119.png "R_{Y}")或![R_{Z}](img/file120.png "R_{Z}")可以通过`crx``(``theta``,`
    `q0``,` `qt``)`、`cry``(``theta``,` `q0``,` `qt``)`和`crz``(``theta``,` `q0``,`
    `qt``)`方法添加，其中，正如之前一样，`q0`代表控制量子比特，`qt`代表目标量子比特。
- en: Important note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that the controlled ![X](img/file9.png "X") gate is the famous **CNOT**.
    We love entangling qubits, so we will certainly be using that `cx` method a lot!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，受控![X](img/file9.png "X")门是著名的**CNOT**。我们喜欢纠缠量子比特，所以我们肯定会大量使用那个`cx`方法！
- en: '![(a)](img/file288.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![a](img/file288.jpg)'
- en: '**(a)**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**(a)**'
- en: '![(b)](img/file289.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![b](img/file289.jpg)'
- en: '**(b)**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**(b**)'
- en: '**Figure 2.2**: Sample quantum circuits that we can construct in Qiskit.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.2**：我们可以在Qiskit中构建的示例量子电路。'
- en: 'Now might be a good moment to step back for a second and see all that we have
    done come alive. For example, let us try to construct the circuit depicted in
    *Figure* [*2.2a*](#Figure2.2a). Using all that we have learned, we could implement
    this circuit in Qiskit as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是退后一步，看看我们所做的一切都变得生动起来的好时机。例如，让我们尝试构建图*2.2a*（[图2.2a](#Figure2.2a)）中所示的电路。利用我们所学的所有知识，我们可以在Qiskit中如下实现这个电路：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And now if we run `qc``.``draw``(``"``mpl``"``)` to verify that our implementation
    is correct, we will get the output shown in *Figure* [*2.3*](#Figure2.3).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们运行`qc``.``draw``(``"``mpl``"``)`来验证我们的实现是否正确，我们将得到图*2.3*（[图2.3](#Figure2.3)）中所示的输出。
- en: '![Figure 2.3: Qiskit output for the circuit in Figure 2.2a.](img/file290.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：图2.2a中电路的Qiskit输出。](img/file290.png)'
- en: '**Figure 2.3**: Qiskit output for the circuit in *Figure* [*2.2a*](#Figure2.2a)*.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.3**：图*2.2a*（[图2.2a](#Figure2.2a)）中电路的Qiskit输出。'
- en: Exercise 2.2
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.2
- en: Construct the circuit in *Figure* [*2.2b*](#Figure2.2b). Draw the result and
    use the output to verify whether your circuit implementation is correct.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图*2.2b*（[图2.2b](#Figure2.2b)）构建电路。绘制结果并使用输出验证你的电路实现是否正确。
- en: Measurements
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量
- en: 'We now know how to add quantum gates to a circuit, so there is only one ingredient
    that we are missing: measurement operators. It turns out that this couldn’t be
    easier. If you want to perform a measurement (in the computational basis) at any
    point in a circuit, you can do so by calling the `measure``(``qbits``,``bits``)`
    method, where `qbits` should be a list with all the qubits that you want to measure
    and `bits` should be a list with all the classical bits on which you want the
    measurements to be stored. Of course, the lists must be of the same length.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何向电路添加量子门，所以我们还缺少一个成分：测量算子。实际上，这非常简单。如果你想在电路的任何位置进行测量（在计算基中），你可以通过调用`measure``(``qbits``,`
    `bits``)`方法来完成，其中`qbits`应该是一个包含你想要测量的所有量子比特的列表，而`bits`应该是一个包含你想要存储测量结果的经典比特的列表。当然，列表必须具有相同的长度。
- en: 'If you just want to measure all the qubits and do not want to bother with creating
    a classical register of the appropriate size, you can just call the `measure_all`
    method. This will add as many bits to your circuit as qubits it has, and it will
    measure each qubit and send the results to these bits. If you have already added
    classical bits to store the measurement results, you can still use them with the
    `measure_all` method: all you have to do is set the `add_bits` parameter to `False`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想测量所有量子比特，而不想麻烦地创建适当大小的经典寄存器，你只需调用`measure_all`方法。这将根据量子比特的数量添加相应数量的比特到你的电路中，并对每个量子比特进行测量，并将结果发送到这些比特。如果你已经添加了经典比特来存储测量结果，你仍然可以使用它们与`measure_all`方法：你只需要将`add_bits`参数设置为`False`。
- en: Exercise 2.3
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.3
- en: Implement your own version of the `measure_all` method. You may need to use
    the `add_register` method of the `QuantumCircuit` class, which takes some register
    objects as arguments and appends them to the circuit.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实现你自己的 `measure_all` 方法。你可能需要使用 `QuantumCircuit` 类的 `add_register` 方法，该方法接受一些寄存器对象作为参数并将它们附加到电路中。
- en: So now we can construct our own quantum circuits, but we still need to find
    a way to run them using Qiskit. We will do that in the next subsection. Let’s
    fly in the Aer!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以构建自己的量子电路，但我们仍然需要找到一种方法来使用 Qiskit 运行它们。我们将在下一小节中这样做。让我们飞向 Aer！
- en: 2.2.3 Using Qiskit Aer to simulate quantum circuits
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.3 使用 Qiskit Aer 模拟量子电路
- en: As we mentioned when we introduced the `Qiskit` framework, the `Terra` package
    includes a Python-based simulator, **BasicAer**. While this simulator is good
    enough for most basic tasks, it is largely out-powered by the simulators included
    in the `Aer` package, so we will only discuss these here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍 `Qiskit` 框架时提到的，`Terra` 包包含一个基于 Python 的模拟器，**BasicAer**。虽然这个模拟器对于大多数基本任务来说足够好，但它很大程度上被
    `Aer` 包中包含的模拟器所超越，所以我们在这里只讨论这些。
- en: 'If we want to use the Aer simulator, it will not suffice to import Qiskit.
    This time, we will also have to run the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 Aer 模拟器，仅导入 Qiskit 是不够的。这次，我们还需要运行以下代码：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we have done the necessary imports, we can create an Aer simulator object
    in one of the following ways, depending on whether or not we have configured our
    system to use a GPU:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了必要的导入，我们可以根据是否已配置我们的系统使用 GPU 来创建一个 Aer 模拟器对象，以下是一些方法：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have a GPU and have configured your Qiskit installation properly (see
    *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing the Tools*, for some instructions),
    using the GPU-powered simulator will yield much better results for demanding simulation
    tasks. Nevertheless, you should keep in mind that for less resource-intensive
    simulations, using the GPU may actually lead to worse performance because of the
    communication overhead. For the remainder of this section, we will use the simulator
    without a GPU. If we were to use `sim_GPU`, everything would be fully analogous.*
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 GPU 并且正确配置了你的 Qiskit 安装（有关说明，请参阅 *附录* *[*D*](ch027.xhtml#x1-240000D)，*安装工具*），使用
    GPU 驱动的模拟器将产生对需求较高的模拟任务更好的结果。然而，你应该记住，对于资源消耗较少的模拟，使用 GPU 实际上可能会因为通信开销而导致性能更差。在本节的剩余部分，我们将使用不带
    GPU 的模拟器。如果我们使用 `sim_GPU`，一切都将完全类似。
- en: '*To learn more…'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*要了解更多信息...'
- en: To simulate circuits using a GPU, you will need the `qiskit``-``aer``-` `gpu`
    package. This package is written using CUDA. For this reason, it only supports
    NVIDIA GPUs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GPU 模拟电路，你需要 `qiskit-aer-gpu` 包。这个包是用 CUDA 编写的。因此，它只支持 NVIDIA GPU。
- en: As we already know, when we measure a quantum state the result is probabilistic.
    For that reason, we usually run several executions or **shots** of a given circuit
    and then compute some statistics on the results. If we wanted to simulate the
    execution of `nshots` shots of a circuit `qc`, we would have to run `job` `=`
    `execute``(``qc``,` `sim``,` `shots` `=` `nshots``)`, and we could retrieve a
    *result* object by calling `result` `=` `job``.``result``()`; by the way, the
    default value for `shots` is `1024`. With this result object, we could get the
    simulated frequency counts using `result``.``get_counts``()`, which would give
    us a dictionary with the absolute frequencies of each outcome.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，当我们测量量子态时，结果是概率性的。因此，我们通常会运行给定电路的多次执行或 **射击**，然后对结果进行一些统计分析。如果我们想模拟电路
    `qc` 的 `nshots` 次射击的执行，我们必须运行 `job = execute(qc, sim, shots=nshots)`，并且我们可以通过调用
    `result = job.result()` 来检索一个 *结果* 对象；顺便说一下，`shots` 的默认值是 `1024`。有了这个结果对象，我们可以使用
    `result.get_counts()` 获取模拟的频率计数，这将给我们一个包含每个结果的绝对频率的字典。
- en: 'Let’s try to make this more clear with an example. We will consider a very
    simple two-qubit circuit with a single Hadamard gate in the top qubit. We will
    then measure both qubits in the circuit and simulate ![1024](img/file291.png "1024")
    shots:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来尝试使这一点更清晰。我们将考虑一个非常简单的双量子比特电路，其中顶部的量子比特有一个哈达德门。然后我们将测量电路中的两个量子比特，并模拟
    ![1024](img/file291.png "1024") 次射击：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To learn more…
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息...
- en: If you have a job running, in an object called `job`, and you want to check
    its status, you can import `job_monitor` from `qiskit``.``providers``.``ibmq``.``job`
    and run `job_monitor``(``job` `)`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行一个名为 `job` 的对象，并且想要检查其状态，你可以从 `qiskit.providers.ibmq.job` 导入 `job_monitor`
    并运行 `job_monitor(job)`。
- en: Important note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When getting results for measurements in Qiskit, you need to keep in mind that
    the top qubit becomes the least significant bit, and so on. This is, if you have
    two qubits and, when measured, the top one (qubit ![0](img/file12.png "0")) has
    value ![0](img/file12.png "0") and the bottom one (qubit ![1](img/file13.png "1"))
    has value ![1](img/file13.png "1"), the result will be interpreted as `10`, not
    as `01`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取Qiskit中测量的结果时，你需要记住最上面的量子比特成为最低有效位，依此类推。也就是说，如果你有两个量子比特，并且在测量时，上面的一个（![0](img/file12.png
    "0")量子比特）的值为![0](img/file12.png "0")，下面的一个（![1](img/file13.png "1")量子比特）的值为![1](img/file13.png
    "1")，结果将被解释为`10`，而不是`01`。
- en: This is the opposite of what we have been doing so far — and also the opposite
    of what most of the world agrees on. Thus, what we call state ![10](img/file161.png
    "10"), Qiskit will call `01`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们迄今为止所做的是相反的——也是世界上大多数人所认同的相反。因此，我们称之为状态![10](img/file161.png "10")，Qiskit会称之为`01`。
- en: For most practical purposes, we can simply ignore this issue and assume that
    when we have to access qubit ![q](img/file292.png "q") in a circuit with ![n](img/file244.png
    "n") qubits, we need to use the index ![n - q - 1](img/file293.png "n - q - 1")
    (remember that we start counting qubits at ![0](img/file12.png "0")). This is
    what we will do implicitly when we use Qiskit in practice.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数实际用途，我们可以简单地忽略这个问题，并假设当我们需要访问含有![n](img/file244.png "n")个量子比特的电路中的![q](img/file292.png
    "q")量子比特时，我们需要使用索引![n - q - 1](img/file293.png "n - q - 1")（记住我们从![0](img/file12.png
    "0")开始计数量子比特）。当我们实际使用Qiskit时，我们会隐式地这样做。
- en: 'Theoretically, we know that the state before the measurement is ![\sqrt{\left.
    1\slash 2 \right.}(\left| {00} \right\rangle + \left| {10} \right\rangle)](img/file204.png
    "\sqrt{\left. 1\slash 2 \right.}(\left| {00} \right\rangle + \left| {10} \right\rangle)"),
    so we would expect an even distribution of frequencies for the (Qiskit) outcomes
    ![01](img/file159.png "01") and ![00](img/file157.png "00"), and we should not
    see any occurrences of other results. Indeed, when we ran the code, we got the
    following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，我们知道测量之前的状态是 ![√(1/2)(|00> + |10>)](img/file204.png "√(1/2)(|00> + |10>))"，因此我们预期(Qiskit)的结果
    ![01](img/file159.png "01") 和 ![00](img/file157.png "00") 的频率分布应该是均匀的，我们不应该看到其他结果的出现。实际上，当我们运行代码时，我们得到了以下结果：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Needless to say, you will not get the same results! But you will certainly get
    something with the same flavor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，你不会得到相同的结果！但你肯定会得到一些具有相同风味的东西。
- en: Notice that, in the preceding measurement, we have labeled as ![10](img/file161.png
    "10") the state with ![1](img/file13.png "1") in the first qubit (qubit ![0](img/file12.png
    "0")) (which is consistent with the notation that we have been using). Nonetheless,
    Qiskit, being consistent with its own notation, has labeled its corresponding
    outcome as ![01](img/file159.png "01").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的测量中，我们将第一个量子比特（![0](img/file12.png "0")）中值为![1](img/file13.png "1")的状态标记为![10](img/file161.png
    "10")（这与我们一直使用的符号一致）。尽管如此，Qiskit与其自身的符号保持一致，将其对应的结果标记为![01](img/file159.png "01")。
- en: To learn more…
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: 'If you want to obtain reproducible results when executing circuits in Qiskit,
    you need to use two parameters of the `execute` function: `seed_transpiler` and
    `seed_simulator`. They are used to set the initial values for the pseudo-random
    number generators that are used in the process of transpiling the circuit — we
    will talk about this later in this section — and when sampling from the results
    of the measurements. If you use some fixed seeds, you will always get the same
    results. This can be useful, for instance, for debugging purposes.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Qiskit中执行电路时获得可重复的结果，你需要使用`execute`函数的两个参数：`seed_transpiler`和`seed_simulator`。它们用于设置在电路转换过程中使用的伪随机数生成器的初始值——我们将在本节后面讨论这一点——以及从测量结果中进行采样。如果你使用一些固定的种子，你将始终得到相同的结果。这可以很有用，例如，用于调试目的。
- en: 'All these numbers are good, but we all know that a picture is worth a thousand
    words. Thankfully, the folks at IBM agree, and they have been thoughtful enough
    to bundle some fancy visualization tools right into Qiskit. For instance, we could
    run these instructions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数字都很好，但我们都知道，一张图片胜过千言万语。幸运的是，IBM的同事们同意这一点，并且他们足够周到地将一些花哨的可视化工具直接捆绑到Qiskit中。例如，我们可以运行以下指令：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And we would get the plot shown in *Figure* [*2.4*](#Figure2.4). This function
    admits the optional argument `filename`, which, if provided, will lead to the
    figure being saved with the given string as the filename.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到*图* [*2.4*](#Figure2.4) 中所示的图表。此函数接受可选参数 `filename`，如果提供，则将图保存为给定的字符串作为文件名。
- en: '![Figure 2.4: Histogram generated by Qiskit](img/file294.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：由Qiskit生成的直方图](img/file294.png)'
- en: '**Figure 2.4**: Histogram generated by Qiskit'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.4**：由Qiskit生成的直方图'
- en: As an interesting fact, you should know that the Aer simulator can simulate
    the execution of circuits using different methods. Nevertheless, unless we ask
    otherwise, our circuits will always be simulated using the **statevector** method,
    which — as the name suggests — computes the exact quantum state (or state vector)
    of the system through the circuit in order to generate results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个有趣的事实，你应该知道Aer模拟器可以使用不同的方法来模拟电路的执行。然而，除非我们要求其他方式，否则我们的电路将始终使用**状态向量**方法进行模拟，正如其名称所暗示的那样，它通过电路计算系统的精确量子状态（或状态向量）以生成结果。
- en: Now, if the simulator does compute the quantum state of the system, why settle
    for some simulated samples when we could be getting the actual state? Of course,
    the state of a circuit is something we don’t have access to when working with
    real quantum computers (we can only obtain results by performing measurements),
    but, hey, simulating circuits should have its own perks too!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果模拟器确实计算了系统的量子状态，为什么我们只满足于一些模拟样本，而不去获取实际的状态呢？当然，当我们与真实的量子计算机一起工作时，电路的状态是我们无法访问的（我们只能通过执行测量来获得结果），但是，嘿，模拟电路也应该有其自身的优势！
- en: 'If we want to access the state vector at any point in a quantum circuit `qc`,
    all we have to do is call `qc``.``save_statevector``()`, just as if we were adding
    another gate. Then, once the circuit has been simulated and we have gotten our
    results from the execution job, we can get the state vector using the `get_statevector`
    method, just as we would use `get_counts`. Actually, if our circuit also has measurements,
    we could do both at the same time. For instance, we can consider this example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在量子电路 `qc` 的任何一点访问状态向量，我们只需调用 `qc.save_statevector()`，就像我们添加另一个门一样。然后，一旦电路被模拟并且我们从执行作业中获得了结果，我们可以使用
    `get_statevector` 方法来获取状态向量，就像我们使用 `get_counts` 一样。实际上，如果我们的电路也有测量，我们可以在同一时间做这两件事。例如，我们可以考虑这个例子：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice how, in this piece of code, we have measured the two qubits in the circuit
    using two individual instructions instead of just calling `qc``.``measure``(``range``(2),`
    `range``(2)`. When we run that, we get the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中，我们使用两个单独的指令来测量电路中的两个量子比特，而不是仅仅调用 `qc.measure(range(2), range(2))`。当我们运行它时，我们得到以下输出：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That is exactly what we should have expected. We just need to remember that
    ![\left. 1\slash\sqrt{2} \approx 0.7071\ldots \right.](img/file295.png "\left.
    1\slash\sqrt{2} \approx 0.7071\ldots \right.")! In the output given by Qiskit,
    the first element of the state vector array is the amplitude of the basis state
    ![\left| {00} \right\rangle](img/file198.png "\left| {00} \right\rangle"), the
    second element is the amplitude of ![\left| {10} \right\rangle](img/file200.png
    "\left| {10} \right\rangle") (remember the Qiskit convention for naming basis
    states, so for Qiskit, the label of this state would be `01`), and the following
    ones are the amplitudes of ![\left| {01} \right\rangle](img/file199.png "\left|
    {01} \right\rangle") and ![\left| {11} \right\rangle](img/file201.png "\left|
    {11} \right\rangle") respectively.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们预期的。我们只需要记住![\( \left. \frac{1}{\sqrt{2}} \approx 0.7071\ldots \right.
    \)](img/file295.png "\( \left. \frac{1}{\sqrt{2}} \approx 0.7071\ldots \right.
    \)")！在Qiskit给出的输出中，状态向量数组的第一个元素是基态![\( \left| {00} \right\rangle \)](img/file198.png
    "\( \left| {00} \right\rangle \)")的振幅，第二个元素是![\( \left| {10} \right\rangle \)](img/file200.png
    "\( \left| {10} \right\rangle \)")的振幅（记住Qiskit命名基态的约定，所以对于Qiskit，这个状态的标签将是`01`），接下来的一个是![\(
    \left| {01} \right\rangle \)](img/file199.png "\( \left| {01} \right\rangle \)")和![\(
    \left| {11} \right\rangle \)](img/file201.png "\( \left| {11} \right\rangle \)")的振幅，依次类推。
- en: To learn more…
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多…
- en: It is possible to save multiple state vectors in order to retrieve them later.
    For this, one needs to pass the optional argument `label` to `save_statevector`,
    specifying a label that uniquely identifies the state vector in the circuit. Then,
    the state vectors can be extracted as a dictionary from the results object `result`
    using `result``.``data` `()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能保存多个状态向量以便稍后检索。为此，需要在 `save_statevector` 中传递可选参数 `label`，指定一个唯一标识电路中状态向量的标签。然后，可以从结果对象
    `result` 中使用 `result.data()` 提取状态向量作为字典。
- en: Another possibility that the Aer simulator offers us is computing the unitary
    matrix that would represent, up to any given point, the transformations that have
    been performed by the circuit. In order to get this matrix, we could use the `save_unitary`
    and `get_unitary` methods, which would work in full analogy to `save_statevector`
    and `get_statevector`. As wonderful as this may seem, there is a small caveat,
    which is that these matrices cannot be computed with the statevector method; instead,
    one needs to use the **unitary** method, which does not support measurements and
    does not allow access to the state vector of the circuit. In any case, this is
    not a big deal, for one can always combine different methods of simulation provided
    the simulated circuits are tweaked accordingly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Aer 模拟器为我们提供的另一个可能性是计算表示电路已执行的所有变换的幺正矩阵。为了获取这个矩阵，我们可以使用 `save_unitary` 和 `get_unitary`
    方法，这些方法将与 `save_statevector` 和 `get_statevector` 完全类似。尽管这听起来可能很神奇，但有一个小问题需要注意，那就是这些矩阵不能使用状态向量方法计算；相反，需要使用
    **幺正** 方法，这种方法不支持测量，也不允许访问电路的状态向量。无论如何，这并不是什么大问题，因为只要模拟电路相应调整，就可以结合不同的模拟方法。
- en: 'To see this in action, let us run the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个例子在实际中的应用，让我们运行以下示例：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we execute this code, this is the output that we get:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此代码时，我们得到以下输出：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is, just as it should be, the matrix of the Hadamard gate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它应该的那样，是哈达玛门的矩阵。
- en: Notice, by the way, how we have used the optional argument `decimals` to limit
    the precision of the output. This can also be used in the `get_statevector` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，注意我们是如何使用可选参数 `decimals` 来限制输出精度的。这也可以在 `get_statevector` 方法中使用。
- en: 'We are now able to use Qiskit to construct and simulate circuits, but there’s
    something we are missing: how to actually run them on real quantum hardware. That’s
    what the next subsection is all about.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够使用 Qiskit 构建和模拟电路，但我们还缺少一些东西：如何在真实的量子硬件上实际运行它们。这正是下一个小节要讨论的内容。
- en: '2.2.4 Let’s get real: using IBM Quantum'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2.4 让我们面对现实：使用 IBM Quantum
- en: Now we know how to use the tools provided by Qiskit Aer in order to perform
    ideal simulations of quantum circuits, but we know that real quantum computers,
    even if with limitations, exist and are actually accessible, so why not give them
    a shot (pun intended)?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 Qiskit Aer 提供的工具来执行量子电路的理想模拟，但我们知道真实的量子计算机，即使有局限性，确实存在并且可以访问，那么为什么不尝试一下呢（当然，这里是一个双关语）？
- en: IBM provides, for free, access to some of its real quantum computers. In order
    to gain access, all you have to do is sign up for a free IBM ID account. With
    it, you can log into the IBM Quantum website ([https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/))
    and get your API token (refer to *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing
    the Tools*, for more details).*
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: IBM 免费提供对其部分真实量子计算机的访问。为了获得访问权限，你只需注册一个免费的 IBM ID 账户。有了它，你可以登录到 IBM Quantum
    网站 ([https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/))
    并获取你的 API 令牌（有关更多详细信息，请参阅 *附录* *[*D*](ch027.xhtml#x1-240000D)，*安装工具*）。
- en: '*Once you have your token, the next thing you should do is head to your local
    environment and execute the instruction `IBMQ``.``save_account``(``"``TOKEN``"``)`,
    where, of course, you should replace `TOKEN` with your actual token. With that
    out of the way, we may run the following piece of code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦你有了你的令牌，接下来你应该做的就是前往你的本地环境并执行指令 `IBMQ.save_account("TOKEN")`，其中当然应该用你的实际令牌替换
    `TOKEN`。完成这些后，我们可以运行以下代码片段：*'
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will allow us to load our account details and get a list of all the available
    real quantum devices. If you have an ordinary free account, you could expect to
    get something like this as output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们加载我们的账户详情并获取所有可用真实量子设备的列表。如果你有一个普通的免费账户，你可能会得到以下类似的输出：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we used the argument `simulator` `=` `True`, we would get a list of all the
    available cloud simulators. Their main advantage is that some of them are capable
    of running circuits with many more qubits than an ordinary computer can handle.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用参数 `simulator` `=` `True`，我们会得到所有可用的云模拟器的列表。它们的主要优势是其中一些能够运行比普通计算机能处理的更多量子比特的电路。
- en: A naive way of picking any of these providers would be just choosing one element
    in the list, for instance, taking `dev` `=` `provider``.``backends``(``simulator`
    `=` `False``)[0]`. Alternatively, if you knew the name of the device that you
    want to use (let it be `ibmq_lima`, for instance), you could simply run `dev`
    `=` `provider``.``get_backend``(``’``ibmq_lima``’``)`. Once you have chosen a
    device, that is, a backend object, you can get some of its configuration details
    by calling the `configuration` method (with no arguments). This will return an
    object with information about the device. For instance, in order to know how many
    qubits a provider `dev` has, we could just access `dev``.``configuration``().``n_qubits`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这些提供者的一种天真方式就是从列表中选择一个元素，例如，取 `dev` `=` `provider``.``backends``(``simulator`
    `=` `False``)[0]`。或者，如果你知道你想要使用的设备名称（例如 `ibmq_lima`），你可以简单地运行 `dev` `=` `provider``.``get_backend``(``’``ibmq_lima``’``)。一旦你选择了一个设备，即一个后端对象，你可以通过调用
    `configuration` 方法（不带参数）来获取一些其配置细节。这将返回一个包含设备信息的对象。例如，为了知道提供者 `dev` 有多少个量子比特，我们只需访问
    `dev``.``configuration``().``n_qubits`。
- en: 'Nevertheless, rather than picking a device at random or by a fancy location
    name, we can try to do some filtering first. When calling `get_backend`, we can
    pass an optional `filters` parameter. This should be a one-argument function that
    would only return `True` for the devices that we want to pick. For instance, if
    we wanted to get a list of all the real devices with at least ![5](img/file296.png
    "5") qubits, we could use the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其随机选择一个设备或根据一个花哨的位置名称选择，我们首先可以尝试进行一些筛选。当调用 `get_backend` 时，我们可以传递一个可选的 `filters`
    参数。这应该是一个单参数函数，它只为我们要选择的设备返回 `True`。例如，如果我们想要获取所有至少有 ![5](img/file296.png "5")
    个量子比特的真实设备列表，我们可以使用以下代码：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Out of all of these devices, maybe it is wise to just use the one that is the
    least busy. For this, we can simply execute the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些设备中，可能明智的做法是只使用最不忙碌的那个。为此，我们可以简单地执行以下操作：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To learn more…
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: The `least_busy` accepts an optional parameter called `reservation_lookahead`.
    This is the number of minutes for which a device needs to be free of reservations
    to be considered as a candidate for being the least busy one. The default value
    of the parameter is ![60](img/file297.png "60"). So if it ever happens to you
    that `least_busy` does not return a suitable device, you may set `reservation_lookahead``=`
    `None` to also consider computers that are under reservation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`least_busy` 接受一个名为 `reservation_lookahead` 的可选参数。这是设备需要空闲无预约的时间（分钟数），才能被认为是忙碌程度最低的候选者。该参数的默认值是
    ![60](img/file297.png "60")。所以如果 `least_busy` 没有返回一个合适的设备，你可以设置 `reservation_lookahead`
    `=` `None` 来考虑那些处于预约状态下的计算机。'
- en: And now, running a circuit on the device that we have selected with a certain
    number of shots will be completely analogous to running it on a simulator. Actually,
    we can run it on both and compare the results!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在选定的设备上运行一个电路，该设备具有一定数量的射击次数，将完全类似于在模拟器上运行它。实际上，我们可以在两者上运行并比较结果！
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It will probably take a while to get the results (you will get status updates
    thanks to the `job_monitor``(``job``)` instruction). In fact, sometimes, you can
    experience quite long waiting times because many users are submitting jobs at
    the same time. But with a little bit of patience, the results will eventually
    come! Once the execution has finished, we can print the results, and we could
    get something like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 获取结果可能需要一段时间（你将通过 `job_monitor` (`job`) 指令获得状态更新）。实际上，有时你可能需要经历相当长的等待时间，因为许多用户同时提交作业。但只要有耐心，结果最终会到来！一旦执行完成，我们可以打印结果，可能会得到类似以下的内容：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That is close, but far from ideal! We can see how in the execution on real hardware,
    we get some outputs — namely, `10` and 01 — that should not even be allowed in
    the first place. This is the effect of the **noise** of real quantum computers,
    which makes them deviate from perfect mathematical simulations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很接近了，但还远非理想！我们可以看到在真实硬件上的执行中，我们得到了一些输出——即 `10` 和 `01`——这些输出在最初甚至都不应该被允许。这是真实量子计算机的**噪声**效应，这使得它们偏离了完美的数学模拟。
- en: To learn more…
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: 'Here, we have only worked with ideal simulations. You can also perform noisy
    simulations in Qiskit, which can more faithfully resemble the behavior of the
    quantum computers that are at our disposal today. Moreover, you could configure
    these simulations to use the same noise parameters as those measured in the real
    quantum devices owned by IBM. We will learn how to do this in *Chapter* *[*7*](ch015.xhtml#x1-1190007),
    *VQE: Variational Quantum Eigensolver*.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只进行了理想模拟。你还可以在Qiskit中进行有噪声的模拟，这可以更真实地模拟我们今天可用的量子计算机的行为。此外，你可以配置这些模拟以使用与IBM拥有的真实量子设备中测量的相同噪声参数。我们将在*第*
    *7* *章* *VQE：变分量子本征值求解器* *中学习如何做到这一点*。
- en: '*Important note'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*重要提示'
- en: When executing quantum circuits on actual quantum hardware, you have to be aware
    of the fact that real quantum systems only implement certain gates, and thus some
    of the gates that make up the circuit may have to be decomposed using the gates
    available. For instance, it is typical to decompose multi-qubit gates into qubits
    that act on just one or two qubits or to simulate CNOT gates between qubits that
    are not directly connected in the quantum computer by first swapping the qubits,
    then applying an actually existing CNOT gate, and then swapping back the qubits.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当在真实的量子硬件上执行量子电路时，你必须意识到现实中的量子系统只实现某些门，因此组成电路的一些门可能需要使用可用的门进行分解。例如，将多量子比特门分解为仅作用于一个或两个量子比特的门是典型的做法，或者通过首先交换量子比特，然后应用实际存在的CNOT门，最后再交换回量子比特，来模拟量子计算机中未直接连接的量子比特之间的CNOT门。
- en: This process is called **transpilation**, and, using the code that we have considered,
    we have let Qiskit take care of all its details automatically. However, it is
    possible to dive deeper into this and to hack it as much as one could want! For
    instance, you can use the `transpile` method to manually define a transpilation,
    specifying the gates that are present in the computer or the qubits that are actually
    connected, among other things. See the documentation at [https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html](https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html)
    for more details.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为**编译器转换**，并且，使用我们考虑的代码，我们已经让Qiskit自动处理所有细节。然而，你可以深入了解这一点，并且尽可能多地对其进行修改！例如，你可以使用`transpile`方法手动定义编译器转换，指定计算机中存在的门或实际连接的量子比特，以及其他事项。有关更多详细信息，请参阅[https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html](https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html)。
- en: 'In this section, we have gained a good understanding of the general structure
    of the Qiskit framework, we have learned how to implement circuits in it, and
    how to simulate them and run them on real hardware through IBM Quantum. In the
    following section, we will do the same for another very interesting framework:
    PennyLane. Let’s get to it!'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们对Qiskit框架的一般结构有了很好的理解，我们学习了如何在其中实现电路，以及如何通过IBM Quantum对其进行模拟和运行。在下一节中，我们将对另一个非常有趣的框架：PennyLane，做同样的处理。让我们开始吧！
- en: 2.3 Working with PennyLane
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 使用PennyLane
- en: 'The structure of PennyLane [[103](ch030.xhtml#XPennyLane)] is more simple than
    that of Qiskit. PennyLane mainly consists of a core software package, which comes
    with all the features that you would expect: it allows you to implement quantum
    circuits, it comes with some wonderful built-in simulators, and it also allows
    you to train quantum machine learning models (both with native tools and with
    a **TensorFlow** interface).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: PennyLane的结构[[103](ch030.xhtml#XPennyLane)]比Qiskit简单。PennyLane主要包含一个核心软件包，它包含了你期望的所有功能：它允许你实现量子电路，它附带一些出色的内置模拟器，并且它还允许你使用原生工具和**TensorFlow**接口训练量子机器学习模型。
- en: In addition to this core package, PennyLane can be extended with a wide selection
    of plugins that provide interfaces to other quantum computing frameworks and platforms.
    At the time of writing, these include **Qiskit**, **Amazon Braket**, the **Microsoft
    QDK**, and **Cirq**, among many others that we have not mentioned in our introduction.
    In addition, there is a community plugin, **PyQuest**, that makes PennyLane interoperable
    with the QuEST simulator ([https://github.com/johannesjmeyer/pennylane-pyquest](https://github.com/johannesjmeyer/pennylane-pyquest)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个核心包之外，PennyLane可以通过一系列插件进行扩展，这些插件提供了与其他量子计算框架和平台的接口。在撰写本文时，这些包括**Qiskit**、**Amazon
    Braket**、**Microsoft QDK**和**Cirq**等许多我们未在介绍中提到的其他框架。此外，还有一个社区插件**PyQuest**，它使得PennyLane能够与QuEST模拟器([https://github.com/johannesjmeyer/pennylane-pyquest](https://github.com/johannesjmeyer/pennylane-pyquest))兼容。
- en: In short, with PennyLane, it’s not that you get the best of both worlds. You
    truly can get the best of any world!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用PennyLane，你不仅仅是获得了两个世界的最佳之处。你真的可以获取任何世界的最佳之处！
- en: Important note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are going to work with **version 0.26** of PennyLane. If you are using a
    different version, some things may be different. If in doubt, you should always
    check the documentation ([https://pennylane.readthedocs.io/en/stable/](https://pennylane.readthedocs.io/en/stable/)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**版本0.26**的PennyLane。如果你使用的是不同版本，某些事情可能会有所不同。如果有疑问，你应该始终检查文档([https://pennylane.readthedocs.io/en/stable/](https://pennylane.readthedocs.io/en/stable/))。
- en: Exercise 2.4
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.4
- en: Follow the instructions in *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing
    the Tools*, to install **version 0.26** of PennyLane and its Qiskit plugin.*
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照*附录* *[*D*](ch027.xhtml#x1-240000D)中*安装工具*的说明，安装PennyLane及其Qiskit插件的**版本0.26**。
- en: '*Once you have installed PennyLane, you can import it. Following the conventions
    set out in PennyLane’s documentation, we will do it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦你安装了PennyLane，你就可以导入它。按照PennyLane文档中规定的约定，我们将如下操作：'
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After running this instruction, you can check which version of PennyLane you
    are running by printing the string `qml``.``__version__`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此指令后，你可以通过打印字符串`qml``.``__version__`来检查你正在运行的PennyLane版本。
- en: Now that we are all set up, let’s build our first circuit, shall we?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了，让我们构建我们的第一个电路，好吗？
- en: 2.3.1 Circuit engineering 101
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.1 电路工程101
- en: The way quantum circuits are built in PennyLane is fundamentally different to
    the way they are constructed in Qiskit.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在PennyLane中构建量子电路的方式与在Qiskit中构建的方式根本不同。
- en: In Qiskit, if we wanted to implement a quantum circuit, we would initialize
    a `QuantumCircuit` object and manipulate it with some methods; some of these methods
    would be used to add gates to the circuit, some to perform measurements, and some
    to specify where we wanted to extract information about the state of the circuit.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qiskit中，如果我们想实现一个量子电路，我们会初始化一个`QuantumCircuit`对象，并使用一些方法来操作它；其中一些方法用于向电路添加门，一些用于执行测量，还有一些用于指定我们想要提取有关电路状态信息的位置。
- en: 'In PennyLane, on the other hand, if you want to run a circuit, you need two
    elements: a `Device` object and a function that specifies the circuit.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在PennyLane中，另一方面，如果你想运行一个电路，你需要两个元素：一个`Device`对象和一个指定电路的函数。
- en: 'To put it in simple terms, a `Device` object is PennyLane’s virtual analog
    of a quantum device. It is an object with methods that allow it to run any circuit
    that it is given (through a simulator, through an interface with other platforms,
    or however it may be!). For example, if we have a circuit and we want to run it
    on the `default``.``qubit` simulator (more on that later in this section) using
    two qubits, we will need to use this device:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话来说，`Device`对象是PennyLane对量子设备的虚拟模拟。它是一个具有方法的对象，允许它运行任何给定的电路（通过模拟器、通过与其他平台的接口，或任何其他方式！）例如，如果我们有一个电路，并且我们想在`default``.``qubit`模拟器上使用两个量子比特运行它（关于这一点将在本节后面详细说明），我们需要使用这个设备：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice, by the way, how the number of qubits available is a property of the
    device object itself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，注意一下可用的量子比特数量是设备对象本身的属性。
- en: Now that we have a device, we need to define the specification of our circuit.
    As we mentioned earlier, that is as easy as defining a function. In this function,
    we will execute instructions that will correspond to the actions of the quantum
    gates that we want to use. Lastly, the output of the function will be whichever
    information we want to get out of the circuit — whether it be the state of the
    circuit, some measurement samples, or whatever it may be. Of course, the output
    that we can get will depend on the device that we are using.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了设备，我们需要定义电路的规格。正如我们之前提到的，这就像定义一个函数一样简单。在这个函数中，我们将执行与我们要使用的量子门动作相对应的指令。最后，函数的输出将是我们要从电路中获取的任何信息——无论是电路的状态、一些测量样本，还是其他任何信息。当然，我们可以获取的输出将取决于我们使用的设备。
- en: 'Let us illustrate this with an example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we have a very basic circuit specification. In this circuit, we get the
    state vector (with `qml``.``state``()`), after we first apply an ![X](img/file9.png
    "X") gate on the first qubit and then an ![H](img/file10.png "H") gate on the
    first qubit too. We do this by calling, in sequence, `qml``.``PauliX` and `qml``.``Hadamard`,
    specifying the wires on which we want the gates to act. In most non-parametrized
    gates, `wires` is the first positional argument, and it does not have a default
    value, so you need to provide one. In the case of single-qubit gates, this value
    must be an integer representing the qubit on which the gate is meant to act. Analogously,
    for multi-qubit gates, `wires` must be a list of integers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个非常基本的电路规格。在这个电路中，我们首先在第一个量子比特上应用一个![X](img/file9.png "X")门，然后在第一个量子比特上再应用一个![H](img/file10.png
    "H")门，之后我们得到状态向量（使用`qml.state()`）。我们通过依次调用`qml.PauliX`和`qml.Hadamard`，指定我们想要门作用在其上的线来实现这一点。在大多数非参数化门中，`wires`是第一个位置参数，它没有默认值，因此你需要提供一个。在单量子比特门的情况下，这个值必须是一个整数，表示门要作用的量子比特。类似地，对于多量子比特门，`wires`必须是一个整数列表。
- en: You may have noticed that the naming conventions for gate classes in PennyLane
    differ from those for gate methods in Qiskit. The functions for the ![X](img/file9.png
    "X"), ![Y](img/file11.png "Y"), and ![Z](img/file8.png "Z") Pauli gates are, respectively,
    `qml``.``PauliX`, `qml``.``PauliY`, and `qml``.``PauliZ`. Also, as we have just
    seen, the function for the Hadamard gate is `qml``.``Hadamard`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，PennyLane中门类的命名约定与Qiskit中门方法的命名约定不同。![X](img/file9.png "X")、![Y](img/file11.png
    "Y")和![Z](img/file8.png "Z")泡利门的函数分别是`qml.PauliX`、`qml.PauliY`和`qml.PauliZ`。同样，正如我们刚刚看到的，哈达玛门的函数是`qml.Hadamard`。
- en: In regard to rotation gates, we can apply ![R_{X}](img/file118.png "R_{X}"),
    ![R_{Y}](img/file119.png "R_{Y}"), and ![R_{Z}](img/file120.png "R_{Z}") parametrized
    by `theta` on a wire `w` using the instructions `qml``.``RX``(``phi``=``theta``,`
    `wires``=``w``)`, `qml``.``RY``(``phi``=``theta``,` `wires``=``w``)`, and `qml``.``RZ``(``phi``=``theta``,`
    `wires``=``w``)` respectively. In addition, the universal single-qubit gate ![U(\theta,\varphi,\lambda)](img/file287.png
    "U(\theta,\varphi,\lambda)") can be applied on a wire `w` calling `qml``.``U3``(``theta``,`
    `phi``,` `lambd``,` `w``)`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 关于旋转门，我们可以在线`w`上应用由`theta`参数化的![R_{X}](img/file118.png "R_{X}")、![R_{Y}](img/file119.png
    "R_{Y}")和![R_{Z}](img/file120.png "R_{Z}")，分别使用指令`qml.RX(phi=theta, wires=w)`、`qml.RY(phi=theta,
    wires=w)`和`qml.RZ(phi=theta, wires=w)`。此外，通用的单量子比特门![U(\theta,\varphi,\lambda)](img/file287.png
    "U(\theta,\varphi,\lambda)")可以通过调用`qml.U3(theta, phi, lambd, w)`在线`w`上应用。
- en: Lastly, the controlled Pauli gates can be applied on a pair of qubits `w` `=`
    `[``w0``,` `w1``]` using the instructions `qml``.``CNOT``(``w``)`, `qml``.``CY``(``w``)`
    and `qml``.``CZ``(``w``)`. The first wire, `w0`, is meant to be the control qubit,
    while the second one must be the target. Controlled ![X](img/file9.png "X"), ![Y](img/file11.png
    "Y"), and ![Z](img/file8.png "Z") rotations parametrized by an angle `theta` can
    be added with the instructions `qml``.``CRX``(``theta``,` `w``)`, `qml``.``CRY``(``theta``,`
    `w``)`, and `qml``.``CRZ``(``theta``,` `w``)` respectively.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，受控泡利门可以通过指令`qml.CNOT(w)`、`qml.CY(w)`和`qml.CZ(w)`应用于一对量子比特`w` `=` `[w0, w1]`。第一条线`w0`意味着要作为控制量子比特，而第二条线必须是目标量子比特。通过指令`qml.CRX(theta,
    w)`、`qml.CRY(theta, w)`和`qml.CRZ(theta, w)`可以分别添加由角度`theta`参数化的受控![X](img/file9.png
    "X")、![Y](img/file11.png "Y")和![Z](img/file8.png "Z")旋转。
- en: 'In any case, we now have a two-qubit device `dev` and we have a circuit function
    `qc`. How do we assemble these two together and run the circuit? Easy, all we
    have to do is execute the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们现在有一个双量子比特设备`dev`和一个电路函数`qc`。我们如何将这两个组合在一起并运行电路？很简单，我们只需要执行以下操作：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we run this, we will get the following result,
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们将得到以下结果，
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: which makes perfect sense, for we know that
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全合理，因为我们知道
- en: '| ![(HX \otimes I)\left&#124; {00} \right\rangle = (H \otimes I)\left&#124;
    {10} \right\rangle = \frac{1}{\sqrt{2}}\left( {\left&#124; {00} \right\rangle
    - \left&#124; {10} \right\rangle} \right) \approx (0.7071\ldots)\left( {\left&#124;
    {00} \right\rangle - \left&#124; {10} \right\rangle} \right).](img/file298.png
    "(HX \otimes I)\left&#124; {00} \right\rangle = (H \otimes I)\left&#124; {10}
    \right\rangle = \frac{1}{\sqrt{2}}\left( {\left&#124; {00} \right\rangle - \left&#124;
    {10} \right\rangle} \right) \approx (0.7071\ldots)\left( {\left&#124; {00} \right\rangle
    - \left&#124; {10} \right\rangle} \right).") |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| ![此处应有图片](img/file298.png "(HX \otimes I)\left&#124; {00} \right\rangle =
    (H \otimes I)\left&#124; {10} \right\rangle = \frac{1}{\sqrt{2}}\left( {\left&#124;
    {00} \right\rangle - \left&#124; {10} \right\rangle} \right) \approx (0.7071\ldots)\left(
    {\left&#124; {00} \right\rangle - \left&#124; {10} \right\rangle} \right).") |'
- en: As a fun fact, the result of assembling a circuit function and a device is known,
    in PennyLane jargon, as a **Quantum Node** (or **QNode**, for short).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为有趣的事实，在PennyLane术语中，将电路函数和设备组合的结果称为**量子节点**（或简称**QNode**）。
- en: Important note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'PennyLane, unlike Qiskit, labels state like most people do: assigning to the
    first qubit the most significant bit. Thus, a PennyLane output of `10` corresponds
    to the state ![\left| {10} \right\rangle](img/file200.png "\left| {10} \right\rangle").'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与Qiskit不同，PennyLane像大多数人一样标记状态：将最重要的比特分配给第一个量子比特。因此，PennyLane的输出`10`对应于状态![\left|
    {10} \right\rangle](img/file200.png "\left| {10} \right\rangle")。
- en: Notice how, consistent with PennyLane’s convention for labeling states, the
    state vector is returned as a list with the amplitudes of the states in the computational
    basis. The first element corresponds to the amplitude state ![\left| {0\cdots
    0} \right\rangle](img/file299.png "\left| {0\cdots 0} \right\rangle"), the second
    one to that of ![\left| {0\cdots 01} \right\rangle](img/file300.png "\left| {0\cdots
    01} \right\rangle"), and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与PennyLane对状态标记的约定一致，状态向量以列表形式返回，其中包含计算基中各状态的概率幅。第一个元素对应于状态![\left| {0\cdots
    0} \right\rangle](img/file299.png "\left| {0\cdots 0} \right\rangle")的概率幅，第二个对应于![\left|
    {0\cdots 01} \right\rangle](img/file300.png "\left| {0\cdots 01} \right\rangle")的概率幅，依此类推。
- en: In the preceding example, we should remark that at no point in the definition
    of the function `qc` did we specify the number of qubits of the circuit — we left
    that to the device. When we create a QNode, PennyLane assumes that the device
    has enough qubits to execute the circuit specification. If that isn’t the case,
    we will encounter a `WireError` exception when executing the corresponding QNode.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们应该指出，在函数`qc`的定义中，我们没有指定电路的量子比特数量——我们将其留给了设备。当我们创建一个QNode时，PennyLane假设设备有足够的量子比特来执行电路规范。如果情况不是这样，当执行相应的QNode时，我们将遇到`WireError`异常。
- en: 'If you — like most of us! — are lazy, all this process of defining a function
    and assembling it with a device might seem overwhelmingly exhausting. Thankfully,
    the folks at PennyLane were kind enough to provide a shortcut. If you have a device
    `dev` and want to define a circuit for it, you could just do the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你——就像我们中的大多数人一样——很懒，那么定义一个函数并将其与设备组装起来的整个过程可能看起来非常累人。幸运的是，PennyLane的团队非常友好，提供了一条捷径。如果你有一个设备`dev`并且想要为其定义一个电路，你可以简单地做以下操作：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that is much cuter! By placing the `@qml``.``qnode``(``dev``)` decorator
    before the definition of our circuit function, it automatically became a QNode
    without us having to do anything else.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来要酷多了！通过在电路函数定义之前放置`@qml``.``qnode``(``dev``)`装饰器，它自动变成了一个QNode，我们无需做任何其他事情。
- en: 'We have seen how circuits in PennyLane are implemented as simple functions,
    and this begs the question: are we allowed then to use parameters in these functions?
    The answer is a resounding yes. Let us say that we want to construct a one-qubit
    circuit, parametrized by a certain `theta`, which performs an ![X](img/file9.png
    "X")-rotation by this parameter. Doing so is as easy as this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 PennyLane 中的电路是如何实现为简单的函数的，这引发了一个问题：我们是否可以在这些函数中使用参数？答案是响亮的肯定。让我们假设我们想要构建一个由某个
    `theta` 参数化的单量子比特电路，该电路通过这个参数执行 ![X](img/file9.png "X")-旋转。这样做就像这样：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And, with this, for any value `theta` of our choice, we can run `qcirc``(``theta``)`
    and get our result. This way of handling parameters is very handy and convenient.
    Of course, you can use loops and conditionals dependent on circuit parameters
    within the definition of a circuit. The possibilities are endless!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，有了这个，对于我们所选择的任何 `theta` 值，我们都可以运行 `qcirc(theta)` 并得到我们的结果。这种方式处理参数非常方便和方便。当然，你可以在电路定义中使用循环和依赖于电路参数的条件。可能性是无限的！
- en: 'If at any point you need to draw a circuit in PennyLane, that is not an issue:
    it is fairly straightforward. Once you have a quantum node `qcirc`, you can pass
    this node to the `qml``.``draw` function. This will itself return a function,
    `qml``.``draw``(``qcirc``)`, which will take the same arguments as `qcirc` and
    will give you a string that *draws* the circuit for each choice of those arguments.
    We may see this more clearly with an example. Let us execute the following piece
    of code to draw the `qcirc` circuit that we’ve just considered for ![\theta =
    2](img/file301.png "\theta = 2"):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候你需要绘制 PennyLane 中的电路，那不是问题：这相当直接。一旦你有一个量子节点 `qcirc`，你可以将这个节点传递给 `qml.draw`
    函数。这将返回一个函数，`qml.draw(qcirc)`，它将接受与 `qcirc` 相同的参数，并将给出一个字符串，为这些参数的每个选择绘制电路。我们可以用一个例子更清楚地看到这一点。让我们执行以下代码来绘制我们刚刚考虑的
    `qcirc` 电路，其中 ![theta = 2](img/file301.png "\theta = 2")：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Upon running that, we get the following representation of the circuit:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，我们得到以下电路表示：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So far, we have only performed simulations that return the state vector of
    the circuit at the end of its executions, but, naturally, that is just one of
    the many options that PennyLane provides. These are some, but not all, of the
    return values that we can have in a circuit function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只执行了返回电路执行结束时状态向量的模拟，但，自然地，这只是 PennyLane 提供的许多选项之一。这些是一些，但不是所有的返回值，我们可以在电路函数中拥有：
- en: If we want to get the state of the circuit at the end of its execution, we can,
    as we have seen, return `qml``.``state` `()`.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在电路执行结束时获取其状态，我们可以像之前看到的那样，返回 `qml.state()`。
- en: If we wish to get a list with the probabilities of each state in the computational
    basis of a list of wires `w`, we can return `qml``.``probs``(``wires` `=` `w``)`.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们希望得到一个列表，其中包含列表 `w` 中每个状态在计算基的概率，我们可以返回 `qml.probs(wires = w)`。
- en: We can get a sample of measurements in the computational basis of some wires
    `w` by returning `qml``.``sample``(``wires` `=` `w``)`; the `wires` argument is
    optional (if no value is provided, all qubits are measured). When we get a sample,
    we have to specify its size by either setting a `shots` argument when invoking
    the device or by setting it when calling the QNode.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过返回 `qml.sample(wires = w)` 来获取一些线 `w` 在计算基中的测量样本；`wires` 参数是可选的（如果没有提供值，则测量所有量子比特）。当我们得到一个样本时，我们必须通过在调用设备时设置
    `shots` 参数或在调用 QNode 时设置它来指定其大小。
- en: We will explore some additional possibilities for return values in *Chapter*
    *[*10*](ch019.xhtml#x1-18100010), *Quantum Neural Networks*. We already know how
    to get the state of the circuit. In order to illustrate the other return values
    that we may use, let us execute the following piece of code:*
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第* *[*10*](ch019.xhtml#x1-18100010)* 章 *量子神经网络* 中探索一些额外的返回值可能性。我们已经知道如何获取电路的状态。为了说明我们可能使用的其他返回值，让我们执行以下代码：*
- en: '*[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE30]'
- en: 'The output we got with this execution is the following (the samples returned
    in your case will probably be different):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这次执行得到的输出如下（你返回的样本可能会不同）：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There might be a bit to unpack here. So, first of all, we are returned a list
    of probabilities; these are, in accordance with PennyLane’s conventions, the probabilities
    of getting ![00](img/file157.png "00"), ![01](img/file159.png "01"), ![10](img/file161.png
    "10"), and ![11](img/file163.png "11"). In these possible outcomes, the first
    (leftmost) bit represents the outcome of the first measured qubit: in our case,
    since we are measuring wires `[1,` `2]`, the second wire of the circuit, wire
    ![1](img/file13.png "1"). The second (rightmost) bit represents the outcome of
    the second measured qubit: in our case, the third wire of the circuit. For example,
    the first number in the list of probabilities represents the probability of getting
    ![00](img/file157.png "00") (that is, ![0](img/file12.png "0") in both wires).
    The second number in the list would be the probability of getting ![01](img/file159.png
    "01") (![0](img/file12.png "0") in wire ![1](img/file13.png "1") and ![1](img/file13.png
    "1") in wire ![2](img/file302.png "2")). And so on.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能有一些内容需要解释。首先，我们得到一个概率列表；根据PennyLane的约定，这些概率是得到![00](img/file157.png "00")、![01](img/file159.png
    "01")、![10](img/file161.png "10")和![11](img/file163.png "11")的概率。在这些可能的结果中，第一个（最左边的）位表示第一个测量的量子比特的结果：在我们的情况下，因为我们测量的是线
    `[1,` `2]`，即电路的第二根线，线![1](img/file13.png "1")。第二个（最右边的）位表示第二个测量的量子比特的结果：在我们的情况下，电路的第三根线。例如，概率列表中的第一个数字表示得到![00](img/file157.png
    "00")的概率（即两根线上都是![0](img/file12.png "0")）。列表中的第二个数字表示得到![01](img/file159.png "01")的概率（即线![1](img/file13.png
    "1")上是![0](img/file12.png "0")，线![2](img/file302.png "2")上是![1](img/file13.png
    "1")）。以此类推。
- en: Lastly, in the next two examples, we are getting some measurement samples. In
    the first case, we specify that we want to measure only the first qubit (wire
    ![0](img/file12.png "0")), and, when we call the QNode, we ask for ![4](img/file143.png
    "4") shots; since we hadn’t specified a default number of shots when defining
    the device, we need to do it in the execution. And with that, we have a sample
    of the first qubit. In our case, the results were first 0, then 1, and then two
    more zeros.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在接下来的两个例子中，我们得到了一些测量样本。在第一种情况下，我们指定只测量第一个量子比特（线![0](img/file12.png "0")），当我们调用QNode时，我们要求![4](img/file143.png
    "4")次射击；因为我们定义设备时没有指定默认的射击次数，所以我们需要在执行时指定。这样，我们就得到了第一个量子比特的样本。在我们的情况下，结果先是0，然后是1，然后是两个更多的0。
- en: In the last example, we define a two-qubit circuit and we measure all the wires.
    We already specified a default number of shots (![4](img/file143.png "4")) when
    we defined the device, so we don’t need to do it when calling the QNode. And,
    upon execution, we are given a sample of measurements. Each item in the list corresponds
    to a sample. Within each sample, the first element gives the result of measuring
    the first qubit of the circuit, the second element the result of measuring the
    second qubit, and so on it would go. For example, in our case, we see that in
    the first measurement we obtained ![1](img/file13.png "1") on the first qubit
    and ![0](img/file12.png "0") on the second one.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，我们定义了一个双量子比特电路，并测量了所有线。我们在定义设备时已经指定了默认的射击次数 (![4](img/file143.png "4"))，所以在调用QNode时不需要做。执行后，我们得到了测量样本。列表中的每个项目都对应一个样本。在每个样本中，第一个元素给出了测量电路第一个量子比特的结果，第二个元素给出了测量第二个量子比特的结果，依此类推。例如，在我们的情况下，我们看到在第一次测量中，第一个量子比特得到了![1](img/file13.png
    "1")，第二个量子比特得到了![0](img/file12.png "0")。
- en: Exercise 2.5
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.5
- en: Implement the circuits in *Figure* [*2.2*](#Figure2.2) and verify that you get
    the same state vector that we get when simulating with Qiskit Aer.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图* [*2.2*](#Figure2.2) 中实现电路，并验证你得到的状态向量与我们使用Qiskit Aer模拟得到的状态向量相同。
- en: Keep in mind that, as we have mentioned before, Qiskit and PennyLane use different
    conventions when naming basis states. Be careful with that!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，正如我们之前提到的，Qiskit和PennyLane在命名基态时使用不同的约定。请注意这一点！
- en: To learn more…
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多……
- en: If you want to get reproducible results using PennyLane’s simulator, you can
    set a seed `s` using the instruction `np``.``random``.``seed``(``s` `)` after
    importing the `numpy` package as `np`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用PennyLane的模拟器得到可重复的结果，你可以在导入`numpy`包作为`np`之后，使用指令`np.random.seed(s)`设置一个种子`s`。
- en: So far, we have been working with devices based on the `default``.``qubit` simulator,
    which is a Python-based simulator with some basic functionalities. We will introduce
    more simulators when we dive into the world of quantum machine learning. For now,
    however, you should at least know about the existence of the `lightning``.``qubit`
    simulator, which relies on a C++ backend and provides a significant boost in performance,
    especially for circuits with a large number of qubits. Its usage is analogous
    to that of the `default``.``qubit` simulator. Furthermore, there is a `lightning``.``gpu`
    simulator that can enable the Lightning simulator to rely on your GPU. It can
    be installed as a plugin. As in the case of Qiskit, at the time of writing this
    book, it only supports NVIDIA GPUs (and mainly just quite modern ones!).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用基于`default.qubit`模拟器的设备，这是一个基于Python的模拟器，具有一些基本功能。当我们深入量子机器学习的世界时，我们将介绍更多的模拟器。然而，现在，你至少应该了解`lightning.qubit`模拟器的存在，它依赖于C++后端，并在性能上提供了显著提升，尤其是在具有大量量子比特的电路中。它的使用方式与`default.qubit`模拟器类似。此外，还有一个`lightning.gpu`模拟器，可以使Lightning模拟器依赖于你的GPU。它可以作为插件安装。正如Qiskit的情况一样，在撰写本书时，它只支持NVIDIA
    GPU（并且主要是相当现代的！）。
- en: 2.3.2 PennyLane’s interoperability
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3.2 PennyLane的互操作性
- en: We have mentioned plenty of times how one of PennyLane’s virtues is its ability
    to communicate with other quantum frameworks. We will now try to demonstrate this
    with PennyLane’s Qiskit interface. Parlez-vous Qiskit?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到PennyLane的一个优点是它能够与其他量子框架进行通信。现在，我们将通过PennyLane的Qiskit接口来尝试展示这一点。你会说Qiskit吗？
- en: 'When you install the Qiskit plugin for PennyLane, you gain access to a new
    set of devices: most notably, a `qiskit``.``aer` device that allows you to use
    the Aer simulator directly from PennyLane, and a `qiskit``.``ibmq` device that
    enables you to run circuits on the real quantum computers available from IBM Quantum.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装PennyLane的Qiskit插件时，你将获得一组新的设备：最值得注意的是，一个`qiskit.aer`设备，它允许你直接从PennyLane使用Aer模拟器，以及一个`qiskit.ibmq`设备，它使你能够在IBM
    Quantum提供的真实量子计算机上运行电路。
- en: Love is in the Aer
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 爱在Aer中
- en: 'If we want to simulate a circuit in PennyLane using Aer, all we have to do
    is use a device with the `qiskit``.``aer` simulator — and, of course, having installed
    the appropriate plugin (refer to *Appendix* *[*D*](ch027.xhtml#x1-240000D), *Installing
    the Tools*). This will allow us to get measurement samples and also measurement
    probabilities (through `qml``.``sample` and `qml``.``probs` respectively). Actually,
    the measurement probabilities returned by these Aer devices are approximations
    of the exact probabilities: they are obtained by sampling and returning the empirical
    probabilities. By default, in an Aer device, the number of shots is fixed at ![1024](img/file291.png
    "1024"), following Qiskit’s conventions. Of course, the number of shots can be
    adjusted as with any other PennyLane device.*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在PennyLane中使用Aer模拟器模拟电路，我们只需要使用一个带有`qiskit.aer`模拟器的设备——当然，前提是你已经安装了适当的插件（参考*附录*
    *[*D*](ch027.xhtml#x1-240000D)，*安装工具*）。这将使我们能够获取测量样本以及测量概率（分别通过`qml.sample`和`qml.probs`）。实际上，这些Aer设备返回的测量概率是精确概率的近似：它们是通过采样并返回经验概率获得的。默认情况下，在Aer设备中，射击次数固定为![1024](img/file291.png
    "1024")，遵循Qiskit的约定。当然，射击次数可以像任何其他PennyLane设备一样进行调整。
- en: '*We can see a `qiskit``.``aer` device in action with the following code sample:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们可以通过以下代码示例看到`qiskit.aer`设备在行动中：'
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we run this, we can get something like the following output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们可以得到以下类似输出：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This shows that, indeed, the result is not analytical, but empirical and extracted
    from a sample. If you want to obtain the state vector, you need to use the following
    instruction when creating the device:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，确实，结果不是解析的，而是经验性的，并从样本中提取出来的。如果你想获得状态向量，你需要在创建设备时使用以下指令：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will allow you to use `qml``.``state``()` to retrieve the state amplitudes,
    as we did with the PennyLane devices. Moreover, if you try to get probabilities
    using `qml``.``probs` with this device object, you will now get analytical results.
    For example, if you run the previous example on this device, you will always obtain
    `[0.5,` `0.5]`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你使用`qml.state()`来检索状态振幅，就像我们使用PennyLane设备时做的那样。此外，如果你尝试使用`qml.probs`与这个设备对象获取概率，你现在将得到解析结果。例如，如果你在这个设备上运行前面的示例，你将始终获得`[0.5,
    0.5]`。
- en: Connecting to IBMQ
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到IBMQ
- en: The ability to (partially) use the Aer simulator is probably not the most appealing
    feature of PennyLane’s Qiskit interface. Nevertheless, being able to connect to
    IBM’s quantum computers is a more exciting possibility.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 能够（部分）使用Aer模拟器可能是PennyLane Qiskit接口最吸引人的特性。然而，能够连接到IBM的量子计算机是一个更令人兴奋的可能性。
- en: 'In order to connect to an IBM Quantum device, we will first load Qiskit and
    get the name of the least busy hardware backend, just as we did in the previous
    section:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到IBM量子设备，我们首先加载Qiskit并获取最不繁忙的硬件后端名称，就像我们在上一节中所做的那样：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Upon executing the preceding code, we get our desired result:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，我们得到了我们期望的结果：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And that’s how you can send jobs to IBM Quantum using PennyLane!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用PennyLane将作业发送到IBM量子计算机的方法！
- en: To learn more…
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多...
- en: Of course, you can use any quantum device that is accessible with your IBM account,
    not just the least busy one. You only need to replace the definition of the backend
    in the previous code with a direct specification of a particular computer as we
    did in the previous section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用任何可以通过你的IBM账户访问的量子设备，而不仅仅是使用最不繁忙的那个。你只需要将之前代码中后端的定义替换为我们在上一节中直接指定的特定计算机即可。
- en: With this introduction to the workings of Qiskit and PennyLane and all the mathematical
    concepts that we studied in *Chapter* *[*1*](ch008.xhtml#x1-180001), *Foundations
    of Quantum* *Computing*, we are now ready to begin solving problems with actual
    quantum algorithms. And that is exactly what we will do, starting in the next
    chapter. Let the quantum games begin — and may the shots be ever in your favor!*
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对Qiskit和PennyLane的工作原理的介绍，以及我们在*第* *[*1*](ch008.xhtml#x1-180001) *章* *[*1*]*中学习的所有数学概念，我们现在准备好开始使用实际的量子算法解决问题。这正是我们将在下一章中做的事情。量子游戏开始——愿你的量子游戏总是顺利！*
- en: '*# Summary'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*# 摘要'
- en: 'In this chapter, we have explored some of the frameworks and platforms that
    can enable us to implement, simulate, and run quantum algorithms. We have also
    learned how to work with two of these frameworks: Qiskit and PennyLane, which
    are very widely used. In addition to this, we have learned how to use the IBM
    Quantum platform to execute quantum circuits on real hardware, sending them from
    either Qiskit or PennyLane.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了一些可以让我们实现、模拟和运行量子算法的框架和平台。我们还学习了如何使用这些框架中的两个：Qiskit和PennyLane，它们被广泛使用。除此之外，我们还学习了如何使用IBM量子平台在真实硬件上执行量子电路，无论是从Qiskit还是PennyLane发送。
- en: With the skills that you have gained in this chapter, you are now able to implement
    and execute your own circuits. Moreover, you are now well-prepared to read the
    rest of the book, since we will be using Qiskit and PennyLane extensively.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你获得了技能，现在你可以实施并执行你自己的电路。此外，你已经为阅读本书的其余部分做好了充分的准备，因为我们将会大量使用Qiskit和PennyLane。
- en: In the next chapter, we will take our first steps in putting all this knowledge
    into practice. We shall dive into the world of quantum optimization!*****************
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将迈出第一步，将所有这些知识付诸实践。我们将深入量子优化的世界！*****************
