- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Controlling Motion with Encoders on Raspberry Pi Pico
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Raspberry Pi Pico上的编码器控制运动
- en: So far in this book, we’ve added sensors to our robot that can track counts
    as its wheels turn. We’ve also looked at a PID algorithm to close the robot control
    loop. We can combine these concepts to control our motors and wheels more precisely.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们已经为我们的机器人添加了传感器，可以跟踪车轮转动时的计数。我们还研究了PID算法来关闭机器人控制回路。我们可以将这些概念结合起来，更精确地控制我们的电机和车轮。
- en: This combination will let us maintain a known speed on each motor and correct
    their relative speeds for a straight line. Encoders with some geometry will let
    us drive the robot a predetermined distance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合将使我们能够在每个电机上保持已知速度，并校正它们的相对速度以保持直线。具有某些几何形状的编码器将使我们能够驱动机器人行驶预定的距离。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Converting an encoder count into a speed
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编码器计数转换为速度
- en: Using PID to maintain speed and a straight line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PID保持速度和直线
- en: Driving a known distance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动已知距离
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: The robot from [*Chapter 10*](B18001_10.xhtml#_idTextAnchor210), *Using the
    PID Algorithm to* *Follow Walls*
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人来自[*第10章*](B18001_10.xhtml#_idTextAnchor210)，*使用PID算法来* *跟随墙壁*
- en: The robot, encoder, and PID code from [*Chapter 10*](B18001_10.xhtml#_idTextAnchor210)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人、编码器和PID代码来自[*第10章*](B18001_10.xhtml#_idTextAnchor210)
- en: Around 2 square meters of floor to test the robot on
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约2平方米的地面来测试机器人
- en: Digital calipers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字卡尺
- en: A PC or laptop with Python 3
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台装有Python 3的PC或笔记本电脑
- en: An Android/iOS smartphone with Bluetooth LE
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一部带有蓝牙LE的Android/iOS智能手机
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-11](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-11).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-11](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-11)找到本章的代码。
- en: Converting an encoder count into a speed
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将编码器计数转换为速度
- en: In [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), *Measuring Movement with
    Encoders on Raspberry Pi Pico*, we used PIO to retrieve a count from the motor
    encoding sensors. We ended that chapter by measuring for movement and counting
    encoder transitions over some time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18001_06.xhtml#_idTextAnchor115)，*使用Raspberry Pi Pico上的编码器测量运动*中，我们使用了PIO从电机编码传感器中检索计数。我们在那一章结束时测量了运动并计数了编码器转换一段时间。
- en: In this section, we will relate wheel geometry to the encoder. Then, we will
    use that to convert encoder counts into a speed or a distance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将车轮几何形状与编码器联系起来。然后，我们将使用它将编码器计数转换为速度或距离。
- en: Loose bolts and nuts
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松动的螺栓和螺母
- en: Vibration can sometimes cause nuts to drop out – a tiny dab of nail varnish
    across the nut and thread can reduce this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 振动有时会导致螺母脱落——在螺母和螺纹上滴一点指甲油可以减少这种情况。
- en: Robot wheel geometry
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器人车轮几何形状
- en: 'Calculating the distance traveled by a wheel requires its circumference. Let’s
    start by measuring the diameter of the wheel, as shown:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 计算车轮行驶的距离需要其圆周。让我们先测量车轮的直径，如下所示：
- en: '![Figure 11.1 – Measuring wheels with calipers ](img/Figure_11.1_B18001.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 使用卡尺测量车轮](img/Figure_11.1_B18001.jpg)'
- en: Figure 11.1 – Measuring wheels with calipers
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 使用卡尺测量车轮
- en: 'The preceding diagram shows how you can measure wheel diameter with digital
    calipers. The diameter can be used in our code directly. In `robot.py`, add your
    measurement rounded to the nearest 0.1 mm:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图显示了如何使用数字卡尺测量车轮直径。直径可以直接用于我们的代码中。在`robot.py`中，添加你的测量值，四舍五入到最近的0.1毫米：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code calculates the circumference from the diameter. Each time
    a wheel makes a complete turn, it will move the wheel circumference in that direction,
    so we can already convert between wheel revolutions and distance. Next, we need
    the encoder details.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码根据直径计算圆周。每次车轮完成一次完整转动，它都会沿着该方向移动车轮的圆周，因此我们已可以将车轮的转数和距离进行转换。接下来，我们需要了解编码器的详细信息。
- en: Encoder geometry
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码器几何形状
- en: In [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115), *Measuring Movement with
    Encoders on Raspberry Pi Pico*, we found the number of poles on the encoder and
    the number of encoder revolutions per revolution. The N20 built-in magnetic encoders
    produce 28 edges or state changes for each encoder disk revolution. We then multiply
    this by the gear ratio 298:1.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B18001_06.xhtml#_idTextAnchor115)中，*在Raspberry Pi Pico上使用编码器测量运动*，我们找到了编码器的极数和每转编码器转数。N20内置磁性编码器为每个编码器盘转产生28个边缘或状态变化。然后我们乘以齿轮比298:1。
- en: 'We can add these calculations (use your motor gear ratio) to `robot.py`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些计算（使用你的电机齿轮比）添加到`robot.py`中：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use m and m/s since this puts distances and speeds in the same order as the
    motor speeds.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用m和m/s，因为这把距离和速度放在与电机速度相同的顺序中。
- en: Now, we can use these geometry measurements to get a speed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这些几何测量来获取速度。
- en: Measuring the speed of each wheel
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量每个轮子的速度
- en: 'We will calculate the speed of each wheel using the speed triangle from physics:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用物理中的速度三角形来计算每个轮子的速度：
- en: '![Figure 11.2 – The speed triangle ](img/Figure_11.2_B18001.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 速度三角形](img/Figure_11.2_B18001.jpg)'
- en: Figure 11.2 – The speed triangle
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 速度三角形
- en: 'The triangle in the preceding diagram shows distance over speed and time. We
    want speed, so we get distance over time by covering speed. We can also see m/s.
    In our code, we’ll need to convert the difference in encoder ticks into a distance
    in m, then divide that by the time the difference covers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图中的三角形显示了距离与速度和时间的关系。我们想要速度，所以我们通过覆盖速度来获取距离。我们还可以看到m/s。在我们的代码中，我们需要将编码器脉冲的差异转换为m的距离，然后除以这个差异覆盖的时间：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can use this calculation in an app to demonstrate the principle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用程序中使用这个计算来展示原理。
- en: Planning a speed-measurement app
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划一个速度测量应用程序
- en: We can build an app to demonstrate this and try different speeds. Using a UART
    command system will make it interactive.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个应用程序来展示这一点，并尝试不同的速度。使用UART命令系统将使其交互式。
- en: 'We’ll build the app using `asyncio` – asynchronous input/output. `asyncio`
    lets us run a few tasks simultaneously on the robot. Most tasks sleep between
    events, and CircuitPython can run another task during that time. The app must
    perform the following tasks:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`asyncio` – 异步输入/输出构建应用程序。`asyncio`允许我们在机器人上同时运行几个任务。大多数任务在事件之间休眠，而CircuitPython可以在那时运行另一个任务。应用程序必须执行以下任务：
- en: Measure the encoders, convert them into a speed value, and send this value to
    the UART.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量编码器，将它们转换为速度值，并将此值发送到UART。
- en: Accept the control commands to change settings or drive for a while.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受控制命令以更改设置或驱动一段时间。
- en: Stop the robot after a specific time.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定时间后停止机器人。
- en: 'The command handlers we’ll want for this robot are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为这个机器人使用的命令处理器如下：
- en: '`M0.7`: Set the motors speed to 0.7'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M0.7`: 将电机速度设置为0.7'
- en: '`T0.3`: Change the measuring time interval to 0.3'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T0.3`: 将测量时间间隔更改为0.3'
- en: '`G3.0`: Go (start moving) for 3 seconds, then stop'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G3.0`: 向前移动3秒，然后停止'
- en: '`G`: Stop the robot from moving immediately'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G`: 立即停止机器人移动'
- en: With the design created, let’s build the app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设计创建后，让我们构建应用程序。
- en: Speed measurement app
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度测量应用程序
- en: 'We will use the Adafruit `asyncio` library with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Adafruit `asyncio`库，以下为命令：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we’ll move the UART into the `robot.py` file. At the imports, add the
    following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将UART移动到`robot.py`文件中。在导入部分添加以下内容：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With that, the UART has been set up for any further examples. We will also
    add a convenience function at the end of `robot.py`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，UART已经为后续示例设置好了。我们还会在`robot.py`的末尾添加一个便利函数：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This wraps the usual interaction of adding a new line and encoding a message
    into bytes on the UART.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括了在UART上添加新行并将消息编码成字节的常规交互。
- en: 'In a new folder, `measuring_wheel_speeds`, make a new `code.py` file starting
    with the following imports:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的文件夹`measuring_wheel_speeds`中，创建一个新的`code.py`文件，从以下导入开始：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These imports are familiar; however, instead of `time`, we are importing `asyncio`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些导入是熟悉的；然而，我们不是导入`time`，而是导入`asyncio`。
- en: 'We can create a `Settings` class to store the current settings, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`Settings`类来存储当前设置，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This groups the settings; different tasks can access them. `speed` is the motor
    speed, and `time_interval` is how frequently the code will read the encoders.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这组成了设置；不同的任务可以访问它们。`speed`是电机速度，而`time_interval`是代码读取编码器的频率。
- en: 'Let’s learn how to handle the encoders:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何处理编码器：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use `async def` to turn the function into an async task. We are computing
    encoder differences, so we keep a last value. We start this with the current encoder
    reading.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `async def` 将函数转换为异步任务。我们在计算编码器差异时，保留最后一个值。我们从这个当前的编码器读取开始。
- en: 'Next, we go into the sensor reading loop, which uses `sleep` to keep that time
    interval:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入传感器读取循环，该循环使用 `sleep` 来保持该时间间隔：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code performs an asynchronous sleep, allowing other tasks to run. We must
    read both sensors again, getting new values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行异步睡眠，允许其他任务运行。我们必须再次读取两个传感器，获取新值：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We get the speed by subtracting the last value from the new one. Then, we convert
    that into meters and divide it by the time interval to get a speed in meters per
    second.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从新值中减去最后一个值来获取速度。然后，我们将这个值转换为米，并除以时间间隔，以获得每秒米数。
- en: 'We must also remember to update the last value. We can repeat this for the
    right sensor:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须记得更新最后一个值。我们可以为右侧传感器重复此操作：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can finish the motor speed loop by printing the speeds to the UART:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将速度打印到 UART 来完成电机速度循环：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice `,0` at the end of the UART output. We must add this to anchor the graph
    at 0 so that the plot shows the speed relative to zero.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 UART 输出末尾的 `,0`。我们必须添加这个来将图表锚定在 0，以便图表显示相对于零的速度。
- en: 'The next component we’ll need is the motor stop task:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要的组件是电机停止任务：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This task will simply wait the given seconds and stop the robot’s motors.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务将简单地等待给定的秒数并停止机器人的电机。
- en: 'We will also need a UART command handler in an async task:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在异步任务中一个 UART 命令处理器：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Sending `G3.0` instructs the robot to wait 5 seconds, drive, and stop after
    3 seconds. This 5-second wait allows the user to start the plot tab before the
    robot starts moving.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 发送 `G3.0` 指示机器人等待 5 秒，行驶 3 秒后停止。这 5 秒的等待允许用户在机器人开始移动之前启动图表标签页。
- en: The sleep commands now use `asyncio.sleep`. We also use `asyncio.sleep(0)` to
    let other tasks run while waiting for UART input.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的睡眠命令使用 `asyncio.sleep`。我们还使用 `asyncio.sleep(0)` 来让其他任务在等待 UART 输入时运行。
- en: 'Finally, we start the motor speed loop and the command handler, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动电机速度循环和命令处理器，如下所示：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Is this multithreaded?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否是多线程的？
- en: Async code is not multithreaded. Instead, when an `asyncio.sleep` is used, control
    is passed to another async block waiting to run. As a result, async code tasks
    do not access variables simultaneously.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码不是多线程的。相反，当使用 `asyncio.sleep` 时，控制权传递给另一个等待运行的异步块。因此，异步代码任务不会同时访问变量。
- en: Send this all to the robot. Now, let’s see how this works and test it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些发送到机器人。现在，让我们看看这是如何工作的，并进行测试。
- en: Testing the speed measurement app
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试速度测量应用程序
- en: I recommend propping the robot on a box for the first test so that its wheels
    aren’t in contact with anything.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在第一次测试时将机器人放在箱子上，这样它的轮子就不会接触任何东西。
- en: 'Connect to the robot with the Bluefruit LE Connect app and use the UART menu
    item. You should see zeros. Send `G20`, which should start the motors moving,
    and then press the back button and select the plot mode. You will see a graph
    like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bluefruit LE Connect 应用程序连接到机器人，并使用 UART 菜单项。你应该看到零。发送 `G20`，这将启动电机移动，然后按返回按钮并选择图表模式。你会看到一个像下面的图表：
- en: '![Figure 11.3 – Encoder speed with glitches ](img/Figure_11.3_B18001.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 带故障的编码器速度](img/Figure_11.3_B18001.jpg)'
- en: Figure 11.3 – Encoder speed with glitches
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 带故障的编码器速度
- en: The preceding plot shows speed versus time from our robot. The *y* axis is the
    speed, while the *x* axis is the time in seconds. There is a clear 0 line. The
    graph then shows the two motor speeds. There are glitches – the speed drops to
    zero and then doubles.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表显示了从我们的机器人中速度与时间的关系。*y* 轴是速度，而 *x* 轴是秒数。有一个清晰的 0 线。图表接着显示了两个电机的速度。存在一些故障
    - 速度降至零然后加倍。
- en: Fixing the encoder glitches
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复编码器故障
- en: These glitches are due to an interaction between our read loop and the encoders.
    Plotting on a UART makes 0.2 s (5 times per second) a good time base. However,
    our PIO outputs encoder counts as often as they change. The PIO outputs these
    counts to an RX FIFO queue – see [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115),
    *Measuring Movement with Encoders on Raspberry* *Pi Pico*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些故障是由于我们的读取循环和编码器之间的交互引起的。在 UART 上绘制图表使 0.2 秒（每秒 5 次）成为一个好的时间基准。然而，我们的 PIO
    以编码器变化的速度输出编码器计数。这些计数输出到 RX FIFO 队列 - 见 [*第 6 章*](B18001_06.xhtml#_idTextAnchor115)，*在
    Raspberry Pi Pico 上使用编码器测量运动*。
- en: 'The PIO `push nowait` instruction will write no more data when the FIFO queue
    is full, but the encoder code continues counting pulses. We can use another `asyncio`
    task to read data more frequently from the FIFO queue. In the imports at the top
    of `pio_encoder.py`, add the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 FIFO 队列满时，PIO `push nowait` 指令将不再写入更多数据，但编码器代码会继续计数脉冲。我们可以使用另一个 `asyncio`
    任务从 FIFO 队列中更频繁地读取数据。在 `pio_encoder.py` 顶部的导入中添加以下内容：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following method somewhere under `QuadratureEncoder`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `QuadratureEncoder` 下的某个位置添加以下方法：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once started, this will continuously read the data into the buffer as frequently
    as possible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，它将尽可能频繁地将数据读入缓冲区。
- en: 'Now, we must modify the `QuadratureEncoder.__init__` method to create a task
    for this. Add the highlighted line shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须修改 `QuadratureEncoder.__init__` 方法来创建一个任务。添加以下高亮显示的行：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `read` method can then return the most recent item from the buffer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 方法可以返回缓冲区中的最新项：'
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can now use this encoder code in our async code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的异步代码中使用这个编码器代码。
- en: 'Reupload the `pio_encoder.py` file so that we can try again. Start the motors
    with `G5` and switch to the plot screen; you should see a plot like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重新上传 `pio_encoder.py` 文件，以便我们可以再次尝试。用 `G5` 启动电机，切换到绘图屏幕；你应该看到这样的图表：
- en: '![Figure 11.4 – Speed measurement without the glitches ](img/Figure_11.4_B18001.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 无故障的速度测量](img/Figure_11.4_B18001.jpg)'
- en: Figure 11.4 – Speed measurement without the glitches
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 无故障的速度测量
- en: The graph now shows the speed of both motors without the glitches. It is a bit
    noisy, and one line is slightly higher than the other. One of the motors is also
    quicker. The robot is moving at around 0.2 m/s. Battery freshness will affect
    the speed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图表现在显示了两个电机无故障的速度。它有点嘈杂，一条线略高于另一条。其中一个电机也更快。机器人以大约 0.2 m/s 的速度移动。电池的新鲜度会影响速度。
- en: If you are not seeing this, please check that the encoders are reporting correctly
    with the examples provided in [*Chapter 6*](B18001_06.xhtml#_idTextAnchor115),
    *Measuring Movement with Encoders on Raspberry* *Pi Pico*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到这个，请检查编码器是否与提供的示例正确报告，例如在 [*第 6 章*](B18001_06.xhtml#_idTextAnchor115)
    中，*使用编码器在 Raspberry Pi Pico 上测量运动*。
- en: We can use this measurement to drive a known distance, but it’s now clear that
    the robot won’t drive in a straight line like this. So, in the next section, we’ll
    correct the differences between the motors.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个测量值来驱动已知距离，但现在很明显，机器人不会像这样直线行驶。因此，在下一节中，我们将纠正电机之间的差异。
- en: Using PID to maintain speed and a straight line
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PID 来维持速度和直线行驶
- en: In this section, we’ll learn how to combine the motor distance measurement with
    a PID controller driving each motor, moving at a particular speed, and keeping
    the robot straight. Let’s start by understanding this system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将电机距离测量与每个电机的 PID 控制器结合起来，以特定速度移动，并保持机器人直线行驶。让我们首先理解这个系统。
- en: The speed control system
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速度控制系统
- en: We can set a target speed in meters per second for the robot and compare the
    converted wheel speeds with it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为机器人设置每秒米的目标速度，并将其与转换后的轮速进行比较。
- en: 'The following diagram shows how we’ll use this to regulate the robot’s driving
    speed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了我们将如何调节机器人的驾驶速度：
- en: '![Figure 11.5 – Controlling the speed of two motors ](img/Figure_11.5_B18001.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 控制两个电机的速度](img/Figure_11.5_B18001.jpg)'
- en: Figure 11.5 – Controlling the speed of two motors
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 控制两个电机的速度
- en: The preceding diagram shows the control system. It starts at the left from a
    set speed and compares that with the actual speed. The actual speed comes from
    the encoders, with their ticks converted into m/s. The error is the difference
    between the speeds.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了控制系统。它从左侧开始，从一个设定速度开始，并将其与实际速度进行比较。实际速度来自编码器，它们的脉冲被转换为 m/s。误差是速度之间的差异。
- en: The error goes into the PID controller, which then produces an acceleration
    for the motor PWM. The motor power will increase for a positive control signal
    or decrease for a negative one. This control system repeats for each wheel.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 误差进入 PID 控制器，然后为电机 PWM 产生加速度。对于正的控制信号，电机功率会增加，对于负的控制信号，电机功率会减少。这个控制系统为每个轮子重复进行。
- en: 'We are building on the motor start/stop with the timer control we used previously.
    However, with a PID controller, this can cause the integral to wind up and accumulate
    errors. Let’s extend the `PIDController` class in `pid_controller.py` so that
    we can reset this. Make the highlighted change:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建在之前使用的定时器控制的基础上电机启动/停止。然而，使用 PID 控制器，这可能会导致积分积累错误。让我们扩展 `PIDController`
    类在 `pid_controller.py` 中，以便我们可以重置它。进行以下高亮显示的更改：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ve moved the initial value settings out to a `reset` method, which we now
    use in the `__init__` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将初始值设置移到了一个 `reset` 方法中，我们现在在 `__init__` 方法中使用它。
- en: Now that we understand this concept, we can build the code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了这个概念，我们可以构建代码。
- en: Speed control code
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速度控制代码
- en: 'Let’s build our speed controller code. In a new folder, `speed_control`, add
    a new `code.py` file. We will start with the regular imports:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的速度控制器代码。在一个新的文件夹 `speed_control` 中，添加一个新的 `code.py` 文件。我们将从常规导入开始：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’ll add settings that we can adjust to control the system when the program
    is running:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些设置，我们可以在程序运行时调整以控制系统：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have a `speed` in m/s. This should be close to the speed you measured previously.
    We also added a `time_interval` for the loop and specified if the motors should
    currently be driving.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `speed` 以 m/s 为单位。这应该接近你之前测量的速度。我们还为循环添加了一个 `time_interval` 并指定了电机是否应该当前驱动。
- en: 'Next, we must add a `SpeedController` class, which we can use for each wheel
    system:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加一个 `SpeedController` 类，我们可以用它来为每个轮子系统使用：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We provide each `SpeedController` system with an encoder to read and a motor
    function (`motor_fn`) to apply control signals. The `SpeedController` creates
    a `PIDController`. Each wheel will get an independent `PIDController`. This then
    calls a `reset` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个 `SpeedController` 系统提供一个编码器来读取和一个应用控制信号的电机函数 (`motor_fn`)。`SpeedController`
    创建一个 `PIDController`。每个轮子将得到一个独立的 `PIDController`。然后它调用一个 `reset` 函数：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code puts the first read of the encoder into `last_ticks`, which we’ll
    update when we get a reading. `pwm` is how much power we will give the motors.
    We track `actual_speed` so that we can print this value to the UART later. We
    also reset the PIDs so that any stored integral is gone.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将第一次读取的编码器值放入 `last_ticks`，我们将在获取读数时更新它。`pwm` 是我们将给予电机的功率。我们跟踪 `actual_speed`
    以便稍后可以将此值打印到 UART。我们还重置了 PID，以便任何存储的积分都会消失。
- en: 'Now, we need a method to update this control system:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个方法来更新这个控制系统：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This `update` method takes a delta time in seconds. While this might be close
    to `time_interval`, we need to be accurate when calculating the speed or updating
    the PID.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `update` 方法接受一个以秒为单位的 delta time。虽然这可能与 `time_interval` 很接近，但在计算速度或更新 PID
    时我们需要准确。
- en: The method reads the current encoder value and subtracts the previous encoder
    reading to get a distance in encoder ticks. To turn this into a speed, we must
    divide this by time. We must update `self.last_ticks` here for the next cycle.
    The speed is more useful to us in m/s, so we convert it using `ticks_to_m`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法读取当前的编码器值，并从之前的编码器读数中减去以得到编码器脉冲的距离。为了将这个距离转换为速度，我们必须除以时间。在这里我们必须更新 `self.last_ticks`
    以便下一次循环。速度对我们来说更有用，以 m/s 为单位，所以我们使用 `ticks_to_m` 进行转换。
- en: 'We can now use this to update the PID and control the motors:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个来更新 PID 并控制电机：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We multiply the `pwm` output setting with the `enabled` flag so that the motors
    will stop if the motors are disabled. We subtract the actual speed from this to
    get the `error` value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `pwm` 输出设置与 `enabled` 标志相乘，这样如果电机被禁用，电机将会停止。我们从实际速度中减去这部分以得到 `error` 值。
- en: The code gets `control_signal` from the PID calculation with `error` and delta
    time. We then use this to accelerate/decelerate `pwm`, which goes into the motor
    function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从 PID 计算中获取 `control_signal`，其中包含 `error` 和时间差。然后我们使用这个信号来加速/减速 `pwm`，这将被输入到电机函数中。
- en: 'We use this system to control both motors:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个系统来控制两个电机：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we need an async loop to drive the system:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个异步循环来驱动系统：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So far, this loop will sleep every interval and update the time, so we have
    an accurate delta time (`dt`) value. We can use this to update both sides:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个循环会在每个间隔中休眠并更新时间，因此我们有一个准确的 delta time (`dt`) 值。我们可以使用这个值来更新两边：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After updating both sides, we can send the expected speed versus the actual
    speed to be plotted via UART.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 更新完两边后，我们可以通过 UART 发送预期的速度与实际速度进行比较。
- en: 'Next, we’ll add a modified `stop_motors_after` async function that updates
    the `motors_enabled` flag; it will not call the `stop` function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个修改后的 `stop_motors_after` 异步函数来更新 `motors_enabled` 标志；它将不会调用 `stop`
    函数：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We want to be able to interact with this. We’ll need the `command_handler`
    function from the speed measuring app with the highlighted differences:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够与之交互。我们需要从速度测量应用程序中获取`command_handler`函数，并注意以下差异：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we send a `G<n>` command to start the robot moving, we reset left and right,
    resetting both the previous encoder value and PID integrals. Otherwise, we may
    have an old encoder setting, and the integral may still hold a value from a previous
    movement.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送`G<n>`命令使机器人移动时，我们会重置左右，重置先前的编码器值和PID积分。否则，我们可能有一个旧的编码器设置，积分可能仍然保留先前的移动值。
- en: 'All that is left is to start this all up:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是启动这一切：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This has been wrapped in an additional `try`/`finally` block that ensures the
    movement task is stopped and the robot is stopped if an error occurs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这被包裹在一个额外的`try`/`finally`块中，确保在发生错误时停止移动任务和机器人。
- en: This code is complete. Send it to the robot along with `robot.py`, `pid_controller.py`,
    and `pio_encoder.py`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码已经完成。将其与`robot.py`、`pid_controller.py`和`pio_encoder.py`一起发送到机器人。
- en: Ensure the motors are powered on and use the Bluefruit Connect app to send the
    `G10` sequence so that the robot starts moving. I propped the robot up so that
    its wheels could turn without moving it to initially test this code. This test
    also lets me keep it connected via USB to see any code errors.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 确保电机已开启，并使用Bluefruit Connect应用程序发送`G10`序列，以便机器人开始移动。我支撑起机器人，使其轮子可以转动而不移动它，以最初测试这段代码。这个测试还让我可以通过USB保持连接，以查看任何代码错误。
- en: Speed controller PID tuning
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速度控制器PID调整
- en: 'The PID values are likely to need tuning here. The values that worked in my
    experiments were `P`: 3, `I`: 0, and `D`:1\. The `P` factor will continue accelerating
    so long as there’s a difference, with the `D` value damping any sudden changes.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'PID值可能需要调整。在我的实验中，工作值是`P`: 3, `I`: 0, 和 `D`:1。只要存在差异，`P`因子就会继续加速，而`D`值会抑制任何突然的变化。'
- en: 'I was able to start with a low `P` value and, using the plot, adjust upward
    if the overshoot wasn’t too great. The following plots show how this system responds:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以从一个较低的`P`值开始，并使用图表调整向上，如果超调不是太严重。以下图表显示了该系统的响应：
- en: '![Figure 11.6 – Speed controller response plots ](img/Figure_11.6_B18001.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 速度控制器响应图](img/Figure_11.6_B18001.jpg)'
- en: Figure 11.6 – Speed controller response plots
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 速度控制器响应图
- en: The preceding graphs show the speed controller system. There are two plots –
    one with the robot propped up so that its wheels have no load and another with
    the robot on the floor. The orange line shows the set point, which is raised to
    0.15 m/s by the code. The blue line is the actual speed measured at one of the
    motors. The system is better tuned for running on a floor.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了速度控制器系统。有两个图表——一个是在机器人支撑起来，使其轮子没有负载的情况下，另一个是在机器人放在地板上的情况下。橙色线表示设定点，代码将其提高到0.15
    m/s。蓝色线是在一个电机上测量的实际速度。系统在地板上运行时调校得更好。
- en: Increase the `D` term to damp the overshoot. Since we are controlling the acceleration
    of this system, a sustained value is not required for it to keep moving, so the
    `I` term can remain at 0.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 增加微分项`D`以抑制超调。由于我们正在控制该系统的加速度，不需要持续值来保持其移动，因此积分项`I`可以保持在0。
- en: There may be other troubleshooting issues around motor and encoder connections
    that you can resolve by going back to the previous examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一些关于电机和编码器连接的故障排除问题，你可以通过回到前面的示例来解决。
- en: Now, you can control the speeds of two motors simultaneously and get a straight
    line while practicing PID tuning. We can now build on this to drive in a straight
    line for a known distance and an expected speed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在练习PID调整时同时控制两个电机的速度，并获得一条直线。我们现在可以在此基础上驱动一段已知距离和预期速度的直线。
- en: Driving a known distance
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驾驶已知距离
- en: We’ll need to bring together some of the previous techniques for this. Then,
    we’ll build a variation of the speed controller – a distance controller – so that
    we can update the distance and let the motor PIDs reach it. This app will use
    a similar structure, including control and asynchronous tasks, as in the previous
    example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要结合一些之前的技术来完成这个任务。然后，我们将构建速度控制器的一个变体——距离控制器，这样我们就可以更新距离，并让电机PID达到它。这个应用程序将使用与上一个示例类似的架构，包括控制和异步任务。
- en: Theory of operation
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作原理
- en: 'The following diagram shows the theory of operation for this behavior:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了该行为的操作原理：
- en: '![Figure 11.7 – Controlling distance and speed ](img/Figure_11.7_B18001.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 控制距离和速度](img/Figure_11.7_B18001.jpg)'
- en: Figure 11.7 – Controlling distance and speed
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 控制距离和速度
- en: The preceding diagram shows an overview of this system. The distance tracker
    tracks distance over time at a given speed, and the distance controller directly
    controls the motors to try and match a distance. Note the feedback from the motor
    into the distance controller. We will have one of these per motor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表示出了这个系统的概览。距离跟踪器在给定的速度下跟踪距离随时间的变化，距离控制器直接控制电机以尝试匹配距离。注意电机反馈到距离控制器。我们将为每个电机有一个这样的组件。
- en: 'Let’s take a closer look at the distance tracker:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看距离跟踪器：
- en: '![Figure 11.8 – The distance tracker ](img/Figure_11.8_B18001.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 距离跟踪器](img/Figure_11.8_B18001.jpg)'
- en: Figure 11.8 – The distance tracker
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 距离跟踪器
- en: The left-hand side of the preceding diagram repeats the speed, time, and distance
    triangle. We have the distance and the speed; to get the time, we need to divide
    the distance by speed. The right-hand side shows this distance tracker system.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图表的左侧重复了速度、时间和距离三角形。我们有距离和速度；要得到时间，我们需要将距离除以速度。右侧显示了这个距离跟踪系统。
- en: The tracker system must first convert the distance into `total_time` using distance
    over speed. We must also convert the distance in meters into `total_distance_in_ticks`.
    These two values will remain constant until we set a new speed or distance. This
    lighter portion only needs to run when we update the speed or reset the distance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪系统必须首先使用距离除以速度将距离转换为`total_time`。我们还必须将米单位的距离转换为`total_distance_in_ticks`。这两个值将在我们设置新的速度或距离之前保持不变。这个较轻的部分只有在更新速度或重置距离时才需要运行。
- en: If we wish to run the system many times, we need to keep track of the current
    position so that we aren’t counting from a position of 0 each time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望多次运行系统，我们需要跟踪当前位置，这样我们每次就不会从0的位置开始计数。
- en: When the system runs, the gray portion will run in a loop, and it will be updating
    the `elapsed_time` since the system was last reset. Dividing `elapsed_time` by
    `total_time` gives us a proportion of `time_proportion`, which will sweep between
    0.0 and 1.0\. We multiply this by `total_distance_in_ticks` to get `expected_distance_in_ticks`,
    tracking the distance the robot should have moved in ticks at any time. Since
    this component is tracking time, it will also pass along a delta time (`dt`) to
    the next component.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统运行时，灰色部分将循环运行，并更新自系统上次重置以来的`elapsed_time`。将`elapsed_time`除以`total_time`得到`time_proportion`的比例，这个比例将在0.0和1.0之间变化。我们将其乘以`total_distance_in_ticks`以得到`expected_distance_in_ticks`，跟踪机器人在任何时间应该移动的刻度数。由于这个组件正在跟踪时间，它还将传递一个时间增量(`dt`)给下一个组件。
- en: 'The next component is the distance controller. Let’s take a closer look at
    this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件是距离控制器。让我们更仔细地看看这个：
- en: '![Figure 11.9 – The distance controller ](img/Figure_11.9_B18001.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 距离控制器](img/Figure_11.9_B18001.jpg)'
- en: Figure 11.9 – The distance controller
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 距离控制器
- en: The preceding diagram shows the update method of a `DistanceController` class.
    `control_signal` directly drives the motor. The `update` method has two inputs
    –`dt` and the `expected` distance in ticks. We subtract the `actual` distance
    in encoder ticks from the `expected` distance to get the `error` value, which
    is used with `dt` to update the `PID`. The output should result in a wheel/motor
    turning faster if it is behind the expected number of ticks or slower if it’s
    ahead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表示出了`DistanceController`类的更新方法。`control_signal`直接驱动电机。`update`方法有两个输入 –
    `dt`和预期的刻度距离。我们从编码器刻度的实际距离中减去预期的距离以得到`error`值，该值与`dt`一起用于更新`PID`。输出应该导致如果它落后于预期的刻度数，轮子/电机转速加快；如果它领先，转速减慢。
- en: We will also use the same graphing and control routines as before, but we will
    alter the `G` control handler to specify a distance in meters instead of time
    in seconds – so, `G0.5` would signal the robot to drive half a meter at the current
    speed, then stop.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与之前相同的绘图和控制程序，但我们将修改`G`控制处理程序，以指定米单位的距离而不是秒单位的时间 – 因此，`G0.5`将指示机器人以当前速度行驶半米，然后停止。
- en: Now, we have enough information to update the code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了足够的信息来更新代码。
- en: Code to control distance and speed
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制距离和速度的代码
- en: Let’s start with a copy of the previous example code. We will update the specific
    changed routines.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一例代码的副本开始。我们将更新具体的更改程序。
- en: 'First, we need to add another number to `robot.py`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`robot.py`中添加另一个数字：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This lets us convert differently so that we can get `m` from ticks. Let’s create
    the new `code.py` file with the familiar imports:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们能够以不同的方式转换，以便我们可以从脉冲中得到`m`。让我们创建一个新的`code.py`文件，使用熟悉的导入：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s add the `DistanceController` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加`DistanceController`类：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we initialized the `PID` controller and renamed `last_ticks` to `start_ticks`
    – the ticks the encoder is at when we start this behavior. We kept `error` so
    that we can plot it. The code sets `filter_gain` for the derivative to `1` so
    that the derivative is not too slow in catching up.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了`PID`控制器，并将`last_ticks`重命名为`start_ticks`——编码器在我们开始这个行为时的脉冲数。我们保留了`error`，这样我们就可以绘制它。代码将导数滤波器增益设置为`1`，这样导数就不会太慢地赶上。
- en: 'Next, we need an `update` method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个`update`方法：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we have an additional `expected` parameter (in ticks). We get an `actual`
    (in moved ticks) by subtracting `start_ticks` from the current encoder reading.
    We store it as `self.actual` so that we can graph this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个额外的`expected`参数（以脉冲为单位）。我们通过从当前编码器的读数中减去`start_ticks`来得到一个`actual`值（以移动的脉冲为单位）。我们将其存储为`self.actual`，这样我们就可以绘制这个值。
- en: '`error` is far simpler; subtracting `expected` from `actual` gives us the number
    of encoder ticks we are short or ahead of. However, to scale it down, we must
    divide by ticks per revolution. This goes into the PID calculation, along with
    `dt`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`要简单得多；通过从`expected`中减去`actual`，我们得到我们短缺或超出编码器脉冲的数量。然而，为了缩小这个比例，我们必须除以每转脉冲数。这会进入PID计算，以及`dt`。'
- en: We use the output of the PID to control the motor.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用PID的输出来控制电机。
- en: 'We’ve completed the `DistanceController` code. Next, we need to create the
    `DistanceTracker` class. We start by storing the controller’s settings:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`DistanceController`代码。接下来，我们需要创建`DistanceTracker`类。我们首先存储控制器的设置：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After setting the `speed` and `time_interval` fields, we store a `start_time`
    to count the time elapsed. We also set up initial values for `current_position`,
    `total_distance_in_ticks`, and `total_time`. Note that `total_time` must not be
    zero as we use it in the division.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`speed`和`time_interval`字段后，我们存储一个`start_time`来计算经过的时间。我们还为`current_position`、`total_distance_in_ticks`和`total_time`设置了初始值。注意，`total_time`不能为零，因为我们会在除法中使用它。
- en: 'We will need to set these values when we update the distance:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新距离时，我们需要设置这些值：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first thing we must do is add any previous movement to `current_position`.
    This means we keep track of the expected position so that the system doesn’t accumulate
    too many errors.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是将任何之前的移动添加到`current_position`。这意味着我们跟踪预期的位置，以便系统不会积累过多的错误。
- en: Then, we must calculate a total distance, converting from meters into ticks
    into `total_distance_in_ticks`. The code calculates the total time by dividing
    `new_distance` by `speed`. However, since going backward would be a negative speed,
    we use the `abs` function to get only a positive time. Also, to avoid that division
    by zero, we clamp this value to be above 0.1 seconds.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须计算总距离，将米转换为脉冲，转换为`total_distance_in_ticks`。代码通过将`new_distance`除以`speed`来计算总时间。然而，由于向后移动会是负速度，我们使用`abs`函数来只得到正值。此外，为了避免除以零，我们将这个值限制在0.1秒以上。
- en: Finally, this resets to a new `start_time`, from which `total_time` will be
    relative.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这会重置到一个新的`start_time`，从这`total_time`将是相对的。
- en: 'Now, we can build the `DistanceTracker` loop:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建`DistanceTracker`循环：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This code creates two `DistanceController` instances and stores a `last_time`
    value for `dt` calculations. The next part of the code is all about time:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了两个`DistanceController`实例，并存储了一个用于`dt`计算的`last_time`值。代码的下一部分全部关于时间：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, we sleep for `time_interval`, then get `current_time`. From this, we
    can calculate `dt` and `elapsed_time`. We calculate a `time_proportion` between
    0 and 1 by dividing `current_time` by `total_time`. This `time_proportion` lets
    us track where we are in the current motion. Note that we clamp this to a limit
    of 1 so that the time ratio doesn’t multiply to a value larger than the intended
    distance.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们睡眠`time_interval`时间，然后获取`current_time`。从这，我们可以计算出`dt`和`elapsed_time`。我们通过将`current_time`除以`total_time`来计算一个介于0和1之间的`time_proportion`。这个`time_proportion`让我们能够跟踪当前运动中的位置。注意，我们将这个值限制在1以内，以防止时间比率乘以一个比预期距离更大的值。
- en: 'Then, we can multiply `time_proportion` by `total_distance_in_ticks` to get
    the relative tick position for the robot. As this is a relatively expected position,
    we add `current_position` again. The `expected` value is an absolute position
    from when we start the code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`time_proportion`乘以`total_distance_in_ticks`以获得机器人的相对刻度位置。由于这是一个相对预期的位置，我们再次添加`current_position`。`expected`值是从我们开始代码时的绝对位置：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, we must update the two `DistanceController` instances and write data to
    the UART to be plotted.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须更新两个`DistanceController`实例并将数据写入UART进行绘图。
- en: 'We can start this part of the system by creating an instance of `DistanceTracker`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建`DistanceTracker`的一个实例来启动这个系统的一部分：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can complete this behavior by creating a UART command handler:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个UART命令处理程序来完成这个行为：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `G<number>` command now updates a distance instead of time; stopping the
    robot sets a new distance of zero.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`G<number>`命令现在更新距离而不是时间；停止机器人将设置新的零距离。'
- en: 'All that remains is to start the async tasks and handle errors:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是启动异步任务并处理错误：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We now have code that tracks a distance at a given speed; however, you will
    likely need to tune the PID. `DistanceController` needs to provide enough `control_signal`
    to keep up with a changing `expected` position. There will be a non-zero `error`
    value in the `update` method if it’s not completed the motion. This PID system
    will be dominantly proportional so that the motors keep up with the expected position.
    The tips at [https://pidexplained.com/how-to-tune-a-pid-controller/](https://pidexplained.com/how-to-tune-a-pid-controller/)
    help with this tuning.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了跟踪给定速度下距离的代码；然而，你可能会需要调整PID。`DistanceController`需要提供足够的`control_signal`以跟上不断变化的`expected`位置。如果未完成动作，`update`方法中将有非零的`error`值。这个PID系统将主要呈比例，以便电机跟上预期的位置。[https://pidexplained.com/how-to-tune-a-pid-controller/](https://pidexplained.com/how-to-tune-a-pid-controller/)上的提示有助于调整。
- en: Note that if you change the motors, the floor type, or the time base, you may
    need to tune this system again.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您更改了电机、地板类型或时间基准，可能需要再次调整此系统。
- en: You should now have a tuned system to drive a specific distance at a specific
    speed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有一个调整好的系统，可以在特定速度下驱动特定距离。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to use the encoder more usefully. You looked
    at how to use wheel geometry to convert encoder pulses into metric measurements
    and then used these measurements to measure speed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何更有效地使用编码器。你了解了如何使用轮子几何形状将编码器脉冲转换为公制测量，然后使用这些测量来测量速度。
- en: Once we can measure speed, we can use a PID to control the speed of each wheel
    and see significantly less veering.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们可以测量速度，我们就可以使用PID来控制每个轮子的速度，并看到显著减少的偏航。
- en: We could then take this to the next level and drive a specific distance at a
    specific speed, providing fully controlled motion.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个概念提升到下一个层次，在特定速度下驱动特定距离，提供完全受控的运动。
- en: In the next chapter, we will connect an IMU to our robot so that we can measure
    a compass heading and control the robot’s direction.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把IMU连接到我们的机器人上，这样我们就可以测量罗盘航向并控制机器人的方向。
- en: Exercises
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'These exercises will deepen your understanding of the topics covered in this
    chapter and make the robot’s code better:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习将加深你对本章所涵盖主题的理解，并使机器人的代码更加完善：
- en: All the preceding examples could benefit from the PID modification and printing
    menu in the UART command handler – consider adding it to them.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的前述示例都可以从PID修改和UART命令处理器的打印菜单中受益——考虑将其添加到它们中。
- en: In the distance control, we set the derivative filter gain to 1, disabling it.
    How does this system behave with other filter gain values?
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在距离控制中，我们将导数滤波器增益设置为1，禁用它。这个系统在其他滤波器增益值下表现如何？
- en: Instead of starting motions with the phone app, could you chain some of these
    movements together? Or even alter the phone G instruction to make a few motions
    with a single command sequence?
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同于用手机应用启动动作，您能否将这些动作链在一起？或者甚至修改手机的G指令，通过单个命令序列完成几个动作？
- en: Further reading
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These further study aids will help you learn more and dive deeper into using
    encoders to control robot motion:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这些进一步的学习辅助工具将帮助你学习更多，并更深入地了解使用编码器控制机器人运动：
- en: In *Learn Robotics Programming Second Edition*, [*Chapter 11*](B18001_11.xhtml#_idTextAnchor233)*,
    Programming Encoders with Python*, I used simpler encoders but dove into the calculations
    needed to make specific turns with encoders that could be adapted to the Pico.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《学习机器人编程 第二版》的 [*第 11 章*](B18001_11.xhtml#_idTextAnchor233)“使用 Python 编程编码器”中，我使用了更简单的编码器，但深入研究了使用可适应
    Pico 的编码器进行特定转向所需的计算。
- en: The Arduino-based tutorial at [https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller](https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller)
    shows how to use a PID controller.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller](https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller)
    的基于 Arduino 的教程中，展示了如何使用 PID 控制器。
- en: This Python file at [https://github.com/pimoroni/pimoroni-pico/blob/main/micropython/examples/inventor2040w/motors/position_control.py](https://github.com/pimoroni/pimoroni-pico/blob/main/micropython/examples/inventor2040w/motors/position_control.py)
    from Pimoroni shows a similar Python approach in MicroPython for the Pico.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 Pimoroni 的这个 Python 文件位于 [https://github.com/pimoroni/pimoroni-pico/blob/main/micropython/examples/inventor2040w/motors/position_control.py](https://github.com/pimoroni/pimoroni-pico/blob/main/micropython/examples/inventor2040w/motors/position_control.py)，展示了在
    MicroPython 中针对 Pico 的类似 Python 方法。
