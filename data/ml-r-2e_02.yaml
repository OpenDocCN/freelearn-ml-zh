- en: Chapter 2. Managing and Understanding Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。管理和理解数据
- en: A key early component of any machine learning project involves managing and
    understanding data. Although this may not be as gratifying as building and deploying
    models—the stages in which you begin to see the fruits of your labor—it is unwise
    to ignore this important preparatory work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何机器学习项目的关键早期组成部分涉及管理和理解数据。虽然这可能不像构建和部署模型那样令人满足——在这些阶段中，您开始看到劳动成果的时候，但忽视这项重要的准备工作是不明智的。
- en: Any learning algorithm is only as good as its input data, and in many cases,
    the input data is complex, messy, and spread across multiple sources and formats.
    Because of this complexity, often the largest portion of effort invested in machine
    learning projects is spent on data preparation and exploration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何学习算法的好坏取决于其输入数据，在许多情况下，输入数据是复杂的、混乱的，并且分布在多个来源和格式中。由于这种复杂性，机器学习项目中投入的大部分精力通常用于数据准备和探索。
- en: This chapter approaches these topics in three ways. The first section discusses
    the basic data structures R uses to store data. You will become very familiar
    with these structures as you create and manipulate datasets. The second section
    is practical, as it covers several functions that are useful to get data in and
    out of R. In the third section, methods for understanding data are illustrated
    while exploring a real-world dataset.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过三种方式探讨这些主题。第一部分讨论了R用于存储数据的基本数据结构。在创建和操作数据集时，您将对这些结构非常熟悉。第二部分是实用的，因为它涵盖了几个有助于将数据输入和输出R的函数。在第三部分中，通过探索一个真实世界的数据集来说明理解数据的方法。
- en: 'By the end of this chapter, you will understand:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的结尾，您将理解：
- en: How to use R's basic data structures to store and extract data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用R的基本数据结构存储和提取数据
- en: Simple functions to get data into R from common source formats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从常见来源格式将数据导入R的简单函数
- en: Typical methods to understand and visualize complex data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和可视化复杂数据的典型方法
- en: Since the way R thinks about data will define the way you work with data, it
    is helpful to know R's data structures before jumping directly into data preparation.
    However, if you are already familiar with R programming, feel free to skip ahead
    to the section on data preprocessing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于R如何思考数据将定义您处理数据的方式，在直接进行数据准备之前了解R的数据结构是有帮助的。但是，如果您已经熟悉R编程，请随时跳到数据预处理部分。
- en: R data structures
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R数据结构
- en: There are numerous types of data structures across programming languages, each
    with strengths and weaknesses suited to particular tasks. Since R is a programming
    language used widely for statistical data analysis, the data structures it utilizes
    were designed with this type of work in mind.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 各种编程语言都有各种类型的数据结构，每种都有其特定任务的优缺点。由于R语言广泛用于统计数据分析，它使用的数据结构是为了这种类型的工作而设计的。
- en: The R data structures used most frequently in machine learning are vectors,
    factors, lists, arrays and matrices, and data frames. Each is tailored to a specific
    data management task, which makes it important to understand how they will interact
    in your R project. In the sections that follow, we will review their similarities
    and differences.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中最常用的R数据结构包括向量、因子、列表、数组和矩阵以及数据框。每种都针对特定的数据管理任务，这使得了解它们在你的R项目中如何互动非常重要。接下来的章节中，我们将回顾它们的相似性和差异。
- en: Vectors
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: The fundamental R data structure is the **vector**, which stores an ordered
    set of values called **elements**. A vector can contain any number of elements,
    but all of the elements must be of the same **type** of values. For instance,
    a vector cannot contain both numbers and text. To determine the type of vector
    `v`, use the `typeof(v)` command.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的R数据结构是**向量**，它存储称为**元素**的有序值集。向量可以包含任意数量的元素，但所有元素必须属于相同类型的值。例如，向量不能同时包含数字和文本。要确定向量`v`的类型，请使用`typeof(v)`命令。
- en: 'Several vector types are commonly used in machine learning: `integer` (numbers
    without decimals), `double` (numbers with decimals), `character` (text data),
    and `logical` (`TRUE` or `FALSE` values). There are also two special values: `NULL`,
    which is used to indicate the absence of any value, and `NA`, which indicates
    a missing value.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中常用几种向量类型：`integer`（无小数点的数字）、`double`（带有小数点的数字）、`character`（文本数据）和`logical`（`TRUE`或`FALSE`值）。还有两个特殊值：`NULL`，用于表示没有任何值，以及`NA`，表示缺失值。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some R functions will report both `integer` and `double` vectors as `numeric`,
    while others will distinguish between the two. As a result, although all `double`
    vectors are `numeric`, not all `numeric` vectors are `double` type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 R 函数会将 `integer` 和 `double` 向量都报告为 `numeric`，而其他函数则会区分这两者。因此，尽管所有 `double`
    向量都是 `numeric`，但并非所有 `numeric` 向量都是 `double` 类型。
- en: It is tedious to enter large amounts of data manually, but small vectors can
    be created by using the `c()` combine function. The vector can also be given a
    name using the `<-` arrow operator, which is R's way of assigning values, much
    like the `=` assignment operator is used in many other programming languages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 手动输入大量数据是很繁琐的，但可以使用 `c()` 合并函数创建小型向量。还可以使用 `<-` 箭头运算符为向量命名，这是 R 赋值的方式，类似于许多其他编程语言中使用的
    `=` 赋值运算符。
- en: 'For example, let''s construct several vectors to store the diagnostic data
    of three medical patients. We''ll create a `character` vector named `subject_name`
    to store the three patient names, a `double` vector named `temperature` to store
    each patient''s body temperature, and a logical vector named `flu_status` to store
    each patient''s diagnosis (`TRUE` if he or she has influenza, `FALSE` otherwise).
    Let''s have a look at the following code to create these three vectors:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们构建几个向量来存储三位病人的诊断数据。我们将创建一个名为 `subject_name` 的 `character` 向量来存储三位病人的姓名，一个名为
    `temperature` 的 `double` 向量来存储每位病人的体温，以及一个名为 `flu_status` 的逻辑向量来存储每位病人的诊断（如果患有流感则为
    `TRUE`，否则为 `FALSE`）。让我们看一下下面的代码来创建这三个向量：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because R vectors are inherently ordered, the records can be accessed by counting
    the item''s number in the set, beginning at one, and surrounding this number with
    square brackets (that is, `[` and `]`) after the name of the vector. For instance,
    to obtain the body temperature for patient Jane Doe (the second element in the
    `temperature` vector) simply type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 R 向量天生是有序的，可以通过计算集合中项目的编号来访问记录，从一开始，并在向量名称后用方括号（即 `[` 和 `]`）括住这个编号。例如，要获取病人
    Jane Doe 的体温（即 `temperature` 向量中的第二个元素），只需输入：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'R offers a variety of convenient methods to extract data from vectors. A range
    of values can be obtained using the (`:`) colon operator. For instance, to obtain
    the body temperature of Jane Doe and Steve Graves, type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: R 提供了多种方便的方法来从向量中提取数据。可以使用 (`:`) 冒号运算符获取一系列的值。例如，要获取 Jane Doe 和 Steve Graves
    的体温，输入：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Items can be excluded by specifying a negative item number. To exclude Jane
    Doe''s `temperature` data, type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定负的项目编号来排除项目。要排除 Jane Doe 的 `temperature` 数据，输入：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, it is also sometimes useful to specify a logical vector indicating
    whether each item should be included. For example, to include the first two `temperature`
    readings but exclude the third, type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时指定一个逻辑向量也很有用，用于指示每个项目是否应被包括。例如，要包括前两个 `temperature` 读数，但排除第三个，输入：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you will see shortly, the vector provides the foundation for many other R
    data structures. Therefore, the knowledge of the various vector operations is
    crucial to work with data in R.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将很快看到的，向量为许多其他 R 数据结构提供了基础。因此，了解各种向量操作对于在 R 中处理数据至关重要。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你的账户中下载所有已购买的 Packt 书籍的示例代码文件，网址为 [http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了本书，可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 注册并直接通过电子邮件获取文件。
- en: New to the second edition of this book, the example code is also available via
    GitHub at [https://github.com/dataspelunking/MLwR/](https://github.com/dataspelunking/MLwR/).
    Check here for the most up-to-date R code, as well as issue tracking and a public
    wiki. Please join the community!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第二版新增了示例代码，并且可以通过 GitHub 在 [https://github.com/dataspelunking/MLwR/](https://github.com/dataspelunking/MLwR/)
    获得。在这里查看最新的 R 代码、问题追踪和公共 Wiki。请加入社区！
- en: Factors
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 因子
- en: 'If you recall from [Chapter 1](ch01.html "Chapter 1. Introducing Machine Learning"),
    *Introducing Machine Learning*, features that represent a characteristic with
    categories of values are known as **nominal**. Although it is possible to use
    a character vector to store nominal data, R provides a data structure specifically
    for this purpose. A **factor** is a special case of vector that is solely used
    to represent categorical or ordinal variables. In the medical dataset we are building,
    we might use a factor to represent gender, because it uses two categories: `MALE`
    and `FEMALE`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得来自[第1章](ch01.html "第1章 引言：机器学习")，*机器学习导论*，表示具有类别值特征的特征被称为**名义型**。尽管可以使用字符向量来存储名义数据，R提供了一个专门用于此目的的数据结构。**因子**是一种特殊的向量，仅用于表示类别变量或有序变量。在我们正在构建的医疗数据集中，我们可能会使用因子来表示性别，因为它使用两个类别：`MALE`和`FEMALE`。
- en: Why not use character vectors? An advantage of factors is that the category
    labels are stored only once. For instance, rather than storing `MALE`, `MALE`,
    `FEMALE`, the computer can store `1`, `1`, `2`, which reduces the size of memory
    needed to store the same information. Additionally, many machine learning algorithms
    treat nominal and numeric data differently. Coding as factors is often needed
    to inform an R function to treat categorical data appropriately.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用字符向量？因子的一个优势是类别标签只存储一次。例如，计算机可以存储`1`、`1`、`2`，而不是存储`MALE`、`MALE`、`FEMALE`，这减少了存储相同信息所需的内存空间。此外，许多机器学习算法会以不同方式处理名义数据和数值数据。将数据编码为因子通常是必要的，能够告诉R函数如何正确处理类别数据。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A factor should not be used for character vectors that are not truly categorical.
    If a vector stores mostly unique values like names or identification strings,
    keep it as a character vector.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不是严格类别型的字符向量，不应该使用因子。如果一个向量主要存储唯一值，比如名字或身份识别字符串，应保持其为字符向量。
- en: 'To create a factor from a character vector, simply apply the `factor()` function.
    For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符向量创建因子，只需应用`factor()`函数。例如：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that when the gender data for John Doe and Jane Doe were displayed,
    R printed additional information about the `gender` factor. The `levels` variable
    comprise the set of possible categories `factor` could take, in this case: `MALE`
    or `FEMALE`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当显示John Doe和Jane Doe的性别数据时，R打印了关于`gender`因子的额外信息。`levels`变量包含因子可能取的类别集，在这个例子中是：`MALE`或`FEMALE`。
- en: 'When we create factors, we can add additional levels that may not appear in
    the data. Suppose we add another factor for the blood type, as shown in the following
    example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建因子时，可以添加在数据中可能未出现的额外级别。假设我们为血型添加了另一个因子，如以下示例所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that when we defined the `blood` factor for the three patients, we specified
    an additional vector of four possible blood types using the `levels` parameter.
    As a result, even though our data included only types `O`, `AB`, and `A`, all
    the four types are stored with the `blood` factor as indicated by the output.
    Storing the additional level allows for the possibility of adding data with the
    other blood types in the future. It also ensures that if we were to create a table
    of blood types, we would know that the `B` type exists, despite it not being recorded
    in our data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们为三位患者定义`blood`因子时，我们使用`levels`参数指定了一个包含四种可能血型的额外向量。因此，尽管我们的数据仅包括`O`、`AB`和`A`型，所有四种类型都被与`blood`因子一起存储，如输出所示。存储额外的级别为将来可能添加其他血型数据提供了可能性。它还确保了，如果我们要创建一个血型表格，即使数据中没有记录`B`型，我们也知道`B`型是存在的。
- en: 'The factor data structure also allows us to include information about the order
    of a nominal variable''s categories, which provides a convenient way to store
    ordinal data. For example, suppose we have data on the severity of a patient''s
    `symptoms` coded in an increasing level of severity from mild, to moderate, to
    severe. We indicate the presence of ordinal data by providing the factor''s `levels`
    in the desired order, listed in ascending order from lowest to highest, and setting
    the `ordered` parameter to `TRUE`, as shown:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因子数据结构还允许我们包含关于名义变量类别顺序的信息，这为存储有序数据提供了一种便捷的方法。例如，假设我们有关于患者`symptoms`（症状）严重性的数据显示，严重性从轻度到中度再到重度依次递增。我们通过按所需顺序提供因子的`levels`，从最低到最高升序排列，并将`ordered`参数设置为`TRUE`，如所示，以表示有序数据。
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The resulting `symptoms` factor now includes information about the order we
    requested. Unlike our prior factors, the levels value of this factor are separated
    by `<` symbols, to indicate the presence of a sequential order from mild to severe:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在得到的`symptoms`因子包括我们请求的顺序信息。与之前的因子不同，这个因子的水平值由`<`符号分隔，用以表示从轻到重的顺序：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A helpful feature of the ordered factors is that logical tests work as you
    expect. For instance, we can test whether each patient''s symptoms are greater
    than moderate:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有序因子的一个有用特性是逻辑测试按预期工作。例如，我们可以测试每个患者的症状是否大于中度：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Machine learning algorithms capable of modeling ordinal data will expect the
    ordered factors, so be sure to code your data accordingly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 能够建模有序数据的机器学习算法会期待有序因子，因此请确保按此要求对数据进行编码。
- en: Lists
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: A **list** is a data structure, much like a vector, in that it is used for storing
    an ordered set of elements. However, where a vector requires all its elements
    to be the same type, a list allows different types of elements to be collected.
    Due to this flexibility, lists are often used to store various types of input
    and output data and sets of configuration parameters for machine learning models.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**是一种数据结构，类似于向量，用于存储有序的元素集合。然而，与向量要求所有元素类型相同不同，列表允许包含不同类型的元素。由于这种灵活性，列表常用于存储各种类型的输入输出数据，以及机器学习模型的配置参数集。'
- en: 'To illustrate lists, consider the medical patient dataset we have been constructing
    with the data for three patients stored in six vectors. If we want to display
    all the data on John Doe (subject 1), we would need to enter five R commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明列表的使用，考虑我们构建的医疗患者数据集，其中包含存储在六个向量中的三名患者数据。如果我们想展示John Doe（患者1）的所有数据，我们需要输入五个R命令：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This seems like a lot of work to display one patient's medical data. The list
    structure allows us to group all of the patient's data into one object that we
    can use repeatedly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要展示一个患者的医疗数据似乎工作量很大。列表结构允许我们将患者的所有数据归为一个对象，这样我们就可以重复使用它。
- en: 'Similar to creating a vector with `c()`, a list is created using the `list()`
    function, as shown in the following example. One notable difference is that when
    a list is constructed, each component in the sequence is almost always given a
    name. The names are not technically required, but allow the list''s values to
    be accessed later on by name rather than by numbered position. To create a list
    with named components for all of the first patient''s data, type the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用`c()`创建向量，列表是通过`list()`函数创建的，如下所示。一个显著的不同是，当构造列表时，序列中的每个组件几乎总是被赋予一个名称。名称在技术上不是必需的，但它允许以后通过名称而非编号位置访问列表的值。为了创建一个包含患者1所有数据的命名组件的列表，可以输入以下内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This patient''s data is now collected in the `subject1` list:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个患者的数据已经收集在`subject1`列表中了：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that the values are labeled with the names we specified in the preceding
    command. However, a list can still be accessed using methods similar to a vector.
    To access the `temperature` value, use the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值已标记为我们在前面命令中指定的名称。然而，列表仍然可以使用类似于向量的方法进行访问。要访问`temperature`值，可以使用以下命令：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result of using vector-style operators on a list object is another list
    object, which is a subset of the original list. For example, the preceding code
    returned a list with a single `temperature` component. To return a single list
    item in its native data type, use double brackets (`[[` and `]]`) when attempting
    to select the list component. For example, the following returns a numeric vector
    of length one:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表对象上使用向量样式操作符的结果是另一个列表对象，它是原始列表的一个子集。例如，前面的代码返回了一个只包含`temperature`组件的列表。要以原始数据类型返回单个列表项，可以在选择列表组件时使用双括号（`[[`和`]]`）。例如，下面的代码将返回一个长度为1的数值向量：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For clarity, it is often easier to access list components directly, by appending
    a `$` and the value''s name to the name of the list component, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，直接访问列表组件通常更为方便，通过在列表组件名称后附加`$`和值的名称，格式如下：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Like the double bracket notation, this returns the list component in its native
    data type (in this case, a numeric vector of length one).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与双括号符号类似，这将返回列表组件的原始数据类型（在这种情况下是一个长度为1的数值向量）。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Accessing the value by name also ensures that the correct item is retrieved,
    even if the order of the list's elements is changed later on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 按名称访问值也确保了即使列表元素的顺序稍后发生变化，仍然能够正确检索到相应的项。
- en: 'It is possible to obtain several items in a list by specifying a vector of
    names. The following returns a subset of the `subject1` list, which contains only
    the `temperature` and `flu_status` components:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定名称向量来获得列表中的多个项。以下代码返回 `subject1` 列表的子集，只包含 `temperature` 和 `flu_status`
    组件：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Entire datasets could be constructed using lists and lists of lists. For example,
    you might consider creating a `subject2` and `subject3` list, and combining these
    into a single list object named `pt_data`. However, constructing a dataset in
    this way is common enough that R provides a specialized data structure specifically
    for this task.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 整个数据集可以通过使用列表和列表的列表来构建。例如，你可能会考虑创建一个 `subject2` 和 `subject3` 列表，并将它们合并成一个名为
    `pt_data` 的单一列表对象。然而，以这种方式构建数据集足够常见，以至于 R 提供了一个专门的结构来执行这个任务。
- en: Data frames
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框
- en: By far, the most important R data structure utilized in machine learning is
    the **data frame**, a structure analogous to a spreadsheet or database, since
    it has both rows and columns of data. In R terms, a data frame can be understood
    as a list of vectors or factors, each having exactly the same number of values.
    Because the data frame is literally a list of vector type objects, it combines
    aspects of both vectors and lists.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在机器学习中使用的最重要的 R 数据结构是 **数据框（data frame）**，它类似于电子表格或数据库结构，因为它具有行和列的数据。在
    R 术语中，数据框可以理解为一个向量或因子的列表，每个向量或因子具有相同数量的值。因为数据框本质上是向量类型对象的列表，它结合了向量和列表的特点。
- en: 'Let''s create a data frame for our patient dataset. Using the patient data
    vectors we created previously, the `data.frame()` function combines them into
    a data frame:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为患者数据集创建一个数据框。使用我们之前创建的患者数据向量，`data.frame()` 函数将它们组合成一个数据框：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You might notice something new in the preceding code. We included an additional
    parameter: `stringsAsFactors = FALSE`. If we do not specify this option, R will
    automatically convert every character vector to a factor.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到前面的代码中有些新内容。我们加入了一个额外的参数：`stringsAsFactors = FALSE`。如果我们没有指定这个选项，R 会自动将每个字符向量转换为因子。
- en: This feature is occasionally useful, but also sometimes unwarranted. Here, for
    example, the `subject_name` field is definitely not categorical data, as names
    are not categories of values. Therefore, setting the `stringsAsFactors` option
    to `FALSE` allows us to convert character vectors to factors only where it makes
    sense for the project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性偶尔会有用，但有时也没有必要。例如，这里 `subject_name` 字段显然不是类别数据，因为名字不是值的类别。因此，将 `stringsAsFactors`
    选项设置为 `FALSE`，让我们只在对项目有意义的情况下将字符向量转换为因子。
- en: 'When we display the `pt_data` data frame, we see that the structure is quite
    different from the data structures we worked with previously:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们显示 `pt_data` 数据框时，可以看到它的结构与我们之前使用的数据结构有很大不同：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compared to the one-dimensional vectors, factors, and lists, a data frame has
    two dimensions and is displayed in matrix format. This particular data frame has
    one column for each vector of patient data and one row for each patient. In machine
    learning terms, the data frame's columns are the features or attributes and the
    rows are the examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于一维的向量、因子和列表，数据框（data frame）有两个维度，并且以矩阵格式显示。这个特定的数据框每个患者数据的向量对应一个列，每个患者对应一行。在机器学习的术语中，数据框的列是特征或属性，行是示例。
- en: 'To extract entire columns (vectors) of data, we can take advantage of the fact
    that a data frame is simply a list of vectors. Similar to lists, the most direct
    way to extract a single element is by referring to it by name. For example, to
    obtain the `subject_name` vector, type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取整个列（向量）数据，我们可以利用数据框本质上是一个向量的列表这一特性。类似于列表，提取单个元素最直接的方式是通过名称引用它。例如，要获取 `subject_name`
    向量，可以输入：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also similar to lists, a vector of names can be used to extract several columns
    from a data frame:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于列表，姓名向量可以用来从数据框中提取多个列：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we access the data frame in this way, the result is a data frame containing
    all the rows of data for all the requested columns. Alternatively, the `pt_data[2:3]`
    command will also extract the `temperature` and `flu_status` columns. However,
    requesting the columns by name results in a clear and easy-to-maintain R code
    that will not break if the data frame is restructured in the future.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式访问数据框时，结果是一个包含所有请求列的所有行数据的数据框。或者，`pt_data[2:3]` 命令也可以提取 `temperature`
    和 `flu_status` 列。然而，通过名称请求列会得到一个清晰且易于维护的 R 代码，如果数据框将来重新结构化，也不会出错。
- en: 'To extract values in the data frame, methods like those for accessing values
    in vectors are used. However, there is an important exception. Because the data
    frame is two-dimensional, both the desired rows and columns to be extracted must
    be specified. Rows are specified first, followed by a comma and then the columns
    in a format like this: `[rows, columns]`. As with vectors, rows and columns are
    counted beginning at one.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取数据框中的值，可以使用类似于访问向量值的方法。然而，有一个重要的例外。由于数据框是二维的，因此必须同时指定要提取的行和列。行先指定，后面跟着一个逗号，然后是列，格式如下：`[行,
    列]`。与向量一样，行和列从1开始计数。
- en: 'For instance, to extract the value in the first row and second column of the
    patient data frame (the `temperature` value for John Doe), use the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要提取患者数据框中第一行和第二列的值（即John Doe的`temperature`值），请使用以下命令：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you like more than a single row or column of data, specify vectors for the
    rows and columns desired. The following command will pull data from the first
    and third rows and the second and fourth columns:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要不止一行或一列的数据，可以指定所需的行和列向量。以下命令将从第一行和第三行以及第二列和第四列提取数据：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To extract all the rows or columns, simply leave the row or column portion
    blank. For example, to extract all the rows of the first column:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取所有的行或列，只需将行或列部分留空。例如，要提取第一列的所有行：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To extract all the columns of the first row, use the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取第一行的所有列，请使用以下命令：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To extract everything, use the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取所有内容，请使用以下命令：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Other methods to access values in lists and vectors can also be used to retrieve
    data frame rows and columns. For example, columns can be accessed by name rather
    than position, and negative signs can be used to exclude rows or columns of data.
    Therefore, the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 访问列表和向量中的值的其他方法也可以用来提取数据框的行和列。例如，可以通过名称而不是位置来访问列，并且可以使用负号来排除某些行或列的数据。因此，以下命令：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Is equivalent to:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To become more familiar with data frames, try practicing similar operations
    with the patient dataset, or even better, use data from one of your own projects.
    These types of operations are crucial for much of the work we will do in the upcoming
    chapters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更熟悉数据框，尝试用患者数据集进行类似的操作，或者更好的是，使用你自己项目中的数据。这些类型的操作对于我们将在接下来的章节中做的许多工作至关重要。
- en: Matrixes and arrays
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵和数组
- en: In addition to data frames, R provides other structures that store values in
    a tabular form. A **matrix** is a data structure that represents a two-dimensional
    table with rows and columns of data. Like vectors, R matrixes can contain any
    one type of data, although they are most often used for mathematical operations
    and, therefore, typically store only numeric data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据框，R还提供了其他以表格形式存储值的结构。**矩阵**是一种数据结构，表示一个具有行和列数据的二维表格。与向量类似，R矩阵可以包含任何一种类型的数据，尽管它们通常用于数学运算，因此通常只存储数值数据。
- en: 'To create a matrix, simply supply a vector of data to the `matrix()` function
    along with a parameter specifying the number of rows (`nrow`) or number of columns
    (`ncol`). For example, to create a 2 x 2 matrix storing the numbers one through
    four, we can use the `nrow` parameter to request the data to be divided into two
    rows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个矩阵，只需向`matrix()`函数提供一个数据向量，并指定行数（`nrow`）或列数（`ncol`）的参数。例如，要创建一个存储数字1到4的2
    x 2矩阵，我们可以使用`nrow`参数来要求将数据分为两行：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is equivalent to the matrix produced using `ncol = 2`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于使用`ncol = 2`所产生的矩阵：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will notice that R loaded the first column of the matrix first before loading
    the second column. This is called **column-major order**, and is R's default method
    for loading matrices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，R首先加载了矩阵的第一列，然后才加载第二列。这被称为**列主序**，是R加载矩阵的默认方法。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To override this default setting and load a matrix by rows, set the parameter
    `byrow = TRUE` when creating the matrix.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖此默认设置并按行加载矩阵，在创建矩阵时设置参数`byrow = TRUE`。
- en: To illustrate this further, let's see what happens if we add more values to
    the matrix.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，让我们看看如果我们向矩阵中添加更多值会发生什么。
- en: 'With six values, requesting two rows creates a matrix with three columns:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用六个值，请求两行会创建一个包含三列的矩阵：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Requesting two columns creates a matrix with three rows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请求两列会创建一个包含三行的矩阵：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As with data frames, values in matrixes can be extracted using `[row, column]`
    notation. For instance, `m[1, 1]` will return the value `1` and `m[3, 2]` will
    extract `6` from the `m` matrix. Additionally, entire rows or columns can be requested:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据框一样，矩阵中的值可以使用`[行, 列]`符号提取。例如，`m[1, 1]`将返回值`1`，而`m[3, 2]`将从`m`矩阵中提取值`6`。此外，整个行或列也可以被请求：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Closely related to the matrix structure is the **array**, which is a multidimensional
    table of data. Where a matrix has rows and columns of values, an array has rows,
    columns, and any number of additional layers of values. Although we will be occasionally
    using matrixes in the upcoming chapters, the use of arrays is outside the scope
    of this book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与矩阵结构密切相关的是**数组**，它是一个多维的数据表格。矩阵具有行和列的值，而数组则具有行、列以及任意数量的附加层级值。尽管我们将在接下来的章节中偶尔使用矩阵，但数组的使用超出了本书的范围。
- en: Managing data with R
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用R管理数据
- en: One of the challenges faced while working with massive datasets involves gathering,
    preparing, and otherwise managing data from a variety of sources. Although we
    will cover data preparation, data cleaning, and data management in depth by working
    on real-world machine learning tasks in the later chapters, this section will
    highlight the basic functionality to get data into and out of R.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大量数据集时，面临的挑战之一是收集、准备以及管理来自多种来源的数据。尽管我们将在后续章节中通过实际的机器学习任务深入讨论数据准备、数据清理和数据管理，但本节将突出介绍如何将数据导入和导出R的基本功能。
- en: Saving, loading, and removing R data structures
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存、加载和删除R数据结构
- en: When you have spent a lot of time getting a data frame into the desired form,
    you shouldn't need to recreate your work each time you restart your R session.
    To save a data structure to a file that can be reloaded later or transferred to
    another system, use the `save()` function. The `save()` function writes one or
    more R data structures to the location specified by the `file` parameter. R data
    files have an `.RData` extension.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你花了很多时间将一个数据框整理成所需的形式时，你不应该在每次重新启动R会话时都需要重新创建你的工作。要将数据结构保存到一个可以稍后重新加载或传输到另一个系统的文件中，请使用`save()`函数。`save()`函数将一个或多个R数据结构写入由`file`参数指定的位置。R数据文件的扩展名为`.RData`。
- en: 'Suppose you have three objects named `x`, `y`, and `z` that you would like
    to save in a permanent file. Regardless of whether they are vectors, factors,
    lists, or data frames, we could save them to a file named `mydata.RData` using
    the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有三个对象，名为`x`、`y`和`z`，并希望将它们保存到一个永久文件中。无论它们是向量、因子、列表还是数据框，我们都可以使用以下命令将它们保存到名为`mydata.RData`的文件中：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `load()` command can recreate any data structures that have been saved
    to an `.RData` file. To load the `mydata.RData` file we saved in the preceding
    code, simply type:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`命令可以重新创建已保存到`.RData`文件中的任何数据结构。要加载我们在前面代码中保存的`mydata.RData`文件，只需输入：'
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will recreate the `x`, `y`, and `z` data structures.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新创建`x`、`y`和`z`数据结构。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be careful of what you are loading! All data structures stored in the file you
    are importing with the `load()` command will be added to your workspace, even
    if they overwrite something else you are working on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 小心你正在加载的内容！所有存储在你通过`load()`命令导入的文件中的数据结构都会被添加到你的工作区，即使它们覆盖了你正在处理的其他内容。
- en: If you need to wrap up your R session in a hurry, the `save.image()` command
    will write your entire session to a file simply called `.RData`. By default, R
    will look for this file the next time you start R, and your session will be recreated
    just as you had left it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要急速结束你的R会话，`save.image()`命令将会把你的整个会话保存到一个名为`.RData`的文件中。默认情况下，下次启动R时，R会查找这个文件，你的会话将会如你上次离开时那样被重新创建。
- en: 'After working on an R session for sometime, you may have accumulated a number
    of data structures. The `ls()` listing function returns a vector of all the data
    structures currently in the memory. For example, if you''ve been following along
    with the code in this chapter, the `ls()` function returns the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在R会话中工作了一段时间后，你可能会积累许多数据结构。`ls()`列出函数返回当前内存中所有数据结构的向量。例如，如果你跟随本章的代码操作，`ls()`函数将返回如下内容：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'R will automatically remove these from its memory upon quitting the session,
    but for large data structures, you may want to free up the memory sooner. The
    `rm()` remove function can be used for this purpose. For example, to eliminate
    the `m` and `subject1` objects, simply type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: R 会在退出会话时自动从内存中删除这些对象，但对于大型数据结构，您可能希望更早释放内存。可以使用 `rm()` 删除函数来达到此目的。例如，要删除 `m`
    和 `subject1` 对象，只需输入：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `rm()` function can also be supplied with a character vector of the object
    names to be removed. This works with the `ls()` function to clear the entire R
    session:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm()` 函数也可以接受一个包含要删除的对象名称的字符向量。结合 `ls()` 函数，可以清除整个 R 会话：'
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Be very careful while executing the preceding command, as you will not be prompted
    before your objects are removed!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述命令时请务必小心，因为在删除对象之前不会提示您确认！
- en: Importing and saving data from CSV files
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 CSV 文件导入和保存数据
- en: It is very common for public datasets to be stored in text files. Text files
    can be read on virtually any computer or operating system, which makes the format
    nearly universal. They can also be exported and imported to and from programs
    such as Microsoft Excel, providing a quick and easy way to work with spreadsheet
    data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 公共数据集通常存储在文本文件中。文本文件几乎可以在任何计算机或操作系统上读取，这使得这种格式几乎是通用的。它们还可以导入到 Excel 等程序中，提供了一种快速简便的方式来处理电子表格数据。
- en: A **tabular** (as in "table") data file is structured in the matrix form, such
    that each line of text reflects one example, and each example has the same number
    of features. The feature values on each line are separated by a predefined symbol,
    known as a **delimiter**. Often, the first line of a tabular data file lists the
    names of the columns of data. This is called a **header** line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格**（如“表”）数据文件是以矩阵形式结构化的，每行文本表示一个示例，每个示例具有相同数量的特征。每行中的特征值由预定义符号分隔，该符号被称为**分隔符**。通常，表格数据文件的第一行列出数据列的名称，这称为**标题**行。'
- en: 'Perhaps the most common tabular text file format is the **CSV** (**Comma-Separated
    Values**) file, which as the name suggests, uses the comma as a delimiter. The
    CSV files can be imported to and exported from many common applications. A CSV
    file representing the medical dataset constructed previously could be stored as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的表格文本文件格式可能是**CSV**（**逗号分隔值**）文件，顾名思义，它使用逗号作为分隔符。CSV 文件可以被许多常见应用程序导入和导出。之前构建的医学数据集可以存储为一个
    CSV 文件，示例如下：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Given a patient data file named `pt_data.csv` located in the R working directory,
    the `read.csv()` function can be used as follows to load the file into R:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 给定名为 `pt_data.csv` 的患者数据文件，位于 R 工作目录中，可以如下使用 `read.csv()` 函数将文件加载到 R 中：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will read the CSV file into a data frame titled `pt_data`. Just as we did
    previously while constructing a data frame, we need to use the `stringsAsFactors
    = FALSE` parameter to prevent R from converting all text variables into factors.
    This step is better left to you, not R, to perform.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 CSV 文件读入名为 `pt_data` 的数据框。正如我们在构建数据框时所做的那样，我们需要使用 `stringsAsFactors = FALSE`
    参数，防止 R 将所有文本变量转换为因子。此步骤最好由您而非 R 执行。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If your dataset resides outside the R working directory, the full path to the
    CSV file (for example, `/path/to/mydata.csv`) can be used when calling the `read.csv()`
    function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的数据集位于 R 工作目录之外，则可以在调用 `read.csv()` 函数时使用 CSV 文件的完整路径（例如，`/path/to/mydata.csv`）。
- en: 'By default, R assumes that the CSV file includes a header line listing the
    names of the features in the dataset. If a CSV file does not have a header, specify
    the option `header = FALSE`, as shown in the following command, and R will assign
    default feature names in the `V1` and `V2` forms and so on:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，R 假定 CSV 文件包含一个列出数据集中各特征名称的标题行。如果 CSV 文件没有标题行，请指定选项 `header = FALSE`，如以下命令所示，R
    会为每个特征分配默认名称，如 `V1`、`V2` 等：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `read.csv()` function is a special case of the `read.table()` function,
    which can read tabular data in many different forms, including other delimited
    formats such as **Tab-Separated Values** (**TSV**). For more detailed information
    on the `read.table()` family of functions, refer to the R help page using the
    `?read.table` command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`read.csv()` 函数是 `read.table()` 函数的一个特例，它可以读取许多不同形式的表格数据，包括其他分隔格式，如**制表符分隔值**（**TSV**）。有关
    `read.table()` 函数族的更多详细信息，请使用 `?read.table` 命令查看 R 帮助页面。'
- en: 'To save a data frame to a CSV file, use the `write.csv()` function. If your
    data frame is named `pt_data`, simply enter:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将数据框保存为 CSV 文件，使用`write.csv()`函数。如果你的数据框名为`pt_data`，只需输入：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will write a CSV file with the name `pt_data.csv` to the R working folder.
    The `row.names` parameter overrides R's default setting, which is to output row
    names in the CSV file. Unless row names have been added to a data frame, this
    output is unnecessary and will simply inflate the size of the resulting file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把一个名为`pt_data.csv`的 CSV 文件写入 R 工作文件夹。`row.names`参数覆盖了 R 的默认设置，默认设置是将行名输出到
    CSV 文件中。除非数据框中已添加行名，否则这种输出是多余的，且只会增加文件的大小。
- en: Exploring and understanding data
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索并理解数据
- en: After collecting data and loading it into R's data structures, the next step
    in the machine learning process involves examining the data in detail. It is during
    this step that you will begin to explore the data's features and examples, and
    realize the peculiarities that make your data unique. The better you understand
    your data, the better you will be able to match a machine learning model to your
    learning problem.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集数据并将其加载到 R 的数据结构中后，机器学习过程中的下一步是详细检查数据。正是在这一步，你将开始探索数据的特征和示例，并意识到使数据独特的特殊性。你对数据理解得越透彻，就越能将合适的机器学习模型应用于你的学习问题。
- en: The best way to learn the process of data exploration is with an example. In
    this section, we will explore the `usedcars.csv` dataset, which contains actual
    data about used cars recently advertised for sale on a popular U.S. website.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 学习数据探索过程的最佳方式是通过一个例子。在本节中，我们将探索`usedcars.csv`数据集，该数据集包含了最近在美国一个流行网站上广告出售的二手车的实际数据。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `usedcars.csv` dataset is available for download on the Packt Publishing
    support page for this book. If you are following along with the examples, be sure
    that this file has been downloaded and saved to your R working directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`usedcars.csv`数据集可以在本书的 Packt Publishing 支持页面下载。如果你正在跟随本书的例子进行操作，确保已将该文件下载并保存到你的
    R 工作目录中。'
- en: 'Since the dataset is stored in the CSV form, we can use the `read.csv()` function
    to load the data into an R data frame:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据集以 CSV 形式存储，我们可以使用`read.csv()`函数将数据加载到 R 数据框中：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Given the `usedcars` data frame, we will now assume the role of a data scientist
    who has the task of understanding the used car data. Although data exploration
    is a fluid process, the steps can be imagined as a sort of investigation in which
    questions about the data are answered. The exact questions may vary across projects,
    but the types of questions are always similar. You should be able to adapt the
    basic steps of this investigation to any dataset you like, whether large or small.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`usedcars`数据框，我们现在将扮演数据科学家的角色，任务是理解二手车数据。尽管数据探索是一个流动的过程，但可以将这些步骤想象成一种调查，其中关于数据的问题得到解答。确切的问题可能因项目而异，但问题的类型始终相似。你应该能够将这种调查的基本步骤适应到任何你喜欢的数据集上，无论它们是大是小。
- en: Exploring the structure of data
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索数据的结构
- en: One of the first questions to ask in an investigation of a new dataset should
    be about how the dataset is organized. If you are fortunate, your source will
    provide a **data dictionary**, which is a document that describes the dataset's
    features. In our case, the used car data does not come with this documentation,
    so we'll need to create one on our own.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查一个新数据集时，首先要问的问题之一是数据集是如何组织的。如果幸运的话，你的源数据将提供一个**数据字典**，这是一份描述数据集特征的文档。在我们的案例中，二手车数据并没有随附该文档，因此我们需要自己创建一个数据字典。
- en: 'The `str()` function provides a method to display the structure of R data structures
    such as data frames, vectors, or lists. It can be used to create the basic outline
    for our data dictionary:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()`函数提供了一种显示 R 数据结构（如数据框、向量或列表）结构的方法。它可以用来创建我们数据字典的基本框架：'
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using such a simple command, we learn a wealth of information about the dataset.
    The statement `150 obs` informs us that the data includes 150 **observations**,
    which is just another way of saying that the dataset contains 150 records or examples.
    The number of observations is often simply abbreviated as *n*. Since we know that
    the data describes used cars, we can now presume that we have examples of *n =
    150* automobiles for sale.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样一个简单的命令，我们可以获得关于数据集的大量信息。语句`150 obs`告知我们数据集包含150个**观察值**，这只是另一种说法，意思是数据集包含150条记录或示例。观察值的数量通常简写为*n*。既然我们知道数据描述的是二手车，那么我们可以推测这些是*n
    = 150*辆待售的汽车。
- en: 'The `6 variables` statement refers to the six features that were recorded in
    the data. These features are listed by name on separate lines. Looking at the
    line for the feature called `color`, we can note some additional details:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`6 variables` 语句指的是数据中记录的六个特征。这些特征按名称列出，每个特征占一行。查看 `color` 特征的这一行，我们可以注意到一些额外的细节：'
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After the variable's name, the `chr` label tells us that the feature is `character`
    type. In this dataset, three of the variables are character while three are noted
    as `int`, which indicates `integer` type. Although the `usedcars` dataset includes
    only `character` and `integer` variables, you are also likely to encounter `num`
    or `numeric` type while using noninteger data. Any factors would be listed as
    `factor` type. Following each variable's type, R presents a sequence of the first
    few feature values. The values `"Yellow" "Gray" "Silver" "Gray"` are the first
    four values of the `color` feature.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量名之后，`chr` 标签告诉我们该特征是 `character` 类型。在这个数据集中，三个变量是字符型，而三个变量标记为 `int`，表示整数类型。尽管
    `usedcars` 数据集只包含 `character` 和 `integer` 类型的变量，但在使用非整数数据时，你也可能遇到 `num` 或 `numeric`
    类型。任何因素都将列为 `factor` 类型。在每个变量的类型后，R 会显示几个特征值的序列。`color` 特征的前四个值是 `"Yellow" "Gray"
    "Silver" "Gray"`。
- en: Applying a bit of the subject-area knowledge to the feature names and values
    allows us to make some assumptions about what the variables represent. The `year`
    variable could refer to the year the vehicle was manufactured or it could specify
    the year the advertisement was posted. We will have to investigate this feature
    more in detail later, since the four example values (`2011 2011 2011 2011`) could
    be used to argue for either possibility. The `model`, `price`, `mileage`, `color`,
    and `transmission` variables most likely refer to the characteristics of the car
    for sale.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将一些领域知识应用于特征名称和值，可以让我们对变量代表的内容做出一些假设。`year` 变量可能指的是车辆的生产年份，也可能指广告发布年份。我们将需要更详细地调查这个特征，因为四个示例值（`2011
    2011 2011 2011`）可能支持这两种可能性。`model`、`price`、`mileage`、`color` 和 `transmission`
    变量很可能指的是待售汽车的特征。
- en: Although our data seems to have been given meaningful variable names, this is
    not always the case. Sometimes datasets have features with nonsensical names or
    codes like `V1`. In these cases it may be necessary to do additional sleuthing
    to determine what a feature actually represents. Still, even with helpful feature
    names, it is always prudent to be skeptical about the labels you have been provided
    with. Let's investigate further.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的数据似乎已经给出了有意义的变量名称，但这并不总是如此。有时，数据集中的特征名称或代码可能像 `V1` 这样毫无意义。在这种情况下，可能需要进一步调查才能确定一个特征实际代表什么。不过，即使特征名称有帮助，我们仍然应对所提供的标签保持怀疑态度。让我们进一步调查。
- en: Exploring numeric variables
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索数值型变量
- en: 'To investigate the numeric variables in the used car data, we will employ a
    common set of measurements to describe values known as **summary statistics**.
    The `summary()` function displays several common summary statistics. Let''s take
    a look at a single feature, `year`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调查 `usedcar` 数据中的数值型变量，我们将使用一组常见的度量来描述这些值，这些度量被称为**汇总统计量**。`summary()` 函数会显示几个常见的汇总统计量。让我们来看看一个特征，`year`：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Even if you aren't already familiar with summary statistics, you may be able
    to guess some of them from the heading before the `summary()` output. Ignoring
    the meaning of the values for now, the fact that we see numbers such as `2000`,
    `2008`, and `2009` could lead us to believe that the `year` variable indicates
    the year of manufacture rather than the year the advertisement was posted, since
    we know the vehicles were recently listed for sale.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你还不熟悉汇总统计量，你也可以从 `summary()` 输出前的标题中猜测一些统计量。暂时忽略值的含义，看到像 `2000`、`2008` 和 `2009`
    这样的数字，可能会让我们认为 `year` 变量指示的是生产年份，而不是广告发布年份，因为我们知道这些车辆是最近列出的待售车。
- en: 'We can also use the `summary()` function to obtain summary statistics for several
    `numeric` variables at the same time:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `summary()` 函数同时获取多个 `numeric` 变量的汇总统计量：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The six summary statistics that the `summary()` function provides are simple,
    yet powerful tools to investigate data. They can be divided into two types: measures
    of center and measures of spread.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()` 函数提供的六个汇总统计量是简单但强大的数据分析工具。它们可以分为两类：集中度量和分散度量。'
- en: Measuring the central tendency – mean and median
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量集中趋势 – 平均数和中位数
- en: 'Measures of **central tendency** are a class of statistics used to identify
    a value that falls in the middle of a set of data. You most likely are already
    familiar with one common measure of center: the average. In common use, when something
    is deemed average, it falls somewhere between the extreme ends of the scale. An
    average student might have marks falling in the middle of his or her classmates;
    an average weight is neither unusually light nor heavy. An average item is typical
    and not too unlike the others in the group. You might think of it as an exemplar
    by which all the others are judged.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**集中趋势**度量是用来识别一组数据中间值的统计量类别。你很可能已经熟悉一种常见的中心度量：平均值。在日常使用中，当某物被认为是平均时，它位于尺度的两个极端之间。一个平均学生可能成绩位于同班同学的中间；一个平均体重既不特别轻也不特别重。一个平均项目是典型的，与组中的其他项目没有太大差异。你可以将其视为所有其他项目的示范。'
- en: 'In statistics, the average is also known as the **mean**, which is a measurement
    defined as the sum of all values divided by the number of values. For example,
    to calculate the mean income in a group of three people with incomes of $36,000,
    $44,000, and $56,000, use the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，平均值也称为**均值**，它是通过将所有数值相加后除以数值的个数来定义的。例如，计算三个人的平均收入，假设他们的收入分别为36,000美元、44,000美元和56,000美元，可以使用以下命令：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'R also provides a `mean()` function, which calculates the mean for a vector
    of numbers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: R还提供了一个`mean()`函数，用于计算一组数字的均值：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The mean income of this group of people is about $45,333\. Conceptually, this
    can be imagined as the income each person would have, if the total amount of income
    were divided equally across every person.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这组人的平均收入大约是45,333美元。从概念上讲，这可以想象为如果将总收入平均分配给每个人，每个人的收入将会是多少。
- en: Recall that the preceding `summary()` output listed mean values for the `price`
    and `mileage` variables. The means suggest that the typical used car in this dataset
    was listed at a price of $12,962 and had an odometer reading of 44,261\. What
    does this tell us about our data? Since the average price is relatively low, we
    might expect that the dataset contains economy class cars. Of course, the data
    can also include late-model luxury cars with high mileage, but the relatively
    low mean mileage statistic doesn't provide evidence to support this hypothesis.
    On the other hand, it doesn't provide evidence to ignore the possibility either.
    We'll need to keep this in mind as we examine the data further.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前`summary()`输出的均值，列出了`price`和`mileage`变量的均值。这些均值表明，这个数据集中典型的二手车价格为12,962美元，里程为44,261英里。那这告诉我们什么呢？由于平均价格相对较低，我们可能会认为数据集中包含了经济型汽车。当然，数据中也可能包括了高里程的晚期豪华车，但相对较低的均值里程并没有提供证据支持这一假设。另一方面，它也没有提供证据去忽略这个可能性。在进一步分析数据时，我们需要记住这一点。
- en: 'Although the mean is by far the most commonly cited statistic to measure the
    center of a dataset, it is not always the most appropriate one. Another commonly
    used measure of central tendency is the **median**, which is the value that occurs
    halfway through an ordered list of values. As with the mean, R provides a `median()`
    function, which we can apply to our salary data, as shown in the following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管均值是衡量数据集中心的最常引用的统计量，但它并不总是最合适的。另一个常用的集中趋势度量是**中位数**，它是排序后的数值列表中位于中间的值。与均值一样，R提供了一个`median()`函数，我们可以将其应用于我们的工资数据，如下所示：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because the middle value is `44000`, the median income is $44,000.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因为中间值是`44000`，所以中位数收入为44,000美元。
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If a dataset has an even number of values, there is no middle value. In this
    case, the median is commonly calculated as the average of the two values at the
    center of the ordered list. For example, the median of the values 1, 2, 3, and
    4 is 2.5.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据集中的数值个数为偶数，则没有中间值。在这种情况下，中位数通常计算为排序列表中两个中间数值的平均值。例如，数值1、2、3和4的中位数是2.5。
- en: At the first glance, it seems like the median and mean are very similar measures.
    Certainly, the mean value of $45,333 and the median value of $44,000 are not very
    different. Why have two measures of central tendency? The reason is due to the
    fact that the mean and median are affected differently by the values falling at
    the far ends of the range. In particular, the mean is highly sensitive to **outliers**,
    or values that are atypically high or low in relation to the majority of data.
    Because the mean is sensitive to outliers, it is more likely to be shifted higher
    or lower by a small number of extreme values.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，似乎中位数和均值是非常相似的度量。确实，均值 45,333 和中位数 44,000 差异不大。为什么要有两个集中趋势的度量呢？原因在于均值和中位数受数据范围两端值的影响不同。特别是，均值对**离群值**（即相对于大多数数据来说，值异常高或低的值）非常敏感。由于均值对离群值敏感，它更容易受到少数极端值的影响，导致均值偏高或偏低。
- en: Recall again the reported median values in the `summary()` output for the used
    car dataset. Although the mean and median price are fairly similar (differing
    by approximately five percent), there is a much larger difference between the
    mean and median for mileage. For mileage, the mean of 44,261 is approximately
    20 percent more than the median of 36,385\. Since the mean is more sensitive to
    extreme values than the median, the fact that the mean is much higher than the
    median might lead us to suspect that there are some used cars in the dataset with
    extremely high mileage values. To investigate this further, we'll need to add
    additional summary statistics to our analysis.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回顾一下在 `summary()` 输出中报告的二手车数据集的中位数值。尽管均值和中位数价格非常相似（相差大约 5%），但里程的均值和中位数之间有很大的差异。对于里程，均值
    44,261 比中位数 36,385 高出大约 20%。由于均值对极端值更为敏感，因此均值远高于中位数，可能暗示数据集中存在一些极高里程的二手车。为了进一步调查这一点，我们需要在分析中加入更多的汇总统计数据。
- en: Measuring spread – quartiles and the five-number summary
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量分布——四分位数和五数概括
- en: Measuring the mean and median provides one way to quickly summarize the values,
    but these measures of center tell us little about whether or not there is diversity
    in the measurements. To measure the diversity, we need to employ another type
    of summary statistics that is concerned with the **spread** of data, or how tightly
    or loosely the values are spaced. Knowing about the spread provides a sense of
    the data's highs and lows and whether most values are like or unlike the mean
    and median.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 测量均值和中位数提供了一种快速总结数值的方法，但这些集中趋势的度量对数据是否存在多样性并没有提供太多信息。为了衡量多样性，我们需要采用另一种关注数据**分布**的汇总统计方法，即数据的值是如何紧密或松散分布的。了解数据的分布可以帮助我们了解数据的极端值，以及大多数值是类似于均值和中位数，还是与其不同。
- en: 'The **five-number summary** is a set of five statistics that roughly depict
    the spread of a feature''s values. All five of the statistics are included in
    the output of the `summary()` function. Written in order, they are:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**五数概括**是一组五个统计值，粗略地描述了特征值的分布情况。所有这五个统计值都包含在 `summary()` 函数的输出中。按顺序排列，它们是：'
- en: Minimum (`Min.`)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小值 (`Min.`)
- en: First quartile, or Q1 (`1st Qu.`)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一四分位数，或 Q1 (`1st Qu.`)
- en: Median, or Q2 (`Median`)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中位数，或 Q2 (`Median`)
- en: Third quartile, or Q3 (`3rd Qu.`)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三四分位数，或 Q3 (`3rd Qu.`)
- en: Maximum (`Max.`)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大值 (`Max.`)
- en: As you would expect, minimum and maximum are the most extreme feature values,
    indicating the smallest and largest values, respectively. R provides the `min()`
    and `max()` functions to calculate these values on a vector of data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，最小值和最大值是最极端的特征值，分别表示最小值和最大值。R 提供了 `min()` 和 `max()` 函数，用于计算数据向量的这些值。
- en: 'The span between the minimum and maximum value is known as the **range**. In
    R, the `range()` function returns both the minimum and maximum value. Combining
    `range()` with the `diff()` difference function allows you to examine the range
    of data with a single line of code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值和最大值之间的跨度被称为**范围**。在 R 中，`range()` 函数返回最小值和最大值。将 `range()` 与 `diff()` 差异函数结合使用，可以通过一行代码检查数据的范围：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first and third quartiles—Q1 and Q3—refer to the value below or above which
    one quarter of the values are found. Along with the (Q2) median, the **quartiles**
    divide a dataset into four portions, each with the same number of values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一四分位数和第三四分位数——Q1 和 Q3——是指其中一个值以下或以上的四分之一数据值。与中位数（Q2）一起，**四分位数**将数据集划分为四个部分，每部分包含相同数量的数据值。
- en: Quartiles are a special case of a type of statistics called **quantiles**, which
    are numbers that divide data into equally sized quantities. In addition to quartiles,
    commonly used quantiles include **tertiles** (three parts), **quintiles** (five
    parts), **deciles** (10 parts), and **percentiles** (100 parts).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 四分位数是一种特殊情况，属于称为**分位数**的统计类型，它将数据等分为相同大小的数量。除了四分位数，常用的分位数还包括**三分位数**（三部分）、**五分位数**（五部分）、**十分位数**（十部分）和**百分位数**（100部分）。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Percentiles are often used to describe the ranking of a value; for instance,
    a student whose test score was ranked at the 99^(th) percentile performed better
    than, or equal to, 99 percent of the other test takers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 百分位数通常用来描述值的排名；例如，考试成绩排在第99百分位数的学生比其他考生中的99%表现更好或相等。
- en: 'The middle 50 percent of data between the first and third quartiles is of particular
    interest because it in itself is a simple measure of spread. The difference between
    Q1 and Q3 is known as the **Interquartile Range** (**IQR**), and it can be calculated
    with the `IQR()` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 介于第一四分位数（Q1）和第三四分位数（Q3）之间的中间50%数据特别重要，因为它本身是一个简单的展布度量。Q1到Q3的差异被称为**四分位距**（**IQR**），可以通过`IQR()`函数计算：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We could have also calculated this value by hand from the `summary()` output
    for the `usedcars$price` variable by computing *14904 – 10995 = 3909*. The small
    difference between our calculation and the `IQR()` output is due to the fact that
    R automatically rounds the `summary()` output.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过从`summary()`输出的`usedcars$price`变量计算*14904 – 10995 = 3909*来手动计算这个值。我们计算和`IQR()`输出之间的小差异是因为R自动舍入`summary()`输出。
- en: 'The `quantile()` function provides a robust tool to identify quantiles for
    a set of values. By default, the `quantile()` function returns the five-number
    summary. Applying the function to the used car data results in the same statistics
    as done earlier:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`quantile()` 函数提供了一个强大的工具来识别一组值的分位数。默认情况下，`quantile()` 函数返回五数概括。将该函数应用于二手车数据会产生与之前相同的统计结果：'
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While computing quantiles, there are many methods to handle ties among values
    and datasets with no middle value. The `quantile()` function allows you to specify
    among nine different algorithms by specifying the `type` parameter. If your project
    requires a precisely defined quantile, it is important to read the function documentation
    using the `?quantile` command.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算分位数时，有许多方法处理数值和数据集中没有中间值的情况。`quantile()`函数允许您通过指定`type`参数来选择九种不同的算法之一。如果您的项目需要精确定义的分位数，重要的是要阅读使用`?quantile`命令查看函数文档。
- en: 'If we specify an additional `probs` parameter using a vector denoting cut points,
    we can obtain arbitrary quantiles, such as the 1^(st) and 99^(th) percentiles:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个指定切点的向量作为额外的`probs`参数，我们可以获取任意的分位数，比如第1和第99百分位数：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `seq()` function is used to generate vectors of evenly-spaced values. This
    makes it easy to obtain other slices of data, such as the quintiles (five groups),
    as shown in the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq()` 函数用于生成均匀间隔数值的向量。这使得获取其他数据片段变得简单，比如以下命令中显示的五分位数（五组）：'
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Equipped with an understanding of the five-number summary, we can re-examine
    the used car `summary()` output. On the `price` variable, the minimum was $3,800
    and the maximum was $21,992\. Interestingly, the difference between the minimum
    and Q1 is about $7,000, as is the difference between Q3 and the maximum; yet,
    the difference from Q1 to the median to Q3 is roughly $2,000\. This suggests that
    the lower and upper 25 percent of values are more widely dispersed than the middle
    50 percent of values, which seem to be more tightly grouped around the center.
    We see a similar trend with the `mileage` variable, which is not unsurprising.
    As you will learn later in this chapter, this pattern of spread is common enough
    that it has been called a "normal" distribution of data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了五数概括之后，我们可以重新检查二手车`summary()`输出。对于`price`变量，最小值是$3,800，最大值是$21,992。有趣的是，最小值到Q1之间的差异约为$7,000，Q3到最大值之间的差异也是如此；然而，从Q1到中位数再到Q3的差异大约为$2,000。这表明，值的下25%和上25%比中间50%的值更分散，似乎更紧密地聚集在中心周围。我们在`mileage`变量中也看到了类似的趋势，这并不令人惊讶。正如本章稍后将介绍的那样，这种数据分布的模式是常见的“正态”分布。
- en: 'The spread of the `mileage` variable also exhibits another interesting property:
    the difference between Q3 and the maximum value is far greater than that between
    the minimum value and Q1\. In other words, the larger values are far more spread
    out than the smaller values.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`mileage`变量的分布也展示了另一个有趣的特性：Q3与最大值之间的差距远大于最小值与Q1之间的差距。换句话说，较大的值比较小的值分布得更加分散。'
- en: This finding explains why the mean value is much greater than the median. Because
    the mean is sensitive to extreme values, it is pulled higher, while the median
    stays relatively in the same place. This is an important property, which becomes
    more apparent when the data is presented visually.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这一发现解释了为什么均值远大于中位数。由于均值对极端值敏感，它被拉得更高，而中位数保持相对不变。这是一个重要特性，尤其在数据以图形方式呈现时更为明显。
- en: Visualizing numeric variables – boxplots
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化数值变量 – 箱线图
- en: Visualizing numeric variables can be helpful in diagnosing data problems. A
    common visualization of the five-number summary is **boxplot**, also known as
    a **box-and-whiskers** plot. The boxplot displays the center and spread of a numeric
    variable in a format that allows you to quickly obtain a sense of the range and
    skew of a variable or compare it to other variables.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化数值变量有助于诊断数据问题。五数概括的常见可视化方式是**箱线图**，也称为**箱须图**。箱线图以一种可以让你快速了解变量的范围和偏态，或者将其与其他变量进行比较的格式展示了数值变量的中心位置和分布。
- en: 'Let''s take a look at a boxplot for the used car price and mileage data. To
    obtain a boxplot for a variable, we will use the `boxplot()` function. We will
    also specify a pair of extra parameters, `main` and `ylab`, to add a title to
    the figure and label the *y* axis (the vertical axis), respectively. The commands
    to create the `price` and `mileage` boxplots are:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下二手车价格和里程数据的箱线图。为了获取某个变量的箱线图，我们将使用`boxplot()`函数。我们还会指定一对额外的参数，`main`和`ylab`，分别为图形添加标题和标注*y*轴（纵轴）。创建`price`和`mileage`箱线图的命令如下：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'R will produce figures as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: R将生成如下图形：
- en: '![Visualizing numeric variables – boxplots](img/B03905_02_01.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![可视化数值变量 – 箱线图](img/B03905_02_01.jpg)'
- en: The box-and-whiskers plot depicts the five-number summary values using the horizontal
    lines and dots. The horizontal lines forming the box in the middle of each figure
    represent Q1, Q2 (the median), and Q3 while reading the plot from the bottom to
    the top. The median is denoted by the dark line, which lines up with $13,592 on
    the vertical axis for `price` and 36,385 mi. on the vertical axis for `mileage`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图通过水平线和点来展示五数概括的值。图形中间箱体的水平线表示Q1、Q2（中位数）和Q3，按从下到上的顺序阅读图表。中位数由深色线表示，在`price`的纵轴上与$13,592对齐，在`mileage`的纵轴上与36,385
    mi.对齐。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In simple boxplots such as those in the preceding diagram, the width of the
    box-and-whiskers plot is arbitrary and does not illustrate any characteristic
    of the data. For more sophisticated analyses, it is possible to use the shape
    and size of the boxes to facilitate comparisons of the data across several groups.
    To learn more about such features, begin by examining the `notch` and `varwidth`
    options in the R `boxplot()` documentation by typing the `?boxplot` command.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在像前图那样简单的箱线图中，箱体和胡须的宽度是任意的，并不反映数据的任何特征。对于更复杂的分析，可以通过箱体的形状和大小来比较多个组的数据。要了解这些功能，可以首先查看R语言`boxplot()`文档中的`notch`和`varwidth`选项，方法是键入`?boxplot`命令。
- en: The minimum and maximum values can be illustrated using the whiskers that extend
    below and above the box; however, a widely used convention only allows the whiskers
    to extend to a minimum or maximum of 1.5 times the IQR below Q1 or above Q3\.
    Any values that fall beyond this threshold are considered outliers and are denoted
    as circles or dots. For example, recall that the IQR for the `price` variable
    was 3,909 with a Q1 of 10,995 and a Q3 of 14,904\. An outlier is therefore any
    value that is less than *10995 - 1.5 * 3909= 5131.5* or greater than *14904 +
    1.5 * 3909 = 20767.5*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值和最大值可以通过延伸到箱体上下方的胡须来表示；然而，广泛使用的约定只允许胡须延伸到距离Q1下方或Q3上方1.5倍IQR的最小值或最大值。超出此阈值的任何值被认为是离群值，并以圆圈或点表示。例如，回想一下`price`变量的IQR为3909，Q1为10995，Q3为14904。因此，离群值是任何小于*10995
    - 1.5 * 3909 = 5131.5*或大于*14904 + 1.5 * 3909 = 20767.5*的值。
- en: The plot shows two such outliers on both the high and low ends. On the `mileage`
    boxplot, there are no outliers on the low end and thus, the bottom whisker extends
    to the minimum value, 4,867\. On the high end, we see several outliers beyond
    the 100,000 mile mark. These outliers are responsible for our earlier finding,
    which noted that the mean value was much greater than the median.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了在高端和低端都有两个此类异常值。在`mileage`箱线图中，低端没有异常值，因此底部的胡须延伸到最小值4,867。高端则出现了多个超过100,000英里标记的异常值。这些异常值是我们之前发现的原因，表明均值远大于中位数。
- en: Visualizing numeric variables – histograms
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化数值变量 – 直方图
- en: A **histogram** is another way to graphically depict the spread of a numeric
    variable. It is similar to a boxplot in a way that it divides the variable's values
    into a predefined number of portions or **bins** that act as containers for values.
    Their similarities end there, however. On one hand, a boxplot requires that each
    of the four portions of data must contain the same number of values, and widens
    or narrows the bins as needed. On the other hand, a histogram uses any number
    of bins of an identical width, but allows the bins to contain different number
    of values.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**直方图**是另一种图形化展示数值变量分布的方式。它与箱线图相似，因为它将变量的值划分为预定数量的部分或**区间**，这些区间充当值的容器。然而，它们的相似性仅止于此。一方面，箱线图要求数据的四个部分包含相同数量的值，并根据需要调整区间的宽度。另一方面，直方图使用任意数量的等宽区间，但允许每个区间包含不同数量的值。'
- en: 'We can create a histogram for the used car price and mileage data using the
    `hist()` function. As we did with the boxplot, we will specify a title for the
    figure using the `main` parameter, and label the *x* axis with the `xlab` parameter.
    The commands to create the histograms are:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`hist()`函数为二手车价格和里程数据创建直方图。就像我们在箱线图中做的那样，我们将使用`main`参数为图形指定标题，并使用`xlab`参数标记*X*轴。创建直方图的命令如下：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This produces the following diagram:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下图表：
- en: '![Visualizing numeric variables – histograms](img/B03905_02_02.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![可视化数值变量 – 直方图](img/B03905_02_02.jpg)'
- en: The histogram is composed of a series of bars with heights indicating the count,
    or **frequency** of values falling within each of the equal width bins partitioning
    the values. The vertical lines that separate the bars, as labeled on the horizontal
    axis, indicate the start and end points of the range of values for the bin.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该直方图由一系列条形图组成，每个条形的高度表示值在各个相等宽度的区间（**区间**）内的数量或**频率**。分隔条形的垂直线，如横轴上所标记的，表示每个区间的起始和结束位置。
- en: Tip
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may have noticed that the preceding histograms have a different number of
    bins. This is because the `hist()` function attempts to identify a reasonable
    number of bins for the variable's range. If you'd like to override this default,
    use the `breaks` parameter. Supplying an integer like `breaks = 10` would create
    exactly 10 bins of equal width; supplying a vector like `c(5000, 10000, 15000,
    20000)` would create bins that break at the specified values.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，前面的直方图有不同数量的区间。这是因为`hist()`函数会尝试为变量的范围确定一个合理的区间数量。如果你想覆盖这个默认值，可以使用`breaks`参数。传递一个整数值如`breaks
    = 10`将创建恰好10个等宽的区间；传递一个向量如`c(5000, 10000, 15000, 20000)`将创建在指定值处断开的区间。
- en: On the `price` histogram, each of the 10 bars spans an interval of $2,000, beginning
    at $2,000 and ending at $22,000\. The tallest bar at the center of the figure
    covers the $12,000 to $14,000 range and has a frequency of 50\. Since we know
    that our data includes 150 cars, we know that one-third of all the cars are priced
    from $12,000 to $14,000\. Nearly 90 cars—more than half—are priced from $12,000
    to $16,000.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`price`直方图中，10个柱状图中的每一个跨越一个$2,000的区间，从$2,000开始，到$22,000结束。图形中心的最高柱子覆盖$12,000到$14,000的范围，频率为50。由于我们知道数据包括150辆车，我们可以推断出三分之一的车辆价格在$12,000到$14,000之间。近90辆车——超过一半——的价格在$12,000到$16,000之间。
- en: The `mileage` histogram includes eight bars indicating bins of 20,000 miles
    each, beginning at 0 and ending at 160,000 miles. Unlike the price histogram,
    the tallest bar is not at the center of the data, but on the left-hand side of
    the diagram. The 70 cars contained in this bin have odometer readings from 20,000
    to 40,000 miles.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`mileage`直方图包括八个柱状图，每个柱状图表示20,000英里区间，从0开始，到160,000英里结束。与价格直方图不同，最高的柱状图不在数据的中心，而是在图表的左侧。这个区间内的70辆车的里程数从20,000到40,000英里不等。'
- en: 'You might also notice that the shape of the two histograms is somewhat different.
    It seems that the used car prices tend to be evenly divided on both sides of the
    middle, while the car mileages stretch further to the right. This characteristic
    is known as **skew**, or more specifically right skew, because the values on the
    high end (right side) are far more spread out than the values on the low end (left
    side). As shown in the following diagram, histograms of skewed data look stretched
    on one of the sides:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，两个直方图的形状有些不同。二手车的价格似乎在中间两侧比较均匀分布，而汽车的行驶里程则更多地集中在右侧。这种特征被称为**偏斜**，或者更具体地说是右偏，因为高端（右侧）的值比低端（左侧）的值分布得更广。如下面的图所示，偏斜数据的直方图在一侧看起来被拉长：
- en: '![Visualizing numeric variables – histograms](img/B03905_02_03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![可视化数值变量 – 直方图](img/B03905_02_03.jpg)'
- en: The ability to quickly diagnose such patterns in our data is one of the strengths
    of the histogram as a data exploration tool. This will become even more important
    as we start examining other patterns of spread in numeric data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 快速诊断数据中的这种模式是直方图作为数据探索工具的优点之一。随着我们开始检视数值数据中其他离散模式，这一点将变得更加重要。
- en: Understanding numeric data – uniform and normal distributions
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解数值数据 – 均匀分布和正态分布
- en: Histograms, boxplots, and statistics describing the center and spread provide
    ways to examine the distribution of a variable's values. A variable's **distribution**
    describes how likely a value is to fall within various ranges.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图、箱形图以及描述中心和离散度的统计量提供了检视变量值分布的方法。一个变量的**分布**描述了一个值在不同范围内出现的可能性。
- en: 'If all the values are equally likely to occur—say, for instance, in a dataset
    recording the values rolled on a fair six-sided die—the distribution is said to
    be **uniform**. A uniform distribution is easy to detect with a histogram, because
    the bars are approximately the same height. When visualized with a histogram,
    it may look something like the following diagram:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有值的出现概率相等——比如说，在记录公平六面骰子掷出的数值的数据集中——这种分布被称为**均匀分布**。均匀分布通过直方图很容易被检测到，因为条形大致相同高度。通过直方图可视化时，它可能看起来像下面的图：
- en: '![Understanding numeric data – uniform and normal distributions](img/B03905_02_04.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![理解数值数据 – 均匀分布和正态分布](img/B03905_02_04.jpg)'
- en: It's important to note that not all random events are uniform. For instance,
    rolling a weighted six-sided trick die would result in some numbers coming up
    more often than others. While each roll of the die results in a randomly selected
    number, they are not equally likely.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，并非所有的随机事件都是均匀分布的。例如，掷一颗加权的六面骰子会导致某些数字比其他数字更频繁地出现。虽然每次掷骰子的结果都是随机选出的数字，但它们并不是等概率的。
- en: 'Take, for instance, the used car data. This is clearly not uniform, since some
    values are seemingly far more likely to occur than others. In fact, on the price
    histogram, it seems that values grow less likely to occur as they are further
    away from both sides of the center bar, resulting in a bell-shaped distribution
    of data. This characteristic is so common in real-world data that it is the hallmark
    of the so-called **normal distribution**. The stereotypical bell-shaped curve
    of normal distribution is shown in the following diagram:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以二手车数据为例。这显然不是均匀分布，因为某些值的出现概率远高于其他值。实际上，在价格直方图中，值似乎越是远离中心条的两侧，出现的可能性就越小，从而形成了数据的钟形分布。这个特征在现实世界的数据中非常常见，它是所谓**正态分布**的标志。正态分布的典型钟形曲线如下面的图所示：
- en: '![Understanding numeric data – uniform and normal distributions](img/B03905_02_05.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![理解数值数据 – 均匀分布和正态分布](img/B03905_02_05.jpg)'
- en: Although there are numerous types of non-normal distributions, many real-world
    phenomena generate data that can be described by the normal distribution. Therefore,
    the normal distribution's properties have been studied in great detail.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在许多类型的非正态分布，但许多现实世界现象生成的数据可以用正态分布来描述。因此，正态分布的属性已经被深入研究。
- en: Measuring spread – variance and standard deviation
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量离散度 – 方差和标准差
- en: 'Distributions allow us to characterize a large number of values using a smaller
    number of parameters. The normal distribution, which describes many types of real-world
    data, can be defined with just two: center and spread. The center of normal distribution
    is defined by its mean value, which we have used earlier. The spread is measured
    by a statistic called the **standard deviation**.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 分布让我们能够使用更少的参数来表征大量的值。正态分布描述了许多类型的现实世界数据，它只需要两个参数来定义：中心和分布。正态分布的中心由它的平均值定义，我们之前已经使用过了。分布则通过一个叫做**标准差**的统计量来衡量。
- en: 'In order to calculate the standard deviation, we must first obtain the **variance**,
    which is defined as the average of the squared differences between each value
    and the mean value. In mathematical notation, the variance of a set of *n* values
    of *x* is defined by the following formula. The Greek letter *mu* (similar in
    appearance to an *m* or *u*) denotes the mean of the values, and the variance
    itself is denoted by the Greek letter *sigma* squared (similar to a *b* turned
    sideways):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算标准差，我们必须首先获得**方差**，它被定义为每个值与平均值之间差异的平方的平均值。用数学符号表示，一组*n*个*x*值的方差通过以下公式定义。希腊字母*mu*（看起来类似于*m*或*u*）表示值的平均数，而方差本身用希腊字母*sigma*的平方表示（看起来像是一个横着的*b*）：
- en: '![Measuring spread – variance and standard deviation](img/B03905_02_06.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![衡量分布 – 方差和标准差](img/B03905_02_06.jpg)'
- en: 'The standard deviation is the square root of the variance, and is denoted by
    *sigma*, as shown in the following formula:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差是方差的平方根，用*sigma*表示，如下公式所示：
- en: '![Measuring spread – variance and standard deviation](img/B03905_02_07.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![衡量分布 – 方差和标准差](img/B03905_02_07.jpg)'
- en: 'The `var()` and `sd()` functions can be used to obtain the variance and standard
    deviation in R. For example, computing the variance and standard deviation on
    our `price` and `mileage` variables, we find:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`var()`和`sd()`函数可以用来获取R中的方差和标准差。例如，计算我们`price`和`mileage`变量的方差和标准差，结果如下：'
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: While interpreting the variance, larger numbers indicate that the data are spread
    more widely around the mean. The standard deviation indicates, on average, how
    much each value differs from the mean.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释方差时，较大的数值表示数据在平均值周围的分布较广。标准差则表示每个值与平均值之间的差异程度。
- en: Tip
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you compute these statistics by hand using the formulas in the preceding
    diagrams, you will obtain a slightly different result than the built-in R functions.
    This is because the preceding formulae use the population variance (which divides
    by *n*), while R uses the sample variance (which divides by *n - 1*). Except for
    very small datasets, the distinction is minor.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动使用前面图示中的公式来计算这些统计数据，你会得到一个与内建的R函数稍有不同的结果。这是因为前面的公式使用了总体方差（它除以*n*），而R使用了样本方差（它除以*n
    - 1*）。除了非常小的数据集外，这个区别是微小的。
- en: 'The standard deviation can be used to quickly estimate how extreme a given
    value is under the assumption that it came from a normal distribution. The **68-95-99.7
    rule** states that 68 percent of the values in a normal distribution fall within
    one standard deviation of the mean, while 95 percent and 99.7 percent of the values
    fall within two and three standard deviations, respectively. This is illustrated
    in the following diagram:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差可以用来快速估算给定值在假设它来自正态分布的情况下有多极端。**68-95-99.7规则**指出，正态分布中68%的值落在平均值一个标准差的范围内，而95%和99.7%的值分别落在两个和三个标准差的范围内。如下图所示：
- en: '![Measuring spread – variance and standard deviation](img/B03905_02_08.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![衡量分布 – 方差和标准差](img/B03905_02_08.jpg)'
- en: Applying this information to the used car data, we know that since the mean
    and standard deviation of `price` were $12,962 and $3,122, respectively, assuming
    that the prices are normally distributed, approximately 68 percent of cars in
    our data were advertised at prices between *$12,962 - $3,122 = $9,840* and *$12,962
    + $3,122 = $16,804*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些信息应用于二手车数据，我们知道，由于`price`的平均值和标准差分别为12,962美元和3,122美元，假设价格呈正态分布，那么我们数据中大约68%的车的价格在*12,962美元
    - 3,122美元 = 9,840美元* 和 *12,962美元 + 3,122美元 = 16,804美元* 之间。
- en: Tip
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although, strictly speaking, the 68-95-99.7 rule only applies to normal distributions,
    the basic principle applies to any data; values more than three standard deviations
    away from the mean are exceedingly rare events.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，68-95-99.7 法则仅适用于正态分布，但基本原则适用于任何数据；与均值相差超过三个标准差的值是极为罕见的事件。
- en: Exploring categorical variables
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索类别变量
- en: 'If you recall, the used car dataset had three categorical variables: `model`,
    `color`, and `transmission`. Because we used the `stringsAsFactors = FALSE` parameter
    while loading the data, R has left them as the `character` (`chr`) type vectors
    rather than automatically converting them into `factor` type. Additionally, we
    might consider treating the year variable as categorical; although it has been
    loaded as a `numeric` (`int`) type vector, each year is a category that could
    apply to multiple cars.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，二手车数据集有三个类别变量：`model`、`color` 和 `transmission`。由于在加载数据时我们使用了 `stringsAsFactors
    = FALSE` 参数，R 将它们保留为 `character`（`chr`）类型向量，而不是自动将它们转换为 `factor` 类型。此外，我们可能考虑将年份变量视为类别变量；尽管它已作为
    `numeric`（`int`）类型向量加载，但每个年份都是可以应用于多辆车的类别。
- en: 'In contrast to `numeric` data, categorical data is typically examined using
    tables rather than summary statistics. A table that presents a single categorical
    variable is known as a **one-way table**. The `table()` function can be used to
    generate one-way tables for our used car data:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `numeric` 数据不同，类别数据通常通过表格而不是摘要统计量进行检查。呈现单个类别变量的表格称为 **单向表格**。可以使用 `table()`
    函数为我们的二手车数据生成单向表格：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `table()` output lists the categories of the nominal variable and a count
    of the number of values falling into this category. Since we know that there are
    150 used cars in the dataset, we can determine that roughly one-third of all the
    cars were manufactured in the year `2010`, given that *49/150 = 0.327*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`table()` 输出列出了名义变量的类别以及落入该类别的值的计数。由于我们知道数据集中有 150 辆二手车，因此可以确定大约三分之一的所有汽车是在
    `2010` 年制造的，因为 *49/150 = 0.327*。'
- en: 'R can also perform the calculation of table proportions directly, by using
    the `prop.table()` command on a table produced by the `table()` function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: R 还可以通过对 `table()` 函数生成的表格使用 `prop.table()` 命令，直接计算表格比例：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The results of `prop.table()` can be combined with other R functions to transform
    the output. Suppose that we would like to display the results in percentages with
    a single decimal place. We can do this by multiplying the proportions by 100,
    then using the `round()` function while specifying `digits = 1`, as shown in the
    following example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`prop.table()` 的结果可以与其他 R 函数结合使用，以转换输出。假设我们希望以单个小数位显示结果。我们可以通过将比例乘以 100，然后使用
    `round()` 函数并指定 `digits = 1` 来实现，如下例所示：'
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Although this includes the same information as the default `prop.table()` output,
    this is easier to read. The results show that black is the most common color,
    since nearly a quarter (23.3 percent) of all the advertised cars are `Black`.
    `Silver` is a close second with 21.3 percent and `Red` is third with 16.7 percent.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这与默认的 `prop.table()` 输出包含相同的信息，但这种格式更易读。结果显示，黑色是最常见的颜色，因为几乎四分之一（23.3%）的广告车是
    `Black`。`Silver` 紧随其后，占 21.3%，`Red` 排名第三，占 16.7%。
- en: Measuring the central tendency – the mode
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 衡量集中趋势——众数
- en: In statistics terms, the **mode** of a feature is the value occurring most often.
    Like the mean and median, the mode is another measure of central tendency. It
    is often used for categorical data, since the mean and median are not defined
    for nominal variables.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从统计学的角度来看，**众数**是出现频率最高的值。像均值和中位数一样，众数也是一种集中趋势的度量。它通常用于类别数据，因为均值和中位数对于名义变量是无法定义的。
- en: For example, in the used car data, the mode of the `year` variable is 2010,
    while the modes for the `model` and `color` variables are `SE` and `Black`, respectively.
    A variable may have more than one mode; a variable with a single mode is **unimodal**,
    while a variable with two modes is **bimodal**. Data having multiple modes is
    more generally called **multimodal**.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在二手车数据中，`year` 变量的众数是 2010，而 `model` 和 `color` 变量的众数分别是 `SE` 和 `Black`。一个变量可能有多个众数；具有单一众数的变量称为
    **单峰**，具有两个众数的变量称为 **双峰**。具有多个众数的数据通常称为 **多峰**。
- en: Tip
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although you might suspect that you could use the `mode()` function, R uses
    this to obtain the type of variable (as in `numeric`, `list`, and so on) rather
    than the statistical mode. Instead, to find the statistical mode, simply look
    at the table output of the category with the greatest number of values.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能怀疑可以使用 `mode()` 函数，R 语言使用它来获取变量的类型（如 `numeric`、`list` 等），而不是统计学中的众数。相反，要找到统计学中的众数，只需查看类别表格输出中出现次数最多的值。
- en: The mode or modes are used in a qualitative sense to gain an understanding of
    important values. Yet, it would be dangerous to place too much emphasis on the
    mode, since the most common value is not necessarily a majority. For instance,
    although `Black` was the most common value for the `color` variable, black cars
    were only about a quarter of all advertised cars.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 众数或众数们在定性意义上被用来理解重要值。然而，过于强调众数是危险的，因为最常见的值不一定是多数值。例如，尽管 `color` 变量中 `Black`
    是最常见的值，但黑色轿车仅占所有广告车的大约四分之一。
- en: It is best to think about modes in relation to the other categories. Is there
    one category that dominates all the others or are there several? From here, we
    may ask what the most common values tell us about the variable being measured.
    If black and silver are commonly used car colors, we might assume that the data
    are for luxury cars, which tend to be sold in more conservative colors. These
    colors could also indicate economy cars, which are sold with fewer color options.
    We will keep this question in mind as we continue to examine this data.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将众数与其他类别进行对比。是否有一个类别主导了其他所有类别，还是有几个类别？在这里，我们可以问，最常见的值告诉我们有关被测量变量的信息。如果黑色和银色是常见的汽车颜色，我们可能会假设数据是关于豪华车的，因为豪华车通常采用更加保守的颜色。这些颜色也可能表示经济型轿车，它们的颜色选择较少。在我们继续分析数据时，我们会保持这个问题在心。
- en: Thinking about modes as common values allows us to apply the concept of statistical
    mode to the numeric data. Strictly speaking, it would be unlikely to have a mode
    for a continuous variable, since no two values are likely to repeat. Yet, if we
    think about modes as the highest bars on a histogram, we can discuss the modes
    of variables such as `price` and `mileage`. It can be helpful to consider mode
    while exploring the numeric data, particularly to examine whether or not the data
    is multimodal.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将众数看作是常见值，允许我们将统计学中的众数概念应用于数值数据。严格来说，对于连续变量，几乎不可能有众数，因为两个值重复的可能性极小。然而，如果我们将众数看作直方图中的最高柱状条，就能讨论
    `price` 和 `mileage` 等变量的众数。在探索数值数据时，考虑众数是很有帮助的，尤其是在检查数据是否是多众数的情况下。
- en: '![Measuring the central tendency – the mode](img/B03905_02_09.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![衡量集中趋势 – 众数](img/B03905_02_09.jpg)'
- en: Exploring relationships between variables
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索变量之间的关系
- en: 'So far, we have examined variables one at a time, calculating only **univariate**
    statistics. During our investigation, we raised questions that we were unable
    to answer at that time:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经逐一检查了变量，只计算了**单变量**统计数据。在我们的调查过程中，我们提出了一些当时无法回答的问题：
- en: Does the `price` data imply that we are examining only economy-class cars or
    are there also luxury cars with high mileage?
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price` 数据是否意味着我们仅在研究经济型轿车，还是也有高里程的豪华车？'
- en: Do relationships between the `model` and `color` data provide insight into the
    types of cars we are examining?
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model` 和 `color` 数据之间的关系是否能为我们研究的汽车类型提供一些见解？'
- en: These type of questions can be addressed by looking at **bivariate** relationships,
    which consider the relationship between two variables. Relationships of more than
    two variables are called **multivariate** relationships. Let's begin with the
    bivariate case.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的问题可以通过查看**双变量**关系来解决，双变量关系考虑了两个变量之间的关系。超过两个变量的关系被称为**多变量**关系。让我们从双变量情况开始。
- en: Visualizing relationships – scatterplots
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化关系 – 散点图
- en: A **scatterplot** is a diagram that visualizes a bivariate relationship. It
    is a two-dimensional figure in which dots are drawn on a coordinate plane using
    the values of one feature to provide the horizontal *x* coordinates and the values
    of another feature to provide the vertical *y* coordinates. Patterns in the placement
    of dots reveal the underlying associations between the two features.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**散点图**是用来可视化双变量关系的图表。它是一个二维图形，点被绘制在坐标平面上，使用一个特征的值作为水平 *x* 坐标，另一个特征的值作为垂直 *y*
    坐标。点的分布模式揭示了两个特征之间的潜在关联。'
- en: To answer our question about the relationship between `price` and `mileage`,
    we will examine a scatterplot. We'll use the `plot()` function along with the
    `main`, `xlab` and `ylab` parameters used previously to label the diagram.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答我们关于`price`和`mileage`之间关系的问题，我们将检查散点图。我们将使用`plot()`函数，并结合之前用于标注图表的`main`、`xlab`和`ylab`参数。
- en: To use `plot()`, we need to specify `x` and `y` vectors containing the values
    used to position the dots on the figure. Although the conclusions would be the
    same regardless of the variable used to supply the *x* and *y* coordinates, convention
    dictates that the *y* variable is the one that is presumed to depend on the other
    (and is therefore known as the dependent variable). Since a seller cannot modify
    the odometer reading, mileage is unlikely to be dependent on the car's price.
    Instead, our hypothesis is that the price depends on the odometer mileage. Therefore,
    we will use `price` as the *y*, or dependent, variable.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`plot()`，我们需要指定包含用于确定图中点位置的`x`和`y`向量。尽管无论使用哪个变量来提供*x*和*y*坐标，结论都将相同，但惯例规定*y*变量是假定依赖于其他变量的（因此被称为因变量）。由于卖家无法修改里程表读数，因此里程不太可能依赖于汽车的价格。相反，我们的假设是价格依赖于里程表读数。因此，我们将使用`price`作为*y*或因变量。
- en: 'The full command to create our scatterplot is:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们散点图的完整命令是：
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This results in the following scatterplot:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下散点图：
- en: '![Visualizing relationships – scatterplots](img/B03905_02_10.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![可视化关系 – 散点图](img/B03905_02_10.jpg)'
- en: Using the scatterplot, we notice a clear relationship between the price of a
    used car and the odometer reading. To read the plot, examine how values of the
    *y* axis variable change as the values on the *x* axis increase. In this case,
    car prices tend to be lower as the mileage increases. If you have ever sold or
    shopped for a used car, this is not a profound insight.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用散点图时，我们注意到二手车价格和里程表读数之间存在明确的关系。要读取图表，请检查当*x*轴的值增大时，*y*轴变量的值如何变化。在这种情况下，随着里程的增加，汽车价格趋向于下降。如果你曾经出售或购买过二手车，你一定能体会到这一点。
- en: Perhaps a more interesting finding is the fact that there are very few cars
    that have both high price and high mileage, aside from a lone outlier at about
    125,000 miles and $14,000\. The absence of more points like this provides evidence
    to support a conclusion that our data is unlikely to include any high mileage
    luxury cars. All of the most expensive cars in the data, particularly those above
    $17,500, seem to have extraordinarily low mileage, implying that we could be looking
    at a brand new type of car retailing for about $20,000.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 也许一个更有趣的发现是，几乎没有汽车既有高价格又有高里程，除了一个大约125,000英里和14,000美元的孤立点。缺乏更多类似的点为我们提供了证据，支持我们的结论，即数据中不太可能包含高里程的豪华车。数据中所有最贵的汽车，特别是那些价格超过17,500美元的，似乎都有异常低的里程，这意味着我们可能在看一种零售价格约为20,000美元的新车。
- en: The relationship we've found between car prices and mileage is known as a negative
    association, because it forms a pattern of dots in a line sloping downward. A
    positive association would appear to form a line sloping upward. A flat line,
    or a seemingly random scattering of dots, is evidence that the two variables are
    not associated at all. The strength of a linear association between two variables
    is measured by a statistic known as **correlation**. Correlations are discussed
    in detail in [Chapter 6](ch06.html "Chapter 6. Forecasting Numeric Data – Regression
    Methods"), *Forecasting Numeric Data – Regression Methods*, which covers the methods
    for modeling linear relationships.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现的汽车价格和里程之间的关系被称为负相关，因为它形成了一个向下倾斜的直线状数据点模式。正相关则会形成一个向上倾斜的直线。平坦的直线或看似随机分散的数据点表明这两个变量之间没有任何关联。两个变量之间线性关系的强度通过一个称为**相关性**的统计量来衡量。相关性在[第6章](ch06.html
    "Chapter 6. Forecasting Numeric Data – Regression Methods")《预测数值数据–回归方法》中有详细讨论，该章节介绍了建模线性关系的方法。
- en: Tip
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that not all associations form straight lines. Sometimes the dots
    form a *U* shape, or a *V* shape; sometimes the pattern seems to be weaker or
    stronger for increasing values of the `x` or `y` variable. Such patterns imply
    that the relationship between the two variables is not linear.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，并非所有的关联都形成直线。有时候，数据点会形成一个*U*形状，或者*V*形状；有时候，随着`x`或`y`变量的增大，模式可能会显得更弱或更强。这些模式表明两个变量之间的关系并非线性。
- en: Examining relationships – two-way cross-tabulations
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查关系 – 双向交叉表
- en: To examine a relationship between two nominal variables, a **two-way cross-tabulation**
    is used (also known as a **crosstab** or **contingency table**). A cross-tabulation
    is similar to a scatterplot in that it allows you to examine how the values of
    one variable vary by the values of another. The format is a table in which the
    rows are the levels of one variable, while the columns are the levels of another.
    Counts in each of the table's cells indicate the number of values falling into
    the particular row and column combination.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检验两个名义变量之间的关系，使用**双向列联表**（也称为**列联表**或**列联表格**）。列联表类似于散点图，它可以帮助你检视一个变量的值如何随另一个变量的值变化。其格式为一个表格，其中行表示一个变量的各个水平，而列表示另一个变量的各个水平。表格中每个单元格的计数值表示该行和该列组合所对应的值的数量。
- en: 'To answer our earlier question about whether there is a relationship between
    car `model` and `color`, we will examine a crosstab. There are several functions
    to produce two-way tables in R, including `table()`, which we used for one-way
    tables. The `CrossTable()` option in the `gmodels` package by Gregory R. Warnes
    is perhaps the most user-friendly function, as it presents the row, column, and
    margin percentages in a single table, saving us the trouble of combining this
    data ourselves. To install the `gmodels` package, type:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答我们之前提出的关于汽车`model`（型号）和`color`（颜色）之间是否存在关系的问题，我们将检查列联表。在R中，有多个函数可以生成双向表格，包括我们用来生成单向表格的`table()`。`gmodels`包中的`CrossTable()`选项由Gregory
    R. Warnes编写，可能是最易于使用的函数，因为它将行、列和边际百分比都呈现在一个表格中，节省了我们自己合并这些数据的麻烦。要安装`gmodels`包，输入：
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After the package installs, type `library(gmodels)` to load the package. You
    will need to do this during each R session in which you plan on using the `CrossTable()`
    function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在包安装完成后，输入`library(gmodels)`来加载该包。在每次使用`CrossTable()`函数的R会话中，你都需要执行此操作。
- en: 'Before proceeding with our analysis, let''s simplify our project by reducing
    the number of levels in the `color` variable. This variable has nine levels, but
    we don''t really need this much detail. What we are really interested in is whether
    or not the car''s color is conservative. Toward this end, we''ll divide the nine
    colors into two groups: the first group will include the conservative colors `Black`,
    `Gray`, `Silver`, and `White`; and the second group will include `Blue`, `Gold`,
    `Green`, `Red`, and `Yellow`. We will create a binary indicator variable (often
    called a **dummy variable**), indicating whether or not the car''s color is conservative
    by our definition. Its value will be `1` if true, `0` otherwise:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行分析之前，让我们通过减少`color`变量的水平数量来简化项目。该变量有九个水平，但我们不需要这么多细节。我们真正关心的是汽车颜色是否为保守色。为此，我们将九种颜色分为两组：第一组包括保守色`Black`（黑色）、`Gray`（灰色）、`Silver`（银色）和`White`（白色）；第二组包括`Blue`（蓝色）、`Gold`（金色）、`Green`（绿色）、`Red`（红色）和`Yellow`（黄色）。我们将创建一个二元指示变量（通常称为**虚拟变量**），表示汽车颜色是否符合我们定义的保守色。若为保守色，值为`1`，否则为`0`：
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You may have noticed a new command here: the `%in%` operator returns `TRUE`
    or `FALSE` for each value in the vector on the left-hand side of the operator
    depending on whether the value is found in the vector on the right-hand side.
    In simple terms, you can translate this line as "Is the used car color in the
    set of `Black`, `Gray`, `Silver`, and `White`?"'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能已经注意到一个新命令：`%in%`运算符会返回`TRUE`或`FALSE`，取决于运算符左侧向量中的每个值是否在右侧向量中找到。简单来说，可以将这行代码理解为“该汽车颜色是否属于`Black`（黑色）、`Gray`（灰色）、`Silver`（银色）和`White`（白色）这一集合？” '
- en: 'Examining the `table()` output for our newly created variable, we see that
    about two-thirds of the cars have conservative colors, while one-third do not
    have conservative colors:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们新创建的变量的`table()`输出，我们看到约三分之二的汽车颜色为保守色，而三分之一的汽车颜色则不是保守色：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let''s look at a cross-tabulation to see how the proportion of conservatively
    colored cars varies by the model. Since we''re assuming that the model of the
    car dictates the choice of color, we''ll treat the conservative color indicator
    as the dependent (`y`) variable. The `CrossTable()` command is therefore:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看一个列联表，了解保守色彩的汽车比例如何随车型变化。由于我们假设汽车的型号决定了颜色的选择，因此我们将保守色彩指示器视为因变量（`y`）。因此，`CrossTable()`命令如下：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The preceding command results in the following table:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将生成以下表格：
- en: '![Examining relationships – two-way cross-tabulations](img/B03905_02_11.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![检视关系 – 双向列联表](img/B03905_02_11.jpg)'
- en: 'There is a wealth of data in the `CrossTable()` output. The legend at the top
    (labeled `Cell Contents`) indicates how to interpret each value. The rows in the
    table indicate the three models of used cars: `SE`, `SEL`, and `SES` (plus an
    additional row for the total across all models). The columns indicate whether
    or not the car''s color is conservative (plus a column totaling across both types
    of color). The first value in each cell indicates the number of cars with that
    combination of model and color. The proportions indicate that the cell''s proportion
    is relative to the chi-square statistic, row''s total, column''s total, and table''s
    total.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrossTable()`输出中包含了大量数据。顶部的图例（标记为`Cell Contents`）表示如何解释每个值。表格的行表示三种二手车模型：`SE`、`SEL`和`SES`（以及表示所有车型总和的附加行）。列表示车辆的颜色是否为保守色（并且还有一列显示两种颜色类型的总和）。每个单元格中的第一个值表示具有该车型和颜色组合的车辆数量。比例表示该单元格的比例是相对于卡方统计量、行总数、列总数和表格总数的。'
- en: What we are most interested in is the row proportion for conservative cars for
    each model. The row proportions tell us that 0.654 (65 percent) of `SE` cars are
    colored conservatively in comparison to 0.696 (70 percent) of `SEL` cars and 0.653
    (65 percent) of `SES`. These differences are relatively small, suggesting that
    there are no substantial differences in the types of colors chosen by the model
    of the car.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最感兴趣的是每个车型中保守色车的行比例。行比例告诉我们，`SE`车型中有0.654（65％）的车辆是保守色的，相比之下，`SEL`车型中有0.696（70％）的车辆是保守色，`SES`车型中则为0.653（65％）。这些差异相对较小，表明不同车型之间在选择颜色类型上没有实质性的差异。
- en: The chi-square values refer to the cell's contribution in the **Pearson's Chi-squared
    test for independence** between two variables. This test measures how likely it
    is that the difference in the cell counts in the table is due to chance alone.
    If the probability is very low, it provides strong evidence that the two variables
    are associated.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方值指的是**皮尔逊卡方独立性检验**中每个单元格的贡献。该检验衡量的是表格中单元格计数差异仅由偶然因素造成的可能性。如果概率非常低，则提供了强有力的证据，表明这两个变量之间存在关联。
- en: You can obtain the chi-squared test results by adding an additional parameter
    specifying `chisq = TRUE` while calling the `CrossTable()` function. In this case,
    the probability is about 93 percent, suggesting that it is very likely that the
    variations in cell count are due to chance alone and not due to a true association
    between the model and the color.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在调用`CrossTable()`函数时添加额外的参数`chisq = TRUE`来获得卡方检验结果。在这种情况下，概率约为93％，这表明单元格计数的变化很可能仅由偶然因素造成，而不是由于车型和颜色之间的真正关联。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the basics of managing data in R. We started
    by taking an in-depth look at the structures used for storing various types of
    data. The foundational R data structure is the vector, which is extended and combined
    into more complex data types such as lists and data frames. The data frame is
    an R data structure that corresponds to the notion of a dataset, having both features
    and examples. R provides functions for reading and writing data frames to spreadsheet-like
    tabular data files.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们学习了在R中管理数据的基础知识。我们首先深入了解了用于存储各种类型数据的结构。R的基础数据结构是向量，它被扩展并组合成更复杂的数据类型，如列表和数据框。数据框是R中的数据结构，类似于数据集的概念，既有特征也有样本。R提供了读取和写入数据框的函数，可以将数据存储为类似电子表格的表格数据文件。
- en: We then explored a real-world dataset containing data on used car prices. We
    examined numeric variables using common summary statistics of center and spread,
    and visualized relationships between prices and odometer readings with a scatterplot.
    We examined nominal variables using tables. In examining the used car data, we
    followed an exploratory process that can be used to understand any dataset. These
    skills will be required for the other projects throughout this book.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了一个包含二手车价格数据的真实数据集。我们使用常见的汇总统计量（如集中趋势和离散程度）来分析数值变量，并通过散点图可视化了价格与里程表读数之间的关系。我们使用表格分析了名义变量。在分析二手车数据时，我们遵循了一种探索性过程，这种过程可用于理解任何数据集。这些技能将在本书的其他项目中得到应用。
- en: Now that we have spent some time understanding the basics of data management
    with R, you are ready to begin using machine learning to solve real-world problems.
    In the next chapter, we will tackle our first classification task using nearest
    neighbor methods.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经花了一些时间了解了 R 的数据管理基础，你已经准备好开始使用机器学习来解决现实世界的问题了。在下一章中，我们将使用最近邻方法解决我们的第一个分类任务。
