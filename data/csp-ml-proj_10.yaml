- en: Credit Card Fraud Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信用卡欺诈检测
- en: In the previous chapter, we built our first anomaly detection model using **Principal
    Component Analysis** (**PCA**) and saw how we can detect cyber attacks using principal
    components. Similar to cyber attack or network intrusion problems, anomaly detection
    models are frequently used for fraud detection. Various organizations in many
    industries, such as financial services, insurance companies, and government agencies,
    often come across fraudulent cases. Especially in financial sectors, frauds are
    directly related to monetary losses and these fraudulent cases can come in many
    different guises, such as stolen credit cards, accounting forgeries, or fake checks.
    Because these events occur relatively rarely, it is difficult and tricky to detect
    these fraudulent cases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用**主成分分析（PCA**）构建了我们的第一个异常检测模型，并看到了如何使用主成分来检测网络攻击。与网络攻击或网络入侵问题类似，异常检测模型常用于欺诈检测。许多行业中的各种组织，如金融服务、保险公司和政府机构，经常遇到欺诈案例。特别是在金融领域，欺诈直接与货币损失相关，这些欺诈案例可以以许多不同的形式出现，例如被盗信用卡、会计伪造或假支票。因为这些事件相对较少发生，检测这些欺诈案例既困难又棘手。
- en: In this chapter, we are going to discuss how we can build an anomaly detection
    model for credit card fraud detection. We are going to use an anonymized credit
    card dataset that contains a large portion of normal credit card transactions
    and relatively fewer fraudulent credit card transactions. We will first look at
    the structure of the dataset, the distribution of the target classes, and the
    distributions of various anonymized features. Then, we are going to start applying
    PCA and building standardized principal components that will be used as features
    for our fraud detection model. In the model building step, we are going to experiment
    with two different approaches to building fraud detection models—the **Principal
    Component Classifier** (**PCC**) that is similar to what we built in [Chapter
    9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber Attack Detection*
    and the one-class **Support Vector Machine** (**SVM**) that learns from normal
    credit card transactions and detects any anomalies. With these models built, we
    are going to evaluate their anomaly detection rates and compare their performances
    for credit card fraud detection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何构建一个用于信用卡欺诈检测的异常检测模型。我们将使用一个包含大量正常信用卡交易和相对较少欺诈信用卡交易的匿名信用卡数据集。我们首先将查看数据集的结构、目标类别的分布以及各种匿名特征的分布。然后，我们将开始应用主成分分析（PCA）并构建标准化的主成分，这些主成分将被用作我们的欺诈检测模型的特征。在模型构建步骤中，我们将尝试两种不同的构建欺诈检测模型的方法——类似于我们在第9章中构建的**主成分分类器（PCC**），即*网络攻击检测*，以及从正常信用卡交易中学习并检测任何异常的单类**支持向量机（SVM**）。构建了这些模型后，我们将评估它们的异常检测率并比较它们在信用卡欺诈检测中的性能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Problem definition for the credit card fraud detection project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信用卡欺诈检测项目的定义问题
- en: Data analysis for the anonymized credit card dataset
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名信用卡数据集的数据分析
- en: Feature engineering and PCA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征工程和PCA
- en: The one-class SVM versus the PCC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单类SVM与PCC的比较
- en: Evaluating anomaly detection models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估异常检测模型
- en: Problem definition
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题定义
- en: Credit card fraud is relatively common among other fraudulent events, and can
    happen in our daily lives. There are various ways credit card fraud can happen.
    Credit cards can be lost or stolen and then used by a thief. Another way credit
    card fraud can occur is that your identity might have been exposed to malicious
    persons who then use your identity to open a new credit card account, or even
    take over your existing credit card accounts. Scammers can even use telephone
    phishing for credit card fraud. As there are many ways credit card fraud can happen,
    many credit card holders are exposed to the risk of this type of fraud, and having
    a proper way to prevent them from happening has become essential in our daily
    lives. Many credit card companies have employed various measures to prevent and
    detect these types of fraudulent activities, using various **machine learning**
    (**ML**) and anomaly-detection technologies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 信用卡欺诈在其他欺诈事件中相对较为常见，并且可能发生在我们的日常生活中。信用卡欺诈可能发生的各种方式。信用卡可能会丢失或被盗，然后被窃贼使用。另一种信用卡欺诈可能发生的方式是，你的身份可能已经被恶意人员泄露，然后他们使用你的身份开设新的信用卡账户，甚至接管你现有的信用卡账户。骗子甚至可能使用电话钓鱼进行信用卡欺诈。由于信用卡欺诈可能发生的途径很多，许多信用卡持卡人都面临着这种类型欺诈的风险，因此在我们日常生活中有一种适当的方法来预防它们的发生变得至关重要。许多信用卡公司已经采取了各种措施来预防和检测这些类型的欺诈活动，使用了各种**机器学习**（**ML**）和异常检测技术。
- en: 'In this chapter, we are going to work on building a credit card fraud detection
    model by using and expanding our knowledge about building anomaly detection models.
    We will be using an anonymized credit card dataset that can be found at the following
    link: [https://www.kaggle.com/mlg-ulb/creditcardfraud/data](https://www.kaggle.com/mlg-ulb/creditcardfraud/data).
    This dataset has about 285,000 credit card transactions, and only about 0.17%
    of those transactions are fraudulent transactions, which reflects a real-life
    situation very well. With this data, we are going to look at how the dataset is
    structured, and then start looking at the distributions of the target and feature
    variables. Then, we will be building features by using PCA, similar to what we
    did in [Chapter 9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber
    Attack Detection*. For building credit card fraud detection models, we are going
    to experiment with both the PCC, similar to the one we built in [Chapter 9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber
    Attack Detection*, and the one-class SVM, which learns from normal credit card
    transactions and decides whether a new transaction is fraudulent or not. Lastly,
    we are going to look at false alarm and fraud detection rates to evaluate and
    compare the performances of these models.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过运用和扩展我们关于构建异常检测模型的知识来构建信用卡欺诈检测模型。我们将使用一个可以在以下链接中找到的匿名信用卡数据集：[https://www.kaggle.com/mlg-ulb/creditcardfraud/data](https://www.kaggle.com/mlg-ulb/creditcardfraud/data)。这个数据集大约有285,000笔信用卡交易，其中只有大约0.17%的交易是欺诈交易，这很好地反映了现实生活中的情况。有了这些数据，我们将研究数据集的结构，然后开始研究目标和特征变量的分布。然后，我们将使用PCA构建特征，类似于我们在第9章中做的，即*网络攻击检测*。在构建信用卡欺诈检测模型时，我们将尝试使用PCC，类似于我们在第9章中构建的，即*网络攻击检测*，以及单类SVM，它从正常的信用卡交易中学习并决定一笔新交易是否为欺诈。最后，我们将查看误报率和欺诈检测率，以评估和比较这些模型的性能。
- en: 'To summarize our problem definition for the credit card fraud detection project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结我们的信用卡欺诈检测项目的问题定义：
- en: What is the problem? We need an anomaly detection model for fraudulent credit
    card transactions that can identify, prevent, and stop potential fraudulent credit
    card activities.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题是什么？我们需要一个异常检测模型来识别、预防和阻止潜在的欺诈性信用卡交易。
- en: Why is it a problem? Every credit card holder is exposed to the risks of becoming
    the victim of credit card fraud, and without being properly prepared for such
    malicious attempts, the number of credit card fraud victims is going to increase.
    With a credit card fraud detection model, we can prevent and stop potential fraudulent
    credit card transactions from happening.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么这是一个问题？每个信用卡持卡人都面临着成为信用卡欺诈受害者的风险，如果没有为这种恶意尝试做好充分准备，信用卡欺诈受害者的数量将会增加。通过信用卡欺诈检测模型，我们可以预防和阻止潜在的欺诈性信用卡交易发生。
- en: What are some of the approaches to solving this problem? We are going to use
    anonymized credit card data that is publicly available, and has lots of normal
    credit card transactions and a small number of fraudulent transactions. We are
    going to apply PCA to this data and experiment with the PCC and the one-class
    SVM models for fraud detection.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决这个问题的方法有哪些？我们将使用公开可用的匿名信用卡数据，这些数据包含大量的正常信用卡交易和少量欺诈交易。我们将对此数据应用PCA，并尝试使用PCC和单类SVM模型进行欺诈检测。
- en: What are the success criteria? Since any credit card fraud event will result
    in monetary loss, we want a high fraud detection rate. Even if there are some
    false positives or false alarms, it is better to flag any suspicious credit card
    activities to prevent any fraudulent transactions from going through.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功的标准是什么？由于任何信用卡欺诈事件都会导致经济损失，我们希望有高欺诈检测率。即使有一些误报或误警，也最好标记任何可疑的信用卡活动，以防止任何欺诈交易通过。
- en: Data analysis for anonymized credit card data
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名信用卡数据的数据分析
- en: Let's now start looking at the credit card dataset. As mentioned before, we
    are going to use the dataset that is available at the following link: [https://www.kaggle.com/mlg-ulb/creditcardfraud/data](https://www.kaggle.com/mlg-ulb/creditcardfraud/data).
    It is a dataset that contains about 285,000 records of credit card transactions,
    where some of them are fraudulent transactions and the majority of the records
    are normal credit card transactions. Due to confidentiality issues, the feature
    names in the dataset are anonymized. We will be using the `creditcard.csv` file,
    which can be downloaded from the link.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始查看信用卡数据集。如前所述，我们将使用以下链接提供的可用数据集：[https://www.kaggle.com/mlg-ulb/creditcardfraud/data](https://www.kaggle.com/mlg-ulb/creditcardfraud/data)。这是一个包含大约285,000条信用卡交易记录的数据集，其中一些是欺诈交易，而大多数记录是正常的信用卡交易。由于保密问题，数据集中的特征名称被匿名化。我们将使用可以从中下载的`creditcard.csv`文件。
- en: Target variable distribution
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标变量分布
- en: 'The first thing we are going to examine is the distribution of fraudulent and
    non-fraudulent credit card transactions in the dataset. In the dataset, the column
    named `Class` is the target variable that is encoded with `1` for fraudulent credit
    card transactions and `0` for non-fraudulent transactions. You can use the following
    code to first load the data into a Deedle data frame:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一件事是数据集中欺诈和非欺诈信用卡交易的分发情况。在数据集中，名为`Class`的列是目标变量，欺诈信用卡交易用`1`编码，非欺诈交易用`0`编码。你可以使用以下代码首先将数据加载到Deedle数据框中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This dataset has headers that represent each of the features and the target
    class, so we are loading this data with the `hasHeaders: true` flag. Now that
    we have the data loaded, you can use the following code to analyze the distribution
    of the target classes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '这个数据集有标题，代表每个特征和目标类，因此我们使用`hasHeaders: true`标志加载此数据。现在数据已经加载，你可以使用以下代码来分析目标类的分布：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you might be familiar with this function already, we are using the `AggregateRowsBy`
    function in a Deedle data frame to group rows by the column `Class`, and then
    count the number of records in each target class. Since the column name, `Class`,
    is not a good representative of what our target class is and what it means, we
    renamed it with another name, `is_fraud`. As you can see from this code, you can
    use the `RenameColumns` function with an array of strings for new column names
    to rename the feature names. Lastly, we used the `DataBarBox` class in the Accord.NET
    framework to display a bar plot that visually shows the distributions of the target
    classes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可能已经熟悉这个函数了，我们在Deedle数据框中使用`AggregateRowsBy`函数按`Class`列分组行，然后计算每个目标类中的记录数。由于列名`Class`并不能很好地代表我们的目标类及其含义，我们将其重命名为另一个名称，`is_fraud`。从这段代码中你可以看到，你可以使用`RenameColumns`函数和一个字符串数组来重命名特征名称。最后，我们使用了Accord.NET框架中的`DataBarBox`类来显示一个条形图，该图可以直观地展示目标类的分布。
- en: 'The following output shows the distribution of the target classes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了目标类的分布：
- en: '![](img/00163.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00163.jpeg)'
- en: As you can see from this output, there is a large gap between the number of
    fraudulent credit card transactions and non-fraudulent credit card transactions.
    We only have 492 records of frauds and over 284,000 records of non-frauds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以看出，欺诈信用卡交易和非欺诈信用卡交易的数目之间存在很大的差距。我们只有492条欺诈记录，而超过284,000条非欺诈记录。
- en: 'The following is a bar plot that the code generates for visually displaying
    the distribution of target classes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由代码生成的用于直观显示目标类别分布的条形图：
- en: '![](img/00164.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00164.jpeg)'
- en: As expected from the previous output, there is a large gap between the number
    of records that belong to the target class, **1**, which represents fraud, and
    the number of records that belong to the target class, **0**, which represents
    non-fraud and normal credit card transactions. This large gap is expected as credit
    card frauds happen relatively rarely, compared to the large number of normal everyday
    credit card transactions. This large class imbalance makes it difficult for most
    ML models to accurately learn how to identify frauds from non-frauds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述输出所预期，属于目标类别**1**（代表欺诈）的记录数量与属于目标类别**0**（代表非欺诈和正常信用卡交易）的记录数量之间存在很大的差距。由于与大量正常的日常信用卡交易相比，信用卡欺诈相对较少，这种大的类别不平衡是预期的。这种大的类别不平衡使得大多数机器学习模型难以准确学习如何从非欺诈中识别欺诈。
- en: Feature distributions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征分布
- en: The features, except for the transactional amounts, we have in this data are
    anonymized due to confidentiality issues. Because we do not know what each feature
    represents and what each feature means, it will be difficult to deduce any intuitive
    insights from the feature analysis. However, it is still helpful to understand
    how each of the features is distributed, how the distribution of each feature
    differs from the others, and whether there is any noticeable pattern we can derive
    from the set of features.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于保密性问题，我们在这份数据中除了交易金额外的特征都进行了匿名处理。因为我们不知道每个特征代表什么以及每个特征的含义，所以从特征分析中推断任何直观的见解将会很困难。然而，了解每个特征的分布情况、每个特征的分布与其他特征的区别，以及是否可以从特征集中推导出任何明显的模式，仍然是有帮助的。
- en: 'Let''s first take a look at the code. The following code shows how we can compute
    and visualize the distributions of the features:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看代码。以下代码展示了我们如何计算并可视化特征的分布：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see from this code, we are computing the quartiles. As you might
    recall, quartiles are the points that separate the data into four different sections.
    The first quartile is the middle point between the minimum and the median, the
    second quartile is the median, and the third quartile is the middle point between
    the median and the maximum. You can easily compute the quartiles by using the
    `Accord.Statistics.Measures.Quantiles` function. After we compute the quartiles,
    we build histogram plots for each feature to visualize the distributions, using
    the `HistogramBox` class in the Accord.NET framework. Let's take a look at some
    of the outputs from this code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中看到的，我们正在计算四分位数。如您可能记得，四分位数是将数据分为四个不同部分的点。第一四分位数是最小值和中间值之间的中点，第二四分位数是中间值，第三四分位数是中间值和最大值之间的中点。您可以通过使用`Accord.Statistics.Measures.Quantiles`函数轻松计算四分位数。计算四分位数后，我们使用Accord.NET框架中的`HistogramBox`类为每个特征构建直方图以可视化分布。让我们看看这段代码的一些输出结果。
- en: 'The first distribution we are going to look at is for the `V1` feature, and
    the quartiles for `V1` look like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个分布是针对`V1`特征的，而`V1`的特征四分位数看起来如下：
- en: '![](img/00165.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00165.jpeg)'
- en: 'It seems the distribution of the `V1` feature is skewed towards the negative
    direction. Even though the median is about 0, the negative values range from -56.41
    to 0, while the positive values range only from 0 to 2.45\. The following is the
    histogram output from the previous code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个代码中可以看出，`V1`特征的分布似乎偏向负方向。尽管中位数大约为0，但负值范围从-56.41到0，而正值范围仅从0到2.45。以下是由前述代码生成的直方图输出：
- en: '![](img/00166.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00166.jpeg)'
- en: As expected, the histogram plot shows left skewness in the distribution of the
    feature, `V1`, while the majority of the values are around 0.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，直方图显示了特征`V1`分布的左偏斜，而大多数值都围绕0。
- en: 'Next, let''s look at the distribution of the second feature, `V2`, where the
    output looks as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看第二个特征`V2`的分布情况，输出如下：
- en: '![](img/00167.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00167.jpeg)'
- en: 'The histogram for `V2` looks like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`V2`的直方图看起来如下：'
- en: '![](img/00168.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00168.jpeg)'
- en: It seems the values are centered around 0, although there are some extreme values
    in the negative direction and in the positive direction. The skewness is less
    obvious, compared to the previous feature, `V1`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值似乎集中在0附近，尽管在负方向和正方向上都有一些极端值。与之前的特征`V1`相比，偏度不太明显。
- en: 'Lastly, let''s look at the distribution of the `amount` feature, which can
    tell us the range of transaction amounts. The following are the quartiles for
    the `amount` feature:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`amount`特征的分布，这可以告诉我们交易金额的范围。以下是`amount`特征的四分位数：
- en: '![](img/00169.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00169.jpeg)'
- en: 'It seems any credit card transaction can take any positive number that ranges
    between 0 and 25,691.16 as a transaction amount. The following is a histogram
    for the `amount` feature:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎任何信用卡交易都可以取0到25,691.16之间的任何正数作为交易金额。以下是`amount`特征的直方图：
- en: '![](img/00170.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: As expected, we can see there is a long tail to the right. This is somewhat
    expected, as the spending pattern for each individual differs from any other.
    Some people might typically buy moderately priced items, while some others might
    buy very expensive items.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们可以看到右侧有一个长尾。这是可以预料的，因为每个人的消费模式都与其他人不同。有些人可能通常购买价格适中的商品，而有些人可能购买非常昂贵的商品。
- en: 'Lastly, let''s take a brief look at how well the current feature set separates
    fraudulent credit card transactions from non-fraudulent transactions. Let''s take
    a look at the following code first:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要看看当前特征集如何将欺诈信用卡交易与非欺诈交易区分开来。首先看看以下代码：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see from this code, we first convert the Deedle data frame variable,
    `df`, to a two-dimensional array variable, `data`, to build scatter plots. Then,
    we take the first two features and display a scatter plot that shows the distribution
    of the target classes across these first two features. We repeat this process
    twice more for the second, third, and fourth features.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下代码中可以看到，我们首先将Deedle数据帧变量`df`转换为二维数组变量`data`，以构建散点图。然后，我们取前两个特征并显示一个散点图，该图显示了目标类别在这两个特征上的分布。我们重复这个过程两次，分别针对第二、第三和第四个特征。
- en: 'The following scatter plot is the distribution of target classes across the
    first and second features in our dataset:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下散点图是我们数据集中第一和第二个特征的分布：
- en: '![](img/00171.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00171.jpeg)'
- en: 'From this scatter plot, it is quite difficult, if not impossible, to separate
    the frauds (encoded as 1) from the non-frauds (encoded as 0). Let''s look at the
    scatter plot between the next two features:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个散点图中，很难（如果不是不可能的话）将欺诈（编码为1）与非欺诈（编码为0）区分开来。让我们看看接下来两个特征的散点图：
- en: '![](img/00172.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00172.jpeg)'
- en: 'Similar to the case of the first two features, there does not seem to be a
    clear line separating frauds from non-frauds. Lastly, the following is a scatter
    plot of the target classes between the third and fourth feature:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个特征的情况类似，似乎没有一条清晰的线可以区分欺诈与非欺诈。最后，以下是在第三和第四个特征之间目标类别的散点图：
- en: '![](img/00173.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00173.jpeg)'
- en: From looking at this scatter plot, it will be difficult to draw a clear line
    that separates the two target classes. The fraudulent transactions seem to reside
    more in the bottom-right side of this scatter plot, but the pattern is weak. In
    the following section, we will try to build features that better separate the
    two target classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个散点图中可以看出，很难画出一条清晰的线来区分两个目标类别。欺诈交易似乎更多地位于散点图的右下角，但模式很弱。在下一节中，我们将尝试构建更好的特征来区分两个目标类别。
- en: The full code for this data analysis step can be found at the following link: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/DataAnalyzer.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/DataAnalyzer.cs).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据分析步骤的完整代码可以在以下链接找到：[https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/DataAnalyzer.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/DataAnalyzer.cs)。
- en: Feature engineering and PCA
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征工程与PCA
- en: So far, we have analyzed what the distributions of the target and feature variables
    look like. In this chapter, we are going to focus on building features, using
    PCA.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分析了目标和特征变量的分布情况。在本章中，我们将重点关注使用PCA构建特征。
- en: Preparation for feature engineering
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征工程准备
- en: 'In order to fit the PCA, we will have to prepare our data first. Let''s quickly
    look at the following code to load the credit card fraud data into Deedle''s data
    frame:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拟合PCA，我们首先需要准备我们的数据。让我们快速查看以下代码，将信用卡欺诈数据加载到Deedle的数据框中：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have loaded the data into a variable, named `df`, we are going
    to have to split the data into two sets, one for normal credit card transaction
    data and another for fraudulent transaction data, so that we can fit PCA with
    the normal transactions only. Take a look at the following code for how we can
    separate out the normal transactions from the raw dataset:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据加载到名为`df`的变量中，我们需要将数据分成两组，一组是正常信用卡交易数据，另一组是欺诈交易数据，这样我们就可以只使用正常交易来拟合PCA。看看以下代码，了解我们如何从原始数据集中分离出正常交易：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you recall from the previous data analysis step, the target variable, `Class`,
    is encoded as 1 for fraudulent transactions and 0 for non-fraudulent transactions.
    As you can see from the code, we created a data frame, `noFraudData`, with only
    normal credit card transaction records. Then, we converted this data frame into
    a two-dimensional double array that will be used to fit the PCA, using the helper
    function, `BuildJaggedArray`. The code for this helper function looks like the
    following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得之前的数据分析步骤，目标变量`Class`被编码为1表示欺诈交易，0表示非欺诈交易。从代码中您可以看到，我们创建了一个只包含正常信用卡交易记录的数据框`noFraudData`。然后，我们使用辅助函数`BuildJaggedArray`将这个数据框转换成二维双精度数组，该数组将被用于拟合PCA。这个辅助函数的代码如下：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code should look familiar, as we have used it in a number of previous chapters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来很熟悉，因为我们已经在许多前面的章节中使用过它。
- en: 'The next thing we need to do is convert the entire data frame, including both
    non-fraudulent and fraudulent records, into a two-dimensional array. Using the
    trained PCA, we are going to transform this newly created two-dimensional array
    that will later be used for building credit card fraud detection models. Let''s
    take a look at the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是将整个数据框，包括非欺诈和欺诈记录，转换成二维数组。使用训练好的PCA，我们将转换这个新创建的二维数组，该数组将用于构建信用卡欺诈检测模型。让我们看看以下代码：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Fitting a PCA
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拟合PCA
- en: 'We are now ready to fit a PCA using the non-fraudulent credit card data. Similar
    to what we did in [Chapter 9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber
    Attack Detection*, we are going to use the following code to fit a PCA:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备使用非欺诈信用卡数据拟合PCA。类似于我们在[第9章](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470)“网络攻击检测”中所做的，我们将使用以下代码来拟合PCA：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see from this code, we are using the `PrincipalComponentAnalysis`
    class in the Accord.NET framework to train a PCA. One more thing to note here
    is how we used `PrincipalComponentMethod.Standardize`. Since PCA is sensitive
    to the scales of the features, we are standardizing the feature values first and
    then fitting a PCA. Using this trained PCA, we can transform the whole data that
    contains both fraudulent and non-fraudulent transactions. The code for applying
    PCA transformation to the dataset looks as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中看到的，我们正在使用Accord.NET框架中的`PrincipalComponentAnalysis`类来训练PCA。在这里要注意的另一件事是我们如何使用`PrincipalComponentMethod.Standardize`。由于PCA对特征的尺度很敏感，我们首先标准化特征值，然后拟合PCA。使用这个训练好的PCA，我们可以转换包含欺诈和非欺诈交易的全数据。将PCA转换应用于数据集的代码如下：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we have all the PCA features ready for the following model building step.
    Before we move one, let''s see if we can find any noticeable patterns that can
    separate target classes with the new PCA features. Let''s take a look at the following
    code first:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了所有PCA特征，用于接下来的模型构建步骤。在我们继续之前，让我们看看是否可以通过新的PCA特征找到任何可以区分目标类别的明显模式。让我们首先看看以下代码：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Similar to what we did in the data analysis step, we are taking two features
    and creating scatter plots of target classes across the selected features. From
    these plots, we can see if the principal components in the PCA-transformed data
    more effectively separate fraudulent credit card transactions from non-fraudulent
    transactions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在数据分析步骤中所做的，我们选取了两个特征，并创建了目标类别在所选特征上的散点图。从这些图中，我们可以看到PCA转换后的数据中的主成分是否更有效地将欺诈信用卡交易与非欺诈交易分开。
- en: 'The following scatter plot applies between the first and second principal components:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的散点图显示了第一和第二个主成分之间的关系：
- en: '![](img/00174.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00174.jpeg)'
- en: There is a noticeable cutoff point that separates frauds (red points in the
    scatter plot) from non-frauds (blue points in the scatter plot). From this scatter
    plot, it seems fraudulent samples typically have Y-values (the second principal
    component values) of less than -5.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个明显的截止点，将欺诈（散点图中的红色点）与非欺诈（散点图中的蓝色点）分开。从这个散点图来看，欺诈样本的Y值（第二个主成分值）通常小于-5。
- en: 'The following is a scatter plot between the second and third principal components:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为第二个和第三个主成分之间的散点图：
- en: '![](img/00175.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00175.jpeg)'
- en: The pattern seems to be weaker in this plot, compared to the previous scatter
    plot, but there still seems to be a distinct line that separates many fraud cases
    from non-fraud cases.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的散点图相比，这个图中的模式似乎更弱，但仍然似乎有一条明显的线将许多欺诈案例与非欺诈案例区分开来。
- en: 'The following scatter plot is between the third and fourth principal components:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下散点图是第三个和第四个主成分之间的：
- en: '![](img/00176.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00176.jpeg)'
- en: 'And lastly, the following is a scatter plot between the fourth and fifth principal
    components:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是第四个和第五个主成分之间的散点图：
- en: '![](img/00177.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00177.jpeg)'
- en: In the last two scatter plots, we cannot find a noticeable pattern to separate
    the two target classes from each other. Given that there were some separable lines
    we could find when we looked at the first three principal components and their
    scatter plots, our anomaly detection model for credit card fraud detection will
    be able to learn how to classify frauds, when it learns from this data in a higher
    dimension and multiple principal components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个散点图中，我们找不到一个明显的模式来区分两个目标类别。鉴于我们在查看前三个主成分及其散点图时找到了一些可区分的线，我们的信用卡欺诈检测的异常检测模型将能够从这些数据在更高维度和多个主成分中学习如何分类欺诈。
- en: 'Lastly, let''s take a look at the proportion of variance explained by the principal
    components. Take a look at the following code first:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下主成分解释的方差比例。首先看看以下代码：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we discussed in [Chapter 9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470),
    *Cyber Attack Detection*, we can use the `Components` property within a `PrincipalComponentAnalysis`
    object to extract the cumulative proportion of variance explained by each component.
    As you can see from the third line in the code, we iterate through the `Components`
    property and extract `CumulativeProportion` values. Then, we display a line chart
    by using the `DataSeriesBox` class. When you run this code, you will see the following
    chart for the cumulative proportion of variance explained by the principal components:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第9章](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470)“网络攻击检测”中讨论的，我们可以使用`PrincipalComponentAnalysis`对象内的`Components`属性来提取每个成分解释的累积方差比例。如代码中的第三行所示，我们遍历`Components`属性并提取`CumulativeProportion`值。然后，我们使用`DataSeriesBox`类显示一个折线图。当你运行此代码时，你将看到以下图表，显示了主成分解释的累积方差比例：
- en: '![](img/00178.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00178.jpeg)'
- en: As you can see from this chart, by the twentieth principal component, about
    80% of the variance in the data, is explained. We will use this chart to make
    a decision on how many principal components to use when we build an anomaly detection
    model in the following section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图表所示，到第二十个主成分时，大约80%的数据方差得到了解释。我们将在下一节构建异常检测模型时使用此图表来决定使用多少个主成分。
- en: 'Lastly, we need to export this data, as we just created a newly PCA-transformed
    dataset in this feature engineering step and we want to use this new data to build
    models. You can export this data by using the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要导出这些数据，因为我们在这个特征工程步骤中创建了一个新的PCA变换数据集，我们希望使用这些新数据来构建模型。你可以使用以下代码来导出这些数据：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The full code that was used in this feature engineering step can be found at
    the following link: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/FeatureEngineering.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/FeatureEngineering.cs).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此特征工程步骤中使用到的完整代码可以在以下链接中找到：[https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/FeatureEngineering.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/FeatureEngineering.cs)。
- en: One-class SVM versus PCC
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单类SVM与PCC对比
- en: We are now ready to build anomaly detection models for the credit card fraud
    detection project. In this step, we are going to experiment with two different
    approaches. We are going to build a PCC, similarly to what we did in [Chapter
    9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber Attack Detection*.
    Also, we are going to introduce a new learning algorithm, the one-class SVM, which
    learns from normal credit card transaction data and decides whether a new data
    point is similar to the normal data that it was trained with.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好为信用卡欺诈检测项目构建异常检测模型了。在这个步骤中，我们将尝试两种不同的方法。我们将构建一个PCC，这与我们在[第9章](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470)，“网络攻击检测”中所做的一样。此外，我们还将介绍一种新的学习算法，即单类SVM，它从正常的信用卡交易数据中学习，并决定新的数据点是否与其训练的正常数据相似。
- en: Preparation for model training
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型训练准备
- en: 'First, we need to load the data that we created in the previous feature-engineering
    step. You can use the following code to load the data:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要加载我们在上一个特征工程步骤中创建的数据。你可以使用以下代码来加载数据：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you recall from the previous feature-engineering step, we did not export
    the data with the column names. So, we are loading the data into a Deedle data
    frame, `featuresDF`, with the `hasHeaders` flag set to `false`. Then, we give
    the proper column names for each feature by using the `RenameColumns` method.
    Let''s quickly check the target class distributions within this dataset, using
    the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从上一个特征工程步骤中回忆起来，我们没有将带有列名的数据导出。因此，我们将数据加载到带有`hasHeaders`标志设置为`false`的Deedle数据框`featuresDF`中。然后，我们使用`RenameColumns`方法为每个特征赋予适当的列名。让我们快速检查这个数据集内的目标类别分布，以下代码：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of this code looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![](img/00179.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00179.jpeg)'
- en: As seen previously, in the data analysis step, the majority of the samples belong
    to non-fraudulent transactions and only a small portion of the data is fraudulent
    credit card transactions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在数据分析步骤中，大多数样本属于非欺诈交易，只有一小部分数据是欺诈信用卡交易。
- en: Principal component classifier
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主成分分类器
- en: We will first try to build an anomaly detection model using principal components,
    similar to what we did in [Chapter 9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470),
    *Cyber Attack Detection*. For training and testing a PCC model, we wrote a helper
    function, named `BuildPCAClassifier`. The detailed code for this helper function
    can be found at the following repo: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/Modeling.cs).
    Let's take a look at this helper function step by step.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先尝试使用主成分构建一个异常检测模型，这与我们在[第9章](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470)，“网络攻击检测”中所做的一样。为了训练和测试PCC模型，我们编写了一个名为`BuildPCAClassifier`的辅助函数。这个辅助函数的详细代码可以在以下仓库中找到：[https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/Modeling.cs)。让我们一步一步地看看这个辅助函数。
- en: 'You will see the following lines of code when you look at the code for the
    `BuildPCAClassifier` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看`BuildPCAClassifier`方法的代码时，你会看到以下几行代码：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we are sub-selecting the first thirteen principal components that explain
    about 50% of the variance. Then, we create a non-fraudulent credit card transaction
    group, `normalDF` and `normalData`, so that we can use this subset to build an
    anomaly detection model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择前十三项主成分，这些成分解释了大约50%的方差。然后，我们创建一个非欺诈信用卡交易组`normalDF`和`normalData`，这样我们就可以使用这个子集来构建异常检测模型。
- en: 'The next thing we do is start computing the **Mahalanobis distance** metric
    to measure the distance between a data point and the distribution of the non-fraudulent
    credit card transactions. If you recall, we used the same distance metric in [Chapter
    9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber Attack Detection*,
    and we recommend you review the *Model building* section in [Chapter 9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber
    Attack Detection*, for a more detailed explanation about this distance metric.
    The code to compute the distances looks like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是开始计算**马氏距离**度量，以衡量数据点与非欺诈信用卡交易分布之间的距离。如果你还记得，我们在[第9章](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470)，“网络攻击检测”中使用了相同的距离度量，我们建议你回顾第9章，“网络攻击检测”中的“模型构建”部分，以了解更多关于这个距离度量的详细信息。计算距离的代码如下：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code should look familiar, as this is the same code we used in [Chapter
    9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber Attack Detection*, to
    build a PCC model for cyber attack detection. Additionally, the following is the
    code for the `ComputeDistances` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来应该很熟悉，因为这和我们在[第9章](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470)，*网络攻击检测*中使用的代码相同，用于构建网络攻击检测的PCC模型。此外，以下是在`ComputeDistances`方法中的代码：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code should also look familiar, as we used this same code in [Chapter
    9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber Attack Detection*
    as well. Using these two methods, we computed the mean and the standard deviation
    of the distance measures within the non-fraudulent transaction data. The output
    looks like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也应该很熟悉，因为我们同样在[第9章](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470)，*网络攻击检测*中使用了相同的代码。使用这两个方法，我们计算了非欺诈交易数据中距离度量的平均值和标准差。输出如下：
- en: '![](img/00180.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00180.jpeg)'
- en: 'With the distance measures within the normal transaction group computed, we
    now compute the distances between the fraudulent transactions and the distribution
    of non-fraudulent transactions. The following is the part of the `BuildPCAClassifier`
    code that computes the distances for frauds:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算了正常交易组内的距离度量后，我们现在计算欺诈交易与非欺诈交易分布之间的距离。以下是在`BuildPCAClassifier`代码中计算欺诈距离的部分：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One-class SVM
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单类SVM
- en: The next approach we are going to explore for credit card fraud detection is
    training a one-class SVM. A one-class SVM is a special case of a SVM, where an
    SVM model is first trained with a data and then, when it sees a new data point,
    the SVM model can determine if the new data point is close enough to the data
    that it was trained with. For training a one-class SVM model, we wrote a helper
    function, `BuildOneClassSVM`, and the full code for this function can be found
    at the following repo: [https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/Modeling.cs).
    Let's go through this helper function step by step.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要探索的信用卡欺诈检测方法是训练一个单类SVM。单类SVM是SVM的一个特例，其中SVM模型首先使用数据训练，然后，当它看到新的数据点时，SVM模型可以确定这个新数据点是否足够接近它训练过的数据。为了训练单类SVM模型，我们编写了一个辅助函数`BuildOneClassSVM`，这个函数的完整代码可以在以下仓库中找到：[https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/blob/master/ch.10/Modeling.cs)。让我们一步一步地分析这个辅助函数。
- en: 'First, let''s look at the part of the code that sub-selects non-fraudulent
    credit card transaction data that will be used to train the one-class SVM. The
    code looks like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看代码中用于子选择用于训练单类SVM的非欺诈信用卡交易数据的部分。代码看起来如下：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Similar to the previous PCC model that we built, we are using the first thirteen
    principal components that explain about 50% of the total variance. Next, we are
    going to sub-select records from the non-fraudulent transaction samples and build
    a train set. As you can see from this code, we are randomly selecting 15,000 non-fraudulent
    samples as a train set.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前构建的PCC模型类似，我们使用了前十三项主成分，这些主成分解释了大约50%的总方差。接下来，我们将从非欺诈交易样本中子选择记录来构建训练集。如您从这段代码中可以看到，我们随机选择了15,000个非欺诈样本作为训练集。
- en: 'Now that we have a train set to train a one-class SVM model with, let''s take
    a look at the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了训练单类SVM模型的训练集，让我们看看以下代码：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are using the `OneclassSupportVectorLearning` algorithm in the Accord.NET
    framework to train a one-class SVM model. As you can see, we built an SVM model
    with the `Gaussian` kernel in this chapter, but you can experiment with different
    kernels. Now, the only step left is to test this one-class SVM model that we just
    trained. The following code shows how we built a test set to evaluate this model:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Accord.NET框架中使用`OneclassSupportVectorLearning`算法来训练一个单类SVM模型。如您所见，我们在本章中构建了一个具有`Gaussian`核的SVM模型，但您可以尝试不同的核。现在，唯一剩下的步骤就是测试我们刚刚训练的单类SVM模型。以下代码展示了我们如何构建测试集来评估这个模型：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see from this code, we are taking all the fraud samples and 5,000
    randomly sub-selected non-fraud samples as a test set. With this test set, we
    are going to evaluate how well this one-class SVM model performs at detecting
    credit card frauds.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中可以看到，我们选取了所有欺诈样本和5,000个随机选择的非欺诈样本作为测试集。使用这个测试集，我们将评估这个单类SVM模型在检测信用卡欺诈方面的表现。
- en: 'We are going to look closer into the evaluation code in the following section,
    but let''s take a quick look at how we can evaluate the performance of the one-class
    SVM model that we just trained. The code looks like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地查看评估代码，但让我们先快速看一下我们如何评估刚刚训练的单类SVM模型。代码如下所示：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see from this code, we iterate through different values of thresholds,
    similar to how we set different thresholds for the previous PCC model. As in the
    third line of the code, you can use the `Threshold` property of the model to get
    or set the threshold that determines whether a record is normal or abnormal. Similar
    to how we evaluate the PCC, we are going to look at the fraud detection rate and
    the false-alarm rate for model validations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中可以看到，我们遍历不同的阈值值，类似于我们为之前的PCC模型设置不同的阈值。在代码的第三行中，您可以使用模型的`Threshold`属性来获取或设置确定记录是否正常的阈值。类似于我们评估PCC，我们将查看模型验证的欺诈检测率和误报率。
- en: The full code we used in the model building step can be found at the following
    link: [https://github.com/yoonhwang/c-sharp-machine-learning/edit/master/ch.10/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/edit/master/ch.10/Modeling.cs).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型构建步骤中使用的完整代码可以在以下链接中找到：[https://github.com/yoonhwang/c-sharp-machine-learning/edit/master/ch.10/Modeling.cs](https://github.com/yoonhwang/c-sharp-machine-learning/edit/master/ch.10/Modeling.cs)。
- en: Evaluating anomaly detection models
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估异常检测模型
- en: We have trained two anomaly detection models—one using principal components
    and another using a one-class SVM algorithm. In this section, we are going to
    take a closer look at the performance metrics and the codes used to evaluate these
    models.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经训练了两个异常检测模型——一个使用主成分，另一个使用单类SVM算法。在本节中，我们将更详细地查看性能指标和用于评估这些模型的代码。
- en: Principal Component Classifier
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主成分分类器
- en: 'As briefly mentioned in the previous section, we are going to look at the credit
    card fraud detection rates for each of the target false alarm rates. The code
    for evaluating the PCC model looks like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节简要提到的，我们将查看每个目标误报率下的信用卡欺诈检测率。评估PCC模型的代码如下所示：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Similar to [Chapter 9](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470), *Cyber
    Attack Detection*, we iterate through the target false alarm rates from 5% to
    10% and inspect the detection rates for the given false alarm rates. Using the
    target false alarm rate variable, `targetFalseAlarmRate`, we compute the threshold
    using the `Accord.Statistics.Measures.Quantile` method. With this calculated threshold,
    we flag all records with distances greater than this threshold as fraud, and others
    as non-fraud.  Let's look at the evaluation results.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第9章](part0116.html#3EK180-5ebdf09927b7492888e31e8436526470)，“网络攻击检测”类似，我们遍历从5%到10%的目标误报率，并检查给定误报率下的检测率。使用目标误报率变量`targetFalseAlarmRate`，我们使用`Accord.Statistics.Measures.Quantile`方法计算阈值。使用这个计算出的阈值，我们将距离大于此阈值的所有记录标记为欺诈，其他为非欺诈。让我们看看评估结果。
- en: 'The following is the fraud detection rate at the 5% false alarm rate:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在5%误报率下的欺诈检测率：
- en: '![](img/00181.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00181.jpeg)'
- en: 'The following is the fraud detection rate at the 10% false alarm rate:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在10%误报率下的欺诈检测率：
- en: '![](img/00182.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00182.jpeg)'
- en: 'The following is the fraud detection rate at 15% false alarm rate:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在15%误报率下的欺诈检测率：
- en: '![](img/00183.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00183.jpeg)'
- en: 'Lastly, the following is the fraud detection rate at 20% false alarm rate:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是在20%误报率下的欺诈检测率：
- en: '![](img/00184.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00184.jpeg)'
- en: As you can see from these results, as we relax and increase the target false
    alarm rate, the fraud detection rate improves. At the 5% target false alarm rate,
    we could only detect about 59% of the fraudulent transactions. However, at the
    20% target false alarm rate, we can detect over 80% of the fraudulent credit card
    transactions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些结果中可以看到，随着我们放宽并增加目标误报率，欺诈检测率有所提高。在5%的目标误报率下，我们只能检测到大约59%的欺诈交易。然而，在20%的目标误报率下，我们可以检测到超过80%的欺诈信用卡交易。
- en: One-class SVM
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单类SVM
- en: 'Let''s now take a look at how the one-class SVM model performed on the credit
    card fraud dataset. The code for the model evaluation looks like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看单类SVM模型在信用卡欺诈数据集上的表现。模型评估的代码如下所示：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see from this code, we iterate through different thresholds from
    -1.0 to 0.0, in increments of 0.1\. You can set the threshold for the model by
    updating the `Threshold` property of the one-class SVM model object. This threshold
    will instruct the model on how to determine which record is fraudulent and which
    is not. When making a decision on the final model, you will need to experiment
    with different values for thresholds to settle on the best threshold that fits
    your requirements. Let's take a look at some of the performance results.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这段代码中可以看到，我们以0.1的增量从-1.0迭代到0.0的不同阈值。您可以通过更新单类SVM模型对象的`Threshold`属性来设置模型的阈值。这个阈值将指导模型如何确定哪些记录是欺诈的，哪些不是。在决定最终模型时，您需要尝试不同的阈值值，以确定最适合您需求的最佳阈值。让我们来看看一些性能结果。
- en: 'The following shows the performance metrics for the threshold at -0.4:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了阈值为-0.4时的性能指标：
- en: '![](img/00185.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00185.jpeg)'
- en: 'The following shows the performance metrics for the threshold at -0.3:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了阈值为-0.3时的性能指标：
- en: '![](img/00186.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00186.jpeg)'
- en: 'The following shows the performance metrics for the threshold at -0.2:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了阈值为-0.2时的性能指标：
- en: '![](img/00187.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00187.jpeg)'
- en: 'Lastly, the following shows the performance metrics for the threshold at -0.1:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下展示了阈值为-0.1时的性能指标：
- en: '![](img/00188.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00188.jpeg)'
- en: As you can see from these results, as we increase the threshold, the false alarm
    rate decreases, but the fraud detection rate decreases as well. It is clear that
    there is a trade-off between higher precision and a higher fraud detection rate.
    At a threshold of -0.4, the model was able to detect about 70% of the fraudulent
    credit card transactions with a roughly 40% false alarm rate. On the other hand,
    at a threshold of -0.1, the model could only detect about 57% of the fraudulent
    credit card transactions, but the false alarm rate was only about 33%.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些结果中可以看到，随着阈值的增加，误报率降低，但欺诈检测率也随之降低。很明显，在更高的精确度和更高的欺诈检测率之间存在权衡。在阈值为-0.4时，模型能够检测到大约70%的欺诈信用卡交易，误报率大约为40%。另一方面，在阈值为-0.1时，模型只能检测到大约57%的欺诈信用卡交易，但误报率仅为大约33%。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built another anomaly detection model for credit card fraud
    detection. We started this chapter by looking at the structure of the anonymized
    credit card fraud data, and then started analyzing the distributions of the target
    and feature variables. While we were analyzing the distribution of the target
    classes, we noticed that there was a large class imbalance between the fraud and
    non-fraud classes. This is normal when we face any kind of anomaly detection project,
    where the normal class outweighs by far the positive class. Then, we started analyzing
    the distributions of the anonymized features. Due to the fact that the features
    were anonymized for confidentiality issues, we could not arrive at any intuitions
    from the dataset.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为信用卡欺诈检测构建了另一个异常检测模型。我们本章开始时查看匿名信用卡欺诈数据结构，然后开始分析目标变量和特征变量的分布。当我们分析目标类别的分布时，我们注意到欺诈和非欺诈类别之间存在很大的类别不平衡。当我们面对任何类型的异常检测项目时，这种情况是正常的，其中正常类别远远超过正类别。然后，我们开始分析匿名特征的分布。由于出于保密问题对特征进行了匿名处理，我们无法从数据集中得出任何直觉。
- en: However, we were able to understand the distributions better and how we cannot
    easily separate frauds from non-frauds using raw features. We then applied PCA
    and exported the PCA features for the model building step. We experimented with
    two approaches to building a credit card fraud detection model—the Principal Component
    Classifier and the one-class SVM. We evaluated the performances of these models
    by looking at the fraud detection rates at various false alarm rates. It was clear
    that there are trade-offs between improving the false alarm rates and improving
    the fraud detection rates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们能够更好地理解分布情况，以及我们如何无法轻易地使用原始特征将欺诈与非欺诈区分开来。然后，我们应用PCA并导出PCA特征用于模型构建步骤。我们尝试了两种构建信用卡欺诈检测模型的方法——主成分分类器和单类SVM。我们通过查看不同误报率下的欺诈检测率来评估这些模型的性能。很明显，在提高误报率和提高欺诈检测率之间存在权衡。
- en: This chapter was the last chapter about building ML models in C#. In the next
    chapter, we are going to summarize what we have done so far throughout all the
    chapters, and what additional real-life challenges there are when building ML
    models. Also, we are going to discuss some other software packages, as well as
    some other data-science technologies out there, that can be used for your future
    ML projects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于在C#中构建机器学习模型的最后一章。在下一章中，我们将总结到目前为止所有章节中我们所做的一切，以及构建机器学习模型时可能遇到的额外现实挑战。此外，我们还将讨论一些其他软件包，以及一些其他可用于您未来机器学习项目的数据科学技术。
