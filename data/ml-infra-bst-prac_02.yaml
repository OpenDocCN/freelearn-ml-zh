- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Machine Learning Compared to Traditional Software
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与传统软件相比，机器学习
- en: Machine learning software is a special kind of software that finds patterns
    in data, learns from them, and even recreates these patterns on new data. Developing
    the machine learning software is, therefore, focused on finding the right data,
    matching it with the appropriate algorithm, and evaluating its performance. Traditional
    software, on the contrary, is developed with the algorithm in mind. Based on software
    requirements, programmers develop algorithms that solve specific tasks and then
    test them. Data is secondary, although not completely unimportant. Both types
    of software can co-exist in the same software system, but the programmer must
    ensure compatibility between them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习软件是一种特殊的软件，它能在数据中找到模式，从中学习，甚至在新数据上重新创建这些模式。因此，开发机器学习软件的重点是找到合适的数据，将其与适当的算法匹配，并评估其性能。相反，传统软件的开发是以算法为前提的。基于软件需求，程序员开发解决特定任务的算法，然后对其进行测试。数据是次要的，尽管并非完全不重要。这两种类型的软件可以在同一软件系统中共存，但程序员必须确保它们之间的兼容性。
- en: In this chapter, we’ll explore where these two types of software systems are
    most appropriate. We’ll learn about the software development processes that programmers
    use to create both types of software. We’ll also learn about the four classical
    types of machine learning software – rule-based learning, supervised learning,
    unsupervised learning, and reinforcement learning. Finally, we’ll learn about
    the different roles of data in traditional and machine learning software – as
    input to pre-programmed algorithms in traditional software and input to training
    models in machine learning software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这两种类型软件系统最合适的领域。我们将了解程序员用来创建这两种类型软件的软件开发过程。我们还将了解四种经典的机器学习软件类型——基于规则的学习、监督学习、无监督学习和强化学习。最后，我们将了解数据在传统和机器学习软件中的不同作用——在传统软件中作为预编程算法的输入，在机器学习软件中作为训练模型的输入。
- en: The best practices introduced in this chapter provide practical guidance on
    when to choose each type of software and how to assess the advantages and disadvantages
    of these types. By exploring a few modern examples, we’ll understand how to create
    an entire software system with machine learning algorithms at the center.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的最佳实践提供了何时选择每种类型软件以及如何评估这些类型软件优缺点的实用指导。通过探讨几个现代实例，我们将了解如何以机器学习算法为中心创建整个软件系统。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Machine learning is not a traditional software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习不是传统软件
- en: Probability and software – how well do they go together?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率和软件——它们搭配得怎么样？
- en: Testing and validation – the same but different
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和验证——相同但不同
- en: Machine learning is not traditional software
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习不是传统软件
- en: Although machine learning and artificial intelligence have been around since
    the 1950s, introduced by Alan Turing, they only became popular with the first
    MYCIN system and our understanding of machine learning systems changed over time.
    It was not until the 2010s that we started to perceive, design, and develop machine
    learning in the same way as we do today (in 2023). In my view, two pivotal moments
    shaped the landscape of machine learning as we see it today.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管机器学习和人工智能自20世纪50年代由艾伦·图灵引入以来就已经存在，但它们只有在第一个MYCIN系统出现以及我们对机器学习系统的理解随时间变化后才开始流行。直到2010年代，我们才开始以今天（2023年）的方式感知、设计和开发机器学习。在我看来，有两个关键时刻塑造了我们今天所看到的机器学习格局。
- en: The first pivotal moment was the focus on big data in the late 2000s and early
    2010s. With the introduction of smartphones, companies started to collect and
    process increasingly large quantities of data, mostly about our behavior online.
    One of the companies that perfected this was Google, which collected data about
    our searches, online behavior, and usage of Google’s operating system, Android.
    As the volume of the collected data increased (and its speed/velocity), so did
    its value and the need for its veracity – the five Vs. These five Vs – volume,
    velocity, value, veracity, and variety – required a new approach to working with
    data. The classical approach of relational databases (SQL) was no longer sufficient.
    Relational databases became too slow in handling high-velocity data streams, which
    gave way to map-reduce algorithms, distributed databases, and in-memory databases.
    The classical approach of relational schemas became too constraining for the variety
    of data, which gave way for non-SQL databases, which stored documents.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个关键时刻是在2000年代末和2010年代初对大数据的关注。随着智能手机的引入，公司开始收集和处理越来越多的数据，这些数据大多关于我们在网上的行为。其中一家完美掌握这一技术的公司是谷歌，它收集了我们搜索、在线行为以及使用谷歌操作系统Android的数据。随着收集到的数据量（及其速度/速度）的增加，其价值和对真实性的需求——即五个“V”——也随之增加。这五个“V”——量、速度、价值、真实性和多样性——需要一种新的数据处理方法。传统的基于关系型数据库（SQL）的方法在处理高速数据流时变得过于缓慢，这导致了map-reduce算法、分布式数据库和内存数据库的出现。传统的基于关系模式的处理方法对于数据的多样性来说过于约束，这导致了非SQL数据库的出现，这些数据库存储文档。
- en: The second pivotal moment was the rise of modern machine learning algorithms
    – deep learning. Deep learning algorithms are designed to handle unstructured
    data such as text, images, or music (compared to structured data in the form of
    tables and matrices). Classical machine learning algorithms, such as regression,
    decision trees, or random forest, require data in a tabular form. Each row is
    a data point, and each column is one characteristic of it – a feature. The classical
    models are designed to handle relatively small datasets. Deep learning algorithms,
    on the other hand, can handle large datasets and find more complex patterns in
    the data because of the power of large neural networks and their complex architectures.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键时刻是现代机器学习算法——深度学习的兴起。深度学习算法被设计来处理非结构化数据，如文本、图像或音乐（与表格和矩阵形式的结构化数据相比）。传统的机器学习算法，如回归、决策树或随机森林，需要表格形式的数据。每一行是一个数据点，每一列是它的一个特征——一个属性。传统的模型被设计来处理相对较小的数据集。另一方面，深度学习算法可以处理大型数据集，并利用大型神经网络和其复杂的架构找到数据中的更复杂模式。
- en: Machine learning is sometimes called *statistical learning* as it is based on
    statistical methods. The statistical methods calculate properties of data (such
    as mean values, standard deviations, and coefficients) and thus find patterns
    in the data. The core characteristic of machine learning is that it uses data
    to find patterns, learn from them, and then repeat these patterns on new data.
    We call this way of learning patterns training, and repeating these patterns as
    reasoning, or in machine learning language, *predicting*. The main benefits of
    using machine learning software come from the fact that we do not need to design
    the algorithms – we focus on the problem to be solved and the data that we use
    to solve the problem. *Figure 1**.1* shows an example of how such a flowchart
    of machine learning software can be realized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习有时被称为*统计学习*，因为它基于统计方法。统计方法计算数据的属性（如平均值、标准偏差和系数），从而在数据中找到模式。机器学习的核心特征是它使用数据来寻找模式，从中学习，然后在新的数据上重复这些模式。我们称这种学习模式的方式为训练，将这些模式重复为推理，或者用机器学习的语言来说，就是*预测*。使用机器学习软件的主要好处来自于我们不需要设计算法——我们专注于要解决的问题以及我们用来解决问题的数据。“图1.1”展示了这样一个机器学习软件流程图的实现示例。
- en: First, we import a generic machine learning model from a library. This generic
    model has all elements that are specific to it, but it is not trained to solve
    any tasks. An example of such a model is a decision tree model, which is designed
    to learn dependencies in data in the form of decisions (or data splits), which
    it uses later for new data. To make this model somewhat useful, we need to train
    it. For that, we need data, which we call the training data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从库中导入一个通用的机器学习模型。这个通用模型具有它特有的所有元素，但它并未训练用于解决任何任务。这类模型的例子是一个决策树模型，它被设计用来学习数据中的依赖关系，以决策（或数据拆分）的形式呈现，之后它将使用这些信息来处理新数据。为了使这个模型变得有些用处，我们需要对其进行训练。为此，我们需要数据，我们称之为训练数据。
- en: Second, we evaluate the trained model on new data, which we call the test data.
    The evaluation process uses the trained model and applies it to check whether
    its inferences are correct. To be precise, it checks to which degree the inferences
    are correct. The training data is in the same format as the test data, but the
    content of these datasets is different. No data point should be present in both.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，我们在新的数据上评估训练好的模型，我们称之为测试数据。评估过程使用训练好的模型，并应用它来检查其推理是否正确。更精确地说，它检查推理正确的程度。训练数据与测试数据具有相同的格式，但这两个数据集的内容是不同的。不应该有任何数据点同时存在于两者中。
- en: In the third step, we use the model as part of a software system. We develop
    other non-machine learning components, and we connect them to the trained model.
    The entire software system usually consists of data procurement components, real-time
    validation components, data cleaning components, user interfaces, and business
    logic components. All these components, including the machine learning model,
    provide a specific functionality for the end user. Once the software system has
    been developed, it needs to be tested, which is where the input data comes into
    play. The input data is something that the end user inputs to the system, such
    as by filling in a form. The input data is designed in such a way that has both
    the input and expected output – to test whether the software system works correctly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步，我们将模型作为软件系统的一部分使用。我们开发其他非机器学习组件，并将它们连接到训练好的模型。整个软件系统通常包括数据采集组件、实时验证组件、数据清洗组件、用户界面和业务逻辑组件。所有这些组件，包括机器学习模型，都为最终用户提供特定的功能。一旦软件系统开发完成，就需要对其进行测试，这时输入数据就派上用场。输入数据是最终用户输入到系统中的数据，例如通过填写表格。输入数据被设计成既包含输入又包含预期的输出——以测试软件系统是否正确工作。
- en: 'Finally, the last step is to deploy the entire system. The deployment can be
    very different, but most modern machine learning systems are organized into two
    parts – the onboard/edge algorithms for non-machine learning components and the
    user interface, and the offboard/cloud algorithms for machine learning inferences.
    Although it is possible to deploy all parts of the system on the target device
    (both machine learning and non-machine learning components), complex machine learning
    models require significant computational power for good performance and seamless
    user experience. The principle is simple – more data/complex data means more complex
    models, which means that more computational power is needed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是部署整个系统。部署可能非常不同，但大多数现代机器学习系统被组织成两部分——用于非机器学习组件的机载/边缘算法和用户界面，以及用于机器学习推理的离岸/云算法。尽管有可能在目标设备上部署系统的所有部分（包括机器学习和非机器学习组件），但复杂的机器学习模型需要大量的计算能力以实现良好的性能和无缝的用户体验。原则很简单——更多的数据/更复杂的数据意味着更复杂的模型，这意味着需要更多的计算能力：
- en: '![Figure 1.1 – Typical flow of machine learning software development](img/B19548_01_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 机器学习软件开发典型流程](img/B19548_01_1.jpg)'
- en: Figure 1.1 – Typical flow of machine learning software development
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 机器学习软件开发典型流程
- en: As shown in *Figure 1**.1*, one of the crucial elements of the machine learning
    software is the *model*, which is one of the generic machine learning models,
    such as a neural network, that’s been trained on specific data. Such a model is
    used to make predictions and inferences. In most systems, this kind of component
    – the model – is often prototyped and developed in Python.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图1**.1*所示，机器学习软件的一个关键元素是*模型*，这是经过特定数据训练的通用机器学习模型之一，例如神经网络。这类模型用于进行预测和推理。在大多数系统中，这种组件——模型——通常是用Python进行原型设计和开发的。
- en: Models are trained for different datasets and, therefore, the core characteristic
    of machine learning software is its dependence on that dataset. An example of
    such a model is a vision system, where we train a machine learning algorithm such
    as a **convolutional neural network** (**CNN**) to classify images of cats and
    dogs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模型针对不同的数据集进行训练，因此，机器学习软件的核心特征是其对那个数据集的依赖性。这样的模型的一个例子是视觉系统，我们训练一个机器学习算法，如**卷积神经网络**（**CNN**），以对猫和狗的图像进行分类。
- en: Since the models are trained on specific datasets, they perform best on similar
    datasets when making inferences. For example, if we train a model to recognize
    cats and dogs in 160 x 160-pixel grayscale images, the model can recognize cats
    and dogs in such images. However, the same model will perform very poorly (if
    at all!) if it needs to recognize cats and dogs in colorful images instead of
    grayscale images – the accuracy of the classification will be low (close to 0).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型是在特定数据集上训练的，因此在进行推理时，它们在类似数据集上的表现最佳。例如，如果我们训练一个模型在160 x 160像素的灰度图像中识别猫和狗，该模型可以识别这样的图像中的猫和狗。然而，如果需要在该模型中识别彩色图像中的猫和狗而不是灰度图像，该模型的性能将非常差（如果有的话！）——分类的准确性将很低（接近0）。
- en: On the other hand, when we develop and design traditional software systems,
    we do not rely on data that much, as shown in *Figure 1**.2*. This figure provides
    an overview of a software development process for traditional, non-machine learning
    software. Although it is depicted as a flow, it is usually an iterative process
    where *Steps 1* to *3* are done in cycles, each one ending with new functionality
    added to the product.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们开发和设计传统软件系统时，我们并不那么依赖数据，如图**1.2**所示。这张图概述了传统、非机器学习软件的开发过程。尽管它被描绘为流程，但通常是一个迭代过程，其中**步骤1**到**步骤3**是循环进行的，每次循环都以向产品中添加新功能结束。
- en: The first step is developing the software system. This includes the development
    of all its components – user interface, business logic (processing), handling
    of data, and communication. The step does not involve much data unless the software
    engineer creates data for testing purposes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是开发软件系统。这包括开发所有组件——用户界面、业务逻辑（处理）、数据处理和通信。除非软件工程师为了测试目的创建数据，否则这一步不涉及太多数据。
- en: The second step is system testing, where we use input data to validate the software
    system. In essence, this step is almost identical to testing machine learning
    software. The input data is complemented with the expected outcome data, which
    allows software testers to assess whether the software works correctly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是系统测试，我们使用输入数据来验证软件系统。本质上，这一步几乎与测试机器学习软件相同。输入数据与预期的结果数据相结合，这使得软件测试人员能够评估软件是否正确工作。
- en: 'The third step is to deploy the software. The deployment can be done in many
    ways. However, if we consider traditional software that is similar in function
    to machine learning software, it is usually simpler. It usually does not require
    deployment on the cloud, just like machine learning models:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是部署软件。部署可以通过多种方式进行。然而，如果我们考虑与机器学习软件在功能上相似的传统的软件，它通常更简单。它通常不需要在云上进行部署，就像机器学习模型一样：
- en: '![Figure 1.2 - Typical flow of traditional software development](img/B19548_01_2.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 - 传统软件开发典型流程](img/B19548_01_2.jpg)'
- en: Figure 1.2 - Typical flow of traditional software development
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 传统软件开发典型流程
- en: The main difference between traditional software and machine learning-based
    software is that we need to design, develop, and test all the elements of the
    traditional software. In machine learning-based software, we take an empty model,
    which contains all the necessary elements, and we use the data to train it. We
    do not need to develop the individual components of the machine learning model
    from scratch.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 传统软件与基于机器学习的软件之间的主要区别在于，我们需要设计、开发和测试传统软件的所有元素。在基于机器学习的软件中，我们使用一个包含所有必要元素的空模型，并使用数据对其进行训练。我们不需要从头开始开发机器学习模型的各个组件。
- en: One of the main parts of traditional software is the *algorithm*, which is developed
    by software engineers from scratch, based on the requirements or user stories.
    The algorithm is usually written as a sequential set of steps that are implemented
    in a programming language. Naturally, all algorithms use data to operate on it,
    but they do it differently than machine learning systems. They do it based on
    the software engineer’s design – *if x, then y* or something similar.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 传统软件的主要部分之一是*算法*，这是软件工程师从头开始根据需求或用户故事开发的。算法通常被编写为一系列按编程语言实现的步骤。自然地，所有算法都使用数据来操作它，但它们与机器学习系统不同。它们基于软件工程师的设计——*如果x，则y*或类似的东西。
- en: We usually consider these traditional algorithms as deterministic, explainable,
    and traceable. This means that the software engineer’s design decisions are documented
    in the algorithm and the algorithm can be analyzed afterward. They are deterministic
    because they are programmed based on rules; there is no training from data or
    identifying patterns from data. They are explainable because they are designed
    by programmers and each line of the program has a predefined meaning. Finally,
    they are traceable as we can debug every step of these programs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将这些传统算法视为确定性的、可解释的和可追溯的。这意味着软件工程师的设计决策在算法中得到了记录，并且算法可以在之后进行分析。它们是确定性的，因为它们是基于规则编写的；没有从数据中训练或从数据中识别模式。它们是可解释的，因为它们是由程序员设计的，程序中的每一行都有预定义的含义。最后，它们是可追溯的，因为我们能够调试这些程序的每一步。
- en: However, there is a drawback – the software engineer needs to thoroughly consider
    all corner cases and understand the problem very well. The data that the software
    engineer uses is only to support them in analyzing the algorithm, not training
    it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在一个缺点——软件工程师需要彻底考虑所有边界情况，并且非常了解问题。软件工程师使用的这些数据只是为了支持他们分析算法，而不是用于训练算法。
- en: An example of a system that can be implemented using both machine learning algorithms
    and traditional ones is one for reading passport information. Instead of using
    machine learning for image recognition, the software uses specific marks in the
    passport (usually the `<<<` sequence of characters) to mark the beginning of the
    line or the beginning of the sequence of characters denoting a surname. These
    marks can be recognized quite quickly using rule-based **optical character recognition**
    (**OCR**) algorithms without the need for deep learning or CNNs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以使用机器学习算法和传统算法实现的系统示例是读取护照信息的系统。而不是使用机器学习进行图像识别，软件使用护照中的特定标记（通常是`<<<`字符序列）来标记行首或表示姓氏的字符序列的开始。这些标记可以使用基于规则的**光学字符识别**（**OCR**）算法快速识别，无需深度学习或CNN。
- en: Therefore, I would like to introduce the first best practice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我想介绍第一条最佳实践。
- en: 'Best practice #1'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '最佳实践 #1'
- en: Use machine learning algorithms when your problem is focused on data, not on
    the algorithm.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的问题集中在数据而不是算法时，使用机器学习算法。
- en: When selecting the right technology, we need to understand whether it is based
    on the classical approach, where the design of the algorithm is in focus, or whether
    we need to focus on handling data and finding patterns in it. It is usually beneficial
    to start with the following guidelines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择合适的技术时，我们需要了解它是否基于经典方法，其中算法的设计是重点，或者我们是否需要专注于处理数据和在其中寻找模式。通常，以下指导方针是有益的。
- en: If the problem requires processing large quantities of data in raw format, use
    the machine learning approach. Examples of such systems are conversational bots,
    image recognition tools, text processing tools, or even prediction systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题需要处理大量原始格式的数据，则使用机器学习方法。这类系统的例子包括对话机器人、图像识别工具、文本处理工具，甚至是预测系统。
- en: However, if the problem requires traceability and control, use the traditional
    approach. Examples of such systems are control software in cars (anti-lock braking,
    engine control, and so on) and embedded systems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果问题需要可追溯性和控制，则使用传统方法。这类系统的例子包括汽车中的控制软件（如防抱死制动系统、发动机控制等）和嵌入式系统。
- en: If the problem requires new data to be generated based on the existing data,
    a process known as *data manipulation*, use the machine learning approach. Examples
    of such systems are image manipulation programs (DALL-E), text generation programs,
    deep fake programs, and source code generation programs (GitHub Copilot).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题需要根据现有数据生成新数据，即所谓的*数据处理*过程，请使用机器学习方法。这类系统的例子包括图像处理程序（DALL-E）、文本生成程序、深度伪造程序和源代码生成程序（GitHub
    Copilot）。
- en: If the problem requires adaptation over time and optimization, use machine learning
    software. Examples of such systems are power grid optimization software, non-playable
    character behavior components in computer games, playlist recommendation systems,
    and even GPS navigation systems in modern cars.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题需要随着时间的推移进行适应和优化，请使用机器学习软件。这类系统的例子包括电网优化软件、计算机游戏中的非玩家角色行为组件、播放列表推荐系统，甚至现代汽车的GPS导航系统。
- en: However, if the problem requires stability and traceability, use the traditional
    approach. Examples of such systems are systems to make diagnoses and recommendation
    systems in medicine, safety-critical systems in cars, planes, and trains, and
    infrastructure controlling and monitoring systems.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果问题需要稳定性和可追溯性，请使用传统方法。这类系统的例子包括医学中的诊断和推荐系统、汽车、飞机和火车中的安全关键系统，以及基础设施控制和监控系统。
- en: Supervised, unsupervised, and reinforcement learning – it is just the beginning
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监督学习、无监督学习和强化学习——这只是开始
- en: 'Now is a good time to mention that the field of machine learning is huge, and
    it is organized into three main areas – supervised learning, unsupervised learning,
    and reinforcement learning. Each of these areas has hundreds of different algorithms.
    For example, the area of supervised learning has over 1,000 algorithms, all of
    which can be automatically selected by meta-heuristic algorithms such as AutoML:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是提到机器学习领域非常庞大的时候了，它被组织成三个主要领域——监督学习、无监督学习和强化学习。每个领域都有数百种不同的算法。例如，监督学习领域有超过1,000种算法，所有这些都可以通过元启发式算法如AutoML自动选择：
- en: '**Supervised learning**: This is a group of algorithms that are trained based
    on annotated data. The data that’s used in these algorithms needs to have a *target*
    or a *label*. The label is used to tell the algorithm which pattern to look for.
    For example, such a label can be *cat* or *dog* for each image that the supervised
    learning model needs to recognize. Historically, supervised learning algorithms
    are the oldest ones as they come directly from statistical methods such as linear
    regression and multinomial regression. Modern algorithms are advanced and include
    methods such as deep learning neural networks, which can recognize objects in
    3D images and segment them accordingly. The most advanced algorithms in this area
    are deep learning and multimodal models, which can process text and images at
    the same time.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监督学习**：这是一组基于标注数据进行训练的算法。这些算法中使用的数据需要有一个*目标*或*标签*。标签用于告诉算法寻找哪种模式。例如，这样的标签可以是监督学习模型需要识别的每张图像的*猫*或*狗*。历史上，监督学习算法是最古老的，因为它们直接来自如线性回归和多项式回归等统计方法。现代算法更先进，包括深度学习神经网络等方法，可以识别3D图像中的对象并相应地进行分割。该领域最先进的算法是深度学习和多模态模型，它们可以同时处理文本和图像。'
- en: A sub-group of supervised learning algorithms is **self-supervised models**,
    which are often based on transformer architectures. These models do not require
    labels in the data, but they use the data itself as labels. The most prominent
    examples of these algorithms are translation models for natural languages and
    generative models for images or texts. Such algorithms are trained by masking
    words in the original texts and predicting them. For the generative models, these
    algorithms are trained by masking parts of their output to predict it.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 监督学习算法的一个子集是**自监督模型**，它们通常基于转换器架构。这些模型不需要数据中的标签，但它们使用数据本身作为标签。这些算法中最突出的例子是自然语言的翻译模型和图像或文本的生成模型。这些算法通过在原始文本中遮蔽单词并预测它们来训练。对于生成模型，这些算法通过遮蔽其输出的部分来预测它进行训练。
- en: '**Unsupervised learning**: This is a group of models that are applied to find
    patterns in data without any labels. These models are not trained, but they use
    statistical properties of the input data to find patterns. Examples of such algorithms
    are clustering algorithms and semantic map algorithms. The input data for these
    algorithms is not labeled and the goal of applying these algorithms is to find
    structure in the dataset according to similarities; these structures can then
    be used to add labels to this data. We encounter these algorithms daily when we
    get recommendations for products to buy, books to read, music to listen to, or
    films to watch.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无监督学习**：这是一组应用于在数据中寻找模式而不需要任何标签的模型。这些模型未经训练，但它们使用输入数据的统计特性来寻找模式。这类算法的例子包括聚类算法和语义映射算法。这些算法的输入数据没有标签，应用这些算法的目标是根据相似性在数据集中找到结构；然后，这些结构可以用来为这些数据添加标签。当我们得到购买产品、阅读书籍、听音乐或看电影的建议时，我们每天都会遇到这些算法。'
- en: '**Reinforcement learning**: This is a group of models that are applied to data
    to solve a particular task given a goal. For these models, we need to provide
    this goal in addition to the data. It is called the *reward function,* and it
    is an expression that defines when we achieve the goal. The model is trained based
    on this fitness function. Examples of such models are algorithms that play Go,
    Chess, or StarCraft. These algorithms are also used to solve hard programming
    problems (AlphaCode) or optimize energy consumption.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强化学习**：这是一组应用于数据以解决特定任务的模型。对于这些模型，我们除了需要提供数据外，还需要提供目标。这被称为*奖励函数*，它是一个定义我们何时达到目标的表达式。模型基于这个适应函数进行训练。这类模型的例子包括玩围棋、象棋或星际争霸的算法。这些算法也被用来解决困难的编程问题（AlphaCode）或优化能耗。'
- en: So, let me introduce the second best practice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我介绍第二个最佳实践。
- en: 'Best practice #2'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '最佳实践 #2'
- en: Before you start developing a machine learning system, do due diligence and
    identify the right group of algorithms to use.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始开发机器学习系统之前，要进行尽职调查，并确定使用正确的算法组。
- en: As each of these groups of models has different characteristics, solves different
    problems, and requires different data, a mistake in selecting the right algorithm
    can be costly. Supervised models are very good at solving problems related to
    predictions and classifications. The most powerful models in this area can compete
    with humans in selected areas – for example, GitHub Copilot can create programs
    that can pass as human-written. Unsupervised models are very powerful if we want
    to group entities and make recommendations. Finally, reinforcement learning models
    are the best when we want to have continuous optimization with the need to retrain
    models every time the data or the environment changes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些模型组各自具有不同的特性，解决不同的问题，并需要不同的数据，选择错误算法可能会造成高昂的代价。监督模型在解决与预测和分类相关的问题上非常出色。在这个领域中最强大的模型可以在选定的领域与人类竞争——例如，GitHub
    Copilot可以创建可以以人类编写的程序。无监督模型在需要将实体分组并做出推荐时非常强大。最后，当我们需要连续优化并且每次数据或环境变化时都需要重新训练模型时，强化学习模型是最好的选择。
- en: Although all these models are based on statistical learning, they are all components
    of larger systems to make them useful. Therefore, we need to understand how this
    probabilistic and statistical nature of machine learning goes with traditional,
    digital software products.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有这些模型都基于统计学习，但它们都是更大系统的一部分，以便使它们变得有用。因此，我们需要了解机器学习的这种概率和统计性质如何与传统、数字软件产品相结合。
- en: An example of traditional and machine learning software
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统机器学习和机器学习软件的例子
- en: To illustrate the difference between traditional software and machine learning
    software, let’s implement the same program using these two paradigms. We’ll implement
    a program that calculates a Fibonacci sequence using the traditional approach,
    which we have seen a million times in computer science courses. Then, we’ll implement
    the same program using machine learning models – or one model to be exact – that
    is, logistic regression.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明传统软件和机器学习软件之间的区别，让我们使用这两种范式实现相同的程序。我们将使用传统方法实现一个计算斐波那契序列的程序，这在计算机科学课程中我们已经见过无数次。然后，我们将使用机器学习模型——确切地说是一个模型——来实现相同的程序，即逻辑回归。
- en: 'The traditional implementation is presented here. It is based on one recursive
    function and a loop that tests it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了传统的实现方式。它基于一个递归函数和一个测试它的循环：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The implementation is very simple and is based on the algorithm – in our case,
    the `fibRec` function. It is simplistic, but it has its limitations. The first
    one is its recursive implementation, which costs resources. Although it can be
    written as an iterative one, it still suffers from the second problem – it is
    focused on the calculations and not on the data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简单，基于算法——在我们的案例中，是`fibRec`函数。它很简单，但有其局限性。第一个是其递归实现，这会消耗资源。尽管它可以写成迭代形式，但它仍然存在第二个问题——它专注于计算而不是数据。
- en: 'Now, let’s see how the machine learning implementation is done. I’ll explain
    this by dividing it into two parts – data preparation and model training/inference:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看机器学习实现的步骤。我将通过将其分为两部分来解释——数据准备和模型训练/推理：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the case of machine learning software, we prepare data to train the algorithm.
    In our case, this is the `dfTrain` DataFrame. It is a table that contains the
    numbers that the machine learning algorithm needs to find the pattern.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习软件的情况下，我们准备数据来训练算法。在我们的案例中，这是`dfTrain` DataFrame。它是一个表格，包含机器学习算法需要找到模式的数字。
- en: Please note that we prepared two datasets – `dfTrain`, which contains the numbers
    to train the algorithm, and `lstSequence`, which is the sequence of Fibonacci
    numbers that we’ll find later.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们准备了两个数据集——`dfTrain`，其中包含训练算法所需的数字，以及`lstSequence`，这是我们稍后将找到的斐波那契数列。
- en: 'Now, let’s start training the algorithm:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始训练算法：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The magic of the entire code fragment is in the bold-faced code – the `model.fit`
    method call. This method trains the logistic regression model based on the data
    we prepared for it. The model itself is created one line above, in the `model
    =` `LinearRegression()` line.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码片段的魔力在于加粗的代码——`model.fit`方法的调用。此方法基于我们为其准备的数据训练逻辑回归模型。模型本身是在上一行的`model =
    LinearRegression()`行中创建的。
- en: 'Now, we can make inferences or create new Fibonacci numbers using the following
    code fragment:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码片段进行推理或创建新的斐波那契数：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code fragment contains a similar line to the previous one – `model.predict()`.
    This line uses the previously created model to make an inference. Since the Fibonacci
    sequence is recursive, we need to add the newly created number to the list before
    we can make the new inference, which is done in the `lstSequence.append()` line.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段包含与上一个类似的行——`model.predict()`。此行使用先前创建的模型进行推理。由于斐波那契数列是递归的，我们需要在`lstSequence.append()`行中将新创建的数字添加到列表中，然后才能进行新的推理。
- en: Now, it is very important to emphasize the difference between these two ways
    of solving the same problem. The traditional implementation *exposes* the algorithm
    used to create the numbers. We do not see the Fibonacci sequence there, but we
    can see how it is calculated. The machine learning implementation *exposes* the
    data used to create the numbers. We see the first sequence as training data, but
    we never see how the model creates that sequence. We do not know whether that
    model is always correct – we would need to test it against the real sequence –
    simply because we do not know how the algorithm works. This takes us to the next
    part, which is about just that – probabilities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在非常重要的一点是要强调这两种解决相同问题的方法之间的区别。传统的实现*暴露*了用于创建数字的算法。在那里我们看不到斐波那契数列，但我们可以看到它是如何计算的。机器学习实现*暴露*了用于创建数字的数据。我们看到第一个序列作为训练数据，但我们从未看到模型是如何创建该序列的。我们不知道该模型是否总是正确的——我们需要将其与真实序列进行测试——仅仅因为我们不知道算法是如何工作的。这引出了下一个部分，也就是关于概率的部分。
- en: Probability and software – how well they go together
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概率与软件——它们如何相得益彰
- en: The fundamental characteristic that makes machine learning software different
    from traditional software is the fact that the core of machine learning models
    is statistics. This statistical learning means that the output of the machine
    learning model is a probability and, as such, it is not as clear as in traditional
    software systems.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使机器学习软件与传统软件不同的基本特征是，机器学习模型的核心是统计学。这种统计学习意味着机器学习模型的输出是一个概率，因此它不如传统软件系统那样清晰。
- en: 'The probability, which is the result of the model, means that the answer we
    receive is a probability of something. For example, if we classify an image to
    check whether it contains a dog or a cat, the result of this classification is
    a probability – for example, there is a 93% probability that the image contains
    a dog and a 7% probability that it contains a cat. This is illustrated in *Figure
    1**.3*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 概率，即模型的结果，意味着我们收到的答案是某事的概率。例如，如果我们对一张图片进行分类以检查它是否包含狗或猫，这个分类的结果就是一个概率——例如，有 93%
    的概率该图片包含狗，有 7% 的概率包含猫。这如图 *图 1**.3* 所示：
- en: '![Figure 1.3 – Probabilistic nature of machine learning software](img/B19548_01_3.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 机器学习软件的概率性质](img/B19548_01_3.jpg)'
- en: Figure 1.3 – Probabilistic nature of machine learning software
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 机器学习软件的概率性质
- en: To use these probabilistic results in other parts of the software, or other
    systems, the machine learning software usually uses thresholds (for example, if
    `x<0.5`) to provide only one result. Such thresholds specify which probability
    is acceptable to be able to consider the results to belong to a specific class.
    For our example of image classification, this probability would be 50% – if the
    probability of identifying a dog in the image is larger than 50%, then the model
    states that the image contains a dog (without the probability).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要在其他软件部分或其他系统中使用这些概率结果，机器学习软件通常使用阈值（例如，如果 `x<0.5`）来只提供单一结果。这些阈值指定了哪些概率是可以接受的，以便将结果考虑为属于特定类别。以我们的图像分类为例，这个概率将是
    50%——如果识别图像中狗的概率大于 50%，则模型表示该图像包含狗（不包含概率）。
- en: Changing these probabilistic results to digital ones, as we did in the previous
    example, is often correct, but not always. Especially in corner cases, such as
    when the probability is close to the threshold’s lower bound, the classification
    can lead to errors and thus to software failures. Such failures are often negligible,
    but not always. In safety-critical systems, there should be no mistakes as they
    can lead to unnecessary hazards with potentially catastrophic consequences.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些概率结果转换为数字，就像我们在前面的例子中所做的那样，通常是正确的，但并不总是如此。特别是在边缘情况下，例如当概率接近阈值的下限时，分类可能导致错误，从而引起软件故障。这样的故障通常是可以忽略的，但并不总是如此。在安全关键系统中，不应有任何错误，因为它们可能导致不必要的危害，并可能产生灾难性的后果。
- en: In contexts where the probabilistic nature of machine learning software is problematic,
    but we still need machine learning for its other benefits, we can construct mechanisms
    that mitigate the consequences of mispredictions, misclassifications, and sub-optimizations.
    These mechanisms can guard the machine learning models and prevent them from suggesting
    wrong recommendations. For example, when we use machine learning image classification
    in the safety system of a car, we construct a so-called *safety cage* around the
    model. This safety cage is a non-machine learning component that uses rules to
    check whether a specific recommendation, classification, or prediction is plausible
    in the specific context. It can, for instance, prevent a car from suddenly stopping
    for a non-existent traffic light signal on a highway, which is a consequence of
    a misclassification of a camera feed from the front camera.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习软件的概率性质成为问题，但我们仍然需要机器学习以利用其其他好处的情况下，我们可以构建机制来减轻误判、误分类和次优化的后果。这些机制可以保护机器学习模型，防止它们提出错误的建议。例如，当我们使用机器学习图像分类在汽车的安全系统中时，我们在模型周围构建了一个所谓的
    *安全笼*。这个安全笼是一个非机器学习组件，它使用规则来检查在特定环境中某个建议、分类或预测是否合理。例如，它可以防止汽车在高速公路上突然停车，因为这是由前摄像头摄像头的误分类引起的。
- en: Therefore, let’s look at another best practice that encourages the use of machine
    learning software even in safety-critical systems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看另一个最佳实践，它鼓励在安全关键系统中使用机器学习软件。
- en: 'Best practice #3'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '最佳实践 #3'
- en: If your software is safety-critical, make sure that you can design mechanisms
    to prevent hazards caused by the probabilistic nature of machine learning.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的软件是安全关键的，确保你可以设计机制来防止由机器学习软件的概率性质引起的安全隐患。
- en: 'Although this best practice is formulated toward safety-critical systems, it
    is more general than that. Even for mission-critical or business-critical systems,
    we can construct mechanisms that can gatekeep the machine learning models and
    prevent erroneous behavior of the entire software system. An example of how such
    a cage can be constructed is shown in *Figure 1**.4*, where the gatekeeper component
    provides an additional signal that the model’s prediction cannot be trusted/used:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个最佳实践是针对关键安全系统制定的，但它比这更普遍。即使是任务关键或业务关键系统，我们也可以构建机制来门控机器学习模型，并防止整个软件系统的错误行为。如何构建这样一个笼子的一个例子在*图
    1**.4*中显示，其中门控器组件提供了一个额外的信号，表明模型的预测不可信/不可用：
- en: '![Figure 1.4 – Gatekeeping of machine learning models](img/B19548_01_4.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 机器学习模型的门控](img/B19548_01_4.jpg)'
- en: Figure 1.4 – Gatekeeping of machine learning models
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 机器学习模型的门控
- en: In this figure, the additional component is placed as the last one in this processing
    pipeline to ensure that the result is always binary (for this case). In other
    cases, such a gatekeeper can be placed in parallel to the machine learning model
    and can act as a parallel processing flow, where data quality is checked rather
    than the classification model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，附加组件被放置在处理管道的最后，以确保结果始终是二元的（对于这种情况）。在其他情况下，这样的门控器可以与机器学习模型并行放置，并可以作为并行处理流程，检查数据质量而不是分类模型。
- en: Such gatekeeper models are used quite frequently, such as when detecting objects
    in perception systems – the model detects objects in individual images, while
    the gatekeeper checks that the same object is identified consistently over sequences
    of consecutive images. They can form redundant processing channels and pipelines.
    They can form feasibility-checking components, or they can correct out-of-bounds
    results into proper values. Finally, they can also disconnect machine learning
    components from the pipeline and adapt these pipelines to other components of
    the software, usually algorithms that make decisions – thus forming self-adaptive
    or self-healing software systems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的门控器模型被相当频繁地使用，例如在感知系统检测对象时 – 模型检测单个图像中的对象，而门控器检查在一系列连续图像中是否一致地识别出相同的对象。它们可以形成冗余的处理通道和管道。它们可以形成可行性检查组件，或者可以将超出范围的输出结果更正为适当的值。最后，它们还可以将机器学习组件从管道中断开，并将这些管道适应软件的其他组件，通常是做出决策的算法
    – 从而形成自适应或自修复的软件系统。
- en: This probabilistic nature of machine learning software means that pre-deployment
    activities are different from the traditional software. In particular, the process
    of testing machine learning and traditional software is different.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习软件的这种概率性质意味着部署前的活动与传统软件不同。特别是，测试机器学习和传统软件的过程是不同的。
- en: Testing and evaluation – the same but different
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和评估 – 相同但不同
- en: Every machine learning model needs to be validated, which means that the model
    needs to be able to provide correct inferences for a dataset that the model did
    not see before. The goal is to assess whether the model has learned patterns in
    the data, the data itself, or neither. The typical measures of correctness in
    classification problems are accuracy (the quotient of correctly inferred instances
    to all classified instances), **Area Under Curve/Receiver Operation Characteristics**
    (**AUROC**), and the **true positive ratio** (**TPR**) and **false positive**
    **ratio** (**FPR**).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个机器学习模型都需要经过验证，这意味着模型需要能够为模型之前未见过的一个数据集提供正确的推理。目标是评估模型是否在数据中学习了模式，数据本身，或者两者都不是。分类问题中正确性的典型度量是准确率（正确推断的实例数与所有分类实例数的商），**曲线下面积/接收器操作特性**（**AUROC**），以及**真正例率**（**TPR**）和**假正例率**（**FPR**）。
- en: 'For prediction problems, the quality of the model is measured in the mispredictions,
    such as the **mean squared error** (**MSE**). These measures quantify the errors
    in predictions – the smaller the values, the better the model. *Figure 1**.5*
    shows the process for the most common form of supervised learning:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预测问题，模型的质量通过误预测来衡量，例如**均方误差**（**MSE**）。这些度量量化了预测中的错误 – 值越小，模型越好。*图 1**.5*显示了最常见形式监督学习的评估过程：
- en: '![Figure 1.5 – Model evaluation process for supervised learning](img/B19548_01_5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 监督学习模型评估过程](img/B19548_01_5.jpg)'
- en: Figure 1.5 – Model evaluation process for supervised learning
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 监督学习模型评估过程
- en: In this process, the model is subjected to different data for every iteration
    of training, after which it is used to make inferences (classifications or regression)
    on the same test data. The test data is set aside before training, and it is used
    as input to the model only when validating, never during training.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，模型在每次训练迭代中都会接受不同的数据，之后它被用来对相同的测试数据进行推断（分类或回归）。测试数据在训练之前就被留出，并且仅在验证时作为模型的输入，永远不会在训练期间使用。
- en: Finally, some models are reinforcement learning models, where the quality is
    assessed by the ability of the model to optimize the output according to a predefined
    function (reward function). These measures allow the algorithm to optimize its
    operations and find the optimal solution – for example, in genetic algorithms,
    self-driving cars, or energy grid operations. The challenge with these models
    is that there is no single metric that can measure performance – it depends on
    the scenario, the function, and the amount of training that the model received.
    One famous example of such training is the algorithm from the *War Games* movie
    (from 1983), where the main supercomputer plays millions of tic-tac-toe games
    to understand that there is no strategy to win – the game has no winner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些模型是强化学习模型，其质量通过模型根据预定义函数（奖励函数）优化输出的能力来评估。这些措施允许算法优化其操作并找到最优解——例如，在遗传算法、自动驾驶汽车或能源网格操作中。这些模型的挑战在于没有单一的指标可以衡量性能——它取决于场景、函数以及模型接收到的训练量。一个著名的此类训练的例子是来自1983年电影《战争游戏》中的算法，其中主要超级计算机玩数百万个井字棋游戏，以理解没有获胜策略——游戏没有赢家。
- en: '*Figure 1**.6* presents the process of training a reinforcement system graphically:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.6*以图形方式展示了训练强化系统的过程：'
- en: '![Figure 1.6 – Reinforcement learning training process](img/B19548_01_6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 强化学习训练过程](img/B19548_01_6.jpg)'
- en: Figure 1.6 – Reinforcement learning training process
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 强化学习训练过程
- en: We could get the impression that training, testing, and validating machine learning
    models are all we need when developing machine learning software. This is far
    from being true. The models are parts of larger systems, which means that they
    need to be integrated with other components; these components are not validated
    in the process of validation described in *Figure 1**.5* and *Figure 1**.6*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会产生这样的印象，当开发机器学习软件时，我们只需要训练、测试和验证机器学习模型。这远远不是真的。这些模型是更大系统的一部分，这意味着它们需要与其他组件集成；这些组件在*图1.5*和*图1.6*中描述的验证过程中并未得到验证。
- en: Every software system needs to undergo rigorous testing before it can be released.
    The goal of this testing is to find and remove as many defects as possible so
    that the user of the software experiences the best possible quality. Typically,
    the process of testing software is a process that comprises multiple phases. The
    process of testing follows the process of software development and aligns with
    that. In the beginning, software engineers (or testers) use unit tests to verify
    the correctness of their components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件系统在发布之前都需要经过严格的测试。测试的目标是尽可能多地发现和消除缺陷，以便软件用户能够体验到最佳的质量。通常，测试软件的过程是一个包含多个阶段的流程。测试过程遵循软件开发过程，并与之一致。最初，软件工程师（或测试人员）使用单元测试来验证其组件的正确性。
- en: '*Figure 1**.7* presents how these three types of testing are related to one
    another. In unit testing, the focus is on algorithms. Often, this means that the
    software engineers must test individual functions and modules. Integration testing
    focuses on the connections between modules and how they can conduct tasks together.
    Finally, system testing and acceptance testing focus on the entire software product.
    The testers imitate real users to check that the software fulfills the requirements
    of the users:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.7*展示了这三种测试类型是如何相互关联的。在单元测试中，重点是算法。通常，这意味着软件工程师必须测试单个函数和模块。集成测试关注模块之间的连接以及它们如何共同执行任务。最后，系统测试和验收测试关注整个软件产品。测试人员模仿真实用户来检查软件是否满足用户的需求：'
- en: '![Figure 1.7 – Three types of software testing – unit testing (left), integration
    testing (middle), and system and acceptance testing (right)](img/B19548_01_7.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 三种软件测试类型 – 单元测试（左）、集成测试（中）和系统及验收测试（右）](img/B19548_01_7.jpg)'
- en: Figure 1.7 – Three types of software testing – unit testing (left), integration
    testing (middle), and system and acceptance testing (right)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 三种软件测试类型 – 单元测试（左）、集成测试（中）和系统及验收测试（右）
- en: The software testing process is very different than the process of model validation.
    Although we could mistake unit testing for model validation, this is not entirely
    the case. The output from the model validation process is one of the metrics (for
    example, accuracy), whereas the output from the unit test is `true/false` – whether
    the software produces the expected output or not. No known defects (equivalent
    to the false test results) are acceptable for a software company.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试过程与模型验证过程非常不同。尽管我们可以将单元测试误认为是模型验证，但这并不完全正确。模型验证过程的输出是其中一个指标（例如，准确率），而单元测试的输出是`true/false`——软件是否产生了预期的输出。对于软件公司来说，没有已知的缺陷（相当于错误的测试结果）是可以接受的。
- en: In traditional software testing, software engineers prepare a set of test cases
    to check whether their software works according to the specification. In machine
    learning software, the process of testing is based on setting aside part of the
    dataset (the test set) and checking how well the trained model (on the train set)
    works on that data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的软件测试中，软件工程师准备一系列测试用例来检查他们的软件是否按照规格工作。在机器学习软件中，测试过程基于留出一部分数据集（测试集）并检查训练好的模型（在训练集上）在该数据上的表现如何。
- en: Therefore, here is my fourth best practice for testing machine learning systems.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我关于测试机器学习系统的第四个最佳实践。
- en: 'Best practice #4'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '最佳实践 #4'
- en: Test the machine learning software as an addition to the typical train-validation-evaluation
    process of machine learning model development.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将机器学习软件测试作为机器学习模型开发典型训练-验证-评估流程的补充。
- en: Testing the entire system is very important as the entire software system contains
    mechanisms to cope with the probabilistic nature of machine learning components.
    One such mechanism is the safety cage mechanism, where we can monitor the behavior
    of the machine learning components and prevent them from providing low-quality
    signals to the rest of the system (in the case of corner cases, close to the decision
    boundaries, in the inference process).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 测试整个系统非常重要，因为整个软件系统包含处理机器学习组件概率性质的机制。其中一种机制是安全笼机制，我们可以监控机器学习组件的行为，防止它们向系统其他部分提供低质量信号（在边缘情况、接近决策边界、推理过程中）。
- en: When we test the software, we also learn about the limitations of the machine
    learning components and our ability to handle the corner cases. Such knowledge
    is important for deploying the system when we need to specify the operational
    environment for the software. We need to understand the limitations related to
    the requirements and the specification of the software – the use cases for our
    software. Even more importantly, we need to understand the implications of the
    use of the software in terms of ethics and trustworthiness.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试软件时，我们也会了解机器学习组件的限制以及我们处理边缘情况的能力。这种知识对于在需要为软件指定操作环境时部署系统非常重要。我们需要了解与软件需求和规格相关的限制——我们软件的使用案例。更重要的是，我们需要了解软件使用的伦理和可靠性方面的含义。
- en: We’ll discuss ethics in [*Chapter 15*](B19548_15.xhtml#_idTextAnchor179) and
    [*Chapter 16*](B19548_16.xhtml#_idTextAnchor187), but it is important to understand
    that we need to consider ethics from the very beginning. If we don’t, we risk
    that our system makes potentially harmful mistakes, such as the ones made by large
    artificial intelligence hiring systems, face recognition systems, or self-driving
    vehicles. These harmful mistakes entail monetary costs, but more importantly,
    they entail loss of trust in the product and even missed opportunities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第15章*](B19548_15.xhtml#_idTextAnchor179)和[*第16章*](B19548_16.xhtml#_idTextAnchor187)中讨论伦理问题，但重要的是要理解我们需要从一开始就考虑伦理问题。如果我们不这样做，我们的系统可能会犯出潜在的有害错误，例如大型人工智能招聘系统、人脸识别系统或自动驾驶汽车所犯的错误。这些有害错误涉及货币成本，但更重要的是，它们涉及对产品的信任损失，甚至错失机会。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Machine learning and traditional software are often perceived as two alternatives.
    However, they are more like siblings – one cannot function without the other.
    Machine learning models are very good at solving constrained problems, but they
    require traditional software for data collection, preparation, and presentation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习与传统软件通常被视为两种替代品。然而，它们更像是兄弟姐妹——一个不能没有另一个。机器学习模型在解决约束性问题方面非常出色，但它们需要传统软件进行数据收集、准备和展示。
- en: The probabilistic nature of machine learning models requires additional elements
    to make them useful in the context of complete software products. Therefore, we
    need to embrace this nature and use it to our advantage. Even for safety-critical
    systems, we could (and should) use machine learning when we know how to design
    safety mechanisms to prevent hazardous consequences.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型的概率性质需要额外的元素才能使它们在完整的软件产品环境中变得有用。因此，我们需要接受这种性质并利用它来发挥优势。即使对于安全关键系统，如果我们知道如何设计安全机制来防止危险后果，我们也可以（并且应该）使用机器学习。
- en: In this chapter, we explored the differences between machine learning software
    and traditional software while focusing on how to design software that can contain
    both parts. We also showed that there is much more to machine learning software
    than just training, testing, and evaluating the model – we showed that rigorous
    testing makes sense and is necessary for deploying reliable software.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了机器学习软件与传统软件之间的差异，同时关注如何设计能够包含这两部分的软件。我们还展示了机器学习软件不仅仅是训练、测试和评估模型，我们还展示了严格的测试对于部署可靠的软件是有意义且必要的。
- en: Now, it is time to move on to the next chapter, where we’ll open up the black
    box of machine learning software and explore what we need to develop a complete
    machine learning software product – starting from data acquisition and ending
    with user interaction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进入下一章了，我们将揭开机器学习软件的黑箱，探讨我们需要开发一个完整的机器学习软件产品所需的内容——从数据采集开始，到用户交互结束。
- en: References
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: '*Shortliffe, E.H., et al., Computer-based consultations in clinical therapeutics:
    explanation and rule acquisition capabilities of the MYCIN system. Computers and
    biomedical research, 1975\. 8(4):* *p. 303-320.*'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shortliffe, E.H. 等，基于计算机的临床治疗咨询：MYCIN 系统的解释和规则获取能力。计算机与生物医学研究，1975年，第8卷第4期：*
    *p. 303-320。*'
- en: '*James, G., et al., An introduction to statistical learning. Vol. 112\.* *2013:
    Springer.*'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*James, G. 等，统计学习引论。第112卷。Springer，2013年。*'
- en: '*Saleh, H., Machine Learning Fundamentals: Use Python and scikit-learn to get
    up and running with the hottest developments in machine learning. 2018: Packt*
    *Publishing Ltd.*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Saleh, H.，机器学习基础：使用 Python 和 scikit-learn 开始使用机器学习的最新发展。Packt 出版公司，2018年。*'
- en: '*Raschka, S. and V. Mirjalili, Python machine learning: Machine learning and
    deep learning with Python, scikit-learn, and TensorFlow 2\. 2019: Packt* *Publishing
    Ltd.*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Raschka, S. 和 V. Mirjalili, Python 机器学习：使用 Python、scikit-learn 和 TensorFlow
    2 的机器学习和深度学习，Packt 出版公司，2019年。*'
- en: '*Sommerville, I., Software engineering. 10th. Book Software Engineering. 10th,
    Series Software* *Engineering, 2015.*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sommerville, I.，软件工程。第10版。软件工程书籍。第10版，软件工程系列，2015年。*'
- en: '*Houpis, C.H., G.B. Lamont, and B. Lamont, Digital control systems: theory,
    hardware, software. 1985: McGraw-Hill* *New York.*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Houpis, C.H.，G.B. Lamont 和 B. Lamont，数字控制系统：理论、硬件、软件。McGraw-Hill，纽约，1985年。*'
- en: '*Sawhney, R., Can artificial intelligence make software development more productive?
    LSE Business* *Review, 2021.*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sawhney, R.，人工智能能否使软件开发更高效？LSE 商业评论，2021年。*'
- en: '*He, X., K. Zhao, and X. Chu, AutoML: A survey of the state-of-the-art. Knowledge-Based
    Systems.* *2021\. 212:* *p. 106622.*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*He, X.，K. Zhao 和 X. Chu，AutoML：最新技术的调查。知识库系统。2021年，第212卷：* *p. 106622。*'
- en: '*Reed, S., et al., A generalist agent. arXiv preprint* *arXiv:2205.06175, 2022.*'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Reed, S. 等，通用代理。arXiv 预印本 *arXiv:2205.06175，2022年。*'
- en: '*Floridi, L. and M. Chiriatti, GPT-3: Its nature, scope, limits, and consequences.
    Minds and Machines, 2020\. 30(4):* *p. 681-694.*'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Floridi, L. 和 M. Chiriatti，GPT-3：其本质、范围、局限性和后果。心智与机器，2020年，第30卷第4期：* *p. 681-694。*'
- en: '*Creswell, A., et al., Generative adversarial networks: An overview. IEEE signal
    processing magazine, 2018\. 35(1):* *p. 53-65.*'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Creswell, A. 等，生成对抗网络：概述。IEEE 信号处理杂志，2018年，第35卷第1期：* *p. 53-65。*'
- en: '*Celebi, M.E. and K. Aydin, Unsupervised learning algorithms.* *2016: Springer.*'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Celebi, M.E. 和 K. Aydin，无监督学习算法。Springer，2016年。*'
- en: '*Chen, J.X., The evolution of computing: AlphaGo. Computing in Science & Engineering,
    2016\. 18(4):* *p. 4-7.*'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Chen, J.X., 计算机发展的演变：AlphaGo。科学工程计算，2016年。18(4)：* *p. 4-7.*'
- en: '*Ko, J.-S., J.-H. Huh, and J.-C. Kim, Improvement of energy efficiency and
    control performance of cooling system fan applied to Industry 4.0 data center.
    Electronics, 2019\. 8(5):* *p. 582.*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ko, J.-S., J.-H. Huh, and J.-C. Kim, 改进应用于工业4.0数据中心冷却系统风扇的能源效率和控制性能。电子学，2019年。8(5)：*
    *p. 582.*'
- en: '*Dastin, J., Amazon scraps secret AI recruiting tool that showed bias against
    women. In Ethics of Data and Analytics. 2018, Auerbach Publications.* *p. 296-299.*'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dastin, J., 亚马逊废弃了显示对女性有偏见的秘密AI招聘工具。在《数据与分析伦理》中。2018年，Auerbach出版社。* *p. 296-299.*'
- en: '*Castelvecchi, D., Is facial recognition too biased to be let loose? Nature,
    2020\. 587(7834):* *p. 347-350.*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Castelvecchi, D., 面部识别技术是否偏见过大以至于不能放任？自然，2020年。587(7834)：* *p. 347-350.*'
- en: '*Siddiqui, F., R. Lerman, and J.B. Merrill, Teslas running Autopilot involved
    in 273 crashes reported since last year. In The Washington* *Post. 2022.*'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Siddiqui, F., R. Lerman, 和 J.B. Merrill，自去年以来报告的特斯拉Autopilot涉及273起事故。在《华盛顿邮报》中。2022年。*'
