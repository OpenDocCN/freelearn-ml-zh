- en: Searching for Luxury Accommodations Worldwide
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全球范围内搜索豪华住宿
- en: Today the bridal suite, tomorrow a prison. A secret agent's sleeping arrangements
    are horribly unpredictable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天是新娘套房，明天可能是监狱。一个秘密特工的睡眠安排是极其不可预测的。
- en: Each day, someone in MI6 gets the job of booking a stellar hotel room and, conversely,
    some evil henchman has to pick a warehouse or dilapidated apartment, plus a lamp,
    a chair, and implements of bondage. For mini missions or brief beatings, it is
    tolerable to leave the choice of venue to a fallible human being. However, for
    long-term rentals or acquisitions, would it not be wiser to develop a specialized
    search engine that takes the legwork and the guesswork out of the equation?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每天都有人在 MI6 负责预订一个豪华酒店房间，反之，某个邪恶的帮凶必须选择一个仓库或破旧的公寓，再加上一盏灯、一把椅子和束缚工具。对于微型任务或简短的殴打，将地点选择权留给一个有缺陷的人类是可以容忍的。然而，对于长期租赁或收购，不是更明智地开发一个专门的搜索引擎，以消除其中的体力劳动和猜测工作吗？
- en: 'With this motivation, we are going to develop a desktop app called `Luxocator:
    The Luxury Locator`. It is a search engine that finds images on the web by keyword
    search and classifies each image as a luxury, interior scene; luxury, exterior
    scene; Stalinist, interior scene; or Stalinist, exterior scene, according to certain
    visual cues in the image.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '带着这样的动机，我们将开发一个名为 `Luxocator: The Luxury Locator` 的桌面应用程序。它是一个搜索引擎，可以通过关键词搜索在网络上找到图像，并根据图像中的某些视觉线索将每张图像分类为豪华、室内场景；豪华、室外场景；斯大林主义、室内场景；或斯大林主义、室外场景。'
- en: 'Particularly, our classifier relies on comparing statistical distributions
    of color in different images or sets of images. This topic is called **color histogram
    analysis**. We will learn how to efficiently store and process our statistical
    model and how to redistribute it, along with our code, in an application bundle.
    Specifically, this chapter covers the following programming topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们的分类器依赖于比较不同图像或图像集中颜色的统计分布。这个主题被称为**颜色直方图分析**。我们将学习如何高效地存储和处理我们的统计模型，以及如何在应用程序捆绑包中重新分配它，包括我们的代码。具体来说，本章涵盖了以下编程主题：
- en: Using OpenCV's Python bindings, along with the NumPy and SciPy libraries, to
    classify images based on color histogram analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OpenCV 的 Python 绑定，结合 NumPy 和 SciPy 库，根据颜色直方图分析对图像进行分类
- en: Using the Bing Image Search API to acquire images from a web search
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bing 图像搜索 API 从网络搜索中获取图像
- en: Building a GUI application with `wxPython`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `wxPython` 构建 GUI 应用程序
- en: Using PyInstaller to bundle a Python application as an executable that can run
    on other systems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PyInstaller 将 Python 应用程序打包成可在其他系统上运行的可执行文件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter''s project has the following software dependencies:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目有以下软件依赖：
- en: '**A Python environment with the following modules**: OpenCV, NumPy, SciPy,
    Requests, wxPython, and optionally PyInstaller'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以下模块的 Python 环境**：OpenCV、NumPy、SciPy、Requests、wxPython，以及可选的 PyInstaller'
- en: Setup instructions are covered in [Chapter 1](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml),
    *Preparing for the Mission*. Refer to the setup instructions for any version requirements.
    Basic instructions for running Python code are covered in [Appendix C](c44b1aaa-fe12-4054-85fb-37d584f15d3b.xhtml),
    *Running with Snakes (or, First Steps with Python)*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设置说明包含在[第 1 章](e3ac8266-975b-43ca-8221-482a15eb0e05.xhtml)，*准备任务*。请参考设置说明以了解任何版本要求。运行
    Python 代码的基本说明包含在[附录 C](c44b1aaa-fe12-4054-85fb-37d584f15d3b.xhtml)，*与 Python
    一起运行（或，Python 的第一步)*。
- en: The completed project for this chapter can be found in this book's GitHub repository, [https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition](https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition),
    in the `Chapter002` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完成项目可以在本书的 GitHub 仓库中找到，[https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition](https://github.com/PacktPublishing/OpenCV-4-for-Secret-Agents-Second-Edition)，在
    `Chapter002` 文件夹中。
- en: Planning the Luxocator app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划 Luxocator 应用
- en: This chapter uses Python. Being a high-level, interpreted language with great
    third-party libraries for numeric and scientific computing, Python lets us focus
    on the functionality of the system rather than implementing subsystem details.
    For our first project, such a high-level perspective is precisely what we need.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用 Python。作为一种高级、解释型语言，具有强大的第三方库用于数值和科学计算，Python 让我们能够专注于系统的功能，而不是实现子系统细节。对于我们的第一个项目，这种高级视角正是我们所需要的。
- en: 'Let''s look at an overview of Luxocator''s functionality and our choice of
    Python libraries that support this functionality. Like many computer vision applications,
    Luxocator has six basic steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Luxocator的功能概述以及我们选择的支持此功能的Python库。像许多计算机视觉应用一样，Luxocator有六个基本步骤：
- en: '**Acquire a static set of reference images**: For Luxocator, we (the developers)
    choose certain images that we deem to be luxury indoor scenes, other images that
    we consider Stalinist indoor scenes, and so on. We load these images into memory.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取一组静态的参考图像**：对于Luxocator，我们（开发者）选择了一些我们认为属于豪华室内场景的图像，其他一些我们认为属于斯大林主义室内场景的图像，等等。我们将这些图像加载到内存中。'
- en: '**Train a model based on the reference images**: For Luxocator, our model describes
    each image in terms of its normalized color histogram—that is, the distribution
    of colors across the image''s pixels. We use OpenCV and NumPy to perform the calculations.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于参考图像训练模型**：对于Luxocator，我们的模型用图像的归一化颜色直方图来描述每个图像——即图像像素中颜色的分布。我们使用OpenCV和NumPy进行计算。'
- en: '**Store the results of the training**: For Luxocator, we use SciPy to compress
    the reference histograms and write/read them to/from disk.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存储训练结果**：对于Luxocator，我们使用SciPy压缩参考直方图并将它们写入/从磁盘读取。'
- en: '**Acquire a dynamic set of query images**: For Luxocator, we acquire query
    images using the Bing Search API through a Python wrapper. We also use the Requests
    library to download the full-resolution images.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取一组动态的查询图像**：对于Luxocator，我们通过Python包装器使用Bing搜索API获取查询图像。我们还使用Requests库下载全分辨率图像。'
- en: '**Compare the query images to the reference images**: For Luxocator, we compare
    each query image and each reference image based on the intersection of their histograms.
    We then make a classification based on the average results of these comparisons.
    We use NumPy to perform the calculations.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**比较查询图像和参考图像**：对于Luxocator，我们根据它们的直方图交集比较每个查询图像和每个参考图像。然后，我们根据这些比较的平均结果进行分类。我们使用NumPy进行计算。'
- en: '**Present the results of the comparison**: For Luxocator, we provide a GUI
    for initiating a search and navigating the results. This cross-platform GUI is
    developed in `wxPython`. A classification label, such as Stalinist, exterior,
    is shown below each image. See the following screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**展示比较结果**：对于Luxocator，我们提供了一个GUI来启动搜索并导航结果。这个跨平台GUI是用`wxPython`开发的。每个图像下方都显示了一个分类标签，如斯大林主义，外部。请参见以下截图：'
- en: '![](img/1b03f4f2-86f3-4b97-845a-1d148dba3fe2.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b03f4f2-86f3-4b97-845a-1d148dba3fe2.png)'
- en: Optionally, we use PyInstaller to build Luxocator so that it can be deployed
    to users who do not have Python or the aforementioned libraries. However, remember
    that you might need to do extra troubleshooting of your own to make PyInstaller
    work in some environments, including Raspberry Pi or other ARM devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们使用PyInstaller构建Luxocator，以便它可以部署给没有Python或上述库的用户。然而，请记住，你可能需要在自己的环境中进行额外的故障排除，以便PyInstaller能够在某些环境中工作，包括树莓派或其他ARM设备。
- en: Creating, comparing, and storing histograms
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、比较和存储直方图
- en: '"A grey-green color that often finds itself on the walls of public institutions-e.g.,
    hospitals, schools, government buildings—and, where appropriated, on sundry supplies
    and equipment."'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “一种灰色绿色，常出现在公共机构的墙上——例如，医院，学校，政府大楼——以及，当被采用时，在各种各样的供应和设备上。”
- en: – "institutional green", Segen's Medical Dictionary (2012)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: – “机构绿色”，Segen的医学词典（2012）
- en: I hesitate to make sweeping statements about the ideal color of paint on a wall.
    It depends. I have found solace in many walls of many colors. My mother is a painter
    and I like paint in general.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我犹豫着对墙上理想的颜料颜色做出概括性的陈述。这取决于。我在许多不同颜色的墙上找到了安慰。我的母亲是一位画家，我总体上喜欢颜料。
- en: But not all color is paint. Some color is dirt. Some color is concrete or marble,
    plywood or mahogany. Some color is the sky through big windows, the ocean, the
    golf course, the swimming pool, or Jacuzzi. Some color is discarded plastics and
    beer bottles, baked food on the stove, or perished vermin. Some color is unknown.
    Maybe the paint camouflages the dirt.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有颜色都是颜料。有些颜色是污垢。有些颜色是混凝土或大理石，胶合板或桃花心木。有些颜色是大窗户透过的天空，海洋，高尔夫球场，游泳池，或按摩浴缸。有些颜色是丢弃的塑料和啤酒瓶，炉灶上烤焦的食物，或腐烂的害虫。有些颜色是未知的。也许颜料掩盖了污垢。
- en: A typical camera can capture at least 16.7 million (*256 * 256 * 256*) distinct
    colors. For any given image, we can count the number of pixels of each color.
    This set of counts is called the **color histogram** of the image. Typically,
    most entries in the histogram will be zero because most scenes are not polychromatic
    (many-colored).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一台典型的相机可以捕捉至少 16.7 百万 (*256 * 256 * 256*) 种不同的颜色。对于任何给定的图像，我们可以计算每种颜色的像素数量。这个计数的集合被称为图像的**颜色直方图**。通常，直方图中的大多数条目将为零，因为大多数场景不是多色的（多彩的）。
- en: We can normalize the histogram by dividing the color counts by the total number
    of pixels. Since the number of pixels is factored out, normalized histograms are
    comparable even if the original images have different resolutions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将颜色计数除以总像素数来归一化直方图。由于像素数被约简了，即使原始图像具有不同的分辨率，归一化直方图也是可以比较的。
- en: 'Given a pair of normalized histograms, we can measure the histograms'' similarity
    on a scale of zero to one. One measure of similarity is called the **intersection**
    of the histograms. It is computed as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一对归一化直方图，我们可以在零到一的比例尺度上测量直方图的相似度。相似度的一个度量称为直方图的**交集**。其计算方法如下：
- en: '![](img/b373e041-8828-452c-9593-b94fe12d709a.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b373e041-8828-452c-9593-b94fe12d709a.png)'
- en: 'Here is the equivalent Python code (which we will optimize later):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是等效的 Python 代码（我们稍后会对其进行优化）：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, suppose that in one image, `50%` of the pixels are black and `50%`
    are white. In another image, `100%` of the pixels are black. The similarity is
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在一个图像中，`50%` 的像素是黑色，`50%` 是白色。在另一个图像中，`100%` 的像素是黑色。相似度如下：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, a similarity of one does not mean that the images are identical; it means
    that their normalized histograms are identical. Relative to the first image, the
    second image could be a different size, could be flipped, or could even contain
    the same pixel values in a randomly different order.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，相似度为一并不意味着图像完全相同；这意味着它们的归一化直方图是相同的。相对于第一张图像，第二张图像可能大小不同，可能翻转，甚至可能以随机不同的顺序包含相同的像素值。
- en: Conversely, a similarity of zero does not mean that the images look completely
    different to a layperson; it just means that they have no color values in common.
    For example, an image that is all black and another image that is all charcoal-gray
    have histograms with a similarity of zero by our definition.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，相似度为零并不意味着图像对普通人来说看起来完全不同；它只是意味着它们没有共同的颜色值。例如，一张全黑的图像和另一张全炭灰的图像，根据我们的定义，它们的直方图相似度为零。
- en: For the purpose of classifying images, we want to find the average similarity
    between a query histogram and a set of multiple reference histograms. A single
    reference histogram (and a single reference image) would be far too specific for
    a broad classification such as **Lu****xury, indoor**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对图像进行分类，我们希望找到查询直方图与多个参考直方图集合之间的平均相似度。单个参考直方图（和单个参考图像）对于像**Luxury, indoor**这样的广泛分类来说过于具体。
- en: Although we focus on one approach to comparing histograms, there are many alternatives.
    For a discussion of several algorithms and their implementations in Python, see
    this blog post by Adrian Rosebrock at [http://www.pyimagesearch.com/2014/07/14/3-ways-compare-histograms-using-opencv-python/](http://www.pyimagesearch.com/2014/07/14/3-ways-compare-histograms-using-opencv-python/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们专注于比较直方图的一种方法，但还有许多替代方案。关于几个算法及其在 Python 中的实现，请参阅 Adrian Rosebrock 在 [http://www.pyimagesearch.com/2014/07/14/3-ways-compare-histograms-using-opencv-python/](http://www.pyimagesearch.com/2014/07/14/3-ways-compare-histograms-using-opencv-python/)
    的这篇博客文章。
- en: 'Let''s write a class called `HistogramClassifier`, which creates and stores
    sets of references histograms and finds the average similarity between a query
    histogram and each set of reference histograms. To support this functionality,
    we will use OpenCV, NumPy, and SciPy. Create a file called `HistogramClassifier.py`
    and add the following shebang line (path to the Python interpreter) and `import`
    statements at the top:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为 `HistogramClassifier` 的类，该类创建并存储参考直方图的集合，并找到查询直方图与每个参考直方图集合之间的平均相似度。为了支持此功能，我们将使用
    OpenCV、NumPy 和 SciPy。创建一个名为 `HistogramClassifier.py` 的文件，并在顶部添加以下 shebang 行（Python
    解释器的路径）和 `import` 语句：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Some versions of PyInstaller work better if we explicitly import the `numpy`
    module before the `cv2` module. Remember that OpenCV's Python bindings depend
    on NumPy. Also, note that the OpenCV Python module is called `cv2`, even though
    we are using OpenCV 4\. The name `cv2` comes from a historical distinction between
    the parts of OpenCV that had an underlying C++ implementation (called `cv2`) and
    the parts that an older, underlying C implementation (called `cv`). As of OpenCV
    4, everything is `cv2`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些版本的 PyInstaller 如果我们在导入 `cv2` 模块之前显式导入 `numpy` 模块，则工作得更好。请记住，OpenCV 的 Python
    绑定依赖于 NumPy。此外，请注意，OpenCV 的 Python 模块称为 `cv2`，即使我们使用的是 OpenCV 4。`cv2` 这个名称来源于
    OpenCV 中具有底层 C++ 实现的部分（称为 `cv2`）和具有较老、底层 C 实现的部分（称为 `cv`）之间的历史区别。截至 OpenCV 4，所有内容都是
    `cv2`。
- en: 'An instance of `HistogramClassifier` stores several variables. A public Boolean
    called `verbose` controls the level of logging. A public float called `minimumSimilarityForPositiveLabel`
    defines a similarity threshold—if all the average similarities fall below this
    value, then the query image is given an `''Unknown''` classification. Several
    variables store values related to the color model. We assume that our images have
    three color channels with 8 bits (256 possible values) per channel. Finally, and
    most importantly, a dictionary called `_references` maps string keys such as `''Luxury,
    interior''` to lists of reference histograms. Let''s declare the variables in
    the `HistogramClassifier` class''s `__init__` method, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`HistogramClassifier` 的一个实例存储了几个变量。一个名为 `verbose` 的公共布尔值控制日志级别。一个名为 `minimumSimilarityForPositiveLabel`
    的公共浮点值定义了一个相似度阈值——如果所有平均相似度都低于此值，则查询图像被赋予 `''Unknown''` 分类。几个变量存储与颜色模型相关的值。我们假设我们的图像有三个颜色通道，每个通道有
    8 位（256 个可能值）。最后，也是最重要的，一个名为 `_references` 的字典将字符串键（如 `''Luxury, interior''`）映射到参考直方图的列表。让我们在
    `HistogramClassifier` 类的 `__init__` 方法中声明这些变量，如下所示：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By convention, in a Python class, a variable or method name is prefixed with
    an underscore if the variable or method is meant to be protected (accessed only
    within the class and its subclasseses). However, this level of protection is not
    actually enforced. Most of our member variables and methods in this book are marked
    as protected, but a few are public. Python supports private variables and methods
    (denoted by a double-underscore prefix) that are meant to be inaccessible, even
    to subclasses. However, we avoid private variables and methods in this book because
    Python classes should typically be highly extensible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，在 Python 类中，如果一个变量或方法是为了保护（仅在类及其子类中访问）而设计的，那么它的名称前会加上一个下划线。然而，这种保护级别实际上并没有得到强制执行。本书中的大多数成员变量和方法都被标记为受保护的，但也有一些是公开的。Python
    支持私有变量和方法（由双下划线前缀表示），这些变量和方法意味着不可访问，即使是子类也无法访问。然而，我们在这本书中避免使用私有变量和方法，因为 Python
    类通常应该是高度可扩展的。
- en: '`HistogramClassifier` has a method, `_createNormalizedHist`, which takes two
    arguments—an image and a Boolean indicating whether to store the resulting histogram
    in a **sparse** (compressed) format. The histogram is computed using an OpenCV
    function, `cv2.calcHist`. As arguments, it takes the image, the number of channels,
    the histogram size (that is, the dimensions of the color model), and the range
    of each color channel. We flatten the resulting histogram into a one-dimensional
    format that uses memory more efficiently. Then, optionally, we convert the histogram
    into a sparse format using a SciPy function called `scipy.sparse.csc_matrix`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`HistogramClassifier` 类有一个名为 `_createNormalizedHist` 的方法，它接受两个参数——一个图像和一个布尔值，表示是否将生成的直方图存储在
    **稀疏**（压缩）格式中。直方图是通过 OpenCV 函数 `cv2.calcHist` 计算的。它接受图像、通道数、直方图大小（即颜色模型的维度）以及每个颜色通道的范围作为参数。我们将生成的直方图展平成一种一维格式，这种格式使用内存更有效率。然后，可选地，我们使用名为
    `scipy.sparse.csc_matrix` 的 SciPy 函数将直方图转换为稀疏格式。'
- en: A sparse matrix uses a form of compression that relies on a default value, normally
    `0`. That is to say, we do not bother storing all the zeroes individually; instead,
    we note the ranges that are full of zeroes. For histograms, this is an important
    optimization because in a typical image, most of the possible colors are absent.
    So, most of the histogram values are `0`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏矩阵使用一种依赖于默认值（通常是 `0`）的压缩形式。也就是说，我们不必分别存储所有的零；相反，我们记录充满零的范围。对于直方图来说，这是一个重要的优化，因为在典型的图像中，大多数可能的颜色都不存在。因此，大多数直方图值都是
    `0`。
- en: Compared to an uncompressed format, a sparse format offers better memory efficiency
    but worse computational efficiency. The same trade-off applies to compressed formats
    in general.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与未压缩格式相比，稀疏格式提供了更好的内存效率，但计算效率较差。这种权衡在一般情况下也适用于压缩格式。
- en: 'Here is the implementation of `_createNormalizedHist`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`_createNormalizedHist`的实现：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A public method, `addReference`, accepts two arguments—an image and a label
    (the label is a string describing the classification). We pass the image to `_createNormalizedHist`
    in order to create a normalized histogram in a sparse format. For a reference
    histogram, the sparse format is more appropriate because we want to keep many
    reference histograms in memory for the entire duration of a classification session.
    After creating the histogram, we add it to a list in `_references`, using the
    label as the key. Here is the implementation of `addReference`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个公共方法`addReference`接受两个参数——一个图像和一个标签（标签是一个描述分类的字符串）。我们将图像传递给`_createNormalizedHist`以创建一个稀疏格式的归一化直方图。对于参考直方图，稀疏格式更合适，因为我们希望在分类会话的整个过程中在内存中保留许多参考直方图。创建直方图后，我们使用标签作为键将其添加到`_references`列表中。以下是`addReference`的实现：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the purposes of Luxocator, reference images come from files on disk. Let''s
    give `HistogramClassifier` a public method, `addReferenceFromFile`, which accepts
    a file path instead of directly accepting an image. It also accepts a label. We
    load the image from file using an OpenCV method called `cv2.imread`, which accepts
    a path and a color format. Based on our earlier assumption about having three
    color channels, we always want to load images in color, not grayscale. This option
    is represented by the `cv2.IMREAD_COLOR` value. Having loaded the image, we pass
    it and the label to `addReference`. The implementation of `addReferenceFromFile`
    is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Luxocator来说，参考图像来自磁盘上的文件。让我们给`HistogramClassifier`提供一个公共方法，`addReferenceFromFile`，它接受一个文件路径而不是直接接受一个图像。它还接受一个标签。我们使用一个名为`cv2.imread`的OpenCV方法从文件中加载图像，该方法接受一个路径和一个颜色格式。根据我们之前关于有三个颜色通道的假设，我们总是希望以彩色而不是灰度格式加载图像。这个选项由`cv2.IMREAD_COLOR`值表示。加载图像后，我们将它及其标签传递给`addReference`。`addReferenceFromFile`的实现如下：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we arrive at the crux of the matter—the `classify` public method, which
    accepts a query image, as well as an optional string to identify the image in
    log output. For each set of reference histograms, we compute the average similarity
    to the query histogram. If all similarity values fall below `minimumSimilarityForPositiveLabel`,
    we return the `''Unknown''` label. Otherwise, we return the label of the most
    similar set of reference histograms. If `verbose` is `True`, we also log all the
    labels and their respective average similarities. Here is the method''s implementation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了问题的关键——`classify`公共方法，它接受一个查询图像，以及一个可选的字符串来在日志输出中标识图像。对于每一组参考直方图，我们计算其与查询直方图的平均相似度。如果所有相似度值都低于`minimumSimilarityForPositiveLabel`，我们返回`'Unknown'`标签。否则，我们返回最相似的一组参考直方图的标签。如果`verbose`为`True`，我们还会记录所有标签及其相应的平均相似度。以下是该方法实现：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note the use of the `todense` method to decompress a sparse matrix.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了`todense`方法来解压缩稀疏矩阵。
- en: 'We also provide a public method, `classifyFromFile`, which accepts a file path
    instead of directly accepting an image. Here is the implementation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个公共方法，`classifyFromFile`，它接受一个文件路径而不是直接接受一个图像。以下是实现方式：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Computing all our reference histograms will take a bit of time. We do not want
    to recompute them every time we run Luxocator. So, we need to serialize and deserialize
    (save and load) the histograms to/from disk. For this purpose, SciPy provides
    two functions, `scipy.io.savemat` and `scipy.io.loadmat`. They accept a file and
    various optional arguments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 计算所有我们的参考直方图将花费一些时间。我们不希望在每次运行Luxocator时都重新计算它们。因此，我们需要将直方图序列化和反序列化（保存和加载）到磁盘上。为此，SciPy提供了两个函数，`scipy.io.savemat`和`scipy.io.loadmat`。它们接受一个文件和多个可选参数。
- en: 'We can implement a `serialize` method with optional compression, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一个具有可选压缩的`serialize`方法，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When deserializing, we get a dictionary from `scipy.io.loadmat`. However, this
    dictionary contains more than our original `_references` dictionary. It also contains
    some serialization metadata and some serialization metadata, and some additional
    arrays that wrap the lists that were originally in `_references`. We strip out
    these unwanted, added contents and store the result back in `_references`. The
    implementation is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在反序列化时，我们从`scipy.io.loadmat`获取一个字典。然而，这个字典包含的不仅仅是我们的原始`_references`字典。它还包含一些序列化元数据和一些序列化元数据，以及一些额外的数组，这些数组包装了原本在`_references`中的列表。我们移除了这些不需要的附加内容，并将结果存储回`_references`。实现如下：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That is our classifier. Next, we will test our classifier by feeding it some
    reference images and a query image.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们的分类器。接下来，我们将通过提供一些参考图像和一个查询图像来测试我们的分类器。
- en: Training the classifier with reference images
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用参考图像训练分类器
- en: '"Can you identify this coastline? Given time, yes."'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '"你能识别这条海岸线吗？给定时间，可以。"'
- en: – Photo caption, Dante Stella ([http://www.dantestella.com/technical/hex352.html](http://www.dantestella.com/technical/hex352.html))
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: – 照片标题，达恩特·斯特拉 ([http://www.dantestella.com/technical/hex352.html](http://www.dantestella.com/technical/hex352.html))
- en: A small selection of reference images is included in this book's GitHub repository in
    a folder called `Chapter002/images`. Feel free to experiment with the classifier
    by adding more reference images, since a larger set may yield more reliable results.
    Bear in mind that our classifier relies on average similarity, so the more times
    you include a given color scheme in the reference images, the more heavily you
    are weighting the classifier in favor of that color scheme.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本书GitHub仓库中包含了一小部分参考图像，位于名为`Chapter002/images`的文件夹中。您可以自由地通过添加更多参考图像来实验分类器，因为更大的数据集可能会产生更可靠的结果。请记住，我们的分类器依赖于平均相似度，所以您在参考图像中包含特定配色方案次数越多，您就越倾向于在分类器中为该配色方案增加权重。
- en: 'At the end of `HistogramClassifier.py`, let''s add a `main` method to train
    and serialize a classifier using our reference images. We will also run the classifier
    on a couple of the images as a test. Here is a partial implementation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HistogramClassifier.py`的末尾，让我们添加一个`main`方法来使用我们的参考图像训练和序列化一个分类器。我们还将运行分类器对几幅图像进行测试。以下是部分实现：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Depending on the number of reference images, this method may take several minutes
    (or even longer) to run. Fortunately, since we are serializing the trained classifier,
    we will not have to run such a method every time we open our main application.
    Instead, we will simply deserialize the trained classifier from file, as we will
    see later in this chapter in the *Integrating everything into the GUI* section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据参考图像的数量，此方法可能需要几分钟（甚至更长）才能运行。幸运的是，由于我们正在序列化训练好的分类器，我们不必每次打开主应用程序时都运行此方法。相反，我们将简单地从文件中反序列化训练好的分类器，正如我们将在本章的*将一切整合到GUI中*部分中看到的。
- en: For a large number of training images, you might wish to modify the `main` function
    of `HistogramClassifier.py` to use all images in a specified folder. (For examples
    of iteration over all images in a folder, refer to the `describe.py` file in the
    code for [Chapter 3](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*, Training a
    Smart Alarm to Recognize the Villain and His Cat*.) However, for a small number
    of training images, I find it more convenient to specify a list of images in code
    so that we can comment and uncomment individual images to see the effect on training.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大量的训练图像，您可能希望修改`HistogramClassifier.py`中的`main`函数，以便使用指定文件夹中的所有图像。（有关遍历文件夹中所有图像的示例，请参阅[第3章](49c9a5fb-89a3-4c0d-bbee-021d2618168c.xhtml)*，训练智能闹钟识别恶棍和他的猫*。）然而，对于少量训练图像，我发现通过在代码中指定图像列表更方便，这样我们可以注释和取消注释单个图像以查看对训练的影响。
- en: Next, let's consider how our main application will acquire query images.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑我们的主应用程序如何获取查询图像。
- en: Acquiring images from the web
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网络获取图像
- en: 'Our query images will come from a web search. Before we start implementing
    the search functionality, let''s write some helper functions that let us fetch
    images through the `Requests` library and convert them into an OpenCV-compatible
    format. Because this functionality is highly reusable, we will put it in a module
    of static utility functions. Let''s create a file called `RequestsUtils.py` and
    import OpenCV, NumPy, and Requests, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查询的图片将来自网络搜索。在我们开始实现搜索功能之前，让我们编写一些辅助函数，以便我们通过`Requests`库获取图片并将它们转换为OpenCV兼容的格式。由于这个功能高度可重用，我们将把它放在一个静态实用函数模块中。让我们创建一个名为`RequestsUtils.py`的文件，并按照以下方式导入OpenCV、NumPy和Requests：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As a global variable, let''s store `HEADERS`, a dictionary of headers that
    we will use when making web requests. Some servers reject requests that appear
    to come from a bot. To improve the chance of our requests being accepted, let''s
    set the `''User-Agent''` header to a value that mimics a web browser, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为全局变量，让我们存储`HEADERS`，这是我们将在发送网络请求时使用的头信息字典。一些服务器拒绝看起来来自机器人的请求。为了提高我们的请求被接受的机会，让我们将`'User-Agent'`头设置为模拟网络浏览器的值，如下所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Whenever we receive a response to a web request, we want to check whether the
    status code is `200` OK. This is only a cursory test of whether the response is
    valid, but it is a good enough test for our purposes. We implement this test in
    the following method, `validateResponse`, which returns `True` if the response
    is deemed valid; otherwise, it logs an error message and returns `False`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们收到网络请求的响应时，我们希望检查状态码是否为`200` OK。这只是一个粗略的测试，以确定响应是否有效，但对于我们的目的来说已经足够好了。我们在以下方法中实现这个测试，`validateResponse`，如果响应被认为是有效的，则返回`True`；否则，记录错误消息并返回`False`：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the help of `HEADERS` and `validateResponse`, we can try to get an image
    from a URL and return that image in an OpenCV-compatible format (failing that,
    we return `None`). As an intermediate step, we read raw data from a web response
    into a NumPy array using a function called `numpy.fromstring`. We then interpret
    this data as an image using a function called `cv2.imdecode`. Here is our implementation,
    a function called `cvImageFromUrl` that accepts a URL as an argument:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HEADERS`和`validateResponse`的帮助下，我们可以尝试从一个URL获取图片，并以OpenCV兼容的格式返回该图片（如果失败，则返回`None`）。作为一个中间步骤，我们使用名为`numpy.fromstring`的函数从网络响应中读取原始数据到一个NumPy数组。然后我们使用名为`cv2.imdecode`的函数将此数据解释为图片。以下是我们的实现，一个名为`cvImageFromUrl`的函数，它接受一个URL作为参数：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To test these two functions, let''s give `RequestsUtils.py` a `main` function
    that downloads an image from the web, converts it into an OpenCV-compatible format,
    and writes it to disk using an OpenCV function called `imwrite`. Here is our implementation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这两个函数，让我们给`RequestsUtils.py`一个`main`函数，该函数从网络上下载图片，将其转换为OpenCV兼容的格式，并使用OpenCV的`imwrite`函数将其写入磁盘。以下是我们的实现：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To confirm that everything worked, open `image.png` (which should be in the
    same directory as `RequestsUtils.py`) and compare it to the online image, which
    you can view in a web browser at [http://nummist.com/images/ceiling.gaze.jpg](http://nummist.com/images/ceiling.gaze.jpg).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认一切正常，打开`image.png`（它应该在`RequestsUtils.py`相同的目录中），并与您可以在网络浏览器中查看的在线图片进行比较[http://nummist.com/images/ceiling.gaze.jpg](http://nummist.com/images/ceiling.gaze.jpg)。
- en: Although we are putting a simple test of our `RequestUtils` module in a `main`
    function, a more sophisticated and maintainable approach to writing tests in Python
    is to use the classes in the `unittest` module of the standard library. For more
    information, refer to the official tutorial at [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将对`RequestUtils`模块的简单测试放在一个`main`函数中，但在Python中编写测试的更复杂和可维护的方法是使用标准库中的`unittest`模块中的类。有关更多信息，请参阅官方教程[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)。
- en: Acquiring images from Bing Image Search
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Bing图片搜索获取图片
- en: 'Microsoft''s search engine, Bing, has an API that enables us to send queries
    and receive results in our own application. For a limited number of queries per
    month, the Bing Search API is free to use (currently, the limit is three thousand
    queries per month and three queries per second). However, we must register for
    it by performing the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的搜索引擎Bing有一个API，它允许我们在自己的应用程序中发送查询并接收结果。对于每月有限数量的查询，Bing搜索API是免费的（目前，每月限制为三千个查询，每秒三个查询）。然而，我们必须通过以下步骤注册：
- en: Go to [https://azure.microsoft.com/](https://azure.microsoft.com/) and log in.
    You will need to create a Microsoft account if you do not already have one.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://azure.microsoft.com/](https://azure.microsoft.com/) 并登录。如果您还没有，您需要创建一个
    Microsoft 账户。
- en: Go to [https://azure.microsoft.com/en-us/services/cognitive-services/bing-image-search-api/](https://azure.microsoft.com/en-us/services/cognitive-services/bing-image-search-api/). Click
    the Try Bing Image Search button.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://azure.microsoft.com/en-us/services/cognitive-services/bing-image-search-api/](https://azure.microsoft.com/en-us/services/cognitive-services/bing-image-search-api/)。点击“尝试
    Bing 图像搜索”按钮。
- en: Next to the Guest option, click the Get started button to start a free seven-day
    trial. After you have started your trial, go to [https://azure.microsoft.com/en-us/try/cognitive-services/](https://azure.microsoft.com/en-us/try/cognitive-services/).
    Select the Search APIs tab. Under the Bing Image Search APIs v7 section, find
    the 32-character API key (you might find two keys labeled Key 1 and Key 2 . Either
    of these is fine). Copy the key and save it in a safe place. We will need to use
    it later to associate our Bing session with our Microsoft Account.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“访客”选项旁边，点击“开始使用”按钮以开始免费的七天试用期。开始试用后，前往 [https://azure.microsoft.com/en-us/try/cognitive-services/](https://azure.microsoft.com/en-us/try/cognitive-services/)。选择“搜索
    API”选项卡。在“Bing 图像搜索 API v7”部分下，找到32字符的 API 密钥（您可能会找到两个标记为“Key 1”和“Key 2”的密钥。这两个都行）。复制密钥并将其保存在安全的地方。我们稍后需要使用它来将我们的
    Bing 会话与我们的 Microsoft 账户关联。
- en: 'As an alternative to step three, or after your seven-day trial expires, you
    can create a free account. Next to the Free Azure account option, click the Sign
    up button to register for a free account with limited uses per month (of course,
    if you decide to use Luxocator obsessively, to the exclusion of normal activities,
    you can always upgrade to a paid account later). Even though the account is free,
    the registration process requires you to provide a phone number and a credit card
    in order to verify your identity. Once you have completed the registration process,
    click the Portal tab to go the Microsoft Azure control panel. Click Cognitive
    Services, then Add, then Bing Search v7, and then Create. Fill out the **Create**
    dialog by following the example in the following screenshot. Click the dialog''s
    Create button. Click the Go to resource button. Click Keys. Find the 32-character
    API key (you might see two keys labeled Key 1 and Key 2\. Either of these is fine).
    Copy the key and save it in a safe place:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第三步的替代方案，或者试用七天后，您可以创建一个免费账户。在“免费 Azure 账户”选项旁边，点击“注册”按钮以注册一个每月使用量有限的免费账户（当然，如果您决定对
    Luxocator 迷恋到排除正常活动的程度，您以后总是可以升级到付费账户）。尽管账户是免费的，但注册过程需要您提供一个电话号码和一张信用卡以验证您的身份。完成注册过程后，点击“门户”选项卡以进入
    Microsoft Azure 控制面板。点击认知服务，然后添加，然后点击 Bing 搜索 v7，然后创建。按照以下截图中的示例填写“创建”对话框。点击对话框的创建按钮。点击“转到资源”按钮。点击“密钥”。找到32字符的
    API 密钥（您可能会看到两个标记为“Key 1”和“Key 2”的密钥。这两个都行）。复制密钥并将其保存在安全的地方：
- en: '![](img/19793bb0-a3ea-4938-bd28-9b2e98337f52.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19793bb0-a3ea-4938-bd28-9b2e98337f52.png)'
- en: Create an environment variable named `BING_SEARCH_KEY`. Set its value equal
    to the API key that we created in step three or four (later, in our code, we will
    access the value of this environment variable in order to associate our Bing search
    session with our API key). Depending on your operating system, there are many
    different ways to create an environment variable. On Windows, you may want to
    use the Control Panel to add a user environment variable. On Unix-like systems,
    you may want to add a definition of the environment variable by editing the user's
    login script, which is called `~/.profile` on Mac, Ubuntu, and many other systems.
    After you have created the environment variable, reboot (or log out and log back
    in).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `BING_SEARCH_KEY` 的环境变量。将其值设置为我们在第三步或第四步中创建的 API 密钥（稍后，在我们的代码中，我们将访问这个环境变量的值，以便将我们的
    Bing 搜索会话与我们的 API 密钥关联）。根据您的操作系统，创建环境变量的方法有很多种。在 Windows 上，您可能想使用控制面板添加用户环境变量。在类
    Unix 系统上，您可能想通过编辑用户的登录脚本（在 Mac、Ubuntu 和许多其他系统上称为 `~/.profile`）来添加环境变量的定义。创建环境变量后，重新启动（或注销并重新登录）。
- en: 'The Bing Search API and several other Microsoft APIs have a third-party Python
    wrapper called `py-ms-cognitive`. We can install it using Python''s package manager,
    `pip`. Open a Terminal (on Unix-like systems) or Command Prompt (on Windows) and
    run the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Bing 搜索 API 以及其他几个 Microsoft API 都有一个名为 `py-ms-cognitive` 的第三方 Python 封装器。我们可以使用
    Python 的包管理器 `pip` 来安装它。打开终端（在类 Unix 系统上）或命令提示符（在 Windows 上），然后运行以下命令：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Building atop `py-ms-cognitive`, we want a high-level interface for submitting
    a query string and navigating through a resulting list of images, which should
    be in an OpenCV-compatible format. We will make a class, `ImageSearchSession`,
    which offers such an interface. First, let''s create a file, `ImageSearchSession.py`,
    and add the following `import` statements at the top:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`py-ms-cognitive`的基础上，我们希望有一个高级接口来提交查询字符串并导航通过图像结果列表，这些图像应与OpenCV兼容。我们将创建一个名为`ImageSearchSession`的类，它提供这样的接口。首先，让我们创建一个文件`ImageSearchSession.py`，并在顶部添加以下`import`语句：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we are modifying one of the `py_ms_cognitive` Python wrapper's static
    variables, `PyMsCognitiveImageSearch.SEARCH_IMAGE_BASE`. We do this because, by
    default, `py_ms_cognitive` uses an outdated base URL for the Bing Search API endpoint.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在修改`py_ms_cognitive`Python包装器的静态变量`PyMsCognitiveImageSearch.SEARCH_IMAGE_BASE`。我们这样做是因为，默认情况下，`py_ms_cognitive`使用过时的基础URL作为Bing搜索API端点的URL。
- en: For `py_ms_cognitive`, we are using OpenCV, pretty-print (for logging JSON results
    from the search), system libraries, and our networking utility functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`py_ms_cognitive`，我们使用OpenCV、pretty-print（用于从搜索中记录JSON结果）、系统库以及我们的网络实用函数。
- en: 'Like `HistogramClassifier`, `ImageSearchSession` has a public Boolean called `verbose` to
    control the level of logging. Moreover, `ImageSearchSession` has member variables
    to store the current query, metadata about the current image results, and metadata
    to help us navigate to the previous and next results. We can initialize these
    variables like so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与`HistogramClassifier`类似，`ImageSearchSession`有一个名为`verbose`的公共布尔值，用于控制日志级别。此外，`ImageSearchSession`有成员变量来存储当前查询、当前图像结果的元数据以及帮助我们导航到上一个和下一个结果的元数据。我们可以这样初始化这些变量：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We provide getters for many of the member variables, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为许多成员变量提供了getter，如下所示：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Given these variables, we can navigate through a large set of results by fetching
    only a few at a time; that is, by looking through a window into the results. We
    can move our window to earlier or later results, as needed, by simply adjusting
    the offset by the number of requested results and clamping the offset to the valid
    range. Here are some implementations of the `searchPrev` and `searchNext` methods,
    which rely on a more general search method that we will implement afterwards:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些变量，我们可以通过一次只获取少量结果来导航大量结果集；也就是说，通过一个窗口查看结果。根据需要，我们可以通过简单地调整偏移量（基于请求的结果数量）并将偏移量限制在有效范围内来移动我们的窗口到更早或更晚的结果。以下是一些`searchPrev`和`searchNext`方法的实现，这些方法依赖于我们稍后将要实现的更通用的搜索方法：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The more general-purpose `search` method accepts a query string, a maximum
    number of results, and an offset relative to the first available result. We store
    these arguments in member variables for reuse in the `searchPrev` and `searchNext`
    methods. The search method also uses the `BING_SEARCH_KEY` environment variable
    that we defined earlier. Here is this first part of the method''s implementation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更通用的`search`方法接受一个查询字符串、最大结果数和相对于第一个可用结果的偏移量。我们将这些参数存储在成员变量中，以便在`searchPrev`和`searchNext`方法中重复使用。搜索方法还使用我们之前定义的`BING_SEARCH_KEY`环境变量。以下是该方法实现的第一部分：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we set up our search parameters, specifying that the results should be
    in `JSON` format and should include color photos only:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置搜索参数，指定结果应以`JSON`格式提供，并且仅包括彩色照片：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We set up a search and request the results in `JSON` format. We handle any
    exceptions by printing an error message, setting the number of search results
    to `0`, and returning prematurely:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置搜索并请求以`JSON`格式提供的结果。我们通过打印错误消息、将搜索结果数设置为`0`并提前返回来处理任何异常：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the request succeeded, we proceed to parse the `JSON`. We store metadata
    about the actual number of results received and number of results available:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求成功，我们继续解析`JSON`。我们存储关于实际接收到的结果数和可用结果数的元数据：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the `verbose` public variable is `True`, we print the JSON results. Here
    is the end of the method''s implementation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`verbose`公共变量为`True`，我们打印JSON结果。以下是方法实现的结尾部分：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although the `search` method fetches a textual description of results, including
    image URLs, it does not actually fetch any full-sized images. This is good, because
    the full-sized images may be large and we do not need them all at once. Instead,
    we provide another method, `getCvImageAndUrl`, to retrieve the image and image
    URL that have a specified index in the current results. The index is given as
    an argument. As an optional second argument, this method accepts a Boolean indicating
    whether a thumbnail should be used instead of the full-sized image. We use `cvImageFromUrl`
    to fetch and convert the thumbnail or full-sized image. Here is our implementation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `search` 方法获取了包括图像 URL 在内的结果文本描述，但它实际上并没有获取任何全尺寸图像。这是好的，因为全尺寸图像可能很大，我们不需要一次性获取所有这些。相反，我们提供了一个名为
    `getCvImageAndUrl` 的另一个方法，用于检索当前结果中具有指定索引的图像和图像 URL。索引作为参数给出。作为可选的第二个参数，此方法接受一个布尔值，指示是否应使用缩略图而不是全尺寸图像。我们使用
    `cvImageFromUrl` 来获取并转换缩略图或全尺寸图像。以下是我们的实现：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The caller of `getCvImageAndUrl` is responsible for dealing gracefully with
    image downloads that are slow or that fail. Recall that our `cvImageFromUrl` function
    just logs an error and returns `None` if the download fails.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCvImageAndUrl` 的调用者负责优雅地处理下载缓慢或失败的情况。回想一下，我们的 `cvImageFromUrl` 函数在下载失败时仅记录错误并返回
    `None`。'
- en: 'To test `ImageSearchSession`, let''s write a main function that instantiates
    the class, sets `verbose` to `True`, searches for `''luxury condo sales''`, and
    writes the first resulting image to disk. Here is the implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `ImageSearchSession`，让我们编写一个主函数，实例化该类，将 `verbose` 设置为 `True`，搜索 `'luxury
    condo sales'`，并将第一个结果图像写入磁盘。以下是实现：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we have a classifier and a search session, we are almost ready to proceed
    to the frontend of Luxocator. We just need a few more utility functions to help
    us prepare data and images for bundling and display.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个分类器和搜索会话，我们几乎准备好进入 Luxocator 的前端了。我们只需要几个额外的实用函数来帮助我们准备打包和显示的数据和图像。
- en: Preparing images and resources for the app
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序的图像和资源
- en: 'Alongside `RequestsUtils.py` and `ImageSearchSession.py`, let''s create another
    file called `ResizeUtils.py` with the following `import` statements:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `RequestsUtils.py` 和 `ImageSearchSession.py`，让我们再创建一个名为 `ResizeUtils.py`
    的文件，并包含以下 `import` 语句：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For display in a GUI, images usually have to be resized. One popular mode of
    resizing is called **aspect fill**. Here, we want to preserve the image''s aspect
    ratio while changing its larger dimension (width for a landscape image or height
    for a portrait image) to a certain value. OpenCV does not directly provide this
    resizing mode, but it does provide a function, `cv2.resize`, which accepts an
    image, target dimensions, and optional arguments, including an interpolation method.
    We can write our own function, `cvResizeAspectFill`, which accepts an image, maximum
    size, and preferred interpolation methods for upsizing and downsizing. It determines
    the appropriate arguments for `cv2.resize` and passes them along. Here is the
    implementation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 GUI 中的显示，图像通常需要调整大小。一种流行的调整大小模式称为 **aspect fill**。在这里，我们希望在改变图像的较大维度（对于风景图像是宽度，对于肖像图像是高度）到一定值的同时，保留图像的宽高比。OpenCV
    并没有直接提供这种调整大小模式，但它提供了一个函数 `cv2.resize`，该函数接受一个图像、目标尺寸和可选参数，包括插值方法。我们可以编写自己的函数
    `cvResizeAspectFill`，该函数接受一个图像、最大尺寸以及用于放大和缩小时的首选插值方法。它确定 `cv2.resize` 的适当参数并将它们传递下去。以下是实现：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For a description of the interpolation methods that OpenCV supports, see the
    official documentation at [https://docs.opencv.org/master/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d](https://docs.opencv.org/master/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d).
    For upsizing, we default to `cv2.INTER_LANCZOS4`, which produces sharp results.
    For downsizing, we default to `cv2.INTER_AREA`, which produces moiré-free results
    (moiré is an artifact that makes parallel lines or concentric curves look like
    crosshatching when they are sharpened at certain magnifications).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OpenCV 支持的插值方法的描述，请参阅官方文档[https://docs.opencv.org/master/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d](https://docs.opencv.org/master/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d)。对于放大，我们默认使用
    `cv2.INTER_LANCZOS4`，它产生清晰的结果。对于缩小，我们默认使用 `cv2.INTER_AREA`，它产生无摩尔纹的结果（摩尔纹是一种在特定放大倍数下使平行线或同心曲线看起来像交叉线纹的伪影）。
- en: 'Now, let''s create another file called `WxUtils.py` with the following `import`
    statements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个名为 `WxUtils.py` 的文件，并包含以下 `import` 语句：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Due to API changes between `wxPython 3` and `wxPython 4`, it is important for
    us to check which version has been imported. We use the following code to get
    a version string, such as `''4.0.3''`, and to parse the major version number,
    such as `4`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `wxPython 3` 和 `wxPython 4` 之间的 API 变化，对于我们来说检查已导入的版本非常重要。我们使用以下代码来获取版本字符串，例如
    `'4.0.3'`，以及解析主版本号，例如 `4`：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'OpenCV and wxPython use different image formats, so we will implement a conversion
    function, `wxBitmapFromCvImage`. While OpenCV stores color channels in BGR order,
    wxPython expects RGB order. We can use an OpenCV function, `cv2.cvtColor`, to
    reformat the image data accordingly. Then, we can use a wxPython function, `wx.BitmapFromBuffer`,
    to read the reformatted data into a wxPython bitmap, which we return. Here is
    the implementation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 和 wxPython 使用不同的图像格式，因此我们将实现一个转换函数 `wxBitmapFromCvImage`。虽然 OpenCV 以
    BGR 顺序存储颜色通道，但 wxPython 预期 RGB 顺序。我们可以使用 OpenCV 函数 `cv2.cvtColor` 重新格式化图像数据。然后，我们可以使用
    wxPython 函数 `wx.BitmapFromBuffer` 将重新格式化的数据读取到 wxPython 位图中，并将其返回。以下是实现代码：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: On some versions of Raspberry Pi and Raspbian, `wx.BitmapFromBuffer` suffers
    from a platform-specific bug that causes it to fail. For a workaround, see [Appendix
    A](ddc68808-2fe3-4064-b333-632e68bb4ddf.xhtml),* Making WxUtils.py Compatible
    with Raspberry Pi*, at the end of this book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些版本的 Raspberry Pi 和 Raspbian 上，`wx.BitmapFromBuffer` 会受到一个特定平台的错误影响，导致它失败。作为解决方案，请参阅本书末尾的附录
    A，即[附录 A](ddc68808-2fe3-4064-b333-632e68bb4ddf.xhtml)，*使 WxUtils.py 与 Raspberry
    Pi 兼容*。
- en: 'We have one more utility module to make. Let''s create a file, `PyInstallerUtils.py`,
    with `import` statements for the `os` and `sys` modules from Python''s standard
    library:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个实用模块。让我们创建一个名为 `PyInstallerUtils.py` 的文件，其中包含 Python 标准库中的 `os` 和 `sys`
    模块的 `import` 语句：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we bundle our application using PyInstaller, the paths to resources will
    change. So, we need a function that correctly resolves paths, regardless of whether
    our application has been bundled or not. Let''s add a function, `pyInstallerResourcePath`,
    which resolves a given path relative to the app directory (the `''_MEIPASS''`
    attribute) or, failing that, the current working directory (`''.''`). It is implemented
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 PyInstaller 打包我们的应用程序时，资源路径将会改变。因此，我们需要一个函数来正确解析路径，无论我们的应用程序是否已经被打包。让我们添加一个名为
    `pyInstallerResourcePath` 的函数，它解析相对于应用程序目录（`'_MEIPASS'` 属性）的给定路径，或者如果失败，则解析当前工作目录（`'.'`）。它的实现如下：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our utilities modules are done now and we can move on to implementing the frontend
    of Luxocator.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具模块现在已经完成，我们可以继续实现 Luxocator 的前端。
- en: Integrating everything into the GUI
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切集成到 GUI 中
- en: 'For Luxocator''s front end, let''s create a file called `Luxocator.py`. This
    module depends on OpenCV, wxPython, and some of Python''s standard OS and threading
    functionality. It also depends on all the other modules that we have written in
    this chapter. Add the following shebang line and `import` statements at the top
    of the file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Luxocator 的前端，让我们创建一个名为 `Luxocator.py` 的文件。此模块依赖于 OpenCV、wxPython 以及 Python
    标准库中的某些 OS 和 threading 功能。它还依赖于本章中我们编写的所有其他模块。在文件顶部添加以下 shebang 行和 `import` 语句：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s implement the `Luxocator` class as a subclass of `wx.Frame`, which
    represents a GUI frame such as the contents of a window. Most of our GUI code
    is in the `Luxocator` class''s `__init__` method, which is, therefore, a big method
    but not very complicated. Our GUI elements include a search control, previous
    and next buttons, a bitmap, and a label to show the classification result. All
    of these GUI elements are stored in member variables. The bitmap is confined to
    a certain maximum size (by default, 768 pixels in the larger dimension), and the
    other elements are laid out below it. Several methods are registered as callbacks
    to handle events such as the window closing, the *Esc* key being pressed, a search
    string being entered, or the next or previous button being clicked. Besides the
    GUI elements, other member variables include instances of our `HistogramClassifier`
    and `ImageSearchSession` classes. Here is the implementation of the initializer,
    interspersed with some remarks on the GUI elements that we are using:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`Luxocator`类作为`wx.Frame`的子类，它代表一个GUI框架，例如窗口的内容。我们的大部分GUI代码都在`Luxocator`类的`__init__`方法中，因此这是一个大方法，但并不复杂。我们的GUI元素包括一个搜索控件、上一页和下一页按钮、一个位图以及一个标签来显示分类结果。所有这些GUI元素都存储在成员变量中。位图被限制在一定的最大尺寸（默认为较大维度上的768像素），其他元素布局在其下方。几个方法被注册为回调以处理诸如窗口关闭、按下*Esc*键、输入搜索字符串或点击下一页或上一页按钮等事件。除了GUI元素外，其他成员变量还包括我们的`HistogramClassifier`和`ImageSearchSession`类的实例。以下是初始化器的实现，其中穿插了一些关于我们使用的GUI元素的说明：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For more information about using bitmaps, controls, and layouts in wxPython,
    refer to the official wiki at [http://wiki.wxpython.org/](http://wiki.wxpython.org/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在wxPython中使用位图、控件和布局的更多信息，请参考官方维基百科[http://wiki.wxpython.org/](http://wiki.wxpython.org/)。
- en: 'The search control (coming up next) deserves special attention because it contains
    multiple controls within it, and its behavior differs slightly across operating
    systems. It may have up to three sub-controls—a text field, a search button, and
    a cancel button. There may be a callback for the *Enter* key being pressed while
    the text field is active. If the search and cancel buttons are present, they have
    callbacks for being clicked. We can set up the search control and its callbacks
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索控件（接下来会提到）值得特别注意，因为它内部包含多个控件，并且它在不同操作系统中的行为略有不同。它可能最多有三个子控件——一个文本字段、一个搜索按钮和一个取消按钮。当文本字段处于活动状态时，可能有一个回调用于按下*Enter*键。如果存在搜索和取消按钮，它们有被点击的回调。我们可以按照以下方式设置搜索控件及其回调：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'By contrast, the label, previous and next buttons, and bitmap do not have any
    sub-controls that concern us. We can set them up as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，标签、上一页和下一页按钮以及位图没有我们关心的任何子控件。我们可以按照以下方式设置它们：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our controls are lined up horizontally, with the search control on the left
    edge of the window, the previous and next buttons on the right edge, and the label
    halfway in-between the search control and previous button. We use an instance
    of `wx.BoxSizer` to define this horizontal layout:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制项水平排列，搜索控件位于窗口的左侧边缘，上一页和下一页按钮位于右侧边缘，标签位于搜索控件和上一页按钮之间的一半位置。我们使用`wx.BoxSizer`的一个实例来定义这个水平布局：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The best thing about layouts (and Russian dolls) is that they can be nested,
    one inside another. Our horizontal layout of controls needs to appear below the
    bitmap. This relationship is a vertical layout, which we define using another
    `wx.BoxSizer` instance:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 布局（以及俄罗斯套娃）的最好之处在于它们可以嵌套，一个套在另一个里面。我们的控件水平布局需要出现在位图下方。这种关系是一个垂直布局，我们使用另一个`wx.BoxSizer`实例来定义：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That is the end of the `__init__` method.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`__init__`方法的结束。
- en: 'As we can see in the following code, we provide getters and setters for the
    `verbose` property of our `ImageSearchSession` instance and our `HistogramClassifier`
    instance:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，我们为我们的`ImageSearchSession`实例和`HistogramClassifier`实例的`verbose`属性提供了获取器和设置器：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our `_onCloseWindow` callback just cleans up the application by calling the
    `Destroy` method of the superclass. Here is its implementation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义`_onCloseWindow`回调只是通过调用超类的`Destroy`方法来清理应用程序。以下是它的实现：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similarly, we have connected the *Esc* key to the `_onQuitCommand` callback,
    which closes the window. This, in turn, will result in `_onCloseWindow` being
    called. Here is the implementation of `_onQuitCommand`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将*Esc*键连接到了`_onQuitCommand`回调，这会关闭窗口。这反过来会导致`_onCloseWindow`被调用。以下是`_onQuitCommand`的实现：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our `_onSearchEntered` callback submits the query string through the search
    method of `ImageSearchSession`. Then, it calls a helper method, `_updateImageAndControls`,
    which asynchronously fetches images and updates the GUI, as we will see later.
    Here is the implementation of `_onSearchEntered`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `_onSearchEntered` 回调通过 `ImageSearchSession` 的搜索方法提交查询字符串。然后，它调用一个辅助方法 `_updateImageAndControls`，该方法异步获取图像并更新GUI，正如我们稍后将会看到的。以下是
    `_onSearchEntered` 的实现：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Our `_onSearchCanceled` callback simply clears the search control''s text field,
    as seen in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `_onSearchCanceled` 回调简单地清除了搜索控制器的文本字段，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our remaining GUI event callbacks, `_onNextButtonClicked` and `_onPrevButtonClicked`,
    check whether more results are available and, if so, uses the `searchNext` or
    `searchPrev` method of `ImageSearchSession`. Then, using the `_updateImageAndControls`
    helper method, images are fetched asynchronously and the GUI is updated. Here
    are the implementations of the callbacks:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩余的GUI事件回调 `_onNextButtonClicked` 和 `_onPrevButtonClicked` 检查是否有更多结果可用，如果有，则使用
    `ImageSearchSession` 的 `searchNext` 或 `searchPrev` 方法。然后，使用 `_updateImageAndControls`
    辅助方法异步获取图像并更新GUI。以下是回调的实现：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `_disableControls` method disables the search control and the previous
    and next buttons, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`_disableControls` 方法禁用搜索控件和上一个和下一个按钮，如下所示：'
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Conversely, the `_enableControls` method enables the search control, the previous
    button (if we are not already at the first available search result), and the next
    button (if we are not already at the last available search result). Here is the
    implementation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`_enableControls` 方法启用搜索控件、上一个按钮（如果我们还没有到达第一个可用的搜索结果），以及下一个按钮（如果我们还没有到达最后一个可用的搜索结果）。以下是其实施：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `_updateImageAndControls` method first disables the controls because we
    do not want to handle any new queries until the current query is handled. Then,
    a busy cursor is shown and another helper method, `_updateImageAndControlsAsync`,
    is started on a background thread. Here is the implementation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`_updateImageAndControls` 方法首先禁用控件，因为我们不希望在处理当前查询之前处理任何新的查询。然后，显示一个忙碌的光标，并在后台线程上启动另一个辅助方法
    `_updateImageAndControlsAsync`。以下是其实施：'
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The background method, `_updateImageAndControlsAsync`, starts by fetching an
    image and converting it into OpenCV format. If the image cannot be fetched and
    converted, an error message is used as the label. Otherwise, the image is classified
    and resized to an appropriate size for display. Then, the resized image and the
    classification label are passed to a third and final helper method, `_updateImageAndControlsResync`,
    which updates the GUI on the main thread. Here is the implementation of `_updateImageAndControlsAsync`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 后台方法 `_updateImageAndControlsAsync` 首先获取一个图像并将其转换为OpenCV格式。如果无法获取和转换图像，则使用错误消息作为标签。否则，图像将被分类并调整到适合显示的适当大小。然后，调整大小的图像和分类标签被传递给第三个也是最后的辅助方法
    `_updateImageAndControlsResync`，该方法在主线程上更新GUI。以下是 `_updateImageAndControlsAsync`
    的实现：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The synchronous callback, `_updateImageAndControlsResync`, hides the busy cursor,
    creates a wxPython bitmap from the fetched image (or just a black bitmap if no
    image was successfully fetched and converted), shows the image and its classification
    label, resizes GUI elements, re-enables controls, and refreshes the window. Here
    is its implementation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同步回调 `_updateImageAndControlsResync` 隐藏忙碌的光标，从获取的图像（如果没有成功获取和转换，则只是一个黑色位图）创建一个wxPython位图，显示图像及其分类标签，调整GUI元素的大小，重新启用控件，并刷新窗口。以下是其实施：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When the image cannot be successfully fetched and converted, the user sees
    something like the following screenshot, containing a black placeholder image:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像无法成功获取和转换时，用户会看到如下截图所示的内容，包含一个黑色占位符图像：
- en: '![](img/7f60d4b5-d0cf-4e4a-9e10-f393b476c78d.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f60d4b5-d0cf-4e4a-9e10-f393b476c78d.png)'
- en: 'Conversely, when an image is successfully fetched and converted, the users
    sees the classification result, as shown in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当图像成功获取并转换后，用户会看到分类结果，如下面的截图所示：
- en: '![](img/38150fba-5da2-485f-bfb9-32b5adcd3007.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38150fba-5da2-485f-bfb9-32b5adcd3007.png)'
- en: 'That completes the implementation of the `Luxocator` class. Now, let''s write
    a `main` method to set resource paths and launch an instance of `Luxocator`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了 `Luxocator` 类的实现。现在，让我们编写一个 `main` 方法来设置资源路径并启动 `Luxocator` 的一个实例：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that one of the resources is a certificate bundle called `cacert.pem`.
    It is required by Requests in order to make an SSL connection, which is, in turn,
    required by Bing. You can find a copy of it inside this chapter's code bundle,
    which is downloadable from my website at [http://nummist.com/opencv/7376_02.zip](http://nummist.com/opencv/7376_02.zip).
    Place `cacert.pem` in the same folder as `Luxocator.py`. Note that our code sets
    an environment variable, `REQUESTS_CA_BUNDLE`, which is used by Requests to locate
    the certificate bundle.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其中一个资源是一个名为 `cacert.pem` 的证书包。这是 Requests 所必需的，以便建立 SSL 连接，而 SSL 连接又是 Bing
    所必需的。您可以在本章节的代码包中找到它的副本，该代码包可以从我的网站 [http://nummist.com/opencv/7376_02.zip](http://nummist.com/opencv/7376_02.zip)
    下载。将 `cacert.pem` 放在与 `Luxocator.py` 相同的文件夹中。请注意，我们的代码设置了一个环境变量，`REQUESTS_CA_BUNDLE`，它被
    Requests 用于定位证书包。
- en: Depending on how it is installed or how it is bundled with an app, Requests
    may or may not have an internal version of the certificate bundle. For predictability,
    it is better to provide this external version.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它是如何安装的或如何与应用程序捆绑在一起，Requests 可能或可能没有内部证书包版本。为了可预测性，提供这个外部版本会更好。
- en: Running Luxocator and troubleshooting SSL problems
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Luxocator 和解决 SSL 问题
- en: 'At this point, you can run `Luxocator.py`, enter search keywords, and navigate
    through the results. Watch for any errors that Luxocator might print to the Terminal.
    On some systems, notably Ubuntu 14.04 and its derivatives, such as Linux Mint
    17, you might run into a bug in the Requests library when Luxocator attempts to
    access an HTTPS URL. The symptom of this bug is an error message similar to the
    following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以运行 `Luxocator.py`，输入搜索关键词，并通过结果进行导航。注意 Luxocator 可能会打印到终端的任何错误。在某些系统上，特别是
    Ubuntu 14.04 及其衍生版本，如 Linux Mint 17，当 Luxocator 尝试访问 HTTPS URL 时，您可能会遇到 Requests
    库中的错误。这个错误的症状类似于以下错误信息：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you encounter this problem, you can try to resolve it by installing additional
    SSL-related packages and downgrading Requests to an earlier version. Some users
    of Ubuntu 14.04 and its derivatives report that they resolved the problem by running
    the following commands:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到这个问题，您可以尝试通过安装额外的 SSL 相关包并将 Requests 降级到早期版本来解决它。一些 Ubuntu 14.04 及其衍生版本的用户报告说，他们通过运行以下命令解决了问题：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Alternatively, some users of Ubuntu 14.04 and its derivatives report that they
    resolved the problem by upgrading to a newer version of the operating system.
    Note that the problem is not specific to Luxocator, but rather it affects any
    software that uses Requests, so it is potentially an issue of system-wide importance.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一些 Ubuntu 14.04 及其衍生版本的用户报告说，他们通过升级到操作系统的较新版本解决了问题。请注意，这个问题并不特定于 Luxocator，而是影响任何使用
    Requests 的软件，因此它可能是一个系统级的问题。
- en: When you are satisfied with your results from testing Luxocator, let's proceed
    to build a Luxocator package that we can more easily distribute to other users'
    systems.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对 Luxocator 的测试结果满意时，让我们继续构建一个 Luxocator 包，这样我们就可以更容易地将它分发到其他用户的系统上。
- en: Building Luxocator for distribution
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为分发构建 Luxocator
- en: 'To tell PyInstaller how to build Luxocator, we must create a specification
    file, which we will call `Luxocator.spec`. Actually, the specification file is
    a Python script that uses a PyInstaller class called `Analysis` and the PyInstaller
    functions called `PYZ`, `EXE`, and `BUNDLE`. The `Analysis` class is responsible
    for analyzing one or more Python scripts (in our case, just `Luxocator.py`) and
    tracing all the dependencies that must be bundled with these scripts in order
    to make a redistributable application. Sometimes, `Analysis` makes mistakes or
    omissions, so we modify the list of dependencies after it is initialized. Then,
    we zip the scripts, make an executable, and (for Mac) make an app bundle using
    `PYZ`, `EXE`, and `BUNDLE`, respectively. Here is the implementation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉 PyInstaller 如何构建 Luxocator，我们必须创建一个规范文件，我们将称之为 `Luxocator.spec`。实际上，规范文件是一个
    Python 脚本，它使用 PyInstaller 的一个名为 `Analysis` 的类和名为 `PYZ`、`EXE` 和 `BUNDLE` 的 PyInstaller
    函数。`Analysis` 类负责分析一个或多个 Python 脚本（在我们的例子中，只是 `Luxocator.py`），并追踪必须与这些脚本捆绑在一起的所有依赖项，以便制作一个可分发的应用程序。有时，`Analysis`
    会犯错误或遗漏，所以我们修改了初始化后的依赖项列表。然后，我们使用 `PYZ`、`EXE` 和 `BUNDLE` 分别压缩脚本、创建可执行文件，并为 Mac
    创建应用程序包。以下是实现方式：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that this script specifies three resource files that must be bundled with
    the app: `cacert.pem`, `classifier.mat`, and `winicon-windowed.ico`. We have already
    discussed `cacert.pem` in the previous section, and `classifier.mat` is the output
    of our main function in `HistogramClassifier.py`. The Windows icon file, `winicon-windowed.ico`,
    is included in this book''s GitHub repository in the `Chapter002/win` folder.
    Alternatively, you may provide your own icon file if you prefer.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此脚本指定了三个必须与应用程序捆绑的资源文件：`cacert.pem`、`classifier.mat` 和 `winicon-windowed.ico`。我们已经在上一节中讨论了
    `cacert.pem`，而 `classifier.mat` 是我们在 `HistogramClassifier.py` 中的主函数的输出。Windows
    图标文件 `winicon-windowed.ico` 包含在本书的 GitHub 仓库的 `Chapter002/win` 文件夹中。或者，如果你愿意，你也可以提供自己的图标文件。
- en: For more information about PyInstaller's `Analysis` class, specification files,
    and other functionality, see the official documentation at [https://pyinstaller.readthedocs.io/](https://pyinstaller.readthedocs.io/).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 PyInstaller 的 `Analysis` 类、规范文件和其他功能的更多信息，请参阅官方文档[https://pyinstaller.readthedocs.io/](https://pyinstaller.readthedocs.io/)。
- en: 'Now, let''s write a platform-specific shell script to clean any old builds,
    train our classifier, and then bundle the app using PyInstaller. On Windows, create
    a script called `build.bat`, containing the following commands:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个特定平台的 shell 脚本来清理任何旧的构建，训练我们的分类器，然后使用 PyInstaller 打包应用程序。在 Windows
    上，创建一个名为 `build.bat` 的脚本，包含以下命令：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If `pyinstaller.exe` is not in your system's `Path`, you will need to change
    the `build.bat` script's definition of the `PYINSTALLER` variable in order to
    provide a full path to `pyinstaller.exe`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `pyinstaller.exe` 不在系统路径 `Path` 中，你需要更改 `build.bat` 脚本中 `PYINSTALLER` 变量的定义，以便提供
    `pyinstaller.exe` 的完整路径。
- en: 'Similarly, on Mac or Linux, create a script called `build.sh`. Make it executable
    (for example, by running `$ chmod +x build.sh` in the Terminal). The file should
    contain the following commands:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 Mac 或 Linux 上，创建一个名为 `build.sh` 的脚本。使其可执行（例如，通过在终端中运行 `$ chmod +x build.sh`）。该文件应包含以下命令：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the `pyinstaller` executable (or a similar executable, such as `pyinstaller-3.6` for
    Python 3.6)  is not in your system's `PATH`, you will need to change the `build.sh` script's
    definition of the `PYINSTALLER` variable in order to provide a full path to `pyinstaller`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `pyinstaller` 可执行文件（或类似的可执行文件，如为 Python 3.6 定制的 `pyinstaller-3.6`）不在系统路径
    `PATH` 中，你需要更改 `build.sh` 脚本中 `PYINSTALLER` 变量的定义，以便提供 `pyinstaller` 的完整路径。
- en: Note that on Mac (the Darwin platform), we are manually modifying the app bundle's
    contents as a post-build step. We do this in order to overwrite the default app
    icon and default properties file that PyInstaller puts in all Mac apps (notably,
    in some versions of PyInstaller, the default properties do not include support
    for Retina mode, so they make the app look pixelated on recent Mac hardware. Our
    customizations fix this issue). This book's GitHub repository includes the custom
    Mac app contents in a folder called `Chapter002/mac/Contents`. You may modify
    its files to provide any icon and properties you want.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Mac（Darwin 平台）上，我们作为构建后的步骤手动修改应用程序捆绑包的内容。我们这样做是为了覆盖 PyInstaller 放置在所有 Mac
    应用程序中的默认应用程序图标和默认属性文件（值得注意的是，在某些 PyInstaller 版本中，默认属性不包括对 Retina 模式的支持，因此在最近的
    Mac 硬件上使应用程序看起来像素化。我们的自定义修改解决了这个问题）。本书的 GitHub 仓库在名为 `Chapter002/mac/Contents`
    的文件夹中包含了自定义的 Mac 应用程序内容。你可以修改其文件以提供你想要的任何图标和属性。
- en: After running the platform-specific build script, we should have a redistributable
    build of Luxocator at `dist/Luxocator.exe` (Windows), `dist/Luxocator.app` (Mac),
    or `dist/Luxocator` (Linux). If we are using 64-bit Python libraries on our development
    machine, this build will only work on 64-bit systems. Otherwise, it should work
    on both 32-bit and 64-bit systems. The best way to test the build is to run it
    on another machine that doesn't have any of the relevant libraries (such as OpenCV)
    installed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行特定平台的构建脚本后，我们应该在 `dist/Luxocator.exe`（Windows）、`dist/Luxocator.app`（Mac）或
    `dist/Luxocator`（Linux）中有一个可重新分发的 Luxocator 构建。如果我们在我们开发机器上使用 64 位 Python 库，此构建将仅在
    64 位系统上工作。否则，它应该在 32 位和 64 位系统上都能工作。测试构建的最佳方式是在没有安装任何相关库（如 OpenCV）的另一台机器上运行它。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So much can happen in a single mission! We trained an OpenCV/NumPy/SciPy histogram
    classifier, performed Bing Image Searches, built a `wxPython` app, and used PyInstaller
    to bundle it all for redistribution to Russia with love (or, indeed, to any destination
    with any sentiment). At this point, you are well-primed to create other Python
    applications that combine computer vision, web requests, and a GUI.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次任务中可以发生很多事情！我们训练了一个OpenCV/NumPy/SciPy直方图分类器，执行了必应图片搜索，构建了一个`wxPython`应用程序，并使用PyInstaller将其打包以便带着爱意（或者，实际上，带着任何情感）重新分发到俄罗斯（或者任何其他目的地）。到这一点，你已经准备好创建其他结合计算机视觉、网络请求和图形用户界面的Python应用程序了。
- en: For our next mission, we will dig our claws deeper into OpenCV and computer
    vision by building a fully functional cat recognizer!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个任务中，我们将通过构建一个功能齐全的猫识别器来更深入地挖掘OpenCV和计算机视觉！
