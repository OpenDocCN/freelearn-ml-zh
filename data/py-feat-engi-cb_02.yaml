- en: <st c="0">2</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**0** **2**'
- en: <st c="2">Encoding Categorical Variables</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**编码分类变量**'
- en: '`<st c="146">Home owner</st>` <st c="156">variable with the values of</st>
    `<st c="185">owner</st>` <st c="190">and</st> `<st c="195">non-owner</st>` <st
    c="204">is categorical, and so is the</st> `<st c="235">Marital status</st>` <st
    c="249">variable with the values of</st> `<st c="278">never married</st>`<st c="291">,</st>
    `<st c="293">married</st>`<st c="300">,</st> `<st c="302">divorced</st>`<st c="310">,
    and</st> `<st c="316">widowed</st>`<st c="323">. In some categorical variables,
    the labels have an intrinsic order; for example, in the</st> `<st c="412">Student''s
    grade</st>` <st c="427">variable, the values of</st> `<st c="452">A</st>`<st c="453">,</st>
    `<st c="455">B</st>`<st c="456">,</st> `<st c="458">C</st>`<st c="459">, and</st>
    `<st c="465">Fail</st>` <st c="469">are ordered, with</st> `<st c="488">A</st>`
    <st c="489">being the highest grade and</st> `<st c="518">Fail</st>` <st c="522">being
    the lowest.</st> <st c="541">These</st> <st c="547">are called</st> `<st c="708">City</st>`
    <st c="712">variable, with the values of</st> `<st c="742">London</st>`<st c="748">,</st>
    `<st c="750">Manchester</st>`<st c="760">,</st> `<st c="762">Bristol</st>`<st
    c="769">, and</st> <st c="775">so on.</st>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="146">业主</st>` <st c="156">变量`<st c="185">owner</st>`和`<st c="190">非业主</st>`
    <st c="195">是分类变量，同样，`<st c="235">婚姻状况</st>` <st c="249">变量`<st c="278">从未结婚</st>`<st
    c="291">、`<st c="293">已婚</st>`<st c="300">、`<st c="302">离婚</st>`<st c="310">和`<st
    c="316">丧偶</st>`<st c="323">也是分类变量。在一些分类变量中，标签具有内在顺序；例如，在`<st c="412">学生成绩</st>`
    <st c="427">变量中，`<st c="452">A</st>`<st c="453">、`<st c="455">B</st>`<st c="456">、`<st
    c="458">C</st>`<st c="459">和`<st c="465">Fail</st>` <st c="469">是按顺序排列的，其中`<st
    c="488">A</st>` <st c="489">是最高等级，而`<st c="518">Fail</st>` <st c="522">是最低等级。</st>`
    <st c="541">这些被称为`<st c="708">城市</st>` <st c="712">变量，其值为`<st c="742">伦敦</st>`<st
    c="748">、`<st c="750">曼彻斯特</st>`<st c="760">、`<st c="762">布里斯托尔</st>`<st c="769">等。</st>`'
- en: <st c="781">The values of categorical variables are often encoded as strings.</st>
    <st c="848">To train most machine learning models, we need to transform those
    strings into numbers.</st> <st c="936">The act of replacing strings</st> <st c="965">with
    numbers is</st> <st c="981">called</st> **<st c="988">categorical encoding</st>**<st
    c="1008">. In this chapter, we will discuss multiple categorical</st> <st c="1064">encoding
    methods.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 分类变量的值通常编码为字符串。为了训练大多数机器学习模型，我们需要将这些字符串转换为数字。将字符串替换为数字的行为称为**<st c="988">分类编码</st>**。在本章中，我们将讨论多种分类**编码方法**。
- en: <st c="1081">This chapter will cover the</st> <st c="1110">following recipes:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下**食谱**：
- en: <st c="1128">Creating binary variables through</st> <st c="1163">one-hot encoding</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**独热编码**创建二进制变量
- en: <st c="1179">Performing one-hot encoding of</st> <st c="1211">frequent categories</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对频繁类别进行**独热编码**
- en: <st c="1230">Replacing categories with counts or the frequency</st> <st c="1281">of
    observations</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用计数或观察值的**频率**替换类别
- en: <st c="1296">Replacing categories with</st> <st c="1323">ordinal numbers</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用**序数**替换类别
- en: <st c="1338">Performing ordinal encoding based on the</st> <st c="1380">target
    value</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据目标值进行**序数编码**
- en: <st c="1392">Implementing target</st> <st c="1413">mean encoding</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现目标**均值编码**
- en: <st c="1426">Encoding with the Weight</st> <st c="1452">of Evidence</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**证据权重**进行编码
- en: <st c="1463">Grouping rare or</st> <st c="1481">infrequent categories</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对稀有或**不频繁类别**进行分组
- en: <st c="1502">Performing</st> <st c="1514">binary en</st><st c="1523">c</st><st
    c="1525">oding</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行**二元编码**
- en: <st c="1530">Technical requirements</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**技术要求**'
- en: <st c="1553">In this chapter, we will use the</st> `<st c="1587">Matplotlib</st>`<st
    c="1597">,</st> `<st c="1599">pandas</st>`<st c="1605">,</st> `<st c="1607">NumPy</st>`<st
    c="1612">,</st> `<st c="1614">scikit-learn</st>`<st c="1626">,</st> `<st c="1628">feature-engine</st>`<st
    c="1642">, and Category Encoders Python libraries.</st> <st c="1684">If you need
    to install Python, the free Anaconda Python distribution (</st>[<st c="1754">https://www.anaconda.com/</st>](https://www.anaconda.com/)<st
    c="1780">) includes most numerical</st> <st c="1807">computing libraries.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1553">在本章中，我们将使用</st> `<st c="1587">Matplotlib</st>`<st c="1597">,</st>
    `<st c="1599">pandas</st>`<st c="1605">,</st> `<st c="1607">NumPy</st>`<st c="1612">,</st>
    `<st c="1614">scikit-learn</st>`<st c="1626">,</st> `<st c="1628">feature-engine</st>`<st
    c="1642">，以及Category Encoders Python库。</st> <st c="1684">如果你需要安装Python，免费的Anaconda
    Python发行版（</st>[<st c="1754">https://www.anaconda.com/</st>](https://www.anaconda.com/)<st
    c="1780">）包括了大多数数值</st> <st c="1807">计算库</st>。</st>
- en: '`<st c="1827">feature-engine</st>` <st c="1842">can be installed</st> <st c="1860">with</st>
    `<st c="1865">pip</st>`<st c="1868">:</st>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="1827">feature-engine</st>` <st c="1842">可以使用</st> `<st c="1865">pip</st>`<st
    c="1868">安装：</st>'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="1897">If you use Anaconda, you can install</st> `<st c="1935">feature-engine</st>`
    <st c="1949">with</st> `<st c="1955">conda</st>`<st c="1960">:</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1897">如果你使用Anaconda，你可以使用</st> `<st c="1935">feature-engine</st>` <st
    c="1949">和</st> `<st c="1955">conda</st>`<st c="1960">安装：</st>
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="2006">To install Category Encoders, use</st> `<st c="2041">pip</st>`
    <st c="2044">as follows:</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2006">要安装Category Encoders，请使用以下</st> `<st c="2041">pip</st>` <st c="2044">命令：</st>
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="2086">We will use the</st> **<st c="2103">Credit Approval</st>** <st
    c="2118">dataset from the</st> *<st c="2136">UCI Machine Learning Repository</st>*
    <st c="2167">(</st>[<st c="2169">https://archive.ics.uci.edu/</st>](https://archive.ics.uci.edu/)<st
    c="2197">), licensed under the CC BY 4.0 creative commons attribution:</st> [<st
    c="2260">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)<st
    c="2313">. You’ll find the dataset at this</st> <st c="2347">link:</st> [<st c="2353">http://archive.ics.uci.edu/dataset/27/credit+approval</st>](http://archive.ics.uci.edu/dataset/27/credit+approval)<st
    c="2406">.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2086">我们将使用来自</st> **<st c="2103">UCI机器学习仓库</st>** <st c="2136">的</st>
    *<st c="2136">信用审批</st>** <st c="2118">数据集</st> <st c="2167">(</st>[<st c="2169">https://archive.ics.uci.edu/</st>](https://archive.ics.uci.edu/)<st
    c="2197">)，该数据集受CC BY 4.0创意共享许可协议保护：</st> [<st c="2260">https://creativecommons.org/licenses/by/4.0/legalcode</st>](https://creativecommons.org/licenses/by/4.0/legalcode)<st
    c="2313">。你可以在以下链接找到数据集：</st> [<st c="2347">http://archive.ics.uci.edu/dataset/27/credit+approval</st>](http://archive.ics.uci.edu/dataset/27/credit+approval)<st
    c="2406">。</st>
- en: <st c="2407">I downloaded and modified the data as shown in this</st> <st c="2460">notebook:</st>
    [<st c="2470">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/credit-approval-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/credit-approval-dataset.ipynb)<st
    c="2620">.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2407">我下载并修改了如本</st> <st c="2460">笔记本</st> <st c="2470">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/credit-approval-dataset.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/credit-approval-dataset.ipynb)<st
    c="2620">所示的数据。</st>
- en: <st c="2621">You’ll find a copy of the modified data set in the accompanying
    GitHub</st> <st c="2693">repository:</st> [<st c="2705">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/)<st
    c="2826">.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2621">你可以在附带的GitHub</st> <st c="2693">仓库中找到修改后的数据集：</st> [<st c="2705">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/)<st
    c="2826">。</st>
- en: <st c="2827">Note</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2827">注意</st>
- en: <st c="2832">Before encoding categorical variables, you might want to impute
    their missing data.</st> <st c="2917">Check out the imputation methods for categorical
    variables in</st> [*<st c="2979">Chapter 1</st>*](B22396_01.xhtml#_idTextAnchor020)<st
    c="2988">,</st> *<st c="2990">Imputing</st>* *<st c="2999">Missing</st> <st c="3007">Data</st>*<st
    c="3011">.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码分类变量之前，你可能想要填充它们的缺失数据。<st c="2917">查看</st> [*<st c="2979">第一章</st>*](B22396_01.xhtml#_idTextAnchor020)<st
    c="2988">中关于分类变量填充方法的内容</st> *<st c="2990">填充</st> *<st c="2999">缺失</st> <st c="3007">数据</st>*<st
    c="3011">。</st>
- en: <st c="3012">Creating binary variables through one-hot encoding</st>
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过独热编码创建二进制变量
- en: '`<st c="3223">1</st>` <st c="3224">if the category is present, or</st> `<st
    c="3256">0</st>` <st c="3257">otherwise.</st>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="3223">1</st>` <st c="3224">如果类别存在，否则</st> `<st c="3256">0</st>` <st
    c="3257">。</st>'
- en: <st c="3268">The following</st> <st c="3282">table shows the one-hot encoded
    representation of the</st> `<st c="3337">Smoker</st>` <st c="3343">variable with
    the categories of</st> `<st c="3376">Smoker</st>` <st c="3382">and</st> `<st c="3387">Non-Smoker</st>`<st
    c="3397">:</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3268">以下</st> <st c="3282">表格显示了</st> `<st c="3337">Smoker</st>` <st
    c="3343">变量的一热编码表示，其类别为</st> `<st c="3376">Smoker</st>` <st c="3382">和</st> `<st
    c="3387">Non-Smoker</st>`<st c="3397">：</st>
- en: '![Figure 2.1 – One-hot encoded representation of the Smoker variable](img/B22396_02_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.1 – One-hot encoded representation of the Smoker variable](img/B22396_02_01.jpg)'
- en: <st c="3475">Figure 2.1 – One-hot encoded representation of the Smoker variable</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3475">图2.1 – Smoker变量的一热编码表示</st>
- en: <st c="3541">As shown in</st> *<st c="3554">Figure 2</st>**<st c="3562">.1</st>*<st
    c="3564">, from the</st> `<st c="3575">Smoker</st>` <st c="3581">variable, we
    can derive a binary variable for</st> `<st c="3628">Smoker</st>`<st c="3634">,
    which shows the value of</st> `<st c="3661">1</st>` <st c="3662">for smokers,</st>
    <st c="3675">or the binary variable for</st> `<st c="3703">Non-Smoker</st>`<st
    c="3713">, which takes the value of</st> `<st c="3740">1</st>` <st c="3741">for
    those who do</st> <st c="3759">not smoke.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3541">如图</st> *<st c="3554">图2.1</st>**<st c="3562">.1</st>*<st c="3564">所示，从</st>
    `<st c="3575">Smoker</st>` <st c="3581">变量中，我们可以导出一个用于</st> `<st c="3628">Smoker</st>`<st
    c="3634">的二进制变量，该变量显示吸烟者的值为</st> `<st c="3661">1</st>` <st c="3662">，或者对于不吸烟者，导出一个</st>
    `<st c="3703">Non-Smoker</st>`<st c="3713">的二进制变量，该变量取值为</st> `<st c="3740">1</st>`
    <st c="3741">。</st>
- en: <st c="3769">For the</st> `<st c="3778">Color</st>` <st c="3783">categorical
    variable with the values of</st> `<st c="3824">red</st>`<st c="3827">,</st> `<st
    c="3829">blue</st>`<st c="3833">, and</st> `<st c="3839">green</st>`<st c="3844">,
    we can create three variables called</st> `<st c="3883">red</st>`<st c="3886">,</st>
    `<st c="3888">blue</st>`<st c="3892">, and</st> `<st c="3898">green</st>`<st c="3903">.
    These variables will be assigned a value of</st> `<st c="3949">1</st>` <st c="3950">if
    the observation corresponds to the respective color, and</st> `<st c="4011">0</st>`
    <st c="4012">if it</st> <st c="4019">does not.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3769">对于具有</st> `<st c="3778">Color</st>` <st c="3783">值的分类变量</st> `<st
    c="3824">red</st>`<st c="3827">，</st> `<st c="3829">blue</st>`<st c="3833">，和</st>
    `<st c="3839">green</st>`<st c="3844">，我们可以创建三个变量，分别称为</st> `<st c="3883">red</st>`<st
    c="3886">，</st> `<st c="3888">blue</st>`<st c="3892">，和</st> `<st c="3898">green</st>`<st
    c="3903">。这些变量将在观察值对应相应颜色时赋予值为</st> `<st c="3949">1</st>` <st c="3950">，如果不对应，则赋予值为</st>
    `<st c="4011">0</st>` <st c="4012">。</st>
- en: <st c="4028">A categorical variable with</st> *<st c="4057">k</st>* <st c="4058">unique
    categories can be encoded using</st> *<st c="4098">k-1</st>* <st c="4101">binary
    variables.</st> <st c="4120">For</st> `<st c="4124">Smoker</st>`<st c="4130">,</st>
    *<st c="4132">k</st>* <st c="4134">is</st> *<st c="4137">2</st>* <st c="4138">as
    it contains two labels (</st>`<st c="4166">Smoker</st>` <st c="4173">and</st>
    `<st c="4178">Non-Smoker</st>`<st c="4188">), so we only need one binary variable
    (</st>*<st c="4229">k - 1 = 1</st>*<st c="4239">) to capture all the information.</st>
    <st c="4274">For the</st> `<st c="4282">Color</st>` <st c="4287">variable, which
    has 3 categories (</st>*<st c="4322">k = 3</st>*<st c="4328">;</st> `<st c="4331">red</st>`<st
    c="4334">,</st> `<st c="4336">blue</st>`<st c="4340">, and</st> `<st c="4346">green</st>`<st
    c="4351">), we need 2 (</st>*<st c="4366">k - 1 = 2</st>*<st c="4376">) binary</st>
    <st c="4386">variables to capture all the information so that the</st> <st c="4439">following
    occurs:</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4028">具有</st> *<st c="4057">k</st>* <st c="4058">个唯一类别的分类变量可以使用</st>
    *<st c="4098">k-1</st>* <st c="4101">个二进制变量进行编码。</st> <st c="4120">对于</st> `<st
    c="4124">Smoker</st>`<st c="4130">，</st> *<st c="4132">k</st>* <st c="4134">是</st>
    *<st c="4137">2</st>* <st c="4138">，因为它包含两个标签（</st>`<st c="4166">Smoker</st>`
    <st c="4173">和</st> `<st c="4178">Non-Smoker</st>`<st c="4188">），所以我们只需要一个二进制变量（</st>*<st
    c="4229">k - 1 = 1</st>*<st c="4239">）来捕捉所有信息。</st> <st c="4274">对于</st> `<st
    c="4282">Color</st>` <st c="4287">变量，它有3个类别（</st>*<st c="4322">k = 3</st>*<st
    c="4328">；</st> `<st c="4331">red</st>`<st c="4334">，</st> `<st c="4336">blue</st>`<st
    c="4340">，和</st> `<st c="4346">green</st>`<st c="4351">），我们需要2个（</st>*<st c="4366">k
    - 1 = 2</st>*<st c="4376">）二进制</st> <st c="4386">变量来捕捉所有信息，以便以下情况发生：</st>
- en: <st c="4456">If the observation is red, it will be captured by the</st> `<st
    c="4511">red</st>` <st c="4514">variable (</st>`<st c="4525">red</st>` <st c="4529">=</st>
    `<st c="4532">1</st>`<st c="4533">,</st> `<st c="4535">blue</st>` <st c="4539">=</st>
    `<st c="4542">0</st>`<st c="4543">)</st>
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="4456">如果观察结果是红色，它将被</st> `<st c="4511">红色</st>` <st c="4514">变量捕获（</st>`<st
    c="4525">红色</st>` <st c="4529">=</st> `<st c="4532">1</st>`<st c="4533">,</st>
    `<st c="4535">蓝色</st>` <st c="4539">=</st> `<st c="4542">0</st>`<st c="4543">）</st>
- en: <st c="4544">If the observation is blue, it will be captured by the</st> `<st
    c="4599">blue</st>` <st c="4603">variable (</st>`<st c="4614">red</st>` <st c="4618">=</st>
    `<st c="4621">0</st>`<st c="4622">,</st> `<st c="4624">blue</st>` <st c="4628">=</st>
    `<st c="4631">1</st>`<st c="4632">)</st>
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="4544">如果观察结果是蓝色，它将被</st> `<st c="4599">蓝色</st>` <st c="4603">变量捕获（</st>`<st
    c="4614">红色</st>` <st c="4618">=</st> `<st c="4621">0</st>`<st c="4622">,</st>
    `<st c="4624">蓝色</st>` <st c="4628">=</st> `<st c="4631">1</st>`<st c="4632">）</st>
- en: <st c="4633">If the observation is green, it will be captured by the combination
    of</st> `<st c="4704">red</st>` <st c="4707">and</st> `<st c="4712">blue</st>`
    <st c="4716">(</st>`<st c="4718">red</st>` <st c="4721">=</st> `<st c="4724">0</st>`<st
    c="4725">,</st> `<st c="4727">blue</st>` <st c="4731">=</st> `<st c="4734">0</st>`<st
    c="4735">)</st>
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="4633">如果观察结果是绿色，它将被</st> `<st c="4704">红色</st>` <st c="4707">和</st> `<st
    c="4712">蓝色</st>` <st c="4716">(</st>`<st c="4718">红色</st>` <st c="4721">=</st>
    `<st c="4724">0</st>`<st c="4725">,</st> `<st c="4727">蓝色</st>` <st c="4731">=</st>
    `<st c="4734">0</st>`<st c="4735">)</st>
- en: <st c="4736">Encoding</st> <st c="4744">into</st> *<st c="4750">k-1</st>* <st
    c="4753">binary variables is well suited for linear models.</st> <st c="4805">There
    are a few occasions in which we may prefer to encode the categorical variables
    with</st> *<st c="4895">k</st>* <st c="4896">binary variables:</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4736">编码</st> <st c="4744">为</st> *<st c="4750">k-1</st>* <st c="4753">二进制变量非常适合线性模型。</st>
    <st c="4805">在某些情况下，我们可能更喜欢使用</st> *<st c="4895">k</st>* <st c="4896">二进制变量来编码分类变量：</st>
- en: <st c="4913">When training decision trees, since they do not evaluate the entire
    feature space at the</st> <st c="5003">same time</st>
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="4913">在训练决策树时，由于它们不会同时评估整个特征空间</st> <st c="5003">，</st>
- en: <st c="5012">When selecting</st> <st c="5028">features recursively</st>
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="5012">当递归选择特征时</st>
- en: <st c="5048">When determining the importance of each category within</st> <st
    c="5105">a variable</st>
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="5048">当确定变量中每个类别的</st> <st c="5105">重要性时</st>
- en: <st c="5115">In this recipe, we will compare the one-hot encoding implementations
    of</st> `<st c="5188">pandas</st>`<st c="5194">,</st> `<st c="5196">scikit-learn</st>`<st
    c="5208">,</st> <st c="5210">and</st> `<st c="5214">featur</st><st c="5220">e-engine</st>`<st
    c="5229">.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5115">在这个菜谱中，我们将比较</st> `<st c="5188">pandas</st>`<st c="5194">、</st>
    `<st c="5196">scikit-learn</st>`<st c="5208">和</st> `<st c="5210">featur</st><st
    c="5220">e-engine</st>`<st c="5229">的one-hot编码实现。</st>
- en: <st c="5230">How to do it...</st>
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5230">如何做到这一点...</st>
- en: <st c="5246">Fir</st><st c="5250">st, let’s make a few imports an</st><st c="5282">d
    get the</st> <st c="5293">data ready:</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5246">首先，让我们做一些导入并</st><st c="5282">准备数据：</st>
- en: <st c="5304">Import</st> `<st c="5312">pandas</st>` <st c="5318">and the</st>
    `<st c="5327">train_test_split</st>` <st c="5343">function</st> <st c="5353">from</st>
    `<st c="5358">scikit-learn</st>`<st c="5370">:</st>
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5304">导入</st> `<st c="5312">pandas</st>` <st c="5318">和</st> `<st c="5327">train_test_split</st>`
    <st c="5343">函数</st> <st c="5353">从</st> `<st c="5358">scikit-learn</st>`<st c="5370">：</st>
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="5445">Let’s load the Credit</st> <st c="5468">Approval dataset:</st>
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5445">让我们加载信用</st> <st c="5468">批准数据集：</st>
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="5531">Let’s separate the data into train and</st> <st c="5571">test sets:</st>
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5531">让我们将数据分为训练集和</st> <st c="5571">测试集：</st>
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="5721">Let’s</st> <st c="5728">inspect the unique categories</st> <st
    c="5757">of the</st> `<st c="5765">A4</st>` <st c="5767">variable:</st>
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5721">让我们</st> <st c="5728">检查</st> `<st c="5765">A4</st>` <st c="5767">变量的</st>
    <st c="5757">唯一类别：</st>
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="5800">We can see the unique values of</st> `<st c="5833">A4</st>` <st
    c="5835">in the</st> <st c="5843">following output:</st>
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="5800">我们可以在以下输出中看到</st> `<st c="5833">A4</st>` <st c="5835">的独特值：</st>
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: dummies = pd.get_dummies(
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: dummies = pd.get_dummies(
- en: X_train["A4"], drop_first=True)
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_train["A4"], drop_first=True)
- en: dummies.head()
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: dummies.head()
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="6102">Note</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6102">注意</st>
- en: <st c="6107">With</st> `<st c="6113">pandas</st>`<st c="6119">’</st> `<st c="6122">get_dummies()</st>`<st
    c="6135">, we can either ignore or encode missing data through the</st> `<st c="6193">dummy_na</st>`
    <st c="6201">parameter.</st> <st c="6213">By setting</st> `<st c="6224">dummy_na=True</st>`<st
    c="6237">, missing data will be encoded in a new binary variable.</st> <st c="6294">To
    encode the variable into</st> *<st c="6322">k</st>* <st c="6323">dummies, use</st>
    `<st c="6337">drop_first=False</st>` <st c="6353">instead.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6107">使用`<st c="6113">pandas</st>`<st c="6119">’</st> `<st c="6122">get_dummies()</st>`<st
    c="6135">，我们可以通过`<st c="6193">dummy_na</st>` <st c="6201">参数忽略或编码缺失数据。</st> <st
    c="6213">通过设置`<st c="6224">dummy_na=True</st>`<st c="6237">，缺失数据将被编码到一个新的二进制变量中。</st>
    <st c="6294">要将变量编码为</st> *<st c="6322">k</st>* <st c="6323">个虚拟变量，请使用`<st c="6337">drop_first=False</st>`
    <st c="6353">。</st>
- en: <st c="6362">Here, we can see the output of</st> *<st c="6394">Step 5</st>*<st
    c="6400">, where each label is now a</st> <st c="6428">binary variable:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6362">在这里，我们可以看到</st> *<st c="6394">步骤5</st>*<st c="6400">的输出，其中每个标签现在都是一个</st>
    <st c="6428">二进制变量：</st>
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="6593">Now, let’s</st> <st c="6605">encode</st> <st c="6612">all the categorical
    variables into</st> *<st c="6647">k-1</st>* <st c="6650">binaries:</st>
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6593">现在，让我们</st> <st c="6605">将所有分类变量编码为</st> *<st c="6647">k-1</st>*
    <st c="6650">二进制值：</st>
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="6768">Note</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6768">注意</st>
- en: '`<st c="6773">pandas</st>`<st c="6780">’</st> `<st c="6783">get_dummies()</st>`<st
    c="6796">will encode all variables of the object, string, or category type by
    default.</st> <st c="6875">To encode a subset of the variables, pass the variable
    names in a list to the</st> `<st c="6953">columns</st>` <st c="6960">par</st><st
    c="6964">ameter.</st>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="6773">pandas</st>`<st c="6780">’</st> `<st c="6783">get_dummies()</st>`<st
    c="6796">默认情况下将编码对象、字符串或类别类型的所有变量。</st> <st c="6875">要编码变量的子集，请将变量名列表传递给`<st c="6953">columns</st>`
    <st c="6960">参数。</st>'
- en: <st c="6972">Let’s inspect the first</st> <st c="6996">five rows of the</st>
    <st c="7014">resulting DataFrame:</st>
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6972">让我们检查一下生成的DataFrame的前五行：</st> <st c="6996">resulting DataFrame:</st>
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="7053">Note</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7053">注意</st>
- en: <st c="7058">When encoding more than one variable,</st> `<st c="7097">get_dummies()</st>`
    <st c="7110">captures the variable name – say,</st> `<st c="7145">A1</st>` <st
    c="7147">– and places an underscore followed by the category name to identify
    the resulting</st> <st c="7231">binary variables.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7058">当编码多个变量时，`<st c="7097">get_dummies()</st>` <st c="7110">会捕获变量名
    – 比如，`<st c="7145">A1</st>` <st c="7147"> – 并在类别名称前加上下划线来标识生成的</st> <st c="7231">二进制变量。</st>
- en: <st c="7248">We can see the binary variables in the</st> <st c="7288">follo</st><st
    c="7293">wing output:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7248">我们可以在以下输出中看到二进制变量：</st> <st c="7288">follo</st><st c="7293">wing
    output:</st>
- en: '![Figure 2.2 – A transformed DataFrame showing the numerical variables followed
    by the one-hot encoded representation of the categorical variables](img/B22396_02_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 一个转换后的DataFrame，显示了数值变量后跟分类变量的独热编码表示](img/B22396_02_02.jpg)'
- en: <st c="7967">Figure 2.2 – A transformed DataFrame showing the numerical variables
    followed by the one-hot encoded representation of the categorical variables</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7967">图2.2 – 一个转换后的DataFrame，显示了数值变量后跟分类变量的独热编码表示</st>
- en: <st c="8111">Note</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8111">注意</st>
- en: '`<st c="8116">pandas</st>`<st c="8123">’</st> `<st c="8126">get_dummies()</st>`<st
    c="8139">will create one binary variable per category seen in a DataFrame.</st>
    <st c="8206">Hence, if there are more categories in the train set than in the
    test set,</st> `<st c="8281">get_dummies()</st>` <st c="8294">will return more
    columns in the transformed train set than in the transformed test set, and vice
    versa.</st> <st c="8399">To avoid this, it is better to carry out one-hot encoding
    with</st> `<st c="8462">scikit-learn</st>` <st c="8474">or</st> `<st c="8478">feature-engine</st>`<st
    c="8492">.</st>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="8116">pandas</st>`<st c="8123">’</st> `<st c="8126">get_dummies()</st>`<st
    c="8139">将为DataFrame中看到的每个类别创建一个二进制变量。</st> <st c="8206">因此，如果训练集中比测试集中有更多类别，`<st
    c="8281">get_dummies()</st>` <st c="8294">将在转换后的训练集中返回比转换后的测试集更多的列，反之亦然。</st>
    <st c="8399">为了避免这种情况，最好使用`<st c="8462">scikit-learn</st>` <st c="8474">或`<st
    c="8478">feature-engine</st>`<st c="8492">进行独热编码。</st>'
- en: <st c="8493">Let’s do one-hot encoding using</st> `<st c="8526">scikit-learn</st>`
    <st c="8538">instead.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8493">让我们使用`<st c="8526">scikit-learn</st>` <st c="8538">来进行独热编码。</st>
- en: <st c="8547">Let’s</st> <st c="8554">import the encoder</st> <st c="8572">and</st>
    `<st c="8577">ColumnTransformer</st>` <st c="8594">from</st> `<st c="8600">scikit-learn</st>`<st
    c="8612">:</st>
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8547">让我们</st> <st c="8554">从</st> `<st c="8600">scikit-learn</st>`<st
    c="8612">导入编码器</st> <st c="8572">和</st> `<st c="8577">ColumnTransformer</st>`
    <st c="8594">：</st>
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="8708">Let’s create a list with the names of the</st> <st c="8751">categorical
    variables:</st>
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8708">让我们创建一个包含分类变量名称的列表：</st>
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="8838">Let’s set up the encoder to create</st> *<st c="8874">k-1</st>*
    <st c="8877">binary variables:</st>
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8838">让我们设置编码器以创建</st> *<st c="8874">k-1</st>* <st c="8877">个二进制变量：</st>
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="8954">Note</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8954">注意</st>
- en: <st c="8959">To encode variables into</st> *<st c="8985">k</st>* <st c="8986">dummies,
    set the</st> `<st c="9004">drop</st>` <st c="9008">parameter to</st> `<st c="9022">None</st>`<st
    c="9026">. To encode only binary variables into</st> *<st c="9065">k-1</st>*<st
    c="9068">, set the</st> `<st c="9078">drop</st>` <st c="9082">parameter to</st>
    `<st c="9096">if_binary</st>`<st c="9105">. The latter is useful because encoding
    binary variables into</st> *<st c="9167">k</st>* <st c="9168">dummies</st> <st
    c="9177">is redundant.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8959">要将变量编码为</st> *<st c="8985">k</st> * <st c="8986">个虚拟变量，将</st> `<st
    c="9004">drop</st>` <st c="9008">参数设置为</st> `<st c="9022">None</st>`<st c="9026">。要将仅二进制变量编码为</st>
    *<st c="9065">k-1</st>*<st c="9068">，将</st> `<st c="9078">drop</st>` <st c="9082">参数设置为</st>
    `<st c="9096">if_binary</st>`<st c="9105">。后者是有用的，因为将二进制变量编码为</st> *<st c="9167">k</st>*
    <st c="9168">个虚拟变量</st> <st c="9177">是多余的。</st>
- en: <st c="9190">Let’s</st> <st c="9197">restrict the encoding to the</st> <st c="9226">categorical
    variables:</st>
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9190">让我们</st> <st c="9197">将编码限制在</st> <st c="9226">分类变量</st>：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="9396">Let’s fit</st> <st c="9407">the encoder so that it identifies the
    categories</st> <st c="9456">to encode:</st>
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9396">让我们拟合编码器，使其识别要编码的类别：</st>
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="9482">Let’s inspect the categories that will be represented with</st>
    <st c="9542">binary variables:</st>
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9482">让我们检查将用二进制变量表示的类别：</st>
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="9605">The transformer will add binary variables for the</st> <st c="9656">follow</st><st
    c="9662">ing categories:</st>
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="9605">该转换器将为以下类别添加二进制变量：</st>
- en: '![Figure 2.3 – Arrays with the categories that will be encoded into binary
    variables (one array per variable)](img/B22396_02_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 将编码为二进制变量的类别数组（每个变量一个数组）](img/B22396_02_03.jpg)'
- en: <st c="10132">Figure 2.3 – Arrays with the categories that will be encoded into
    binary variables (one array per variable)</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10132">图2.3 – 将编码为二进制变量的类别数组（每个变量一个数组）</st>
- en: <st c="10239">Note</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10239">注意</st>
- en: '`<st c="10244">scikit-learn</st>`<st c="10257">’s</st> `<st c="10261">OneHotEncoder()</st>`
    <st c="10276">will only encode the categories learned from the train set.</st>
    <st c="10337">If there are new categories in the test set, we can instruct the
    encoder to ignore them, return an error, or replace them with an infrequent category,
    by setting the</st> `<st c="10503">handle_unknown</st>` <st c="10517">parameter
    to</st> `<st c="10531">ignore</st>`<st c="10537">,</st> `<st c="10539">error</st>`<st
    c="10544">,</st> <st c="10546">or</st> `<st c="10549">infrequent_if</st><st c="10562">_exists</st>`<st
    c="10570">.</st>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="10244">scikit-learn</st>`<st c="10257">的</st> `<st c="10261">OneHotEncoder()</st>`
    <st c="10276">将仅编码从训练集中学习到的类别。</st> <st c="10337">如果测试集中有新的类别，我们可以指示编码器忽略它们、返回错误或将它们替换为不常见的类别，通过将</st>
    `<st c="10503">handle_unknown</st>` <st c="10517">参数设置为</st> `<st c="10531">ignore</st>`<st
    c="10537">、`<st c="10539">error</st>`<st c="10544">、`<st c="10546">或</st> `<st
    c="10549">infrequent_if</st><st c="10562">_exists</st>`<st c="10570">。</st>'
- en: <st c="10571">Let’s</st> <st c="10578">encode the</st> <st c="10589">categorical
    variables:</st>
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10571">让我们</st> <st c="10578">编码分类变量：</st>
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="10681">Make sure to inspect the result by</st> <st c="10717">executing</st>
    `<st c="10727">X_test_enc.head()</st>`<st c="10744">.</st>
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10681">确保通过执行</st> <st c="10717">`<st c="10727">X_test_enc.head()</st>`</st>
    <st c="10744">来检查结果。</st>
- en: <st c="10745">To get</st> <st c="10752">familiar with the output, let’s print
    the variable names of the</st> <st c="10817">resulting DataFrame:</st>
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10745">为了熟悉输出，让我们打印结果DataFrame的变量名称：</st>
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="10864">In the following image, we see the names of the variables in the</st>
    <st c="10930">transf</st><st c="10936">ormed DataFrame:</st>
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10864">在以下图像中，我们看到转换后的DataFrame中的变量名称：</st>
- en: '![Figure 2.4 – Arrays with the names of the variables in the resulting DataFrame](img/B22396_02_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 转换后的DataFrame中的变量名称数组](img/B22396_02_04.jpg)'
- en: <st c="11696">Figure 2.4 – Arrays with the names of the variables in the resulting
    DataFrame</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11696">图2.4 – 结果DataFrame中变量的名称数组</st>
- en: <st c="11774">Note</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11774">注意</st>
- en: '`<st c="11779">ColumnTransformer()</st>` <st c="11799">changes the name and
    order of the variables during the transformation.</st> <st c="11871">If the variable
    was encoded, it will append the</st> `<st c="11919">encoder</st>` <st c="11926">prefix
    and if the variable was not modified, it will append the</st> `<st c="11991">remainder</st>`
    <st c="12000">prefix.</st>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="11779">ColumnTransformer()</st>` <st c="11799">在转换过程中更改变量的名称和顺序。</st>
    <st c="11871">如果变量已被编码，它将附加`<st c="11919">encoder</st>` <st c="11926">前缀；如果变量未被修改，它将附加`<st
    c="11991">remainder</st>` <st c="12000">前缀。</st>'
- en: <st c="12008">To wrap up the recipe, let’s perform one-hot encoding</st> <st
    c="12063">with</st> `<st c="12068">featu</st><st c="12073">re-engine</st>`<st
    c="12083">.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12008">为了总结这个配方，让我们使用`<st c="12063">featu</st><st c="12068">re-engine</st>`<st
    c="12083">`进行独热编码：</st>
- en: <st c="12084">Let’s</st> <st c="12090">import</st> <st c="12098">the encoder</st>
    <st c="12110">from</st> `<st c="12115">f</st>``<st c="12116">eature-engine</st>`<st
    c="12129">:</st>
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12084">让我们</st> <st c="12090">导入</st> <st c="12098">编码器</st> <st c="12110">来自</st>
    `<st c="12115">f</st>``<st c="12116">eature-engine</st>`<st c="12129">:</st>
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="12182">Let’s set up the encoder so that it returns</st> *<st c="12227">k-1</st>*
    <st c="12230">binary variables:</st>
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12182">让我们设置编码器，使其返回`*<st c="12227">k-1</st>`* <st c="12230">二元变量：</st>
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="12288">Note</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12288">注意</st>
- en: '`<st c="12293">feature-engine</st>`<st c="12308">’s</st> `<st c="12312">OneHotEncoder()</st>`
    <st c="12327">encodes all categorical variables by default.</st> <st c="12374">To
    encode a subset of the variables, pass the variable names in a list:</st> `<st
    c="12446">OneHotEncoder(variables=["A1", "A4"]</st>`<st c="12482">).</st> <st
    c="12486">To encode numerical variables, set the</st> `<st c="12525">ignore_format</st>`
    <st c="12538">parameter to</st> `<st c="12552">True</st>` <st c="12556">or cast
    the variables</st> <st c="12579">as objects.</st>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="12293">feature-engine</st>`<st c="12308">`的`<st c="12312">OneHotEncoder()</st>`
    <st c="12327">默认情况下编码所有分类变量。</st> <st c="12374">要编码变量的子集，请传递变量名称列表：</st> `<st
    c="12446">OneHotEncoder(variables=["A1", "A4"]</st>`<st c="12482">)。</st> <st
    c="12486">要编码数值变量，将`<st c="12525">ignore_format</st>` <st c="12538">参数设置为`<st
    c="12552">True</st>` <st c="12556">或将变量转换为对象。</st>'
- en: <st c="12590">Let’s fit the encoder to the train set so that it learns the categories
    and variables</st> <st c="12677">to encode:</st>
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12590">让我们将编码器拟合到训练集，以便它学习要编码的类别和变量：</st> <st c="12677">要编码的：</st>
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="12708">Note</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12708">注意</st>
- en: <st c="12713">To encode binary variables into</st> *<st c="12746">k-1</st>*<st
    c="12749">, and other categorical variables into</st> *<st c="12788">k</st>* <st
    c="12789">dummies, set the</st> `<st c="12807">drop_last_binary</st>` <st c="12823">parameter</st>
    <st c="12834">to</st> `<st c="12837">True</st>`<st c="12841">.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12713">要将二元变量编码为`*<st c="12746">k-1</st>`*<st c="12749">，并将其他分类变量编码为`*<st
    c="12788">k</st>` <st c="12789">虚变量，将`<st c="12807">drop_last_binary</st>` <st
    c="12823">参数设置为`<st c="12837">True</st>`<st c="12841">。</st>
- en: <st c="12842">Let’s explore the variables that will</st> <st c="12881">be encoded:</st>
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12842">让我们探索将要</st> <st c="12881">编码的变量：</st>
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="12911">The transformer found and stored the variables of the object or
    categorical type, as shown in the</st> <st c="13010">following output:</st>
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12911">Transformer找到了并存储了对象或分类类型的变量，如下面的输出所示：</st> <st c="13010">以下输出：</st>
- en: '[PRE24]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="13086">Let’s</st> <st c="13092">explore the c</st><st c="13106">ategories
    for which dummy variables will</st> <st c="13148">be created:</st>
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13086">让我们</st> <st c="13092">探索将创建虚变量的类别：</st>
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="13181">The</st> <st c="13185">following dictionary contains the categories
    that will be encoded in</st> <st c="13255">each variable:</st>
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13181">以下</st> <st c="13185">字典包含将在每个变量中编码的类别：</st>
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="13555">Let’s encode the categorical variables in train and</st> <st c="13608">test
    sets:</st>
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13555">让我们在训练集和测试集中编码分类变量：</st>
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="13698">If we execute</st> `<st c="13713">X_train_enc.head()</st>`<st
    c="13731">, we will see the</st> <st c="13749">f</st><st c="13750">ollowing DataFrame:</st>
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13698">如果我们执行</st> `<st c="13713">X_train_enc.head()</st>`<st c="13731">，我们将看到以下DataFrame：</st>
- en: '![Figure 2.5 – Transformed DataFrame with numerical variables followed by the
    one-hot encoded representation of the categorical variables](img/B22396_02_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 带有数值变量和分类变量独热编码表示的转换后的DataFrame](img/B22396_02_05.jpg)'
- en: <st c="14176">Figure 2.5 – Transformed DataFrame with numerical variables followed
    by the one-hot encoded representation of the categorical variables</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14176">图2.5 – 转换后的DataFrame，数值变量之后跟着分类变量的独热编码表示</st>
- en: <st c="14311">Note</st> <st c="14317">how the</st> `<st c="14325">A4</st>` <st
    c="14327">cate</st><st c="14332">gorical</st> <st c="14341">variable was replaced
    with</st> `<st c="14368">A4_u</st>`<st c="14372">,</st> `<st c="14374">A4_y</st>`<st
    c="14378">, and</st> <st c="14384">so on.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14311">注意</st> <st c="14317">如何</st> `<st c="14325">A4</st>` <st c="14327">分类</st><st
    c="14332">变量</st> <st c="14341">被替换为</st> `<st c="14368">A4_u</st>`<st c="14372">，`<st
    c="14374">A4_y</st>`<st c="14378">，以及</st> <st c="14384">等等。</st>
- en: <st c="14390">Note</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14390">注意</st>
- en: <st c="14395">We can get the names of all the variables in the transformed dataset
    by</st> <st c="14468">executing</st> `<st c="14478">ohe_enc.get</st><st c="14489">_feature_names_out()</st>`<st
    c="14510">.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14395">我们可以通过执行</st> `<st c="14468">ohe_enc.get</st><st c="14489">_feature_names_out()</st>`<st
    c="14510">来获取转换后的数据集中所有变量的名称。</st>
- en: <st c="14511">How it works...</st>
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14511">它的工作原理...</st>
- en: <st c="14527">In this recipe, we performed a one-hot encoding of categorical
    variables using</st> `<st c="14607">pandas</st>`<st c="14613">,</st> `<st c="14615">scikit-learn</st>`<st
    c="14627">,</st> <st c="14629">and</st> `<st c="14633">feature-engine</st>`<st
    c="14647">.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14527">在这个菜谱中，我们使用</st> `<st c="14607">pandas</st>`<st c="14613">，`<st
    c="14615">scikit-learn</st>`<st c="14627">，和</st> `<st c="14629">feature-engine</st>`<st
    c="14647">对分类变量进行了独热编码。</st>
- en: '`<st c="14648">pandas</st>`<st c="14655">’</st> `<st c="14658">get_dummies()</st>`
    <st c="14671">replaced the categorical variables with a set of binary variables
    representing each of the categories.</st> <st c="14775">When used on the entire
    dataset, it returned the numerical variables, followed by the one-hot encoded
    representation of each seen category in every variable of type object, string,</st>
    <st c="14956">or categorical.</st>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="14648">pandas</st>`<st c="14655">’</st> `<st c="14658">get_dummies()</st>`
    <st c="14671">将分类变量替换为表示每个类别的二进制变量集。</st> <st c="14775">当用于整个数据集时，它返回数值变量，然后是每个变量中看到的每个类别的独热编码表示，变量类型为对象、字符串，</st>
    <st c="14956">或分类。</st>'
- en: <st c="14971">Note</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14971">注意</st>
- en: '`<st c="14976">pandas</st>` <st c="14983">will return binary variables for
    every category seen in a dataset.</st> <st c="15051">In practice, to avoid data
    leakage and anticipate deployment eventualities, we want to return dummy variables
    for categories seen in a training set only.</st> <st c="15205">So, it is safer
    to use</st> `<st c="15228">scikit-learn</st>` <st c="15240">and</st> `<st c="15245">feature-engine</st>`<st
    c="15259">.</st>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="14976">pandas</st>` <st c="14983">将为数据集中看到的每个类别返回二进制变量。</st> <st c="15051">在实际应用中，为了避免数据泄露并预测部署情况，我们只想为训练集中看到的类别返回虚拟变量。</st>
    <st c="15205">因此，使用</st> `<st c="15228">scikit-learn</st>` <st c="15240">和</st>
    `<st c="15245">feature-engine</st>`<st c="15259">更安全。</st>'
- en: '`<st c="15260">OneHotEncoder()</st>` <st c="15276">from</st> `<st c="15282">scikit-learn</st>`
    <st c="15294">or</st> `<st c="15298">feature-engine</st>` <st c="15312">learned
    the categories that should be represented by binary variables from the train set
    when we applied</st> `<st c="15418">fit()</st>`<st c="15423">. With</st> `<st
    c="15430">transform()</st>`<st c="15441">,</st> `<st c="15443">scikit-learn</st>`
    <st c="15455">returned just the binary variables, whereas</st> `<st c="15500">feature-engine</st>`
    <st c="15514">returned the numerical variables followed by the one-hot encoded
    representation of the</st> <st c="15602">categorical ones.</st>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15260">OneHotEncoder()</st>` <st c="15276">从</st> `<st c="15282">scikit-learn</st>`
    <st c="15294">或</st> `<st c="15298">feature-engine</st>` <st c="15312">学习了我们应用</st>
    `<st c="15418">fit()</st>`<st c="15423">时应该用二进制变量表示的类别。使用</st> `<st c="15430">transform()</st>`<st
    c="15441">，`<st c="15443">scikit-learn</st>` <st c="15455">仅返回二进制变量，而</st> `<st
    c="15500">feature-engine</st>` <st c="15514">返回数值变量，然后是分类变量的独热编码表示。</st>'
- en: '`<st c="15619">scikit-learn</st>`<st c="15632">’s</st> `<st c="15636">OneHotEncoder()</st>`
    <st c="15651">encodes all variables by default.</st> <st c="15686">To restrict
    the encoding to</st> <st c="15714">categorical variables, we</st> <st c="15740">used</st>
    `<st c="15745">ColumnTransformer()</st>`<st c="15764">. We set the output of</st>
    `<st c="15787">transform()</st>`<st c="15798">to</st> `<st c="15802">pandas</st>`
    <st c="15808">to obtain the resulting data as</st> <st c="15841">a DataFrame.</st>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15619">scikit-learn</st>` `<st c="15632">’s</st>` `<st c="15636">OneHotEncoder()</st>`
    `<st c="15651">默认情况下编码所有变量。</st>` `<st c="15686">要限制编码为</st>` `<st c="15714">分类变量，我们</st>`
    `<st c="15740">使用了</st>` `<st c="15745">ColumnTransformer()</st>` `<st c="15764">。我们将</st>`
    `<st c="15787">transform()</st>` `<st c="15798">的输出</st>` `<st c="15802">设置为</st>`
    `<st c="15808">pandas</st>` `<st c="15841">，以获得结果数据作为</st>` `<st c="15841">DataFrame。</st>`'
- en: <st c="15853">Note</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15853">注意</st>`'
- en: <st c="15858">One-hot encoding is suitable for linear models.</st> <st c="15907">It
    also expands the feature space.</st> <st c="15942">If your dataset contains many
    categorical variables or highly cardinal variables, you can restrict the number
    of binary variables by encoding the most frequent categories only.</st> <st c="16119">You
    can do this automatically with both</st> `<st c="16159">scikit-learn</st>` <st
    c="16171">and</st> `<st c="16176">feature-engine</st>` <st c="16190">as we describe
    in the</st> *<st c="16213">Performing one-hot encoding of freq</st><st c="16248">uent</st>*
    *<st c="16254">categories</st>* <st c="16264">recipe.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15858">One-hot 编码适用于线性模型。</st>` `<st c="15907">它还扩展了特征空间。</st>` `<st
    c="15942">如果你的数据集包含许多分类变量或高度基数变量，你可以通过仅编码最频繁的类别来限制二进制变量的数量。</st>` `<st c="16119">你可以使用</st>`
    `<st c="16159">scikit-learn</st>` `<st c="16171">和</st>` `<st c="16176">feature-engine</st>`
    `<st c="16190">自动完成此操作，正如我们在</st>` `<st c="16213">Performing one-hot encoding
    of freq</st><st c="16248">uent</st>` `<st c="16254">categories</st>` `<st c="16264">recipe.</st>`
    `<st c="16213">执行频繁类别 one-hot 编码</st>` `<st c="16254">recipe.</st>` `<st c="16264">配方</st>`
    `<st c="16213">中描述的。</st>`'
- en: <st c="16272">There’s more...</st>
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="16272">还有更多...</st>`'
- en: <st c="16288">We can also perform one-hot encoding using the Category Encoders
    Python</st> <st c="16361">library:</st> [<st c="16370">https://</st><st c="16378">contrib.scikit-learn.org/category_encoders/onehot.html</st>](https://contrib.scikit-learn.org/category_encoders/onehot.html)<st
    c="16433">.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16288">我们还可以使用 Category Encoders Python</st>` `<st c="16361">库</st>`
    `<st c="16370">https://</st><st c="16378">contrib.scikit-learn.org/category_encoders/onehot.html</st>`
    `<st c="16433">。</st>`'
- en: <st c="16434">To limit the number of binary variables, we can choose which categories
    to encode and which to ignore; check out a Python demo in the following</st> <st
    c="16579">article:</st> <st c="16588">https://www.blog.trainindata.com/one-hot-encoding-</st><st
    c="16638">categorical-variables</st><st c="16660">/</st><st c="16662">.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16434">为了限制二进制变量的数量，我们可以选择要编码的类别和要忽略的类别；查看以下</st>` `<st c="16579">文章</st>`
    `<st c="16588">https://www.blog.trainindata.com/one-hot-encoding-</st><st c="16638">categorical-variables</st><st
    c="16660">/</st><st c="16662">。</st>`'
- en: <st c="16663">Performing one-hot encoding of frequent categories</st>
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<st c="16663">执行频繁类别 one-hot 编码</st>`'
- en: <st c="16714">One-hot encoding</st> <st c="16732">represents each variable’s
    category with a binary variable.</st> <st c="16791">Hence, one-hot encoding of
    highly cardinal variables or datasets with multiple categorical features can expand
    the feature space dramatically.</st> <st c="16935">This, in turn, may increase
    the computational cost of using machine learning models or deteriorate their performance.</st>
    <st c="17053">To reduce the number of binary variables, we can perform one-hot
    encoding of the most frequent categories.</st> <st c="17160">One-hot encoding</st>
    <st c="17177">the top categories is equivalent to treating the remaining, less
    frequent categories as a single,</st> <st c="17275">unique category.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16714">One-hot 编码</st>` `<st c="16732">使用二进制变量表示每个变量的类别。</st>` `<st
    c="16791">因此，高度基数变量或具有多个分类特征的数据集的 one-hot 编码可以显著扩展特征空间。</st>` `<st c="16935">这反过来可能会增加使用机器学习模型的计算成本或降低其性能。</st>`
    `<st c="17053">为了减少二进制变量的数量，我们可以对最频繁的类别执行 one-hot 编码。</st>` `<st c="17160">对顶级类别进行
    one-hot 编码</st>` `<st c="17177">相当于将剩余的、较少出现的类别视为一个单一的、独特的类别。</st>`'
- en: <st c="17291">In this recipe, we will implement one-hot encoding of the most
    popular categories using</st> `<st c="17380">pandas</st>`<st c="17386">,</st>
    `<st c="17388">Scikit-l</st><st c="17396">earn</st>`<st c="17401">,</st> <st c="17403">and</st>
    `<st c="17407">feature-engine</st>`<st c="17421">.</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用 `<st c="17291">pandas</st>`、`<st c="17380">Scikit-l</st><st c="17396">earn</st>`、`<st
    c="17403">和</st>` `<st c="17407">feature-engine</st>` `<st c="17421">` 来实现最流行类别的
    one-hot 编码。
- en: <st c="17422">How to do it...</st>
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17422">如何操作...</st>
- en: <st c="17438">First, let’s import</st> <st c="17459">the necessary</st> <st
    c="17473">Python libraries and get the</st> <st c="17502">dataset ready:</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17438">首先，让我们导入</st> <st c="17459">必要的</st> <st c="17473">Python 库并准备好</st>
    <st c="17502">数据集：</st>
- en: <st c="17516">Import the required Python libraries, functions,</st> <st c="17566">and
    classes:</st>
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17516">导入所需的 Python 库、函数、</st> <st c="17566">和类：</st>
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="17670">Let’s load the Credit Approval dataset and divide it into train
    and</st> <st c="17739">test sets:</st>
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17670">让我们加载 Credit Approval 数据集并将其分为训练集和</st> <st c="17739">测试集：</st>
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="17935">Note</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17935">注意</st>
- en: <st c="17940">The most frequent categories need to be determined in the train
    set.</st> <st c="18010">This is to avoid</st> <st c="18027">data leakage.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17940">需要在训练集中确定最频繁的类别。</st> <st c="18010">这是为了避免</st> <st c="18027">数据泄露。</st>
- en: <st c="18040">Let’s inspect the unique categories of the</st> `<st c="18084">A6</st>`
    <st c="18086">variable:</st>
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18040">让我们检查</st> `<st c="18084">A6</st>` <st c="18086">变量的唯一类别：</st>
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="18119">The unique values of</st> `<st c="18141">A6</st>` <st c="18143">are
    displayed in the</st> <st c="18165">following output:</st>
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18119">以下输出显示了</st> `<st c="18141">A6</st>` <st c="18143">的唯一值：</st>
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: X_train["A6"].value_counts().sort_values(
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_train["A6"].value_counts().sort_values(
- en: ascending=False).head(5)
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ascending=False).head(5)
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="18610">A6</st>
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18610">A6</st>
- en: <st c="18613">c      93</st>
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18613">c      93</st>
- en: <st c="18618">q      56</st>
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18618">q      56</st>
- en: <st c="18623">w      48</st>
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18623">w      48</st>
- en: <st c="18628">i      41</st>
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18628">i      41</st>
- en: <st c="18633">ff     38</st>
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18633">ff     38</st>
- en: '<st c="18717">A6</st> in a list by using the code in *<st c="18751">Step 4</st>*
    inside a list comprehension:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18717">使用</st> *<st c="18751">步骤 4</st>* <st c="18719">中的代码在一个列表推导式中将</st>
    `<st c="18717">A6</st>` <st c="18721">放入一个列表中：</st>
- en: '[PRE33]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*****   <st c="18883">Let’s add a binary variable per top category to a copy
    of the train and</st> <st c="18956">test sets:</st>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*****   <st c="18883">让我们为每个顶级类别向训练集和</st> <st c="18956">测试集的副本添加一个二元变量：</st>'
- en: '[PRE35]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="19178">Let’s display</st> <st c="19192">the top</st> `<st c="19201">10</st>`
    <st c="19203">rows</st> <st c="19209">of the original and encoded variable,</st>
    `<st c="19247">A6</st>`<st c="19249">, in the</st> <st c="19258">train set:</st>
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19178">让我们显示</st> <st c="19192">原始和编码变量</st> `<st c="19203">A6</st>`<st
    c="19249">，在</st> <st c="19258">训练集</st>中的</st> `<st c="19201">前 10</st>` <st
    c="19209">行：</st>
- en: '[PRE36]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="19335">In the output of</st> *<st c="19353">Step 7</st>*<st c="19359">,
    we can see the</st> `<st c="19376">A6</st>` <st c="19378">variable, followed by
    the</st> <st c="19405">binary variables:</st>
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19335">在</st> *<st c="19353">步骤 7</st>*<st c="19359">的输出中，我们可以看到</st>
    `<st c="19376">A6</st>` <st c="19378">变量，后面跟着</st> <st c="19405">二元变量：</st>
- en: '[PRE37]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="19690">Let’s import</st> <st c="19704">the encoder:</st>
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19690">让我们导入</st> <st c="19704">编码器：</st>
- en: '[PRE38]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="19764">Let’s set</st> <st c="19775">up the encoder to encode categories
    shown in at least</st> `<st c="19829">39</st>` <st c="19831">observations and
    limit the number of categories to encode</st> <st c="19890">to</st> `<st c="19893">5</st>`<st
    c="19894">:</st>
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19764">让我们设置</st> <st c="19775">编码器以编码至少</st> `<st c="19829">39</st>`
    <st c="19831">个观察值中显示的类别，并将编码的类别数量限制为</st> `<st c="19890">5</st>`<st c="19894">：</st>
- en: '[PRE39]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="20010">Finally, let’s</st> <st c="20025">fit the transformer to the two
    high cardinal variables and then transform</st> <st c="20100">the data:</st>
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20010">最后，让我们</st> <st c="20025">将转换器拟合到两个高基数变量，然后转换</st> <st c="20100">数据：</st>
- en: '[PRE40]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="20222">If you execute</st> `<st c="20238">X_train_enc.head()</st>` <st
    c="20256">you’ll see the</st> <st c="20272">resulting DataFrame:</st>****
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="20222">如果你执行</st> `<st c="20238">X_train_enc.head()</st>` <st c="20256">，你会看到</st>
    <st c="20272">生成的 DataFrame：</st>****
- en: '****![Figure 2.6 – Transformed DataFrame containing binary variables for those
    categories with at least 39 observations and an additional binary representing
    all remaining categories](img/B22396_02_06.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '****![图 2.6 – 包含至少 39 个观察值的类别二元变量以及表示所有剩余类别的额外二元变量的转换 DataFrame](img/B22396_02_06.jpg)'
- en: <st c="20596">Figure 2.6 – Transformed DataFrame containing binary variables
    for those categories with at least 39 observations and an additional binary representing
    all remaining categories</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20596">图 2.6 – 包含至少 39 个观察值的类别二元变量以及表示所有剩余类别的额外二元变量的转换 DataFrame</st>
- en: <st c="20772">To wrap up the recipe, let’s encode the most frequent categories</st>
    <st c="20838">with</st> `<st c="20843">feature-engine</st>`<st c="20857">.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20772">为了总结这个方法，让我们使用</st> `<st c="20843">feature-engine</st>`<st c="20857">.</st>
    <st c="20838">来编码最频繁的类别</st>
- en: <st c="20858">Let’s set up</st> <st c="20871">the one-hot encoder to encode
    the five most frequent categories of the</st> `<st c="20943">A6</st>` <st c="20945">and</st>
    `<st c="20950">A7</st>` <st c="20952">variables:</st>
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="20858">让我们设置</st> <st c="20871">单热编码器，以对</st> `<st c="20943">A6</st>`
    <st c="20945">和</st> `<st c="20950">A7</st>` <st c="20952">变量的前五个最频繁类别进行编码：</st>
- en: '[PRE41]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="21081">Note</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21081">注意</st>
- en: <st c="21086">The number of frequent categories to encode is arbitrarily dete</st><st
    c="21150">rmined by</st> <st c="21161">the user.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21086">要编码的频繁类别数量由</st><st c="21150">用户</st><st c="21161">任意确定。</st>
- en: <st c="21170">Let’s fit</st> <st c="21180">the encoder to the train set so that
    it learns and stores the most frequent categories of</st> `<st c="21271">A6</st>`
    <st c="21273">and</st> `<st c="21278">A7</st>`<st c="21280">:</st>
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="21170">让我们将编码器拟合到训练集，以便它学习并存储</st> `<st c="21271">A6</st>` <st c="21273">和</st>
    `<st c="21278">A7</st>`<st c="21280">的最频繁类别：</st>
- en: '[PRE42]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <st c="21303">Finally, let’s encode</st> `<st c="21326">A6</st>` <st c="21328">and</st>
    `<st c="21333">A7</st>` <st c="21335">in the train and</st> <st c="21353">test
    sets:</st>
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="21303">最后，让我们在训练集和测试集中对</st> `<st c="21326">A6</st>` <st c="21328">和</st>
    `<st c="21333">A7</st>` <st c="21335">进行编码：</st>
- en: '[PRE43]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="21443">You can view the new binary variables in the transformed DataFrame
    by executing</st> `<st c="21524">X_train_enc.head()</st>`<st c="21542">. You can
    also find the top five categories learned by the encoder b</st><st c="21610">y</st>
    <st c="21613">executing</st> `<st c="21623">ohe_enc.encoder_dict_</st>`<st c="21644">.</st>
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="21443">您可以通过执行</st> `<st c="21524">X_train_enc.head()</st>`<st c="21542">来查看转换后的
    DataFrame 中的新二进制变量。您还可以通过执行</st> `<st c="21623">ohe_enc.encoder_dict_</st>`<st
    c="21644">来找到编码器学习到的前五个类别。</st>
- en: <st c="21645">How it works...</st>
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="21645">它是如何工作的...</st>
- en: <st c="21661">In the first</st> <st c="21675">part of this recipe, we worked
    with the</st> `<st c="21715">A6</st>` <st c="21717">categorical variable.</st>
    <st c="21740">We inspected its unique categories with</st> `<st c="21780">pandas</st>`<st
    c="21786">’</st> `<st c="21789">unique()</st>`<st c="21797">. Next, we counted
    the number of observations per category using</st> `<st c="21862">pandas</st>`<st
    c="21868">’</st> `<st c="21871">value_counts()</st>`<st c="21885">, which returned
    a</st> `<st c="21904">pandas</st>` <st c="21910">series with the categories as
    the index and the number of observations as values.</st> <st c="21993">Next, we
    sorted the categories from the one with the most to the one with the least observations
    using</st> `<st c="22096">pandas</st>`<st c="22102">’</st> `<st c="22104">sort_values()</st>`<st
    c="22117">. We then reduced the series to the five most popular categories by
    using</st> `<st c="22191">pandas</st>`<st c="22197">’</st> `<st c="22200">head()</st>`<st
    c="22206">. We used this series in a list comprehension to capture the names of
    the most frequent categories.</st> <st c="22306">After that, we looped over each
    category, and with NumPy’s</st> `<st c="22365">where()</st>`<st c="22372">, we
    created binary variables by placing a value of</st> `<st c="22424">1</st>` <st
    c="22425">if the observation showed the category, or</st> `<st c="22469">0</st>`
    <st c="22470">otherwise.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21661">在这个菜谱的第一部分，我们处理了</st> `<st c="21715">A6</st>` <st c="21717">分类变量。</st>
    <st c="21740">我们使用</st> `<st c="21780">pandas</st>`<st c="21786">的</st> `<st c="21789">unique()</st>`<st
    c="21797">检查其独特的类别。接下来，我们使用</st> `<st c="21862">pandas</st>`<st c="21868">的</st>
    `<st c="21871">value_counts()</st>`<st c="21885">计算每个类别的观测数，它返回了一个以类别为索引、观测数为值的</st>
    `<st c="21904">pandas</st>` <st c="21910">系列。</st> <st c="21993">接下来，我们使用</st>
    `<st c="22096">pandas</st>`<st c="22102">的</st> `<st c="22104">sort_values()</st>`<st
    c="22117">将类别从观测数最多的到最少的进行排序。然后，我们使用</st> `<st c="22191">pandas</st>`<st c="22197">的</st>
    `<st c="22200">head()</st>`<st c="22206">将系列缩减到最流行的五个类别。我们使用列表推导式来捕获最频繁类别的名称。</st>
    <st c="22306">之后，我们对每个类别进行循环，并使用 NumPy 的</st> `<st c="22365">where()</st>`<st
    c="22372">创建二进制变量，如果观测显示该类别，则放置值为</st> `<st c="22424">1</st>` <st c="22425">，否则为</st>
    `<st c="22469">0</st>` <st c="22470">。</st>
- en: <st c="22481">We discussed how to use</st> `<st c="22506">OneHotEncoder()</st>`
    <st c="22521">from</st> `<st c="22527">scikit-learn</st>` <st c="22539">and</st>
    `<st c="22544">feature-engine</st>` <st c="22558">in the</st> *<st c="22566">Creating
    binary variables through one-hot encoding</st>* <st c="22616">recipe.</st> <st
    c="22625">Here, I will only highlight the parameters needed to encode the most</st>
    <st c="22694">frequent categories.</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="22481">我们在</st>` `<st c="22506">scikit-learn</st>` `<st c="22521">和</st>`
    `<st c="22527">scikit-learn</st>` `<st c="22539">中的</st>` `<st c="22544">feature-engine</st>`
    `<st c="22558">的</st>` `<st c="22566">通过单热编码创建二元变量</st>` `<st c="22616">食谱中讨论了如何使用</st>`
    `<st c="22625">这里，我将只强调编码最频繁类别所需的参数。</st>`'
- en: <st c="22714">To encode</st> <st c="22724">frequent categories with</st> `<st
    c="22750">scikit-learn</st>`<st c="22762">, we set the</st> `<st c="22775">min_frequency</st>`
    <st c="22788">parameter to</st> `<st c="22802">39</st>`<st c="22804">. Hence,
    categories shown in less than</st> `<st c="22843">39</st>` <st c="22845">observations
    were grouped into an additional binary variable</st> <st c="22907">called</st>
    `<st c="22914">infrequent_sklearn</st>`<st c="22932">.</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="22714">使用</st>` `<st c="22724">scikit-learn</st>` `<st c="22750">来编码频繁类别，我们将</st>`
    `<st c="22775">min_frequency</st>` `<st c="22788">参数设置为</st>` `<st c="22802">39</st>`
    `<st c="22804">。因此，在少于</st>` `<st c="22843">39</st>` `<st c="22845">个观测值中显示的类别将被组合成一个额外的二元变量</st>`
    `<st c="22907">，称为</st>` `<st c="22914">infrequent_sklearn</st>` `<st c="22932">。</st>`'
- en: <st c="22933">To encode frequent categories with</st> `<st c="22969">feature-engine</st>`<st
    c="22983">, we set the</st> `<st c="22996">top_categories</st>` <st c="23010">parameter
    to</st> `<st c="23024">5</st>`<st c="23025">. Hence, the transformer created binary
    variables for the 5 most frequent categories only.</st> <st c="23116">Less frequent
    categories will s</st><st c="23147">how a</st> `<st c="23154">0</st>` <st c="23155">in
    all the</st> <st c="23167">binary variables.</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<st c="22933">特征工程</st>` `<st c="22969">feature-engine</st>` `<st c="22983">，我们将</st>`
    `<st c="22996">top_categories</st>` `<st c="23010">参数设置为</st>` `<st c="23024">5</st>`
    `<st c="23025">。因此，该转换器只为5个最频繁的类别创建了二元变量。</st>` `<st c="23116">较少出现的类别将在所有</st>`
    `<st c="23147">二元变量中显示为</st>` `<st c="23154">0</st>` `<st c="23155">。</st>`
- en: <st c="23184">There’s more...</st>
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="23184">还有更多...</st>`'
- en: <st c="23200">This recipe is based on the winning solution of the</st> **<st
    c="23253">Knowledge Discovery and Data</st>** <st c="23282">(</st>**<st c="23283">KDD</st>**<st
    c="23286">) 2009 mining cup,</st> *<st c="23306">Winning the KDD Cup Orange Challenge
    with Ensemble Selection</st>* <st c="23366">(http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf),
    where the author's limited one-hot encoding to the 10 most f</st><st c="23490">requent
    categories of</st> <st c="23513">each variable.</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="23200">这个食谱基于2009年知识发现与数据挖掘杯赛（</st>` **`<st c="23253">知识发现与数据挖掘</st>`**
    `<st c="23282">(</st>` **`<st c="23283">KDD</st>`** `<st c="23286">)` `<st c="23282">）的获奖解决方案，</st>`
    `<st c="23306">Winning the KDD Cup Orange Challenge with Ensemble Selection</st>`
    `<st c="23366">(http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf)，其中作者将单热编码限制为每个变量的10个最频繁类别。</st>`'
- en: <st c="23527">Replacing categories with counts or th</st><st c="23566">e frequency
    of observations</st>
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<st c="23527">用计数或观测值的频率替换类别</st>`'
- en: <st c="23594">In count</st> <st c="23604">with counts or frequency of observatio</st><st
    c="23642">ns” or frequency encoding, we replace the categories with the count
    or the fraction of observations showing that category.</st> <st c="23766">That
    is, if 10 out of 100 observations show the</st> `<st c="23814">blue</st>` <st
    c="23818">category for the</st> `<st c="23836">Color</st>` <st c="23841">variable,
    we would replace</st> `<st c="23869">blue</st>` <st c="23873">with</st> `<st c="23879">10</st>`
    <st c="23881">when doing count encoding, or with</st> `<st c="23917">0.1</st>`
    <st c="23920">if performing frequency encoding.</st> <st c="23955">These encoding
    methods are useful when there is a relationship between the category frequency
    and the target.</st> <st c="24065">For example, in sales, the frequency of a product
    may indicate</st> <st c="24128">its popularity.</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与“计数”或“观测值的计数或频率”编码相比，我们用该类别的计数或观测值中显示该类别的比例来替换类别。</st>` `<st c="23642">也就是说，如果有10个观测值中的100个显示</st>`
    `<st c="23814">蓝色</st>` `<st c="23818">类别对于</st>` `<st c="23836">颜色</st>` `<st
    c="23841">变量，我们在进行计数编码时将用</st>` `<st c="23869">蓝色</st>` `<st c="23873">替换为</st>`
    `<st c="23879">10</st>` `<st c="23881">，或者在进行频率编码时用</st>` `<st c="23917">0.1</st>`
    `<st c="23920">。</st>` `<st c="23955">这些编码方法在类别频率与目标之间存在关系时很有用。</st>` `<st c="24065">例如，在销售中，产品的频率可能表明</st>`
    `<st c="24128">其受欢迎程度。</st>`
- en: <st c="24143">Note</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="24143">注意</st>`'
- en: <st c="24148">If two different categories are present in the same number of
    observations, they will be replaced by the same value, which may lead to</st>
    <st c="24284">information loss.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24148">如果两个不同的类别在相同的观测数中存在，它们将被相同的值替换，这可能会导致</st> `<st c="24284">信息丢失</st>`。</st>
- en: <st c="24301">In this recipe, we will perform count and frequency enco</st><st
    c="24358">ding using</st> `<st c="24370">pandas</st>` <st c="24376">and</st> `<st
    c="24381">feature-engine</st>`<st c="24395">.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24301">在这个菜谱中，我们将使用</st> `<st c="24370">pandas</st>` `<st c="24376">和</st>
    `<st c="24381">feature-engine</st>` `<st c="24395">执行计数和频率编码。</st>
- en: <st c="24396">How to do it...</st>
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24396">如何做到这一点...</st>
- en: <st c="24412">We’ll start by encoding one variable with</st> `<st c="24455">pandas</st>`
    <st c="24461">and then we’ll automate the process</st> <st c="24498">with</st>
    `<st c="24503">feature-engine</st>`<st c="24517">:</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24412">我们将使用</st> `<st c="24455">pandas</st>` <st c="24461">对一个变量进行编码，然后我们将使用</st>
    `<st c="24498">feature-engine</st>`<st c="24517">来自动化这个过程：</st>
- en: <st c="24519">Let’s start with</st> <st c="24536">the imports:</st>
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24519">让我们从</st> `<st c="24536">进口</st>`开始：</st>
- en: '[PRE44]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="24679">Let’s load the Credit Approval dataset and divide it into train
    and</st> <st c="24748">test sets:</st>
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24679">让我们加载信用批准数据集并将其分为训练集和</st> `<st c="24748">测试集</st>`：</st>
- en: '[PRE45]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="24944">Let’s</st> <st c="24951">with counts or frequency of observations”
    capture the number of observations per category of the</st> `<st c="25048">A7</st>`
    <st c="25050">variable in</st> <st c="25063">a dictionary:</st>
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24944">让我们</st> `<st c="24951">使用计数或观测频率”来捕获</st> `<st c="25048">A7</st>`
    <st c="25050">变量</st> `<st c="25063">的每个类别的观测数</st>，并在一个字典中：</st>
- en: '[PRE46]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="25124">Note</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25124">注意</st>
- en: <st c="25129">To find the frequency instead,</st> <st c="25161">execute</st>
    `<st c="25169">X_train["A7"].value_counts(normalize=True).to_dict()</st>`<st c="25221">.</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25129">要找到频率而不是计数，</st> `<st c="25161">执行</st>` `<st c="25169">X_train["A7"].value_counts(normalize=True).to_dict()</st>`<st
    c="25221">。</st>
- en: <st c="25222">If we execute</st> `<st c="25237">print(counts)</st>`<st c="25250">,
    we’ll see the count of observations per category</st> <st c="25301">of</st> `<st
    c="25304">A7</st>`<st c="25306">:</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25222">如果我们执行</st> `<st c="25237">print(counts)</st>`<st c="25250">，我们将看到</st>
    `<st c="25304">A7</st>`<st c="25306">的每个类别的观测计数：</st>
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <st c="25403">Let’s replace the categories in</st> `<st c="25436">A7</st>` <st
    c="25438">with the counts in a copy of the</st> <st c="25472">data sets:</st>
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25403">让我们用</st> `<st c="25436">A7</st>` <st c="25438">中的计数来替换</st> `<st
    c="25472">数据集</st>`中的类别：</st>
- en: '[PRE48]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <st c="25636">Go ahead and inspect the data by executing</st> `<st c="25680">X_train_enc.head()</st>`
    <st c="25698">to corroborate that the categories have been replaced by</st> <st
    c="25756">the counts.</st>
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25636">继续执行</st> `<st c="25680">X_train_enc.head()</st>` <st c="25698">来验证类别已经被计数所替换：</st>
- en: <st c="25767">To apply this procedure to multiple variables, we can</st> <st
    c="25822">use</st> `<st c="25826">feature-engine</st>`<st c="25840">.</st>
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25767">要将此过程应用于多个变量，我们可以</st> `<st c="25822">使用</st>` `<st c="25826">feature-engine</st>`<st
    c="25840">。</st>
- en: <st c="25841">Let’s set up the encoder so that it encodes all categorical variables
    with the count</st> <st c="25927">of observations:</st>
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25841">让我们设置编码器，使其使用观测计数来编码所有分类变量：</st>
- en: '[PRE49]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <st c="26021">Note</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26021">注意</st>
- en: '`<st c="26026">CountFrequencyEncoder()</st>` <st c="26050">will automatically
    find and encode all categorical variables in the train set.</st> <st c="26130">To
    encode only a subset of the variables, pass the variable names in a list to the</st>
    `<st c="26213">variables</st>` <st c="26222">argument.</st> <st c="26233">To encode
    with the frequency instead,</st> <st c="26271">use</st> `<st c="26275">encoding_method="frequency"</st>`<st
    c="26302">.</st>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="26026">CountFrequencyEncoder()</st>` `<st c="26050">将自动找到并编码训练集中的所有分类变量。</st>
    `<st c="26130">要仅编码变量子集，请将变量名列表传递给</st>` `<st c="26213">variables</st>` `<st c="26222">参数。</st>
    `<st c="26233">要使用频率进行编码，请使用</st>` `<st c="26271">encoding_method="frequency"</st>`
    `<st c="26302">。</st>'
- en: <st c="26303">Let’s fit the</st> <st c="26317">encoder to the train set so that
    it stores the number of observations per category</st> <st c="26401">per variable:</st>
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26303">让我们将编码器拟合到训练集，以便它存储每个变量每个类别的观测数：</st>
- en: '[PRE50]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: <st c="26437">The encoder found the categorical variables automatically.</st>
    <st c="26497">Let’s check</st> <st c="26509">them out:</st>
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26437">编码器自动找到了分类变量。</st> `<st c="26497">让我们检查</st>` `<st c="26509">它们：</st>
- en: '[PRE51]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <st c="26539">The previous command returns the names of the categorical variables
    in the</st> <st c="26615">train set:</st>
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="26539">之前的命令返回了训练集中分类变量的名称：</st>`'
- en: '[PRE52]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <st c="26683">Let’s print the count of observations per category</st> <st c="26735">per
    variable:</st>
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="26683">让我们按变量打印每个类别的观测数：</st>`'
- en: '[PRE53]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <st c="26772">The previous attribute stores the mappings that will be used to
    replace</st> <st c="26845">the categories:</st>
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="26772">之前的属性存储了将要用于替换类别的映射：</st>`'
- en: '![Figure 2.7 – Dictionary containing the number of observations per category,
    for each variable; these values will be used to encode the categorical variables](img/B22396_02_07.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 包含每个变量的每个类别的观测数字典；这些值将用于编码分类变量](img/B22396_02_07.jpg)'
- en: <st c="27366">Figure 2.7 – Dictionary containing the number of observations
    per category, for each variable; these values will be used to encode the categorical
    variables</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27366">图 2.7 – 包含每个变量的每个类别的观测数字典；这些值将用于编码分类变量</st>`'
- en: <st c="27522">Finally, let’s</st> <st c="27538">with counts or frequency of
    observations” replace the categories with counts in the train and</st> <st c="27632">test
    sets:</st>
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="27522">最后，让我们用“每个类别的观测数或频率”替换训练集和测试集中的类别：</st>`'
- en: '[PRE54]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: <st c="27726">Check out the result by executing</st> `<st c="27761">X_train_enc.head()</st>`<st
    c="27779">. The encoder returns</st> `<st c="27801">pandas</st>` <st c="27807">DataFrames
    with the strings of the categorical variables replaced with the counts of observations,
    leaving the variables r</st><st c="27930">eady to use in machine</st> <st c="27954">learning
    models.</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27726">通过执行 `<st c="27761">X_train_enc.head()</st>`<st c="27779"> 来查看结果。编码器返回了
    `<st c="27801">pandas</st>` 数据框，其中分类变量的字符串被替换为观测数的计数，使得变量准备好在机器学习模型中使用。</st>`'
- en: <st c="27970">How it works...</st>
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="27970">工作原理...</st>`'
- en: <st c="27986">In this recipe, we replaced categories with the count of observations
    using</st> `<st c="28063">pandas</st>` <st c="28069">and</st> `<st c="28074">feature-engine</st>`<st
    c="28088">.</st>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27986">在这个配方中，我们使用 `<st c="28063">pandas</st>` 和 `<st c="28074">feature-engine</st>`
    将类别替换为观测数。</st>`'
- en: <st c="28089">Using</st> `<st c="28096">pandas</st>`<st c="28102">’</st> `<st
    c="28105">value_counts()</st>`<st c="28119">, we determined the number of observations
    per category of the</st> `<st c="28182">A7</st>` <st c="28184">variable, and with</st>
    `<st c="28204">pandas</st>`<st c="28210">’</st> `<st c="28213">to_dict()</st>`<st
    c="28222">, we captured these values in a</st> <st c="28254">with counts or frequency
    of observations” dictionary, where each key was a unique category, and each value
    the number of observations for that category.</st> <st c="28407">With</st> `<st
    c="28412">pandas</st>`<st c="28418">’</st> `<st c="28421">map()</st>` <st c="28426">and
    using this dictionary, we replaced the categories with the observation counts
    in both the train and</st> <st c="28531">test sets.</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<st c="28089">pandas</st>` 的 `<st c="28105">value_counts()</st>`，我们确定了变量
    `<st c="28182">A7</st>` 的每个类别的观测数，并且使用 `<st c="28204">pandas</st>` 的 `<st c="28213">to_dict()</st>`，我们将这些值捕获在一个“每个类别的观测数或频率”的字典中，其中每个键是一个唯一的类别，每个值是该类别的观测数。</st>
    使用 `<st c="28412">pandas</st>` 的 `<st c="28421">map()</st>` 和这个字典，我们在训练集和测试集中将类别替换为观测数。
- en: <st c="28541">Note</st>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="28541">注意</st>`'
- en: <st c="28546">The count of observations for the encoding should be obtained
    from the train set to avoid data leakage.</st> <st c="28651">Note that new categories
    in the test set will not have a corresponding mapping and hence will be replaced
    by</st> `<st c="28760">nan</st>`<st c="28763">. To avoid this, use f</st>`<st
    c="28785">eature-engine</st>`<st c="28799">. Alternatively, you can replace the</st>
    `<st c="28836">nan</st>` <st c="28839">with</st> `<st c="28845">0</st>`<st c="28846">.</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="28546">编码的观测数应该从训练集中获得，以避免数据泄露。</st> 注意，测试集中的新类别将没有相应的映射，因此将被替换为 `<st
    c="28760">nan</st>`<st c="28763">。为了避免这种情况，请使用 `<st c="28785">feature-engine</st>`<st
    c="28799">。或者，您可以将 `<st c="28836">nan</st>` <st c="28839">替换为 `<st c="28845">0</st>`<st
    c="28846">。</st>`'
- en: <st c="28847">To perform count encoding with</st> `<st c="28879">feature-engine</st>`<st
    c="28893">, we used</st> `<st c="28903">CountFrequencyEncoder()</st>` <st c="28926">and
    set</st> `<st c="28935">encoding_method</st>` <st c="28950">to</st> `<st c="28954">'count'</st>`<st
    c="28961">. We left the</st> `<st c="28975">variables</st>` <st c="28984">argument
    set to</st> `<st c="29001">None</st>` <st c="29005">so that the encoder automatically
    finds all the categorical variables in the dataset.</st> <st c="29092">With</st>
    `<st c="29097">fit()</st>`<st c="29102">, the transformer found the categorical
    variables and stored the observation counts per category in the</st> `<st c="29206">encoder_dict_</st>`
    <st c="29219">attribute.</st> <st c="29231">With</st> `<st c="29236">transform()</st>`<st
    c="29247">, the transformer replaced the categories with the counts, returning
    a</st> `<st c="29318">pandas</st>` <st c="29324">DataFrame.</st>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<st c="28879">feature-engine</st>` 进行计数编码时，我们使用了 `<st c="28903">CountFrequencyEncoder()</st>`
    并将 `<st c="28935">encoding_method</st>` 设置为 `<st c="28954">'count'</st>`。我们将 `<st
    c="28975">variables</st>` 参数设置为 `<st c="29001">None</st>`，以便编码器自动找到数据集中的所有类别变量。使用
    `<st c="29097">fit()</st>`，转换器找到了类别变量，并将每个类别的观测计数存储在 `<st c="29206">encoder_dict_</st>`
    属性中。使用 `<st c="29236">transform()</st>`，转换器将类别替换为计数，返回一个 `<st c="29318">pandas</st>`
    `<st c="29324">DataFrame</st>`。
- en: <st c="29335">Note</st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: <st c="29340">If there are categories in the test set that were not present
    in the train set, the encoder will raise an error by default.</st> <st c="29465">You
    can make it ignore them, in which case they will appear as</st> `<st c="29528">nan</st>`<st
    c="29531">, or encode them</st> <st c="29548">as</st> `<st c="29551">0</st>`<st
    c="29552">.</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试集中有在训练集中不存在的类别，编码器默认会引发错误。您可以使其忽略它们，在这种情况下，它们将显示为 `<st c="29528">nan</st>`，或者将它们编码为
    `<st c="29551">0</st>`。
- en: <st c="29553">See also</st>
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: <st c="29562">You can also carry out count and frequency encoding with the Python
    library Category</st> <st c="29648">Encoders:</st> [<st c="29658">https://contrib.scikit-learn.org/category_encoders/count.html</st>](https://contrib.scikit-learn.org/category_encoders/count.html)<st
    c="29719">.</st>
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 Python 库 Category Encoders 执行计数和频率编码：[https://contrib.scikit-learn.org/category_encoders/count.html](https://contrib.scikit-learn.org/category_encoders/count.html)。
- en: <st c="29720">For some useful applications of count encoding, check out this</st>
    <st c="29784">article:</st> [<st c="29793">https://</st><st c="29801">letsdatascience.com/frequency-encoding/</st>](https://letsdatascience.com/frequency-encoding/)<st
    c="29841">.</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看计数编码的一些有用应用，请参阅这篇文章：[https://](https://letsdatascience.com/frequency-encoding/)。
- en: <st c="29842">Replacing categories with ordinal numbers</st>
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换类别为序数
- en: <st c="29884">Ordinal encoding</st> <st c="29902">consists of replacing the
    categories with digits from</st> *<st c="29956">1</st>* <st c="29957">to</st>
    *<st c="29961">k</st>* <st c="29962">(or</st> *<st c="29967">0</st>* <st c="29968">to</st>
    *<st c="29972">k-1</st>*<st c="29975">, depending on the implementation), where</st>
    *<st c="30017">k</st>* <st c="30018">is the number of distinct categories of the
    variable.</st> <st c="30073">The numbers are assigned arbitrarily.</st> <st c="30111">Ordinal
    encoding is better suited for non-linear machine learning models, which can navigate
    through arbitrarily assigned numbers to find patterns that relate to</st> <st
    c="30273">the target.</st>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 序数编码包括将类别替换为从 *<st c="29956">1</st>* 到 *<st c="29961">k</st>* 的数字（或 *<st c="29967">0</st>*
    到 *<st c="29972">k-1</st>*，具体取决于实现），其中 *<st c="30017">k</st>* 是变量的不同类别数量。这些数字是任意分配的。序数编码更适合非线性机器学习模型，这些模型可以通过任意分配的数字来寻找与目标相关的模式。
- en: <st c="30284">In this recipe, we will</st> <st c="30309">perform ordinal encoding
    using</st> `<st c="30339">pandas</st>`<st c="30346">,</st> `<st c="30348">scikit-learn</st>`<st
    c="30360">,</st> <st c="30362">and</st> `<st c="30366">feature-engine</st>`<st
    c="30380">.</st>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 `<st c="30339">pandas</st>`、`<st c="30348">scikit-learn</st>`、`<st
    c="30360">and</st>` `<st c="30366">feature-engine</st>` 进行序数编码。
- en: <st c="30381">How to do it...</st>
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: <st c="30397">First, let’s make the import and prepare</st> <st c="30439">the
    dataset:</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30397">首先，让我们导入并准备</st> <st c="30439">数据集：</st>
- en: <st c="30451">Import</st> `<st c="30459">pandas</st>` <st c="30465">and the
    data</st> <st c="30479">split function:</st>
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30451">导入</st> `<st c="30459">pandas</st>` <st c="30465">和数据</st> <st
    c="30479">分割函数：</st>
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <st c="30567">Let’s load the Credit Approval dataset and divide it into train
    and</st> <st c="30636">test sets:</st>
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30567">让我们加载Credit Approval数据集并将其分为训练集和</st> <st c="30636">测试集：</st>
- en: '[PRE56]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <st c="30832">To</st> <st c="30836">encode the</st> `<st c="30847">A7</st>`
    <st c="30849">variable, let’s make a dictionary of</st> <st c="30887">category-to-integer
    pairs:</st>
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30832">为了</st> <st c="30836">编码</st> `<st c="30847">A7</st>` <st c="30849">变量，让我们创建一个类别到整数的字典对：</st>
    <st c="30887">：</st>
- en: '[PRE57]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <st c="30989">If we execute</st> `<st c="31004">print(ordinal_mapping)</st>`<st
    c="31026">, we will see the digits that will replace</st> <st c="31069">each category:</st>
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30989">如果我们执行</st> `<st c="31004">print(ordinal_mapping)</st>`<st c="31026">，我们将看到将替换每个类别的数字：</st>
- en: '[PRE58]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <st c="31173">Now, let’s</st> <st c="31185">replace the categories in a copy
    of</st> <st c="31221">the DataFrames:</st>
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31173">现在，让我们在DataFrame的副本中替换类别：</st> <st c="31221">：</st>
- en: '[PRE59]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <st c="31408">Go ahead and execute</st> `<st c="31430">print(X_train["A7"].head())</st>`
    <st c="31457">to see the result of the</st> <st c="31483">previous operation.</st>
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31408">执行</st> `<st c="31430">print(X_train["A7"].head())</st>` <st c="31457">以查看上一操作的</st>
    <st c="31483">结果。</st>
- en: <st c="31502">Next, we’ll carry out ordinal encoding</st> <st c="31542">using</st>
    `<st c="31548">scikit-learn</st>`<st c="31560">.</st>
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31502">接下来，我们将使用</st> <st c="31542">scikit-learn</st>`<st c="31560">执行顺序编码：</st>
- en: <st c="31561">Let’s import the</st> <st c="31579">required classes:</st>
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31561">让我们导入所需的</st> <st c="31579">类：</st>
- en: '[PRE60]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <st c="31691">Note</st>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31691">注意</st>
- en: <st c="31696">Do not confuse</st> `<st c="31712">OrdinalEncoder()</st>` <st
    c="31728">with</st> `<st c="31734">LabelEncoder()</st>` <st c="31748">from</st>
    `<st c="31754">scikit-learn</st>`<st c="31766">. The former is intended to encode
    predictive features, whereas the latter is intended to modify the</st> <st c="31867">target
    variable.</st>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31696">不要将</st> `<st c="31712">OrdinalEncoder()</st>` <st c="31728">与</st>
    `<st c="31734">LabelEncoder()</st>` <st c="31748">从</st> `<st c="31754">scikit-learn</st>`<st
    c="31766">混淆。前者旨在编码预测特征，而后者旨在修改</st> <st c="31867">目标变量。</st>
- en: <st c="31883">Let’s set</st> <st c="31893">up</st> <st c="31897">the encoder:</st>
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31883">让我们设置</st> <st c="31893">编码器：</st>
- en: '[PRE61]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: <st c="31932">Let’s make a list containing the categorical variables</st> <st
    c="31988">to encode:</st>
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31932">让我们创建一个包含要编码的分类变量的列表：</st> <st c="31988">：</st>
- en: '[PRE62]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <st c="32062">Let’s restrict</st> <st c="32078">the encoding to the</st> <st
    c="32098">categorical variables:</st>
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32062">让我们将编码限制在</st> <st c="32078">分类变量</st> <st c="32098">上：</st>
- en: '[PRE63]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: <st c="32264">Note</st>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32264">注意</st>
- en: <st c="32269">Remember to set</st> `<st c="32286">remainder</st>` <st c="32295">to</st>
    `<st c="32299">"passthrough"</st>` <st c="32312">to make the</st> `<st c="32325">ColumnTransformer()</st>`
    <st c="32344">return the un-transformed variables</st> <st c="32381">as well.</st>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32269">请记住将</st> `<st c="32286">remainder</st>` <st c="32295">设置为</st>
    `<st c="32299">"passthrough"</st>` <st c="32312">，以便</st> `<st c="32325">ColumnTransformer()</st>`
    <st c="32344">返回未转换的变量。</st>
- en: <st c="32389">Let’s fit the encoder to the train set so that it creates and
    stores representations of categories</st> <st c="32489">to digits:</st>
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32389">让我们将编码器拟合到训练集，以便它创建并存储类别到数字的表示：</st> <st c="32489">：</st>
- en: '[PRE64]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: <st c="32515">Note</st>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32515">注意</st>
- en: <st c="32520">By executing</st> `<st c="32534">ct.named_transformers_["encoder"].categories_</st>`<st
    c="32579">, you can visualize the unique categories</st> <st c="32621">per variable.</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32520">通过执行</st> `<st c="32534">ct.named_transformers_["encoder"].categories_</st>`<st
    c="32579">，您可以可视化每个变量的唯一类别。</st>
- en: <st c="32634">Now, let’s encode the categorical variables in the train and</st>
    <st c="32696">test sets:</st>
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32634">现在，让我们对训练集和</st> <st c="32696">测试集中的分类变量进行编码：</st>
- en: '[PRE65]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: <st c="32776">Go ahead and execute</st> `<st c="32798">X_train_enc.head()</st>`
    <st c="32816">to check out the</st> <st c="32834">resulting DataFrame.</st>
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32776">执行</st> `<st c="32798">X_train_enc.head()</st>` <st c="32816">以检查生成的</st>
    <st c="32834">DataFrame。</st>
- en: <st c="32854">Note</st>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32854">注意</st>
- en: '`<st c="32859">ColumnTransformer()</st>` <st c="32879">will mark the encoded
    variables by appending</st> `<st c="32925">encoder</st>` <st c="32932">to the
    variable name.</st> <st c="32955">The variables that were not modified show the</st>
    `<st c="33001">remainder</st>` <st c="33010">prefix.</st>'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="32859">ColumnTransformer()</st>` <st c="32879">将通过在变量名后附加`<st c="32925">encoder</st>`
    <st c="32932">来标记编码变量。</st> <st c="32955">未修改的变量显示`<st c="33001">remainder</st>`
    <st c="33010">前缀。</st>'
- en: <st c="33018">Now, let’s do</st> <st c="33032">ordinal encoding</st> <st c="33050">with</st>
    `<st c="33055">feature-engine</st>`<st c="33069">.</st>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`<st c="33018">。</st> <st c="33032">ordinal encoding</st>` <st c="33050">与`<st
    c="33055">feature-engine</st>`<st c="33069">。</st>
- en: <st c="33070">Let’s import</st> <st c="33084">the encoder:</st>
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入编码器：<st c="33070">。</st> <st c="33084">。</st>
- en: '[PRE66]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: <st c="33147">Let’s set up the encoder so that it replaces categories with arbitrary
    integers in the categorical variables specified in</st> *<st c="33270">Step 7</st>*<st
    c="33276">:</st>
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置编码器，使其在*<st c="33270">步骤7</st>*<st c="33276">中指定的分类变量中用任意整数替换类别：<st c="33147">。</st>
- en: '[PRE67]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: <st c="33351">Note</st>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33351">注意</st>
- en: '`<st c="33356">feature-engine</st>`<st c="33371">’s</st> `<st c="33375">OrdinalEncoder()</st>`
    <st c="33391">automatically finds and encodes all categorical variables if the</st>
    `<st c="33457">variables</st>` <st c="33466">parameter is</st> `<st c="33480">None</st>`<st
    c="33484">. Alternatively, it will encode the variables indicated in the list.</st>
    <st c="33553">In addition, it can assign the integers according to the target
    mean value (see the</st> *<st c="33637">Performing ordinal encoding based on the
    target</st>* *<st c="33685">value</st>* <st c="33690">recipe).</st>'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="33356">feature-engine</st>`<st c="33371">’s</st> `<st c="33375">OrdinalEncoder()</st>`
    <st c="33391">会自动找到并编码所有分类变量，如果<st c="33457">变量</st> <st c="33466">参数是`<st c="33480">None</st>`<st
    c="33484">。或者，它将编码列表中指定的变量。</st> <st c="33553">此外，它可以根据目标均值值分配整数（参见*<st c="33637">基于目标值进行序数编码</st>*
    *<st c="33685">的配方）。</st>'
- en: <st c="33699">Let’s fit the</st> <st c="33713">encoder to the train set so</st>
    <st c="33742">that it learns and stores the</st> <st c="33772">category-to-integer
    mappings:</st>
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将编码器拟合到训练集中，以便它学习并存储类别到整数的映射：<st c="33699">。</st> <st c="33713">。</st> <st
    c="33742">。</st> <st c="33772">。</st>
- en: '[PRE68]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <st c="33818">Note</st>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="33818">注意</st>`'
- en: <st c="33823">The category to integer mappings are stored in the</st> `<st c="33875">encoder_dict_</st>`
    <st c="33888">attribute and can be accessed by</st> <st c="33922">executing</st>
    `<st c="33932">enc.encoder_dict_</st>`<st c="33949">.</st>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 分类到整数的映射存储在`<st c="33875">encoder_dict_</st>` <st c="33888">属性中，可以通过执行`<st c="33922">enc.encoder_dict_</st>`<st
    c="33949">来访问。</st>
- en: <st c="33950">Finally, let’s encode the categorical variables in the train and</st>
    <st c="34016">test sets:</st>
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将训练集和测试集中的分类变量进行编码：<st c="33950">。</st> <st c="34016">。</st>
- en: '[PRE69]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`<st c="34098">feature-engine</st>` <st c="34113">returns</st> `<st c="34122">pandas</st>`
    <st c="34128">DataFrames where the values of the original variables are replaced
    with numbers, leaving the</st> <st c="34222">DataFrame ready to use in machine</st>
    <st c="34256">learning models.</st>'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="34098">feature-engine</st>` <st c="34113">返回`<st c="34122">pandas</st>`
    <st c="34128">DataFrames，其中原始变量的值被数字替换，使DataFrame准备好在机器学习模型中使用。</st>'
- en: <st c="34272">How it works...</st>
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="34272">它是如何工作的...</st>
- en: <st c="34288">In this recipe, we replaced categories with integers</st> <st
    c="34342">assigned arbitrarily.</st>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将类别替换为任意分配的整数<st c="34288">。</st> <st c="34342">。</st>
- en: <st c="34363">We used</st> `<st c="34372">pandas</st>`<st c="34378">’</st> `<st
    c="34381">unique()</st>` <st c="34389">to find the unique categories of the</st>
    `<st c="34427">A7</st>` <st c="34429">variable.</st> <st c="34440">Next, we created
    a dictionary of category-to-integer and passed it to</st> `<st c="34510">pandas</st>`<st
    c="34516">’</st> `<st c="34519">map()</st>` <st c="34524">to replace the strings
    in</st> `<st c="34551">A7</st>` <st c="34553">with</st> <st c="34559">the integers.</st>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了<st c="34363">。</st> `<st c="34372">pandas</st>`<st c="34378">’</st> `<st
    c="34381">unique()</st>` <st c="34389">来找到变量<st c="34427">A7</st> <st c="34429">的唯一类别。</st>
    <st c="34440">接下来，我们创建了一个类别到整数的字典，并将其传递给<st c="34510">pandas</st>`<st c="34516">’</st>
    `<st c="34519">map()</st>` <st c="34524">，以将<st c="34551">A7</st> <st c="34553">中的字符串替换为整数。</st>
- en: <st c="34572">Next, we carried out ordinal encoding using</st> `<st c="34617">scikit-learn</st>`<st
    c="34629">’s</st> `<st c="34633">OrdinalEncoder()</st>` <st c="34650">and used</st>
    `<st c="34659">ColumnTransformer()</st>` <st c="34678">to restrict the encoding
    to categorical variables.</st> <st c="34730">With</st> `<st c="34735">fit()</st>`<st
    c="34740">, the transformer created the category-to-integer mappings based on
    the categories in the train set.</st> <st c="34841">With</st> `<st c="34846">transform()</st>`<st
    c="34857">, the categories were replaced with integers.</st> <st c="34903">By
    setting the</st> `<st c="34918">remainder</st>` <st c="34927">parameter to</st>
    `<st c="34941">passthrough</st>`<st c="34952">, we made</st> `<st c="34962">ColumnTransformer()</st>`
    <st c="34981">concatenate the variables that are not encoded at the back of the</st>
    <st c="35048">encoded features.</st>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="34572">接下来，我们使用</st>` `<st c="34617">scikit-learn</st>` `<st c="34629">的</st>`
    `<st c="34633">OrdinalEncoder()</st>` `<st c="34650">进行了序数编码，并使用</st>` `<st c="34659">ColumnTransformer()</st>`
    `<st c="34678">将编码限制为分类变量。</st>` `<st c="34730">使用</st>` `<st c="34735">fit()</st>`
    `<st c="34740">，转换器根据训练集中的类别创建了类别到整数的映射。</st>` `<st c="34841">使用</st>` `<st c="34846">transform()</st>`
    `<st c="34857">，类别被替换为整数。</st>` `<st c="34903">通过将</st>` `<st c="34918">remainder</st>`
    `<st c="34927">参数设置为</st>` `<st c="34941">passthrough</st>` `<st c="34952">，我们使</st>`
    `<st c="34962">ColumnTransformer()</st>` `<st c="34981">将未编码的变量连接到编码特征之后。</st>`'
- en: <st c="35065">To perform ordinal encoding with</st> `<st c="35099">feature-engine</st>`<st
    c="35113">, we used</st> `<st c="35123">OrdinalEncoder()</st>`<st c="35139">,
    indicating that the integers should be assigned arbitrarily through</st> `<st
    c="35209">encoding_method</st>`<st c="35224">, and passed a list with the variables
    to encode in the</st> `<st c="35280">variables</st>` <st c="35289">argument.</st>
    <st c="35300">With</st> `<st c="35305">fit()</st>`<st c="35310">, the encoder
    assigned integers to each variable’s categories, which</st> <st c="35379">were
    stored in the</st> `<st c="35398">encoder_dict_</st>` <st c="35411">attribute.</st>
    <st c="35423">These</st> <st c="35428">mappings were then used by the</st> `<st
    c="35460">transform()</st>` <st c="35471">method to replace the categories in
    the train and test sets,</st> <st c="35533">returning DataFrames.</st>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<st c="35065">feature-engine</st>`进行序数编码时，我们使用了`<st c="35123">OrdinalEncoder()</st>`，表示整数应通过`<st
    c="35209">encoding_method</st>`任意分配，并在`<st c="35280">variables</st>` `<st c="35289">参数</st>`中传递一个包含要编码变量的列表。<st
    c="35300">使用</st> `<st c="35305">fit()</st>`<st c="35310">，编码器将整数分配给每个变量的类别，这些类别存储在`<st
    c="35398">encoder_dict_</st>` `<st c="35411">属性</st>`中。<st c="35423">这些</st> `<st
    c="35428">映射</st>`随后被`<st c="35460">transform()</st>` `<st c="35471">方法</st>`使用，以替换训练集和测试集中的类别，并返回DataFrames。
- en: <st c="35554">Note</st>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="35554">注意</st>`'
- en: <st c="35559">When a category in the test set is not present in the training
    set, it will not have a mapping to a digit.</st> `<st c="35667">OrdinalEncoder()</st>`
    <st c="35683">from</st> `<st c="35689">scikit-learn</st>` <st c="35701">and</st>
    `<st c="35706">feature-engine</st>` <st c="35720">will raise an error by default.</st>
    <st c="35753">However, they have the option to replace unseen categories with
    a user-defined value or</st> `<st c="35841">-</st>``<st c="35842">1</st>`<st c="35843">,
    respectively.</st>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="35559">当测试集中的类别不在训练集中时，它将没有映射到数字。</st>` `<st c="35667">OrdinalEncoder()</st>`
    `<st c="35683">来自</st>` `<st c="35689">scikit-learn</st>` `<st c="35701">和</st>`
    `<st c="35706">feature-engine</st>` `<st c="35720">默认情况下会引发错误。</st>` `<st c="35753">然而，它们可以选择用用户定义的值或`<st
    c="35841">-</st>` `<st c="35842">1</st>` `<st c="35843">分别替换未看到的类别。</st>`'
- en: '`<st c="35858">scikit-learn</st>`<st c="35871">’s</st> `<st c="35875">OrdinalEncoder()</st>`
    <st c="35891">can restrict the encoding to those categories with a minimum frequency.</st>
    `<st c="35964">feature-engine</st>`<st c="35978">’s</st> `<st c="35982">OrdinalEncoder()</st>`
    <st c="35998">can assign the numbers based on the target</st> <st c="36041">mean
    value, as we will see in the</st> <st c="36076">following recipe.</st>'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="35858">scikit-learn</st>` `<st c="35871">的</st>` `<st c="35875">OrdinalEncoder()</st>`
    `<st c="35891">可以限制编码到具有最小频率的类别。</st>` `<st c="35964">feature-engine</st>` `<st
    c="35978">的</st>` `<st c="35982">OrdinalEncoder()</st>` `<st c="35998">可以根据目标`<st
    c="36041">平均值</st>`分配数字，正如我们将在下面的食谱中看到的那样。'
- en: <st c="36093">There’s more...</st>
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="36093">还有更多...</st>`'
- en: <st c="36109">You can also carry out ordinal encoding with</st> `<st c="36155">OrdinalEncoder()</st>`
    <st c="36171">from Category Encoders.</st> <st c="36196">Check it out</st> <st
    c="36209">at</st> [<st c="36212">http://cont</st><st c="36223">rib.scikit-l</st><st
    c="36236">earn.org/category_encoders/ordinal.html</st>](http://contrib.scikit-learn.org/category_encoders/ordinal.html)<st
    c="36276">.</st>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用来自 Category Encoders 的 `<st c="36155">OrdinalEncoder()</st>` <st c="36171">执行序数编码。查看[这里](http://contrib.scikit-learn.org/category_encoders/ordinal.html)<st
    c="36276">。</st>
- en: <st c="36277">Performing ordinal encoding based on the target value</st>
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于目标值执行序数编码
- en: <st c="36331">In the previous</st> <st c="36347">recipe, we replaced categories
    with integers, which were assigned arbitrarily.</st> <st c="36427">We can also
    assign integers to the categories given the target values.</st> <st c="36498">To
    do this, first, we calculate the mean value of the target per category.</st> <st
    c="36573">Next, we order the categories from the one with the lowest to the one
    with the highest target mean value.</st> <st c="36679">Finally, we assign digits
    to the ordered categories, starting with</st> *<st c="36746">0</st>* <st c="36747">to
    the first category up to</st> *<st c="36776">k-1</st>* <st c="36779">to the last
    category, where</st> *<st c="36808">k</st>* <st c="36809">is the number of</st>
    <st c="36827">distinct categories.</st>
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个<st c="36331">配方中，我们将类别替换为任意分配的整数。我们也可以根据目标值给类别分配整数。为了做到这一点，首先，我们计算每个类别的目标平均值。接下来，我们按从最低到最高的目标平均值对类别进行排序。最后，我们将数字分配给有序的类别，从*<st
    c="36746">0</st>* <st c="36747">到第一个类别，到*<st c="36776">k-1</st>* <st c="36779">到最后一个类别，其中*<st
    c="36808">k</st>* <st c="36809">是不同类别的数量。</st>
- en: <st c="36847">This encoding method creates a monotonic relationship between
    the categorical variable and the response and therefore makes the variables more
    adequate for use in</st> <st c="37011">linear models.</st>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码方法在分类变量和响应之间创建了一个单调关系，因此使变量更适合用于线性模型。
- en: <st c="37025">In this recipe, we will</st> <st c="37049">encode categories while
    follo</st><st c="37079">wing the target value using</st> `<st c="37108">pandas</st>`
    <st c="37114">and</st> `<st c="37119">feature-engine</st>`<st c="37133">.</st>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用 `<st c="37108">pandas</st>` <st c="37114">和</st> `<st c="37119">feature-engine</st>`<st
    c="37133">来编码类别，同时遵循目标值。
- en: <st c="37134">How to do it...</st>
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: <st c="37150">First, let’s import the necessary Python libraries and get the</st>
    <st c="37214">dataset ready:</st>
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入必要的 Python 库并准备好数据集：
- en: <st c="37228">Import the required Python libraries, functions,</st> <st c="37278">and
    classes:</st>
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的 Python 库、函数和类：
- en: '[PRE70]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: <st c="37395">Let’s load the Credit Approval dataset and divide it into train
    and</st> <st c="37464">test sets:</st>
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载 Credit Approval 数据集并将其分为训练集和测试集：
- en: '[PRE71]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: <st c="37660">Let’s determine the mean target value per category in</st> `<st
    c="37715">A7</st>`<st c="37717">, then sort the categories from that with the
    lowest to that with the highest</st> <st c="37795">target value:</st>
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `<st c="37715">A7</st>`<st c="37717">中确定每个类别的平均目标值，然后按从最低到最高的目标值对类别进行排序：
- en: '[PRE72]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <st c="37860">The following is the output of the</st> <st c="37896">preceding
    command:</st>
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是在先前的命令的输出：
- en: '[PRE73]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: <st c="38065">Now, let’s</st> <st c="38077">repeat the computation in</st> *<st
    c="38103">Step 3</st>*<st c="38109">, but this time, let’s retain the ordered</st>
    <st c="38151">category names:</st>
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重复在*<st c="38103">步骤 3</st>*<st c="38109">中的计算，但这次，让我们保留有序的<st c="38151">类别名称：</st>
- en: '[PRE74]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: <st c="38242">To display the output of the preceding command, we can execute</st>
    `<st c="38306">print(ordered_labels)</st>`<st c="38327">:</st> `<st c="38330">Index(['o',
    'ff', 'j', 'dd', 'v', 'bb', 'h', 'n', 'z', 'Missing'],</st>` `<st c="38397">dtype='object',
    name='A7')</st>`<st c="38423">.</st>
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要显示先前的命令的输出，我们可以执行 `<st c="38306">print(ordered_labels)</st>`<st c="38327">：</st>
    `<st c="38330">Index(['o', 'ff', 'j', 'dd', 'v', 'bb', 'h', 'n', 'z', 'Missing'],</st>`
    `<st c="38397">dtype='object', name='A7')</st>`<st c="38423">。</st>
- en: <st c="38424">Let’s create a dictionary of category-to-integer pairs, using
    the ordered list we created in</st> *<st c="38518">Step 4</st>*<st c="38524">:</st>
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38424">让我们创建一个类别到整数的字典，使用我们在*<st c="38518">步骤 4</st>*<st c="38524">中创建的有序列表：</st>
- en: '[PRE75]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: <st c="38594">We can visualize the result of the preceding code by</st> <st
    c="38648">executing</st> `<st c="38658">print(ordinal_mapping)</st>`<st c="38680">:</st>
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38594">我们可以通过执行</st> <st c="38648">print(ordinal_mapping)</st>`<st c="38680">来可视化前面代码的结果：</st>
- en: '[PRE76]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: X_train_enc = X_train.copy()
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_train_enc = X_train.copy()
- en: X_test_enc = X_test.copy()
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_test_enc = X_test.copy()
- en: X_train_enc["A7"] = X_train_enc["A7"].map(
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_train_enc["A7"] = X_train_enc["A7"].map(
- en: ordinal_mapping)
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ordinal_mapping)
- en: X_test_enc["A7"] = X_test_enc["A7"].map(
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_test_enc["A7"] = X_test_enc["A7"].map(
- en: ordinal_mapping)
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ordinal_mapping)
- en: '[PRE77]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: <st c="39050">Note</st>
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39050">注意</st>
- en: <st c="39055">If the test set contains a category that is not present in the
    train set, the preceding code will</st> <st c="39154">introduce</st> `<st c="39164">np.nan</st>`<st
    c="39170">.</st>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39055">如果测试集包含训练集中不存在的类别，前面的代码将</st> <st c="39154">引入</st> `<st c="39164">np.nan</st>`<st
    c="39170">。</st>
- en: <st c="39171">To visualize the effect of this encoding, let’s plot the relationship
    of the categories of the</st> `<st c="39267">A7</st>` <st c="39269">variable with
    the target before and after</st> <st c="39312">the encoding.</st>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39171">为了可视化这种编码的效果，让我们绘制编码前后</st> `<st c="39267">A7</st>` <st c="39269">变量类别与目标之间的关系。</st>
- en: <st c="39325">Let’s plot the mean target response per category of the</st> `<st
    c="39382">A7</st>` <st c="39384">variable:</st>
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39325">让我们绘制</st> `<st c="39382">A7</st>` <st c="39384">变量每个类别的均值目标响应：</st>
- en: '[PRE78]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: <st c="39531">We can see the non-monotonic relationship between</st> <st c="39581">categories
    of</st> `<st c="39596">A7</st>` <st c="39598">and the target in the</st> <st c="39621">following
    plot:</st>
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39531">我们可以从以下图中看到</st> `<st c="39596">A7</st>` <st c="39598">类别与目标之间的非单调关系：</st>
- en: '![Figure 2.8 – Mean target value per category of A7 before the encoding](img/B22396_02_08.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 编码前 A7 类别每类的均值目标值。](img/B22396_02_08.jpg)'
- en: <st c="39747">Figure 2.8 – Mean target value per category of A7 before the encoding</st>
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39747">图 2.8 – 编码前 A7 类别每类的均值目标值。</st>
- en: <st c="39816">Let’s plot</st> <st c="39827">the mean target value per category
    in the</st> <st c="39870">encoded variable:</st>
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39816">让我们绘制编码变量中每个类别的均值目标值：</st>
- en: '[PRE79]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: <st c="40028">The encoded variable shows a monotonic relationship with the target
    – the higher the mean targe</st><st c="40124">t value, the higher the digit assigned
    to</st> <st c="40167">the category:</st>
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40028">编码变量与目标之间存在单调关系——目标均值目标值越高，分配给</st><st c="40124">的类别</st> <st
    c="40167">的数字就越高：</st>
- en: '![Figure 2.9 – Mean target value per category of A7 after the encoding.](img/B22396_02_09.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 编码后 A7 类别每类的均值目标值。](img/B22396_02_09.jpg)'
- en: <st c="40273">Figure 2.9 – Mean target value per category of A7 after the encoding.</st>
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40273">图 2.9 – 编码后 A7 类别每类的均值目标值。</st>
- en: <st c="40342">Now, let’s</st> <st c="40354">perform ordered ordinal encoding</st>
    <st c="40387">using</st> `<st c="40393">feature-engine</st>`<st c="40407">.</st>
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40342">现在，让我们</st> <st c="40354">使用</st> `<st c="40393">feature-engine</st>`<st
    c="40407">执行有序顺序编码。</st>
- en: <st c="40408">Let’s import</st> <st c="40422">the encoder:</st>
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40408">让我们导入</st> <st c="40422">编码器：</st>
- en: '[PRE80]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: <st c="40486">Next, let’s set up the encoder so that it assigns integers based
    on the target mean value to all categorical variables in</st> <st c="40609">the
    dataset:</st>
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40486">接下来，让我们设置编码器，使其根据目标均值值将整数分配给数据集中所有分类变量：</st> <st c="40609"></st>
- en: '[PRE81]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: <st c="40694">Note</st>
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40694">注意</st>
- en: '`<st c="40699">OrdinalEncoder()</st>` <st c="40716">will find and encode all
    categorical variables automatically.</st> <st c="40779">To restrict the encoding
    to a subset of variables, pass their names in a list to the</st> `<st c="40864">variables</st>`
    <st c="40873">argument.</st> <st c="40884">To encode numerical variables,</st>
    <st c="40915">set</st> `<st c="40919">ignore_format=True</st>`<st c="40937">.</st>'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="40699">OrdinalEncoder()</st>` <st c="40716">将自动查找并编码所有分类变量。</st> <st
    c="40779">要限制编码到变量的子集，将它们的名称作为列表传递给</st> `<st c="40864">variables</st>` <st c="40873">参数。</st>
    <st c="40884">要编码数值变量，</st> <st c="40915">设置</st> `<st c="40919">ignore_format=True</st>`<st
    c="40937">。</st>'
- en: <st c="40938">Let’s fit the encoder to the train set so that it finds the categorical
    variables, and then stores the</st> <st c="41042">category and</st> <st c="41055">integer
    m</st><st c="41064">appings:</st>
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40938">让我们将编码器拟合到训练集，以便它找到类别变量，然后存储</st><st c="41042">类别和</st><st c="41055">整数映射：</st>
- en: '[PRE82]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: <st c="41107">Finally, let’s replace the categories with numbers in the train
    and</st> <st c="41176">test sets:</st>
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="41107">最后，让我们在训练集和</st><st c="41176">测试集中将类别替换为数字：</st>
- en: '[PRE83]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: <st c="41274">Note</st>
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41274">注意</st>
- en: <st c="41279">You’ll find the digits that will replace each category in the</st>
    `<st c="41342">encoder_dict_</st>` <st c="41355">attribute.</st>
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41279">你将在</st><st c="41342">encoder_dict_</st><st c="41355">属性中找到替换每个类别的数字。
- en: <st c="41366">Check out the outp</st><st c="41385">ut of the transformation
    by</st> <st c="41414">executing</st> `<st c="41424">X_train_enc.head()</st>`<st
    c="41442">.</st>
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41366">检查通过执行</st><st c="41385">X_train_enc.head()</st><st c="41442">.</st>
    变换的输出。
- en: <st c="41443">How it works...</st>
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="41443">它是如何工作的...</st>
- en: <st c="41459">In this recipe, we replaced the categories with integers according
    to the</st> <st c="41534">target mean.</st>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41459">在这个菜谱中，我们根据</st><st c="41534">目标均值</st><st c="41546">将类别替换为整数。</st>
- en: <st c="41546">In the first part of this recipe, we worked with the</st> `<st
    c="41600">A7</st>` <st c="41602">categorical variable.</st> <st c="41625">With</st>
    `<st c="41630">pandas</st>`<st c="41636">’</st> `<st c="41639">groupby()</st>`<st
    c="41648">, we grouped the data based on the categories of</st> `<st c="41697">A7</st>`<st
    c="41699">, and with</st> `<st c="41710">pandas</st>`<st c="41716">’</st> `<st
    c="41719">mean()</st>`<st c="41725">, we determined the mean value of the target
    for each of those categories.</st> <st c="41800">Next, we ordered the categories
    with</st> `<st c="41837">pandas</st>`<st c="41843">’</st> `<st c="41846">sort_values()</st>`
    <st c="41859">from the ones with the lowest to the ones with the highest target
    mean response.</st> <st c="41941">The output of this operation was a</st> `<st
    c="41976">pandas</st>` <st c="41982">series, with the categories as indices and
    the target mean as values.</st> <st c="42053">With</st> `<st c="42058">pandas</st>`<st
    c="42064">’</st> `<st c="42067">index</st>`<st c="42072">, we captured the ordered
    categories in an array; then, with Python dictionary comprehension, we created
    a dictionary of category-to-integer pairs.</st> <st c="42220">Finally, we used
    this dictionary to replace the category with integers using</st> `<st c="42297">pandas</st>`<st
    c="42303">’</st> `<st c="42306">map()</st>`<st c="42311">.</st>
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41546">在这个菜谱的第一部分，我们处理了</st><st c="41600">A7</st><st c="41602">类别变量。</st>
    <st c="41625">使用</st><st c="41630">pandas</st><st c="41636">’</st><st c="41639">groupby()</st><st
    c="41648">，我们根据</st><st c="41697">A7</st><st c="41699">的类别对数据进行分组，并使用</st><st
    c="41710">pandas</st><st c="41716">’</st><st c="41719">mean()</st><st c="41725">，我们确定了每个类别的目标均值。</st>
    <st c="41800">接下来，我们使用</st><st c="41837">pandas</st><st c="41843">’</st><st c="41846">sort_values()</st><st
    c="41859">对类别进行排序，从目标均值响应最低的类别到最高的类别。</st> <st c="41941">这个操作的输出是一个</st><st c="41976">pandas</st><st
    c="41982">序列，类别作为索引，目标均值作为值。</st> <st c="42053">使用</st><st c="42058">pandas</st><st
    c="42064">’</st><st c="42067">index</st><st c="42072">，我们将排序后的类别存储在一个数组中；然后，使用Python字典推导式，我们创建了一个类别到整数的字典。</st>
    <st c="42220">最后，我们使用这个字典通过</st><st c="42297">pandas</st><st c="42303">’</st><st
    c="42306">map()</st><st c="42311">将类别替换为整数。
- en: <st c="42312">Note</st>
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42312">注意</st>
- en: <st c="42317">To avoid data leakage, we determine the ca</st><st c="42360">tegory-to-integer
    mappings from the</st> <st c="42397">train set.</st>
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42317">为了避免数据泄露，我们从</st><st c="42360">训练集</st><st c="42397">确定类别到整数的映射。
- en: <st c="42407">To perform the encoding with</st> `<st c="42437">feature-engine</st>`<st
    c="42451">, we used</st> `<st c="42461">OrdinalEncoder()</st>`<st c="42477">,
    setting the</st> `<st c="42491">encoding_method</st>` <st c="42506">to</st> `<st
    c="42510">ordered</st>`<st c="42517">. We left the argument variables set to</st>
    `<st c="42557">None</st>` <st c="42561">so that the encoder automatically detects
    all categorical variables in the dataset.</st> <st c="42646">With</st> `<st c="42651">fit()</st>`<st
    c="42656">, the encoder</st> <st c="42669">found the categorical variables and
    assigned digits to their categories according to the target mean value.</st> <st
    c="42778">The categorical variables’ names and dictionaries with category-to-digit
    pairs were stored in the</st> `<st c="42876">variables_</st>` <st c="42886">and</st>
    `<st c="42891">encoder_dict_</st>` <st c="42904">attributes, respectively.</st>
    <st c="42931">Finally, using</st> `<st c="42946">transform()</st>`<st c="42957">,
    we replaced the categories with digit</st><st c="42996">s in the train and test
    sets, returning</st> `<st c="43037">pandas</st>` <st c="43043">DataFrames.</st>
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用`feature-engine`进行编码时，我们使用了`OrdinalEncoder()`，将`encoding_method`设置为`ordered`。我们将参数变量设置为`None`，以便编码器自动检测数据集中的所有分类变量。</st>
    [使用`fit()`，编码器找到了分类变量，并根据目标均值值将数字分配给它们的类别。</st> [分类变量的名称和类别到数字对的字典分别存储在`variables_`和`encoder_dict_`属性中。</st>
    [最后，使用`transform()`，我们在训练集和测试集中将类别替换为数字，返回`pandas` DataFrame。</st>]'
- en: <st c="43055">See also</st>
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[另请参阅](https://wiki.example.org/see_also)'
- en: <st c="43064">For an implementation of this recipe with Category Encoders, visit
    this book’s GitHub</st> <st c="43151">repository:</st> [<st c="43163">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-cate</st><st
    c="43267">gorical-encoding/Recipe-05-Ordered-ordinal-encod</st><st c="43316">ing.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-05-Ordered-ordinal-encoding.ipynb)<st
    c="43326">.</st>
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[要使用Category Encoders实现此菜谱，请访问本书的GitHub仓库：](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-05-Ordered-ordinal-encoding.ipynb)
    [<st c="43163">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-05-Ordered-ordinal-encoding.ipynb</st><st
    c="43267">](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-05-Ordered-ordinal-encoding.ipynb).'
- en: <st c="43327">Implementing target mean encoding</st>
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[实现目标均值编码](https://wiki.example.org/implementing_target_mean_encoding)'
- en: '**<st c="43361">Mean encoding</st>** <st c="43375">or</st> **<st c="43379">target
    encoding</st>** <st c="43394">maps</st> <st c="43400">each category to the probability
    estimate of the target attribute.</st> <st c="43467">If the target is binary,
    the numerical mapping is the posterior probability of the target conditioned to
    the value of the category.</st> <st c="43599">If the target is continuous, the
    numerical representation is given by the expected value of the target given the
    value of</st> <st c="43721">the category.</st>'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**[均值编码**](https://wiki.example.org/mean_encoding) 或 **[目标编码**](https://wiki.example.org/target_encoding)
    将每个类别映射到目标属性的概率估计值。如果目标是二进制，则数值映射是目标在给定类别值条件下的后验概率。如果目标是连续的，则数值表示是给定类别值的目标的期望值。]'
- en: <st c="43734">In its simplest form, the</st> <st c="43760">numerical representation
    for each category is given by the mean value of the target variable for a particular
    category group.</st> <st c="43887">For example, if we have a</st> `<st c="43913">City</st>`
    <st c="43917">variable, with the categories of</st> `<st c="43951">London</st>`<st
    c="43957">,</st> `<st c="43959">Manchester</st>`<st c="43969">, and</st> `<st
    c="43975">Bristol</st>`<st c="43982">, and we want to predict the default rate
    (the target takes values of</st> `<st c="44052">0</st>` <st c="44053">and</st>
    `<st c="44058">1</st>`<st c="44059">); if the default rate for</st> `<st c="44086">London</st>`
    <st c="44092">is 30%, we replace</st> `<st c="44112">London</st>` <st c="44118">with</st>
    `<st c="44124">0.3</st>`<st c="44127">; if the default rate for</st> `<st c="44154">Manchester</st>`
    <st c="44164">is 20%, we replace</st> `<st c="44184">Manchester</st>` <st c="44194">with</st>
    `<st c="44200">0.2</st>`<st c="44203">; and so on.</st> <st c="44217">If the target
    is continuous – say we want to predict income – then we would replace</st> `<st
    c="44301">London</st>`<st c="44307">,</st> `<st c="44309">Manchester</st>`<st
    c="44319">, and</st> `<st c="44325">Bristol</st>` <st c="44332">with the mean
    income earned in</st> <st c="44364">each city.</st>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单形式中，每个类别的数值表示是通过特定类别组的目标变量的平均值给出的。<st c="43760">例如，如果我们有一个</st> `<st c="43913">城市</st>`
    <st c="43917">变量，其类别为</st> `<st c="43951">伦敦</st>`<st c="43957">、</st> `<st c="43959">曼彻斯特</st>`<st
    c="43969">和</st> `<st c="43975">布里斯托尔</st>`<st c="43982">，并且我们想要预测违约率（目标取值为</st>
    `<st c="44052">0</st>` <st c="44053">和</st> `<st c="44058">1</st>`<st c="44059">）；如果伦敦的违约率为30%，我们将</st>
    `<st c="44086">伦敦</st>` <st c="44092">替换为</st> `<st c="44112">0.3</st>`<st c="44127">；如果曼彻斯特的违约率为20%，我们将</st>
    `<st c="44154">曼彻斯特</st>` <st c="44164">替换为</st> `<st c="44184">0.2</st>`<st c="44200">；依此类推。</st>
    <st c="44217">如果目标是连续的——比如说我们想要预测收入——那么我们将</st> `<st c="44301">伦敦</st>`<st c="44307">、</st>
    `<st c="44309">曼彻斯特</st>`<st c="44319">和</st> `<st c="44325">布里斯托尔</st>` <st c="44332">替换为每个城市所赚取的平均收入。</st>
- en: <st c="44374">In mathematical terms, if the target is binary, the replacement
    value,</st> *<st c="44446">S</st>*<st c="44447">, is determined</st> <st c="44463">like
    so:</st>
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学术语中，如果目标是二进制，则替换值，*<st c="44446">S</st>*，是这样确定的：
- en: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>(</mml:mo><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
    display="block"><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>(</mml:mo><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/1.png)'
- en: <st c="44480">Here, the numerator is the number of observations with a target
    value of</st> *<st c="44553">1</st>* <st c="44554">for category</st> *<st c="44568">i</st>*
    <st c="44569">and the denominator is the number of observations with a category
    value</st> <st c="44642">of</st> *<st c="44645">i</st>*<st c="44646">.</st>
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44480">在这里，分子是具有类别值</st> *<st c="44553">1</st>* <st c="44554">的观测值的数量，对于类别</st>
    *<st c="44568">i</st>* <st c="44569">，分母是具有类别值</st> <st c="44642">的观测值的数量</st>
    *<st c="44645">i</st>*<st c="44646">。</st>
- en: <st c="44647">If the target is continuous,</st> *<st c="44677">S</st>*<st c="44678">,
    this is determined by the</st> <st c="44706">following formula:</st>
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44647">如果目标是连续的，</st> *<st c="44677">S</st>*<st c="44678">，这是通过以下公式确定的：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mo>∑</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><msub><mi>n</mi><mi>i</mi></msub></mfrac></mrow></mrow></math>](img/2.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mo>∑</mo><msub><mi>y</mi><mi>i</mi></msub></mrow><msub><mi>n</mi><mi>i</mi></msub></mfrac></mrow></mrow></math>](img/2.png)'
- en: <st c="44764">Here, the</st> <st c="44773">numerator is the sum of the target
    across observations in category</st> *<st c="44841">i</st>* <st c="44842">and</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/3.png)
    <st c="44847"><st c="44848">is the total number of observations in</st> <st c="44888">category</st>
    *<st c="44897">i</st>*<st c="44898">.</st></st>
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44764">在这里，分子是类别</st> *<st c="44841">i</st>* <st c="44842">中观察到的目标值的总和</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/3.png)
    <st c="44847"><st c="44848">是类别</st> *<st c="44888">i</st>*<st c="44898">中的观察总数。</st>
- en: <st c="44899">These formulas provide a good approximation of the target estimate
    if there is a sufficiently large number of observations with each category value
    – in other words, if</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/4.png)
    <st c="45069"><st c="45080">is large.</st> <st c="45090">However, in many datasets,
    there will be categories present in a few observations.</st> <st c="45173">In
    these cases, target estimates derived from the precedent formulas can</st> <st
    c="45246">be unreliable.</st></st>
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44899">如果每个类别值有足够多的观察值，这些公式提供了对目标估计的良好近似——换句话说，如果</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/4.png)
    <st c="45069"><st c="45080">很大。</st> <st c="45090">然而，在许多数据集中，将存在一些观察值中出现的类别。</st>
    <st c="45173">在这些情况下，从前述公式推导出的目标估计可能</st> <st c="45246">不可靠。</st>
- en: '<st c="45260">To mitigate poor estimates returned for rare categories, the
    target estimates can be determined as a mixture of two probabilities: those returned
    by the preceding formulas and the prior probability of the target based on the
    entire training.</st> <st c="45503">The two probabilities are</st> *<st c="45529">blended</st>*
    <st c="45536">using a weighting factor, which is a function of the category</st>
    <st c="45599">group size:</st>'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45260">为了减轻对罕见类别返回的估计值不准确的问题，目标估计值可以确定为两个概率的混合：前述公式返回的概率和基于整个训练集的目标先验概率。</st>
    <st c="45503">这两个概率通过一个加权因子进行*混合*，该加权因子是类别组大小的函数：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mi>λ</mi><mfrac><msub><mi>n</mi><mrow><mi>i</mi><mo>(</mo><mi>Y</mi><mo>=</mo><mn>1</mn><mo>)</mo></mrow></msub><msub><mi>n</mi><mi>i</mi></msub></mfrac><mo>+</mo><mo>(</mo><mn>1</mn><mo>−</mo><msub><mi>λ</mi><mi>i</mi></msub><mo>)</mo><mfrac><msub><mi>n</mi><mi>λ</mi></msub><mi>N</mi></mfrac></mrow></mrow></mrow></math>](img/5.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mi>λ</mi><mfrac><msub><mi>n</mi><mrow><mi>i</mi><mo>(</mo><mi>Y</mi><mo>=</mo><mn>1</mn><mo>)</mo></mrow></msub><msub><mi>n</mi><mi>i</mi></msub></mfrac><mo>+</mo><mo>(</mo><mn>1</mn><mo>−</mo><msub><mi>λ</mi><mi>i</mi></msub><mo>)</mo><mfrac><msub><mi>n</mi><mi>λ</mi></msub><mi>N</mi></mfrac></mrow></mrow></mrow></math>](img/5.png)'
- en: <st c="45633">In this formula,</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">λ</mml:mi></mml:mrow></mml:msub></mml:math>](img/6.png) <st
    c="45650"><st c="45675">is the total number of cases where the target takes a
    value of</st> *<st c="45738">1</st>*<st c="45739">,</st> *<st c="45741">N</st>*
    <st c="45742">is the size of the train set, and</st> *<st c="45777">𝜆</st>* <st
    c="45779">is the</st> <st c="45787">weighting factor.</st></st>
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45633">在这个公式中，</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi
    mathvariant="normal">λ</mml:mi></mml:mrow></mml:msub></mml:math>](img/6.png) <st
    c="45650"><st c="45675">是目标取值为*1*的总案例数，*N*是训练集的大小，而*𝜆*是加权因子。</st>
- en: <st c="45804">When the category group is large,</st> *<st c="45839">𝜆</st>*
    <st c="45841">tends to</st> *<st c="45851">1</st>*<st c="45852">, so more weight
    is given to the first term of the equation.</st> <st c="45913">When the category</st>
    <st c="45931">group size is small, then</st> *<st c="45957">𝜆</st>* <st c="45959">tends
    to</st> *<st c="45969">0</st>*<st c="45970">, so the estimate is mostly driven
    by the second term of the equation – that is, the target’s prior probability.</st>
    <st c="46083">In other words, if the group size is small, knowing the value of
    the category does not tell us anything about the value of</st> <st c="46206">the
    target.</st>
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当类别组较大时，*<st c="45839">𝜆</st>* <st c="45841">趋向于*<st c="45851">1</st>*<st c="45852">，因此方程的第一个项被赋予更多的权重。当类别组大小较小时，则*<st
    c="45957">𝜆</st>* <st c="45959">趋向于*<st c="45969">0</st>*<st c="45970">，因此估计主要由方程的第二个项驱动——即目标的前验概率。换句话说，如果组大小较小，知道类别值并不能告诉我们关于目标值的信息。
- en: <st c="46217">The weighting factor,</st> *<st c="46240">𝜆</st>*<st c="46242">,
    is determined differently in different open-source implementations.</st> <st c="46312">In
    Category Encoders,</st> *<st c="46334">𝜆</st>* <st c="46336">is a function of
    the group size,</st> *<st c="46370">k</st>*<st c="46371">, and a smoothing parameter,</st>
    *<st c="46400">f</st>*<st c="46401">, which controls the rate of transition between
    the first</st> <st c="46459">and second term of the</st> <st c="46482">preceding
    equation:</st>
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 权重因子，*<st c="46240">𝜆</st>*<st c="46242">，在不同的开源实现中确定方式不同。在类别编码器中，*<st c="46334">𝜆</st>*
    <st c="46336">是组大小，*<st c="46370">k</st>*<st c="46371">，以及平滑参数，*<st c="46400">f</st>*<st
    c="46401">，的函数，它控制着前一个方程的第一个项和第二个项之间的转换速率：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>λ</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mrow><mrow><mo>−</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>)</mo></mrow></mrow><mo>/</mo><mi>f</mi></mrow></msup></mrow></mfrac></mrow></mrow></math>](img/7.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>λ</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mrow><mrow><mo>−</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo>)</mo></mrow></mrow><mo>/</mo><mi>f</mi></mrow></msup></mrow></mfrac></mrow></mrow></math>](img/7.png)'
- en: <st c="46520">Here,</st> *<st c="46526">k</st>* <st c="46527">is half of the
    minimal size for which we</st> *<st c="46569">fully trust</st>* <st c="46580">the
    first term of the equation.</st> <st c="46613">The</st> *<st c="46617">f</st>*
    <st c="46618">parameter is selected by the user either arbitrarily or</st> <st
    c="46675">with optimization.</st>
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*<st c="46526">k</st>*是我们可以完全信任方程第一个项的最小大小的一半。*<st c="46569">完全信任</st>*
    <st c="46580">方程的第一个项</st> <st c="46580">的参数由用户任意选择或通过优化选择。*<st c="46617">f</st>*
    <st c="46618">参数由用户任意选择或通过优化选择。
- en: <st c="46693">In</st> `<st c="46697">scikit-learn</st>` <st c="46709">and</st>
    `<st c="46714">feature-engine</st>`<st c="46728">,</st> *<st c="46730">𝜆</st>*
    <st c="46732">is a function of the target variance for the entire dataset and
    within the category, and is determined</st> <st c="46836">as follows:</st>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scikit-learn`和`feature-engine`中，*<st c="46730">𝜆</st>*是一个关于整个数据集和类别内目标方差的函数，并且如下确定：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="normal">λ</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mi>i</mi><mo>×</mo><mi>t</mi></mrow><mrow><mi>s</mi><mo>+</mo><mi>n</mi><mi>i</mi><mo>×</mo><mi>t</mi></mrow></mfrac></mrow></mrow></math>](img/8.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi
    mathvariant="normal">λ</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mi>i</mi><mo>×</mo><mi>t</mi></mrow><mrow><mi>s</mi><mo>+</mo><mi>n</mi><mi>i</mi><mo>×</mo><mi>t</mi></mrow></mfrac></mrow></mrow></math>](img/8.png)'
- en: <st c="46861">Here,</st> *<st c="46867">t</st>* <st c="46868">is the target</st>
    <st c="46882">variance in the entire dataset and</st> *<st c="46918">s</st>* <st
    c="46919">is the target variance within the category.</st> <st c="46964">Both
    implementations are equivalent, but it is important to know the equations because
    they will help you set up the parameters in</st> <st c="47095">the transformers.</st>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*<st c="46867">t</st>* <st c="46868">是整个数据集中的目标方差，*<st c="46918">s</st>*
    <st c="46919">是类别内的目标方差。两种实现是等效的，但了解这些方程很重要，因为它们将帮助你在转换器中设置参数。
- en: <st c="47112">Note</st>
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '<st c="47117">Mean encoding was designed to encode highly cardinal categorical
    variables without expanding the feature space.</st> <st c="47230">For more details,
    check out the following article: Micci-Barreca D.</st> <st c="47298">A.,</st>
    *<st c="47302">Preprocessing Scheme for High-Cardinality Categorical Attributes
    in Classification and Prediction Problems</st>*<st c="47408">. ACM SIGKDD Explorations</st>
    <st c="47434">Newsletter, 2001.</st>'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47117">均值编码旨在在不扩展特征空间的情况下对高度基数分类变量进行编码。</st> <st c="47230">更多详情，请查看以下文章：Micci-Barreca
    D.</st> <st c="47298">A.</st> *<st c="47302">用于分类和预测问题中高基数分类属性的前处理方案</st>*<st
    c="47408">. ACM SIGKDD Explorations</st> <st c="47434">通讯，2001。</st>
- en: <st c="47451">In this recipe, we will perf</st><st c="47480">orm mean encoding
    using</st> `<st c="47505">scikit-learn</st>` <st c="47517">and</st> `<st c="47522">feature-engine</st>`<st
    c="47536">.</st>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47451">在这个菜谱中，我们将使用</st> `<st c="47505">scikit-learn</st>` <st c="47517">和</st>
    `<st c="47522">feature-engine</st>`<st c="47536">来执行均值编码。</st>
- en: <st c="47537">How to do it...</st>
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="47537">如何操作...</st>
- en: <st c="47553">Let’s begin with</st> <st c="47571">this recipe:</st>
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47553">让我们从</st> <st c="47571">这个菜谱</st> 开始：</st>
- en: <st c="47583">Import</st> `<st c="47591">pandas</st>` <st c="47597">and the
    data</st> <st c="47611">split function:</st>
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47583">导入</st> `<st c="47591">pandas</st>` <st c="47597">以及数据</st> `<st
    c="47611">分割函数</st>：</st>
- en: '[PRE84]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: <st c="47699">Let’s load the Credit Approval dataset and divide it into train
    and</st> <st c="47768">test sets:</st>
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47699">让我们加载Credit Approval数据集并将其分为训练集和</st> <st c="47768">测试集：</st>
- en: '[PRE85]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: <st c="47964">Let’s import the transformers</st> <st c="47995">from</st> `<st
    c="48000">scikit-learn</st>`<st c="48012">:</st>
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47964">让我们从`<st c="48000">scikit-learn</st>`<st c="48012">导入转换器</st>
    <st c="47995">：</st>
- en: '[PRE86]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: <st c="48108">Let’s</st> <st c="48115">make a list with the names of the</st>
    <st c="48149">categorical variables:</st>
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48108">让我们</st> <st c="48115">创建一个包含分类变量名称的列表：</st>
- en: '[PRE87]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: <st c="48236">Let’s set up the encoder to use the target variance to determine
    the weighting factor, as described at the beginning of</st> <st c="48357">the
    recipe:</st>
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48236">让我们设置编码器，使其使用目标方差来确定权重因子，正如菜谱开头所述：</st>
- en: '[PRE88]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: <st c="48419">Let’s restrict the imputation to</st> <st c="48453">categorical
    variables:</st>
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48419">让我们将插补限制在</st> <st c="48453">分类变量：</st>
- en: '[PRE89]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: <st c="48587">Let’s fit the encoder and transform</st> <st c="48624">the datasets:</st>
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48587">让我们拟合编码器并转换</st> <st c="48624">数据集：</st>
- en: '[PRE90]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: <st c="48720">Check out the result by</st> <st c="48745">executing</st> `<st
    c="48755">X_train_enc.head()</st>`<st c="48773">.</st>
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48720">通过执行</st> <st c="48745">`<st c="48755">X_train_enc.head()</st>`<st
    c="48773">`</st> 来查看结果。</st>
- en: <st c="48774">Note</st>
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48774">注意</st>
- en: <st c="48779">The</st> `<st c="48784">fit_transform()</st>` <st c="48799">method
    of</st> `<st c="48810">scikit-learn</st>`<st c="48822">’s</st> `<st c="48826">TargetEncoder()</st>`
    <st c="48841">is not equivalent to applying</st> `<st c="48872">fit().transform()</st>`<st
    c="48889">. With</st> `<st c="48896">fit_transform()</st>`<st c="48911">, the
    resulting dataset is encoded based on partial fits over the training folds of
    a cross-validation scheme.</st> <st c="49022">This functionality was intentionally
    designed to prevent overfitting the machine learning model to the</st> <st c="49125">train
    set.</st>
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48779">`<st c="48784">fit_transform()</st>` <st c="48799">方法与`<st c="48810">scikit-learn</st>`<st
    c="48822">的`<st c="48826">TargetEncoder()</st>` <st c="48841">的`<st c="48872">fit().transform()</st>`<st
    c="48889">应用不等价。使用`<st c="48896">fit_transform()</st>`<st c="48911">，生成的数据集基于交叉验证方案的训练折的局部拟合进行编码。</st>
    <st c="49022">此功能是故意设计的，以防止机器学习模型过度拟合</st> <st c="49125">训练集。</st>
- en: <st c="49135">Now, let’s perform target encoding</st> <st c="49171">with</st>
    `<st c="49176">feature-engine</st>`<st c="49190">:</st>
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49135">现在，让我们使用`<st c="49176">feature-engine</st>`<st c="49190">执行目标编码</st>：</st>
- en: <st c="49192">Let’s import</st> <st c="49204">the encoder:</st>
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49192">让我们导入</st> <st c="49204">编码器：</st>
- en: '[PRE91]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: <st c="49265">Let’s set up the target mean encoder to encode all categorical
    variables while</st> <st c="49345">applying smoothing:</st>
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49265">让我们设置目标均值编码器以编码所有分类变量，同时</st> <st c="49345">应用平滑处理：</st>
- en: '[PRE92]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: <st c="49421">Note</st>
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49421">注意</st>
- en: '`<st c="49426">MeanEncoder()</st>` <st c="49440">does not apply smoothing by
    default.</st> <st c="49478">Make sure you set it to</st> `<st c="49502">auto</st>`
    <st c="49506">or to an integer to control the blend b</st><st c="49546">etween
    prior and posterior</st> <st c="49574">target estimates.</st>'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="49426">MeanEncoder()</st>` <st c="49440">默认情况下不应用平滑。</st> <st c="49478">确保您将其设置为</st>
    `<st c="49502">auto</st>` <st c="49506">或整数以控制先验和后验</st><st c="49546">目标估计之间的混合b</st><st
    c="49574">。</st>'
- en: <st c="49591">Let’s fit the transformer to the train set so that it learns and
    stores the mean target value per category</st> <st c="49699">per variable:</st>
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49591">让我们将变压器拟合到训练集，以便它学习并存储每个类别的平均目标值</st> <st c="49699">每个变量：</st>
- en: '[PRE93]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: <st c="49743">Finally, let’s encode the train and</st> <st c="49780">test sets:</st>
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49743">最后，让我们对训练集和</st> <st c="49780">测试集进行编码：</st>
- en: '[PRE94]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: <st c="49872">Note</st>
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49872">注意</st>
- en: <st c="49877">The category-to-number pairs are stored as a dictionary of dictionaries
    in the</st> `<st c="49957">encoder_dict_</st>` <st c="49970">attribute.</st> <st
    c="49982">To disp</st><st c="49989">lay the stored parameters,</st> <st c="50017">execute</st>
    `<st c="50025">mean_enc.encoder_dict_.</st>`
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49877">类别到数字的配对存储在</st> `<st c="49957">encoder_dict_</st>` <st c="49970">属性中的字典字典中。</st>
    <st c="49982">要显示存储的参数，</st><st c="49989">执行</st> `<st c="50017">mean_enc.encoder_dict_.</st>`
- en: <st c="50048">How it works…</st>
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="50048">它是如何工作的…</st>
- en: <st c="50062">In this recipe, we</st> <st c="50081">replaced the categories
    with the mean target value using</st> `<st c="50139">scikit-learn</st>` <st c="50151">and</st>
    `<st c="50156">feature-engine</st>`<st c="50170">.</st>
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50062">在这个配方中，我们</st> <st c="50081">使用</st> `<st c="50139">scikit-learn</st>`
    <st c="50151">和</st> `<st c="50156">feature-engine</st>`<st c="50170">将类别替换为平均目标值。</st>
- en: <st c="50171">To encode with</st> `<st c="50187">scikit-learn</st>`<st c="50199">,
    we used</st> `<st c="50209">TargetEncoder()</st>`<st c="50224">, leaving the</st>
    `<st c="50238">smooth</st>` <st c="50244">parameter to its default value of</st>
    `<st c="50279">auto</st>`<st c="50283">. Like this, the transformer used the target
    variance to determine the weighting factor for the blend of probabilities.</st>
    <st c="50403">With</st> `<st c="50408">fit()</st>`<st c="50413">, the transformer
    learned the value it should use to replace the categories, and with</st> `<st
    c="50499">transform()</st>`<st c="50510">, it replaced</st> <st c="50524">the
    categories.</st>
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50171">要使用</st> `<st c="50187">scikit-learn</st>`<st c="50199">进行编码，我们使用了</st>
    `<st c="50209">TargetEncoder()</st>`<st c="50224">，将</st> `<st c="50238">smooth</st>`
    <st c="50244">参数保留为其默认值</st> `<st c="50279">auto</st>`<st c="50283">。就这样，变压器使用了目标方差来确定概率混合的权重因子。</st>
    <st c="50403">使用</st> `<st c="50408">fit()</st>`<st c="50413">，变压器学习了它应该使用的值来替换类别，并且使用</st>
    `<st c="50499">transform()</st>`<st c="50510">，它替换了</st> <st c="50524">类别。</st>
- en: <st c="50539">Note that for</st> `<st c="50554">TargetEncoder()</st>`<st c="50569">,
    the</st> `<st c="50575">fit()</st>` <st c="50580">method followed by</st> `<st
    c="50600">transform()</st>` <st c="50611">do not return the same dataset as the</st>
    `<st c="50650">fit_transform()</st>`<st c="50665">method.</st> <st c="50674">The
    latter encodes the training set based on mappings found with cross-validation.</st>
    <st c="50757">The idea is to use</st> `<st c="50776">fit_transform()</st>` <st
    c="50791">within a pipeline, so the machine learning model does not overfit.</st>
    <st c="50859">However, and here is where it gets confusing, the mappings stored
    in the</st> `<st c="50932">encodings_</st>` <st c="50942">attribute are the same
    after</st> `<st c="50972">fit()</st>` <st c="50977">and</st> `<st c="50982">fit_transform()</st>`<st
    c="50997">, and this is done intentionally so that when we apply</st> `<st c="51052">transform()</st>`
    <st c="51063">to a new dataset, we obtain the same result regardless of whether
    we apply</st> `<st c="51139">fit()</st>` <st c="51144">or</st> `<st c="51148">fit_transform()</st>`<st
    c="51163">to the</st> <st c="51171">training set.</st>
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50539">请注意，对于</st> `<st c="50554">TargetEncoder()</st>`<st c="50569">，随后的</st>
    `<st c="50575">fit()</st>` <st c="50580">方法和</st> `<st c="50600">transform()</st>`
    <st c="50611">不返回与</st> `<st c="50650">fit_transform()</st>`<st c="50665">方法相同的数据集。</st>
    <st c="50674">后者的想法是在管道中使用</st> `<st c="50776">fit_transform()</st>` <st c="50791">，这样机器学习模型就不会过拟合。</st>
    <st c="50859">然而，这里变得有些混乱，存储在</st> `<st c="50932">encodings_</st>` <st c="50942">属性中的映射在</st>
    `<st c="50972">fit()</st>` <st c="50977">和</st> `<st c="50982">fit_transform()</st>`<st
    c="50997">之后是相同的，这是故意为之，以便当我们将</st> `<st c="51052">transform()</st>` <st c="51063">应用于新数据集时，无论我们是否将</st>
    `<st c="51139">fit()</st>` <st c="51144">或</st> `<st c="51148">fit_transform()</st>`<st
    c="51163">应用于训练集，我们都能获得相同的结果。</st>
- en: <st c="51184">Note</st>
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51184">注意</st>
- en: <st c="51189">Unseen categories are encoded with the target mean by</st> `<st
    c="51244">scikit-learn</st>`<st c="51256">’s</st> `<st c="51260">TargetEncoder()</st>`<st
    c="51275">.</st> `<st c="51277">feature-engine</st>`<st c="51291">’s</st> `<st
    c="51295">MeanEncoder()</st>` <st c="51308">can either return an error, replace
    the unseen categories with</st> `<st c="51372">nan</st>`<st c="51375">, or with
    the</st> <st c="51389">target mean.</st>
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51189">未看到的类别通过<st c="51244">scikit-learn</st><st c="51256">的</st> <st
    c="51260">TargetEncoder()</st><st c="51275">进行编码，以目标均值编码。</st> `<st c="51277">feature-engine</st>`<st
    c="51291">的</st> `<st c="51295">MeanEncoder()</st>`可以返回错误，用<st c="51372">nan</st><st
    c="51375">替换未看到的类别，或者用目标均值替换。</st>
- en: <st c="51401">To perform the target encoding with</st> `<st c="51438">feature-engine</st>`<st
    c="51452">, we used</st> `<st c="51462">MeanEncoder(),</st>` <st c="51476">setting
    the</st> `<st c="51489">smoothing</st>` <st c="51498">parameter to</st> `<st c="51512">auto</st>`<st
    c="51516">. With</st> `<st c="51523">fit()</st>`<st c="51528">, the transformer
    found and stored the categorical variables and the values to encode each category.</st>
    <st c="51629">With</st> `<st c="51634">transform()</st>`<st c="51645">, it replace</st><st
    c="51657">d the categories with numbers, returning</st> `<st c="51699">pandas</st>`
    <st c="51705">DataFrames.</st>
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51401">要使用<st c="51438">feature-engine</st><st c="51452">执行目标编码，我们使用了</st>
    `<st c="51462">MeanEncoder(),</st>` <st c="51476">将</st> `<st c="51489">smoothing</st>`
    <st c="51498">参数设置为</st> `<st c="51512">auto</st>`<st c="51516">。通过</st> `<st
    c="51523">fit()</st>`<st c="51528">，转换器找到了并存储了分类变量以及编码每个类别的值。</st> <st c="51629">通过</st>
    `<st c="51634">transform()</st>`<st c="51645">，它将类别替换为数字，返回</st> `<st c="51699">pandas</st>`
    <st c="51705">数据框。</st>
- en: <st c="51717">There’s more…</st>
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="51717">还有更多...</st>
- en: <st c="51731">If you want to implement target encoding with</st> `<st c="51778">pandas</st>`
    <st c="51784">or Category Encoders, check out the notebook in the accompanying
    GitHub</st> <st c="51857">repository:</st> [<st c="51869">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-06-Target-mean-encoding.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-06-Target-mean-encoding.ipynb)<st
    c="52026">.</st>
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51731">如果您想使用<st c="51778">pandas</st> <st c="51784">或类别编码器实现目标编码，请查看随附GitHub</st>
    <st c="51857">存储库中的笔记本：</st> [<st c="51869">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-06-Target-mean-encoding.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-06-Target-mean-encoding.ipynb)<st
    c="52026">。</st>
- en: <st c="52027">There is an alternative way to return</st> *<st c="52066">better</st>*
    <st c="52072">target estimates when the category groups are small.</st> <st c="52126">The
    replacement valu</st><st c="52146">e for each category is determined</st> <st
    c="52181">as follows:</st>
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52027">当类别分组较小时，有一种替代方法可以返回更准确的**目标估计值**。</st> <st c="52126">每个类别的替换值如下确定：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>n</mi><mrow><mi>i</mi><mfenced
    open="(" close=")"><mrow><mi>Y</mi><mo>=</mo><mn>1</mn></mrow></mfenced></mrow></msub><mo>+</mo><mi>p</mi><mi>Y</mi><mi>x</mi><mi>m</mi></mrow><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>+</mo><mi>m</mi></mrow></mfrac></mrow></mrow></math>](img/9.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><msub><mi>n</mi><mrow><mi>i</mi><mfenced
    open="(" close=")"><mrow><mi>Y</mi><mo>=</mo><mn>1</mn></mrow></mfenced></mrow></msub><mo>+</mo><mi>p</mi><mi>Y</mi><mi>x</mi><mi>m</mi></mrow><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>+</mo><mi>m</mi></mrow></mfrac></mrow></mrow></math>](img/9.png)'
- en: <st c="52214">Here,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>n</mi><mrow><mi>i</mi><mo>(</mo><mi>Y</mi><mo>=</mo><mn>1</mn><mo>)</mo></mrow></msub></mrow></math>](img/10.png)<st
    c="52220"><st c="52227">is the target mean for category</st> *<st c="52259">i</st>*
    <st c="52260">and</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/11.png)
    <st c="52265"><st c="52266">is the number of observations with category</st> *<st
    c="52311">i</st>*<st c="52312">. The</st> <st c="52318">target prior is given
    by</st> *<st c="52343">pY</st>* <st c="52345">and</st> *<st c="52350">m</st>*
    <st c="52351">is the weighting factor.</st> <st c="52377">With this adjustment,
    the only parameter that we have</st> <st c="52431">to set is the weight,</st>
    *<st c="52453">m</st>*<st c="52454">. If</st> *<st c="52459">m</st>* <st c="52460">is
    large, then more importance is given to the target’s prior probability.</st> <st
    c="52536">This adjustment affects target estimates for all categories but mostly
    for those with fewer observations because, in such cases,</st> *<st c="52665">m</st>*
    <st c="52666">could be much larger than</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/12.png)
    <st c="52693"><st c="52694">in the</st> <st c="52702">formula’s denominator.</st></st></st></st>
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52214">这里，</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>n</mi><mrow><mi>i</mi><mo>(</mo><mi>Y</mi><mo>=</mo><mn>1</mn><mo>)</mo></mrow></msub></mrow></math>](img/10.png)<st
    c="52220"><st c="52227">是类别</st> *<st c="52259">i</st>* <st c="52260">的目标均值，并且</st>
    ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/11.png)
    <st c="52265"><st c="52266">是具有类别</st> *<st c="52311">i</st>* <st c="52312">的观测值的数量。目标先验由</st>
    *<st c="52343">pY</st>* <st c="52345">给出，并且</st> *<st c="52350">m</st>* <st c="52351">是权重因子。</st>
    <st c="52377">通过这种调整，我们唯一需要设置的参数是权重，</st> *<st c="52453">m</st>* <st c="52454">。如果</st>
    *<st c="52459">m</st>* <st c="52460">很大，那么就会给予目标先验概率更多的重视。</st> <st c="52536">这种调整会影响所有类别的目标估计，但对于观测值较少的类别影响更大，因为在这种情况下，</st>
    *<st c="52665">m</st>* <st c="52666">可能比</st> ![<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
    xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math>](img/12.png)
    <st c="52693"><st c="52694">在公式分母中的</st> <st c="52702">数量大得多。</st></st></st>
- en: <st c="52724">Note</st>
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52724">注意</st>
- en: <st c="52729">This method is a good alternative to Category Encoders’</st> `<st
    c="52786">TargetEncoder()</st>` <st c="52801">because, in Category Encoders’ implementation
    of target encoding, we need to optimize two parameters instead of one (as we did
    with</st> `<st c="52934">feature-engine</st>` <st c="52948">and</st> `<st c="52953">scikit-learn</st>`<st
    c="52965">) to control</st> <st c="52979">the smoothing.</st>
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52729">这种方法是Category Encoders的`<st c="52786">TargetEncoder()</st>`的一个很好的替代方案，因为，在Category
    Encoders实现的目标编码中，我们需要优化两个参数而不是一个（正如我们在`<st c="52934">feature-engine</st>` `<st
    c="52948">和</st>` `<st c="52953">scikit-learn</st>` `<st c="52965">`中做的那样），以控制</st>
    `<st c="52979">平滑度。</st>`
- en: <st c="52993">For an implementation of this encoding method using</st> `<st
    c="53046">MEstimateEncoder()</st>`<st c="53064">, visit this book’s GitHub</st>
    <st c="53091">repository:</st> [<st c="53103">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-06-Target-mean-encoding.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-06-Target-mean-encoding.ipynb)<st
    c="53260">.</st>
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52993">要使用`<st c="53046">MEstimateEncoder()</st>`实现此编码方法，请访问本书的GitHub</st>
    <st c="53091">仓库：</st> [<st c="53103">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-06-Target-mean-encoding.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-06-Target-mean-encoding.ipynb)<st
    c="53260">。</st>
- en: <st c="53261">E</st><st c="53263">ncoding with Weight of E</st><st c="53287">vidence</st>
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="53261">使用证据权重进行编码</st><st c="53263"></st><st c="53287"></st>
- en: '**<st c="53295">Weight of Evidence</st>** <st c="53314">(</st>**<st c="53316">WoE</st>**<st
    c="53319">) was</st> <st c="53325">developed primarily for credit and financial
    industries to facilitate variable screening and exploratory</st> <st c="53431">analysis
    and to build more predictive linear models to evaluate the risk of</st> <st c="53507">loan
    defaults.</st>'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="53295">证据权重</st>** <st c="53314">(</st>**<st c="53316">WoE</st>**<st
    c="53319">) 主要是为了信用和金融行业开发的，以促进变量筛选和探索性</st> <st c="53431">分析，并构建更具有预测性的线性模型来评估</st>
    <st c="53507">贷款违约的风险。</st>'
- en: <st c="53521">The WoE is computed from the basic</st> <st c="53557">odds ratio:</st>
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53521">WoE 是从基本的</st> <st c="53557">优势比</st> 计算得出的：
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>WoE</mi><mo>=</mo><mi>log</mi><mrow><mrow><mo>(</mo><mfrac><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>s</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>n</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>s</mi></mrow></mfrac><mo>)</mo></mrow></mrow></mrow></mrow></math>](img/13.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>WoE</mi><mo>=</mo><mi>log</mi><mrow><mrow><mo>(</mo><mfrac><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>s</mi></mrow><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>n</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>s</mi><mi>e</mi><mi>s</mi></mrow></mfrac><mo>)</mo></mrow></mrow></mrow></mrow></math>](img/13.png)'
- en: <st c="53632">Here, positive and negative refer to the values of the target
    being</st> *<st c="53700">1</st>* <st c="53701">or</st> *<st c="53705">0</st>*<st
    c="53706">, respectively.</st> <st c="53722">The proportion of positive cases
    per category is determined as the sum of positive cases per category group divided
    by the total positive cases in the training set.</st> <st c="53887">The proportion
    of negative</st> <st c="53914">cases per category is determined as the sum of
    negative cases per category group divided by the total number of negative observations
    in the</st> <st c="54055">training set.</st>
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53632">在这里，正负分别指目标值的</st> *<st c="53700">1</st>* <st c="53701">或</st>
    *<st c="53705">0</st>*<st c="53706">。</st> <st c="53722">每个类别的正例比例是每个类别组正例总和除以训练集中正例总数。</st>
    <st c="53887">每个类别的负例比例是每个类别组负例总和除以训练集中负观察值的总数。</st>
- en: <st c="54068">WoE has the</st> <st c="54081">following characteristics:</st>
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54068">WoE 具有以下特性：</st>
- en: <st c="54107">WoE =</st> *<st c="54114">0</st>* <st c="54115">if</st> *<st c="54119">p(positive)</st>*
    <st c="54130">/</st> *<st c="54133">p(negative)</st>* <st c="54144">=</st> *<st
    c="54147">1</st>*<st c="54148">; that is, if the outcome</st> <st c="54174">is
    random</st>
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="54107">WoE =</st> *<st c="54114">0</st>* <st c="54115">if</st> *<st c="54119">p(positive)</st>*
    <st c="54130">/</st> *<st c="54133">p(negative)</st>* <st c="54144">=</st> *<st
    c="54147">1</st>*<st c="54148">; 即，如果结果</st> <st c="54174">是随机的</st>
- en: <st c="54183">WoE ></st> *<st c="54190">0</st>* <st c="54191">if</st> *<st c="54195">p(positive)</st>*
    <st c="54206">></st> *<st c="54209">p(negative)</st>*
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="54183">WoE ></st> *<st c="54190">0</st>* <st c="54191">if</st> *<st c="54195">p(positive)</st>*
    <st c="54206">></st> *<st c="54209">p(negative)</st>*
- en: <st c="54220">WoE <</st> *<st c="54227">0</st>* <st c="54228">if</st> *<st c="54232">p(negative)</st>*
    <st c="54243">></st> *<st c="54246">p(positive)</st>*
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="54220">如果</st> *<st c="54227">0</st>* <st c="54228">，则 WoE <</st> *<st
    c="54232">p(negative)</st>* <st c="54243">></st> *<st c="54246">p(positive)</st>*
- en: '<st c="54257">This allows us to directly visualize the predictive power of
    the category in the variable: the higher the WoE, the more likely the event will
    occur.</st> <st c="54407">If the WoE is positive, the event is likely</st> <st
    c="54451">to occur.</st>'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54257">这使我们能够直接可视化变量中类别的预测能力：WoE 越高，事件发生的可能性就越大。</st> <st c="54407">如果
    WoE 为正，则事件很可能发生。</st>
- en: <st c="54460">Logistic regression models a binary response,</st> *<st c="54507">Y</st>*<st
    c="54508">, based on</st> *<st c="54519">X</st>* <st c="54520">predictor variables,
    assuming that there is a linear relationship between</st> *<st c="54595">X</st>*
    <st c="54596">and the log of odds</st> <st c="54617">of</st> *<st c="54620">Y</st>*<st
    c="54621">:</st>
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54460">逻辑回归模型基于</st> *<st c="54507">Y</st>*<st c="54508">预测变量，对二元响应进行建模，假设</st>
    *<st c="54519">X</st>* <st c="54520">与</st> *<st c="54595">X</st>* <st c="54596">的对数几率之间存在线性关系</st>
    <st c="54617">：</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>log</mi><mfenced
    open="(" close=")"><mfrac><mrow><mi>p</mi><mfenced open="(" close=")"><mrow><mi>Y</mi><mo>=</mo><mn>1</mn></mrow></mfenced></mrow><mrow><mi>p</mi><mfenced
    open="(" close=")"><mrow><mi>Y</mi><mo>=</mo><mn>0</mn></mrow></mfenced></mrow></mfrac></mfenced><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><msub><mi>X</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><msub><mi>X</mi><mn>2</mn></msub><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>b</mi><mi>n</mi></msub><msub><mi>X</mi><mi>n</mi></msub></mrow></mrow></math>](img/14.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>log</mi><mfenced
    open="(" close=")"><mfrac><mrow><mi>p</mi><mfenced open="(" close=")"><mrow><mi>Y</mi><mo>=</mo><mn>1</mn></mrow></mfenced></mrow><mrow><mi>p</mi><mfenced
    open="(" close=")"><mrow><mi>Y</mi><mo>=</mo><mn>0</mn></mrow></mfenced></mrow></mfrac></mfenced><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><msub><mi>X</mi><mn>1</mn></msub><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><msub><mi>X</mi><mn>2</mn></msub><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>b</mi><mi>n</mi></msub><msub><mi>X</mi><mi>n</mi></msub></mrow></mrow></math>](img/14.png)'
- en: <st c="54655">Here,</st> *<st c="54661">log (p(Y=1)/p(Y=0))</st>* <st c="54680">is
    the log of odds.</st> <st c="54701">As you can see, the WoE encodes the categories
    in the same scale – that is, the log of odds – as the outcome of the</st> <st
    c="54817">logistic regression.</st>
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54655">在这里，</st> *<st c="54661">log (p(Y=1)/p(Y=0))</st>* <st c="54680">是对数几率。</st>
    <st c="54701">正如你所见，WOE将类别编码在对数几率——即逻辑回归的输出——的同一尺度上。</st>
- en: <st c="54837">Therefore, by using WoE, the predictors are prepared and coded
    on the same scale, and the parameters in the logistic regression model – that
    is, the coefficients – can be</st> <st c="55009">directly compared.</st>
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54837">因此，通过使用WOE，预测变量被准备并编码在同一尺度上，逻辑回归模型中的参数——即系数——可以</st> <st c="55009">直接比较。</st>
- en: <st c="55027">In this recipe</st><st c="55042">, we will perform WoE encoding
    using</st> `<st c="55079">pandas</st>` <st c="55085">and</st> `<st c="55090">feature-engine</st>`<st
    c="55104">.</st>
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55027">在这个菜谱中</st><st c="55042">，我们将使用</st> `<st c="55079">pandas</st>`
    <st c="55085">和</st> `<st c="55090">feature-engine</st>`<st c="55104">执行WOE编码。</st>
- en: <st c="55105">How to do it...</st>
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="55105">如何操作...</st>
- en: <st c="55121">Let’s begin by making some imports and preparing</st> <st c="55171">the
    data:</st>
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55121">让我们首先进行一些导入并准备</st> <st c="55171">数据：</st>
- en: <st c="55180">Import the required libraries</st> <st c="55211">and functions:</st>
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55180">导入所需的库</st> <st c="55211">和函数：</st>
- en: '[PRE95]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: <st c="55317">Let’s load</st> <st c="55329">the Credit Approval dataset and
    divide it into train and</st> <st c="55386">test sets:</st>
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55317">让我们加载</st> <st c="55329">信用批准数据集并将其分为训练集和</st> <st c="55386">测试集：</st>
- en: '[PRE96]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: <st c="55582">Let’s get the inverse of the target values to be able to calculate
    the</st> <st c="55654">negative cases:</st>
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55582">让我们求出目标值的逆，以便计算</st> <st c="55654">负案例：</st>
- en: '[PRE97]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: <st c="55746">Let’s determine the number of observations where the target variable
    takes a value of</st> `<st c="55833">1</st>` <st c="55834">or</st> `<st c="55837">0</st>`<st
    c="55838">:</st>
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55746">让我们确定目标变量取值为</st> `<st c="55833">1</st>` <st c="55834">或</st>
    `<st c="55837">0</st>`<st c="55838">的观测数：</st>
- en: '[PRE98]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: <st c="55896">Now, let’s calculate the numerator and denominator of the WoE’s
    formula, which we discussed earlier in</st> <st c="56000">this recipe:</st>
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55896">现在，让我们计算WOE公式的分子和分母，这是我们之前在这个菜谱中讨论过的：</st>
- en: '[PRE99]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: <st c="56128">Now, let’s</st> <st c="56139">calculate the WoE</st> <st c="56158">per
    category:</st>
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56128">现在，让我们</st> <st c="56139">计算每个类别的WOE：</st>
- en: '[PRE100]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: <st c="56193">We can display the series with the category to WoE pairs by</st>
    <st c="56254">executing</st> `<st c="56264">print(woe)</st>`<st c="56274">:</st>
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56193">我们可以通过执行</st> <st c="56254">print(woe)</st> <st c="56274">来显示类别与WOE对的序列：</st>
- en: '[PRE101]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: X_train_enc = X_train.copy()
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_train_enc = X_train.copy()
- en: X_test_enc = X_test.copy()
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_test_enc = X_test.copy()
- en: X_train_enc["A1"] = X_train_enc["A1"].map(woe)
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_train_enc["A1"] = X_train_enc["A1"].map(woe)
- en: X_test_enc["A1"] = X_test_enc["A1"].map(woe)
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_test_enc["A1"] = X_test_enc["A1"].map(woe)
- en: '[PRE102]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: <st c="56696">Let’s import</st> <st c="56710">the encoder:</st>
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56696">让我们导入</st> <st c="56710">编码器：</st>
- en: '[PRE103]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: <st c="56769">Next, let’s set up the encoder to encode three</st> <st c="56817">categorical
    variables:</st>
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56769">接下来，让我们设置编码器以编码三个</st> <st c="56817">分类变量：</st>
- en: '[PRE104]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: <st c="56893">Note</st>
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56893">注意</st>
- en: <st c="56898">For rare categories, it might happen that</st> `<st c="56941">p(0)=0</st>`
    <st c="56947">or</st> `<st c="56951">p(1)=0</st>`<st c="56957">, and then the
    division or the logarithm is not defined.</st> <st c="57014">To avoid this, group
    infrequent categories as shown in the</st> *<st c="57073">Grouping rare or infrequent</st>*
    *<st c="57101">categories</st>* <st c="57111">recipe.</st>
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于罕见类别，可能会发生<st c="56898">p(0)=0</st> <st c="56941">或</st> <st c="56951">p(1)=0</st><st
    c="56957">，此时除法或对数运算未定义。</st> <st c="57014">为了避免这种情况，可以将不常见的类别按以下</st> *<st c="57073">分组罕见或不常见</st>*
    *<st c="57101">类别</st>* <st c="57111">配方</st>进行分组。
- en: <st c="57119">Let’s fit the</st> <st c="57133">transformer to the train set
    so that it learns and stores the WoE of the</st> <st c="57207">different categories:</st>
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57119">让我们将</st> <st c="57133">转换器拟合到训练集，以便它学习并存储不同类别的WoE：</st>
- en: '[PRE105]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: <st c="57258">Note</st>
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57258">注意</st>
- en: <st c="57263">We can display the dictionaries with the categori</st><st c="57313">es
    to WoE pairs by</st> <st c="57333">executing</st> `<st c="57343">woe_enc.encoder_dict_</st>`<st
    c="57364">.</st>
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57263">我们可以通过执行</st> <st c="57333">woe_enc.encoder_dict_</st><st c="57364">来显示具有类别到WoE对的字典。</st>
- en: <st c="57365">Finally, let’s encode the three categorical variables in the train
    and</st> <st c="57437">test sets:</st>
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57365">最后，让我们对训练集和</st> <st c="57437">测试集中的三个分类变量进行编码：</st>
- en: '[PRE106]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`<st c="57527">feature-engine</st>` <st c="57542">returns</st> `<st c="57551">pandas</st>`
    <st c="57557">DataFrames, which contain the enco</st><st c="57592">ded categorical
    variables ready to use in machine</st> <st c="57643">learning models.</st>'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="57527">feature-engine</st>` <st c="57542">返回</st> `<st c="57551">pandas</st>`
    <st c="57557">DataFrames，其中包含可用于机器</st> <st c="57643">学习模型的编码分类变量。</st>'
- en: <st c="57659">How it works...</st>
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="57659">它是如何工作的...</st>
- en: <st c="57675">In this recipe, we encoded categorical variables using the WoE
    with</st> `<st c="57744">pandas</st>` <st c="57750">and</st> `<st c="57755">feature-engine</st>`<st
    c="57769">.</st>
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57675">在这个配方中，我们使用</st> `<st c="57744">pandas</st>` <st c="57750">和</st>
    `<st c="57755">feature-engine</st>`<st c="57769">对分类变量进行了WoE编码。</st>
- en: <st c="57770">We combined the use of</st> `<st c="57794">pandas</st>`<st c="57800">’</st>
    `<st c="57803">sum()</st>` <st c="57808">and</st> `<st c="57813">groupby()</st>`
    <st c="57822">and</st> `<st c="57827">numpy</st>`<st c="57832">’s</st> `<st c="57836">log()</st>`
    <st c="57841">to determine the WoE as we described at the beginning of</st> <st
    c="57899">this recipe.</st>
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57770">我们将</st> `<st c="57794">pandas</st>`<st c="57800">的</st> `<st
    c="57803">sum()</st>` <st c="57808">和</st> `<st c="57813">groupby()</st>` <st
    c="57822">以及</st> `<st c="57827">numpy</st>`<st c="57832">的</st> `<st c="57836">log()</st>`
    <st c="57841">结合起来，正如我们在本配方开头所描述的那样，来确定WoE。</st>
- en: <st c="57911">Next, we automated the procedure with</st> `<st c="57950">feature-engine</st>`<st
    c="57964">. We used the</st> `<st c="57978">WoEEncoder()</st>`<st c="57990">,
    which learned the WoE per category with the</st> `<st c="58036">fit()</st>` <st
    c="58041">method, and then used</st> `<st c="58064">tra</st><st c="58067">nsform()</st>`
    <st c="58076">to replace the categories with the</st> <st c="58112">corresponding
    numbers.</st>
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57911">接下来，我们使用</st> `<st c="57950">feature-engine</st>`<st c="57964">自动化了该过程。我们使用了</st>
    `<st c="57978">WoEEncoder()</st>`<st c="57990">，它通过</st> `<st c="58036">fit()</st>`
    <st c="58041">方法学习每个类别的WoE，然后使用</st> `<st c="58064">tra</st><st c="58067">nsform()</st>`
    <st c="58076">将类别替换为相应的数字。</st>
- en: <st c="58134">See also</st>
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="58134">另请参阅</st>
- en: <st c="58143">For an implementation of WoE with Category Encoders, visit this
    book’s GitHub</st> <st c="58222">repository:</st> [<st c="58234">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/m</st><st
    c="58325">ain/ch02-categorical-encoding/Recipe-07-Weight-of-evidence.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-07-Weight-of-evidence.ipynb)<st
    c="58390">.</st>
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58143">有关使用类别编码器实现WoE的示例，请访问本书的GitHub</st> <st c="58222">存储库：</st> [<st
    c="58234">https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/m</st><st
    c="58325">ain/ch02-categorical-encoding/Recipe-07-Weight-of-evidence.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-engineering-Cookbook-Third-Edition/blob/main/ch02-categorical-encoding/Recipe-07-Weight-of-evidence.ipynb)<st
    c="58390">。</st>
- en: <st c="58391">Grouping rare or infrequent categories</st>
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="58391">分组罕见或不常见类别</st>
- en: <st c="58430">Rare categories are those</st> <st c="58457">presen</st><st c="58463">t
    only in a small fraction of the observations.</st> <st c="58512">There is no rule
    of thumb to determine how small a small fraction is, b</st><st c="58583">ut typically,
    any value below 5% can be</st> <st c="58624">considered rare.</st>
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58430">稀疏类别只出现在观测值的一小部分中。</st> <st c="58457">没有经验法则来确定多小的一小部分，但通常，任何低于5%的值都可以</st>
    <st c="58583">被认为是稀疏的。</st>
- en: <st c="58640">Infrequent labels often</st> <st c="58664">appear only on the
    train set or only on the test set, thus making the algorithms prone to overfitting
    or being unable to score an observation.</st> <st c="58808">In addition, when
    encoding categories to numbers, we only create mappings for those categories observed
    in the train set, so we won’t know how to encode new labels.</st> <st c="58973">T</st><st
    c="58974">o avoid these complications, we can group infrequent categories into
    a single category called</st> `<st c="59068">Rare</st>` <st c="59072">or</st>
    `<st c="59076">Other</st>`<st c="59081">.</st>
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58640">不频繁的标签通常</st> <st c="58664">只出现在训练集或测试集中，这使得算法容易过拟合或无法对观测值进行评分。</st>
    <st c="58808">此外，当将类别编码为数字时，我们只为训练集中观察到的类别创建映射，因此我们不知道如何编码新的标签。</st> <st c="58973">为了避免这些复杂性，我们可以将不频繁的类别组合成一个称为</st>
    `<st c="59068">Rare</st>` <st c="59072">或</st> `<st c="59076">Other</st>` <st
    c="59081">的单一类别。</st>
- en: <st c="59082">In this recipe,</st> <st c="59099">we will group infrequent categories
    using</st> `<st c="59141">pandas</st>` <st c="59147">and</st> `<st c="59152">feature-engine</st>`<st
    c="59166">.</st>
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59082">在这个菜谱中，</st> <st c="59099">我们将使用</st> `<st c="59141">pandas</st>`
    <st c="59147">和</st> `<st c="59152">feature-engine</st>` <st c="59166">将不频繁的类别进行分组。</st>
- en: <st c="59167">How to do it...</st>
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="59167">如何操作...</st>
- en: <st c="59183">First, let’s import the necessary Python libraries and get the</st>
    <st c="59247">dataset ready:</st>
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59183">首先，让我们导入必要的Python库并准备好数据集：</st>
- en: <st c="59261">Import the necessary Python libraries, functions,</st> <st c="59312">and
    classes:</st>
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="59261">导入必要的Python库、函数和类：</st>
- en: '[PRE107]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: <st c="59469">Let’s load the Credit Approval dataset and divide it into train
    and</st> <st c="59538">test sets:</st>
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="59469">让我们加载Credit Approval数据集并将其分为训练集和</st> <st c="59538">测试集：</st>
- en: '[PRE108]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: <st c="59735">Let’s</st> <st c="59742">capture the fraction of observations
    per category in</st> `<st c="59795">A7</st>` <st c="59797">in</st> <st c="59801">a
    variable:</st>
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="59735">让我们</st> <st c="59742">捕获</st> <st c="59795">A7</st> <st c="59797">中每个类别的观测值比例</st>
    <st c="59801">在一个变量中：</st>
- en: '[PRE109]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: <st c="59863">We can see the percentage of observations per category of</st>
    `<st c="59922">A7</st>`<st c="59924">, expressed as decimals, in the following
    output after</st> <st c="59979">executing</st> `<st c="59989">print(freqs)</st>`<st
    c="60001">:</st>
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="59863">我们可以看到以下输出中</st> <st c="59922">A7</st> <st c="59924">每个类别的观测值比例，以小数表示，在执行</st>
    `<st c="59989">print(freqs)</st>` <st c="60001">之后：</st>
- en: '[PRE110]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: <st c="60282">Let’s create a list containing the names of the categories present
    in more than 5% of</st> <st c="60369">the observations:</st>
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60282">让我们创建一个包含在超过5%的</st> <st c="60369">观测中存在的类别名称的列表：</st>
- en: '[PRE111]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: <st c="60452">If we execute</st> `<st c="60467">print(frequent_cat)</st>`<st
    c="60486">, we will see the frequent categories</st> <st c="60524">of</st> `<st
    c="60527">A7</st>`<st c="60529">:</st>
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="60452">如果我们执行</st> `<st c="60467">print(frequent_cat)</st>`<st c="60486">，我们将看到</st>
    <st c="60524">A7</st> <st c="60529">的</st>频繁类别：</st>
- en: '[PRE112]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: X_train_enc = X_train.copy()
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_train_enc = X_train.copy()
- en: X_test_enc = X_test.copy()
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_test_enc = X_test.copy()
- en: X_train_enc["A7"] = np.where(X_train["A7"].isin(
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_train_enc["A7"] = np.where(X_train["A7"].isin(
- en: frequent_cat), X_train["A7"], "Rare")
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: frequent_cat), X_train["A7"], "Rare")
- en: X_test_enc["A7"] = np.where(X_test["A7"].isin(
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X_test_enc["A7"] = np.where(X_test["A7"].isin(
- en: frequent_cat), X_test["A7"], "Rare")
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: frequent_cat), X_test["A7"], "Rare")
- en: '[PRE113]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: <st c="60911">Let’s determine the percentage of observations in the</st> <st
    c="60966">encoded variable:</st>
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60911">让我们确定编码变量的观测值百分比：</st>
- en: '[PRE114]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: <st c="61026">We can see that the infrequent labels have now been re-grouped
    into the</st> `<st c="61099">Rare</st>` <st c="61103">category:</st>
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="61026">我们可以看到不频繁的标签现在已经被重新组合到</st> `<st c="61099">Rare</st>` <st c="61103">类别中：</st>
- en: '[PRE115]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: <st c="61251">Let’s</st> <st c="61257">create a rare label encoder that groups
    categories present in less than 5% of the observations, provided that the categorical
    variable has more than four</st> <st c="61412">distinct values:</st>
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="61251">让我们</st> <st c="61257">创建一个稀疏标签编码器，将出现在观测值不到5%的类别组合在一起，前提是分类变量有超过四个</st>
    <st c="61412">不同值：</st>
- en: '[PRE116]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: <st c="61486">Let’s fit the encoder so that it finds the categorical variables
    and then learns their most</st> <st c="61579">frequent categories:</st>
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="61486">让我们拟合编码器，以便它找到分类变量，然后学习它们的最高频率类别：</st>`'
- en: '[PRE117]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: <st c="61625">Note</st>
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="61625">注意</st>`'
- en: <st c="61630">Upon fitting, the transformer will raise warnings, indicating
    that many categorical variables have less than four categories, thus their values
    will not be grouped.</st> <st c="61796">The transformer just lets you know that
    this</st> <st c="61841">is happening.</st>
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="61630">在拟合过程中，转换器将发出警告，表明许多分类变量少于四个类别，因此它们的值不会被分组。</st> <st c="61796">转换器只是通知你这种情况正在发生。</st>`'
- en: <st c="61854">We can display the frequent categories per variable by executing</st>
    `<st c="61920">rare_encoder.encoder_dict_</st>`<st c="61946">, as well as the
    variables that will be encoded by</st> <st c="61997">executing</st> `<st c="62007">rare_encoder.variables_</st>`<st
    c="62030">.</st>
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行`<st c="61920">rare_encoder.encoder_dict_</st>`<st c="61946">来显示每个变量的频繁类别，以及通过执行`<st
    c="61997">executing</st>` `<st c="62007">rare_encoder.variables_</st>`<st c="62030">`将被编码的变量。</st>
- en: <st c="62031">Finally, let’s group rare labels in the train and</st> <st c="62082">test
    sets:</st>
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将训练集和测试集中的稀有标签分组：</st> <st c="62082"></st>
- en: '[PRE118]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: <st c="62182">Now that we have grouped rare labels, we are ready to encode the
    catego</st><st c="62254">rical variables, as we’ve done in the previous recipes
    in</st> <st c="62313">this chapter.</st>
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将稀有标签分组，我们准备对分类变量进行编码，就像我们在本章前面的食谱中所做的那样。</st>
- en: <st c="62326">How it works...</st>
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="62326">它的工作原理...</st>`'
- en: <st c="62342">In this recipe, we grouped infrequent categories using</st> `<st
    c="62398">pandas</st>` <st c="62404">and</st> `<st c="62409">feature-engine</st>`<st
    c="62423">.</st>
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="62342">在这个食谱中，我们使用`<st c="62398">pandas</st>` <st c="62404">和`<st c="62409">feature-engine</st>`<st
    c="62423">将不频繁的类别分组。</st>`'
- en: <st c="62424">We determined</st> <st c="62438">the fraction of observations
    per category of the</st> `<st c="62488">A7</st>` <st c="62490">variable using</st>
    `<st c="62506">pandas</st>`<st c="62512">’</st> `<st c="62515">value_counts()</st>`
    <st c="62529">by setting the</st> `<st c="62545">normalize</st>` <st c="62554">parameter
    to</st> `<st c="62568">True</st>`<st c="62572">. Using list comprehension, we
    captured the names of the variables present in more than 5% of the observations.</st>
    <st c="62684">Finally, u</st><st c="62694">sing NumPy’s</st> `<st c="62708">where()</st>`<st
    c="62715">, we searched each row of</st> `<st c="62741">A7</st>`<st c="62743">,
    and if</st> <st c="62752">the observation was one of the frequent categories in
    the list, which we checked using</st> `<st c="62839">pandas</st>`<st c="62845">’</st>
    `<st c="62848">isin()</st>`<st c="62854">, its value was kept; otherwise, it was
    replaced</st> <st c="62903">with</st> `<st c="62908">Rare</st>`<st c="62912">.</st>
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确定了`<st c="62488">A7</st>` <st c="62490">变量每个类别的观测值比例，使用了`<st c="62506">pandas</st>`<st
    c="62512">’</st> `<st c="62515">value_counts()</st>` <st c="62529">函数，通过将`<st
    c="62545">normalize</st>` <st c="62554">参数设置为`<st c="62568">True</st>`<st c="62572">。使用列表推导，我们捕获了在超过5%的观测值中存在的变量名称。</st>
    <st c="62684">最后，使用NumPy的`<st c="62708">where()</st>`<st c="62715">函数，我们搜索了`<st
    c="62741">A7</st>`<st c="62743">的每一行，如果观测值是列表中的频繁类别之一，我们使用`<st c="62839">pandas</st>`<st
    c="62845">’</st> `<st c="62848">isin()</st>`<st c="62854">进行检查，则保留其值；否则，将其替换为`<st
    c="62908">Rare</st>`<st c="62912">。</st>
- en: <st c="62913">We automated the preceding steps for multiple categorical variables
    using</st> `<st c="62988">feature-engine</st>`<st c="63002">’s</st> `<st c="63006">RareLabelEncoder()</st>`<st
    c="63024">. By setting</st> `<st c="63037">tol</st>` <st c="63040">to</st> `<st
    c="63044">0.05</st>`<st c="63048">, we retained categories present in more than
    5% of the observations.</st> <st c="63118">By setting</st> `<st c="63129">n_categories</st>`
    <st c="63141">to</st> `<st c="63145">4</st>`<st c="63146">, we only grouped categories
    in variables with more than four unique values.</st> <st c="63223">With</st> `<st
    c="63228">fit()</st>`<st c="63233">, the transformer identified the categorical
    variables and then learned and stored their frequent categories.</st> <st c="63343">With</st>
    `<st c="63348">transform</st><st c="63357">()</st>`<st c="63360">, the transformer
    replaced infrequent categories with the</st> `<st c="63418">Rare</st>` <st c="63422">string.</st>
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62913">我们使用</st> `<st c="62988">feature-engine</st>`<st c="63002">的</st>
    `<st c="63006">RareLabelEncoder()</st>`<st c="63024">自动化了前面提到的多个分类变量的步骤。通过将</st>
    `<st c="63037">tol</st>` <st c="63040">设置为</st> `<st c="63044">0.05</st>`<st c="63048">，我们保留了在超过5%的观测中存在的类别。</st>
    <st c="63118">通过将</st> `<st c="63129">n_categories</st>` <st c="63141">设置为</st>
    `<st c="63145">4</st>`<st c="63146">，我们只对具有超过四个唯一值的变量中的类别进行分组。</st> <st c="63223">使用</st>
    `<st c="63228">fit()</st>`<st c="63233">，转换器识别了分类变量，然后学习并存储了它们的频繁类别。</st> <st
    c="63343">使用</st> `<st c="63348">transform</st><st c="63357">()</st>`<st c="63360">，转换器将不频繁的类别替换为</st>
    `<st c="63418">Rare</st>` <st c="63422">字符串。</st>
- en: <st c="63430">Performing b</st><st c="63443">inary encoding</st>
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="63430">执行二进制编码</st>
- en: '`<st c="63808">1</st>` <st c="63809">can be represented with the sequence of</st>
    `<st c="63850">1-0</st>`<st c="63853">, integer</st> `<st c="63863">2</st>` <st
    c="63864">with</st> `<st c="63870">0-1</st>`<st c="63873">, integer</st> `<st
    c="63883">3</st>` <st c="63884">with</st> `<st c="63890">1-1</st>`<st c="63893">,
    and integer</st> `<st c="63907">0</st>` <st c="63908">with</st> `<st c="63914">0-0</st>`<st
    c="63917">. The digits in the two positions of the binary string become the</st>
    <st c="63982">columns, which are the encoded representations of the</st> <st c="64037">original
    variable:</st>'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="63808">1</st>` <st c="63809">可以用序列</st> `<st c="63850">1-0</st>`<st
    c="63853">表示，整数</st> `<st c="63863">2</st>` <st c="63864">可以用</st> `<st c="63870">0-1</st>`<st
    c="63873">表示，整数</st> `<st c="63883">3</st>` <st c="63884">可以用</st> `<st c="63890">1-1</st>`<st
    c="63893">表示，整数</st> `<st c="63907">0</st>` <st c="63908">可以用</st> `<st c="63914">0-0</st>`<st
    c="63917">表示。二进制字符串的两个位置的数字成为</st> <st c="63982">列，这些列是原始变量的编码表示：</st>'
- en: '![Figure 2.10 – Table showing the steps required for binary encoding the color
    variable](img/B22396_02_10.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.10 – 表格显示对颜色变量进行二进制编码所需的步骤](img/B22396_02_10.jpg)'
- en: <st c="64134">Figure 2.10 – Table showing the steps required for binary encoding
    the color variable</st>
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64134">Figure 2.10 – 表格显示对颜色变量进行二进制编码所需的步骤</st>
- en: <st c="64219">Binary encoding</st> <st c="64236">encodes the data in fewer dimensions
    than one-hot encoding.</st> <st c="64296">In our example, the</st> `<st c="64316">Color</st>`
    <st c="64321">variable would be encoded into</st> *<st c="64353">k-1</st>* <st
    c="64356">categories by one-hot encoding – that is, three variables – but with
    binary encoding, we can represent the variable with only two features.</st> <st
    c="64497">More generally, we determine the number of binary features needed to
    encode a variable as</st> *<st c="64587">log2(number of distinct</st> <st c="64610">categories)</st>*<st
    c="64622">; in our example,</st> *<st c="64641">log2(4) = 2</st>* <st c="64652">binary
    features.</st>
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64219">二进制编码</st> <st c="64236">比独热编码使用更少的维度。</st> <st c="64296">在我们的例子中，</st>
    `<st c="64316">颜色</st>` <st c="64321">变量将通过独热编码被编码为</st> *<st c="64353">k-1</st>*
    <st c="64356">个类别——即三个变量——但使用二进制编码，我们可以只用两个特征来表示该变量。</st> <st c="64497">更一般地，我们确定编码一个变量所需的二进制特征数量为</st>
    *<st c="64587">log2(不同类别的数量)</st>*<st c="64622">；在我们的例子中，</st> *<st c="64641">log2(4)
    = 2</st>* <st c="64652">二进制特征。</st>
- en: <st c="64669">Binary encoding is an alternative method to one-hot encoding where
    we do not lose information about the variable, yet we obtain fewer features after
    the encoding.</st> <st c="64833">This is particularly useful when we have highly
    cardinal variables.</st> <st c="64901">For example, if a variable contains 128
    unique categories, with one-hot encoding, we would need 127 features to encode
    the variable, whereas with binary encoding, we will only need</st> *<st c="65082">7
    (log2(128)=7)</st>*<st c="65097">. Thus, this encoding prevents the feature space
    from exploding.</st> <st c="65162">In addition, binary-encoded features are also
    suitable for linear models.</st> <st c="65236">On the downside, the derived binary
    features lack human interpretability, so if we need to interpret the decisions
    made by our models, this encoding method may not be a</st> <st c="65405">suitable
    option.</st>
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64669">二进制编码是one-hot编码的替代方法，其中我们不会丢失关于变量的信息，但在编码后我们获得更少的特征。</st> <st
    c="64833">这在处理高度基数变量时特别有用。</st> <st c="64901">例如，如果一个变量包含128个唯一类别，使用one-hot编码，我们需要127个特征来编码该变量，而使用二进制编码，我们只需要</st>
    *<st c="65082">7 (log2(128)=7)</st>*<st c="65097">。因此，这种编码防止了特征空间的爆炸。</st> <st
    c="65162">此外，二进制编码的特征也适合线性模型。</st> <st c="65236">然而，从衍生出的二进制特征中缺乏人类可解释性，因此如果我们需要解释模型所做的决策，这种编码方法可能不是一个</st>
    <st c="65405">合适的选择。</st>
- en: <st c="65421">In this rec</st><st c="65433">ipe, we will learn how to perform
    binary encoding using</st> <st c="65490">Category Encoders.</st>
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65421">在这个例子中，我们将学习如何使用</st> <st c="65490">类别编码器</st> <st c="65433">执行二进制编码。</st>
- en: <st c="65508">How to do it...</st>
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="65508">如何做到这一点...</st>
- en: <st c="65524">First, let’s import the necessary Python libraries and get the</st>
    <st c="65588">dataset ready:</st>
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65524">首先，让我们导入必要的Python库并准备好</st> <st c="65588">数据集：</st>
- en: <st c="65602">Import the required Python libraries, functions,</st> <st c="65652">and
    classes:</st>
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="65602">导入所需的Python库、函数、</st> <st c="65652">和类：</st>
- en: '[PRE119]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: <st c="65788">Let’s load the Credit Approval dataset and divide it into train
    and</st> <st c="65857">test sets:</st>
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="65788">让我们加载Credit Approval数据集并将其分为训练集和</st> <st c="65857">测试集：</st>
- en: '[PRE120]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: <st c="66053">Let’s inspect</st> <st c="66067">the unique categories</st> <st
    c="66090">in</st> `<st c="66093">A7</st>`<st c="66095">:</st>
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66053">让我们检查</st> <st c="66067">`A7`</st> <st c="66090">中的唯一类别：</st>
- en: '[PRE121]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: <st c="66120">In the following output, we can see that</st> `<st c="66162">A7</st>`
    <st c="66164">has 10</st> <st c="66172">different categories:</st>
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="66120">在以下输出中，我们可以看到</st> `<st c="66162">A7</st>` <st c="66164">有10</st>
    <st c="66172">个不同的类别：</st>
- en: '[PRE122]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: encoder = BinaryEncoder(cols=["A7"],
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: encoder = BinaryEncoder(cols=["A7"],
- en: drop_invariant=True)
  id: totrans-565
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: drop_invariant=True)
- en: '[PRE123]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: <st c="66377">Note</st>
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66377">注意</st>
- en: '`<st c="66382">BinaryEncoder()</st>`<st c="66398">, as well as other encoders
    from the Category Encoders package, allow us to select the variables to encode.</st>
    <st c="66506">We simply pass the column names in a list to the</st> `<st c="66555">cols</st>`
    <st c="66559">argument.</st>'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="66382">BinaryEncoder()</st>`<st c="66398">，以及其他来自类别编码器包的编码器，允许我们选择要编码的变量。</st>
    <st c="66506">我们只需将列名列表传递给</st> `<st c="66555">cols</st>` <st c="66559">参数。</st>'
- en: <st c="66569">Let’s fit the transformer to the train set so that it calculates
    how many binary variables it needs and creates the variable-to-binary</st> <st
    c="66705">code representations:</st>
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66569">让我们将转换器拟合到训练集中，以便它计算所需的二进制变量数量并创建变量到二进制</st> <st c="66705">代码表示：</st>
- en: '[PRE124]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: <st c="66747">Finally, let’s encode</st> `<st c="66770">A7</st>` <st c="66772">in
    the train and</st> <st c="66790">test sets:</st>
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66747">最后，让我们将</st> `<st c="66770">A7</st>` <st c="66772">编码到训练集和测试集中：</st>
- en: '[PRE125]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: <st c="66880">We can</st> <st c="66887">display the top rows of the transformed
    train set</st> <st c="66938">by executing</st> `<st c="66951">print(X_train_enc.head())</st>`<st
    c="66976">, which returns the</st> <st c="66996">following output:</st>
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="66880">我们可以</st> <st c="66887">通过执行</st> `<st c="66951">print(X_train_enc.head())</st>`<st
    c="66976">来显示转换后的训练集的前几行，它返回以下输出：</st>
- en: '![Figure 2.11 – DataFrame with the variables after binary encoding](img/B22396_02_11.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 二进制编码后的变量DataFrame](img/B22396_02_11.jpg)'
- en: <st c="67333">Figure 2.11 – DataFrame with the variables after binary encoding</st>
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67333">图2.11 – 二进制编码后的变量DataFrame</st>
- en: <st c="67397">Binary encoding returned four binary variables for</st> `<st c="67449">A7</st>`<st
    c="67451">, which are</st> `<st c="67463">A7_0</st>`<st c="67467">,</st> `<st
    c="67469">A7_1</st>`<st c="67473">,</st> `<st c="67475">A7_2</st>`<st c="67479">,
    and</st> `<st c="67485">A</st><st c="67486">7_3</st>`<st c="67489">, instead of
    the nine that would have been returned by</st> <st c="67544">one-hot encoding.</st>
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67397">二进制编码为</st> `<st c="67449">A7</st>`<st c="67451">返回了四个二进制变量，分别是</st>
    `<st c="67463">A7_0</st>`<st c="67467">,</st> `<st c="67469">A7_1</st>`<st c="67473">,</st>
    `<st c="67475">A7_2</st>`<st c="67479">，和</st> `<st c="67485">A</st><st c="67486">7_3</st>`<st
    c="67489">，而不是由one-hot编码返回的九个变量。</st>
- en: <st c="67561">How it works...</st>
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="67561">它是如何工作的...</st>
- en: <st c="67577">In this recipe, we performed binary encoding using the Category
    Encoders package.</st> <st c="67660">We used</st> `<st c="67668">BinaryEncoder()</st>`
    <st c="67683">to encode the</st> `<st c="67698">A</st><st c="67699">7</st>` <st
    c="67700">variable.</st> <st c="67711">With the</st> `<st c="67720">fit()</st>`
    <st c="67725">method,</st> `<st c="67734">BinaryEncoder()</st>` <st c="67749">created
    a mapping from a category to a set of binary columns, and with the</st> `<st c="67825">transform()</st>`
    <st c="67836">method, the encoder encoded the</st> `<st c="67869">A7</st>` <st
    c="67871">variable in both the train and</st> <st c="67903">test sets.</st>****
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了Category Encoders包进行二进制编码。<st c="67660">我们使用了</st> `<st c="67668">BinaryEncoder()</st>`
    <st c="67683">来编码</st> `<st c="67698">A</st><st c="67699">7</st>` <st c="67700">变量。</st>
    <st c="67711">使用</st> `<st c="67720">fit()</st>` <st c="67725">方法，</st> `<st c="67734">BinaryEncoder()</st>`
    <st c="67749">创建了一个从类别到一组二进制列的映射，并且使用</st> `<st c="67825">transform()</st>` <st
    c="67836">方法，编码器在训练集和</st> <st c="67903">测试集</st> <st c="67905">中对</st> `<st c="67869">A7</st>`
    <st c="67871">变量进行了编码。</st>****
