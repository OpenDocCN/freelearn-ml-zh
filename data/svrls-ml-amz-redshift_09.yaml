- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Deep Learning with Redshift ML
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redshift ML进行深度学习
- en: We explored **supervised learning** in *Chapters 6* and *7* and **unsupervised
    learning** models in [*Chapter 8*](B19071_08.xhtml#_idTextAnchor139). In this
    chapter, we will explore **deep learning algorithms**, a **multilayer perceptron**
    (**MLP**), which is a **feedforward artificial neural network** (**ANN**), and
    understand how it handles data that is not linearly separable (which means the
    data points in your data cannot be separated by a clear line). This chapter will
    provide detailed steps on how to perform deep learning in Amazon Redshift ML using
    MLP. By the end of this chapter, you will be in a position to identify a business
    problem that can be solved using MLP and know how to create the model, evaluate
    the performance of the model, and run predictions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第6章*和*第7章*中探讨了**监督学习**，在[*第8章*](B19071_08.xhtml#_idTextAnchor139)中探讨了**无监督学习**模型。在本章中，我们将探讨**深度学习算法**，一个**多层感知器**（**MLP**），它是一个**前馈人工神经网络**（**ANN**），并了解它如何处理非线性可分的数据（这意味着你的数据点不能通过一条清晰的线分离）。本章将提供如何在Amazon
    Redshift ML中使用MLP进行深度学习的详细步骤。到本章结束时，你将能够识别出可以使用MLP解决的问题，并了解如何创建模型、评估模型性能以及运行预测。
- en: 'In this chapter, we will go through the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主要主题：
- en: Introduction to deep learning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习简介
- en: Business problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业问题
- en: Uploading and analyzing the data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传和分析数据
- en: Creating a multiclass classification model using MLP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MLP创建多类分类模型
- en: Running predictions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行预测
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires a web browser and access to the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要网络浏览器以及访问以下内容：
- en: AWS account
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS账户
- en: Amazon Redshift Serverless endpoint
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Redshift无服务器端点
- en: Amazon Redshift Query Editor v2
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Redshift查询编辑器v2
- en: 'You can find the code used in this chapter here: [https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter9/chapter9.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter9/chapter9.sql).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处找到本章使用的代码：[https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter9/chapter9.sql](https://github.com/PacktPublishing/Serverless-Machine-Learning-with-Amazon-Redshift/blob/main/CodeFiles/chapter9/chapter9.sql)。
- en: Introduction to deep learning
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度学习简介
- en: Deep learning is a type of **artificial intelligence** (**AI**) that uses algorithms
    to analyze and learn data to draw output similar to the way humans do. Deep learning
    can leverage both supervised and unsupervised learning using **artificial neural
    networks** (**ANNs**). In deep learning, a set of outputs is generated from the
    input layers using a feedforward ANN called an MLP. The MLP utilizes backpropagation
    to feed the errors from the outputs back into the layers to compute one layer
    at a time and iterates until the model has learned the patterns and relationships
    in the input data to arrive at a specific output.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习是一种使用算法分析和学习数据以产生类似人类输出的**人工智能**（**AI**）。深度学习可以利用**人工神经网络**（**ANNs**）进行监督学习和无监督学习。在深度学习中，通过一个称为MLP的前馈ANN（多层感知器）从输入层生成一系列输出。MLP利用反向传播将输出中的错误反馈到层中，一次计算一层，直到模型学会了输入数据中的模式和关系，从而得到特定的输出。
- en: '**Feature learning** is a set of techniques where the machine uses raw data
    to derive the characteristics of a class in the data to derive a specific task
    at hand. Deep learning models use feature learning efficiently to learn complex,
    redundant, and variable input data and classify the specified task. Thus, it eliminates
    the need for manual feature engineering for designing and selecting the input
    features. Deep learning is very useful when your datasets cannot be separated
    by a straight line, known as non-linear data.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**特征学习**是一组技术，其中机器使用原始数据推导出数据中类的特征，以推导出特定任务。深度学习模型有效地使用特征学习来学习复杂、冗余和可变输入数据，并对指定任务进行分类。因此，它消除了手动特征工程来设计和选择输入特征的需求。当你的数据集不能通过一条直线（称为非线性数据）分离时，深度学习非常有用。'
- en: For example, in classifying financial transactions as fraudulent or legitimate,
    there may not be a clear linear boundary between the two classes of data. In such
    cases, deep learning models can learn these variable and complex non-linear relationships
    between the features of the input data and thus improve the accuracy of the target
    classification.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在将金融交易分类为欺诈或合法时，两个数据类别之间可能没有明确的线性边界。在这种情况下，深度学习模型可以学习输入数据特征之间的这些可变和复杂的非线性关系，从而提高目标分类的准确性。
- en: 'When working on classification problems, an easy way to determine whether your
    dataset is linearly separated is to draw a scatter plot for classes and see whether
    two classes can be separated by a line or not. In the following diagram, the left-hand
    chart shows that two classes are linearly separated and the right-hand chart shows
    that they are not:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理分类问题时，确定您的数据集是否线性分离的一个简单方法是为类别绘制散点图，看看两个类别是否可以通过一条线来分离。在下面的图中，左侧图表显示两个类别是线性分离的，而右侧图表显示它们不是：
- en: '![Figure 9.1 – Linear versus non-linear datasets](img/B19071_09_001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 线性与非线性数据集](img/B19071_09_001.jpg)'
- en: Figure 9.1 – Linear versus non-linear datasets
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 线性与非线性数据集
- en: 'You can create models in Redshift ML when your dataset cannot be linearly separated
    by using the MLP algorithm. Common use cases where MLP algorithms are useful are
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的数据集无法通过MLP算法线性分离时，您可以在Redshift ML中创建模型。MLP算法有用的常见用例如下：
- en: Speech recognition
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语音识别
- en: Image recognition
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像识别
- en: Machine translation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器翻译
- en: This chapter will show you how to build deep learning models in Amazon Redshift
    ML using the MLP algorithm.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何使用MLP算法在Amazon Redshift ML中构建深度学习模型。
- en: Business problem
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业问题
- en: We will use a wall-following robot navigation dataset to build a machine learning
    model using the MLP algorithm. The robot is equipped with ultrasound sensors and
    data is collected as the robot navigates through the room in a clockwise direction.
    The goal here is to guide the robot to follow the wall by giving simple directions
    such as *Move-Forward*, *Slight-Right-Turn*, *Sharp-Right-Turn*, and *Slight-Left-Turn*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个跟随墙壁的机器人导航数据集，使用MLP算法构建机器学习模型。机器人配备了超声波传感器，当机器人在顺时针方向穿过房间时，数据被收集。这里的目的是通过给出简单的指令，如*前进*、*轻微右转*、*急右转*和*轻微左转*，来引导机器人沿着墙壁行走。
- en: 'Since there are classes to predict for a given set of sensor readings, this
    is going to be a multiclass problem. We will use MLP to correctly guide the robot
    to follow the wall. (This data is taken from [https://archive.ics.uci.edu/ml/datasets/Wall-Following+Robot+Navigation+Data](https://archive.ics.uci.edu/ml/datasets/Wall-Following+Robot+Navigation+Data)
    and is attributed to Ananda Freire, Marcus Veloso, and Guilherme Barreto (2019).
    UCI Machine Learning Repository [[http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml)].
    Irvine, CA: University of California, School of Information and Computer Science.)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对于一组给定的传感器读数存在要预测的类别，这将是一个多类问题。我们将使用MLP来正确引导机器人沿着墙壁行走。（此数据来自[https://archive.ics.uci.edu/ml/datasets/Wall-Following+Robot+Navigation+Data](https://archive.ics.uci.edu/ml/datasets/Wall-Following+Robot+Navigation+Data)，归功于Ananda
    Freire、Marcus Veloso和Guilherme Barreto（2019）。UCI机器学习库[[http://archive.ics.uci.edu/ml](http://archive.ics.uci.edu/ml)]。加州大学欧文分校：加州大学信息与计算机科学学院。）
- en: Please follow the detailed document on the page to gain more understanding of
    the use case.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请遵循页面上的详细文档以了解更多关于用例的使用。
- en: Now, you will upload the data, analyze it, and prepare for training the model.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将上传数据，分析它，并为训练模型做准备。
- en: Uploading and analyzing the data
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传和分析数据
- en: 'We have sensor readings data stored in the following S3 location:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下S3位置存储了传感器读数数据：
- en: '`s3://packt-serverless-ml-redshift/chapter09/`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`s3://packt-serverless-ml-redshift/chapter09/`'
- en: 'After successfully connecting to Redshift as an admin or database developer,
    load data into Amazon Redshift:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 成功连接到Redshift作为管理员或数据库开发者后，将数据加载到Amazon Redshift中：
- en: 'Navigate to **Redshift query editor v2** and connect to **Serverless: workgroup2**
    and then to the **dev** database:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '导航到**Redshift查询编辑器v2**，连接到**Serverless: workgroup2**，然后连接到**dev**数据库：'
- en: '![Figure 9.2 – Connect to the dev database](img/B19071_09_002.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 连接到开发数据库](img/B19071_09_002.jpg)'
- en: Figure 9.2 – Connect to the dev database
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 连接到开发数据库
- en: 'Execute the following steps to create the schema and customer table, and load
    the data:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建模式和客户表，并加载数据：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the following query to examine some sample data:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下查询以检查一些样本数据：
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In *Figure 9**.3*, we can see that our data has been loaded successfully:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9*.3中，我们可以看到我们的数据已成功加载：
- en: '![Figure 9.3 – Sample output](img/B19071_09_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 样本输出](img/B19071_09_003.jpg)'
- en: Figure 9.3 – Sample output
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 样本输出
- en: 'From the preceding screenshot, we can see that there are several sensor readings.
    Run the following query to see the distribution of the different directions of
    the robot’s movements, as shown in *Figure 9**.4*:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图，我们可以看到有几个传感器读数。运行以下查询以查看机器人运动的不同方向的分布，如图*图9*.4所示：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To view the results as a bar graph, please click on the toggle **C****hart**
    button (![](img/B19071_09_Icone_1.png)) on the **Result** pane. Under **Traces**,
    click on **+ Trace** (![](img/B19071_09_Icone_2.png)) and set **Type** as **Bar**,
    **X-axis** as **Direction**, and **Y-axis** as **Count** from the dropdown. Keep
    **Orientation** as **Vertical**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要将结果以柱状图的形式查看，请点击**结果**面板上的**图表**切换按钮 (![](img/B19071_09_Icone_1.png))。在**跟踪**下，点击**+
    跟踪** (![](img/B19071_09_Icone_2.png))，并将**类型**设置为**柱状图**，**X轴**设置为**方向**，**Y轴**从下拉菜单中选择**计数**。保持**方向**为**垂直**。
- en: '![Figure 9.4 – Graph generated using Query Editor v2](img/B19071_09_004.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 使用查询编辑器v2生成的图形](img/B19071_09_004.jpg)'
- en: Figure 9.4 – Graph generated using Query Editor v2
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 使用查询编辑器v2生成的图形
- en: You can notice that there are more *Sharp-Right-Turn* and *Move-Forward* directions
    than *Slight-Right-Turn* and *Slight-Left-Turn* directions. We will use these
    inputs to predict the future movement of the robot.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到，*急转右转*和*前进*方向的数量比*轻微右转*和*轻微左转*方向的数量多。我们将使用这些输入来预测机器人的未来运动。
- en: Prediction goal
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测目标
- en: Since this is a multiclass classification problem, the goal of this model is
    to predict which direction the robot will take next based on the 24 sensor readings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个多类分类问题，这个模型的目标是根据24个传感器读数预测机器人将采取的方向。
- en: The dataset has one ID column, which uniquely identifies a row of 24 sensor
    readings named `us1`, `us2`, …, `us24`, and a `direction` variable, which has
    4 values in it. The `direction` variable is the class variable that we are trying
    to predict.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集有一个ID列，它唯一地标识了24个传感器读数，命名为`us1`、`us2`、…、`us24`，以及一个`direction`变量，其中包含4个值。`direction`变量是我们试图预测的类别变量。
- en: Now let’s split the dataset into a training dataset, which will be input to
    our model, and a test dataset, which we will use to do our predictions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将数据集分成训练数据集，它将被输入到我们的模型中，以及测试数据集，我们将用它来做预测。
- en: Splitting data into training and test datasets
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据分割成训练集和测试集
- en: We are going to split our table into two datasets, train and test, with an approximately
    80:20 split. Let’s use the `mod` function in Redshift to split our table. The
    `mod` function returns the remainder of two numbers. We will pass in the ID and
    the number `5`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的表分成两个数据集，训练集和测试集，大约80:20的比例。让我们在Redshift中使用`mod`函数来分割我们的表。`mod`函数返回两个数字的余数。我们将传入ID和数字`5`。
- en: 'To train the model, let’s use `where mod(id,5)` is not equal to `0`, which
    represents our training set of 80%. Run the following command in Query Editor
    v2:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了训练模型，让我们使用`where mod(id,5)`不等于`0`，这代表我们的80%的训练集。在Query Editor v2中运行以下命令：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In *Figure 9**.5*, we see the data distribution based on ~80% of the data:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9*.5中，我们看到基于大约80%的数据的数据分布：
- en: '![Figure 9.5 – Training dataset distribution](img/B19071_09_005.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 训练数据集分布](img/B19071_09_005.jpg)'
- en: Figure 9.5 – Training dataset distribution
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 训练数据集分布
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might see a different count than we have shown. We are using Redshift’s
    `Identity` function to generate the values for the `id` column. To be sure that
    the identity values are unique, Amazon Redshift skips some values when creating
    the identity values. Identity values are unique but the order might not match.
    Hence, you might see a different count but the data is 80% of the total count
    (5,456 rows).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能看到的计数与我们展示的不同。我们正在使用Redshift的`Identity`函数来生成`id`列的值。为了确保身份值是唯一的，Amazon Redshift在创建身份值时会跳过一些值。身份值是唯一的，但顺序可能不匹配。因此，你可能看到不同的计数，但数据是总计数的80%（5,456行）。
- en: 'The **Chart** function in Query Editor v2 depicts this in a bar chart format
    as shown in *Figure 9**.6*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Query Editor v2中的**图表**函数以柱状图格式显示了这一点，如图*图9*.6所示：
- en: '![Figure 9.6 – Training set bar chart](img/B19071_09_006.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 训练集柱状图](img/B19071_09_006.jpg)'
- en: Figure 9.6 – Training set bar chart
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 训练集柱状图
- en: 'To test the model, let’s use `where mod(id,5)` is equal to `0`, which represents
    our test dataset of 20%:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试模型，让我们使用`where mod(id,5)`等于`0`，这代表我们的20%测试数据集：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In *Figure 9**.7*, we see the data distribution based on ~20% of the data:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9*.7中，我们看到基于~20%的数据的数据分布：
- en: '![Figure 9.7 – Test dataset distribution](img/B19071_09_007.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 测试数据集分布](img/B19071_09_007.jpg)'
- en: Figure 9.7 – Test dataset distribution
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 测试数据集分布
- en: 'The **Chart** function in Query Editor v2 depicts this in a bar chart format
    as shown in *Figure 9**.8*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Query Editor v2中的**Chart**函数以条形图格式显示了*图9*.8中的内容：
- en: '![Figure 9.8 – Test data bar chart](img/B19071_09_008.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 测试数据条形图](img/B19071_09_008.jpg)'
- en: Figure 9.8 – Test data bar chart
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 测试数据条形图
- en: Now that we have analyzed our data and determined how we will split it into
    training and test datasets, let’s create our model using the MLP algorithm.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分析了我们的数据，并确定了如何将其分割成训练集和测试集，让我们使用MLP算法创建我们的模型。
- en: Creating a multiclass classification model using MLP
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MLP创建多类分类模型
- en: In this exercise, we are going to guide the `CREATE MODEL` statement to use
    the MLP model. You will achieve that by setting the `model_type` parameter to
    `MLP`. The rest of the parameters can be set to default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将指导`CREATE MODEL`语句使用MLP模型。您将通过将`model_type`参数设置为`MLP`来实现这一点。其余参数可以设置为默认值。
- en: 'Let’s create a model to predict the direction of the robot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个预测机器人方向的模型：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `CREATE MODEL` function is run with a `max_runtime` value of `1800` seconds.
    This means the maximum amount of time to train the model is 30 minutes. Training
    jobs often complete sooner depending on the dataset size. Since we have not set
    other parameters (for example, objective or problem type), Amazon SageMaker Autopilot
    will be doing the bulk of the work to identify the parameters for us.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CREATE MODEL`函数时，设置了`max_runtime`值为`1800`秒。这意味着模型训练的最大时间是30分钟。训练作业通常根据数据集的大小完成得更快。由于我们没有设置其他参数（例如，目标或问题类型），Amazon
    SageMaker Autopilot将为我们识别参数的大部分工作。
- en: 'Run the `SHOW MODEL` command to check whether model training is completed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`SHOW MODEL`命令以检查模型训练是否完成：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check **Model State** in *Figure 9**.9*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9*.9中检查**模型状态**：
- en: '![Figure 9.9 – SHOW MODEL output](img/B19071_09_009.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – SHOW MODEL输出](img/B19071_09_009.jpg)'
- en: Figure 9.9 – SHOW MODEL output
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – SHOW MODEL输出
- en: From the preceding screenshot, we can see that the **Model State** field shows
    the status as **TRAINING**, which means the model is still under training. But
    notice that Redshift ML has picked up **Model Type** as **mlp**; other parameters
    such as **Problem Type** and **Objective** are empty now, but after the model
    has been trained, we will see these values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图可以看出，**模型状态**字段显示状态为**训练中**，这意味着模型仍在训练中。但请注意，Redshift ML已将**模型类型**识别为**mlp**；其他参数，如**问题类型**和**目标**现在为空，但在模型训练完成后，我们将看到这些值。
- en: 'Run the `SHOW MODEL` command again after some time to check whether model training
    is complete or not. From the following screenshot, notice that model training
    has finished and **Accuracy** has been selected as the objective for model evaluation.
    This is auto-selected by Redshift ML. Also notice that Redshift ML correctly recognized
    this as a multiclass classification problem:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间后再次运行`SHOW MODEL`命令以检查模型训练是否完成。从下面的屏幕截图可以看出，模型训练已完成，**准确率**已被选为模型评估的目标。这是由Redshift
    ML自动选择的。同时请注意，Redshift ML正确地将此识别为多类分类问题：
- en: '![Figure 9.10 – SHOW MODEL output](img/B19071_09_010.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – SHOW MODEL输出](img/B19071_09_010.jpg)'
- en: Figure 9.10 – SHOW MODEL output
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – SHOW MODEL输出
- en: Now that our model has finished training, let’s run predictions using the function
    that was created. In *Figure 9**.10*, `predict_robot_direction_fn` and we will
    refer to that in our prediction query.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了模型的训练，让我们使用创建的函数进行预测。在*图9*.10中，`predict_robot_direction_fn`，我们将在预测查询中引用它。
- en: Also note the `validation:accuracy` value of `.940026` in *Figure 9**.10*. This
    means our model has an accuracy of >94%, which is very good.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意*图9*.10中的`validation:accuracy`值为`.940026`。这意味着我们的模型准确率超过94%，这非常好。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might get a different accuracy value due to different hyperparameters selected
    for the algorithm in the background, and this can slightly affect accuracy.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在后台算法中选择了不同的超参数，您可能会得到不同的准确率值，这可能会略微影响准确率。
- en: Since our model has been successfully trained, let’s run some predictions on
    our test dataset.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的模型已经成功训练，让我们在我们的测试数据集上运行一些预测。
- en: Running predictions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行预测
- en: 'In this first query, we will be using the function returned by the `CREATE
    MODEL` command to compare the actual direction with our predicted directions.
    Run the following query in Query Editor v2 to see how many times we predicted
    correctly:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个查询中，我们将使用`CREATE MODEL`命令返回的函数来比较实际方向与我们的预测方向。在Query Editor v2中运行以下查询以查看我们预测正确的次数：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In *Figure 9**.11*, we see that our model correctly predicted the robot’s direction
    1,033 times.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9**.11中，我们看到我们的模型正确预测了机器人方向1,033次。
- en: 'Please note that your count might be slightly different:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您的计数可能会有所不同：
- en: '![Figure 9.11 – Actual directions versus predicted direction](img/B19071_09_011.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – 实际方向与预测方向](img/B19071_09_011.jpg)'
- en: Figure 9.11 – Actual directions versus predicted direction
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 实际方向与预测方向
- en: 'Now, let’s run a query against the test dataset to predict which direction
    the robot will move. Run the following query in Query Editor v2 to return the
    first 10 rows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对测试数据集运行一个查询以预测机器人将移动的方向。在Query Editor v2中运行以下查询以返回前10行：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In *Figure 9**.12*, we show the first 10 rows and the direction based on the
    ID:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9**.12*中，我们展示了基于ID的前10行和方向：
- en: '![Figure 9.12 – Predicted direction by ID](img/B19071_09_012.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 根据ID预测的方向](img/B19071_09_012.jpg)'
- en: Figure 9.12 – Predicted direction by ID
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 根据ID预测的方向
- en: 'Now, let’s modify the query to summarize our predicted robot movements. Run
    the following in Query Editor v2:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改查询以总结我们预测的机器人运动。在Query Editor v2中运行以下命令：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In *Figure 9**.13*, we can see that **Move-Forward** is the most popular direction,
    followed closely by **Sharp-Right-Turn**. Please note that your counts might differ
    slightly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9**.13中，我们可以看到**前进**是最受欢迎的方向，其次是**急右转**。请注意，您的计数可能会有所不同。
- en: '![Figure 9.13 – Summary of predicted direction](img/B19071_09_013.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – 预测方向的总结](img/B19071_09_013.jpg)'
- en: Figure 9.13 – Summary of predicted direction
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 预测方向的总结
- en: You have now created a model using the MLP algorithm and run predictions on
    the test dataset.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已使用MLP算法创建了一个模型，并在测试数据集上运行了预测。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed deep learning models and why you need them and
    showed you how to create an MLP model on sensor-reading data to predict the next
    movement of the robot. You learned that non-linear datasets are suited for deep
    learning and created a multiclass classification model using the MLP algorithm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了深度学习模型及其必要性，并展示了如何使用MLP算法在传感器读数数据上创建一个MLP模型来预测机器人的下一步动作。您了解到非线性数据集适合深度学习，并使用MLP算法创建了一个多类分类模型。
- en: In the next chapter, we will show you how to create a model with complete control
    of hyper-tuning parameters using XGBoost algorithms.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您展示如何使用XGBoost算法创建一个完全控制超调参数的模型。
