- en: Chapter 3. Learning the Graphical User Interface and Basic Filtering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：学习图形用户界面和基本滤波
- en: In the previous chapter, we learned the basic classes and structures of OpenCV
    and the most important class called `Mat`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了OpenCV的基本类和结构，以及最重要的类`Mat`。
- en: We learned how to read and save images, videos, and the internal structure in
    the memory of images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何读取和保存图片、视频以及图片在内存中的内部结构。
- en: We are ready to work now, but we need to show our results and have some basic
    interaction with our images. OpenCV provides us with a few basic user interfaces
    to work with and help create our applications and prototypes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始工作了，但我们需要展示我们的结果，并与我们的图片进行一些基本的交互。OpenCV为我们提供了一些基本的用户界面来工作，并帮助我们创建应用程序和原型。
- en: To better understand how the user interface works, we are going to create a
    small application called **PhotoTool** at the end of this chapter. In this application,
    we will learn how to use filters and color conversions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解用户界面是如何工作的，我们将在本章末尾创建一个名为**PhotoTool**的小应用程序。在这个应用程序中，我们将学习如何使用滤波器和颜色转换。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basic OpenCV user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV的基本用户界面
- en: The OpenCV QT interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV的QT界面
- en: Sliders and buttons
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块和按钮
- en: An advanced user interface—OpenGL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个高级用户界面——OpenGL
- en: Color conversion
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色转换
- en: Basic filters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本过滤器
- en: Introducing the OpenCV user interface
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OpenCV用户界面
- en: OpenCV has its own cross-operating system user interface that allows developers
    to create their own applications without the need to learn complex libraries for
    the user interface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV拥有自己的跨操作系统用户界面，允许开发者创建自己的应用程序，无需学习复杂的用户界面库。
- en: The OpenCV user interface is basic, but it gives Computer Vision developers
    the basic functions to create and manage their software developments. All of them
    are native and optimized for real-time use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV的用户界面是基本的，但它为计算机视觉开发者提供了创建和管理软件开发的基本功能。所有这些功能都是本地的，并且针对实时使用进行了优化。
- en: 'OpenCV provides two options for the user interface:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV为用户界面提供了两种选项：
- en: A basic interface based on native user interfaces, such as Cocoa or Carbon for
    OS X and GTK for Linux or Windows user interfaces, that are selected by default
    when you compile OpenCV.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于本地用户界面（如OS X的Cocoa或Carbon，Linux或Windows的GTK）的基本界面，这些界面在编译OpenCV时默认选择。
- en: A slightly more advanced interface based on the QT library that is cross-platform.
    You have to enable the QT option manually in CMake before you compile OpenCV.![Introducing
    the OpenCV user interface](img/B04283_03_01.jpg)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于QT库的稍微高级一点的界面，它是跨平台的。在编译OpenCV之前，您必须手动在CMake中启用QT选项。![介绍OpenCV用户界面](img/B04283_03_01.jpg)
- en: A basic graphical user interface with OpenCV
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV的基本图形用户界面
- en: We are going to create a basic user interface with OpenCV. The OpenCV user interface
    allows us to create windows, add images to it, move it, resize it, and destroy
    it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OpenCV创建一个基本的用户界面。OpenCV用户界面允许我们创建窗口，向其中添加图片，移动它，调整大小，以及销毁它。
- en: 'The user interface is in the OpenCV''s module called `highui`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面位于OpenCV的`highui`模块中：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's understand the code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解代码。
- en: 'The first task that we need to perform in order to enable a Graphical User
    Interface is import the OpenCV''s module `highui`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用图形用户界面，我们需要执行的第一项任务是导入OpenCV的`highui`模块：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we are prepared to create our new windows, and then we need to load some
    images that are to be shown:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建我们的新窗口，然后我们需要加载一些要显示的图片：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create the windows, we use the `namedWindow` function. This function has
    two parameters: the first parameter is a constant string with the window''s name,
    and the second parameter is the flags that we require, which is optional:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建窗口，我们使用`namedWindow`函数。此函数有两个参数：第一个参数是一个常量字符串，包含窗口的名称，第二个参数是我们需要的标志，这是可选的：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our case, we create two windows: the first window is called `Lena` and the
    second is called `Photo`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们创建了两个窗口：第一个窗口被称作`Lena`，第二个被称作`Photo`。
- en: 'By default, there are the three flags for QT and native interfaces:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，有三个用于QT和本地界面的标志：
- en: '`WINDOW_NORMAL`: This flag allows the user to resize the window'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_NORMAL`：此标志允许用户调整窗口大小'
- en: '`WINDOW_AUTOSIZE`: If this flag is set, the window size is automatically adjusted
    to fit the display image and it is not possible to resize the window'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_AUTOSIZE`：如果设置了此标志，窗口大小将自动调整以适应显示的图片，并且无法调整窗口大小'
- en: '`WINDOW_OPENGL`: This flag enables OpenGL support'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_OPENGL`：此标志启用 OpenGL 支持'
- en: 'QT has some more flags, which are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: QT 有一些其他标志，如下所示：
- en: '`WINDOW_FREERATIO` or `WINDOW_KEEPRATIO`: If set to `WINDOW_FREERATIO`, then
    the image is adjusted with no respect to its ratio. If set to `WINDOW_FREERATIO`,
    then the image is adjusted with respect to its ratio.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_FREERATIO` 或 `WINDOW_KEEPRATIO`：如果设置为 `WINDOW_FREERATIO`，则图像调整时不考虑其比例。如果设置为
    `WINDOW_FREERATIO`，则图像调整时考虑其比例。'
- en: '`CV_GUI_NORMAL` or `CV_GUI_EXPANDED`: The first flag enables the basic interface
    without the status bar and toolbar. The second flag enables the most advanced
    graphical user interface with the status bar and toolbar.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_GUI_NORMAL` 或 `CV_GUI_EXPANDED`：第一个标志启用不带状态栏和工具栏的基本界面。第二个标志启用带有状态栏和工具栏的最先进图形用户界面。'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we compile OpenCV with QT, all the windows that we create are, by default,
    in the expanded interface, but we can use native and more basic interfaces by
    adding the `CV_GUI_NORMAL` flag.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 QT 编译 OpenCV，则我们创建的所有窗口默认情况下都在扩展界面中，但我们可以通过添加 `CV_GUI_NORMAL` 标志来使用原生和更基本的界面。
- en: By default, the flags are `WINDOW_AUTOSIZE`, `WINDOW_KEEPRATIO`, and `CV_GUI_EXPANDED`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，标志是 `WINDOW_AUTOSIZE`、`WINDOW_KEEPRATIO` 和 `CV_GUI_EXPANDED`。
- en: 'When we create multiple windows, they are superimposed one above the other,
    but we can move the windows to any area of our desktop with the `moveWindow` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建多个窗口时，它们一个叠一个，但我们可以使用 `moveWindow` 函数将窗口移动到桌面上的任何区域：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our code, we move the `Lena` window to the left 10 pixels 10 pixels to the
    top; and the `Photo` window to the left 520 pixels and 10 pixels to the top:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将 `Lena` 窗口向左移动 10 像素，向上移动 10 像素；将 `Photo` 窗口向左移动 520 像素，向上移动 10 像素：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After showing the images that we loaded previously with the `imshow` function,
    we resize the `Lena` window to 512 pixels, calling the `resizeWindow` function.
    This function has three parameters: `window name`, `width`, and `height`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `imshow` 函数显示我们之前加载的图像后，我们调用 `resizeWindow` 函数将 `Lena` 窗口调整为 512 像素。此函数有三个参数：`窗口名称`、`宽度`和`高度`。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The specific window size is for the image area. Toolbars are not counted. Only
    windows without the enabled `WINDOW_AUTOSIZE` flag can be resized.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的窗口大小是针对图像区域的。工具栏不计入。只有未启用 `WINDOW_AUTOSIZE` 标志的窗口可以调整大小。
- en: 'After waiting for a key press with the `waitKey` function, we will remove or
    delete our windows with the `destroyWindow` function in which the name of the
    window is the only parameter that is required:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `waitKey` 函数等待按键后，我们将使用 `destroyWindow` 函数删除或删除我们的窗口，其中窗口名称是唯一必需的参数：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OpenCV has a function that is used to remove all the windows that we create
    in only one call. The function is called `destroyAllWindows`. To show how this
    function works, in our sample we create 10 windows and wait for a key press. When
    the user presses any key, we destroy all the windows. Anyway, OpenCV automatically
    handles the destruction of all the windows when the application is terminated,
    and it is not necessary to call this function at the end of our application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 有一个函数，用于在一次调用中删除我们创建的所有窗口。该函数名为 `destroyAllWindows`。为了展示此函数的工作原理，在我们的示例中我们创建了
    10 个窗口并等待按键。当用户按下任意键时，我们销毁所有窗口。无论如何，OpenCV 在应用程序终止时自动处理所有窗口的销毁，因此不需要在应用程序末尾调用此函数：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result of this code can be seen in the following images in two steps. The
    first image shows two windows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的结果可以在以下图像中分两步看到。第一张图像显示两个窗口：
- en: '![A basic graphical user interface with OpenCV](img/B04283_03_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![使用 OpenCV 的基本图形用户界面](img/B04283_03_02.jpg)'
- en: 'After pressing any key, the application continues and draws several windows
    by changing their positions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 按下任意键后，应用程序继续并通过改变位置绘制几个窗口：
- en: '![A basic graphical user interface with OpenCV](img/B04283_03_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用 OpenCV 的基本图形用户界面](img/B04283_03_03.jpg)'
- en: The graphical user interface with QT
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 QT 的图形用户界面
- en: The QT user interface gives us more control and options to work with our images.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: QT 用户界面为我们提供了更多控制和选项来处理我们的图像。
- en: 'The interface is divided into three main areas:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 界面分为三个主要区域：
- en: The toolbar
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具栏
- en: The image area
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像区域
- en: The status bar![The graphical user interface with QT](img/B04283_03_04.jpg)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态栏![使用 QT 的图形用户界面](img/B04283_03_04.jpg)
- en: 'The toolbar has the following buttons from left to right:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏从左到右有以下按钮：
- en: Four buttons for panning
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个用于平移的按钮
- en: Zoom x1
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放大 x1
- en: Zoom x30 and show labels
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放大 x30 并显示标签
- en: Zoom in
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放大
- en: Zoom out
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩小
- en: Save the current image
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存当前图像
- en: Show the properties windows
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示属性窗口
- en: 'These options can be seen more clearly in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项在下面的截图中可以更清楚地看到：
- en: '![The graphical user interface with QT](img/B04283_03_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QT 的图形用户界面](img/B04283_03_05.jpg)'
- en: 'The image area shows an image and a contextual menu when we push the right
    mouse button over the image. This area can show an overlay message at the top
    of the area using the `displayOverlay` function. This function accepts three parameters:
    the window name, the text that we want to show, and the period in milliseconds
    when the overlay text is displayed. If the time is set to `0`, the text never
    disappears:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在图像上按下右鼠标按钮时，图像区域显示一个图像和一个上下文菜单。此区域可以使用 `displayOverlay` 函数在区域的顶部显示叠加消息。此函数接受三个参数：窗口名称、我们想要显示的文本以及叠加文本显示的毫秒数。如果时间设置为
    `0`，则文本永远不会消失：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![The graphical user interface with QT](img/B04283_03_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QT 的图形用户界面](img/B04283_03_06.jpg)'
- en: 'Finally, the status bar shows the bottom part of the window, the pixel value,
    and the position of the coordinates in the image:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，状态栏显示窗口的底部部分、像素值和图像中的坐标位置：
- en: '![The graphical user interface with QT](img/B04283_03_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QT 的图形用户界面](img/B04283_03_07.jpg)'
- en: 'We can use the status bar to show messages, such as an overlay. The function
    that can change the status bar message is `displayStatusBar`. This function has
    the same parameters as overlay functions: the window name, the text to show, and
    the period of time to show it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用状态栏来显示消息，例如叠加。可以更改状态栏消息的函数是 `displayStatusBar`。此函数具有与叠加函数相同的参数：窗口名称、要显示的文本以及显示它的持续时间：
- en: '![The graphical user interface with QT](img/B04283_03_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QT 的图形用户界面](img/B04283_03_08.jpg)'
- en: Adding slider and mouse events to our interfaces
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将滑块和鼠标事件添加到我们的界面中
- en: Mouse events and slider controls are very useful in Computer Vision and OpenCV.
    Using these controls, users can interact directly with the interface and change
    the properties of their input images or variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件和滑块控制在计算机视觉和 OpenCV 中非常有用。使用这些控件，用户可以直接与界面交互，并更改其输入图像或变量的属性。
- en: 'In this section, we are going to introduce you to the concepts of adding slider
    and mouse events for basic interactions. To understand this correctly, we will
    create a small project, where we paint green circles in the image using the mouse
    events and blur the image with the slider:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍添加滑块和鼠标事件以进行基本交互的概念。为了正确理解这一点，我们将创建一个小项目，在该项目中，我们使用鼠标事件在图像中绘制绿色圆圈，并使用滑块模糊图像：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's understand the code!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下代码！
- en: 'First, we create a variable to save the slider position, and then we need to
    save the slider position for access from other functions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个变量来保存滑块位置，然后我们需要保存滑块位置以便其他函数访问：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we define our callbacks for our slider and mouse events that are required
    for the OpenCV `setMouseCallbac` and `createTrackbar` functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义我们的滑块和鼠标事件回调，这些事件对于 OpenCV 的 `setMouseCallback` 和 `createTrackbar` 函数是必需的：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the main function, we load an image and create a new window called `Lena`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们加载一个图像并创建一个名为 `Lena` 的新窗口：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is time to create the slider. OpenCV has the `createTrackbar` function that
    is used to generate a slider with the following parameters in order:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建滑块了。OpenCV 有一个 `createTrackbar` 函数，用于生成具有以下参数的滑块：
- en: The track bar name.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹条名称。
- en: The window name.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口名称。
- en: An integer pointer to be used as a value; this parameter is optional. If the
    pointer value is set, the slider gets this position during its creation.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数指针，用作值；此参数是可选的。如果设置指针值，则滑块在创建时获取此位置。
- en: The maximal position on the slider.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块上的最大位置。
- en: The callback function when the position slider changes.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块位置改变时的回调函数。
- en: 'The user data to be sent to the callback. It can be used to send data to callbacks
    without using global variables:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发送到回调的用户数据。它可以用来向回调发送数据，而无需使用全局变量：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After creating the slider, we add the mouse events that allow you to paint
    circles when the user pushes the left mouse button. OpenCV has the `setMouseCallback`
    function. This function has three parameters, which are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建滑块后，我们添加允许用户在按下左鼠标按钮时绘制圆圈的鼠标事件。OpenCV 有一个 `setMouseCallback` 函数。此函数有三个参数，如下所示：
- en: The window name where we get the mouse events
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取鼠标事件的窗口名称
- en: The `callback` function to be called when there are mouse interactions
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有鼠标交互时被调用的 `callback` 函数。
- en: 'User data refers to any data that will be sent to the callback function when
    it''s fired. In our example, we''ll send the entire `Lena` image:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数据指的是当它被触发时将发送到回调函数的任何数据。在我们的例子中，我们将发送整个 `Lena` 图像：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To finalize the `main` function, we only need to initialize the image with
    the same parameter as the slider. To perform the initialization, we only need
    to call the `callback` function manually and wait for events before we close the
    windows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最终化 `main` 函数，我们只需要使用与滑块相同的参数初始化图像。为了执行初始化，我们只需要手动调用 `callback` 函数并等待事件，在我们关闭窗口之前：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The slider callback applies a basic blur filter to the image using the slider
    value as a blur quantity:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块回调函数使用滑块值作为模糊量对图像应用基本的模糊滤镜：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function checks whether the slider value is 0 using the `pos` variable;
    in this case, we do not apply the filter because it generates a bad execution.
    We cannot apply a 0 pixels blur.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `pos` 变量检查滑块值是否为 0；在这种情况下，我们不应用滤镜，因为它会产生不良的执行效果。我们不能应用 0 像素的模糊。
- en: After checking the slider value, we create an empty matrix called `imgBlur`
    to store the blur result.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查滑块值后，我们创建一个名为 `imgBlur` 的空矩阵来存储模糊结果。
- en: To retrieve the image sent via the user data in the `callback` function, we
    have to cast the `void* userData` to correct the `pointer Mat*` image type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `callback` 函数中检索通过用户数据发送的图像，我们必须将 `void* userData` 强制转换为正确的 `pointer Mat*`
    图像类型。
- en: Now, we have the correct variables to be applied to the blur filter. The blur
    function applies a basic median filter to an input image, `*img` in our case,
    to an output image. The last parameter is the size of a blur kernel (a kernel
    is a small matrix used to calculate the means of convolution between the kernel
    and image) that we want to apply. In our case, we are using a squared kernel of
    the `pos` size.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了应用模糊滤镜的正确变量。模糊函数将一个基本的中值滤波器应用于输入图像，在我们的例子中是 `*img`，到输出图像。最后一个参数是我们想要应用的模糊核的大小（核是一个用于计算核与图像之间卷积平均的小矩阵）。在我们的例子中，我们使用了一个
    `pos` 大小的平方核。
- en: Finally, we only need to update the image interface using the `imshow` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要使用 `imshow` 函数更新图像界面。
- en: 'The mouse events callback has five input parameters: the first parameter defines
    the event type, the second and third parameters define the mouse position, the
    fourth parameter defines the wheel movement, and the fifth parameter defines the
    user input data.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件回调有五个输入参数：第一个参数定义事件类型，第二个和第三个参数定义鼠标位置，第四个参数定义鼠标滚轮的移动，第五个参数定义用户输入数据。
- en: 'The mouse event types are shown in the following table:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件类型如下表所示：
- en: '| Event type | Description |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `EVENT_MOUSEMOVE` | When the user moves the mouse |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MOUSEMOVE` | 当用户移动鼠标时 |'
- en: '| `EVENT_LBUTTONDOWN` | When the user pushes the left mouse button |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_LBUTTONDOWN` | 当用户按下鼠标左键时 |'
- en: '| `EVENT_RBUTTONDOWN` | When the user pushes the right mouse button |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_RBUTTONDOWN` | 当用户按下鼠标右键时 |'
- en: '| `EVENT_MBUTTONDOWN` | When the user pushes the middle mouse button |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MBUTTONDOWN` | 当用户按下鼠标中键时 |'
- en: '| `EVENT_LBUTTONUP` | When the user releases the left mouse button |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_LBUTTONUP` | 当用户释放鼠标左键时 |'
- en: '| `EVENT_RBUTTONUP` | When the user releases the right mouse button |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_RBUTTONUP` | 当用户释放鼠标右键时 |'
- en: '| `EVENT_MBUTTONUP` | When the user releases the middle mouse button |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MBUTTONUP` | 当用户释放鼠标中键时 |'
- en: '| `EVENT_LBUTTONDBLCLK` | When the user double-clicks with the left mouse button
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_LBUTTONDBLCLK` | 当用户用左键双击时 |'
- en: '| `EVENT_RBUTTONDBLCLK` | When the user double-clicks with the right mouse
    button |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_RBUTTONDBLCLK` | 当用户用鼠标右键双击时 |'
- en: '| `EVENT_MBUTTONDBLCLK` | When the user double-clicks with the middle mouse
    button |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MBUTTONDBLCLK` | 当用户用鼠标中键双击时 |'
- en: '| `EVENTMOUSEWHEEL` | When the user does a vertical scroll with the mouse wheel
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `EVENTMOUSEWHEEL` | 当用户用鼠标滚轮进行垂直滚动时 |'
- en: '| `EVENT_MOUSEHWHEEL` | When the user does a horizontal scroll with the mouse
    wheel |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MOUSEHWHEEL` | 当用户用鼠标滚轮进行水平滚动时 |'
- en: 'In our sample, we only go to manage events that come from a left-push mouse
    button, and then any other event different from `EVENT_LBUTTONDOWN` is discarded.
    After discarding other events, we get the input image, such as a slider callback,
    and draw a circle in the image with the circle OpenCV function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只处理来自左键按下的鼠标事件，然后丢弃任何不同于 `EVENT_LBUTTONDOWN` 的其他事件。在丢弃其他事件后，我们得到输入图像，例如滑块回调，并使用
    OpenCV 的圆形函数在图像中绘制一个圆：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Adding buttons to a user interface
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向用户界面添加按钮
- en: In the previous chapter, we learned how to create normal or QT interfaces and
    interact with them with a mouse and slider, but we can create different types
    of buttons as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建普通或 QT 界面，以及如何使用鼠标和滑块与之交互，但我们可以创建不同类型的按钮。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Buttons are only supported in QT Windows.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮仅在 QT 窗口中受支持。
- en: 'The types of buttons supported are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的按钮类型如下：
- en: The `push` button
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push` 按钮'
- en: The `checkbox`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkbox`'
- en: The `radiobox`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radiobox`'
- en: The buttons only appear in the control panel. The control panel is an independent
    window per program, where we can attach buttons and track bars.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮仅在控制面板中显示。控制面板是每个程序的独立窗口，我们可以将其附加到按钮和滑块上。
- en: To show the control panel, we can push the last toolbar button, right-click
    on any part of the QT window, and select the **Display properties** window or
    the *Ctrl* + *P* shortcut.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示控制面板，我们可以点击最后一个工具栏按钮，在 QT 窗口的任何部分右键单击，并选择 **显示属性** 窗口或 *Ctrl* + *P* 快捷键。
- en: 'Let''s see how to create a basic sample with buttons. The code is large, and
    we will first explain the main function and later explain each callback separately
    to understand each one of them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建带有按钮的基本示例。代码量很大，我们首先解释主函数，然后分别解释每个回调以了解它们：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are going to apply three types of blur fiters, a sobel fiter, and a color
    conversion to gray. All these filters are optional and the user can choose each
    one of them using the buttons that we are going to create. Then, in order to get
    the status of each filter, we create three global Boolean variables:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用三种类型的模糊过滤器，一个 sobel 过滤器和颜色转换到灰度。所有这些过滤器都是可选的，用户可以使用我们将要创建的按钮中的任何一个来选择。然后，为了获取每个过滤器的状态，我们创建三个全局布尔变量：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the main function after we load the image and create the window, we have
    to use the `createButton` function to create each button.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，在我们加载图像并创建窗口之后，我们必须使用 `createButton` 函数来创建每个按钮。
- en: 'There are three button types defined in OpenCV, which are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 中定义了三种按钮类型，如下所示：
- en: '`QT_CHECKBOX`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT_CHECKBOX`'
- en: '`QT_RADIOBOX`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT_RADIOBOX`'
- en: '`QT_PUSH_BUTTON`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT_PUSH_BUTTON`'
- en: 'Each button has five parameters with the following order:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮有五个参数，顺序如下：
- en: The button name
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮名称
- en: The callback function
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数
- en: A pointer to user variable data passed to callback
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给回调的用户变量数据的指针
- en: The button type
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮类型
- en: The default initialized state used for the `checkbox` and `radiobox` button
    types
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 `checkbox` 和 `radiobox` 按钮类型的默认初始化状态
- en: 'Then, we create a blur checkbox button, two radio buttons for color conversion,
    and a push button for the Sobel filter:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个模糊复选框按钮，两个用于颜色转换的单选按钮，以及一个用于 Sobel 过滤器的按钮：
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the most important part of the main function. We are going to explore
    the callback functions. Each callback changes its status variable to call another
    function called `applyFilters` and adds the filters activated by the input image:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是主函数中最重要的部分。我们将探索回调函数。每个回调都会更改其状态变量以调用另一个名为 `applyFilters` 的函数，并添加由输入图像激活的过滤器：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `applyFilters` function checks the status variable for each filter:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applyFilters` 函数检查每个过滤器的状态变量：'
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To change the color to gray, we use the `cvtColor` function that accepts three
    parameters: an input image, an output image, and the color conversion type.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要将颜色转换为灰度，我们使用 `cvtColor` 函数，该函数接受三个参数：输入图像、输出图像和颜色转换类型。
- en: 'The most useful color spaces conversions are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的颜色空间转换如下：
- en: RGB or BGR to gray (`COLOR_RGB2GRAY, COLOR_BGR2GRAY`)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB 或 BGR 到灰度（`COLOR_RGB2GRAY, COLOR_BGR2GRAY`）
- en: RGB or BGR to YcrCb (or YCC) (`COLOR_RGB2YCrCb, COLOR_BGR2YCrCb`)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB 或 BGR 到 YcrCb（或 YCC）（`COLOR_RGB2YCrCb, COLOR_BGR2YCrCb`）
- en: RGB or BGR to HSV (`COLOR_RGB2HSV, COLOR_BGR2HSV`)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB 或 BGR 到 HSV（`COLOR_RGB2HSV, COLOR_BGR2HSV`）
- en: RGB or BGR to Luv (`COLOR_RGB2Luv, COLOR_BGR2Luv`)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB 或 BGR 到 Luv（`COLOR_RGB2Luv, COLOR_BGR2Luv`）
- en: Gray to RGB or BGR (`COLOR_GRAY2RGB, COLOR_GRAY2BGR`)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰度到 RGB 或 BGR（`COLOR_GRAY2RGB, COLOR_GRAY2BGR`）
- en: We can see that the code is easy to memorize.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到代码很容易记住。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that OpenCV works, by default, with the BGR format, and the color conversion
    is different for RGB and BGR, when converting to gray. Some developers think that
    gray equals *R+G+B/3*, but the optimal gray value is called **luminosity** and
    has the formula *0.21*R + 0.72*G + 0.07*B*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，OpenCV 默认使用 BGR 格式，当转换为灰度时，RGB 和 BGR 的颜色转换不同。一些开发者认为灰度等于 *R+G+B/3*，但最佳灰度值称为
    **亮度**，其公式为 *0.21*R + 0.72*G + 0.07*B*。
- en: The blur filter was described in the previous section. Finally, if the `applySobel`
    variable is `true`, we apply the sobel filter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中描述了模糊滤镜。最后，如果 `applySobel` 变量是 `true`，则应用 Sobel 滤镜。
- en: The sobel filter is an image derivatives that uses the sobel operator, commonly
    used to detect edges. OpenCV allow us to generate different derivatives with different
    kernel sizes, but the most common is a 3x3 kernel used to calculate the `x` derivatives
    or `y` derivatives.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel 滤波器是一个使用 Sobel 运算符的图像导数，通常用于检测边缘。OpenCV 允许我们使用不同大小的核生成不同的导数，但最常见的是用于计算
    `x` 导数或 `y` 导数的 3x3 核。
- en: 'The most important sobel parameters are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的 Sobel 参数如下：
- en: An input image
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输入图像
- en: An output image
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出图像
- en: An output image depth (`CV_8U`, `CV_16U`, `CV_32F`, `CV_64F`)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个输出图像深度（`CV_8U`、`CV_16U`、`CV_32F`、`CV_64F`）
- en: The order of the derivatives x
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导数的顺序 x
- en: The order of the derivatives y
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导数的顺序 y
- en: The kernel size (3 value by default)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核大小（默认为 3 个值）
- en: 'To generate a 3x3 kernel and first `x` order derivatives, we have to use the
    following parameters:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要生成一个 3x3 的核和第一个 `x` 阶导数，我们必须使用以下参数：
- en: '[PRE23]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To generate the `y` order derivatives, we use the following parameters:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要生成 `y` 阶导数，我们使用以下参数：
- en: '[PRE24]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our example, we use the `x` and `y` derivatives simultaneously to overwrite
    the input:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们同时使用 `x` 和 `y` 导数来覆盖输入：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the `x` and `y` derivatives is as shown:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 导数的输出如下：'
- en: '![Adding buttons to a user interface](img/B04283_03_09.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![向用户界面添加按钮](img/B04283_03_09.jpg)'
- en: OpenGL support
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL 支持
- en: OpenCV includes OpenGL support. OpenGL is a graphical library that is integrated
    in graphic cards as a standard. OpenGL allow us to draw from 2D to complex 3D
    scenes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 包括 OpenGL 支持。OpenGL 是一个集成在图形卡中的图形库，作为标准。OpenGL 允许我们从 2D 绘制到复杂的 3D 场景。
- en: OpenCV includes OpenGL support due to the importance of representing 3D spaces
    in some tasks. To allow a window support in OpenGL, we have to set up the `WINDOW_OPENGL`
    flag when we create the window with the `namedWindow` call.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在有些任务中表示 3D 空间的重要性，OpenCV 包括 OpenGL 支持。为了允许 OpenGL 窗口支持，我们必须在调用 `namedWindow`
    时设置 `WINDOW_OPENGL` 标志。
- en: 'The following code creates a window with OpenGL support and draws a rotated
    plane that shows the web camera frames:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个具有 OpenGL 支持的窗口，并绘制了一个旋转的平面，该平面显示了网络摄像头的帧：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's understand the code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下代码。
- en: 'The first task is to create the required global variables where we store the
    video capture, save the frames, control the animation angle plane, and the OpenGL
    texture:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是创建所需的全局变量，其中我们存储视频捕获、保存帧、控制动画角度平面和 OpenGL 纹理：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In our main function, we have to create the video camera capture to retrieve
    the camera frames:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们必须创建视频摄像头捕获以检索摄像头帧：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the camera is opened correctly, then we have to create our window with OpenGL
    support using the `WINDOW_OPENGL` flag:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果摄像头正确打开，那么我们必须使用 `WINDOW_OPENGL` 标志创建我们的窗口，以支持 OpenGL：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our example, we want to draw the images in a plane that come from the web
    camera, and then we need to enable the OpenGL textures:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们想要绘制来自网络摄像头的图像，然后我们需要启用 OpenGL 纹理：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we are ready to draw with OpenGL in our window, but we need set up a draw
    OpenGL callback such as a typical OpenGL application. OpenCV give us the `setOpenGLDrawCallback`
    function that has two parameters: the window name and the callback function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在我们的窗口中使用 OpenGL 绘制，但我们需要设置一个绘制 OpenGL 回调，例如典型的 OpenGL 应用程序。OpenCV
    给我们 `setOpenGLDrawCallback` 函数，该函数有两个参数：窗口名称和回调函数：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the OpenCV window and callback function defined, we need to create a loop
    to load the texture and update the window content by calling the OpenGL draw callback;
    finally, we need to update the angle position.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 OpenCV 窗口和回调函数后，我们需要创建一个循环来加载纹理，并通过调用 OpenGL 绘制回调来更新窗口内容；最后，我们需要更新角度位置。
- en: 'To update the window content, we use the OpenCV function update window with
    the window name as the parameter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新窗口内容，我们使用带有窗口名称作为参数的 OpenCV 函数 `updateWindow`：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are in the loop while the user press the *q* key.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下 *q* 键时，我们处于循环中。
- en: Before we compile our application sample, we need to define the `loadTexture`
    function and our `on_opengl` callback draw function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编译应用程序示例之前，我们需要定义 `loadTexture` 函数和我们的 `on_opengl` 回调绘制函数。
- en: 'The `loadTexture` function converts our `Mat` frame to an OpenGL texture image
    that is ready to be loaded and used in each callback drawing. Before we load the
    image as a texture, we need to ensure that we have data in our frame matrix to
    check whether the data variable object is not empty:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTexture`函数将我们的`Mat`框架转换为OpenGL纹理图像，该图像已准备好在每次回调绘制中使用。在我们将图像作为纹理加载之前，我们需要确保我们的框架矩阵中有数据，以检查数据变量对象是否不为空：'
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we have data in our matrix frame, then we can create the OpenGL texture
    binding and set the OpenGL texture parameters as a linear interpolation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在矩阵框架中有数据，那么我们可以创建OpenGL纹理绑定并设置OpenGL纹理参数为线性插值：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we need to define how the pixels are stored in our matrix and how to generate
    the pixels with the OpenGL''s `glTexImage2D` function. It''s very important to
    note that OpenGL uses the RGB format and OpenCV has the BGR format by default,
    and we need to set it up correctly in this function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义像素在矩阵中的存储方式以及如何使用OpenGL的`glTexImage2D`函数生成像素。非常重要的一点是，OpenGL使用RGB格式，而OpenCV默认使用BGR格式，我们需要在这个函数中正确设置它：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we only need to finish drawing our plane for every callback when we call
    the `updateWindow` in the main loop. We use the common OpenGL functions, and then
    we load the identity OpenGL matrix to reset all our previous changes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在主循环中调用`updateWindow`时完成绘制我们的平面。我们使用常见的OpenGL函数，然后加载单位OpenGL矩阵以重置我们之前的所有更改：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Load the frame texture into the memory:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将框架纹理加载到内存中：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before we draw our plane, we apply all the transformations to our scene; in
    our case, we are going to rotate our plane in the (1, 1, 1) axis:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制我们的平面之前，我们将所有变换应用到我们的场景中；在我们的情况下，我们将在(1, 1, 1)轴上旋转我们的平面：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we have the scene set correctly to draw our plane, so we will draw quads
    faces and use `glBegin(GL_QUADS)`for this purpose:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经正确设置了场景来绘制我们的平面，所以我们将绘制四边形面并使用`glBegin(GL_QUADS)`来完成这个目的：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We draw a plane centered at the (0, 0) position with a two units of size. Then,
    we have to define the texture coordinate to be used and the vertex position using
    the `glTextCoord2D` and `glVertex2D` functions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以(0, 0)位置为中心绘制一个大小为两单位的平面。然后，我们必须使用`glTextCoord2D`和`glVertex2D`函数定义要使用的纹理坐标和顶点位置：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This OpenGL code is becoming obsolete, but it is important to better understand
    the OpenCV and OpenGL integration without the complex OpenGL code. To introduce
    you to modern OpenGL, read *Introduction to Modern OpenGL*, *Pack Publishing*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段OpenGL代码正在变得过时，但了解OpenCV和OpenGL集成而不使用复杂的OpenGL代码非常重要。为了向您介绍现代OpenGL，请阅读*现代OpenGL入门*，*Pack
    Publishing*。
- en: 'We can see the result in the following image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图像中看到结果：
- en: '![OpenGL support](img/B04283_03_10.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![OpenGL支持](img/B04283_03_10.jpg)'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create different types of user interface
    to show images or 3D interfaces using OpenGL. We learned how to create sliders
    and buttons and draw in 3D. We learned some basic image processing filters as
    well.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建不同类型的用户界面来使用OpenGL显示图像或3D界面。我们学习了如何创建滑块和按钮，并在3D中绘制。我们还学习了一些基本的图像处理过滤器。
- en: In the next chapter, we will learn how to construct a complete photo tool application
    using all that we learned using the graphical user interface. We will also learn
    how to apply multiple filters to an input image.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用图形用户界面构建一个完整的照片工具应用程序，使用我们所学到的所有知识。我们还将学习如何将多个过滤器应用到输入图像上。
