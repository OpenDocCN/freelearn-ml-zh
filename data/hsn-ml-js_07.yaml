- en: Forecasting with Regression Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回归算法进行预测
- en: In this chapter, we're going to take a brief look at forecasting using regression
    algorithms. We'll additionally discuss time-series analysis and how we can use
    techniques from digital-signal processing to aid in our analysis. By the end of
    the chapter, you will have seen a number of patterns commonly found in time-series
    and continuous-valued data and will have an understanding of which types of regressions
    fit on which types of data. Additionally, you will have learned a few digital
    signal processing techniques, such as filtering, seasonality analysis, and Fourier
    transformations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍使用回归算法进行预测。我们还将讨论时间序列分析以及我们如何使用数字信号处理技术来辅助我们的分析。到本章结束时，你将看到时间序列和连续值数据中常见的许多模式，并了解哪些类型的回归适合哪些类型的数据。此外，你还将学习一些数字信号处理技术，例如滤波、季节性分析和傅里叶变换。
- en: 'Forecasting is a very broad concept that covers many types of tasks. This chapter
    will provide you with an initial toolbox of concepts and algorithms that apply
    broadly to time-series data. We will focus on the fundamentals, and discuss the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 预测是一个非常广泛的概念，涵盖了多种类型的任务。本章将为你提供一套适用于时间序列数据的初始概念和算法工具箱。我们将关注基础，并讨论以下主题：
- en: Regression versus classification
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归与分类
- en: Regression basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归基础
- en: Linear, exponential, and polynomial regression
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性、指数和多项式回归
- en: Time-series analysis basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列分析基础
- en: Low-pass and high-pass filtering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低通和高通滤波
- en: Seasonality and subtractive analysis
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 季节性和减法分析
- en: Fourier analysis
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 傅里叶分析
- en: These concepts build an essential toolbox that you can use when working with
    real-world forecasting and analysis problems. There are many other tools that
    apply to specific situations, but I consider these topics to be the absolute essentials.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念构建了一个基本的工具箱，你可以在处理现实世界的预测和分析问题时使用。还有许多其他适用于特定情况的工具，但我认为这些主题是绝对的基础。
- en: Let's begin by looking at the similarities—and differences—between regression
    and classification in **machine learning** (**ML**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从比较和对比机器学习（ML）中回归和分类的相似之处和不同之处开始。
- en: Regression versus classification
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归与分类
- en: Much of this book has been involved with classification tasks, where the objective
    of the analysis is to fit a data point to one of a number of predefined classes
    or labels. When classifying data, you are able to judge your algorithm's accuracy
    by comparing predictions to true values; a guessed label is either correct or
    incorrect. In classification tasks, you can often determine the likelihood or
    probability that a guessed label fits the data, and you typically choose the label
    with the maximum likelihood.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分内容都与分类任务有关，分析的目标是将数据点拟合到预定义的多个类别或标签之一。在分类数据时，你可以通过将预测值与真实值进行比较来判断你的算法的准确性；一个猜测的标签要么是正确的，要么是错误的。在分类任务中，你通常可以确定一个猜测的标签与数据的匹配可能性或概率，并且你通常选择具有最大可能性的标签。
- en: Let's compare and contrast classification tasks to regression tasks. Both are
    similar in that the ultimate goal is to make a prediction, informed by prior knowledge
    or data. Both are similar in that we want to create some kind of function or logic
    that maps input values to output values, and make that mapping function both as
    accurate and as generalized as possible. However, the major difference between
    regression and classification is that in regression, your goal is to determine
    the *quantity* of a value rather than its label.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较和对比分类任务与回归任务。两者在最终目标上相似，即根据先前的知识或数据进行预测。两者在目标上相似，即我们希望创建某种函数或逻辑，将输入值映射到输出值，并使映射函数尽可能准确和通用。然而，回归和分类之间的主要区别在于，在回归中，你的目标是确定值的*数量*而不是其标签。
- en: 'Imagine you have historical data about the processing load over time on a server
    that you manage. This data is *time-series*, because the data evolves over time.
    The data is also *continuous* (as opposed to *discrete*), because the output values
    can be any real number: 1, or 2.3, or 2.34353, and so on. The goal in time-series
    analysis or regression analysis is not to label the data, but rather to predict
    what your server load will be next Thursday evening at 20:15 p.m., for instance.
    To accomplish this goal, you must analyze the time-series data and attempt to
    extract patterns from it, and then use those patterns to make a future prediction.
    Your prediction will also be a real and continuous number, such as *I predict
    the server load next Thursday night will be 2.75*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一份关于你管理的服务器随时间处理负载的历史数据。这些数据是*时间序列*的，因为数据随时间演变。数据也是*连续的*（与*离散的*相对），因为输出值可以是任何实数：1，或2.3，或2.34353，等等。在时间序列分析或回归分析中的目标不是标记数据，而是预测例如下周四晚上20:15的服务器负载将会是多少。为了实现这个目标，你必须分析时间序列数据，并尝试从中提取模式，然后使用这些模式进行未来预测。你的预测也将是一个真实且连续的数字，例如*我预测下周四晚上服务器负载将是2.75*。
- en: In classification tasks, you can judge the accuracy of your algorithm by comparing
    predictions to true values and counting how many predictions were correct or incorrect.
    Because regression tasks involve themselves with continuous values, one cannot
    simply determine whether a prediction was correct or incorrect. If you predict
    that server load will be 2.75 and it ends up truly being 2.65, can you say that
    the prediction was correct? Or incorrect? What about if it ends up being 2.74?
    When classifying *spam* or *not spam*, you either get the prediction right or
    you get it wrong. When you compare continuous values, however, you can only determine
    how close you got the prediction and therefore must use some other metric to define
    the accuracy of your algorithm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在分类任务中，你可以通过将预测与真实值进行比较，并计算预测正确或错误的数量来判断算法的准确性。由于回归任务涉及连续值，不能简单地确定预测是否正确。如果你预测服务器负载将是2.75，结果实际上是2.65，你能说预测是正确的吗？或者错误的？如果结果是2.74呢？当分类*垃圾邮件*或*非垃圾邮件*时，要么预测正确，要么预测错误。然而，当你比较连续值时，你只能确定预测有多接近，因此必须使用其他指标来定义算法的准确性。
- en: In general, you will use a different set of algorithms to analyze continuous
    or time-series data than you would use for classification tasks. However, there
    are some ML algorithms that can handle both regression and classification tasks
    with minor modifications. Most notably, decision trees, random forests, and neural
    networks can all be used both for classification and regression tasks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你将使用不同的算法集来分析连续或时间序列数据，而不是用于分类任务。然而，有一些机器学习算法可以通过轻微的修改来处理回归和分类任务。最值得注意的是，决策树、随机森林和神经网络都可以用于分类和回归任务。
- en: 'In this chapter, we will look at the following concepts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下概念：
- en: Least-squares regressions techniques, such as linear regression, polynomial
    regression, power law regression, and others
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小二乘回归技术，如线性回归、多项式回归、幂律回归等
- en: Trend analysis or smoothing
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 趋势分析或平滑
- en: Seasonality analysis or pattern subtraction
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 季节性分析或模式减法
- en: Regression basics
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归基础
- en: When performing regression analysis, there are two primary and overarching goals.
    First, we want to determine and identify any underlying, systemic patterns in
    the data. If we can identify the systemic patterns, we may be able to identify
    the phenomena underlying the patterns and develop a deeper understanding of the
    system as a whole. If, through your analysis, you find that there is a pattern
    that repeats itself every 16 hours, you will be in a much better position to figure
    out what phenomenon is causing the pattern and take action. As with all ML tasks,
    that 16-hour pattern may be buried deep within the data and may not be identifiable
    at a glance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行回归分析时，有两个主要和整体的目标。首先，我们希望确定和识别数据中任何潜在的、系统的模式。如果我们能识别出系统的模式，我们可能能够识别出导致这些模式的现象，并更深入地理解整个系统。如果你通过分析发现有一个每16小时重复一次的模式，你将处于一个更好的位置来弄清楚是什么现象导致了这个模式，并采取行动。与所有机器学习任务一样，这个16小时的模式可能深深隐藏在数据中，并且可能一眼看不出来。
- en: The second major goal is to use the knowledge of the underlying patterns to
    make future predictions. The predictions that you make will only be as good as
    the analysis that powers the predictions. If there are four different systemic
    patterns in your data, and you've only identified and modeled three of them, your
    predictions may be inaccurate since you haven't fully modeled the real-world phenomena
    involved.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要目标是利用对基本模式的知识来做出未来的预测。你所做的预测将仅与驱动预测的分析一样好。如果你的数据中有四个不同的系统性模式，而你只识别并建模了其中的三个，那么你的预测可能不准确，因为你没有完全建模涉及的现实世界现象。
- en: Achieving both of these goals relies on your ability to identify and formally
    (that is, mathematically) describe the patterns and phenomena. In some cases,
    you may not be able to fully identify the root cause of a pattern; even then,
    if the pattern is reliable and your analysis is good, you will still be able to
    predict the future behavior of the system even if you don't fully understand the
    cause. This is the case with all ML problems; ML ultimately analyzes behaviors
    and results—the things we can measure—but having a deep understanding of the causes
    can only help.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这两个目标依赖于你识别和正式（即数学上）描述模式和现象的能力。在某些情况下，你可能无法完全识别模式的根本原因；即使如此，如果模式是可靠的，你的分析是好的，即使你不完全理解原因，你仍然能够预测系统的未来行为。这是所有机器学习问题的情况；机器学习最终分析的是行为和结果——我们可以衡量的东西，但深入了解原因只能有所帮助。
- en: 'In all ML problems, we must also contend with noise. In classification problems,
    noise can take many forms, such as missing or incorrect values, or undefinable
    human behavior. Noise can take many forms in regression problems as well: sensors
    may be susceptible to environmental noise, there can be random fluctuations in
    the underlying processes, or noise can be caused by many small, hard-to-predict,
    systemic factors.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有机器学习问题中，我们还得应对噪声。在分类问题中，噪声可以有多种形式，例如缺失或错误的数据值，或者不可定义的人类行为。在回归问题中，噪声也可以有多种形式：传感器可能容易受到环境噪声的影响，基本过程可能存在随机波动，或者噪声可能由许多难以预测的小型系统性因素引起。
- en: Noise always makes patterns more difficult to identify, whether you're performing
    regression or classification analysis. In regression analysis, your goal is to
    be able to separate the systemic behaviors (the actual patterns) from the random
    sources of noise in the data. In some cases, it's important to also model the
    noise as a behavior, because the noise itself can have a significant effect on
    your predictions; in other cases, the noise can be ignored.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在进行回归分析还是分类分析，噪声总是使模式更难以识别。在回归分析中，你的目标是能够将数据中的系统性行为（实际模式）与随机噪声源分开。在某些情况下，也很重要将噪声建模为一种行为，因为噪声本身可能对你的预测产生重大影响；在其他情况下，噪声可以被忽略。
- en: 'To illustrate the difference between systemic patterns and noise, consider
    the following dataset. There are no units on the graph, as this is just a conceptual
    example of some dependent parameter, *Y*, that varies with some independent parameter, *X*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明系统性模式和噪声之间的区别，考虑以下数据集。图中没有单位，因为这只是一个关于某些依赖参数*Y*随某些独立参数*X*变化的抽象示例：
- en: '![](img/342e53f9-ac57-4b05-9286-d8b22306ed87.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/342e53f9-ac57-4b05-9286-d8b22306ed87.png)'
- en: In this example, we can clearly see the difference between the systemic pattern
    and the noise. The systemic pattern is the steady, linear growth—the Y-values
    generally increase as the X-values increase, despite some fluctuations from point
    to point due to noise. By modeling the systemic pattern in this data, we would
    be able to make a reasonable prediction for what the Y-value will be when the
    X-value is 75, or 100, or -20\. Whether or not the noise is significant will depend
    on the specific application; you can either ignore the noise, or you can model
    it and include it in your analysis.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以清楚地看到系统性模式和噪声之间的区别。系统性模式是稳定的线性增长——Y值通常随着X值的增加而增加，尽管由于噪声导致的点与点之间的波动，Y值有所波动。通过在这个数据中建模系统性模式，我们就能对当X值为75、100或-20时Y值将是什么做出合理的预测。噪声是否重要将取决于具体的应用；你可以忽略噪声，或者你可以对其进行建模并将其包含在分析中。
- en: 'In [Chapter 1](370a39e1-e618-475d-9722-9b4315a9a6ee.xhtml), *Exploring the
    Potential of JavaScript*, we learned about one technique for dealing with noise:
    smoothing with a moving average. Instead of graphing individual points, we can
    take groups of three points together and plot their averages. If the noise is
    truly random and distributed evenly (that is, the average of all the effects of
    noise comes out close to zero), a moving average will tend to cancel out some
    of the noise. If you are averaging three points, and the effect due to noise on
    each of those points adds +1, -2, and +1.2 to each point, respectively, the moving
    average will reduce the total effect of the noise to +0.2\. When we graph the
    moving average, we will typically find a smoother pattern:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](370a39e1-e618-475d-9722-9b4315a9a6ee.xhtml)，“探索JavaScript的潜力”中，我们了解了一种处理噪声的技术：使用移动平均进行平滑。我们不是绘制单个点，而是可以一起取三个点的组合并绘制它们的平均值。如果噪声确实是真正的随机且均匀分布的（也就是说，所有噪声效应的平均值接近于零），则移动平均将倾向于消除一些噪声。如果你平均三个点，并且每个点由于噪声产生的影响分别增加+1、-2和+1.2，那么移动平均将减少噪声的总影响至+0.2。当我们绘制移动平均时，我们通常会找到一个更平滑的模式：
- en: '![](img/c0ee9697-e607-458f-9c5c-fa5dc5bd941d.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0ee9697-e607-458f-9c5c-fa5dc5bd941d.png)'
- en: The moving average has reduced the effect of the noise, and helps us focus on
    the systemic pattern a bit more—but we are not much closer to being able to predict
    future values, such as when *X* is 75\. The moving average only helps us reduce
    the effect of noise on the data points within the dataset. When you look at the
    Y-value when *X = 4*, for instance, the measured value is around 21 while the
    smoothed value is 28\. In this case, the smoothed value of 28 better represents
    the *systemic pattern* at *X = 4*, even though the actual measured value at this
    point was 21\. Most likely, the big difference between the measurement and the
    systemic pattern was caused by a significant source of random noise when this
    measurement was taken.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平均减少了噪声的影响，并帮助我们更多地关注系统模式——但我们并没有更接近于能够预测未来的值，例如当*X*为75时。移动平均仅帮助我们减少数据集中数据点的噪声影响。例如，当你查看*X
    = 4*时的Y值时，测量的值大约是21，而平滑后的值是28。在这种情况下，28的平滑值更好地代表了*X = 4*处的*系统模式*，尽管在此点的实际测量值是21。很可能是由于在这次测量时存在一个显著的随机噪声源，导致测量值与系统模式之间存在很大的差异。
- en: Be cautious when dealing with noise. It's important to recognize that, in the
    preceding example, the actual measured Y-value was indeed 21 at *X = 4*. The smoothed,
    moving average version is an idealization. It is our attempt to cut through the
    noise in order to see the signal, but we cannot forget that the actual measurement
    was significantly affected by noise. Whether this fact is important to your analysis
    depends significantly on the problem you are trying to solve.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理噪声时请谨慎。重要的是要认识到，在前面的例子中，实际测量的Y值在*X = 4*时确实是21。平滑的移动平均是一种理想化。这是我们试图穿过噪声以看到信号的努力，但我们不能忘记实际测量受到了噪声的显著影响。这个事实是否对你的分析重要，很大程度上取决于你试图解决的问题。
- en: How, then, do we approach the problem of predicting a future value of this data?
    The moving average may help us when *interpolating* data, but not when *extrapolating*
    to a future X-value. You can, of course, make a guess as to what the value will
    be when *X = 75*, since this example is simple and easy to visualize. However,
    since this is a book about ML, we can assume that real-world problems will not
    be so easy to analyze by eye, and we will need to introduce new tools.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何处理预测这些数据未来值的难题呢？移动平均在*插值*数据时可能对我们有所帮助，但在*外推*到未来的X值时则不然。当然，你可以猜测当*X =
    75*时该值将会是多少，因为此例简单且易于可视化。然而，由于这是一本关于机器学习的书，我们可以假设现实世界的问题不会如此容易通过肉眼分析，我们需要引入新的工具。
- en: The solution to this problem is the *regression.* As with all predictive ML
    problems, we want to create some kind of abstract function that can map input
    values to output values, and use that function to make predictions. In classification
    tasks, that mapping function may be a Bayesian predictor or a heuristic based
    on random forests. In regression tasks, the mapping function will often be a mathematical
    function that describes a line, or a polynomial, or some other kind of shape that
    fits the data well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是*回归*。与所有预测性机器学习问题一样，我们希望创建某种抽象函数，可以将输入值映射到输出值，并使用该函数进行预测。在分类任务中，该映射函数可能是一个贝叶斯预测器或基于随机森林的启发式方法。在回归任务中，映射函数通常是一个描述直线、多项式或其他适合数据的形状的数学函数。
- en: 'If you''ve ever graphed data in Excel or Google Sheets, there''s a good chance
    you have already used linear regressions. The *trendline* feature of these programs
    performs a linear regression in order to determine a mapping function that best
    fits the data. The following graph is a trendline determined by a *linear regression*,
    which is a type of algorithm that is used to find the mathematical line that best
    fits the data:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在 Excel 或 Google Sheets 中绘制过数据，那么你很可能已经使用了线性回归。这些程序的趋势线功能执行线性回归，以确定最佳拟合数据的映射函数。以下图表是由*线性回归*确定的趋势线，线性回归是一种用于找到最佳拟合数据的数学线的算法：
- en: '![](img/a85c0ab2-389f-42fe-b705-a3715dc8ecf3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a85c0ab2-389f-42fe-b705-a3715dc8ecf3.png)'
- en: Additionally, Excel gives us another piece of information, called the **R² value**,
    which is a representation of how well the trendline fits the data. An R² value
    closer to 1.0 indicates that the trendline explains much of the variance between
    points; a low R² value indicates that the model does not explain the variance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Excel 还给我们提供了另一条信息，称为**R²值**，它是趋势线如何适合数据的表示。R²值接近 1.0 表示趋势线解释了点之间的大部分方差；R²值低表示模型没有解释方差。
- en: The major difference between the trendline and the moving average we saw earlier
    is that the trendline is an actual mathematical model. When you find a trendline
    with a linear regression, you will have a mathematical formula that describes
    the entire line. The moving average only exists where the data points exist; we
    can only have a moving average between X = 0 and X = 50\. The trendline, on the
    other hand, is described by the mathematical formula for a straight line, and
    it extends out to infinity both to the left and to the right. If you know the
    formula for the trendline, you can plug in *any* value of *X* to that formula
    and get a prediction for the value of *Y*. If, for example, you find that the
    formula for a line is *Y = 2.5 x X + 22*, you can plug in *X = 75* and you will
    get a prediction of *Y = 2.5 x 75 + 22*, or *Y = 209.5*. There is no way to get
    such a prediction from a moving average.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的趋势线和移动平均的主要区别在于趋势线是一个实际的数学模型。当你找到一个线性回归的趋势线时，你将得到一个描述整条线的数学公式。移动平均只存在于数据点存在的地方；我们只能在
    X = 0 和 X = 50 之间有一个移动平均。另一方面，趋势线由直线的数学公式描述，并且向左和向右无限延伸。如果你知道趋势线的公式，你可以将任何 *X*
    的值代入该公式，并得到 *Y* 值的预测。例如，如果你发现一条线的公式是 *Y = 2.5 x X + 22*，你可以将 *X = 75* 代入，你将得到预测的
    *Y = 2.5 x 75 + 22*，或者 *Y = 209.5*。从移动平均中无法得到这样的预测。
- en: Linear regression is just one type of regression algorithm, specifically used
    to find a straight line that fits the data. In this chapter, we will explore several
    other types of regression algorithms, each with a different shape. In all cases,
    you can use a metric that describes how well the regression fits the data. Typically,
    this metric will be **root mean squared error** (**RMSE**), which is the square
    root of the average of the squared error for each point compared to the trendline.
    Most regression algorithms are *least-squares* regressions, which aim to find
    the trendline that minimizes the RMSE.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归只是回归算法的一种类型，专门用于找到适合数据的直线。在本章中，我们将探讨几种其他类型的回归算法，每种算法都有不同的形状。在所有情况下，你可以使用一个描述回归如何适合数据的度量。通常，这个度量将是**均方根误差**（**RMSE**），它是每个点与趋势线比较的平方误差平均值的平方根。大多数回归算法都是*最小二乘法*回归，旨在找到最小化
    RMSE 的趋势线。
- en: Let's take a look at several examples of regression shapes and how to fit them
    to data in JavaScript.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个回归形状的例子以及如何在 JavaScript 中将它们拟合到数据中。
- en: Example 1 – linear regression
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 1 – 线性回归
- en: 'Before we dive into the first example, let''s take a minute to set up our project
    folder and dependencies. Create a new folder called `Ch7-Regression`, and inside
    that folder add the following `package.json` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入第一个例子之前，让我们花一分钟时间设置我们的项目文件夹和依赖项。创建一个名为 `Ch7-Regression` 的新文件夹，并在该文件夹内添加以下
    `package.json` 文件：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then run the `yarn install` command from the command line to install all dependencies.
    Next, create a folder called `src`, and add an empty file called `index.js`. Finally,
    download the `data.js` file from the book's GitHub repository into the `src` folder.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从命令行运行 `yarn install` 命令来安装所有依赖项。接下来，创建一个名为 `src` 的文件夹，并添加一个名为 `index.js`
    的空文件。最后，从书籍的 GitHub 仓库下载 `data.js` 文件到 `src` 文件夹。
- en: 'In this example, we''re going to work on the noisy linear data from the previous
    section. As a reminder, the data itself looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将处理上一节中的噪声线性数据。作为提醒，数据本身看起来是这样的：
- en: '![](img/6c6d5b17-4315-459f-8800-ff764c663ad3.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c6d5b17-4315-459f-8800-ff764c663ad3.png)'
- en: Our goal is to find the formula for a line that fits the data and make a prediction
    for a future value when *X = 75*. We'll use Tom Alexander's `regression` library,
    which can perform a number of types of regressions and also provides the capability
    to make predictions based on the resultant regression.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到一个适合数据的直线公式，并在 *X = 75* 时对未来值进行预测。我们将使用汤姆·亚历山大的 `regression` 库，它可以执行多种类型的回归，并提供基于结果回归进行预测的能力。
- en: 'In the `index.js` file, add the following import statements to the top of the
    file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.js` 文件中，将以下导入语句添加到文件顶部：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with all ML problems, you should start by visualizing your data and trying
    to understand the overall shape of the data before you choose the algorithm. In
    this case, we can see that the data follows a linear trend so we will choose the
    linear regression algorithm.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有机器学习问题一样，你应该首先可视化你的数据，并在选择算法之前尝试理解数据的整体形状。在这种情况下，我们可以看到数据遵循线性趋势，因此我们将选择线性回归算法。
- en: 'In linear regression, the goal is to determine the parameters for the formula
    for a line that best fits the data. The formula for a straight line has the following
    form: *y = mx + b*, sometimes written as *y = ax + b*, where *x* is the input
    variable or independent variable, *y* is the target or dependent variable, *m*
    (or *a*) is the *slope* or *gradient* of the line, and *b* is the *y-intercept*
    of the line (the Y-value of the line when *X = 0*). Therefore, the minimum requirements
    for the output of a linear regression are the values for *a* and *b*, the only
    two parameters that determine the shape of the line.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性回归中，目标是确定最佳拟合数据的直线公式的参数。直线的公式具有以下形式：*y = mx + b*，有时也写作 *y = ax + b*，其中 *x*
    是输入变量或自变量，*y* 是目标或因变量，*m*（或 *a*）是直线的*斜率*或*梯度*，而 *b* 是直线的*截距*（当 *X = 0* 时的 Y 值）。因此，线性回归输出的最小要求是
    *a* 和 *b* 的值，这两个参数是决定直线形状的唯一两个参数。
- en: 'Add the following import lines to `index.js`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下导入行添加到 `index.js`：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Performing a linear regression on the data will return a model; the model essentially
    encapsulates the values of *a* and *b*, or the slope and the intercept of the
    line. This particular library not only returns the line's parameters in the `linearModel.equation`
    property, but also gives us a string representation of the line formula, calculates
    the R² fit of the regression, and gives us a method, called `predict`, which we
    can use to plug a new X-value into the model.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据进行线性回归将返回一个模型；该模型本质上封装了 *a* 和 *b* 的值，即直线的斜率和截距。这个特定的库不仅返回 `linearModel.equation`
    属性中的直线参数，还提供了直线公式的字符串表示，计算回归的 R² 拟合度，并给我们一个名为 `predict` 的方法，我们可以用它将新的 X 值插入到模型中。
- en: 'Run the code by issuing the `yarn start` command from the command line. You
    should see the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行中发出 `yarn start` 命令来运行代码。你应该会看到以下输出：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The regression has determined that the formula for the line that best fits
    our data is *y = 2.47x + 22.6*. The original formula I used to create this test
    data was *y = 2.5x + 22*. The slight difference between the determined equation
    and the actual equation is due to the effect of the random noise I added to the
    dataset. As you can see, the linear regression has done a good job of looking
    past the noise and discovering the underlying pattern. If we chart these results,
    we will see the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回归确定，最适合我们数据的直线公式是 *y = 2.47x + 22.6*。我用来创建测试数据的原始公式是 *y = 2.5x + 22*。确定方程与实际方程之间的小差异是由于我添加到数据集中的随机噪声的影响。正如你所见，线性回归很好地超越了噪声，发现了潜在的规律。如果我们绘制这些结果，我们将看到以下情况：
- en: '![](img/ec75338a-7bc4-4a74-9a00-aebf94f1a9c3.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec75338a-7bc4-4a74-9a00-aebf94f1a9c3.png)'
- en: The results of the regression, as seen in the preceding graph, are exactly the
    same as the results given by the trendline feature of Excel or Google Sheets,
    with the difference being that we generated the trendline in JavaScript.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，回归的结果与 Excel 或 Google Sheets 的趋势线功能给出的结果完全相同，区别在于我们是在 JavaScript 中生成的趋势线。
- en: When asked to predict a future value where *X = 75*, the regression returns
    *Y = 207.85*. Using my original formula, the true value would have been 209.5\.
    The amount of noise I added to the data amounts to a random and uniform noise
    level of +/- 12.5 for any given point, so the predicted value turns out to be
    very close to the actual value when you account for the uncertainty due to noise.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当被要求预测 *X = 75* 的未来值时，回归返回 *Y = 207.85*。使用我的原始公式，真实值应该是 209.5。我添加到数据中的噪声量相当于任何给定点的随机和均匀噪声水平
    +/- 12.5，因此当考虑到噪声引起的不确定性时，预测值非常接近实际值。
- en: It should be noted, however, that errors in regression compound as you make
    predictions further away from the domain of the original data. When predicting
    for X = 75, the error between the prediction and the actual value is only 1.65\.
    If we were to predict for X = 1000, on the other hand, the true formula would
    return 2,522, but the regression would predict 2,492.6\. The error between the
    actual value and the prediction at X = 1000 is now 29.4, nearly 30, far beyond
    the uncertainty due to noise. Regressions are very useful predictors, but you
    must always keep in mind that these errors can compound and therefore the predictions
    will become less accurate as you get further away from the domain of the dataset.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，随着你预测越来越远离原始数据域，回归误差会累积。当预测 X = 75 时，预测值与实际值之间的误差仅为 1.65。另一方面，如果我们预测
    X = 1000，则真正的公式会返回 2,522，但回归会预测 2,492.6。在 X = 1000 时，实际值与预测值之间的误差现在为 29.4，接近 30，远超过由于噪声引起的不确定性。回归是非常有用的预测工具，但你必须始终记住，这些误差会累积，因此随着你远离数据集的域，预测将变得不那么准确。
- en: The reason for this type of prediction error lies in the regression for the
    slope of the equation. The slope of the line in the original equation is 2.5\.
    This means that for every unit change in the *X* value, we should expect a change
    of 2.5 units in the *Y* value. The regression, on the other hand, determines a
    slope of 2.47\. Therefore, for every unit change in the *X* value, the regression
    is inheriting a slight error of -0.03\. Predicted values will be slightly lower
    than actual values by that amount, multiplied by the *X* distance for your prediction.
    For every 10 units of *X*, the regression inherits a total error of -0.3\. For
    every 100 units of *X*, the regression inherits an error of -3.0, and so on. When
    we extrapolate out to X=1000, we've inherited an error of -30, because that slight
    per-unit error of -0.03 gets multiplied by the distance we travel along the *x*
    axis.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种预测误差的原因在于方程斜率的回归。原始方程中线的斜率是 2.5。这意味着对于 *X* 值的每单位变化，我们应该期望 *Y* 值变化 2.5 个单位。另一方面，回归确定斜率为
    2.47。因此，对于 *X* 值的每单位变化，回归会继承一个微小的误差 -0.03。预测值将比实际值略低，这个量乘以你的预测的 *X* 距离。对于每 10
    个单位的 *X*，回归会继承总共 -0.3 的误差。对于每 100 个单位的 *X*，回归会继承 -3.0 的误差，依此类推。当我们外推到 X=1000 时，我们继承了
    -30 的误差，因为那个每单位微小的误差 -0.03 乘以我们在 *x* 轴上移动的距离。
- en: When we look at values within our data domain—values between X = 0 and X = 50—we
    only get very small prediction errors due to this slight difference in slope.
    Within our data domain, the regression has corrected for the error in slope by
    slightly increasing the y-intercept value (the original is +22, the regression
    returned +22.6). Due to the noise in our data, the regression formula of *y =
    2.47x + 22.6* is a better fit than the actual formula of *y = 2.5x + 22*. The
    regression finds a slightly less-steep slope and makes up for it by raising the
    entire line by 0.6 units (the difference in y-intercepts), because this fits both
    the data and the noise better. This model fits the data very well between X =
    0 and X = 50, but when we try to predict the value when X = 1000, the slight +0.6
    modification in the y-intercept is no longer enough to make up for the decreased
    slope over such a vast distance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看数据域内的值——X = 0 和 X = 50 之间的值——由于斜率略有差异，我们只会得到非常小的预测误差。在我们的数据域内，回归通过略微增加y截距值（原始值为
    +22，回归返回 +22.6）来纠正斜率误差。由于我们数据中的噪声，回归公式 *y = 2.47x + 22.6* 比实际公式 *y = 2.5x + 22*
    更好地拟合。回归找到一个略微平缓的斜率，并通过将整个线提高0.6个单位（y截距的差异）来弥补这一点，因为这样更适合数据和噪声。这个模型在 X = 0 和 X
    = 50 之间拟合得非常好，但当我们尝试预测 X = 1000 时的值时，y截距中轻微的 +0.6 修改已不足以弥补如此巨大距离上的斜率下降。
- en: Linear trends like the one found in this example are very common. There are
    many types of data that exhibit linear relationships and can be modeled simply
    yet accurately as long as you don't attempt to over-extrapolate the data. In the
    next example, we'll take a look at exponential regressions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 像这个例子中找到的线性趋势非常常见。有许多类型的数据表现出线性关系，只要你不尝试过度外推数据，就可以简单而准确地建模。在下一个例子中，我们将查看指数回归。
- en: Example 2 – exponential regression
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 2 – 指数回归
- en: 'Another common trend in continuous data patterns is *exponential growth**,*
    which is also commonly seen as *exponential decay. *In exponential growth, a future
    value is proportionally related to the current value. The general formula for
    this type of growth can be written as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 连续数据模式中的另一个常见趋势是 *指数增长**，它也通常被视为 *指数衰减。* 在指数增长中，未来的值与当前值成比例。这种类型增长的一般公式可以写成：
- en: '*y = y[0] (1 + r) x*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = y[0] (1 + r) x*'
- en: Where *y[0]* is the quantity's initial value (when *x* = 0), and *r* is the
    growth rate of the quantity.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*y[0]* 表示数量的初始值（当 *x* = 0 时），而 *r* 是该数量的增长率。'
- en: For instance, if you are investing money in the stock market and expect a 5%
    rate of return per year (*r = 0.05*) with an initial investment of $10,000, after
    five years you can expect $12,763\. The exponential growth formula applies here
    because the amount of money you have next year is proportionally related to the
    amount of money you have this year, and the amount of money you have two years
    from now is related to the money you have next year, and so on. This only applies
    if you reinvest your returns, causing the amount of money you're actively investing
    to increase with each passing year.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在股市投资并期望每年有5%的回报率（*r = 0.05*），初始投资为10,000美元，五年后你可以期望有12,763美元。指数增长公式适用于这里，因为明年你拥有的金额与今年你拥有的金额成比例，两年后你拥有的金额与明年你拥有的金额成比例，依此类推。这仅适用于你重新投资回报，导致你积极投资的金额每年增加。
- en: 'Another form for the exponential growth equation is given as:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 指数增长方程的另一种形式如下：
- en: '*y = ae^(bx)*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = ae^(bx)*'
- en: Where *b = ln(1 + r)*, *a* is the initial value *y[0]*, and *e* is Euler's constant
    of approximately 2.718\. This slight transformation in form is easier to manipulate
    mathematically and is typically the preferred form used by mathematicians for
    analysis. In our stock market investment example, we can rewrite the formula for
    five year growth as *y = 10000*e^(ln(1.05)*5)*, and we will get the same result
    of $12,763.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *b = ln(1 + r)*，*a* 是初始值 *y[0]*，而 *e* 是约等于2.718的欧拉常数。这种形式上的轻微变换在数学上更容易操作，并且通常是数学家用于分析的首选形式。在我们的股市投资例子中，我们可以将五年增长公式重写为
    *y = 10000*e^(ln(1.05)*5)*，我们将会得到同样的结果12,763美元。
- en: 'Exponential growth is sometimes called **hockey-stick growth** due to the shape
    of the curve resembling the outline of a hockey stick:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 指数增长有时被称为 **曲棍球棒增长**，因为曲线的形状类似于曲棍球的轮廓：
- en: '![](img/4dd1b88a-4d6a-472b-aaeb-21d67069bb13.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dd1b88a-4d6a-472b-aaeb-21d67069bb13.png)'
- en: 'Some examples of exponential growth include:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 指数增长的例子包括：
- en: Population growth; that is, world population or bacterial culture growth
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人口增长；即世界人口或细菌培养生长
- en: Viral growth, such as analysis of disease infections or the viral spread of
    YouTube videos
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 病毒式增长，例如疾病感染的分析或YouTube视频的病毒式传播
- en: Positive feedback loops in mechanics or signal processing
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机械或信号处理中的正反馈回路
- en: Economic growth, including compound interest
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经济增长，包括复利
- en: Processing power of computers under Moore's law
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩尔定律下计算机的处理能力
- en: It is important to note that, in almost all circumstances, exponential growth
    is unsustainable. For example, if you are predicting the growth of a bacterial
    colony in a Petri dish, you may observe exponential growth for a short time, however
    once the Petri dish runs out of food and space, other factors will take over and
    the growth will no longer be exponential. Similarly, if your website incentivizes
    new users to invite their friends, you may see exponential growth in your membership
    for a while, but eventually you will saturate the market and growth will slow.
    Therefore, you must be cautious in analyzing exponential growth models and understand
    that the conditions that fuel exponential growth may ultimately change. Similar
    to linear regression, an exponential regression will only apply to modest extrapolations
    of your data. Your website's membership may grow exponentially for a year, but
    not for ten years; you cannot have 20 billion members if there are only seven
    billion people on Earth.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在几乎所有情况下，指数增长都是不可持续的。例如，如果你在预测培养皿中细菌菌落的增长，你可能会观察到一段时间的指数增长，然而一旦培养皿中的食物和空间耗尽，其他因素将占主导地位，增长将不再呈指数形式。同样，如果你的网站通过激励新用户邀请朋友来增加会员，你可能会看到一段时间内会员数的指数增长，但最终市场将饱和，增长会放缓。因此，在分析指数增长模型时必须谨慎，并理解推动指数增长的条件最终可能会改变。与线性回归类似，指数回归只适用于数据的适度外推。你的网站会员可能一年内会呈指数增长，但不可能持续十年；地球上只有70亿人口，你不能有200亿会员。
- en: If the growth rate, *r*, or the parameter *k* (called the **growth constant**),
    is negative, you will have exponential decay rather than exponential growth. Exponential
    decay is still exponential growth in the sense that future values are proportional
    to the current value, however in exponential decay, future values are proportionately
    *smaller* than the current value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果增长率*r*或参数*k*（称为**增长常数**）为负，那么你将得到指数衰减而不是指数增长。尽管在指数衰减中，未来的值与当前值成比例，但未来的值在比例上比当前值*小*。
- en: One real-world use of exponential decay is in carbon-dating analysis. Because
    the radioactive carbon-14 isotope decays into non-radioactive carbon-12 with a
    half-life of 5,730 years—meaning that, in aggregate, half the carbon-14 decays
    into carbon-12 every 5,730 years—scientists can use the exponential decay formula
    to figure out how old an object must be in order to have the appropriate ratio
    of carbon-14 to carbon-12.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 指数衰减的一个实际应用是在碳-14年代测定中。因为放射性碳-14同位素以5730年的半衰期衰变为非放射性碳-12——这意味着在总体上，每5730年有一半的碳-14衰变为碳-12——科学家可以使用指数衰减公式来计算出物体必须有多久才能达到碳-14与碳-12的适当比例。
- en: Exponential decay is also seen in physics and mechanics, particularly in the
    spring-mass-damper problem. It can also be used by coroners and medical examiners
    to determine the time of death of a subject, based on the fact that a warm body
    will cool down and approach the ambient temperature of the room in an exponentially
    decaying fashion.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 指数衰减在物理学和力学中也有所体现，尤其是在弹簧-质量-阻尼问题中。验尸官和法医也可以利用这一原理，根据尸体温度以指数衰减的方式逐渐接近室温来确定死亡时间。
- en: 'In exponential regression, our goal is to determine the values of the parameters
    *a* and *b*—the initial value and the growth constant. Let''s try this in JavaScript.
    The data we wish to analyze is exponentially decaying, with random sensor noise
    added:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在指数回归中，我们的目标是确定参数*a*和*b*的值——初始值和增长常数。让我们用JavaScript来尝试一下。我们希望分析的数据是指数衰减的，并添加了随机传感器噪声：
- en: '![](img/928b67bb-e521-4c2a-af8a-64d5cad67500.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/928b67bb-e521-4c2a-af8a-64d5cad67500.png)'
- en: The preceding chart exhibits some quantity that starts near 100 and decays down
    to approximately 0\. This could represent, for instance, the number of visitors
    over time to a post that was shared on Facebook.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了一些量，它从接近100开始衰减到大约0。例如，这可以代表在Facebook上分享的帖子随时间变化的访问者数量。
- en: 'Attempting to fit a trendline with Excel or Google Sheets does not help us
    in this case. The linear trendline does not fit the exponential curve, and the
    inappropriateness of the fit is indicated by the poor R² value:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用Excel或Google Sheets来拟合趋势线在这种情况下并不能帮助我们。线性趋势线并不适合指数曲线，不合适的拟合可以通过较差的R²值来表示：
- en: '![](img/e6682428-e2cf-4d50-8bae-007dd6ce7e70.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6682428-e2cf-4d50-8bae-007dd6ce7e70.png)'
- en: 'Let''s now use JavaScript to find the regression for this data and also make
    a prediction of the value for one second before the dataset started. Add the following
    code to `index.js`; it is the linear regression code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用JavaScript来找到这个数据的回归，并预测数据集开始前一秒的值。将以下代码添加到`index.js`中；这是线性回归代码：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the program with `yarn start` and you should see the following output,
    following the output for the linear regression example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`yarn start`运行程序，你应该看到以下输出，紧随线性回归示例的输出之后：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can immediately see the high R² value of 0.99, indicating that the regression
    has found a good fit to the data. If we chart this regression along with the original
    data, we see the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到高R²值0.99，这表明回归已经很好地拟合了数据。如果我们将这个回归与原始数据一起绘制，我们会看到以下结果：
- en: '![](img/7bfcc118-4465-45e4-9359-e1ac6b4c739e.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7bfcc118-4465-45e4-9359-e1ac6b4c739e.png)'
- en: Additionally, we get a prediction for X = -1 of 103, which fits our data well.
    The original parameters for the equation I used to generate the test data were
    *a = 100* and *b = -0.1*, while the predicted parameters were *a = 94.5* and *b
    = -0.09*. The presence of noise has made a significant impact on the starting
    value, which would have been 100 if there were no noise in the system, but was
    actually measured at 96\. When comparing the regressed value for *a* to the actual
    value of *a*, you must also consider the fact that the regressed value of *a*
    was close to the measured, noisy value, even though it is pretty far from the
    systemic value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还得到了X = -1时的预测值为103，这与我们的数据拟合得很好。我用来生成测试数据的方程的原始参数是**a = 100**和**b = -0.1**，而预测的参数是**a
    = 94.5**和**b = -0.09**。噪声的存在对起始值产生了重大影响，如果没有噪声，起始值应该是100，但实际上测量值为96。当比较回归值**a**与实际值**a**时，你还必须考虑回归值**a**接近测量值（即使它离系统值相当远）这一事实。
- en: In the next section, we will take a look at the polynomial regression.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨多项式回归。
- en: Example 3 – polynomial regression
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例3 – 多项式回归
- en: 'The polynomial regression can be considered a more generalized form of the
    linear regression. A polynomial relationship has the form:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式回归可以被认为是线性回归的更一般形式。多项式关系的形式为：
- en: '*y = a[0] + a[1]x¹ + a[2]x² + a[3]x³ + ... + a[n]x^n*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**y = a[0] + a[1]x¹ + a[2]x² + a[3]x³ + ... + a[n]x^n**'
- en: 'A polynomial can have any number of terms, which is called the **degree** of
    the polynomial. For each degree of the polynomial, the independent variable, *x*,
    is multiplied by some parameter, *a[n]*,, and the X-value is raised to the power
    *n*. A straight line is considered a polynomial of degree *1*; if you update the
    preceding polynomial formula to remove all degrees above one, you are left with:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式可以有任意多个项，这被称为多项式的**次数**。对于多项式的每个次数，自变量**x**乘以某个参数**a[n]**，X值被提升到**n**次幂。一条直线被认为是**一次**多项式；如果你更新前面的多项式公式以删除高于一次的所有次数，你将剩下：
- en: '* y = a[0] + a[1]x*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**y = a[0] + a[1]x**'
- en: Where *a[0]* is the y-intercept and *a[1]* is the slope of the line. Despite
    the slight difference in notation, this is equivalent to *y = mx + b*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其中**a[0]**是y轴截距，**a[1]**是线的斜率。尽管符号略有不同，但这与**y = mx + b**是等价的。
- en: Quadratic equations, which you may recall from high school math, are simply
    polynomials of degree *2*, or *y = a[0] + a[1]x + a[2]x²*. Cubic equations are
    polynomials of degree 3, quadratic equations are polynomials of degree 4, and
    so on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 二次方程，你可能还记得从高中数学中学过的，它仅仅是**二次**的多项式，或者**y = a[0] + a[1]x + a[2]x²**。三次方程是**三次**的多项式，四次方程是**四次**的多项式，以此类推。
- en: The property of polynomials and polynomial regressions that makes them so powerful
    is the fact that nearly any shape can be described by a polynomial of sufficient
    degree, within a limited range of values. Polynomial regressions can even fit
    sinusoidal shapes, as long as you don't try to extrapolate too far. Polynomial
    regressions exhibit properties similar to other machine learning algorithms in
    the sense that they can overfit and become very inaccurate for new data points
    if you attempt to extrapolate too far.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式和多项式回归的属性使它们如此强大，是因为在有限的值范围内，几乎任何形状都可以用足够次数的多项式来描述。只要你不尝试过度外推，多项式回归甚至可以拟合正弦形状。多项式回归在某种程度上表现出与其他机器学习算法相似的性质，即如果你尝试过度外推，它们可能会过拟合并对于新的数据点变得非常不准确。
- en: Because polynomials can be of any degree, you must also configure the regression
    with an additional parameter; this parameter can be guessed or you can search
    for the degree that maximizes the R² fit. This approach is similar to the approach
    we used for k-means when you don't know the number of clusters in advance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为多项式可以是任何次数，所以你也必须配置回归的附加参数；这个参数可以猜测，或者你可以寻找最大化R²拟合度的次数。这种方法与我们用于k-means（当你事先不知道聚类数量时）的方法类似。
- en: 'The data we wish to fit, when graphed, looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望拟合的数据，当绘制时，看起来像这样：
- en: '![](img/8bcfab46-a8df-43ab-b29e-87973f606582.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bcfab46-a8df-43ab-b29e-87973f606582.png)'
- en: This small window of data looks sinusoidal but is in fact polynomial; remember
    that polynomial equations can reproduce many types of shapes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小数据窗口看起来是正弦形的，但实际上是多项式的；记住，多项式方程可以复制许多类型的形状。
- en: 'Add the following code to the bottom of `index.js`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`index.js`的底部：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we have configured the regression with `{order: 2}`, that is, we
    are attempting to fit the data with a quadratic formula. Run the program with
    `yarn start` to see the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，我们已经将回归配置为`{order: 2}`，这意味着我们正在尝试用二次公式拟合数据。使用`yarn start`运行程序，可以看到以下输出：'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The R² fit for this data is quite low, at `0.75`, indicating that we have probably
    used an incorrect value for the `order` parameter. Try increasing the order to
    `{order: 4}` and re-run the program to get the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '这组数据的R²拟合度相当低，为`0.75`，这表明我们可能使用了错误的`order`参数值。尝试将顺序增加到`{order: 4}`并重新运行程序，可以得到以下结果：'
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The regression is a much better fit now, at the expense of having added extra
    polynomial terms to the equation. If we graph this regression against the original
    data, we will see the following output, which indeed fits the data very well:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回归拟合得更好了，但代价是方程中添加了额外的多项式项。如果我们用原始数据来绘制这个回归，我们会看到以下输出，这确实很好地拟合了数据：
- en: '![](img/135d82e1-3f14-42d7-a7cd-29ae566248cb.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/135d82e1-3f14-42d7-a7cd-29ae566248cb.png)'
- en: In the next section, we will explore some other types of analyses that can be
    performed on time-series data, including low-pass and high-pass filters, and seasonality
    analysis.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨可以在时间序列数据上执行的其他类型分析，包括低通滤波器、高通滤波器和季节性分析。
- en: Other time-series analysis techniques
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他时间序列分析技术
- en: Regressions are a great starting point for analyzing continuous data, however,
    there are many other techniques one can employ when analyzing time-series data
    specifically. While regressions can be used for any continuous data mapping, time-series
    analysis is specifically geared toward continuous data that evolves over time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回归分析是分析连续数据的良好起点，然而，在分析特定的时间序列数据时，还有许多其他技术可以采用。虽然回归可以用于任何连续数据的映射，但时间序列分析专门针对随时间演变的连续数据。
- en: 'There are many examples of time-series data, for instance:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列数据有很多例子，例如：
- en: Server load over time
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器负载随时间变化
- en: Stock prices over time
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票价格随时间变化
- en: User activity over time
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户活动随时间变化
- en: Weather patterns over time
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气候模式随时间变化
- en: The objective when analyzing time-series data is similar to the objective in
    analyzing continuous data with regressions. We wish to identify and describe the
    various factors that influence the changing value over time. This section will
    describe a number of techniques above and beyond regressions that you can use
    to analyze time-series data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分析时间序列数据时的目标与使用回归分析连续数据时的目标相似。我们希望识别和描述影响随时间变化的值的各种因素。本节将描述一些超越回归的技术，您可以使用这些技术来分析时间序列数据。
- en: In this section, we will look at techniques that come from the field of digital
    signal processing, which has applications in electronics, sensor analysis, and
    audio signals. While your specific time-series problem may not be related to any
    of these fields, the tools used in digital signal processing applications can
    be applied to any problem domain that deals with digital signals. Among the most
    significant tools and techniques are filtering, seasonality detection, and frequency
    analysis. We'll discuss these techniques, but I will leave it up to you to implement
    your own examples and experiments.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨来自数字信号处理领域的技巧，该领域在电子学、传感器分析和音频信号处理中都有应用。虽然你的具体时间序列问题可能与这些领域无关，但数字信号处理应用中使用的工具可以应用于任何处理数字信号的领域。其中最显著的工具和技术包括滤波、季节性检测和频谱分析。我们将讨论这些技术，但我将把实现自己的示例和实验留给你。
- en: Filtering
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滤波
- en: Filtering, in a digital signal processing context, is a technique used to filter
    out either high-frequency or low-frequency components of a signal. These are called
    **low-pass filters** and **high-pass filters**, respectively; a low-pass filter
    allows low-frequency signals to *pass* while removing high-frequency components
    from the signal. There are also *band-pass* and *notch* filters, which either
    allow a range of frequencies to pass or cut a range of frequencies from the signal.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字信号处理的背景下，滤波是一种用于过滤掉信号的高频或低频成分的技术。这些分别被称为**低通滤波器**和**高通滤波器**；低通滤波器允许低频信号通过，同时从信号中移除高频成分。还有**带通滤波器**和**陷波滤波器**，它们允许一定范围内的频率通过或从信号中截断一定范围的频率。
- en: In electronics, filters are designed by using capacitors, resistors, and other
    simple electronic components in order to allow only frequencies above or below
    a *cut-off* *frequency* to pass through the circuit. In digital signal processing,
    the same effect can be achieved with an *infinite impulse response* filter, which
    is an algorithm that can reproduce the effects of an electronic circuit on time-series
    data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子学中，通过使用电容器、电阻和其他简单的电子元件来设计滤波器，以便只允许高于或低于一个**截止频率**的频率通过电路。在数字信号处理中，可以通过一个**无限脉冲响应**滤波器实现相同的效果，这是一种可以再现电子电路对时间序列数据影响的算法。
- en: 'To illustrate this, consider the following data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑以下数据：
- en: '![](img/0f3482fb-e2bf-4a0b-ae03-693641f263d6.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f3482fb-e2bf-4a0b-ae03-693641f263d6.png)'
- en: 'This data was generated by combining two sinusoidal signals, one low-frequency
    signal and one high-frequency signal. If we chart the two signals individually,
    we can see how they combine to create the overall signal:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这组数据是通过组合两个正弦信号生成的，一个是低频信号，另一个是高频信号。如果我们单独绘制这两个信号，我们可以看到它们是如何组合成整体信号的：
- en: '![](img/4c71d815-d1a7-4dd8-8731-5ecdc504f319.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c71d815-d1a7-4dd8-8731-5ecdc504f319.png)'
- en: When filtering the overall signal, the goal is to extract either the low-frequency
    or the high-frequency component of the signal, while filtering the other out.
    This is called **subtractive processing**, since we are removing (filtering) a
    component from the signal.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤整体信号时，目标是提取信号的低频或高频成分，同时过滤掉另一个成分。这被称为**减法处理**，因为我们是从信号中移除（过滤）一个成分。
- en: In general, you should use low-pass filtering to isolate large, general, periodic
    trends in time-series data while ignoring faster periodic trends. High-pass filtering,
    on the other hand, should be used when you wish to explore the short-term periodic
    trends while ignoring the long-term trends. One example of this approach is when
    analyzing visitor traffic; you can use high-pass and low-pass filtering to selectively
    ignore monthly trends versus daily trends.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你应该使用低通滤波来隔离时间序列数据中的大范围、一般性的周期性趋势，同时忽略较快的周期性趋势。另一方面，当你希望探索短期周期性趋势而忽略长期趋势时，应该使用高通滤波。这种方法的一个例子是在分析访客流量时；你可以使用高通和低通滤波来选择性地忽略月度趋势与日度趋势。
- en: Seasonality analysis
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 季节性分析
- en: 'Building on the previous section, we can also use digital signal processing
    to analyze seasonal trends. Seasonal trends are long-term periodic (that is, low-frequency)
    trends that you wish to subtract from your overall data in order to analyze other,
    potentially non-periodic trends in data. Consider the following graph:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的基础上，我们还可以使用数字信号处理来分析季节性趋势。季节性趋势是长期周期性（即低频）趋势，你希望从整体数据中减去，以便分析数据中的其他可能非周期性趋势。考虑以下图表：
- en: '![](img/e6c51674-759f-47b5-b62d-43960d3bdacd.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6c51674-759f-47b5-b62d-43960d3bdacd.png)'
- en: This data exhibits a combination of linear growth on top of periodic fluctuations
    in activity. Specifically, there are two periodic components (one low-frequency
    and one high-frequency) and one linear component to this data trend.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这份数据显示了活动周期性波动之上的线性增长组合。具体来说，这个数据趋势有两个周期性成分（一个低频和一个高频）和一个线性成分。
- en: 'In order to analyze this data, the approach would be to first identify the
    linear trend, either through a large moving-average window or through a linear
    regression. Once the linear trend has been identified, you can subtract it from
    the data to isolate the periodic portions only. This approach is illustrated as
    follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析这些数据，首先的方法是识别线性趋势，无论是通过一个大的移动平均窗口还是通过线性回归。一旦确定了线性趋势，就可以从数据中减去它，以仅隔离周期性部分。以下是如何展示这个方法的：
- en: '![](img/8ac0f8fa-ab8c-42b4-96dc-220c50a0db30.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ac0f8fa-ab8c-42b4-96dc-220c50a0db30.png)'
- en: Because signals are additive, you are able to subtract the linear trend from
    the original data in order to isolate the non-linear components of the signal.
    If you've identified multiple trends, either through regressions or other means,
    you can continue to subtract the trends that you've identified from the original
    signal and you'll be left with only the unidentified signal components. Once you've
    identified and subtracted all of the systemic patterns, you'll have only the sensor
    noise remaining.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为信号是可加的，所以你可以从原始数据中减去线性趋势，以隔离信号的非线性成分。如果你已经通过回归或其他方式识别了多个趋势，你可以继续从原始信号中减去你已识别的趋势，最终只剩下未识别的信号成分。一旦你识别并减去了所有的系统模式，你将只剩下传感器噪声。
- en: In this case, once you've identified and subtracted the linear trend from the
    data, you can either perform filtering on the resultant signal in order to isolate
    the low- and high-frequency components, or you can perform a *Fourier analysis*
    on the leftover signal to identify the specific frequencies and amplitudes of
    the remaining components.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一旦你从数据中识别并减去线性趋势，你可以对结果信号进行滤波，以隔离低频和高频成分，或者可以对剩余信号进行*傅里叶分析*，以识别剩余成分的具体频率和幅度。
- en: Fourier analysis
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 傅里叶分析
- en: 'Fourier analysis is a mathematical technique used to decompose a time-series
    signal into its individual frequency components. Recall that polynomial regressions
    of arbitrary degree can reproduce nearly any signal shape. In a similar manner,
    the sum of a number of sinusoidal oscillators can reproduce nearly any periodic
    signal. If you''ve ever seen an *oscilloscope* or *spectrum analyzer* in action,
    you''ve seen the real-time results of a Fourier transform being applied to a signal.
    In short, a Fourier transformation turns a periodic signal, such as the ones we
    saw in the last section, into a formula similar to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶分析是一种数学技术，用于将时间序列信号分解为其各自的频率分量。回想一下，任意阶数的多项式回归可以复制几乎任何信号形状。以类似的方式，多个正弦振荡器的总和可以复制几乎任何周期性信号。如果你曾经看到过*示波器*或*频谱分析仪*在工作，你就看到了傅里叶变换应用于信号的实时结果。简而言之，傅里叶变换将周期性信号，如我们在上一节中看到的，转换成类似以下的公式：
- en: '*a[1]sin(f[1]+φ[1]) + a[2]sin(f[2]+φ[2]) + a[3]sin(f[3]+φ[3]) + ... + a[n]sin(f[n]+φ[n])*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*a[1]sin(f[1]+φ[1]) + a[2]sin(f[2]+φ[2]) + a[3]sin(f[3]+φ[3]) + ... + a[n]sin(f[n]+φ[n]*) '
- en: Where *f[n]* represents a frequency, *a[n]* represents its amplitude, and *φ[n]*
    represents a phase offset. By combining an arbitrary number of these sinusoidal
    signals together, one can replicate nearly any periodic signal.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *f[n]* 代表频率，*a[n]* 代表其幅度，*φ[n]* 代表相位偏移。通过组合任意数量的这些正弦信号，可以复制几乎任何周期性信号。
- en: There are many reasons to perform a Fourier analysis. The most intuitive examples
    relate to audio and sound processing. If you take a one-second-long audio sample
    of the note A4 being played on a piano and perform a Fourier transform on it,
    you would see that the frequency of 440 Hz has the largest amplitude. You would
    also see that the harmonics of 440 Hz, like 880 Hz and 1,320 Hz, also have some
    energy. You can use this data to aid in audio fingerprinting, auto-tuning, visualizing,
    and many other applications. The Fourier transformation is a sampling algorithm,
    and so it is susceptible to aliasing and other sampling errors. A Fourier transformation
    can be used to partially recreate an original signal, but much detail would be
    lost in translation. This process would be similar to down-sampling an image and
    then trying to up-sample it again.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 进行傅里叶分析有许多原因。最直观的例子与音频和声音处理相关。如果你取一个一秒钟长的音频样本，记录钢琴上演奏的A4音符，并对它进行傅里叶变换，你会看到440
    Hz的频率具有最大的振幅。你还会看到440 Hz的谐波，如880 Hz和1,320 Hz，也具有一定的能量。你可以使用这些数据来辅助音频指纹识别、自动调音、可视化以及许多其他应用。傅里叶变换是一种采样算法，因此它容易受到混叠和其他采样误差的影响。傅里叶变换可以用来部分重建原始信号，但在转换过程中会丢失很多细节。这个过程与对图像进行下采样然后再尝试上采样是相似的。
- en: There are many other applications for Fourier transforms in nearly every domain.
    The Fourier transform's popularity is due to the fact that, mathematically, many
    types of operations are easier to perform in the frequency domain than the time
    domain. There are many types of problems in mathematics, physics, and engineering
    that are very difficult to solve in the time domain but easy to solve in the frequency
    domain.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎每个领域，傅里叶变换都有许多其他应用。傅里叶变换之所以受欢迎，是因为在数学上，许多类型的操作在频域中比在时域中更容易执行。在数学、物理和工程中，有许多问题在时域中非常难以解决，但在频域中却容易解决。
- en: A Fourier transformation is a mathematical process that specific algorithms
    perform. The most popular Fourier transform algorithm is called the **Fast Fourier
    Transform** (**FFT**), named s0 because it was much faster than its predecessor,
    the *Discrete Fourier Transform*. The FFT has one significant limitation in that
    the number of samples to be analyzed must be a power of 2, that is, it must be
    128, 256, 512, 1,024, 2,048, and so on, samples long. If you have 1,400 samples
    to analyze, you must either truncate it down to 1,024 samples or pad it up to
    2,048 samples. Most often, you will be *windowing* a larger sample; in the example
    of the piano note recording, we have windowed one second of samples from a live
    or recorded signal. If the audio sample rate is 44,100 Hz, then we would have
    44,100 samples (one second's worth) to give to the Fourier transformation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶变换是一种由特定算法执行的计算过程。最流行的傅里叶变换算法称为**快速傅里叶变换**（**FFT**），之所以命名为FFT，是因为它比其前身*离散傅里叶变换*快得多。FFT有一个显著的限制，即要分析样本的数量必须是2的幂，也就是说，它必须是128、256、512、1,024、2,048等等样本长。如果你有1,400个样本要分析，你必须将其截断到1,024个样本或填充到2,048个样本。通常，你会对较大的样本进行*加窗*；在钢琴音符录音的例子中，我们从实时或录制的信号中提取了一秒钟的样本。如果音频采样率为44,100
    Hz，那么我们就有了44,100个样本（一秒钟的样本）要提供给傅里叶变换。
- en: When padding, truncating, or windowing samples from a larger signal, you should
    use a *window function*, which is a function that tapers the signal at both ends
    so that it is not sharply cut off by your window. There are many types of window
    functions, each with their own mathematical properties and unique effects on your
    signal processing. Some popular window functions include the rectangular and triangular
    windows, as well as the Gaussian, Lanczos, Hann, Hamming, and Blackman windows,
    which each have desirable properties in different types of analyses.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当对来自较大信号的样本进行填充、截断或加窗时，你应该使用一个*窗函数*，这是一个在两端逐渐减小信号的函数，以便它不会被你的窗口锐利地截断。有许多类型的窗函数，每种都有其自己的数学特性和对信号处理的独特影响。一些流行的窗函数包括矩形窗和三角形窗，以及高斯窗、兰佐斯窗、汉宁窗、汉明窗和布莱克曼窗，它们在不同的分析类型中都具有可取的特性。
- en: The output of a Fourier transform algorithm, like the FFT algorithm, is a *frequency
    domain spectrum*. More concretely, the output of the FFT algorithm will be an
    array or a hash table where the keys are frequency buckets (such as 0-10 Hz, 10-20
    Hz, and so on), and the values are amplitude and phase. These may be represented
    as complex numbers, multidimensional arrays, or some other structure specific
    to the algorithm implementation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于FFT算法的傅里叶变换算法的输出是一个*频域频谱*。更具体地说，FFT算法的输出将是一个数组或哈希表，其中键是频率桶（例如0-10 Hz，10-20
    Hz等），值是幅度和相位。这些可能表示为复数、多维数组或算法实现中特定的其他结构。
- en: Some limitations apply to all sampling algorithms; these are limitations of
    signal processing itself. For instance, aliasing can occur if your signal contains
    components at frequencies above the *Nyquist frequency*, or half the sampling
    rate. In audio, where a sampling rate of 44,100 Hz is common, any frequencies
    above 22,050 Hz will be aliased, or misrepresented as low-frequency signals. Preprocessing
    signals with a low-pass filter is therefore a common technique. Similarly, the
    FFT algorithm can only resolve frequencies up to the Nyquist frequency. The FFT
    algorithm will return only as many frequency buckets as the sample buffer size,
    so if you give it 1,024 samples you will only get 1,024 frequency buckets. In
    audio, this means that each frequency bucket will have a bandwidth of 44,100 Hz
    / 1,024 = 43 Hz. This means that you would not be able to tell the difference
    between 50 Hz and 55 Hz, but you would easily be able to tell the difference between
    50 Hz and 500 Hz. In order to get a higher resolution, you would need to provide
    more samples, however, this, in turn, will reduce the time resolution of your
    windows.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有采样算法都存在一些限制；这些限制是信号处理本身的限制。例如，如果您的信号包含高于*奈奎斯特频率*的成分，或者采样率的一半，就会发生混叠。在音频中，常见的采样率为44,100
    Hz，任何高于22,050 Hz的频率都会发生混叠，或者被错误地表示为低频信号。因此，使用低通滤波器预处理信号是一种常见的技术。同样，FFT算法只能解析到奈奎斯特频率。FFT算法将只返回与样本缓冲区大小一样多的频率桶，所以如果您提供1,024个样本，您将只得到1,024个频率桶。在音频中，这意味着每个频率桶的带宽为44,100
    Hz / 1,024 = 43 Hz。这意味着您可能无法区分50 Hz和55 Hz，但您很容易就能区分50 Hz和500 Hz。为了获得更高的分辨率，您需要提供更多的样本，然而，这反过来又会降低您窗口的时间分辨率。
- en: You can use the FFT to analyze the periodic portion of the time-series data
    we saw in the last section. It would be best to perform the FFT after you have
    subtracted the linear trend from the signal. However, if you have a high enough
    frequency resolution, the linear trend may only be interpreted as a low-frequency
    component of the Fourier transformation, so whether or not you need to subtract
    the linear trend will depend on your specific application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用FFT来分析我们在上一节中看到的时间序列数据的周期部分。最好在从信号中减去线性趋势后执行FFT。然而，如果您有足够高的频率分辨率，线性趋势可能只被解释为傅里叶变换的低频成分，因此是否需要减去线性趋势将取决于您的具体应用。
- en: By adding the FFT to the other tools you have learned about in this chapter,
    you are prepared to tackle most real-world regression or time-series analysis
    tasks. Each problem will be unique, and you will have to carefully consider which
    specific tools you will need for your task.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将FFT添加到本章中您所学的其他工具，您已经准备好应对大多数现实世界的回归或时间序列分析任务。每个问题都是独特的，您将必须仔细考虑您任务中需要哪些特定的工具。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a number of techniques used in forecasting, signal
    processing, regression, and time-series data analysis. Because forecasting and
    time-series analysis is a broad category, there is no single algorithm you can
    use that covers every case. Instead, this chapter has given you an initial toolbox
    of important concepts and algorithms that you can start applying to your forecasting
    and regression tasks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了在预测、信号处理、回归和时间序列数据分析中使用的许多技术。由于预测和时间序列分析是一个广泛的类别，没有单一的算法可以涵盖所有情况。相反，本章为您提供了一个初始的工具箱，其中包含了一些重要的概念和算法，您可以从这些算法开始应用到您的预测和回归任务中。
- en: Specifically, you learned about the difference between regression and classification.
    While classification assigns labels to data points, regression attempts to predict
    the numerical value of a data point. Not all regression is necessarily forecasting,
    but regression is the single most significant technique used in forecasting.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你学习了回归和分类之间的区别。分类将标签分配给数据点，而回归则试图预测数据点的数值。并非所有的回归都是必要的预测，但回归是预测中使用的最显著的单一技术。
- en: After learning the basics of regression, we explored a few specific types of
    regression. Namely, we discussed linear, polynomial, and exponential regression.
    We saw how regression deals with noise and how we can use it to predict future
    values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习回归的基本知识之后，我们探索了几种特定的回归类型。具体来说，我们讨论了线性、多项式和对数回归。我们看到了回归如何处理噪声，以及我们如何利用它来预测未来的值。
- en: We then turned to the broader concept of time-series analysis, and discussed
    core concepts, such as extracting trends from signals. We discussed tools used
    in digital signal processing that are applicable to time-series analysis, such
    as low-pass and high-pass filters, seasonality analysis, and Fourier transformations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向更广泛的时间序列分析概念，并讨论了核心概念，例如从信号中提取趋势。我们讨论了在数字信号处理中适用的工具，这些工具适用于时间序列分析，例如低通和高通滤波器、季节性分析和傅里叶变换。
- en: In the next chapter, we're going to look at more advanced machine learning models.
    Specifically, we're going to learn about the neural network—which, by the way,
    can also perform regressions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨更高级的机器学习模型。具体来说，我们将学习神经网络——顺便提一下，神经网络也可以执行回归。
