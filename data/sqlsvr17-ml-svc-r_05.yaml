- en: RevoScaleR Package
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RevoScaleR 包
- en: The `RevoScaleR` package comes with Microsoft Machine Learning R Server and
    R Services. It is also available with R Client, but with some limitations discussed
    in [Chapter 2](part0025.html#NQU20-e3f81285367248f4bbc6431bcd4f926d), *Overview
    of Microsoft Machine Learning Server and SQL Server*. Given the rapid development
    and constant upgrades, this chapter will cover version 8.X and version 9.X-the
    latter is also available with SQL Server 2017\. Changes and upgrades in version
    9.X are not to be overlooked and will be covered as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`RevoScaleR` 包与 Microsoft Machine Learning R Server 和 R Services 一起提供。它也适用于
    R Client，但有一些限制在 [第 2 章](part0025.html#NQU20-e3f81285367248f4bbc6431bcd4f926d)
    中讨论，*Microsoft Machine Learning Server 和 SQL Server 概述*。鉴于快速发展和持续升级，本章将涵盖 8.X
    和 9.X 版本——后者也适用于 SQL Server 2017。9.X 版本的变更和升级不容忽视，也将被涵盖。'
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Limitations of R challenged
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挑战 R 的限制
- en: Scalable and distributive computational environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展和分布式计算环境
- en: Functions for data preparation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据准备函数
- en: Functions for descriptive statistics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述性统计函数
- en: Functions for statistical tests and sampling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计测试和抽样函数
- en: Functions for predictive modeling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测建模函数
- en: Primarily, this R package is designed to be handled in ecosystems where clients
    would be connecting to Microsoft R Server in order to have R code executed against
    a much more powerful server, which would presumably hold whole datasets, not just
    a smaller portion, on which people working on client machines would be dealing
    with.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 主要来说，这个 R 包旨在在客户端连接到 Microsoft R Server 以执行 R 代码的生态系统中使用，以便在更强大的服务器上执行，该服务器可能包含整个数据集，而不仅仅是客户端机器上工作的人处理的小部分。
- en: Overcomming R language limitations
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克服 R 语言限制
- en: Prior to SQL Server 2016 (and 2017) BI and data scientists had the OLAP cubes,
    DMX language, and all super awesome and cool Microsoft algorithms available within
    **SQL Server Analysis Services **(**SSAS**). But, with rapid changes and bigger
    market demands, the need for integration of an open-source product (whether R,
    Python, Perl,or any other) was practically already there. And the next logical
    step was to integrate it with one. Microsoft sought a solution and ended up acquiring
    Revolution Analytics, which has put them on track again. Revolution R has addressed
    major issues concerning the R language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 2016（和 2017）之前，BI 和数据科学家有 OLAP 立方体、DMX 语言以及所有超级酷炫的 Microsoft 算法，这些都可在
    **SQL Server Analysis Services (SSAS**) 中使用。但随着快速变化和更大的市场需求，集成开源产品（无论是 R、Python、Perl
    还是其他任何产品）的需求实际上已经存在。接下来的逻辑步骤是将它与之一集成。微软寻求解决方案，最终收购了 Revolution Analytics，这使他们再次走上正轨。Revolution
    R 解决了 R 语言的主要问题。
- en: Microsoft addressed R's limitations. Many of these limitations were aimed at
    faster data exploration and parallel programming techniques in R. In addition
    to this, also MKL computations have been enhanced, therefore making matrix-wise
    calculations even faster, along with scalar calculation and also calculation resulting
    in cartesian-products.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微软解决了 R 的限制。其中许多限制旨在加快 R 中的数据探索和并行编程技术。此外，还增强了 MKL 计算，因此矩阵计算甚至更快，包括标量计算和笛卡尔积计算。
- en: 'The following limitations were addressed and also solved:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下限制得到了解决：
- en: Communication overhead is particularly an issue with fine-grained parallelism
    consisting of a very large number of relatively small tasks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信开销在由大量相对较小的任务组成的细粒度并行计算中尤其是一个问题
- en: Load balance is where computing resources aren't contributing equally to the
    problem
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载平衡是指计算资源没有平等地贡献给问题
- en: Impacts from the use of RAM and virtual memory, such as cache misses and page
    faults
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RAM 和虚拟内存的影响，如缓存未命中和页面错误
- en: Network effects, such as latency and bandwidth, that impact performance and
    communication overhead
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响性能和通信开销的网络效应，如延迟和带宽
- en: Interprocess conflicts and thread scheduling
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间冲突和线程调度
- en: Data access and other I/O considerations
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问和其他 I/O 考虑因素
- en: Scalable and distributive computational environments
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展和分布式计算环境
- en: The `RevoScaleR` package has the following functions available, which will be
    covered in detail throughout the chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`RevoScaleR` 包提供了以下函数，这些函数将在本章中详细说明。'
- en: 'To get a list of all the `ScaleR` functions, the following T-SQL can be used:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有 `ScaleR` 函数的列表，可以使用以下 T-SQL：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You get a table in SSMS with all the relevant `rx` functions that can be used
    with the `RevoScaleR` package.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSMS中，您会看到一个包含所有可以与`RevoScaleR`包一起使用的相关`rx`函数的表格。
- en: 'Based on the list of these functions, a simpler and better overview of the
    functions can be prepared:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些函数的列表，可以准备一个更简单、更好的函数概览：
- en: '![](img/00070.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: 'Figure 1: List of RevoScaleR functions (source: Microsoft)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：RevoScaleR函数列表（来源：Microsoft）
- en: Functions for data preparation
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据准备函数
- en: Importing data is the first of the many processes in data preparation. Importing
    data is a process of bringing data into your system from any external system using
    an external file or by establishing a connection to a live data source. In the
    following part, we will look at importing data that is stored as SPSS or SAS files
    and using an ODBC connection string to connect directly to an external live database
    system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 导入数据是数据准备过程中的第一步。导入数据是指将数据从任何外部系统通过外部文件或建立与实时数据源的连接引入到您的系统中。在接下来的部分，我们将探讨如何导入存储为SPSS或SAS文件的数据，以及如何使用ODBC连接字符串直接连接到外部实时数据库系统。
- en: Data import from SAS, SPSS, and ODBC
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从SAS、SPSS和ODBC导入数据
- en: Importing data into R or SQL Server tables is not the main focus of `RevoScaleR`
    library, but since this is on the list, let's briefly look into it. In this manner,
    based on your data source, the `RevoScaleR` package gives many abilities to connect
    to different data sources. Among these are also SAS and SPSS - two very broad
    and common statistical programs for data analysis and predictive analytics. We
    will simply focus on SAS software ([https://www.sas.com/](https://www.sas.com/)),
    SPSS Statistics, acquired by IBM in 2009 ([https://www.ibm.com/products/spss-statistics](https://www.ibm.com/products/spss-statistics)),
    or SPSS Modeler ([https://www.ibm.com/products/spss-modeler](https://www.ibm.com/products/spss-modeler)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据导入R或SQL Server表不是`RevoScaleR`库的主要焦点，但由于这一点在列表中，让我们简要地了解一下。这样，根据您的数据源，`RevoScaleR`包提供了连接到不同数据源的能力。其中也包括SAS和SPSS——两个非常广泛且常用的数据分析与预测分析统计程序。我们将简单地关注SAS软件（[https://www.sas.com/](https://www.sas.com/)），SPSS
    Statistics，于2009年被IBM收购（[https://www.ibm.com/products/spss-statistics](https://www.ibm.com/products/spss-statistics)），或SPSS
    Modeler（[https://www.ibm.com/products/spss-modeler](https://www.ibm.com/products/spss-modeler)）。
- en: Importing SAS data
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入SAS数据
- en: SAS is among the popular programs for data analysis if not the most popular
    for statistical analysis, data mining, and machine learning. Therefore, let's
    create a simple SAS file and read it using the `ScaleR` function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是统计分析、数据挖掘和机器学习中最受欢迎的程序，SAS是数据分析中流行的程序之一。因此，让我们创建一个简单的SAS文件，并使用`ScaleR`函数读取它。
- en: 'With the following SAS code (the code is available along with the book), you
    can very easily create a sample dataset:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下SAS代码（代码与本书一起提供），您可以非常容易地创建一个样本数据集：
- en: '![](img/00071.gif)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.gif)'
- en: 'Figure 2: Outlook of SAS code'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：SAS代码的概述
- en: Now, let's assume that our SAS data is stored in the file `sas_data.sas7bdat`
    as the code suggests in the `PROC DATA` statement.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们的SAS数据存储在文件`sas_data.sas7bdat`中，正如代码在`PROC DATA`语句中所建议的那样。
- en: 'With the following R code, we can extract and import this dataset into the
    R `data.frame`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下R代码，我们可以提取并将此数据集导入到R的`data.frame`中：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Make sure that your `sampleDataDir` holds the data sample. Also, you could
    specify some other path such as:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的`sampleDataDir`包含数据样本。您还可以指定其他路径，例如：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, you need to make sure that you have granted access to this working
    folder. In both ways, you should get results presented as a table, read from the
    SAS file as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您需要确保您已授予对此工作文件夹的访问权限。两种方式都会以表格形式呈现结果，如下从SAS文件中读取：
- en: '![](img/00072.gif)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.gif)'
- en: 'Figure 3: Outlook of SAS code result'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：SAS代码结果的概述
- en: 'Another way of importing the SAS file is by using `RxSasData` directly (in
    this case, from R):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种导入SAS文件的方法是直接使用`RxSasData`（在这种情况下，从R）：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can easily generate a histogram from the SAS data file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地从SAS数据文件中生成直方图。
- en: Importing SPSS data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入SPSS数据
- en: 'With SPSS, the procedure is similar. The following SPSS syntax (the syntax
    is included with this chapter) generates the sample dataset, which is stored on
    your local machine:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SPSS，过程类似。以下SPSS语法（语法包含在本章中）生成样本数据集，该数据集存储在您的本地机器上：
- en: '![](img/00073.gif)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.gif)'
- en: 'Figure 4: Outlook of SPSS syntax'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：SPSS语法的概述
- en: 'This involves getting data into R Services using the SPSS save file that is
    generated from the preceding SPSS syntax, which is relatively the same as with
    the SAS file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到使用从前面 SPSS 语法生成的 SPSS 保存文件将数据导入 R 服务，这与 SAS 文件相对类似：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to this, the `RevoScaleR` package has a special function to directly
    read the SPSS file called `RxSpssData`. The following R code can accomplish the
    same result as the preceding T-SQL code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`RevoScaleR` 包有一个特殊函数可以直接读取 SPSS 文件，称为 `RxSpssData`。以下 R 代码可以完成与前面 T-SQL
    代码相同的结果：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And the `RevoScaleR` histogram can be used directly with the SPSS datasource,
    generating a simple histogram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `RevoScaleR` 直方图可以直接与 SPSS 数据源一起使用，生成简单的直方图：
- en: '![](img/00074.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.jpeg)'
- en: Importing data using ODBC
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ODBC 导入数据
- en: Using the ODBC driver extends accessibility to almost any kind of database whose
    driver you can obtain and that has  a common RDBM model.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ODBC 驱动程序可以扩展对几乎所有可以获取驱动程序且具有通用 RDBM 模型的数据库的访问权限。
- en: The `RevoScaleR` package extends the list of ODBS drivers also to support systems
    on Linux and other systems. Using ODBC, you can connect to MySQL, Oracle, PostgreSQL,
    SQL Server on Linux, Cloudera, and Teradata (which in this case is much better
    to use than the `RxTeradata` function).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`RevoScaleR` 包扩展了 ODBS 驱动程序的列表，也支持 Linux 和其他系统。使用 ODBC，您可以连接到 MySQL、Oracle、PostgreSQL、Linux
    上的 SQL Server、Cloudera 和 Teradata（在这种情况下，使用 `RxTeradata` 函数会更好）。'
- en: 'The following example will use the ODBC driver to get data from another SQL
    server instance, both using the `RxOdbcData` and `RxSqlServerData` function, since
    they are interchangeable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用 ODBC 驱动程序从另一个 SQL 服务器实例获取数据，同时使用 `RxOdbcData` 和 `RxSqlServerData` 函数，因为它们可以互换使用：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This would be the same as running the following on the same server:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与在同一服务器上运行以下命令相同：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the case of using the `RxOdbcData` function, you should check the credentials
    and you might also want to check which user you are using to run the script. You
    can also create a new login and user and use it to check and execute the script:
    the `Adventureworks` database is available to download from Microsoft''s GitHub
    website ([https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/adventure-works](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/adventure-works)):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `RxOdbcData` 函数的情况下，您应检查凭证，并且您可能还想检查您正在使用哪个用户来运行脚本。您还可以创建一个新的登录和用户，并使用它来检查和执行脚本：`Adventureworks`
    数据库可以从微软的 GitHub 网站下载（[https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/adventure-works](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/adventure-works)）：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Variable creation and data transformation
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量创建和数据转换
- en: Variable creation and data transformation are two processes when defining data
    munging and data wrangling tasks. These tasks are important for proper data preparation
    and make it easier to analyze data for future tasks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 变量创建和数据转换是在定义数据清洗和数据整理任务时的两个过程。这些任务对于适当的数据准备很重要，并使分析数据以供未来任务更容易。
- en: 'The functions that we will be exploring are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的函数如下：
- en: Variable creation and recoding
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量创建和重新编码
- en: Data transformation
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据转换
- en: Handling missing values
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: Sorting, merging, and splitting datasets
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序、合并和分割数据集
- en: Aggregate by category (which means sums), which is similar to T-SQL aggregations
    and Windows functions
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按类别（即总和）汇总，这与 T-SQL 汇总和 Windows 函数类似
- en: 'This part will cover some of the following functions, mainly focusing on data
    transformation, handling missing values, and splitting datasets:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将涵盖以下一些函数，主要关注数据转换、处理缺失值和分割数据集：
- en: '`RxDataSource`, `rxDataStep`, `rxDataStepXdf`, `RxFileSystem`, `rxFindFileInPath`,
    `rxFindPackage`, `rxFisherTest`, `RxForeachDoPar`, `rxGetInfo`, `rxGetInfoXdf`,
    `rxGetJobInfo`, `rxGetJobInfo`, `rxGetOption`, `rxGetVarInfo`, `rxGetVarNames`,
    `rxImport`, `rxImportToXdf`, `rxIsOpen`, `rxOdbcData`, `rxOptions`, `rxOpen`,
    `rxQuantile`, `rxReadXdf`, `rxResultsDF`, `rxSetFileSystem`, `rxSetInfo`, `rxSetInfoXdf`,
    `rxSort`, `rxSetVarInfoXdf`, `rxSetVarInfo`, `rxMarginals`, `rxMerge`, `rxMergeXdf`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxDataSource`、`rxDataStep`、`rxDataStepXdf`、`RxFileSystem`、`rxFindFileInPath`、`rxFindPackage`、`rxFisherTest`、`RxForeachDoPar`、`rxGetInfo`、`rxGetInfoXdf`、`rxGetJobInfo`、`rxGetJobInfo`、`rxGetOption`、`rxGetVarInfo`、`rxGetVarNames`、`rxImport`、`rxImportToXdf`、`rxIsOpen`、`rxOdbcData`、`rxOptions`、`rxOpen`、`rxQuantile`、`rxReadXdf`、`rxResultsDF`、`rxSetFileSystem`、`rxSetInfo`、`rxSetInfoXdf`、`rxSort`、`rxSetVarInfoXdf`、`rxSetVarInfo`、`rxMarginals`、`rxMerge`、`rxMergeXdf`'
- en: When using In-database R Service (or the in-database machine learning service,
    also counting Python for SQL Server 2017), you should keep in mind where and how
    to do any kind of data transformation, data wrangling, as well as sorting and/or
    merging. After running many performance and speed tests, it became very clear
    that many of the munging and wrangling tasks should be done in-database, before
    sending the dataset to be executed by `sp_execute_external_script`. This set of
    functions is the only set where the computation context should be considered as
    a very important one. All the other functions for statistical tests, descriptive
    statistics, and predictive statistics can easily be used with external procedure,
    without compromising on performance or time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用数据库内 R 服务（或数据库内机器学习服务，包括 SQL Server 2017 的 Python）时，你应该牢记在哪里以及如何进行任何类型的数据转换、数据处理，以及排序和/或合并。经过多次性能和速度测试后，变得非常清楚，许多的整理和数据处理任务应该在将数据集发送到由
    `sp_execute_external_script` 执行之前在数据库内完成。这个函数集是唯一一个需要将计算上下文视为非常重要的函数集。所有其他用于统计测试、描述性统计和预测统计的函数都可以很容易地与外部过程一起使用，而不会影响性能或时间。
- en: 'Starting with the `rxDataStep` function, it gives us many opportunities to
    extract and generate XDF files, using in-database R:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `rxDataStep` 函数开始，它为我们提供了许多使用数据库内 R 提取和生成 XDF 文件的机会：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will generate the `df_sql4.xdf` file on your sample data directory. If
    you are interested in where this folder is pointing to, you can do the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的样本数据目录中生成 `df_sql4.xdf` 文件。如果你对指向此文件夹的位置感兴趣，你可以执行以下操作：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It will be something similar to what is shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它将类似于以下截图所示的内容：
- en: '![](img/00075.gif)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00075.gif)'
- en: And make sure that you have granted access for the user, executing the `rxDataStep`
    code, because the code will be creating a physical XDF file on the destination
    location.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经为执行 `rxDataStep` 代码的用户授予了访问权限，因为代码将在目标位置创建一个物理 XDF 文件。
- en: Variable creation and recoding
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量创建和重新编码
- en: 'Using `rxGetVarInfo` will expose the information about the `data.frame` to
    the `sp_execute_external_script` output. It is obvious that some of these functions
    were never designed for presenting the output to `data.frame`, but were designed
    only for exploring the dataset. Some of these functions-for example, `rxGetVarInfo`-will
    give a nice output in the R environment, but will be hard to manipulate in data
    frames for outputting in the SQL Server database:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rxGetVarInfo` 将将 `data.frame` 的信息暴露给 `sp_execute_external_script` 输出。很明显，一些这些函数从未被设计为向
    `data.frame` 展示输出，而是仅设计用于探索数据集。一些这些函数（例如，`rxGetVarInfo`）将在 R 环境中给出一个很好的输出，但在 SQL
    Server 数据库的数据框中操作输出将很困难：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we are using the `unlist` function that unlists the set of lists
    in a single vector. Just to compare the output, we can run the same script in
    the R environment:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 `unlist` 函数，该函数将列表的集合取消列表成一个向量。只是为了比较输出，我们可以在 R 环境中运行相同的脚本：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, running the `rxGetVarInfo(df_sql)` will give you a slightly different
    export:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `rxGetVarInfo(df_sql)` 将给出一个略微不同的导出结果：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And after unlisting with the `unlist()` function, we get the same information,
    written in a slightly different manner:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unlist()` 函数取消列表后，我们得到相同的信息，但以稍微不同的方式书写：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This indicates that some of these functions for variable creation and recoding
    were meant more for R data engineers than for T-SQL data engineers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，这些用于变量创建和重新编码的函数更多的是为 R 数据工程师而不是 T-SQL 数据工程师设计的。
- en: 'The `rxGetInfo()` function will get you the size of your dataset and the number
    of observations/variables:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`rxGetInfo()` 函数将获取你的数据集大小以及观测值/变量的数量：'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The same logic applies: if you run this R environment, you will get a neater
    display of information:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑适用：如果你运行这个 R 环境，你将得到一个更整洁的信息显示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Adding some additional parameters to this function also yields a richer output,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 向此函数添加一些额外的参数也会产生更丰富的输出，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A with `rxGetVarInfo`, `rxGetInfo` will create a list of elements. `rxGetVarInfo`
    will generate a list of lists, where the number of tuples equals the number of
    variables, and `rxGetInfo` will generate a list of six elements, where each list
    will hold information about the object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rxGetVarInfo` 和 `rxGetInfo`，`rxGetVarInfo` 将生成一个元素列表。`rxGetVarInfo` 将生成一个列表的列表，其中元组的数量等于变量的数量，而
    `rxGetInfo` 将生成一个包含六个元素的列表，其中每个列表将包含有关对象的信息：
- en: '![](img/00076.gif)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00076.gif)'
- en: 'Knowing this, the preceding T-SQL executions can be slightly altered so that
    the relevant information is displayed in a more readable format, by presenting
    elements (tuples) to the result set:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，可以对前面的 T-SQL 执行进行轻微的修改，以便以更易读的格式显示相关信息，通过向结果集呈现元素（元组）：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The results returned in SQL Server Management Studio:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server Management Studio 中返回的结果：
- en: '![](img/00077.gif)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00077.gif)'
- en: This looks very neat and spending some extra effort will for sure give much
    better formatted results that will be easier to read as well as much more informative.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常整洁，多花一些精力肯定能给出格式更好、更容易阅读以及更富有信息量的结果。
- en: In this example, you have also seen how to create a new variable. This especially
    comes in handy when cleaning data or recoding/bucketing data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您还看到了如何创建一个新变量。这在清理数据或重新编码/分桶数据时特别有用。
- en: 'Let''s suppose that you want to recode the values of existing variables in
    the dataset and create a new one. It can be done using standard R code as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想重新编码数据集中现有变量的值并创建一个新的变量。可以使用以下标准 R 代码完成：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you can do this using the `rxDataStep()` function and the `transformFunc`
    parameter with an additional function for creating a new variable by transforming
    old values:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `rxDataStep()` 函数和 `transformFunc` 参数，以及一个用于通过转换旧值创建新变量的附加函数来完成此操作：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`rxDataStep()X` is a very powerful function mainly for data selection, subsetting,
    data transformation, and the creation of new variables for the desired dataset.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`rxDataStep()X` 是一个非常强大的函数，主要用于数据选择、子集化、数据转换以及为所需数据集创建新变量。'
- en: Dataset subsetting
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据集子集化
- en: 'Subsetting the data is also relatively straightforward using the `rxDataStep()`
    function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rxDataStep()` 函数对数据进行子集化也是相对直接的：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Keep in mind that subsetting operations using R code might bring unnecessary
    memory and I/O costs, especially when pumping whole datasets into R, instead of
    subsetting the data beforehand. In the preceding example, using the `rowSelection`
    parameter in `rxDataStep` can easily be replaced with the `WHERE` clause in the
    `@input_data_1` argument. So bear this in mind and always avoid unnecessary traffic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用 R 代码进行子集化操作可能会带来不必要的内存和 I/O 成本，尤其是在将整个数据集泵入 R 而不是事先对数据进行子集化时。在前面的例子中，`rxDataStep`
    中的 `rowSelection` 参数可以很容易地用 `@input_data_1` 参数中的 `WHERE` 子句替换。所以请记住这一点，并始终避免不必要的流量。
- en: Dataset merging
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据集合并
- en: 'The `rxMerge()` function merges two datasets into one. The datasets must be
    a dataframe (or XDF format) and operate similarly to the `JOIN` clause in T-SQL
    (the `rxMerge()` function should not be confused with T-SQL''s `MERGE` statement).
    Two datasets are merged based on one or more variables using the `matchVars` argument.
    In addition, when using the local compute context (which we are using in the next
    sample), the sorting of the data needs to be defined as well, since `data.frames`-as
    a collection of vectors-in R are not presorted or do not hold any sorts whatsoever.
    So, if no presorting is done, the `autoSort` argument must be set to true (`autosort
    = TRUE`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`rxMerge()` 函数将两个数据集合并为一个。数据集必须是数据框（或 XDF 格式），并且操作类似于 T-SQL 中的 `JOIN` 子句（`rxMerge()`
    函数不应与 T-SQL 的 `MERGE` 语句混淆）。使用 `matchVars` 参数根据一个或多个变量合并两个数据集。此外，当使用本地计算上下文（我们将在下一个示例中使用）时，还需要定义数据的排序，因为
    R 中的 `data.frames` 作为向量的集合既没有预先排序，也没有任何排序。因此，如果没有进行预先排序，则必须将 `autoSort` 参数设置为
    true (`autosort = TRUE`)：'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This T-SQL code creates a left join on both the datasets. Dataframe 2 (called `someExtraData`)
    is created on the fly, but it can be any other dataframe read from an XDF file
    or any manually inserted dataset, and will be joined at R runtime. Also, pay attention
    to which is the first and which is the second data frame in combination to which
    type of join you are using. The preceding example specifies the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 T-SQL 代码在两个数据集上创建了一个左连接。动态创建的数据框 2（称为 `someExtraData`），但它可以是任何其他从 XDF 文件读取的数据框或任何手动插入的数据集，并在
    R 运行时进行连接。请注意，哪个是第一个数据框，哪个是第二个数据框，以及您正在使用哪种类型的连接。前面的例子指定了以下内容：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, the order of the data frames could be changed as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据框的顺序可以按以下方式更改：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, the output would be presented differently (the sorting of the columns
    in the data frame would be changed).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出将呈现不同的形式（数据框中列的排序将改变）。
- en: Functions for descriptive statistics
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述性统计函数
- en: Descriptive statistics give insights into understanding data. These are summary
    statistics that describe a given dataset by summarizing features and measures,
    such as central tendency and measure of spread (or variability). Central tendency
    includes calculation of the mean, median, mode, whereas measures of variability
    include range, quartiles, minimum and maximum value, variance and standard deviation,
    as well as skewness and kurtosis.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性统计有助于了解数据。这些是通过总结特征和度量来描述给定数据集的汇总统计，例如集中趋势和离散程度的度量。集中趋势包括计算平均值、中位数、众数，而离散程度的度量包括范围、四分位数、最小值和最大值、方差和标准差，以及偏度和峰度。
- en: 'These statistics are covered by`rx-` functions in `RevoScaleR` package, which
    means that you can use all the computational advantages of the package by calling:
    `rxSummary`, `rxCrossTabs`, `rxMarginals`, `rxQuantile`, `rxCube`, and `rxHistogram`,
    without worrying about the performance, out of memory exceptions, or which R package
    holds the right function.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些统计数据由`RevoScaleR`包中的`rx-`函数覆盖，这意味着您可以通过调用：`rxSummary`、`rxCrossTabs`、`rxMarginals`、`rxQuantile`、`rxCube`和`rxHistogram`来使用该包的所有计算优势，无需担心性能、内存不足异常或哪个R包包含正确的函数。
- en: 'We will be using the`[Sales].[vPersonDemographics]` view in the `AdventureWorks`
    database to neatly show the usability of these functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`AdventureWorks`数据库中使用`[Sales].[vPersonDemographics]`视图来清楚地展示这些函数的可用性：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With one line of R code, you can get some summary statistics. I prefer using
    the `summaryStats` argument to list the statistics, but note that the order of
    the statistics does not mean that the order of the output will be the same. In
    addition, using the element `summary$sDataFrame` dataframe as a result from `rxSummary` will
    automatically generate the data frame that will contain all the summaries for
    numeric variables.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一行R代码获取一些汇总统计。我更喜欢使用`summaryStats`参数来列出统计信息，但请注意，统计信息的顺序并不代表输出顺序相同。此外，使用`summary$sDataFrame`数据框作为`rxSummary`的结果将自动生成包含所有汇总的数值变量的数据框。
- en: 'The result of the T-SQL query is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: T-SQL查询的结果如下：
- en: '![](img/00078.gif)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.gif)'
- en: 'The `rxSummary()` function also holds a formula, whereby you can specify which
    variables the function will take into account while calculating descriptive statistics.
    In our case, we have used only the `TotalChildren` variable:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`rxSummary()`函数还包含一个公式，您可以通过它指定函数在计算描述性统计时要考虑哪些变量。在我们的例子中，我们只使用了`TotalChildren`变量：'
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But let''s assume, we want to get descriptives for all the variables; we simply
    write the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们想要获取所有变量的描述性统计；我们只需写下以下内容：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will give us statistics for all the variables as shown in the following
    screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供所有变量的统计数据，如下面的截图所示：
- en: '![](img/00079.gif)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.gif)'
- en: Note that only the integer (continuous) type of variables will be taken into
    consideration, whereas variables such as `MaritalStatus`, `Education`, and `Occupation`,
    will be presented as `NULL`, since these variables are treated as categorical
    variables in R.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有整数（连续）类型的变量将被考虑，而像`MaritalStatus`、`Education`和`Occupation`这样的变量将显示为`NULL`，因为这些变量在R中被视为分类变量。
- en: 'For this, firstly, we will need to specify the factor variable, and based on
    that we will be able to run the statistics:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此，首先，我们需要指定因素变量，基于此，我们将能够运行统计：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This function will give simple counts for the `MaritalStatus` factor:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将为`MaritalStatus`因素提供简单的计数：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The same logic can be applied to all other categorical variables. The formula
    in the `rxSummary()` function also gives users the ability to combine different
    variables. For example, instead of using the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑可以应用于所有其他分类变量。`rxSummary()`函数中的公式还赋予用户组合不同变量的能力。例如，而不是使用以下代码：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also use the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下代码：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will calculate the observed statistics for both the variables together:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算两个变量的观察统计：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This can also be calculated for categorical variables. These variables need
    to be recoded into factors first and later the same summary statistics can be
    calculated:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用于计算分类变量。这些变量需要首先被重新编码为因素，然后可以计算相同的汇总统计：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And the complete R and T-SQL code using `sp_execute_external_script` is as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sp_execute_external_script`的完整R和T-SQL代码如下：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following are the results for each factor level:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对每个因素级别的结果：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Quantiles and deciles are also very useful to view the data distribution and
    the `RevoScaleR` packages provides the `rxQuantile` function. Using T-SQL, the
    result set can be returned as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 分位数和十分位数也非常有用，可以查看数据分布，`RevoScaleR`包提供了`rxQuantile`函数。使用T-SQL，结果集可以返回如下：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This gives us the following result:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下结果：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also modify and calculate deciles with a slight change to the `rxQuantile()`
    function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过稍微修改`rxQuantile()`函数来修改和计算十分位数：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Calculating crosstabulations-the relationship between two (or more) variables-we
    will use two functions: `rxCrossTabs` and `rxMargins`. Crosstabulations are usually
    expressed in a contingency table or any other *[n]*[m] *table format; this really
    depends on the number of levels each variable will have.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 计算交叉表（两个或更多变量之间的关系）我们将使用两个函数：`rxCrossTabs`和`rxMargins`。交叉表通常以列联表或其他*[n]*[m]表格格式表示；这实际上取决于每个变量将有多少个级别。
- en: 'We will use our two variables `NumberCarsOwned` and `TotalChildren` to explore
    the `rxCrossTabs`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的两个变量`NumberCarsOwned`和`TotalChildren`来探索`rxCrossTabs`：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Calculating crosstabulations using `rxCrossTabs` can give you two types of
    statistics: the count of observations and the mean of observations, given the
    category of intersect. This is manipulated using the means `= TRUE` or means `=
    FALSE` argument. The function operates in a way that will need the dependent variable(s)
    and independent variables(s) and in our example, the information can be retrieved
    from the results as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rxCrossTabs`计算交叉表可以提供两种类型的统计：给定交叉类别的观测值的计数和平均值。这是通过`means = TRUE`或`means
    = FALSE`参数来操作的。该函数以需要依赖变量和独立变量的方式运行，在我们的例子中，信息可以从以下结果中检索：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In order to have the crosstabulation successfully calculated, independent variables
    must be presented as factors. In this case, the `TotalChildren` variable has a
    `F()` function wrapped, denoting a factor conversion in the runtime.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功计算交叉表，独立变量必须以因素的形式呈现。在这种情况下，`TotalChildren`变量被`F()`函数包装，表示在运行时进行因素转换。
- en: 'This can be visualized using a standard barplot in the base package or R:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使用基础包或R中的标准条形图进行可视化：
- en: '![](img/00080.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: 'Use the following code to plot the histogram using `barplot` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码使用`barplot`函数绘制直方图：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using variables that are categorical, there is no need for explicit conversion:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分类变量时，无需进行显式转换：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Also, the transform argument can be used to recode, recalculate, or somehow
    transform any of the variables. Marginal statistics from the contingency tables
    deriving from `rxCrossTabs` can be called using the `rxMarginals` functions, which
    is simply wrapped around the `rxCrossTabs`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，转换参数可以用来重新编码、重新计算或以某种方式转换任何变量。从`rxCrossTabs`派生的列联表边缘统计可以使用`rxMarginals`函数调用，该函数简单地将`rxCrossTabs`包装起来。
- en: 'Marginal statistics will give you the sum, counts, or mean for each of the
    totals per row or per column for the desired variable:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘统计将为您提供所需变量的每一行或每一列的总和、计数或平均值：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Exploring the data can also be done using the graphs and the `RevoScaleR` package
    comes with a Line and bar plot, both designed to tackle large datasets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 探索数据也可以使用图表进行，`RevoScaleR`包提供了折线图和条形图，两者都旨在处理大型数据集。
- en: 'The following is a simplistic preview of one of the variables:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个变量的简单预览：
- en: '![](img/00081.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: 'Use the following line of R code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下R代码行：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This has already been converted to marital status factor as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经按照以下方式转换为婚姻状况因素：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](img/00082.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: 'Also, variables can be combined as follows (the marital status with the number
    of cars owned):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，变量可以组合如下（婚姻状况与拥有汽车的数量）：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And we get the following plot, showing marital status (**M** - married; **S**
    - single) and the total number of cars owned as a categorical variable (**0**
    - no car, **1** - 1 car owned, **2** - two cars owned, **3** - three cars owned,
    and **4** - four cars owned):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下图表，显示了婚姻状况（**M** - 已婚；**S** - 未婚）和拥有汽车的总数作为一个分类变量（**0** - 没有汽车，**1** -
    拥有一辆汽车，**2** - 拥有两辆汽车，**3** - 拥有三辆汽车，以及 **4** - 拥有四辆汽车）：
- en: '![](img/00083.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: 'Instead of a bar plot, we can also use a Line plot, but this time with different
    variables:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了条形图，我们还可以使用折线图，但这次使用不同的变量：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For the time period of little over half a year (between January 01 and July
    17^(th) 2001), the plot is showing a logarithmic variable for the total amount
    of purchases in this time period. In this case, we need to factorize the date
    variable and we are also using the `log()` function to level the purchases. And
    instead of using `rxHistogram`, we are using `rxLinePlot`, another `RevoScaleR`
    function, to plot graphs for large datasets. `rxLinePlot` represents a line chart:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于超过半年时间（从2001年1月1日到7月17日）的时间段，图表显示的是这段时间内总购买量的对数变量。在这种情况下，我们需要对日期变量进行因式分解，并且我们还在使用`log()`函数来平衡购买量。而不是使用`rxHistogram`，我们使用另一个`RevoScaleR`函数`rxLinePlot`来为大型数据集绘制图表。`rxLinePlot`代表折线图：
- en: '![](img/00084.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00084.jpeg)'
- en: 'So, in the end, we can combine all three graphs using the `par()` function,
    arranging two columns, each having one or two graphs:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终我们可以使用`par()`函数将所有三个图表结合起来，排列成两列，每列包含一个或两个图表：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Using graphs is good for storytelling, customer journey, or simply by great
    and fast understanding of the data, when combining the most informative variables.
    Another good way is to use markdown documentation and include multiple graphs
    in one block. An addition when using the `par()` function in combination with
    `rxHistogram` or `rxLinePlot` is that it might not always display graphs as expected.
    This is due to some compatibility issues with the `par()` function. Alternatively,
    using `print()` function and positioning each graph is another way to do it, without
    running into possible problems:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图表对于讲故事、客户旅程或通过结合最有信息量的变量快速理解数据都是有益的。另一种好方法是使用Markdown文档，并在一个块中包含多个图表。当使用`par()`函数与`rxHistogram`或`rxLinePlot`结合时，它可能并不总是按预期显示图表。这是由于与`par()`函数的一些兼容性问题。作为替代，使用`print()`函数并定位每个图表是另一种方法，这样可以避免可能的问题：
- en: '![](img/00085.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00085.jpeg)'
- en: Functions for statistical tests and sampling
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计测试和抽样的函数
- en: Statistical tests are important for determining the correlation between two
    (or more) variables and what is their direction of correlation (positive, neutral,
    or negative). Statistically speaking, the correlation is a measure of the strength
    of the association between two variables and their direction. The `RevoScaleR`
    package supports calculation of Chi-square, Fischer, and Kendall rank correlation.
    Based on the types of variable, you can distinguish between Kendall, Spearman,
    or Pearson correlation coefficient.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 统计测试对于确定两个（或更多）变量之间的相关性及其相关方向（正相关、中性或负相关）非常重要。从统计学的角度来看，相关性是衡量两个变量之间关联强度及其方向的度量。`RevoScaleR`包支持计算卡方、费舍尔和肯德尔秩相关。根据变量的类型，你可以区分肯德尔、斯皮尔曼或皮尔逊相关系数。
- en: 'For Chi-Square test, we will be using the `rxChiSquareTest()` function that
    uses the contingency table to see if two variables are related. A small chi-square
    test statistic means that the observed data fits your expected data very well,
    denoting there is a correlation, respectively. The formula for calculating chi-square
    is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于卡方测试，我们将使用`rxChiSquareTest()`函数，该函数使用列联表来查看两个变量是否相关。小的卡方测试统计量意味着观察到的数据与预期数据非常吻合，表示存在相关性。计算卡方的公式如下：
- en: '![](img/00086.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00086.jpeg)'
- en: Prior to calculating this statistical independence test, we must have data in
    the `xCrossTab` or xCube format. Therefore, the T-SQL query will need to generate
    the crosstabulations first in order to calculate the chi-square coefficient.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算这个统计独立性测试之前，我们必须有`xCrossTab`或xCube格式的数据。因此，T-SQL查询需要首先生成交叉表，以便计算卡方系数。
- en: 'Chi-square is generated on two categorical variables as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方是在两个分类变量上生成的如下：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following results are returned:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 返回了以下结果：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'With Kendall Tau you can calculate the correlation between the ranks and the
    result of the preceding correlation using R code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kendall Tau，你可以使用R代码计算排名与先前相关性的相关性：
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following are the results:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些结果：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This same principle can be used in a T-SQL query:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个同样的原则也可以用在T-SQL查询中：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Many other principles can be used to calculate correlations among variables.
    But this is beyond the scope of this book, and therefore we have focused only
    on the necessary ones.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 返回了许多其他可以用来计算变量之间相关性的原则。但这些都超出了本书的范围，因此我们只关注了必要的部分。
- en: Functions for predictive modeling will be covered in the next chapter - [Chapter
    6](part0096.html#2RHM00-e3f81285367248f4bbc6431bcd4f926d), *Predictive Modeling*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 预测建模的相关函数将在下一章介绍 - [第6章](part0096.html#2RHM00-e3f81285367248f4bbc6431bcd4f926d)，*预测建模*。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered important functions (among many others) for data manipulation
    and data wrangling. These steps are absolutely and utterly important for understanding
    the structure of the dataset, the content of the dataset, and how the data is
    distributed. These are used to mainly understand frequencies, descriptive statistics,
    and also some statistical sampling, as well as statistical correlations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了数据操作和数据整理的重要函数（以及其他许多函数）。这些步骤对于理解数据集的结构、数据集的内容以及数据的分布至关重要。这些步骤主要用于理解频率、描述性统计，以及一些统计抽样和统计相关性。
- en: 'These steps must be done (or should be done) prior to data cleaning and data
    merging in order to get a better understanding of the data. Cleaning the data
    is of the highest importance, as outliers might bring sensitive data (or any kind
    of data) to strange or false conclusions: it might also sway the results in some
    other direction. So, treating these steps as highly important by using the powerful
    `rx`- functions (or classes) should be the task of every data engineer, data wrangler,
    as well as data scientist. The next chapter will be focused on `RevoScaleR` functions
    for predictive modeling, mainly focusing on creating models and running the predictions
    against these models.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据清洗和数据合并之前，必须（或应该）完成这些步骤，以便更好地理解数据。数据清洗是最重要的，因为异常值可能会将敏感数据（或任何类型的数据）引向奇怪或错误的结论：它也可能使结果偏向其他方向。因此，通过使用强大的`rx`-函数（或类）将这些步骤视为高度重要，应该是每位数据工程师、数据整理员以及数据科学家的任务。下一章将专注于`RevoScaleR`的预测建模函数，主要关注创建模型以及在这些模型上运行预测。
