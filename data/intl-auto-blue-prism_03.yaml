- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Code Stages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码阶段
- en: While Python is the dominant language used for ML, Microsoft is making heavy
    investments in AI, and not just through its investments in OpenAI and ChatGPT.
    Microsoft is actively expanding support for ML development in VB.NET and C# through
    the open source **ML.NET** framework. In this chapter, we’ll be looking at how
    to set up BP to use ML.NET through **Code Stages**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 是用于 ML 的主导语言，但微软正在大力投资 AI，而不仅仅是通过其对 OpenAI 和 ChatGPT 的投资。微软正在通过开源的
    **ML.NET** 框架积极扩展对 VB.NET 和 C# 中 ML 开发的支持。在本章中，我们将探讨如何通过 **代码阶段** 设置 BP 以使用 ML.NET。
- en: In my research, random forests were the most commonly cited family of algorithms
    used in IA, followed by deep learning and gradient boosting. All of these algorithms
    have implementations in ML.NET. Random forests and gradient-boosting algorithms
    can realistically be used on digital workers to produce timely predictions. Deep
    learning may not be a good candidate for training and predicting the Digital Worker
    itself due to computation and GPU requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的研究中，随机森林是 IA 中最常引用的算法家族，其次是深度学习和梯度提升。所有这些算法在 ML.NET 中都有实现。随机森林和梯度提升算法可以在数字工作者上实际使用以产生及时预测。由于计算和
    GPU 要求，深度学习可能不是训练和预测数字工作者的良好候选者。
- en: This chapter features three examples that build on one another. They are modeled
    after a real-life scenario. Imagine that an ML model (binary classification for
    sentiment analysis) has been built by data scientists using ML.NET. The model
    has been reviewed and accepted for an IA use case and an IA team needs to take
    ownership of the model maintenance and source code going forward. In our examples,
    we will be going over the steps to successfully get the ML code running in BP.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含三个相互关联的示例。它们是根据现实生活中的场景构建的。想象一下，数据科学家使用 ML.NET 建立了一个 ML 模型（用于情感分析的二元分类）。该模型已经经过审查并被接受用于
    IA 用例，IA 团队需要从现在开始负责模型维护和源代码。在我们的示例中，我们将介绍在 BP 中成功运行 ML 代码的步骤。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Setting up ML.NET in BP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 BP 中设置 ML.NET
- en: Importing the C# code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 C# 代码
- en: Improving BP integration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高BP集成
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Download and import the three files in the `ch3` folder on GitHub at [https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch3](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch3).
    Note that two of the files have the file extension `.bpobject`, and they need
    importing as `Process / Object`. Additional setup steps will be performed as part
    of the examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并导入 GitHub 上 `ch3` 文件夹中的三个文件，网址为 [https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch3](https://github.com/PacktPublishing/Intelligent-Automation-with-Blue-Prism/tree/main/ch3)。请注意，其中两个文件具有
    `.bpobject` 文件扩展名，它们需要作为 `Process / Object` 导入。示例中还将执行其他设置步骤。
- en: Setting up ML.NET in BP
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 BP 中设置 ML.NET
- en: ML.NET can be used natively inside of BP code stages. While you have a choice
    between C# and VB.net in BP, almost all of the documentation on the Internet is
    written for C#. The examples in this chapter will also use C#.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ML.NET 可以在 BP 代码阶段原生使用。虽然你在 BP 中可以选择 C# 或 VB.NET，但互联网上的几乎所有文档都是用 C# 编写的。本章中的示例也将使用
    C#。
- en: Possibly the biggest challenge that developers face when trying to use ML.NET
    is getting all of the `.dll` files) imported and `.dll` dependencies in the project
    for the developer. BP unfortunately doesn’t have a feature to do the same. In
    BP, getting the assembly imports and namespaces working is largely through trial
    and error and checking documentation. We iteratively add new `.dll` files or namespaces
    and check for changes in the errors displayed in BP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在尝试使用 ML.NET 时可能面临的最大挑战之一是导入项目中的所有 `.dll` 文件及其 `.dll` 依赖项。不幸的是，BP 没有这样的功能。在
    BP 中，获取程序集导入和命名空间的工作主要是通过试错和检查文档来完成的。我们迭代地添加新的 `.dll` 文件或命名空间，并检查 BP 中显示的错误是否有变化。
- en: Since only Business Objects (not Processes) can have Code Stages, the contents
    of this chapter only apply to objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有业务对象（而不是流程）可以有代码阶段，因此本章的内容仅适用于对象。
- en: Adding references and namespaces to BP
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 BP 中添加引用和命名空间
- en: The area to add `.dll` files and namespaces is in the Object’s Properties in
    the **Code Options** tab. To access an Object’s properties, visit the **Initialise**
    Page. By default, to the left of the **Start** Stage, there’s a rectangle containing
    the Object’s name, the creation date, and the last changed date. Right-click this
    rectangle and choose **Properties**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `.dll` 文件和命名空间的区域位于 **代码选项** 选项卡中的对象的属性中。要访问对象的属性，请访问 **初始化** 页面。默认情况下，在
    **开始** 阶段左侧有一个包含对象名称、创建日期和最后更改日期的矩形。右键单击此矩形并选择 **属性**。
- en: '![Figure 3.1 – Accessing an Object’s properties from the Initialise Page](img/B18416_03_1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 从初始化页面访问对象的属性](img/B18416_03_1.jpg)'
- en: Figure 3.1 – Accessing an Object’s properties from the Initialise Page
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 从初始化页面访问对象的属性
- en: An alternate way of opening the Object’s Properties is to double-click the white
    rectangle. With the **Properties** window open, you’ll see a **Code Options**
    tab. The **Code Options** tab is where external assemblies and namespaces can
    be added. The code language (**C#**, **Visual Basic**, or **Visual J#**) can also
    be selected here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 打开对象属性的另一种方法是双击白色矩形。当 **属性** 窗口打开时，您将看到一个 **代码选项** 选项卡。**代码选项** 选项卡是添加外部程序集和命名空间的地方。也可以在此处选择代码语言（**C#**、**Visual
    Basic** 或 **Visual J#**）。
- en: '![Figure 3.2 – The Code Options tab of an Object’s Properties](img/B18416_03_2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 对象属性的 **代码选项** 选项卡](img/B18416_03_2.jpg)'
- en: Figure 3.2 – The Code Options tab of an Object’s Properties
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 对象属性的 **代码选项** 选项卡
- en: While *Figure 3**.2* shows `.dll` file, you can also specify them by providing
    the full path. If you don’t see the full path to the `.dll`, this means that the
    assembly is either stored in the BP installation folder or somewhere on the Windows
    path. The `using` statements in C#, typically after adding the corresponding assembly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **图 3.2** 显示了 `.dll` 文件，但您也可以通过提供完整路径来指定它们。如果您看不到 `.dll` 的完整路径，这意味着该程序集存储在
    BP 安装文件夹中或 Windows 路径的某个位置。在 C# 中，`using` 语句通常在添加相应的程序集后。
- en: 'Next, let’s look at our first example, where we will add **External References**
    and **Namespace Imports** to an Object. We will be doing five high-level steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的第一个示例，我们将向一个对象添加 **外部引用** 和 **命名空间导入**。我们将进行五个高级步骤：
- en: Examining existing `using` statements in the source code
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查源代码中的现有 `using` 语句
- en: Downloading the ML.NET package from NuGet
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 NuGet 下载 ML.NET 包
- en: Extracting the `.dll` files from the NuGet package
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 NuGet 包中提取 `.dll` 文件
- en: Copying the `.dll` files to the BP installation folder
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `.dll` 文件复制到 BP 安装文件夹
- en: Adding references and namespaces to the **Code** **Options** tab
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **代码选项** 选项卡中添加引用和命名空间
- en: The overall goal for this example is to get BP working with ML.NET as much as
    we can before adding in the actual C# code in Code Stages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的总体目标是尽可能在添加实际 C# 代码到代码阶段之前，让 BP 与 ML.NET 一起工作。
- en: Example 1 – preparation work before BP
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1 – BP 之前的准备工作
- en: Recall the scenario introduced at the beginning of the chapter. We’re tasked
    with moving C# ML code into BP. There are two ways to approach determining which
    `.dll` libraries need to be imported. The first way is to copy all of the source
    code into a Code Stage and see what error messages appear. The other (and probably
    smarter) way is to examine the project’s source code first. This gets us familiar
    with the code base and gives us an idea of what `.dll` files and namespaces need
    to be added. We will be doing the latter here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回想本章开头介绍的情景。我们负责将 C# ML 代码移入 BP。有两种方法来确定需要导入哪些 `.dll` 库。第一种方法是将所有源代码复制到一个代码阶段，并查看出现的错误消息。另一种（可能更聪明）的方法是首先检查项目的源代码。这将使我们熟悉代码库，并给我们一个需要添加哪些
    `.dll` 文件和命名空间的思路。我们在这里将采用后者。
- en: 'Our starting source code comes from Microsoft’s GitHub:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起始源代码来自微软的 GitHub：
- en: '[https://github.com/dotnet/machinelearning-samples/tree/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis](https://github.com/dotnet/machinelearning-samples/tree/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/machinelearning-samples/tree/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis](https://github.com/dotnet/machinelearning-samples/tree/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis)'
- en: Examining the C# source files for using statements
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查 C# 源文件中的 `using` 语句
- en: 'In the Microsoft GitHub project, there are only three C# source files. Let’s
    examine each one and note any `.dll` files that might need to be imported:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Microsoft GitHub 项目中，只有三个 C# 源文件。让我们逐一检查并注意可能需要导入的任何 `.dll` 文件：
- en: 'Open the first source file at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs).
    The `using` statements are in the first six lines of the file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第一个源文件 [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs)。该文件的第一个六行包含
    `using` 语句：
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of not are `Microsoft.ML` and `Microsoft.ML.DataOperationsCatalog`. `SentimentAnalysisConsoleApp.DataStructures`
    is a self-reference to the current project as opposed to an external library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.ML` 和 `Microsoft.ML.DataOperationsCatalog` 是 `Microsoft.ML` 的组成部分。`SentimentAnalysisConsoleApp.DataStructures`
    是对当前项目的自引用，而不是外部库。'
- en: Open the second source file at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs).
    There’s only one `using` statement for `Microsoft.ML.Data`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个源文件 [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs)。对于
    `Microsoft.ML.Data` 只有一个 `using` 语句。
- en: Open the final source file at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs).
    Again, we only see `Microsoft.ML.Data`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开最后一个源文件 [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs)。我们再次只看到
    `Microsoft.ML.Data`。
- en: 'We’ve found three notable `using` statements by examining the source files:
    `Microsoft.ML`, `Microsoft.ML.Data`, and `Microsoft.ML.DataOperationsCatalog`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查源文件，我们发现了三个显著的 `using` 语句：`Microsoft.ML`、`Microsoft.ML.Data` 和 `Microsoft.ML.DataOperationsCatalog`。
- en: Examining the .csproj file for PackageReferences
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查 .csproj 文件中的 PackageReferences
- en: The `.csproj` file can also contain references to external libraries that need
    importing. Open [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/SentimentAnalysisConsoleApp.csproj](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/SentimentAnalysisConsoleApp.csproj)
    and search for the term `PackageReference`. See that there’s only one line containing
    `Microsoft.ML`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`.csproj` 文件也可以包含需要导入的外部库引用。打开 [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/SentimentAnalysisConsoleApp.csproj](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/SentimentAnalysisConsoleApp.csproj)
    并搜索术语 `PackageReference`。你会看到只有一行包含 `Microsoft.ML`。'
- en: At this point, we’ve finished examining the C# project code for `using` statements.
    This revealed the need to add `Microsoft.ML`, `Microsoft.ML.Data`, and `Microsoft.ML.DataOperationsCatalog`.
    The `.csproj` file reconfirmed the need to add `Microsoft.ML`. Now that we have
    an idea of which libraries we need to add, let’s download them from NuGet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了对C#项目代码中`using`语句的检查。这揭示了需要添加`Microsoft.ML`、`Microsoft.ML.Data`和`Microsoft.ML.DataOperationsCatalog`。`.csproj`文件再次确认了需要添加`Microsoft.ML`。现在我们已经知道了需要添加哪些库，让我们从NuGet下载它们。
- en: Downloading ML.NET from NuGet
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从NuGet下载ML.NET
- en: 'NuGet is the package manager for .NET. In traditional software development,
    `.dll` management and dependencies are usually handled by your IDE. This functionality
    is unfortunately missing from BP, so we’ll need to manually download packages
    from the NuGet website:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet是.NET的包管理器。在传统的软件开发中，`.dll`管理和依赖通常由您的IDE处理。这个功能很遗憾在BP中缺失，因此我们需要从NuGet网站手动下载包：
- en: Open [https://www.nuget.org/](https://www.nuget.org/) in your web browser. Search
    for `ML.NET`. Click on the result named **Microsoft.ML**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开[https://www.nuget.org/](https://www.nuget.org/)。搜索`ML.NET`。点击名为**Microsoft.ML**的结果。
- en: Click on version `.nupkg` file. This file can be opened with a `.zip` extraction
    program, including the default Windows one.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击版本`.nupkg`文件。此文件可以用`.zip`提取程序打开，包括默认的Windows程序。
- en: '![Figure 3.3 – Downloading Microsoft.ML version 2.0.1 from NuGet](img/B18416_03_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 从NuGet下载Microsoft.ML版本2.0.1](img/B18416_03_3.jpg)'
- en: Figure 3.3 – Downloading Microsoft.ML version 2.0.1 from NuGet
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 从NuGet下载Microsoft.ML版本2.0.1](img/B18416_03_3.jpg)'
- en: Open the `.nupkg` file using a zip extraction tool. Navigate into the `lib\netstandard2.0`
    folder. Extract all seven of the `.dll` files somewhere convenient, such as your
    desktop. We will be using these files later.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用zip提取工具打开`.nupkg`文件。导航到`lib\netstandard2.0`文件夹。将所有七个`.dll`文件提取到方便的位置，例如您的桌面。我们稍后会使用这些文件。
- en: '![Figure 3.4 – Seven .dll files to extract from lib\netstandard2.0](img/B18416_03_4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 从lib\netstandard2.0中提取的七个.dll文件](img/B18416_03_4.jpg)'
- en: Figure 3.4 – Seven .dll files to extract from lib\netstandard2.0
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 从lib\netstandard2.0中提取的七个.dll文件](img/B18416_03_4.jpg)'
- en: 'Of the three libraries that we need to import, two are present in the `Microsoft.ML`
    package: `Microsoft.ML` is in `Microsoft.ML.dll` and `Microsoft.ML.Data` is in
    `Microsoft.ML.Data.dll`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们需要导入的三个库中，有两个包含在`Microsoft.ML`包中：`Microsoft.ML`位于`Microsoft.ML.dll`中，而`Microsoft.ML.Data`位于`Microsoft.ML.Data.dll`中。
- en: It isn’t clear where we can find `Microsoft.ML.DataOperationsCatalog`. From
    the API documentation, found at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog?view=ml-dotnet),
    we see that it belongs to the `Microsoft.ML.Data.dll` assembly, meaning that the
    `Microsoft.ML` `.dll` files cover all of the `using` statements that we know of
    so far.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不清楚在哪里可以找到`Microsoft.ML.DataOperationsCatalog`。从API文档中，可以在[https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog?view=ml-dotnet)找到，我们看到它属于`Microsoft.ML.Data.dll`程序集，这意味着`Microsoft.ML`的`.dll`文件涵盖了迄今为止我们所知的所有`using`语句。
- en: '![Figure 3.5 – DataOperationsCatalog found in Microsoft.ML.Data.dll](img/B18416_03_5.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 在Microsoft.ML.Data.dll中找到的DataOperationsCatalog](img/B18416_03_5.jpg)'
- en: Figure 3.5 – DataOperationsCatalog found in Microsoft.ML.Data.dll
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 在Microsoft.ML.Data.dll中找到的DataOperationsCatalog](img/B18416_03_5.jpg)'
- en: Now that we’ve extracted some of the necessary `.dll` files from the NuGet package,
    let’s move them to a location that BP can access.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从NuGet包中提取了一些必要的`.dll`文件，让我们将它们移动到BP可以访问的位置。
- en: Copying the .dll files to the BP installation folder
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将.dll文件复制到BP安装文件夹
- en: 'By default, BP is installed at `C:\Program Files\Blue Prism Limited\Blue Prism
    Automate`. We need to copy the `.dll` files to the installation folder. If this
    isn’t your installation path, please substitute your own instead:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，BP安装在`C:\Program Files\Blue Prism Limited\Blue Prism Automate`。我们需要将`.dll`文件复制到安装文件夹。如果这不是您的安装路径，请替换为您自己的路径：
- en: Copy the seven `.dll` files extracted from the NuGet package into the BP installation
    folder.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从NuGet包中提取的七个`.dll`文件复制到BP安装文件夹中。
- en: Restart the BP application if you have it open. BP needs to be restarted in
    order to load the new assemblies.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经打开了BP应用程序，请重新启动。BP需要重新启动才能加载新的程序集。
- en: Important note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are multiple locations you can copy assemblies to so that they work with
    BP. This includes the Windows directory, the Windows system directory, and any
    folder on the system’s path environment variable. To make this example less error-prone,
    we’re copying it into the BP installation folder. In a production environment,
    a more maintainable solution would be to copy the `.dll` files into a custom folder
    and to include that folder in the Windows environment path variable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将程序集复制到多个位置，以便与BP一起使用。这包括Windows目录、Windows系统目录以及系统路径环境变量中的任何文件夹。为了使这个例子更不容易出错，我们将它复制到BP安装文件夹中。在生产环境中，一个更易于维护的解决方案是将`.dll`文件复制到一个自定义文件夹中，并将该文件夹包含在Windows环境路径变量中。
- en: Now that the libraries have been copied into a folder that’s accessible to BP,
    let’s create a sample Object and import them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库已经被复制到一个BP可访问的文件夹中，让我们创建一个示例对象并导入它们。
- en: Creating a BP object and adding external references and namespace imports
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个BP对象并添加外部引用和命名空间导入
- en: 'In this final section of the first example, we’ll create a BP Object, add the
    `.dll` files that are needed as references, add namespaces, and set the language
    to C#:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例的最后一部分，我们将创建一个BP对象，添加所需的`.dll`文件作为引用，添加命名空间，并将语言设置为C#：
- en: Create a new Group named `Ch3` inside of **Studio** | **Objects**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工作室** | **对象**内创建一个名为`Ch3`的新组。
- en: Create a new Object named `Example 1 – Sentiment Analysis for User Reviews`
    inside of the `Ch3` Group.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Ch3`组内创建一个名为`Example 1 – 用户评论的情感分析`的新对象。
- en: On the **Initialise** Page, double-click on the white box with the Object’s
    name. This opens the Business Object’s Properties.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**初始化**页面，双击带有对象名称的白色框。这会打开业务对象的属性。
- en: '![Figure 3.6 – Double-clicking to open the Properties of the Business Object](img/B18416_03_6.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 双击打开业务对象的属性](img/B18416_03_6.jpg)'
- en: Figure 3.6 – Double-clicking to open the Properties of the Business Object
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 双击打开业务对象的属性
- en: Click on the `Microsoft.ML.dll`. Click `Microsoft.ML.Data.dll`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Microsoft.ML.dll`。点击`Microsoft.ML.Data.dll`。
- en: Click `Microsoft.ML`. Click `Microsoft.ML.Data`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Microsoft.ML`。点击`Microsoft.ML.Data`。
- en: Choose **C#** in the **Language** drop-down menu.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**语言**下拉菜单中选择**C#**。
- en: 'Verify that the **Code Options** tab looks like the following:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认**代码选项**选项卡看起来如下：
- en: '![Figure 3.7 – The Code Options tab at the end of the first example](img/B18416_03_7.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 在第一个示例末尾的代码选项卡](img/B18416_03_7.jpg)'
- en: Figure 3.7 – The Code Options tab at the end of the first example
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 在第一个示例末尾的代码选项卡
- en: '**Save** the object.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**对象。'
- en: In this example, we did the preparation work needed before moving the C# code
    into a Code Stage. First, we examined the project’s code to figure out *some*
    of the needed assembly imports. The assemblies themselves and the further code
    that we need to add to code stages might have additional dependencies that haven’t
    been imported yet. Next, we downloaded the ML.NET package from NuGet, and extracted
    the `.dll` files. Finally, we copied the ML.NET assemblies into the BP installation
    folder and added them as references in the Object’s Properties. In the next section,
    we’ll focus on porting the source code into BP.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在将C#代码移动到代码阶段之前完成了所需的前期准备工作。首先，我们检查了项目的代码，以确定所需的某些程序集导入。这些程序集本身以及我们需要添加到代码阶段的进一步代码可能还有尚未导入的附加依赖项。接下来，我们从NuGet下载了ML.NET包，并提取了`.dll`文件。最后，我们将ML.NET程序集复制到BP安装文件夹中，并在对象的属性中添加了它们作为引用。在下一节中，我们将专注于将源代码移植到BP中。
- en: Porting ML.NET C# into a Code Stage
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ML.NET C#移植到代码阶段
- en: Porting code into BP is more of an art than a science. It requires knowledge
    of how C# works and digging into the ML.NET API documentation when necessary.
    We’ve already discussed the **Code Options** section of the Object’s Properties.
    The Object’s Properties also have a **Global Code** tab, which will be used in
    the next example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码移植到BP更像是艺术而非科学。这需要了解C#的工作原理，并在必要时深入研究ML.NET API文档。我们已经讨论了对象的属性中的**代码选项**部分。对象的属性还有一个**全局代码**选项卡，它将在下一个示例中使用。
- en: Global Code
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局代码
- en: 'The **Global Code** tab is accessed through the Object’s Properties, similarly
    to the **Code** **Options** tab:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局代码**选项卡通过对象的属性访问，类似于**代码****选项**选项卡：'
- en: '![Figure 3.8 – The Global Code tab is accessed through the Object’s Properties](img/B18416_03_8.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 通过对象的属性访问全局代码选项卡](img/B18416_03_8.jpg)'
- en: Figure 3.8 – The Global Code tab is accessed through the Object’s Properties
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 通过对象的属性访问全局代码标签
- en: The **Global Code** section is used to place *common code* that’s needed across
    multiple Code Stages. This is similar in concept to a global Data Item (unticking
    Hide from other pages in the process checkbox) that’s needed across different
    Actions or Pages. Common code can include *variables*, *classes*, and *functions*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局代码**部分用于放置需要在多个代码阶段中使用的**通用代码**。这在概念上类似于需要在不同操作或页面中使用的全局数据项（取消选中“在过程中隐藏其他页面”的复选框），类似于通用数据项。通用代码可以包括**变量**、**类**和**函数**。'
- en: You’ll also notice a **Check Code** button. This button validates the code from
    the perspective of the compiler in the **Global Code** section, as well as any
    other Code Stage in the Object. We will be using this button frequently to help
    us figure out which assemblies are missing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到一个**检查代码**按钮。此按钮从**全局代码**部分的编译器角度以及对象中的任何其他代码阶段验证代码。我们将频繁使用此按钮来帮助我们确定哪些程序集缺失。
- en: 'In the next example, we will use both the **Global Code** section and the **Check
    Code** button to help in porting the C# code into BP. The example will go through
    five high-level steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将使用**全局代码**部分和**检查代码**按钮来帮助将C#代码移植到BP。示例将通过五个高级步骤进行：
- en: Moving two C# classes into the **Global Code** section of the Object
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个C#类移动到对象的**全局代码**部分
- en: Copying the main source code into a Code Stage
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主要源代码复制到代码阶段
- en: Iteratively fixing compiler errors through the use of the **Check** **Code**
    button
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用**检查** **代码**按钮迭代修复编译错误
- en: Changing C# console print commands so that they output to a file
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改C#控制台打印命令，以便将输出到文件
- en: Testing the ported ML program
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试移植的ML程序
- en: Example 2 - porting the source code into BP
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2 - 将源代码移植到BP
- en: In this example, we will be moving all of the source code into a Code Stage,
    and fixing more assembly and namespace errors. Our goal is to reach a point where
    we can receive a prediction from the C# Code Stage.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将把所有源代码移动到一个代码阶段，并修复更多的汇编和命名空间错误。我们的目标是达到一个可以接收C#代码阶段预测的点。
- en: Important note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This example was created and tested on BP versions 7.1.1 and 7.1.2\. However,
    if you’re using a different version of BP, there may be additional steps needed
    to get this example working. This is because different versions of BP come bundled
    with different versions of Microsoft’s .dll libraries. If you look into your BP
    installation folder, many of these .dll files are prefixed with `System.*` or
    `Microsoft.*`. The steps shown in this example should in the worst case get you
    very close to making a prediction through a Code Stage. You can get to a working
    solution by applying the techniques that we’ll see below.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例是在BP版本7.1.1和7.1.2上创建和测试的。然而，如果您使用的是BP的不同版本，可能需要额外的步骤才能使此示例正常工作。这是因为BP的不同版本捆绑了不同版本的Microsoft的.dll库。如果您查看BP的安装文件夹，许多这些.dll文件都是以`System.*`或`Microsoft.*`为前缀。本例中显示的步骤在最坏的情况下应该能让你非常接近通过代码阶段进行预测。您可以通过应用我们下面将看到的技巧来获得一个可工作的解决方案。
- en: Moving class definitions into BP
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将类定义移动到BP
- en: 'In the first example, we saw that there were only three `.cs` source files.
    Two of the source files, `SentimentIssue.cs` and `SentimentPrediction.cs`, are
    class definitions. Let’s move them into the **Global Code** section of the Object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们看到了只有三个`.cs`源文件。其中两个源文件，`SentimentIssue.cs`和`SentimentPrediction.cs`，是类定义。让我们将它们移动到对象的**全局代码**部分：
- en: Open the Object created in the first example. If needed, a completed version
    of the Object, named `Example 1 - Sentiment Analysis for User Reviews (Completed)`,
    should have already been imported to the `Ch3` Group.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第一个示例中创建的对象。如果需要，一个名为`Example 1 - Sentiment Analysis for User Reviews (Completed)`的完成版对象应该已经导入到`Ch3`组中。
- en: Open the Object’s Properties by double-clicking on the white box with the Object’s
    name on the **Initialise** Page.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击**初始化**页面上的带有对象名称的白色框来打开对象的属性。
- en: Click on the **Global** **Code** tab.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**全局** **代码**标签。
- en: Copy the class definition code from [https://github.com/dotnet/machine learning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs)
    into the `public class SentimentIssue { … }`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类定义代码从[https://github.com/dotnet/machine learning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentIssue.cs)复制到`public
    class SentimentIssue { … }`。
- en: Repeat this for the file at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs).
    This includes everything between `public class SentimentPrediction { … }`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对[https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/DataStructures/SentimentPrediction.cs)中的文件重复此操作。这包括`public
    class SentimentPrediction { … }`之间的所有内容。
- en: 'Confirm that the **Global Code** section contains two class definitions like
    in the figure below:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认**全局代码**部分包含如图所示的两个类定义：
- en: '![Figure 3.9 – The Global Code section contains the two class definitions](img/B18416_03_9.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 全局代码部分包含两个类定义](img/B18416_03_9.jpg)'
- en: Figure 3.9 – The Global Code section contains the two class definitions
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 全局代码部分包含两个类定义
- en: Click on the `The type 'Attribute' is defined in an assembly that is not referenced.
    You must add a reference to assembly 'netstandard,` `Version=2.0.0.0, Culture=neutral`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“类型 'Attribute' 在未引用的程序集中定义。您必须添加对程序集 'netstandard,` `Version=2.0.0.0, Culture=neutral'
    的引用。”
- en: Click on the `netstandard.dll`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`netstandard.dll`。
- en: Return to the **Global Code** tab and click **Check Code** again. Ensure that
    no compiler errors remain.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**全局代码**选项卡并再次点击**检查代码**。确保没有编译器错误。
- en: Click **OK** to save the business object’s properties.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以保存业务对象的属性。
- en: Save the object.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存对象。
- en: So far, we’ve successfully added two classes to the **Global Code** section
    of the Object. Next, let’s import the main program code into a Code Stage.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功将两个类添加到对象的**全局代码**部分。接下来，让我们将主程序代码导入到一个代码阶段。
- en: Porting the machine learning program code into a Code Stage
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将机器学习程序代码移植到代码阶段
- en: 'The main code for the ML program is in this file: [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习程序的主要代码在这个文件中：[https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/SentimentAnalysisConsoleApp/Program.cs)。
- en: 'Let’s move it into a Code Stage:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其移动到一个代码阶段：
- en: Navigate to the `Action 1` Page and add a Code Stage.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“动作 1”页面并添加一个代码阶段。
- en: '**Link** it between **Start** and **End**.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链接**它们在**开始**和**结束**之间。'
- en: '![Figure 3.10 – Adding a Code Stage to Action 1](img/B18416_03_10.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 向动作 1 添加代码阶段](img/B18416_03_10.jpg)'
- en: Figure 3.10 – Adding a Code Stage to Action 1
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 向动作 1 添加代码阶段
- en: Look at lines 12–20 of `Program.cs`. See that it has a number of `private static
    readonly string` statements. These statements define the paths to the training
    data file (line 15) and the model output file (line 20). Add two `Text` to the
    Object diagram to represent these. Name one Data Item `DataPath` and the other
    `ModelPath`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`Program.cs`的第 12-20 行。注意它包含多个`private static readonly string`语句。这些语句定义了训练数据文件（第
    15 行）和模型输出文件（第 20 行）的路径。在对象图中添加两个`Text`来表示这些。将一个数据项命名为`DataPath`，另一个命名为`ModelPath`。
- en: 'Set the `DataPath` to `C:/Users/Public/wikiDetoxAnnotated40kRows.tsv`. Set
    the `ModelPath` to `C:/Users/Public/ch3_SentimentModel.zip`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DataPath`设置为`C:/Users/Public/wikiDetoxAnnotated40kRows.tsv`，将`ModelPath`设置为`C:/Users/Public/ch3_SentimentModel.zip`：
- en: '![ Figure 3.11 – Set the Initial Values of DataPath and ModelPath](img/B18416_03_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – 设置DataPath和ModelPath的初始值](img/B18416_03_11.jpg)'
- en: Figure 3.11 – Set the Initial Values of DataPath and ModelPath
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 设置DataPath和ModelPath的初始值
- en: Double-click `Code1`. Add two Inputs corresponding to the Data Items `DataPath`
    and `ModelPath`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`Code1`。添加两个与数据项`DataPath`和`ModelPath`对应的输入。
- en: '![Figure 3.12 – Adding the two Data Items as inputs to the Code Stage](img/B18416_03_12.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12 – 将两个数据项作为输入添加到代码阶段](img/B18416_03_12.jpg)'
- en: Figure 3.12 – Adding the two Data Items as inputs to the Code Stage
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 将两个数据项作为输入添加到代码阶段
- en: Click on the `Main(string[] args) { [Copy the text here] }` into the code window.
    These are lines 24 to 68 of `Program.cs`. Your code window should have 45 lines
    of code in it.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击代码窗口中的`Main(string[] args) { [Copy the text here] }`。这些是`Program.cs`的第24行到第68行。你的代码窗口中应该有45行代码。
- en: '![Figure 3.13 – The 45 lines of code that should be in your window](img/B18416_03_13.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13 – 应该在窗口中的45行代码](img/B18416_03_13.jpg)'
- en: Figure 3.13 – The 45 lines of code that should be in your window
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 应该在窗口中的45行代码
- en: Click on the `.dll` is missing. For example, you might encounter `You must add
    a reference to assembly 'Microsoft.ML.Core` or `You must add a reference to assembly
    'Microsoft.ML.DataView`. Close the **Check Code** window and press **OK** to save
    the Code Stage.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`.dll`缺失。例如，你可能会遇到`你必须添加对程序集'Microsoft.ML.Core'的引用`或`你必须添加对程序集'Microsoft.ML.DataView'的引用`。关闭**检查代码**窗口并按**确定**保存代码阶段。
- en: Find the `Microsoft.ML.DataView.dll` file from the NuGet website by searching
    for `lib\netstandard2.0\Microsoft.ML.DataView.dll` file from the NuGet package
    into the BP installation folder location. Close and relaunch BP.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在NuGet网站上搜索`lib\netstandard2.0\Microsoft.ML.DataView.dll`文件从NuGet包到BP安装文件夹位置找到`Microsoft.ML.DataView.dll`文件。关闭并重新启动BP。
- en: Open the Object’s Properties on the `Microsoft.ML.Core.dll` and `Microsoft.ML.DataView.dll`
    as **External References**. Press **OK** to close the Object’s Properties.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Microsoft.ML.Core.dll`和`Microsoft.ML.DataView.dll`上打开对象的属性作为**外部引用**。按**确定**关闭对象的属性。
- en: '![Figure 3.14 – Adding two new External References to the Object’s Properties](img/B18416_03_14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14 – 将两个新的外部引用添加到对象的属性中](img/B18416_03_14.jpg)'
- en: Figure 3.14 – Adding two new External References to the Object’s Properties
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 将两个新的外部引用添加到对象的属性中
- en: Go back to the `Code1` Stage and click **Check Code** again. There should still
    be four compiler errors that don’t give a clear indication of what assembly or
    namespace needs to be imported.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`Code1`阶段并再次点击**检查代码**。应该仍然有四个编译器错误，它们没有给出需要导入哪个程序集或命名空间的明确指示。
- en: '![Figure 3.15 – The remaining four compiler errors](img/B18416_03_15.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – 剩余的四个编译器错误](img/B18416_03_15.jpg)'
- en: Figure 3.15 – The remaining four compiler errors
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 剩余的四个编译器错误
- en: At this point, we don’t have a working Code Stage yet, but we’re getting close!
    Let’s investigate and resolve each of the remaining compiler errors individually.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有一个工作的代码阶段，但我们已经接近了！让我们逐一调查和解决剩余的编译器错误。
- en: Fixing individual compiler errors
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复单个编译器错误
- en: 'None of the compiler errors have obvious solutions. We’ll need to rely on the
    API documentation to find out which namespaces or assemblies need to be added.
    Let’s tackle them in the order of which line the error occurs:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 没有编译器错误有明显的解决方案。我们需要依赖API文档来找出需要添加哪些命名空间或程序集。让我们按照错误发生的顺序来处理它们：
- en: 'Look at the compiler error for line 8\. It says `The type or namespace name
    ''TrainTestData'' could not be found`. Let’s refer to the API to find out what
    `TrainTestData` is. The documentation at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog.traintestdata?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog.traintestdata?view=ml-dotnet)
    shows that it belongs to `DataOperationsCatalog`. Recall that `DataOperationsCatalog`
    was one of the `using` statements at the beginning of the `Project.cs` file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看第8行的编译错误。它显示“找不到类型或命名空间名称 'TrainTestData'”。让我们参考API以找出`TrainTestData`是什么。在[https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog.traintestdata?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.dataoperationscatalog.traintestdata?view=ml-dotnet)的文档显示它属于`DataOperationsCatalog`。回想一下，`DataOperationsCatalog`是`Project.cs`文件开头的一个`using`语句之一：
- en: '[PRE1]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`using` statements are normally ported to BP by adding them into the `using
    static` statements cannot be added in that manner. Instead, we need to provide
    the whole namespace in the source code itself.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`using`语句通常通过将它们添加到`using static`语句中移植到BP，但不能以这种方式添加。相反，我们需要在源代码本身中提供整个命名空间。'
- en: 'Open the `Code1` stage on line 8 and prefix `TrainTestSplit` with `Microsoft.ML.DataOperationsCatalog`.
    Line 8 should now be as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第8行打开`Code1`阶段，并在`TrainTestSplit`前加上`Microsoft.ML.DataOperationsCatalog`。现在第8行应该是这样的：
- en: '[PRE2]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Click on **Check Code**. See that the compiler error on line 8 is gone.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**检查代码**。查看第8行的编译错误是否已消失。
- en: 'Look at the compiler error for line 13\. It says: `''TransformsCatalog.TextTransforms''
    does not contain a definition for ''FeaturizeText''`. Look up `FeaturizeText`
    in the API reference at [https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.textcatalog.featurizetext?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.textcatalog.featurizetext?view=ml-dotnet).
    It shows that the assembly `Microsoft.ML.Transforms.dll` is needed:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看第13行的编译错误。它显示：“'TransformsCatalog.TextTransforms' 没有定义 'FeaturizeText'”。在[https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.textcatalog.featurizetext?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.textcatalog.featurizetext?view=ml-dotnet)的API参考中查找`FeaturizeText`。它显示需要`Microsoft.ML.Transforms.dll`程序集：
- en: '![Figure 3.16 – FeaturizeText in Microsoft.ML.Transforms.dll](img/B18416_03_16.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – Microsoft.ML.Transforms.dll中的FeaturizeText](img/B18416_03_16.jpg)'
- en: Figure 3.16 – FeaturizeText in Microsoft.ML.Transforms.dll
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – Microsoft.ML.Transforms.dll中的FeaturizeText
- en: Add `Microsoft.ML.Transforms.dll` as an **External Reference** in the Object’s
    Properties and close the Object’s Properties window by pressing **OK**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象的属性中将`Microsoft.ML.Transforms.dll`添加为**外部引用**，并通过按**确定**按钮关闭对象的属性窗口。
- en: '![Figure 3.17 – Adding Microsoft.ML.Transforms.dll as an External Reference](img/B18416_03_17.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17 – 添加Microsoft.ML.Transforms.dll作为外部引用](img/B18416_03_17.jpg)'
- en: Figure 3.17 – Adding Microsoft.ML.Transforms.dll as an External Reference
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – 添加Microsoft.ML.Transforms.dll作为外部引用
- en: Verify that the compiler error for line 13 is gone.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证第13行的编译错误是否已消失。
- en: 'Look at the compiler error for line 16\. It says `''BinaryClassificationCatalog.BinaryClassificationTrainers''
    does not contain a definition for ''SdcaLogisticRegression''`. The API page at
    [https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.trainers.sdcalogisticregressionbinarytrainer?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.trainers.sdcalogisticregressionbinarytrainer?view=ml-dotnet)
    shows that SdcaLogisticRegression is in Microsoft.ML.StandardTrainers.dll:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看第16行的编译错误。它显示“'BinaryClassificationCatalog.BinaryClassificationTrainers' 没有定义
    'SdcaLogisticRegression'”。在[https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.trainers.sdcalogisticregressionbinarytrainer?view=ml-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.ml.trainers.sdcalogisticregressionbinarytrainer?view=ml-dotnet)的API页面显示，SdcaLogisticRegression位于`Microsoft.ML.StandardTrainers.dll`中：
- en: '![Figure 3.18 – SdcaLogisticRegression in Microsoft.ML.StandardTrainers.dll](img/B18416_03_18.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – Microsoft.ML.StandardTrainers.dll中的SdcaLogisticRegression](img/B18416_03_18.jpg)'
- en: Figure 3.18 – SdcaLogisticRegression in Microsoft.ML.StandardTrainers.dll
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – Microsoft.ML.StandardTrainers.dll中的SdcaLogisticRegression
- en: Add `Microsoft.ML.StandardTrainers.dll` as an **External Reference** in the
    Object’s Properties. Press **OK** to close the Properties window.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象的属性中将`Microsoft.ML.StandardTrainers.dll`添加为**外部引用**。按**确定**按钮关闭属性窗口。
- en: Verify that the compiler error for line 16 is gone.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证第16行的编译错误是否已消失。
- en: The last compiler error that remains on line 26 is about a utility that helps
    to print results to the console window (`ConsoleHelper.PrintBinaryClassificationMetrics`).
    Since our goal is to get this running from BP, we won’t see any console window.
    Let’s change the C# code to write the output to a file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的第 26 行的最后一个编译错误是关于一个帮助将结果打印到控制台窗口的实用程序 (`ConsoleHelper.PrintBinaryClassificationMetrics`)。由于我们的目标是让这个程序从
    BP 运行，我们将不会看到任何控制台窗口。让我们将 C# 代码更改为将输出写入文件。
- en: Changing console output to a file
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将控制台输出更改为文件
- en: 'The `ConsoleHelper.cs` file is located at [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/common/ConsoleHelper.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/common/ConsoleHelper.cs).
    We can copy the code of that function into the **Global Code** section of our
    Object’s Properties and change line 26 to call that function from our Code Stage.
    Then, we will change printing to the console window to writing a file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleHelper.cs` 文件位于 [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/common/ConsoleHelper.cs](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/common/ConsoleHelper.cs)。我们可以将那个函数的代码复制到我们的对象的属性中的
    **全局代码** 部分，并将第 26 行更改为从我们的代码阶段调用该函数。然后，我们将更改打印到控制台窗口为写入文件：'
- en: 'Open `ConsoleHelper.cs` on GitHub and copy the `PrintBinary` **ClassificationMetrics(…)**
    function from lines 41–57 into the **Global Code** section of your Object’s Properties:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GitHub 上打开 `ConsoleHelper.cs` 文件，并将第 41-57 行的 `PrintBinary ClassificationMetrics(…)`
    函数复制到你的对象的属性中的 **全局代码** 部分：
- en: '![Figure 3.19 – Copying PrintBinaryClassificationMetrics() into Global Code](img/B18416_03_19.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – 将 PrintBinaryClassificationMetrics() 复制到全局代码](img/B18416_03_19.jpg)'
- en: Figure 3.19 – Copying PrintBinaryClassificationMetrics() into Global Code
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 将 PrintBinaryClassificationMetrics() 复制到全局代码
- en: Open the `Code1` Stage and on line 26, delete the `Console.Helper.` prefix.
    Line 26 should show `PrintBinaryClassificationMetrics(trainer.ToString(), metrics);`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Code1` 阶段，在第 26 行删除 `Console.Helper.` 前缀。第 26 行应显示 `PrintBinaryClassificationMetrics(trainer.ToString(),
    metrics);`。
- en: Click **Check Code** and confirm that there are no more compiler errors.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **检查代码** 并确认没有更多的编译错误。
- en: Open the Object’s Properties and add `System.IO`. to **Namespace Imports**.
    This is needed to write to a file.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开对象的属性，并将 `System.IO` 添加到 **命名空间导入**。这是写入文件所需的。
- en: '![Figure 3.20 – Adding System.IO to the Namespace Imports](img/B18416_03_20.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – 将 System.IO 添加到命名空间导入](img/B18416_03_20.jpg)'
- en: Figure 3.20 – Adding System.IO to the Namespace Imports
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – 将 System.IO 添加到命名空间导入
- en: 'Go back to the `Code1` Stage and add the following lines to the beginning of
    the code window:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `Code1` 阶段，并在代码窗口的开始处添加以下行：
- en: '[PRE3]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Delete the last two lines at the bottom of the code window. They are as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除代码窗口底部的最后两行。它们如下所示：
- en: '[PRE4]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s safe to delete them, as their purpose is to pause the console window so
    that you can review the printed text, which is no longer necessary.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以安全地删除它们，因为它们的作用是暂停控制台窗口，以便你可以查看打印的文本，这现在不再是必要的。
- en: 'Paste the following three lines at the very bottom of the code window:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下三行粘贴到代码窗口的底部：
- en: '[PRE5]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Press **OK** to save the code window.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **确定** 保存代码窗口。
- en: Now that all of the compiler errors are resolved, we’re ready to download the
    training data and test the ML.NET code stage.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有编译错误都已解决，我们可以下载训练数据并测试 ML.NET 代码阶段。
- en: Running the ML.NET program
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 ML.NET 程序
- en: 'We’re close to the finish line! We need to download the training data, copy
    it to the correct location, and run our model:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接近终点线了！我们需要下载训练数据，将其复制到正确的位置，并运行我们的模型：
- en: Download the training data from [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/Data/wikiDetoxAnnotated40kRows.tsv](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/Data/wikiDetoxAnnotated40kRows.tsv).
    Ensure that the file is downloaded as a `.tsv` file and *not* a `.``txt` file.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/Data/wikiDetoxAnnotated40kRows.tsv](https://github.com/dotnet/machinelearning-samples/blob/main/samples/csharp/getting-started/BinaryClassification_SentimentAnalysis/SentimentAnalysis/Data/wikiDetoxAnnotated40kRows.tsv)
    下载训练数据。确保文件以 `.tsv` 文件格式下载，*而不是* `.txt` 文件。
- en: Copy the `.tsv` file to the location specified by the `DataPath` Data Item,
    `C:/Users/Public/wikiDetoxAnnotated40kRows.tsv`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `.tsv` 文件复制到由 `DataPath` 数据项指定的位置，`C:/Users/Public/wikiDetoxAnnotated40kRows.tsv`。
- en: Click on the `Action 1` Page and run it in the Object Studio.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“操作1”页面，并在对象工作室中运行它。
- en: 'See that there’s an error: `Internal : Could not execute code stage because
    exception thrown by code stage: Could not load file or assembly ‘``System.Collections.Immutable,
    Version=1.2.3.0`.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到有一个错误：“内部：无法执行代码阶段，因为代码阶段抛出异常：无法加载文件或程序集‘System.Collections.Immutable, Version=1.2.3.0’”。
- en: Find the `Systems.Collections.Immutable.dll` file from the NuGet website by
    searching for `lib\netstandard2.0\Systems.Collections.Immutable.dll` file from
    the NuGet package into the BP installation folder location. Close and relaunch
    BP.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在NuGet网站上搜索“lib\netstandard2.0\Systems.Collections.Immutable.dll”文件从NuGet包中找到，将其放入BP安装文件夹位置。关闭并重新启动BP。
- en: 'Run `Action 1` Page from the Object Studio again. See that there’s an error:
    `Shuffle input cursor reader failed with an exception`. This error is not very
    useful, but we can enclose the Code Stage into a try / catch statement to obtain
    the full stack trace. The full stack trace reveals another missing dependency,
    `Microsoft.ML.CpuMath`.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次从对象工作室运行“操作1”页面。注意到有一个错误：“Shuffle输入游标读取失败，异常”。这个错误不是很有用，但我们可以将代码阶段包裹在try /
    catch语句中，以获取完整的堆栈跟踪。完整的堆栈跟踪揭示了另一个缺失的依赖项，“Microsoft.ML.CpuMath”。
- en: Find the `Microsoft.ML.CpuMath.dll` file from the NuGet website by searching
    for `lib\netstandard2.0\ Microsoft.ML.CpuMath.dll` file from the NuGet package
    into the BP installation folder location. This assembly actually has a further
    dependency on a file named CpuMathNative.dll. This file would normally be provided
    to you from the ML engineers as it will be built as a part of their code project.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在NuGet网站上搜索“lib\netstandard2.0\Microsoft.ML.CpuMath.dll”文件从NuGet包中找到，将其放入BP安装文件夹位置。实际上，此程序集还依赖于一个名为CpuMathNative.dll的文件。这个文件通常由机器学习工程师提供，因为它将作为他们代码项目的一部分构建。
- en: 'Download `CpuMathNative.dll` from GitHub (assume that this is provided by the
    ML team): [https://github.com/PacktPublishing/Intelligent-Process-Automation-with-Blue-Prism/blob/main/ch3/CpuMathNative.dll](https://github.com/PacktPublishing/Intelligent-Process-Automation-with-Blue-Prism/blob/main/ch3/CpuMathNative.dll),
    and copy it to the BP installation folder. Close and relaunch BP.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub下载“CpuMathNative.dll”（假设这是由机器学习团队提供的）：[https://github.com/PacktPublishing/Intelligent-Process-Automation-with-Blue-Prism/blob/main/ch3/CpuMathNative.dll](https://github.com/PacktPublishing/Intelligent-Process-Automation-with-Blue-Prism/blob/main/ch3/CpuMathNative.dll)，并将其复制到BP安装文件夹。关闭并重新启动BP。
- en: Run `Action 1` Page from the Object Studio again.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次从对象工作室运行“操作1”页面。
- en: 'Open `C:\Users\Public\ch3_output.txt` and confirm that it looks similar to
    the following figure:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“C:\Users\Public\ch3_output.txt”并确认其外观类似于以下图示：
- en: '![Figure 3.21 – The redirected console out contained in ch3_output.txt](img/B18416_03_21.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21 – 包含在ch3_output.txt中的重定向控制台输出](img/B18416_03_21.jpg)'
- en: Figure 3.21 – The redirected console out contained in ch3_output.txt
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 包含在ch3_output.txt中的重定向控制台输出
- en: This file shows the training accuracy and the results of a sample prediction
    for the sentence `I love` `this movie!`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件显示了句子的训练准确性和对“我爱这部电影！”的样本预测结果。
- en: Confirm that the file, `C:/Users/Public/ch3_SentimentModel.zip`, stored in the
    `ModelPath` data item was created. The file size should be around 13 MB. This
    file can be loaded to make predictions without training the model again.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认存储在“ModelPath”数据项中的文件“C:/Users/Public/ch3_SentimentModel.zip”已创建。文件大小应约为13
    MB。此文件可以加载进行预测，而无需再次训练模型。
- en: We’ve completed porting the ML code into BP. The biggest difficulty to overcome
    was knowing which assemblies and namespace imports to include. We were able to
    find this information in the compiler errors and the ML.NET API documentation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了将机器学习代码移植到BP的过程。克服的最大困难是知道应该包含哪些程序集和命名空间导入。我们能在编译器错误和ML.NET API文档中找到这些信息。
- en: For reference, a completed object for the second example should have been imported
    as `Example 2 - Sentiment Analysis for User Reviews (Completed)` in the `Ch3`
    Group. Now that we have the model trained and the prediction working, let’s refactor
    the example so that it follows BP best practices.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，第二个示例的完整对象应该已导入到“Ch3”组中的“Example 2 - 用户评论情感分析（完成）”。现在我们已经训练了模型并且预测工作正常，让我们重构这个示例，使其遵循BP最佳实践。
- en: Improving BP integration
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进BP集成
- en: While the code in the second example works from a functional standpoint, it
    isn’t well integrated into BP. It’s housed in a single Code Stage, which isn’t
    maintainable or reusable. Data scientists don’t necessarily have experience in
    software design, so you may very well receive an entire ML program in a single
    source file or ML notebook to port into BP.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第二个例子中的代码从功能角度来看是可行的，但它并没有很好地集成到BP中。它被放在一个单独的代码阶段中，这既不可维护也不可重用。数据科学家不一定有软件设计经验，因此你可能会收到一个完整的ML程序，它包含在一个源文件或ML笔记本中，以便将其导入BP。
- en: 'Some issues that are present in the second example include the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子中存在的一些问题包括以下内容：
- en: There’s low logging fidelity. One of the biggest concerns when adding Code Stages
    is that you could be completing numerous important steps and not have any logs
    sent back to the BP database for record keeping.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录的精确度较低。在添加代码阶段时最大的担忧之一是，你可能完成了许多重要步骤，但没有任何日志发送回BP数据库以供记录。
- en: We need to retrain the entire model each time we want to make a prediction,
    which is time-consuming and repetitive work.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们想要进行预测时，都需要重新训练整个模型，这是一项耗时且重复的工作。
- en: There’s a single Action, which doesn’t promote reuse.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个动作，这不利于重用。
- en: There’s a lack of exception handling in the C# code.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#代码中缺少异常处理。
- en: Let’s look at how we can improve the four points listed in our next example.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在下一个例子中改进列出的四个要点。
- en: Example 3 - refactoring
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例3 - 重构
- en: 'In the final example of this chapter, we’ll look at a refactored version of
    the object from the second example, which improves the functionality, reusability,
    and logging:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个例子中，我们将查看第二个例子的重构版本，它改进了功能、可重用性和日志记录：
- en: Open the `Example 3 – Sentiment Analysis for User Reviews (Refactored)` Object
    in the `Ch3` Group in the Object Studio.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象工作室的`Ch3`组中打开`Example 3 – Sentiment Analysis for User Reviews (Refactored)`对象。
- en: Visit the `.zip` file without needing to edit the Object diagram.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无需编辑对象图即可访问`.zip`文件。
- en: '![Figure 3.22 – The training data path and saved model path are stored as Environment
    Variables](img/B18416_03_22.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图3.22 – 训练数据路径和保存的模型路径存储为环境变量](img/B18416_03_22.jpg)'
- en: Figure 3.22 – The training data path and saved model path are stored as Environment
    Variables
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – 训练数据路径和保存的模型路径存储为环境变量
- en: See that the trained model path is now separate from the prediction model path.
    By keeping these separate, you can retrain a model while continuing to predict
    using the previous model. This is crucial because a newly trained model needs
    to be vetted before being used in production.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，训练模型路径现在与预测模型路径分开。通过保持这些分开，你可以在继续使用之前的模型进行预测的同时重新训练模型。这是至关重要的，因为新训练的模型在使用生产之前需要经过审查。
- en: '![Figure 3.23 – The trained model path and prediction model path are different](img/B18416_03_22.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23 – 训练模型路径和预测模型路径不同](img/B18416_03_22.jpg)'
- en: Figure 3.23 – The trained model path and prediction model path are different
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 – 训练模型路径和预测模型路径不同
- en: See that the fraction of training to testing data is exposed as an Environment
    Variable if it needs to be changed without editing the Object diagram. Part of
    building a model is heavy amounts of experimentation surrounding training parameters.
    It’s desirable to not have the training/test split hard-coded inside the Object’s
    Code Stages, in case it needs to be changed. Another valid design would be to
    pass this in as an Input to the Action.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，如果需要更改而不编辑对象图，训练数据与测试数据的比例将作为环境变量暴露出来。构建模型的一部分是围绕训练参数的大量实验。最好不在对象的代码阶段中硬编码训练/测试分割，以防需要更改。另一种有效的设计是将此作为动作的输入。
- en: See that the training, scoring, model saving, and prediction making have all
    been split into separate Actions. Most importantly, we can now predict without
    needing to train the model every time. This also improves the fidelity of the
    Session Logs.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，训练、评分、模型保存和预测制作都已拆分为单独的动作。最重要的是，我们现在可以预测而无需每次都训练模型。这也提高了会话日志的精确度。
- en: '![Figure 3.24 – Each ML stage with its own Action to improve logging and reusability](img/B18416_03_24.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图3.24 – 每个机器学习阶段都有自己的动作以改进日志记录和可重用性](img/B18416_03_24.jpg)'
- en: Figure 3.24 – Each ML stage with its own Action to improve logging and reusability
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 – 每个机器学习阶段都有自己的动作以改进日志记录和可重用性
- en: Open the `try…catch` blocks have been added to each Code Stage, with error messages
    and a Success flag output back to BP.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个代码阶段中添加了`try…catch`块，将错误消息和成功标志输出回BP。
- en: '![Figure 3.25 – Adding try…catch blocks to improve error handling](img/B18416_03_25.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图3.25 – 添加try…catch块以改进错误处理](img/B18416_03_25.jpg)'
- en: Figure 3.25 – Adding try…catch blocks to improve error handling
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 – 添加try…catch块以改进错误处理
- en: Each Page also returns these to the caller as Outputs in the End stage instead
    of writing text into files.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每一页在结束阶段都将这些内容作为输出返回给调用者，而不是将文本写入文件。
- en: 'Visit the **Initialise** Page, open the Object’s Properties, and look at the
    **Global Code**. See that a number of new *static variables* have been added to
    accommodate all of the changes:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问**初始化**页面，打开对象的属性，查看**全局代码**。你会看到为了适应所有这些变化，已经添加了许多新的*静态变量*：
- en: '![Figure 3.26 – Static variables added to the Global Code, usable from other
    Code Stages](img/B18416_03_26.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图3.26 – 添加到全局代码中的静态变量，可在其他代码阶段中使用](img/B18416_03_26.jpg)'
- en: Figure 3.26 – Static variables added to the Global Code, usable from other Code
    Stages
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26 – 添加到全局代码中的静态变量，可在其他代码阶段中使用
- en: This concludes the third example. This was a refactored version of the second
    example, where readability, reusability, and maintainability have all been improved.
    It’s extremely common for an ML program to be contained entirely in just one or
    a few source files. Porting a C# program into a *single* Code Stage results in
    something that’s far from a BP best practice. We need to go that extra step and
    improve what’s provided so that it meets the standards of the IA Center of Excellence.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这第三个例子到此结束。这是对第二个例子的重构版本，可读性、可重用性和可维护性都得到了提升。将整个ML程序完全包含在一个或几个源文件中是非常常见的。将C#程序移植到*单个*代码阶段会导致的结果远远不符合BP的最佳实践。我们需要额外走一步，改进所提供的内容，使其符合IA卓越中心的行业标准。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: ML.NET is Microsoft’s open source, cross-platform ML framework. It’s built on
    .NET and can be used natively in BP through Code Stages. In this chapter, we were
    faced with a common IA scenario. We were provided with a working ML project built
    in ML.NET, and our task was to get the source code working in BP.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ML.NET是微软的开源、跨平台机器学习框架。它基于.NET构建，可以通过代码阶段在BP中本地使用。在本章中，我们面临了一个常见的IA场景。我们得到了一个用ML.NET构建的工作ML项目，我们的任务是让源代码在BP中工作。
- en: In the first example, we examined the source code to understand which `.dll`
    libraries needed to be imported. We downloaded the ML.NET package from NuGet and
    copied the assemblies into the BP installation folder.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们检查了源代码，以了解需要导入哪些`.dll`库。我们从NuGet下载了ML.NET包，并将程序集复制到BP安装文件夹中。
- en: In the second example, we started to move the code into a BP Code Stage. Some
    code, including class definitions, belong in the `.dll` or namespace errors. We
    tackled each error by reading the compiler error message and looking up key terms
    in the API as necessary. A key point to understand is that you don’t need to be
    an ML expert, nor do you need to have experience with the ML framework you’re
    working with to successfully port it into BP! We can successfully port the code
    by using **Check Code** and the documentation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们开始将代码移动到BP代码阶段。一些代码，包括类定义，属于`.dll`或命名空间错误。我们通过阅读编译器错误消息并在必要时查找API中的关键术语来解决每个错误。一个需要理解的关键点是，你不需要是ML专家，也不需要对你正在使用的ML框架有经验，就可以成功将其移植到BP！我们可以通过使用**检查代码**和文档来成功移植代码。
- en: Finally, it’s common for ML code to be provided as a single source code program.
    In the third example, we split up a single Code Stage into multiple Actions that
    more closely matched the ML life cycle. The main goal was to make our Object more
    reusable and maintainable going forward.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ML代码通常以单个源代码程序的形式提供。在第三个例子中，我们将单个代码阶段拆分为多个动作，这些动作更接近ML生命周期。主要目标是使我们的对象在未来更具可重用性和可维护性。
- en: This concludes *Part 1* of this book, where we focused on how BP can trigger
    ML predictions. The main ways of doing so are through web APIs, the command line
    interface, and Code Stages. Up next is *Part 2* of the book, where we shift our
    focus to IA solution design.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的*第一部分*到此结束，我们主要关注了BP如何触发ML预测。实现这一目标的主要方式是通过Web API、命令行界面和代码阶段。接下来是本书的*第二部分*，我们将重点转向IA解决方案设计。
- en: Part 2:Designing IA Solutions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：设计IA解决方案
- en: 'In *Part 1* of this book, we learned three different ways to connect BP to
    ML models to make predictions: Web APIs, the command-line interface, and code
    stages.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*第一部分*中，我们学习了三种将BP连接到ML模型进行预测的不同方法：Web API、命令行界面和代码阶段。
- en: '*Part 2* describes the BP solution design elements that surround the ML prediction.
    Although the design concepts here are generic in that they could be used with
    any RPA tool, they are illustrated in BP. In [*Chapter 4*](B18416_04.xhtml#_idTextAnchor062),
    we’ll introduce the idea of reviewing ML predictions as a way to manage IA risk.
    We’ll discuss and design two different ways to trigger manual review: random sampling
    and thresholding.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二部分*描述了围绕ML预测的BP解决方案设计元素。虽然这里的设计概念是通用的，可以与任何RPA工具一起使用，但它们在BP中得到了展示。在[*第4章*](B18416_04.xhtml#_idTextAnchor062)中，我们将介绍将回顾ML预测作为管理IA风险的方法。我们将讨论并设计两种触发人工审查的不同方式：随机抽样和阈值。'
- en: '[*Chapter 5*](B18416_05.xhtml#_idTextAnchor075) examines different ways to
    design an IA solution by varying the number of BP processes and work queues. Changing
    the number of processes and work queues affects the auditability and scalability
    of an IA solution. With this larger solution structure in place, [*Chapter 6*](B18416_06.xhtml#_idTextAnchor093)
    discusses some smaller, reusable elements that can be used across all of the different
    designs.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第5章*](B18416_05.xhtml#_idTextAnchor075)探讨了通过改变BP流程和工作队列的数量来设计IA解决方案的不同方法。改变流程和工作队列的数量会影响IA解决方案的可审计性和可扩展性。在建立这个更大的解决方案结构后，[*第6章*](B18416_06.xhtml#_idTextAnchor093)讨论了一些较小、可重用的元素，这些元素可以用于所有不同的设计。'
- en: Finally, [*Chapter 7*](B18416_07.xhtml#_idTextAnchor114) consolidates the work
    in this part of the book into reusable IA process templates and an IA VBO that
    can be used as a starting point for your IA solution designs and development.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[*第7章*](B18416_07.xhtml#_idTextAnchor114)将本书这一部分的工作整合成可重用的IA流程模板和一个IA VBO，这些模板可以作为您IA解决方案设计和开发的起点。
- en: 'This part contains the following chapters:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B18416_04.xhtml#_idTextAnchor062), *Reviewing Predictions and
    Human in the Loop*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B18416_04.xhtml#_idTextAnchor062)，*回顾预测和人工参与*'
- en: '[*Chapter 5*](B18416_05.xhtml#_idTextAnchor075), *IA Process and Work Queue
    Designs for HITL*'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18416_05.xhtml#_idTextAnchor075)，*HITL的IA流程和工作队列设计*'
- en: '[*Chapter 6*](B18416_06.xhtml#_idTextAnchor093), *Reusable IA Components*'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18416_06.xhtml#_idTextAnchor093)，*可重用IA组件*'
- en: '[*Chapter 7*](B18416_07.xhtml#_idTextAnchor114), *IA Templates and Utility
    – IA Object*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18416_07.xhtml#_idTextAnchor114)，*IA模板和工具 – IA对象*'
