- en: Chapter 6. Understanding Text
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。理解文本
- en: The previous chapter covered the speech APIs. Throughout this chapter, we will
    look closer at more language APIs. We will learn how to use spellcheck features.
    We will then discover how to detect languages, key phrases, and sentiment in text.
    Finally, we will look at the translator text API to see how we can detect languages
    and translate text.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了语音API。在本章中，我们将更深入地探讨更多的语言API。我们将学习如何使用拼写检查功能。然后，我们将发现如何检测文本中的语言、关键词和情感。最后，我们将查看翻译文本API，看看我们如何检测语言并翻译文本。
- en: 'By the end of this chapter, we will have covered the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将涵盖以下主题：
- en: Checking spelling and recognizing slang and informal language, common names,
    homonyms, and brands
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查拼写和识别俚语和非正式语言、常见名称、同音异义词和品牌
- en: Detecting language, key phrases, and sentiment in text
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本中检测语言、关键词和情感
- en: Translating text on the fly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线翻译文本
- en: Setting up a common core
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置公共核心
- en: Before we get into the details, we want to set ourselves up for success. At
    the time of writing, none of the language APIs that we will be covering have NuGet
    client packages. As such, we will need to call directly to the REST endpoints.
    Because of this, we will do some work beforehand to make sure that we get away
    with writing less code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解细节之前，我们希望为自己设定成功的基础。在撰写本文时，我们将要涵盖的所有语言API都没有NuGet客户端包。因此，我们需要直接调用REST端点。正因为如此，我们将在事先做一些工作，以确保我们能够通过编写更少的代码来完成。
- en: New project
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新项目
- en: 'We will not be adding the APIs to our smart-house application. Using the following
    steps, create a new project using the MVVM template that we created in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Microsoft Cognitive Services"),
    *Getting Started with Microsoft Cognitive Services*:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将API添加到我们的智能家居应用程序中。按照以下步骤，使用我们在[第1章](ch01.html "第1章. 使用Microsoft认知服务入门")中创建的MVVM模板创建一个新项目，*使用Microsoft认知服务入门*：
- en: Go into the NuGet package manager and install `Newtonsoft.Json`. This will help
    us deserialize API responses and serialize request bodies.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入NuGet包管理器并安装`Newtonsoft.Json`。这将帮助我们反序列化API响应并序列化请求体。
- en: Right-click on **References**.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**引用**。
- en: In the **Assemblies** tab, select **System.Web** and **System.Runtime.Serialization**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**程序集**选项卡中，选择**System.Web**和**System.Runtime.Serialization**。
- en: Click **OK**.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: In the `MainView.xaml` file, add a `TabControl` element. All our additional
    views will be added as `TabItems` in the `MainView`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainView.xaml`文件中，添加一个`TabControl`元素。我们所有的附加视图都将作为`TabItems`添加到`MainView`中。
- en: Web requests
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络请求
- en: All the APIs follow the same pattern. They call on their respective endpoints
    using either `POST` or `GET` requests. Further on, they pass on parameters as
    query strings, and some as request bodies. Since they have these similarities,
    we can create one class that will handle all API requests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有API都遵循相同的模式。它们使用`POST`或`GET`请求调用各自的端点。进一步来说，它们将参数作为查询字符串传递，并将一些作为请求体。由于它们有这些相似之处，我们可以创建一个类来处理所有API请求。
- en: In the `Model` folder, add a new class and call it `WebRequest`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Model`文件夹中，添加一个新类，并将其命名为`WebRequest`。
- en: 'We also need a few `private` variables, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些`private`变量，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The constant, `JsonContentTypeHeader`, defines the content type that we want
    to use for all API calls. The `_settings` phrase is a `JsonSerializerSettings`
    object, which specifies how we want JSON data to be (de)serialized.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`JsonContentTypeHeader`定义了我们想要用于所有API调用的内容类型。`_settings`短语是一个`JsonSerializerSettings`对象，它指定了我们想要如何（反）序列化JSON数据。
- en: The `_httpClient` is the object that will be used to make our API requests.
    The last member, `_endpoint`, will hold the API endpoint.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`_httpClient`是我们将用于发出API请求的对象。最后一个成员`_endpoint`将保存API端点。'
- en: 'As shown in the following code, our constructor will accept two parameters:
    one string for the URI, and one string for the API key:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，我们的构造函数将接受两个参数：一个用于URI的字符串和一个用于API密钥的字符串：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We assign the `uri` to the corresponding member. Next, we create a new object
    of a `HttpClient` type and add one request header. This is the header that contains
    the given `apiKey`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`uri`分配给相应的成员。接下来，我们创建一个新的`HttpClient`类型的对象并添加一个请求头。这是包含给定`apiKey`的头。
- en: 'The class will contain one function, `MakeRequest`. This should have the return
    type of `Task<TResponse>`, meaning a type that we specify when calling the function.
    As you can see in the following code, it should accept three parameters: a `HttpMethod`,
    a query `string`, and a `TRequest`, (which is a request body that we specify in
    the call). The function should be asynchronous:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该类将包含一个函数，`MakeRequest`。这个函数应该有`Task<TResponse>`的返回类型，这意味着我们在调用函数时指定的类型。正如你在以下代码中所看到的，它应该接受三个参数：一个`HttpMethod`，一个查询`string`，以及一个`TRequest`（这是我们调用时指定的请求体）。该函数应该是异步的：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding lines show the complete function signature. Note how we do not
    need to specify a request body, as there are some cases where it may be empty.
    We will cover what `TRequest` and `TResponse` may be in a bit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行显示了完整的函数签名。注意我们不需要指定请求体，因为在某些情况下它可能是空的。我们将在稍后讨论`TRequest`和`TResponse`可能是什么。
- en: 'We enter a `try` clause, as shown in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入一个`try`子句，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we create a `url`, consisting of our `_endpoint` and the `queryString`.
    Using this and the specified `method`, we create a `HttpRequestMessage` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`url`，由我们的`_endpoint`和`queryString`组成。使用这个和指定的`method`，我们创建一个`HttpRequestMessage`对象。
- en: If we have a `requestBody`, we add `Content` to the `request` object by serializing
    the `requestBody`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`requestBody`，我们通过序列化`requestBody`将`Content`添加到`request`对象中。
- en: With the request in order, we make an asynchronous call to `SendAsync` on the
    `_httpClient` object. This will call the API endpoint, returning a `HttpResponseMessage`
    containing the response.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求就绪后，我们向`_httpClient`对象上的`SendAsync`进行异步调用。这将调用API端点，返回一个包含响应的`HttpResponseMessage`。
- en: 'If the `response` is successful, we want to get the `Content` as a string.
    This is done as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`response`成功，我们希望将`Content`作为字符串获取。这可以通过以下方式完成：
- en: Make an asynchronous call to `ReadAsStringAsync`. This will return a string.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行异步调用到`ReadAsStringAsync`。这将返回一个字符串。
- en: Deserialize the string as a `TResponse` object.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串反序列化为`TResponse`对象。
- en: Return the deserialized object to the caller.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将反序列化的对象返回给调用者。
- en: 'In the case that there is no data in `responseContent`, we return a default
    `TResponse`. This will contain default values for all properties, as shown in
    the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`responseContent`中没有数据，我们返回一个默认的`TResponse`。这将包含所有属性的所有默认值，如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the API response contains any error code, then we try to get the error message
    as a string (`errorObjectString`). In a typical application, you would want to
    deserialize this and propagate it to the user. However, as this is a simple example
    application, we will choose to output it to the `Debug` console window, as shown
    in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API响应包含任何错误代码，那么我们尝试将错误消息作为字符串（`errorObjectString`）获取。在典型应用程序中，你可能会想要反序列化它并将其传播给用户。然而，由于这是一个简单的示例应用程序，我们将选择将其输出到以下代码所示的`Debug`控制台窗口：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure you add the corresponding `catch` clause and output any exceptions
    to the `Debug` console window. Also, make sure that you return a default `TResponse`
    if any exceptions occur.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你添加相应的`catch`子句，并将任何异常输出到`Debug`控制台窗口。同时，确保在发生任何异常时返回默认的`TResponse`。
- en: Data contracts
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据契约
- en: As we need to (de)serialize JSON data as a part of the requests and responses
    to the APIs, we need to create data contracts. These will act as the `TResponse`
    and `TRequest` objects, used in the `WebRequest` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要将JSON数据序列化和反序列化作为API请求和响应的一部分，我们需要创建数据契约。这些将作为`TResponse`和`TRequest`对象，用于`WebRequest`类。
- en: 'Add a new folder called `Contracts` to the project. A typical data contract
    may look like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中添加一个名为`Contracts`的新文件夹。一个典型的数据契约可能看起来像以下这样：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This correlates to errors in the text analytics API. As you can see, it has
    two string properties for `id` and `message`. Both may appear in an API response.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这与文本分析API中的错误相对应。正如你所看到的，它有两个字符串属性`id`和`message`。两者都可能出现在API响应中。
- en: When discussing each API, we will see all request and response parameters in
    either table form or JSON format. We will not look at how each of these translates
    into a data contract, but it will take a similar form to that previously shown.
    It is then up to you to create the contracts needed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论每个API时，我们将以表格形式或JSON格式显示所有请求和响应参数。我们不会查看这些如何转换为数据契约，但它们将采用与之前所示类似的形式。然后取决于你创建所需的契约。
- en: The most important thing to note is that the property names must be identical
    to the corresponding JSON property.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的最重要的一点是属性名称必须与相应的JSON属性完全相同。
- en: Make sure that the code compiles and that you can run the application before
    continuing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保代码可以编译并且你可以运行应用程序。
- en: Correcting spelling errors
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纠正拼写错误
- en: The Bing Spell Check API leverages the power of machine learning and statistical
    machine translation to train and evolve a highly contextual algorithm for spellchecking.
    Doing so allows us to utilize this to perform spellchecking using context.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Bing拼写检查API利用机器学习和统计机器翻译的力量来训练和进化一个高度上下文化的拼写检查算法。这样做允许我们利用上下文来进行拼写检查。
- en: A typical spellchecker will follow dictionary-based rule sets. As you can imagine,
    this will need continuous updates and expansions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的拼写检查器将遵循基于字典的规则集。正如你可以想象的那样，这将需要不断的更新和扩展。
- en: Using the Bing Spell Check API, we can recognize and correct slang and informal
    language. It can recognize common naming errors and correct word-breaking issues.
    It can detect and correct words that sound the same, but differ in meaning and
    spelling (homophones). It can also detect and correct brands and popular expressions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bing拼写检查API，我们可以识别和纠正俚语和非正式语言。它可以识别常见的命名错误并纠正单词拆分问题。它可以检测并纠正发音相同但意义和拼写不同的单词（同音异义词）。它还可以检测并纠正品牌和流行表达。
- en: Create a new `View` in the `View` folder; call the file `SpellCheckView.xaml`.
    Add a `TextBox` element for the input query. We will also need two `TextBox` elements
    for the pre- and post-context. Add a `TextBox` element to show the result and
    a `Button` element to execute the spellcheck.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`View`文件夹中创建一个新的`View`；调用文件`SpellCheckView.xaml`。添加一个`TextBox`元素用于输入查询。我们还需要两个`TextBox`元素用于前文和后文。添加一个`TextBox`元素来显示结果和一个`Button`元素来执行拼写检查。
- en: 'Add a new `ViewModel` in the folder named `ViewModel`; call the file `SpellCheckViewModel.cs`.
    Make the class `public`, and let it inherit from the `ObservableObject` class.
    Add the following `private` member:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为`ViewModel`的文件夹中添加一个新的`ViewModel`；调用文件`SpellCheckViewModel.cs`。将类设置为`public`，并让它继承自`ObservableObject`类。添加以下`private`成员：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the `WebRequest` class that we created earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前创建的`WebRequest`类。
- en: We need properties corresponding to our `View`. This means that we need four
    `string` properties and one `ICommand` property.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要与我们的`View`对应的属性。这意味着我们需要四个`string`属性和一个`ICommand`属性。
- en: If you have not already done so, register for a free API key at [https://portal.azure.com](https://portal.azure.com).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请前往[https://portal.azure.com](https://portal.azure.com)注册一个免费的API密钥。
- en: 'The constructor should look like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数应如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We create a new object of a `WebRequest` type, specifying the Bing Spell Check
    API endpoint and the API key. We also create a new `DelegateCommand` for our `ExecuteOperationCommand`,
    `ICommand`, property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`WebRequest`类型的对象，指定Bing拼写检查API端点和API密钥。我们还需要为我们的`ExecuteOperationCommand`属性创建一个新的`DelegateCommand`。
- en: The `CanExecuteOperation` property should return `true` if our input query is
    filled in and `false` otherwise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanExecuteOperation`属性应该在输入查询填写时返回`true`，否则返回`false`。'
- en: 'To execute a call to the API, we do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行对API的调用，我们执行以下操作：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we create a `queryString` using `HttpUtility`. This will format the string
    so that it can be used in a URI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`HttpUtility`创建一个`queryString`。这将格式化字符串，使其可以在URI中使用。
- en: As we will be calling the API using a `GET` method, we need to specify all parameters
    in the string. The required parameters are `text` and `mkt`, which are the input
    query and language, respectively. If we have entered `PreContext` and/or `PostContext`,
    then we add these parameters as well. We will look at the different parameters
    in more detail in a bit.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用`GET`方法调用API，我们需要在字符串中指定所有参数。所需的参数是`text`和`mkt`，分别是输入查询和语言。如果我们已经输入了`PreContext`和/或`PostContext`，那么我们也添加这些参数。我们将在稍后更详细地查看不同的参数。
- en: 'To make the request, we need to make the following call:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要发出请求，我们需要进行以下调用：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We call `MakeRequest` on the `_webRequest` object. As we are making a `GET`
    request, we do not need any request body, and we pass on `object` as `TRequest`.
    We expect a `SpellCheckResponse` contract in return. This will contain the resultant
    data, and we will look at the parameters in greater detail in a bit.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`_webRequest`对象上调用`MakeRequest`。由于我们正在执行`GET`请求，我们不需要任何请求体，并将`object`作为`TRequest`传递。我们期望返回一个`SpellCheckResponse`合约。这将包含结果数据，我们将在稍后更详细地查看参数。
- en: 'When we have a response, we pass that on to a function to parse it, as shown
    in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们得到响应时，我们将它传递给一个函数来解析，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we do not have any response, we exit the function. Otherwise, we create
    a `StringBuilder` to format the results, as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有收到任何响应，我们将退出函数。否则，我们将创建一个`StringBuilder`来格式化结果，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we have any corrected spellings, we loop through them. We add all suggestions
    to the `StringBuilder`, making sure that we add the likelihood of the suggestion
    being correct. At the end, we make sure that we output the result to the UI.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有任何更正的拼写，我们将遍历它们。我们将所有建议添加到`StringBuilder`中，确保我们添加了建议正确性的可能性。最后，我们确保将结果输出到UI。
- en: 'The following table describes all the parameters we can add to the API call:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了我们可以添加到API调用中的所有参数：
- en: '| Parameter | Description |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `text` | The text that we want to check for spelling and grammar errors.
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `text` | 我们想要检查拼写和语法错误的文本。 |'
- en: '| `mode` | The current mode of the spellcheck. It can be either of the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '| `mode` | 当前拼写检查的模式。可以是以下之一：'
- en: '**Proof**: Spelling corrections for long queries, as typically used in MS Word.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**校对**：用于长查询的拼写更正，通常用于MS Word。'
- en: '**Spell**: Used for search engine corrections. Can be used for queries up to
    nine words long (tokens).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拼写**：用于搜索引擎更正。可用于长度最多九个单词（标记）的查询。'
- en: '|'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `preContextText` | The string that gives context to the text. The petal parameter
    is valid, but if you specify bike in this parameter, it will be corrected to pedal.
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `preContextText` | 为文本提供上下文的字符串。petal参数是有效的，但如果在此参数中指定bike，它将被更正为pedal。 |'
- en: '| `postContextText` | The string that gives context to the text. The read parameter
    is valid, but if you specify carpet in this parameter, it may be corrected to
    red. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `postContextText` | 为文本提供上下文的字符串。read参数是有效的，但如果在此参数中指定carpet，它可能被更正为red。
    |'
- en: '| `mkt` | For proof mode, the language must be specified. It can currently
    be en-us, es-es, or pt-br. For spell mode, all language codes are supported. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `mkt` | 对于校对模式，必须指定语言。目前可以是en-us、es-es或pt-br。对于拼写模式，支持所有语言代码。 |'
- en: 'A successful response will be a JSON response, containing the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的响应将是一个包含以下内容的JSON响应：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `offset` is where the word appears in the text and `token` is the word that
    contains the error, while `type` describes the type of error. The `suggestions`
    phrase contains an array with the suggested correction and the probability of
    it being correct.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`offset`是单词在文本中的位置，`token`是包含错误的单词，而`type`描述了错误的类型。`suggestions`短语包含一个包含建议更正及其正确性的概率的数组。'
- en: When the `View` and `ViewModel` have been correctly initialized, as seen in
    previous chapters, we should be able to compile and run the example.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当`View`和`ViewModel`已经正确初始化，如前几章所示，我们应该能够编译并运行示例。
- en: 'An example output of running a spellcheck may give the following result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行拼写检查的示例输出可能给出以下结果：
- en: '![Correcting spelling errors](img/B12373_06_01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![纠正拼写错误](img/B12373_06_01.jpg)'
- en: Extracting information through textual analysis
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过文本分析提取信息
- en: Using the **text analytics** API, we are able to analyze text. We will cover
    language detection, key-phrase analysis, and sentiment analysis. In addition,
    a new feature is the ability to detect topics. This does, however, require a lot
    of sample text, and as such, we will not go into detail on this last feature.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**文本分析**API，我们能够分析文本。我们将涵盖语言检测、关键短语分析和情感分析。此外，还有一个新功能是检测主题的能力。然而，这确实需要大量的样本文本，因此我们不会详细介绍这个最后的功能。
- en: For all our text-analysis tasks, we will be using a new `View`. Add a new `View`
    into the `View` folder called `TextAnalysisView.xaml`. This should contain a `TextBox`
    element for the input query. It should also have a `TextBox` element for the result.
    We will need three `Button` elements, one for each detection analysis that we
    will perform.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们所有的文本分析任务，我们将使用一个新的`View`。在`View`文件夹中添加一个新的`View`，命名为`TextAnalysisView.xaml`。这应该包含一个用于输入查询的`TextBox`元素。它还应该有一个用于结果的`TextBox`元素。我们需要三个`Button`元素，每个用于我们将执行的一种检测分析。
- en: We will also need a new `ViewModel`, so add `TextAnalysisViewModel.cs` to the
    `ViewModel` folder. In this, we need two `string` properties, one for each `TextBox`.
    Also add three `ICommand` properties, one for each of our buttons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个新的`ViewModel`，因此将`TextAnalysisViewModel.cs`添加到`ViewModel`文件夹。在这里，我们需要两个`string`属性，每个`TextBox`一个。还要添加三个`ICommand`属性，每个按钮一个。
- en: If you have not already done so, register for an API key at [https://portal.azure.com](https://portal.azure.com).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请前往[https://portal.azure.com](https://portal.azure.com)注册API密钥。
- en: 'Add a `private` member called `_webRequest` of a `WebRequest` type. With that
    in place, we can create our constructor, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为`WebRequest`类型添加一个名为`_webRequest`的`private`成员。有了这个，我们就可以创建构造函数，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The constructor creates a new `WebRequest` object, specifying the API endpoint
    and API key. We then go on to create the `DelegateCommand` objects for our `ICommand`
    properties. The `CanExecuteOperation` function should return `true` if we have
    entered the input query and `false` otherwise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数创建一个新的`WebRequest`对象，指定API端点和API密钥。然后我们继续为我们的`ICommand`属性创建`DelegateCommand`对象。`CanExecuteOperation`函数应该在我们输入查询时返回`true`，否则返回`false`。
- en: Detecting language
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测语言
- en: The API can detect which language is used in text from over 120 different languages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该API可以检测超过120种不同语言中的文本所使用的语言。
- en: 'This is a `POST` call, so we need to send in a request body. A request body
    should consist of `documents`. This is basically an array containing a unique
    `id` for each `text`. It also needs to contain the text itself, as shown in the
    following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`POST`调用，因此我们需要发送请求体。请求体应包含`documents`。这基本上是一个包含每个`text`的唯一`id`的数组。它还需要包含文本本身，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create a `queryString` specifying the REST endpoint that we want to reach.
    Then we go on to create a `TextRequest` contract, which contains documents. As
    we only want to check one piece of text, we add one `TextDocumentRequest` contract,
    specifying an `id` and the `text`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`queryString`，指定我们想要到达的REST端点。然后我们继续创建一个包含文档的`TextRequest`合约。因为我们只想检查一段文本，所以我们添加一个`TextDocumentRequest`合约，指定一个`id`和文本。
- en: When the request is created, we call `MakeRequest`. We expect the response to
    be of a `TextResponse` type and the request body to be of a `TextRequests` type.
    We pass along `POST` as the call method, the `queryString`, and the `request`
    body.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求被创建时，我们调用`MakeRequest`。我们期望响应为`TextResponse`类型，请求体为`TextRequests`类型。我们传递`POST`作为调用方法、`queryString`和请求体。
- en: 'If the response is successful, then we loop through the `detectedLanguages`.
    We add the languages to a `StringBuilder`, also outputting the probability of
    that language being correct. This is then displayed in the UI, as shown in the
    following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应成功，那么我们将遍历`detectedLanguages`。我们将语言添加到`StringBuilder`中，同时也输出该语言正确性的概率。然后这将在UI中显示，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A successful response will contain the following JSON:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的响应将包含以下JSON：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This contains an array of `documents` `-`, as many as were provided in the request.
    Each document will be marked with a unique `id` and contain an array of `detectedLanguage`
    instances. These languages will have the `name`, `iso6391Name`, and the probability
    (`score`) of being correct.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含一个`documents`数组`-`，与请求中提供的数量一样。每个文档将标记一个唯一的`id`并包含一个`detectedLanguage`实例的数组。这些语言将具有`name`、`iso6391Name`和正确性的概率（`score`）。
- en: If any errors occur for any document, we will get an array of `errors`. Each
    error will contain the `id` of the document where the error occurred and the `message`
    as a string.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何文档发生错误，我们将得到一个包含`errors`的数组。每个错误将包含发生错误的文档的`id`和作为字符串的`message`。
- en: 'A successful call will create a result similar to the one shown in the following
    screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用将创建一个类似于以下截图的结果：
- en: '![Detecting language](img/B12373_06_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![检测语言](img/B12373_06_02.jpg)'
- en: Extracting key phrases from text
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文本中提取关键短语
- en: Extracting key phrases from text may be useful if we want our application to
    know key talking points. Using this, we can learn what people are discussing in
    articles, discussions, or other such sources of text.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本中提取关键短语可能对我们想要让我们的应用程序知道关键谈话点很有用。使用这个，我们可以了解人们在文章、讨论或其他此类文本来源中讨论的内容。
- en: This call also uses the `POST` method, which requires a request body. As with
    language detection, we need to specify documents. Each document will need a unique
    ID, the text, and the language used. At the time of writing, English, German,
    Spanish, and Japanese are the only languages that are supported.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用也使用`POST`方法，这需要一个请求体。与语言检测一样，我们需要指定文档。每个文档都需要一个唯一的ID、文本和使用的语言。在撰写本文时，仅支持英语、德语、西班牙语和日语。
- en: 'To extract key phrases, we use the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取关键短语，我们使用以下代码：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, it is quite similar to detecting languages. We create a `queryString`
    using `keyPhrases` as the REST endpoint. We create a request object of the `TextRequests`
    type. We add the documents list, creating one new `TextDocumentRequest`. Again,
    we need the `id` and `text`, but we have also added a `language` tag, as shown
    in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它与检测语言非常相似。我们使用`keyPhrases`作为REST端点创建一个`queryString`。我们创建一个`TextRequests`类型的请求对象。我们添加文档列表，创建一个新的`TextDocumentRequest`。我们再次需要`id`和`text`，但我们还添加了一个`language`标签，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the response contains any key phrases then we loop through them and output
    them to the UI. A successful response will provide the following JSON:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应包含任何关键短语，我们将遍历它们并将它们输出到UI。一个成功的响应将提供以下JSON：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we have an array of `documents`. Each document has a unique `id`, corresponding
    to the ID in the request. Each document also contains an array of strings, with
    `keyPhrases`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`documents`数组。每个文档都有一个唯一的`id`，对应于请求中的ID。每个文档还包含一个字符串数组，包含`keyPhrases`。
- en: As with language detection, any errors will be returned as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与语言检测一样，任何错误都会被返回。
- en: Learning whether a text is positive or negative
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习判断文本是正面还是负面
- en: Using sentiment analysis, we can detect whether or not a text is positive. If
    you have a merchandise website where users can submit feedback, this feature can
    automatically analyze whether the feedback is generally positive or negative.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用情感分析，我们可以检测文本是否为正面。如果你有一个用户可以提交反馈的商品网站，这个功能可以自动分析反馈是否通常是正面或负面。
- en: The sentiment scores are returned as a number between 0 and 1, where a high
    number indicates a positive sentiment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 情感分数以0到1之间的数字返回，高数值表示正面情感。
- en: 'As with the previous two analyses, this is a `POST` call, requiring a request
    body. Again, we need to specify the documents, and each document requires a unique
    ID, the text, and the language, as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两次分析一样，这是一个`POST`调用，需要请求体。同样，我们需要指定文档，每个文档都需要一个唯一的ID、文本和语言，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We create a `queryString` pointing to `sentiment` as the REST endpoint. The
    data contract is `TextRequests`, containing `documents`. The document we pass
    on has a unique `id`, the text, and the language:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个指向`sentiment`作为REST端点的`queryString`。数据合约是`TextRequests`，包含`documents`。我们传递的文档有一个唯一的`id`，文本和语言：
- en: A call to `MakeRequest` will require a request body of a `TextSentimentRequests`
    type, and we expect the result to be of a `TextSentimentResponse` type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`MakeRequest`将需要一个`TextSentimentRequests`类型的请求体，我们期望结果为`TextSentimentResponse`类型。
- en: 'If the response contains any `documents`, we loop through them. For each document,
    we check the `score`, and output whether or not the text is positive or negative.
    This is then shown in the UI, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应包含任何`documents`，我们将遍历它们。对于每个文档，我们检查`score`，并输出文本是正面还是负面。然后这将在UI中显示，如下所示：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A successful response will result in the following JSON:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的响应将导致以下JSON：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is an array of `documents`. Each document will have a corresponding `id`
    as the request and the sentiment `score`. If any `errors` have occurred, they
    will be entered as we saw in the language and key-phrase detection sections.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`documents`数组。每个文档将有一个与请求中ID相对应的`id`，以及情感`score`。如果发生了任何`errors`，它们将像我们在语言和关键短语检测部分看到的那样被记录。
- en: 'A successful test can look like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的测试可能看起来像以下这样：
- en: '![Learning whether a text is positive or negative](img/B12373_06_03.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![学习判断文本是正面还是负面](img/B12373_06_03.jpg)'
- en: Translating text on the fly
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时翻译文本
- en: Using the translator text API, you can easily add translations to your application.
    The API allows you to automatically detect the language. This can be used to serve
    localized content, or to quickly translate content. It also allows us to look
    up alternative translations that can be used to translate words into different
    contexts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用翻译文本API，你可以轻松地将翻译添加到你的应用程序中。该API允许你自动检测语言。这可以用来提供本地化内容，或快速翻译内容。它还允许我们查找可以用于在不同上下文中翻译单词的替代翻译。
- en: In addition, the translator text API can be used to build customized translation
    systems. This means that you can improve the existing models. This can be done
    by adding existing human translations related to expressions and vocabulary in
    your industry.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，翻译文本API可以用来构建定制的翻译系统。这意味着你可以改进现有的模型。这可以通过添加与你的行业中的表达和词汇相关的人类翻译来实现。
- en: 'The translator text API is available as a REST API. We will cover the four
    endpoints that you can reach. To use the API, the following root URL should be
    used:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译文本 API 作为 REST API 提供。我们将介绍你可以到达的四个端点。要使用该 API，应使用以下根 URL：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Sign up for an API key at Microsoft Azure Portal.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Microsoft Azure 门户上注册 API 密钥。
- en: Translating text
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译文本
- en: 'To translate text from one language to another, you should call the following
    URL path:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本从一种语言翻译成另一种语言，你应该调用以下 URL 路径：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following parameters must be specified:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指定以下参数：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This parameter can be specified multiple times.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数可以指定多次。
- en: The request body must contain the text that is to be translated.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体必须包含要翻译的文本。
- en: 'A successful call will result in the following JSON output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用将产生以下 JSON 输出：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Converting text script
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换文本脚本
- en: 'To translate text from one language script (such as Arabic) to another (such
    as Latin), you should call the following URL path:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一种语言脚本（如阿拉伯语）翻译成另一种语言脚本（如拉丁语），你应该调用以下 URL 路径：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following parameters must be specified:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指定以下参数：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The request body must contain the text that is to be translated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体必须包含要翻译的文本。
- en: 'A successful call will result in the following JSON output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用将产生以下 JSON 输出：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Working with languages
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与语言一起工作
- en: There are two paths that you can use when working with languages. The first
    one is used to detect language in a specific text. The second one is used to get
    a list of languages supported by the other APIs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理语言时，你可以使用两个路径。第一个路径用于检测特定文本中的语言。第二个路径用于获取其他 API 支持的语言列表。
- en: Detecting the language
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别语言
- en: 'To detect the language that a certain text uses, you should call the following
    URL path:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测特定文本使用的语言，你应该调用以下 URL 路径：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The request body must contain the text that is to be translated. No parameters
    are needed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体必须包含要翻译的文本。不需要任何参数。
- en: 'A successful call will result in the following JSON output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用将产生以下 JSON 输出：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Getting supported languages
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取支持的语言
- en: 'To get a list of supported languages, you should call the following URL path:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取支持的语言列表，你应该调用以下 URL 路径：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: No parameters or body are required for this call.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用不需要任何参数或请求体。
- en: 'A successful call will result in the following JSON output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用将产生以下 JSON 输出：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the two-letter country code is the key for each entry. You can
    also find the four-letter code for each transliterate language. This API path
    can be used as a basis for the other API paths.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，两字母国家代码是每个条目的关键。你还可以找到每个转写语言的四字母代码。此 API 路径可以用作其他 API 路径的基础。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have focused on the language APIs. We started by creating
    the parts that are needed to execute the API calls to the different services.
    Following this, we looked at the Bing Spell Check API. We moved on to more analytical
    APIs, where we learned how to detect languages, key phrases, and sentiment. Finally,
    we looked into how we can use the translator text API.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于语言 API。我们首先创建了执行对不同服务 API 调用的所需部分。随后，我们查看了 Bing 拼写检查 API。然后，我们转向更分析的
    API，学习了如何检测语言、关键词和情感。最后，我们探讨了如何使用翻译文本 API。
- en: The next chapter will take us from language APIs to knowledge APIs. In the following
    chapter, we will learn how to recognize and identify entities based on context.
    In addition, we will learn how to use the recommendations API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带我们从语言 API 到知识 API。在接下来的章节中，我们将学习如何根据上下文识别和识别实体。此外，我们还将学习如何使用推荐 API。
