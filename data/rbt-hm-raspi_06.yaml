- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Measuring Movement with Encoders on Raspberry Pi Pico
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Raspberry Pi Pico上使用编码器测量运动
- en: Robots don’t just run code blindly; they need sensors. What sensors do we add
    first? Our robot already has some sensors on board, and in this chapter, we’ll
    see how to use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人不会盲目地运行代码；它们需要传感器。我们首先添加哪些传感器？我们的机器人已经有一些传感器，在本章中，我们将了解如何使用它们。
- en: We finished the previous chapter noticing that timing isn’t the most accurate
    way to determine robot movement. So, let’s see how our first sensor, encoders,
    can improve this. Encoders are the first step in getting accurate movement and
    location estimation in robots. We will also learn one of Raspberry Pi Pico’s excellent
    features – **Programmable** **IO** (**PIO**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成上一章时，我们注意到时间并不是确定机器人运动最准确的方法。那么，让我们看看我们的第一个传感器——编码器，如何改进这一点。编码器是获取机器人精确运动和位置估计的第一步。我们还将学习Raspberry
    Pi Pico的一个优秀特性——**可编程** **IO** (**PIO**)。
- en: We’ll dig into movement fundamentals, odometry and encoding, look at Raspberry
    Pi Pico PIO in CircuitPython, and use this to get data from the encoders on our
    robot.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入研究运动基础、里程计和编码，查看CircuitPython中的Raspberry Pi Pico PIO，并使用它从我们的机器人上的编码器获取数据。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: About encoders and odometry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于编码器和里程计
- en: Wiring in encoders on a Raspberry Pi Pico robot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Raspberry Pi Pico机器人上编码器布线
- en: Programming Raspberry Pi Pico PIO
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程Raspberry Pi Pico PIO
- en: Measuring encoder count for movement
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量编码器计数以确定运动
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下内容：
- en: First is the built robot, as made in the previous chapters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是之前章节中构建的机器人
- en: 6 x fresh AA batteries
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6节新的AA电池
- en: A PC or laptop with a USB micro cable
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台带有USB微型电缆的PC或笔记本电脑
- en: Mu software to write our code and upload it
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mu软件编写我们的代码并将其上传
- en: Clear floor space with a meter or so in each direction to test the robot
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个方向上留出大约一米的空旷地面以测试机器人
- en: All code examples are on GitHub at https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-06.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例均可在GitHub上找到：https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-06.
- en: About encoders and odometry
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于编码器和里程计
- en: '**Odometry** is measuring how a position has changed over time. We can combine
    measuring and estimation to determine where you are on a route. **An encoder**
    is a sensor designed to measure distance traveled via wheel turns. They are like
    **tachometers**, but encoders measure position whereas tachometers measure only
    speed. Combined with time, they can make a speed measurement too.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**里程计**是测量位置随时间变化的方法。我们可以结合测量和估计来确定你在路线上的位置。**编码器**是一种设计用来测量通过轮子转动所行驶距离的传感器。它们类似于**转速表**，但编码器测量位置，而转速表只测量速度。结合时间，它们也可以进行速度测量。'
- en: Absolute and relative sensing
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绝对和相对传感
- en: 'Sensors for a robot’s location come in two primary forms. They are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人位置传感器主要有两种形式。具体如下：
- en: '**Absolute sensors** encode a position to a repeatable position. They have
    a limited range or resolution, such as encoding a position along a known line.
    For example, GPS sensors have exact positioning with low resolution, suitable
    for meters but not millimeters.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对传感器**将位置编码为可重复的位置。它们有一个有限的范围或分辨率，例如在已知线上编码位置。例如，GPS传感器具有精确的位置定位和低分辨率，适用于米而不是毫米。'
- en: '**Relative sensors** tend to be cheaper. However, they produce a relative change
    in position, which needs to be combined with the previous state to get an absolute
    estimate – this means that errors can accumulate. Relative encoders are one example
    of relative sensors, also known as **incremental encoders**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对传感器**通常更便宜。然而，它们产生的是相对位置变化，需要结合之前的状态来获得绝对估计——这意味着误差可能会累积。相对编码器是相对传感器的一个例子，也称为**增量编码器**。'
- en: If a sensor tells you where something is *at*, it is absolute. It is relative
    if it tells you how much something has moved *by*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个传感器告诉你某个东西在哪里**是**，那么它是绝对的。如果它告诉你某个东西移动了多少**由**，那么它是相对的。
- en: Types of encoders
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码器的类型
- en: Most encoder designs work by passing markers or code over a sensor that counts
    or decodes the pulses.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编码器设计是通过在传感器上传递标记或代码来计数或解码脉冲来工作的。
- en: 'Encoders come in a few forms. Some example types are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编码器有多种形式。以下是一些示例类型：
- en: A potentiometer or **variable resistor** can sense an absolute encoder position
    by measuring resistance. Servo motors use them. However, potentiometers are not
    suitable for continuous rotations such as wheels, as their track lengths limit
    them. In addition, regular movement wears them down, as they move contacts across
    each other.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测量电阻，电位计或**可变电阻**可以感知绝对编码器的位置。伺服电机使用它们。然而，电位计不适合连续旋转，如车轮，因为它们的轨迹长度限制了它们。此外，常规运动会使它们磨损，因为它们在相互之间移动触点。
- en: '**Mechanical encoders** pass electrical contacts over each other, producing
    on and off pulses. They are subject to heavy wear, so I do not recommend them.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机械编码器**通过相互传递电触点，产生开和关的脉冲。它们容易磨损，所以我并不推荐使用它们。'
- en: '**Optical encoders** shine a light through a disk or strip with slots and detect
    the passing of slots in front of light sensors. They can come in absolute and
    relative flavors. They can be susceptible to interference from light sources or
    just dirt.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光编码器**通过带有槽的圆盘或条带照射光线，并检测光传感器前通过的槽。它们可以是绝对和相对的。它们可能容易受到光源或灰尘的干扰。'
- en: '**Magnetic encoders** detect the movements of magnets in a disc using **hall-effect
    sensors**. Dirt, light interference, and physical wear do not affect them so much.
    Hall-effect sensors produce a voltage depending on a magnetic field – encoder
    modules produce pulses from this.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁编码器**使用**霍尔效应传感器**检测圆盘中磁铁的运动。灰尘、光干扰和物理磨损对它们的影响不大。霍尔效应传感器根据磁场产生电压 - 编码器模块从这个电压产生脉冲。'
- en: The motors we chose came with rotary magnetic encoders in a convenient and small
    format as part of the package. They are incremental encoders.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的电机作为套餐的一部分，以方便和紧凑的格式提供了旋转磁编码器。它们是增量编码器。
- en: Encoder pulse data
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码器脉冲数据
- en: 'We can better understand encoders by looking at the pulses they output. Relative
    encoders usually output digital pulse chains, 1s and 0s. The simplest form is
    just to count pulse edges by detecting marks passing a sensor, as the following
    diagram shows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察编码器输出的脉冲，我们可以更好地理解编码器。相对编码器通常输出数字脉冲链，1 和 0。最简单的方式就是通过检测传感器通过的标记来计数脉冲边缘，如下面的图所示：
- en: '![Figure 6.1 – Simple pulse encoding ](img/Figure_6.01_B18001.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 简单脉冲编码](img/Figure_6.01_B18001.jpg)'
- en: Figure 6.1 – Simple pulse encoding
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 简单脉冲编码
- en: On the left of *Figure 6**.1* is a disk with a rotation arrow. On the disk are
    four white marks – representing the markers passing a sensor. The black rectangular
    object is the sensor that detects the markers. The sensor produces a value of
    0 when it isn’t detecting a marker and 1 when it is – making a bunch of pulses
    or a stream of binary bits with values of 1 or 0.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 6.1* 的左侧是一个带有旋转箭头的圆盘。圆盘上有四个白色标记，代表通过传感器的标记。黑色矩形物体是检测标记的传感器。当传感器没有检测到标记时，它产生
    0 的值，当检测到标记时，它产生 1 的值，从而产生一系列脉冲或一系列值为 1 或 0 的二进制位。
- en: We can count the pulses to get an idea of far the wheel has turned. We count
    a high pulse as 1 and a low pulse as 0\. We can also count **edges**, the changes
    from 0 to 1 and 1 to 0\. Counting edges gives us eight steps per wheel turn. The
    graph to the right of the following diagram shows these pulses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计数脉冲来了解车轮转动了多远。我们将高脉冲计为 1，低脉冲计为 0。我们还可以计数**边缘**，即从 0 到 1 和从 1 到 0 的变化。计数边缘给我们每个车轮转动八步。以下图的右侧显示了这些脉冲。
- en: 'We are likely to want to increase that sensitivity and detect which direction
    a wheel is going. To do that, we add a second sensor to the same wheel, as the
    following diagram shows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望增加灵敏度并检测车轮的运动方向。为了做到这一点，我们在同一车轮上添加第二个传感器，如下面的图所示：
- en: '![Figure 6.2 – Quadrature pulse encoding ](img/Figure_6.02_B18001.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 正交脉冲编码](img/Figure_6.02_B18001.jpg)'
- en: Figure 6.2 – Quadrature pulse encoding
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 正交脉冲编码
- en: '*Figure 6**.2* adds a second sensor to catch the markers at a slightly different
    time from the first, generating pulses out of phase; this means we have two streams
    of pulses.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.2* 添加了一个第二个传感器，在第一个传感器略微不同的时间捕捉标记，产生不同步的脉冲；这意味着我们有两个脉冲流。'
- en: At the top right is the pulse graph for the first sensor, with the digits we
    had read from times between the pulses added, showing a pulse train of 16 bits
    for the same period.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角是第一个传感器的脉冲图，我们读取的脉冲之间的数字被加在一起，显示了相同周期内的 16 位脉冲序列。
- en: The middle graph shows the additional sensor, with the out-of-phase 16-digit
    pulse train. Below the graphs are the two states combined at each point in time
    as **Gray code**, with 2 bits of information on where we are relative to the last
    position. We have twice as many edges, increasing the sensor resolution and also
    encoding the wheel’s direction. If we reverse the wheel, this sequence will reverse.
    This system is known as **quadrature encoding**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的图表显示了额外的传感器，以及16位脉冲列的相位差。在图表下方，每个时间点上的两个状态以**格雷码**的形式结合，提供了2位信息，表示我们相对于最后位置的位置。我们有了两倍多的边缘，增加了传感器的分辨率，同时也编码了车轮的方向。如果我们反转车轮，这个序列也会反转。这个系统被称为**正交编码**。
- en: Let’s look at the encoders on our robot in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看我们机器人上的编码器。
- en: Wiring in encoders on a Raspberry Pi Pico robot
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Raspberry Pi Pico机器人上布线编码器
- en: Our robot has already got encoders on board, and we have already wired them
    in. We can take a closer look at the motors and how they are wired into Raspberry
    Pi Pico GPIO pins to understand the robot better.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人已经配备了编码器，并且我们已经将它们连接好了。我们可以更仔细地看看电机以及它们是如何连接到Raspberry Pi Pico的GPIO引脚上的，以便更好地了解机器人。
- en: Examining the motors
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查电机
- en: 'We use N20 geared motors with encoders. The following diagram labels the motor
    parts:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用带编码器的N20齿轮电机。以下图表标注了电机部件：
- en: '![Figure 6.3 – The N20 motor parts ](img/Figure_6.03_B18001.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – N20电机部件](img/Figure_6.03_B18001.jpg)'
- en: Figure 6.3 – The N20 motor parts
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – N20电机部件
- en: '*Figure 6**.3* shows a drawing of the motors we have used. Marked on it are
    essential features that affect how we use the encoders. On the left is a magnetic
    disk with markers in it. This disk is attached to the motor’s driveshaft and sensed
    by the encoder sensor board. On the right are the gearbox and the motor output
    shaft.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.3*展示了我们所使用的电机的图纸。上面标记了影响我们使用编码器的一些基本特征。在左边是一个带有标记的磁盘，这个磁盘附着在电机的驱动轴上，并由编码器传感器板检测。在右边是变速箱和电机输出轴。'
- en: The driveshaft goes through the gearbox, so the output shaft will not make the
    same number of rotations as the disk – the gear ratio will determine this relationship.
    So one revolution of the output wheel could count many pulses; this gives us high
    resolution.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动轴穿过变速箱，因此输出轴的旋转次数不会与磁盘相同——齿轮比将决定这种关系。因此，输出轮的一圈可以计数多个脉冲；这为我们提供了高分辨率。
- en: Consult the datasheet for the motors. Some Chinese characters are likely, but
    important numbers are usually in English. You may need translation services built
    into web search engines here. The datasheet and product page have two important
    numbers, the number of encoder counts per disk revolution and the gear ratio.
    The datasheet may note counts per disk revolution as pole count.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请查阅电机的数据表。可能有一些中文字符，但重要数字通常用英文表示。在这里，你可能需要使用内置在网页搜索引擎中的翻译服务。数据表和产品页面有两个重要数字，即每圈磁盘的编码器计数和齿轮比。数据表可能会将每圈磁盘的计数称为极数。
- en: In my case, the gear ratio is 298:1, and the pole count is 14\. Interpreting
    these facts means I get 298 turns of my encoder wheel per output wheel revolution.
    Each encoder turn produces 14 poles on each sensor (two sensors), so we get 28
    edges. Multiplying the number of sensor pulses by the gear ratio gives 8344 edges
    per turn.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，齿轮比是298:1，极数是14。解释这些事实意味着我的编码器轮每转一圈输出轮转298圈。每个编码器转一圈在每个传感器（两个传感器）上产生14个极，因此我们得到28个边缘。将传感器脉冲数乘以齿轮比，得到每转8344个边缘。
- en: Examining the wiring
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查布线
- en: 'We saw the wiring for our robot in *Figure 4**.20* of [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080),
    *Building a Robot around Pico*. However, to better illustrate the encoder connections,
    here is a diagram focusing only on the wiring of encoders to Pico:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B18001_04.xhtml#_idTextAnchor080) *“围绕Pico构建机器人”*的*图4.20*中看到了我们机器人的布线。然而，为了更好地说明编码器的连接，这里有一个只关注编码器连接到Pico的布线图：
- en: '![Figure 6.4 – Encoders wired to Raspberry Pi Pico ](img/Figure_6.04_B18001.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 连接到Raspberry Pi Pico的编码器](img/Figure_6.04_B18001.jpg)'
- en: Figure 6.4 – Encoders wired to Raspberry Pi Pico
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 连接到Raspberry Pi Pico的编码器
- en: The preceding figure takes a closer look at data connections for a robot encoder
    connection schematic. On the left is Raspberry Pi Pico; this has four connections
    from the encoders. These are on GPIO 20, 21, 26, and 27\. Each of these can be
    set as input pins to read the state of the encoder pins.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上一图更详细地检查了机器人编码器连接图的数据连接。在左边是Raspberry Pi Pico；它有来自编码器的四个连接，这些连接在GPIO 20、21、26和27上。这些都可以设置为输入引脚，以读取编码器引脚的状态。
- en: If we were just reading encoders alone, we could write code to check each pin
    in sequence. However, doing this may tie things up. What if we could get components
    of the Pico to monitor these pins and pulse chains for us so that we could just
    read a counter for them when we need it?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是读取编码器，我们可以编写代码按顺序检查每个引脚。然而，这样做可能会使事情变得复杂。如果我们能让 Pico 的组件监控这些引脚和脉冲链，那么我们就可以在需要时只读取计数器，会怎么样呢？
- en: Programming Raspberry Pi Pico PIO
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Raspberry Pi Pico PIO 编程
- en: We saw the PIO system back in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015).
    We could read encoders in Python on the Pico central cores; however, we can make
    monitoring the encoders the responsibility of PIO, letting those central cores
    do other things. The PIO system can read and decode the Gray code emitted by the
    encoders. This section will show how to program PIO in assembler and load the
    programs with CircuitPython.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第一章*](B18001_01.xhtml#_idTextAnchor015)中看到了 PIO 系统。我们可以在 Pico 的中央核心上用 Python
    读取编码器；然而，我们可以让 PIO 负责监控编码器，让这些中央核心去做其他事情。PIO 系统可以读取和解码编码器发出的格雷码。本节将展示如何用汇编语言编程
    PIO 并用 CircuitPython 加载程序。
- en: Introduction to PIO programming
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PIO 编程简介
- en: 'As we saw in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015), Pico has two
    PIO devices, each with four state machines. We program PIO in **assembly language**.
    Instructions command PIO to perform operations such as manipulating IO pins, registers,
    and **first in first out** (**FIFO**) queues. The following diagram is a simplified
    representation of a state machine:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第一章*](B18001_01.xhtml#_idTextAnchor015)中看到的，Pico 有两个 PIO 设备，每个设备有四个状态机。我们用汇编语言编程
    PIO。指令命令 PIO 执行操作，如操作 IO 引脚、寄存器和**先进先出**（**FIFO**）队列。以下图是状态机的简化表示：
- en: '![Figure 6.5 – The Raspberry Pi Pico PIO state machines ](img/Figure_6.05_B18001.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – Raspberry Pi Pico 的 PIO 状态机](img/Figure_6.05_B18001.jpg)'
- en: Figure 6.5 – The Raspberry Pi Pico PIO state machines
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – Raspberry Pi Pico 的 PIO 状态机
- en: The preceding diagram shows Raspberry Pi Pico PIO state machines, highlighting
    registers and other features. It shows the two PIO devices and the state machines
    in them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图显示了 Raspberry Pi Pico 的 PIO 状态机，突出了寄存器和其他功能。它显示了两个 PIO 设备以及它们中的状态机。
- en: 'A **register** is like a variable; they have fixed names, and there are only
    a few per core. PIO registers are 32-bit and specific to each state machine. We
    use an essential subset: **input shift register** (**ISR**), **output shift register**
    (**OSR**), and *X* and *Y* (scratch registers). They can store a number or a binary
    pattern. It is common to refer to 32 bits as **words**.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**寄存器**就像一个变量；它们有固定的名称，每个核心只有几个。PIO 寄存器是 32 位的，并且针对每个状态机是特定的。我们使用一个基本子集：**输入移位寄存器**（**ISR**）、**输出移位寄存器**（**OSR**）和
    *X* 和 *Y*（临时寄存器）。它们可以存储一个数字或二进制模式。通常将 32 位称为**字**。'
- en: Each state machine runs the program independently, so the same code runs four
    times, with independent registers. In addition, mappings (shown as dashed lines)
    connect state machines to IO pins – the tiny rectangles. Code can configure which
    state machines use which pins and a single state machine can read/write from many
    pins.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态机独立运行程序，所以相同的代码运行四次，有独立的寄存器。此外，映射（以虚线表示）将状态机连接到 IO 引脚——那些小矩形。代码可以配置哪些状态机使用哪些引脚，一个状态机可以读取/写入多个引脚。
- en: State machines also have FIFO queues. Data put into a FIFO queue comes out in
    the same order. Each can hold 4 x 32-bit words. These let PIO **transmit** (**TX**)
    data from or **receive** (**RX**) data to other devices within the rest of Pico.
    We can configure FIFO queues in many ways. For this chapter, we will use the RX
    FIFO queue to receive data from PIO to our code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机也有 FIFO 队列。放入 FIFO 队列的数据以相同的顺序出来。每个可以存储 4 x 32 位字。这些允许 PIO 从或向 Pico 内的其他设备**传输**（**TX**）数据或**接收**（**RX**）数据。我们可以以多种方式配置
    FIFO 队列。对于本章，我们将使用 RX FIFO 队列从 PIO 接收数据。
- en: Each PIO block can run an independent program with 32 instructions – each roughly,
    but not quite, a line of code. But how do we write and use these programs?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 PIO 块可以运行一个独立的程序，包含 32 条指令——每条大约相当于一行代码。但我们如何编写和使用这些程序呢？
- en: Introducing PIOASM
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 PIOASM
- en: In CircuitPython, we assemble the PIO code using the Adafruit CircuitPython
    `PIOASM` library. This runs on Pico, taking the assembly code in a string and
    outputting a sequence of bytes with the code in it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CircuitPython 中，我们使用 Adafruit CircuitPython 的 `PIOASM` 库来汇编 PIO 代码。它在 Pico
    上运行，将字符串形式的汇编代码转换为包含代码的字节序列。
- en: 'We need to put this `PIOASM` library onto Raspberry Pi Pico:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这个 `PIOASM` 库安装到 Raspberry Pi Pico 上：
- en: First, find the `CIRCUITPY` volume on your computer.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的计算机上找到 `CIRCUITPY` 卷。
- en: From the Adafruit CircuitPython library (as discussed in [*Chapter 2*](B18001_02.xhtml#_idTextAnchor041)),
    copy `lib/adafruit_pioasm.mpy` into the `lib` folder on `CIRCUITPY`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Adafruit CircuitPython 库（如第 [*2章*](B18001_02.xhtml#_idTextAnchor041) 中讨论的），将
    `lib/adafruit_pioasm.mpy` 复制到 `CIRCUITPY` 上的 `lib` 文件夹中。
- en: 'With that in place, we can write our first PIO-based program. Here’s `pio_led_test.py`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以编写第一个基于 PIO 的程序。这是 `pio_led_test.py`：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first four lines are imports. You’ve seen `time` and `board` before. The
    `rp2pio` library lets us communicate with the PIO blocks and start code and interact
    with state machines. The `adafruit_pioasm` library turns assembly code into bytes
    that PIO state machines can run. Now, let’s get into the assembly code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行是导入语句。你之前已经见过 `time` 和 `board`。`rp2pio` 库让我们与 PIO 块通信，启动代码并与状态机交互。`adafruit_pioasm`
    库将汇编代码转换为 PIO 状态机可以运行的字节码。现在，让我们进入汇编代码：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code puts some PIO assembly into the `led_flash` string. Triple
    quotes in Python declare a long multi-line string.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将一些 PIO 汇编代码放入 `led_flash` 字符串中。Python 中的三引号声明了一个长多行字符串。
- en: 'The assembly code starts with the `pull` instruction; this gets a word from
    the TX FIFO queue (removing it) and stores it in the OSR. The `out pins, 1` instruction
    puts 1 bit of data from the OSR onto the configured pins – setting the state of
    a single pin. The code wraps around to run at the first instruction in a loop.
    We need to assemble this code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编代码以 `pull` 指令开始；这从 TX FIFO 队列中获取一个字（移除它）并将其存储在 OSR 中。`out pins, 1` 指令将 OSR
    中的 1 位数据放到配置的引脚上——设置单个引脚的状态。代码在循环中回绕以在第一个指令处运行。我们需要汇编这段代码：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `adafruit_pioasm.assemble` function generates bytecode, which we store
    in the `assembled` variable. We can run this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`adafruit_pioasm.assemble` 函数生成字节码，我们将其存储在 `assembled` 变量中。我们可以运行此代码：'
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`rp2pio.StateMachine` requests a state machine to run this code, telling it
    how fast to run and which output pin to map to – in this case, `board.LED`. Our
    code will be running on the PIO, but we have no data in the FIFO queue, so it
    will be waiting for us to write something to it.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`rp2pio.StateMachine` 请求一个状态机来运行此代码，告诉它运行速度和哪个输出引脚要映射——在这种情况下，`board.LED`。我们的代码将在
    PIO 上运行，但我们没有数据在 FIFO 队列中，所以它将等待我们向它写入内容。'
- en: 'We can write data with a loop in this program:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在程序中使用循环来写入数据：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This loop writes 1s and 0s to the state machine (in the `sm` variable). It must
    wrap the data as a list since a FIFO queue can store more than one data element
    as a `bytes` type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环将 1 和 0 写入状态机（在 `sm` 变量中）。由于 FIFO 队列可以存储多个数据元素作为 `bytes` 类型，因此必须将数据作为列表包装起来。
- en: Send this to Raspberry Pi Pico, and the LED will flash. Let's ensure this works.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码发送到 Raspberry Pi Pico，LED 将会闪烁。让我们确保这能正常工作。
- en: Troubleshooting PIO code
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除 PIO 代码
- en: 'Writing assembler code is somewhat tricky the first time – these tips can help
    you get moving:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 编写汇编代码第一次可能会有些棘手——这些技巧可以帮助你开始：
- en: This code uses the Python triple quote, `"""`, for a multi-line string. Ensure
    you have three quotes at both ends of the assembly section, or you will see errors.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码使用 Python 的三引号 `"""` 来表示多行字符串。确保在汇编部分的两侧都使用三个引号，否则你会看到错误。
- en: If Pico cannot load `adafruit_pioasm`, ensure you have followed the setup steps
    to copy the `mpy` file into the `lib` folder on Pico.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Pico 无法加载 `adafruit_pioasm`，请确保你已经遵循了设置步骤，将 `mpy` 文件复制到 Pico 上的 `lib` 文件夹中。
- en: Note that there must be two close brackets after the `sm.write` statements.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，在 `sm.write` 语句之后必须有两个闭合括号。
- en: If Pico is not running your code, remember to import your code in the `code.py`
    file.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Pico 没有运行你的代码，请记住将你的代码导入到 `code.py` 文件中。
- en: These tips should get you up and running.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧应该能帮助你开始运行。
- en: Now we have our first PIO code, we can try reading data back from an I/O pin.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了第一个 PIO 代码，我们可以尝试从 I/O 引脚读取数据。
- en: Detecting input with PIO
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PIO 检测输入
- en: 'Fetching input from PIO is as simple as getting a pin state into a register
    and pushing that onto the RX FIFO queue for the Python code to pick up. Create
    a file called `pio_read_1_pin.py`. We will add one more import to read PIO data:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PIO 获取输入就像将引脚状态放入寄存器并将它推送到 RX FIFO 队列以供 Python 代码获取一样简单。创建一个名为 `pio_read_1_pin.py`
    的文件。我们将添加一个额外的导入来读取 PIO 数据：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The assembly section looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编部分看起来是这样的：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `in pins,` `1` instruction will read 1 bit of data from 1 input pin and
    store this in the ISR. Following this is a comment starting with a `;` character
    that is for humans to read. The spaces are optional and are there to aid readability
    by aligning the comments. You can also add a `.program` line – effectively another
    comment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`in pins,` `1`指令将从1个输入引脚读取1位数据并将其存储在ISR中。接下来是一个以`;`字符开始的注释，供人类阅读。空格是可选的，并且存在以帮助可读性，通过对齐注释。你还可以添加一个`.program`行——实际上它是一个注释。'
- en: The next instruction is `push noblock`, which will take the ISR register and
    push it as a word onto the RX FIFO queue. `noblock` ensures it will not wait for
    the FIFO queue to be empty – note that data is not written to the FIFO queue if
    it is full.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令是`push noblock`，它将ISR寄存器作为字推送到RX FIFO队列。`noblock`确保它不会等待FIFO队列为空——注意，如果FIFO队列已满，则不会将数据写入FIFO队列。
- en: 'We then assemble this code and load it into a state machine, passing `first_in_pin`
    to map one of our encoder pins as input. Next, we need a buffer to read our FIFO
    queue data where the Python code can use it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将此代码组装并加载到状态机中，将`first_in_pin`传递以将我们的编码器引脚之一映射为输入。接下来，我们需要一个缓冲区来读取我们的FIFO队列数据，Python代码可以使用它：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The array type makes fixed-size data structures in memory. It specifies an unsigned
    32-bit integer with `'I'`. We size it as 1 element and initialize it as `0`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数组类型在内存中创建固定大小的数据结构。它指定了一个无符号32位整数，使用`'I'`。我们将其大小设置为1个元素，并初始化为`0`。
- en: 'The `main` loop reads data into the buffer and prints it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`循环将数据读入缓冲区并打印它：'
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `sm.readinto` Python function pulls data from a FIFO queue into a waiting
    buffer. It will wait if there is no new data to fetch.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`sm.readinto` Python函数将从FIFO队列中拉取数据到等待的缓冲区。如果没有新数据要获取，它将等待。'
- en: We then use a fancy print to output our data. Python `f`-strings (prefixed with
    an f) let you use a variable in the string – in this case, extracting the only
    element of `buffer`. The `:032b` format specifier tells Python to format the data
    as 32-digit binary, with the empty digits in front filled with 0s.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一个花哨的打印来输出我们的数据。Python的`f`字符串（以f开头）允许你在字符串中使用变量——在这种情况下，提取`buffer`的唯一元素。`:032b`格式说明符告诉Python将数据格式化为32位二进制，前面的空位用0填充。
- en: 'When you run this, you will see a repeating output with one of two states:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你会看到一个重复的输出，有两种状态之一：
- en: '`10000000000000000000000000000000`, showing the encoder pin is high'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10000000000000000000000000000000`，表示编码器引脚处于高电平'
- en: '`00000000000000000000000000000000`, showing the encoder pin is low'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00000000000000000000000000000000`，表示编码器引脚处于低电平'
- en: Turn the wheels on the robot slowly. One of them will make the pin change states.
    It may be surprising that the 1 bit is at the start of the data (and would be
    there in the ISR before we sent it).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 慢慢转动机器人的轮子。其中之一将使引脚改变状态。可能会令人惊讶的是，1位数据在数据开始处（在我们发送它之前，在ISR中也会在那里）。
- en: 'We can extend this code to work with two pins easily. Copy this to `pio_read_2_pins.py`
    and make the following modification:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松扩展此代码以使用两个引脚。将此代码复制到`pio_read_2_pins.py`并做出以下修改：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The other code remains the same, except that when we run it to turn the wheel
    slowly, the output will now show 2 bits from the encoder, in the following four
    states:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 其他代码保持不变，除了当我们运行它来慢慢转动轮子时，输出现在将显示编码器的2位，以下四种状态：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These are the bits of the quadrature encoding discussed previously!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是之前讨论过的四倍数编码的位！
- en: Troubleshooting
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'This section is the first time we have tried to get information from the encoders,
    and issues may occur. Try these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是我们第一次尝试从编码器获取信息，可能会出现问题。尝试以下步骤：
- en: If the data values are not changing, check the wiring carefully.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数据值没有变化，请仔细检查布线。
- en: If only 1 bit is changing, 1 encoder wire may be incorrect.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果只有1位在变化，1个编码器线可能是不正确的。
- en: We have data, but the PIO can work harder to decode this and count it for us.
    Next, let's look at these PIO instructions and how they interact with registers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有数据，但PIO可以更努力地解码它并为我们计数。接下来，让我们看看这些PIO指令以及它们如何与寄存器交互。
- en: PIO instructions and registers
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PIO指令和寄存器
- en: Understanding how registers are changed and manipulated by PIO instructions
    is crucial to writing and understanding PIO code. The PIO has nine instruction
    types; however, they have several modes, making their use nuanced and complex.
    [*Chapter 3*](B18001_03.xhtml#_idTextAnchor055) of the *RP2040 datasheet* from
    Raspberry Pi serves as a comprehensive reference. We can get familiar with a few
    more here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 理解寄存器如何被PIO指令改变和操作对于编写和理解PIO代码至关重要。PIO有九种指令类型；然而，它们有几种模式，使得它们的使用变得微妙且复杂。Raspberry
    Pi的*RP2040数据手册*的[*第3章*](B18001_03.xhtml#_idTextAnchor055)提供了一个全面的参考。我们可以在这些地方熟悉更多。
- en: Debugging a register
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寄存器调试
- en: 'This next example shows how to store a value in a register and surface it to
    code for printing. We keep the imports as before. Call this file `pio_debugging_registers.py`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何将值存储在寄存器中并将其暴露给代码以进行打印。我们保持之前的导入。将此文件命名为`pio_debugging_registers.py`：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code uses the `set` instruction, which can put any value less than 32 (5
    bits) into a register. In the example, we store it in the `y` register.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用`set`指令，可以将小于32（5位）的任何值放入寄存器。在示例中，我们将其存储在`y`寄存器中。
- en: The following line is `mov isr, y`, which copies the right (`y`) register data
    into the ISR. We must store a value in the `push` statement, putting it into a
    FIFO queue.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行是`mov isr, y`，它将右（`y`）寄存器的数据复制到ISR中。我们必须在`push`语句中存储一个值，将其放入FIFO队列中。
- en: 'We assemble this and send it to the state machine:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个汇编代码发送到状态机：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can then pull this data from the FIFO queue and examine the content as decimal
    and binary:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从FIFO队列中提取这些数据，并以十进制和二进制形式检查其内容：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code will run and simply pass the number 21 through the system. Because
    I know the value is low, I have formatted it with 32 leading 0s. Therefore, the
    output should look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将运行并通过系统传递数字21。因为我知道这个值是低的，所以我用32个前导0进行了格式化。因此，输出应该看起来像这样：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This feature is handy, and we can use this code with different assemblers as
    a template to test out PIO assembly techniques. We can start by looking at manipulating
    bits in registers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性很方便，我们可以使用这个代码作为模板与不同的汇编器一起测试PIO汇编技术。我们可以从查看寄存器中的位操作开始。
- en: Bit manipulations
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位操作
- en: 'When dealing with registers, we may want to manipulate their content. For example,
    we may want to move bits around, shift them, reverse their order, or flip them
    wholesale. The following diagram shows these operations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理寄存器时，我们可能想要操作它们的内容。例如，我们可能想要移动位、移位它们、反转它们的顺序或全部翻转。以下图表显示了这些操作：
- en: '![Figure 6.6 – PIO bit operations ](img/Figure_6.06_B18001.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – PIO位操作](img/Figure_6.06_B18001.jpg)'
- en: Figure 6.6 – PIO bit operations
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – PIO位操作
- en: '*Figure 6**.6* shows these frequent operations pictorially. The tables show
    the state of registers as bits, with the register name on the left. The diagram
    shows assembler instructions with their effect on the bits highlighted.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6**.6*以图表形式展示了这些频繁的操作。表格显示了寄存器的位状态，寄存器名称在左侧。图表显示了汇编指令及其对位的影响突出显示。'
- en: We have already talked a lot about bit shifting into the ISR. When we use the
    `in` instruction, it makes space for the number of bits to shift in, discarding
    bits at the end. It then copies the new bits into the space. Code can alter this
    shift direction with `StateMachine` parameters, but the operation is essentially
    the same. The example for shifting uses `in` to read the `C1` and `C2` pins from
    our encoder. However, as well as pins, the source can be other registers or null
    to copy in zeros. This operation does not alter the source.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于位移动到中断服务例程（ISR）的内容。当我们使用`in`指令时，它会为要移动的位数腾出空间，丢弃末尾的位。然后，它将新位复制到这个空间中。代码可以通过`StateMachine`参数改变这个移动方向，但操作本质上是相同的。移位示例使用`in`来读取我们的编码器的`C1`和`C2`引脚。然而，除了引脚之外，源还可以是其他寄存器或空（null）以复制零。这个操作不会改变源。
- en: 'We can `::` operation in `mov`; this can be useful to get to bits at the other
    end. The following assembler demonstrates this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`mov`中使用`::`操作；这可以用来访问另一端的位。以下汇编器演示了这一点：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use this example in the same Python code shown in the preceding debug
    registers example. Note that we reverse the `y` register right into the ISR. As
    the code gets more complicated, combining operations like this will be critical,
    as with only 32 instructions, every instruction counts! The output of that code
    looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个示例在前面调试寄存器示例中显示的相同Python代码中。注意，我们将`y`寄存器直接反转到ISR中。随着代码变得更加复杂，结合这种操作将是关键的，因为只有32条指令，每条指令都很重要！该代码的输出如下所示：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`not` operation. It replaces every bit with its logical opposite – 1s become
    0s and 0s become 1s. If we represent signed numbers with our 32-bit words, this
    will make them negative. Try this assembler code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`操作。它将每个位替换为其逻辑相反数 - 1变成0，0变成1。如果我们用32位字表示有符号数，这将使它们变成负数。尝试以下汇编代码：'
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code is exactly like the preceding example, producing the inverted result:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与前面的例子完全一样，产生反转的结果：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can modify our buffer to see how a value becomes negative too. Change the
    array format to a lowercase `i`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改我们的缓冲区来查看一个值如何变成负数。将数组格式更改为小写的`i`：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When running this, we can see what the output is like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个程序时，我们可以看到输出是什么样的：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The binary makes less sense, but we can see that the decimal number is the negative
    plus one. Inverting again gets back to the original number.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制代码不太容易理解，但我们可以看到十进制数是负数加一。再次取反会回到原始数字。
- en: Extracting the value of a single bit
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取单个位的值
- en: 'One more thing to do is to combine operations so that we can extract a specific
    bit using a couple of bit shifts. The following diagram shows the operation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事要做，就是组合操作，这样我们就可以通过几个位移动来提取一个特定的位。以下图表显示了操作：
- en: '![Figure 6.7 – Extracting a bit ](img/Figure_6.07_B18001.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 提取一个位](img/Figure_6.07_B18001.jpg)'
- en: Figure 6.7 – Extracting a bit
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 提取一个位
- en: 'Let us imagine our value starts in `x`; I’ve shaded the bit we want darker
    than the rest. The assembly snippet for this is the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的值从`x`开始；我已经将我们想要的位比其他位阴影更深。这个汇编代码片段如下：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first instruction shifts the bits up to the one we want into the ISR. The
    diagram shows that the bit we want is now leftmost in the ISR. However, as we
    do not want anything to the right of this bit, we use the `in` instruction to
    shift in 31 zeros from `null`. This shift pushes all the other bits away – so
    we have only 0s and the bit we want.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令将位向上移动到我们想要的位到ISR中。图表显示我们想要的位现在在ISR的最左边。然而，由于我们不希望在这个位右边有任何东西，我们使用`in`指令从`null`中移入31个零。这个位移将所有其他位推走
    - 因此我们只有0和想要的位。
- en: 'We’ll put this to real use with the OSR instead. Put the following code in
    `extract_a_bit.py`. We start with imports and a variable to tweak the behavior:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OSR来实际应用这个。将以下代码放入`extract_a_bit.py`。我们首先导入一些内容和一个变量来调整行为：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remember that we store the assembler code in a Python string, so we can perform
    Python string formatting on it with an f-string:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们存储汇编代码在Python字符串中，因此我们可以使用f-string对其进行Python字符串格式化：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Since we cannot use the `set` instruction with values higher than 5 bits, we
    start by pulling data to read, which goes into the OSR.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能使用大于5位的`set`指令，所以我们首先拉取数据以读取，这些数据进入OSR。
- en: We then use `in` to shift the bits up to the bit we want to extract, using the
    f-string to substitute the variable here. The bit to extract must be 32 or less.
    The result is in the ISR. We perform a further `in` operation from `null`, using
    0s to drop all but the bit we wanted. Since this result is already on the ISR,
    we can use `push` to send it to the FIFO queue.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`in`将位向上移动到我们想要提取的位，使用f-string在这里替换变量。要提取的位必须是32位或更少。结果在ISR中。我们从`null`执行进一步的`in`操作，使用0来丢弃除了我们想要的位之外的所有位。由于这个结果已经在ISR中，我们可以使用`push`将其发送到FIFO队列。
- en: 'The remaining code handles assembling this, sending the data, and printing
    the result:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码处理组装、发送数据和打印结果：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result from running this should be the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的结果应该是以下内容：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we want to use this data for conditional logic, we could use the `jmp` instruction,
    requiring us to use the `mov` instruction to move the data into `x` or `y` scratch
    registers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用这个数据来做条件逻辑，我们可以使用`jmp`指令，这需要我们使用`mov`指令将数据移动到`x`或`y`临时寄存器。
- en: Making a counter with PIO
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PIO制作计数器
- en: Counting requires us to be able to add or subtract from a register. We’ll start
    with counting down, as that is easier.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 计数需要我们能够从寄存器中添加或减去。我们将从向下计数开始，因为这更容易。
- en: 'At first glance, the datasheet shows no arithmetic instructions in the PIO
    instruction set. So how do we add or subtract? Although we have not used it yet,
    the `jmp` instruction in PIO assembler usually jumps to a label somewhere else
    in our assembler instructions. However, it has a trick – it can subtract from
    a scratch register. We can exploit this side effect to perform simple arithmetic
    for us. Using `pio_debugging_registers.py` as a template, try switching out the
    assembler for the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，数据表显示PIO指令集中没有算术指令。那么我们如何进行加法或减法？尽管我们还没有使用它，但PIO汇编器中的`jmp`指令通常跳转到汇编指令中的某个标签。然而，它有一个技巧——它可以从临时寄存器中减去。我们可以利用这个副作用为我们执行简单的算术。使用`pio_debugging_registers.py`作为模板，尝试将汇编器替换为以下代码：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I put this with the template in `pio_counting_down.py`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个与模板一起放在`pio_counting_down.py`中。
- en: 'Sending it to Pico and running it gives the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到Pico并运行，得到以下输出：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Hurrah – we can subtract! We have used a `fake:` label for the subtraction because
    we don’t want to jump anywhere, just perform the arithmetic.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼——我们可以减法了！我们使用`fake:`标签进行减法，因为我们不想跳转到任何地方，只想执行算术运算。
- en: What about adding? This is trickier, but if you recall the bit invert, the number
    flipped from positive to negative. We can exploit this by subtracting 1 and flipping
    it again.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 那么增加呢？这有点棘手，但如果你记得位反转，数字从正数变成了负数。我们可以通过减去1并再次反转来利用这一点。
- en: 'Use this assembler (in `pio_counting_up.py`):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此汇编器（在`pio_counting_up.py`）：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We still have our fake label, but we flip the `y` value into itself first and
    then flip it again when putting it into the ISR. The output of running this is
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有我们的假标签，但首先将`y`值翻转成自身，然后在将其放入ISR时再次翻转。运行此代码的输出如下：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You have seen techniques for working with the PIO, how to read data from pins,
    extract information from it, and perform arithmetic. We have building blocks.
    The following section will see us use them to decode information from the encoder
    pins into a counter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了处理PIO的技术，如何从引脚读取数据，从中提取信息，以及执行算术。我们有构建块。接下来的部分将展示我们如何使用它们将编码器引脚的信息解码成计数器。
- en: Measuring encoder count for movement
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量编码器计数以检测移动
- en: We know what sequences to expect for our encoder, and we have a working knowledge
    of PIO assembler. So, we can bring these together to create the counter. We’ll
    start simple though; let’s see how to detect when a system has changed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们的编码器预期的序列，并且我们对PIO汇编器有了一定的了解。因此，我们可以将这些结合起来创建计数器。不过，我们先从简单开始；让我们看看如何检测系统何时发生变化。
- en: Making a simple PIO change detection loop
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的PIO变化检测循环
- en: 'As we saw in the read two pins example, when we output the system’s state in
    a tight loop, it floods off anything interesting. We are interested in state changes,
    a step toward the full decoder. In the `pio_one_encoder_when_changed.py` file,
    we go straight from imports into the assembler:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在读取两个引脚的例子中看到的，当我们在一个紧密的循环中输出系统的状态时，它会淹没任何有趣的东西。我们感兴趣的是状态变化，这是向完整解码器迈出的一步。在`pio_one_encoder_when_changed.py`文件中，我们直接从导入进入汇编器：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We start by clearing `y –`; we are going to use `y` to store a pin value for
    comparison:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先清除`y –`；我们将使用`y`来存储用于比较的引脚值：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following code creates a `read` label; we can loop to this point to get
    new pin readings. It stores the old `y` in x so that we can get a new value. Shifting
    `in null, 32` will fill the ISR with zeros, clearing it. We can then get two pins
    in the ISR:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个`read`标签；我们可以循环到这个点以获取新的引脚读取。它将旧的`y`存储在`x`中，这样我们就可以得到一个新的值。将`in null,
    32`移位将ISR填充为零，清除它。然后我们可以在ISR中获取两个引脚：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We want to compare our new value in the ISR with our old value, now in `x`.
    However, `jmp` cannot use the ISR for comparisons, so we first copy the ISR into
    `y`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在ISR中比较我们的新值与现在的旧值`x`。然而，`jmp`不能使用ISR进行比较，所以我们首先将ISR复制到`y`。
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As the code shows, we can now use `jmp x!=y` to jump somewhere else when the
    register values are different – to a label named `different`. If we do not find
    them different, we loop back to `read` to try a fresh sample from the pins with
    the unconditional `jmp`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，现在当寄存器值不同时，我们可以使用`jmp x!=y`跳转到其他地方——到名为`different`的标签处。如果我们没有找到它们不同，我们将通过无条件`jmp`回到`read`标签以尝试从引脚获取新的样本。
- en: 'Let''s see the code in the `different` label:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`different`标签中的代码：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Although we copied the ISR to `y`, it is still in the ISR so that we can push
    this value, the new changed value, out to the Python code and then jump back around
    to read it again. So, the total effect is that it will spin reading values and,
    if they are different, push them to the Python code and then go back to spinning
    in the `read` loop.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已将中断服务例程（ISR）复制到 `y`，但它仍然在ISR中，这样我们就可以将这个值，新的变化值，推送到Python代码中，然后跳转回读取它。所以，总的效果是它将旋转读取值，如果它们不同，就将它们推送到Python代码中，然后回到
    `read` 循环中的旋转。
- en: 'Let us continue the Python code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续Python代码：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last half assembles our code and creates a state machine with it, using
    a higher frequency. It sets the state machine to use GP20 as the first input pin.
    Then, it uses `in_pin_count` to set a range of two input pins, matching one of
    the encoders. It then reads data into a buffer and prints it in a loop. The `sm.readinto`
    method waits until there is data, so the Python code only prints when there is
    a change. Try rotating the wheels slowly, and you should see the output change:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一半将我们的代码汇编起来，并使用它创建一个状态机，使用更高的频率。它将状态机设置为使用GP20作为第一个输入引脚。然后，它使用 `in_pin_count`
    设置两个输入引脚的范围，匹配一个编码器。然后它将数据读入缓冲区并在循环中打印。`sm.readinto` 方法等待直到有数据，所以Python代码只有在有变化时才会打印。尝试慢慢旋转轮子，你应该看到输出变化：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see the encoder output, and only when it changes. We could just count
    the changes, but our system should count in different directions depending on
    the wheel movement. Let's write code to check this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到编码器的输出，并且只有在它发生变化时。我们本可以简单地计数变化，但我们的系统应该根据轮子的运动方向进行不同的计数。让我们编写代码来检查这一点。
- en: Making a bidirectional counter with PIO
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PIO制作双向计数器
- en: 'We can detect when our sensor is in a new state and store that in `y`, with
    an old state in `x` for comparison. We also need to store a counter, and since
    we aren’t using it, the OSR will suffice. We’ll jump right into the assembler,
    since the imports don’t change:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检测我们的传感器是否处于新的状态，并将其存储在 `y` 中，用 `x` 中的旧状态进行比较。我们还需要存储一个计数器，由于我们未使用它，OSR就足够了。我们将直接进入汇编器，因为导入没有变化：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, beyond setting up the OSR, this starts the same as the previous
    example. However, where things are different, we need to be more innovative. Comparing
    the 2 bits with the previous 2 bits is tricky in assembler, and we have a 32-instruction
    limit. What we are trying to evaluate is the sequences in the following diagram:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，除了设置OSR之外，这与前面的例子一样开始。然而，在有所不同之处，我们需要更有创新性。在汇编器中比较前两个位与后两个位是棘手的，我们有一个32条指令的限制。我们试图评估的是以下图中的序列：
- en: '![Figure 6.8 – Quadrature encoding sequence ](img/Figure_6.08_B18001.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 正交编码序列](img/Figure_6.08_B18001.jpg)'
- en: Figure 6.8 – Quadrature encoding sequence
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 正交编码序列
- en: '*Figure 6**.8* shows the sequence for encoder signals. Each pair of numbers
    shows the sensor states. A jump from **00** to **10** suggests the encoder is
    going clockwise, and from **00** to **01** is anticlockwise; we can follow the
    sequence around in either direction.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.8* 展示了编码器信号的序列。每一对数字表示传感器的状态。从 **00** 到 **10** 的跳跃表明编码器正在顺时针旋转，而从 **00**
    到 **01** 是逆时针；我们可以沿着序列在任意方向跟踪。'
- en: 'We can evaluate an old reading and a new reading with the following conditions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下条件评估旧读数和新读数：
- en: If the first bit of the old reading is 0
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果旧读数的第一个位是0
- en: And the current second bit is 1
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且当前第二个位是1
- en: Then it is going anticlockwise
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它正在逆时针旋转
- en: Else, the current second bit is 0
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，当前第二个位是0
- en: It is going clockwise
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它正在顺时针旋转
- en: If the first bit of the old reading is 1
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果旧读数的第一个位是1
- en: And the current second bit is 1
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且当前第二个位是1
- en: It is going clockwise
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它正在顺时针旋转
- en: Else, the current second bit is 0
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，当前第二个位是0
- en: It is going anticlockwise
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它正在逆时针旋转
- en: 'This logic can boil down to a few instructions in the assembler. First, we
    can isolate the bit we want in the `x` register (the old reading) and compare
    that to zero, jumping on the result:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑可以简化为汇编器中的几个指令。首先，我们可以将 `x` 寄存器（旧读数）中我们想要的位隔离出来，并将其与零进行比较，根据结果跳转：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that this uses the preceding bit extraction method; bit 31 would be the
    first pin (`C1`) read in. We now have the old `C1` value in `x`, padded with 0s.
    If the `x` register is zero, the `jmp !x` instruction will jump to the `c1_old_zero`
    label. Otherwise, it will fall through.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这使用了前面的位提取方法；位31将是第一个读取的引脚（`C1`）。我们现在有 `x` 中的旧 `C1` 值，用0填充。如果 `x` 寄存器为零，`jmp
    !x` 指令将跳转到 `c1_old_zero` 标签。否则，它将直接通过。
- en: 'For clarity, we will start the fall-through section with the `c1_old_non_zero`
    label; this is just a comment, though:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们将 fall-through 部分从 `c1_old_non_zero` 标签开始；这只是一个注释，尽管如此：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: At this point, we test a pin. We’ll see later that we can set `jmp_pin` when
    creating the state machine, and we’ll set it to the `C2` pin for an encoder, so
    this will have the current second pin in it. The `jmp pin, count_up` instruction
    will jump to the `count_up` label if the current state of the pin is 1\. Otherwise,
    we unconditionally jump to `count_down`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们测试一个引脚。我们稍后会看到，在创建状态机时可以设置 `jmp_pin`，我们将它设置为编码器的 `C2` 引脚，所以它将包含当前的第二个引脚。`jmp
    pin, count_up` 指令将在引脚当前状态为 1 时跳转到 `count_up` 标签。否则，我们将无条件跳转到 `count_down`。
- en: 'The code for when `C1` is zero is the opposite:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `C1` 为零时的代码是相反的：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, I am being sneaky – instead of the unconditional jump, the next code
    section will be `count_up`, so we can skip it and save an instruction. `count_up`
    is adding 1, as we’ve seen before, with the twist that the original value is on
    the OSR:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我在这里有点狡猾——不是无条件跳转，下一个代码部分将是 `count_up`，这样我们就可以跳过它并节省一条指令。`count_up` 是加 1，就像我们之前看到的，但是有一个变化，原始值在
    OSR 中：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We invert the OSR into `x`, use jmp to jump to a fake label, subtract 1 from
    `x`, and then invert `x` back. Finally, this code jumps to send the data, with
    the new count now in `x`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 OSR 反转为 `x`，使用 jmp 跳转到假标签，从 `x` 中减去 1，然后再次反转 `x`。最后，这段代码跳转到发送数据，此时新的计数现在在
    `x` 中。
- en: '`count_down` is a little simpler:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_down` 稍微简单一些：'
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code puts the OSR in `x` and subtracts 1 from it, jumping directly to send.
    Regardless of the value of `x`, the `send` part labels the next instruction anyway.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 OSR 放入 `x` 并从它减去 1，然后直接跳转到发送。无论 `x` 的值如何，`send` 部分都会将标签放在下一条指令上。
- en: 'The `send` part is just pushing this all back and storing the new value back
    in the OSR:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 部分只是将所有这些推回并存储在 OSR 中的新值：'
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The final instruction loops back to `read` to recheck the sensor. There is a
    `wrap` directive in other PIO dialects that would save an instruction here; however,
    CircuitPython PIOASM does not implement this at the time of writing.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条指令会循环回 `read` 以重新检查传感器。其他 PIO 语言的 `wrap` 指令可以在这里节省一条指令；然而，CircuitPython
    PIOASM 在编写时没有实现这一点。
- en: That was a lot of assembler language. This example is in the chapter repo as
    `pio_encoder_counting.py`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多汇编语言。这个例子在章节仓库中作为 `pio_encoder_counting.py`。
- en: 'We need a little more Python code to assemble the instructions, run it, and
    get the data:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更多的 Python 代码来组装指令，运行它，并获取数据：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we create two state machines from the same code! We pass C1 to the state
    machine as the first input pin, and `C2` to the state machine as `jmp_pin`, for
    each encoder based on *Figure 6**.4*. We have also set `frequency=0`, which tells
    the state machine to go at full speed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用相同的代码创建了两个状态机！我们将 `C1` 作为第一个输入引脚传递给状态机，将 `C2` 作为 `jmp_pin` 传递给状态机，对于每个编码器基于
    *图 6**.4*。我们还设置了 `frequency=0`，这告诉状态机以全速运行。
- en: 'We can still use one buffer to read the two state machines alternately. However,
    this buffer needs to be type `i` (lowercase) to use signed numbers and count negatively.
    We also will make two variables to hold the left and right wheel states:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用一个缓冲区交替读取两个状态机。然而，这个缓冲区需要是类型 `i`（小写）才能使用有符号数字并负数计数。我们还将创建两个变量来保存左右轮的状态：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In our main loop, we can start with the left sensor, check whether there is
    data waiting in the RX FIFO queue with `.in_waiting`, and print both sides if
    there is:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主循环中，我们可以从左侧传感器开始，使用 `.in_waiting` 检查 RX FIFO 队列中是否有等待的数据，如果有，就打印两边：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that there is no special format now; we are just printing the raw number
    of counts. The right side is the same:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目前没有特殊的格式；我们只是打印原始计数数量。右侧也是一样的：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you run this, you should be able to turn either wheel and see output like
    this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你应该能够转动任意一个轮子并看到如下输出：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can now count pulses for both wheels. So, if you make a complete wheel revolution,
    you should land close to plus or minus 8344 – proving our previous calculation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为两个轮子计数脉冲。所以，如果你使轮子完成一次完整的旋转，你应该会接近加减 8344——证明我们之前的计算。
- en: You will see that one wheel makes the count go backward. Each motor effectively
    turns in an opposite direction from the encoder’s perspective. We will account
    for this later.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个轮子会使计数倒退。每个电机从编码器的角度来看实际上是以相反的方向转动。我们稍后会考虑这一点。
- en: Troubleshooting
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'This example is a lot of code and could go wrong in various ways:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有很多代码，可能会以各种方式出错：
- en: If the code counts up/down randomly and not consistently, you may need to change
    `jmp_pin` to the other input pin.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码随机上下计数而不是持续计数，你可能需要将`jmp_pin`更改为另一个输入引脚。
- en: It could also mean you have missed putting `x` in `isr` before sending.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也可能意味着你在发送之前遗漏了在`isr`中放置`x`。
- en: Check against the source code from git.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与git源代码进行核对。
- en: You should now be up and running and getting counts.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经启动并运行，并且正在获取计数。
- en: Making reusable encoder code
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作可重用编码器代码
- en: Because we will reuse this, we will put it into a module and pick it up in our
    `robot.py`. We will then use this to make a demonstration program.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们会重复使用它，所以我们将它放入一个模块中，并在我们的`robot.py`中调用它。然后我们将使用这个来制作一个演示程序。
- en: 'Let''s take what we made previously and put it into a module named `pio_encoder.py`.
    The following code should all be familiar:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把之前制作的代码放入一个名为`pio_encoder.py`的模块中。以下代码应该都很熟悉：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We need a way to create the state machines with their parameters and a wrapper
    for getting the data. A Python class is an excellent way to do this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来创建具有其参数的状态机，以及一个用于获取数据的包装器。Python类是完成这个任务的绝佳方式：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We will call it `QuadratureEncoder`, as it should work with those types regardless
    of the mechanism. Inside the class is an `__init__` function, which tells Python
    how to make an encoder object – it takes two pins as its parameters and uses them
    to create the state machine. The object also makes a buffer to store the most
    recent return value. Note that the two pins must be in sequence.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为`QuadratureEncoder`，因为它应该与这些类型一起工作，而不管机制如何。在类中有一个`__init__`函数，它告诉Python如何创建编码器对象——它接受两个引脚作为参数并使用它们来创建状态机。该对象还创建一个缓冲区来存储最新的返回值。请注意，两个引脚必须按顺序排列。
- en: There’s also a reversed parameter; this is so we can account for one motor turning
    the opposite way. We cannot just swap pins in the code here, as the `in` instruction
    requires pins in sequence.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个反向参数；这样我们就可以考虑一个电机反向转动的情况。我们在这里不能简单地交换引脚，因为`in`指令要求引脚按顺序排列。
- en: 'Next, we need a method to read from the encoder or the old value if there’s
    no change:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个方法来从编码器读取或如果没有变化则读取旧值：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: By checking the `in_waiting` state, this reading will not block and only update
    the buffer if there’s a new reading; this is a `while` loop because we only want
    the most recent FIFO data. It returns the element in the buffer, returning the
    negative version if the motor is reversed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`in_waiting`状态，这个读取不会阻塞，并且只有当有新的读取时才会更新缓冲区；这是一个`while`循环，因为我们只想获取最新的FIFO数据。它返回缓冲区中的元素，如果电机反向则返回负值。
- en: 'We can now add these encoders to the `robot.py` library from the end of [*Chapter
    5*](B18001_05.xhtml#_idTextAnchor098), *Driving Motors with Raspberry Pi Pico*.
    Let''s add encoders to the imports:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这些编码器添加到从[*第5章*](B18001_05.xhtml#_idTextAnchor098)，“使用Raspberry Pi Pico驱动电机”的末尾的`robot.py`库中。让我们在导入中添加编码器：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The new code is highlighted. We can also set up the two encoders. Add the bold
    code after the motors:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码被突出显示。我们还可以设置两个编码器。在电机后面添加粗体代码：
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When we use our robot, we can now use `robot.left_encoder.read()` and an equivalent
    command for the right encoder to get an encoder reading, which we will now use
    in a demonstration.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用我们的机器人时，现在我们可以使用`robot.left_encoder.read()`以及右编码器的等效命令来获取编码器读数，我们将在演示中使用它。
- en: Measure counts for a known time
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量已知时间的计数
- en: 'We will turn this into a demonstration to see what the count is when driving
    for a second. Because we have put work into preparing our `robot.py`, this code
    is simple. Put the following code in `measure_fixed_time.py`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个变成一个演示，看看在驾驶一秒钟时计数是多少。因为我们已经投入了精力来准备我们的`robot.py`，所以这段代码很简单。将以下代码放入`measure_fixed_time.py`中：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This code loads the `time` library and the `robot` helper. It drives forward
    at 0.8 speed for 1 second. It then stops and prints readings from each encoder.
    While this code sleeps, the encoder code is still running.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码加载`time`库和`robot`辅助库。它以0.8的速度向前行驶1秒钟。然后停止并打印每个编码器的读数。当此代码休眠时，编码器代码仍在运行。
- en: Making the encoders this simple to use means we can integrate them with more
    complex behaviors later; this is a good strategy for most sensors.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使编码器如此简单易用意味着我们可以将其与更复杂的行为集成；这对于大多数传感器来说是一个好的策略。
- en: 'To run this code, be sure to send the `pio_encoders.py` library, the updated
    `robot.py`, and then `measure_fixed_time.py`. Remember to update `code.py` to
    load it, and you should see the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码，请确保发送`pio_encoders.py`库、更新的`robot.py`和`measure_fixed_time.py`。记得更新`code.py`以加载它，你应该会看到以下内容：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You have begun to take sensor readings from your robot, learning PIO on the
    way!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经开始从你的机器人读取传感器读数，并在学习 PIO 的过程中！
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about measuring distance traveled using encoders,
    including the different types of encoders.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用编码器测量行驶距离，包括不同类型的编码器。
- en: You saw the output that quadrature encoders create and how to interpret this
    as a turning direction.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了四倍频编码器产生的输出，以及如何将其解释为转向方向。
- en: You were introduced to the powerful PIO state machines present within Pico and
    saw how you can give tasks such as handling encoders to them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你被介绍到了 Pico 内部强大的 PIO 状态机，并看到了如何将处理编码器等任务分配给它们。
- en: You brought this together to create a reusable handler for the encoders, and
    we had a demonstration to see them working.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你将这些知识结合起来创建了一个可重用的编码器处理器，我们进行了演示以观察其工作情况。
- en: In the next chapter, we will plan and buy more devices for our robot, leading
    to more sensing, and remotely drive it.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将计划和购买更多设备用于我们的机器人，这将导致更多的传感和远程控制。
- en: Exercises
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'These exercises can improve your robot and let you practice your skills:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习可以提高你的机器人性能，并让你练习你的技能：
- en: You have been able to get readings and a count for each wheel when driving for
    a fixed time. How could you make code that stops the motors after a fixed number
    of counts? You may need to check the encoder readings in a loop regularly.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经能够获取在固定时间内行驶时每个轮子的读数和计数。你如何编写代码在固定数量的计数后停止电机？你可能需要定期在循环中检查编码器读数。
- en: You may have noticed imbalances in the counts – this is normal and due to motor
    and wheel differences. One way you could improve this would be to design and make
    a holder for the breadboard with the styrene rod so that it doesn’t slide around
    on the platform.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能已经注意到了计数的不平衡——这是正常的，是由于电机和车轮的差异造成的。你可以通过设计并制作一个带有聚苯乙烯棒的面包板支架来改善这种情况，这样它就不会在平台上滑动。
- en: Could you write code to slow a motor if it’s overtaken another one in its count?
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能编写代码来减慢一个在计数中被另一个超过的电机吗？
- en: Further reading
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These further reading items will help you continue your studies:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些进一步阅读材料将帮助你继续你的学习：
- en: 'Raspberry Pi has the definitive reference in [*Chapter 3*](B18001_03.xhtml#_idTextAnchor055)
    of their datasheet on using PIO and its architecture: [https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf).
    They also have PIO code examples in [*Chapter 3*](B18001_03.xhtml#_idTextAnchor055)
    of their C SDK document (including MicroPython but not CircuitPython samples):
    [https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf](https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf).'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 在其数据表中的 **[第3章](B18001_03.xhtml#_idTextAnchor055**) 中提供了使用 PIO
    及其架构的权威参考：[https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf)。他们还在其
    C SDK 文档的 **[第3章**](B18001_03.xhtml#_idTextAnchor055) 中提供了 PIO 代码示例（包括 MicroPython
    但不包括 CircuitPython 样本）：[https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf](https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-c-sdk.pdf)。
- en: Adafruit documentation for `rp2pio` is at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/rp2pio/](https://circuitpython.readthedocs.io/en/latest/shared-bindings/rp2pio/)
    and is worth consulting for its use, along with their *Introduction to CircuitPython
    RP2040 PIO* at [https://learn.adafruit.com/intro-to-rp2040-pio-with-circuitpython](https://learn.adafruit.com/intro-to-rp2040-pio-with-circuitpython).
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit 的 `rp2pio` 文档位于 [https://circuitpython.readthedocs.io/en/latest/shared-bindings/rp2pio/](https://circuitpython.readthedocs.io/en/latest/shared-bindings/rp2pio/)，并且在使用方面值得参考，还有他们的
    *CircuitPython RP2040 PIO 简介* 在 [https://learn.adafruit.com/intro-to-rp2040-pio-with-circuitpython](https://learn.adafruit.com/intro-to-rp2040-pio-with-circuitpython)。
- en: A video by YouTuber StackSmasher has a great deep dive into PIO, its architecture,
    and programming at [https://youtu.be/yYnQYF_Xa8g](https://youtu.be/yYnQYF_Xa8g).
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YouTube 用户 StackSmasher 有一段关于 PIO、其架构和编程的深入视频，可以在 [https://youtu.be/yYnQYF_Xa8g](https://youtu.be/yYnQYF_Xa8g)
    上找到。
