- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Including Additional Regressors
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含额外回归因子
- en: In your first model in [*Chapter 2*](B19630_02.xhtml#_idTextAnchor104), *Getting
    Started with Prophet*, you forecasted carbon dioxide levels at Mauna Loa using
    only the date (but no other information) to predict future values. Later, in [*Chapter
    6*](B19630_06.xhtml#_idTextAnchor375), *Forecasting Holiday Effects*, you learned
    how to add holidays as additional information to further refine your predictions
    of bicycle ridership in the Divvy bike share network in Chicago.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的第一个模型中，[*第2章*](B19630_02.xhtml#_idTextAnchor104)，*使用Prophet入门*，你仅使用日期（但没有其他信息）来预测未来的二氧化碳水平。后来，在[*第6章*](B19630_06.xhtml#_idTextAnchor375)，*预测节假日影响*中，你学习了如何将节假日作为附加信息添加，以进一步细化你在芝加哥Divvy自行车共享网络中对自行车骑行量的预测。
- en: The way holidays are implemented in Prophet is actually a special case of adding
    a binary regressor. In fact, Prophet includes a generalized method for adding
    any additional regressor, both binary and continuous.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Prophet中实现节假日的方式实际上是添加二元回归因子的一个特殊情况。实际上，Prophet包括了一种通用的方法来添加任何额外的回归因子，包括二元和连续的。
- en: 'In this chapter, you’ll enrich your Divvy dataset with weather information
    by including it as an additional regressor. First, you will add binary weather
    conditions to describe the presence or absence of sun, clouds, or rain, and then
    you will bring in continuous temperature measurements. Using additional regressors
    can allow you to include more information to inform your models, which leads to
    greater predictive power. In this chapter, you will learn about the following
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过将其作为额外回归因子包括进来，用天气信息丰富你的Divvy数据集。首先，你将添加二元天气条件来描述阳光、云或雨的存在或不存在，然后你将引入连续的温度测量。使用额外的回归因子可以使你包含更多信息来告知你的模型，这会导致更强的预测能力。在本章中，你将学习以下主题：
- en: Adding binary regressors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加二元回归因子
- en: Adding continuous regressors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加连续回归因子
- en: Interpreting the regressor coefficients
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释回归系数
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The data files and code for examples in this chapter can be found at [https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中示例的数据文件和代码可以在[https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition](https://github.com/PacktPublishing/Forecasting-Time-Series-Data-with-Prophet-Second-Edition)找到。
- en: Adding binary regressors
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加二元回归因子
- en: 'The first thing to consider with **additional regressors**, whether binary
    or continuous, is that you must have known future values for your entire forecast
    period. This isn’t a problem with holidays because we know exactly when each future
    holiday will occur. All future values must either be known, as with holidays,
    or must have been forecast separately. You must be careful though when building
    a forecast using data that itself has been forecast: the error in the first forecast
    will compound the error in the second forecast, and the errors will continuously
    pile up.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑**额外回归因子**时，无论是二元还是连续的，首先需要考虑的是你必须知道整个预测期间的未来值。这并不是节假日的问题，因为我们确切地知道每个未来节假日的具体时间。所有未来值必须已知，就像节假日一样，或者必须单独进行预测。然而，当使用已经被预测的数据构建预测时，你必须小心：第一次预测的错误会累积到第二次预测中，错误会持续累积。
- en: 'If one variable is much easier to forecast than another, however, then this
    may be a case where these stacked forecasts do make sense. A **hierarchical time
    series** is an example case where this may be useful: you may find good results
    by forecasting the more reliable daily values of one time series, for instance,
    and using those values to forecast hourly values of another time series that is
    more difficult to predict.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个变量的预测比另一个变量容易得多，那么这可能是这些堆叠预测有意义的案例。**分层时间序列**是一个可能有用的情况的例子：你可能通过预测一个时间序列更可靠的日值，例如，并使用这些值来预测另一个更难预测的时间序列的小时值。
- en: In the examples in this chapter, we are going to use a weather forecast to enrich
    our Divvy forecast. This additional regressor is possible because we generally
    do have decent weather forecasts available looking ahead a week or so. In other
    examples in this book, in which we have used Divvy data, we often forecasted a
    full year. In this chapter though, we will only forecast 2 weeks. Let’s be generous
    to Chicago’s weather forecasters and assume that they’ll provide accurate forecasts
    in this time frame.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的例子中，我们将使用天气预报来丰富我们的Divvy预测。这种额外的回归器是可能的，因为我们通常确实有一周左右的相当可靠的天气预报可用。在这本书的其他例子中，当我们使用Divvy数据时，我们经常预测整整一年。然而，在本章中，我们只会预测两周。让我们对芝加哥的天气预报员慷慨一些，并假设他们将在这一时间段内提供准确的预报。
- en: 'To begin, let’s import our necessary packages and load the data:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入必要的包并加载数据：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Please refer to *Figure 5**.6* in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254),
    *Working with Seasonality*, for a plot of the rides per day in this data. *Figure
    5**.7* in [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254) showed an excerpt of
    the data contained in this file. So far in this book, we always excluded the two
    columns for weather and temperature in this dataset, but we’ll use them this time
    around. For our first example, let’s consider the weather conditions. By counting
    the number of times each condition occurred in the dataset, we can see their frequencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考[*第5章*](B19630_05.xhtml#_idTextAnchor254)中的*图5.6*，*处理季节性*，以查看此数据中每天骑行的图表。[*第5章*](B19630_05.xhtml#_idTextAnchor254)中的*图5.7*显示了此文件中包含的数据的摘录。到目前为止，在这本书中，我们总是排除了此数据集中关于天气和温度的两个列，但这次我们将使用它们。对于我们的第一个例子，让我们考虑天气条件。通过计算每个条件在数据集中出现的次数，我们可以看到它们的频率：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding `print` statement is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`print`语句的输出如下：
- en: '![Figure 9.1 – Count of weather conditions in the Divvy dataset](img/Fig_9.1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Divvy数据集中天气条件的计数](img/Fig_9.1.jpg)'
- en: Figure 9.1 – Count of weather conditions in the Divvy dataset
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Divvy数据集中天气条件的计数
- en: By grouping the data by weather and aggregating by count, we can see the number
    of days each condition was reported. Clear weather occurred on `41` days, and
    cloudy weather was by far the most common, with `1346` occurrences. `Not clear`
    was only reported twice, and `rain or snow` occurred `69` times.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按天气分组数据并按计数聚合，我们可以看到每种条件报告的天数。晴朗的天气出现了`41`天，而多云的天气远远是最常见的，有`1346`次出现。`Not
    clear`只报告了两次，而`rain or snow`出现了`69`次。
- en: Now that we understand what data we’re working with, let’s load it into our
    DataFrame. We’ll also load the `temperature` column, even though we won’t use
    it until the next example when we look at **continuous** columns, those in which
    the value may exist along a continuum.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了我们正在处理的数据，让我们将其加载到我们的DataFrame中。我们还将加载`temperature`列，尽管我们直到下一个例子查看**连续**列（其值可能存在于连续体上）时才会使用它。
- en: 'To load the `weather` column, we will use pandas’ `get_dummies` method to convert
    it into four `1` or `0` – essentially, a flag indicating whether the condition
    is present:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载`weather`列，我们将使用pandas的`get_dummies`方法将其转换为四个`1`或`0` – 实际上，这是一个标志，表示条件是否存在：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can display the first five rows of our DataFrame at this point to see what
    the preceding code has done:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以显示DataFrame的前五行，以查看前面的代码做了什么：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the `head` statement should appear as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`语句的输出应该如下所示：'
- en: '![Figure 9.2 – DataFrame with dummy weather columns](img/Fig_9.2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 带有虚拟天气列的DataFrame](img/Fig_9.2.jpg)'
- en: Figure 9.2 – DataFrame with dummy weather columns
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 带有虚拟天气列的DataFrame
- en: You can now see that each unique value in the `weather` column has been converted
    to a new column. Let’s instantiate our model now, setting the seasonality mode
    to multiplicative and the yearly seasonality to have a Fourier order of `4`, as
    we did in previous chapters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到`weather`列中的每个唯一值都已转换为一个新的列。现在让我们实例化我们的模型，将季节性模式设置为乘法，并将年季节性设置为具有`4`个傅里叶阶数，就像我们在前面的章节中所做的那样。
- en: We will also add our additional regressors using the `add_regressor` method.
    As arguments to this method, you must pass the name of the regressor, which is
    the name of the corresponding column in your DataFrame. You may also use the `prior_scale`
    argument to regularize the regressor, just as you did with holidays, seasonalities,
    and trend changepoints. If no prior scale is specified, then `holidays_prior_scale`
    will be used, which defaults to `10`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`add_regressor`方法添加额外的回归器。作为此方法的参数，您必须传递回归器的名称，这是DataFrame中相应列的名称。您还可以使用`prior_scale`参数来正则化回归器，就像您对假日、季节性和趋势变化点所做的那样。如果没有指定先验尺度，则将使用`holidays_prior_scale`，默认值为`10`。
- en: You may also specify whether the regressor should be additive or multiplicative.
    If nothing is specified, then the regressor adopts that stated in `seasonality_mode`.
    Lastly, the method has a `standardize` argument, which, by default, takes the
    `'auto'` string. This means that the column will be standardized if not binary.
    You can instead explicitly set standardization by setting it to either `True`
    or `False`. In this example, all defaults will work out great.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定回归器应该是加法还是乘法。如果没有指定，则回归器将采用`seasonality_mode`中声明的值。最后，该方法有一个`standardize`参数，默认情况下取`'auto'`字符串。这意味着如果列不是二元的，则将对列进行标准化。您可以通过将其设置为`True`或`False`来显式设置标准化。在这个例子中，所有默认值都将很好地工作。
- en: To make it clear, I’ll explicitly state all arguments in only the first `add_regressor`
    call and for the remaining, we will only state the name of the regressor and otherwise
    accept all default values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其清晰，我将在第一个`add_regressor`调用中明确声明所有参数，而对于其余的，我们只将声明回归器的名称，并接受所有默认值。
- en: We must make one `add_regressor` call for each additional regressor but note
    that we are leaving the regressor for `cloudy` out. For Prophet to get accurate
    forecast results, this isn’t strictly necessary. However, because including all
    four binary columns will introduce **multicollinearity**, this makes interpreting
    the individual effect of each condition difficult, so we will exclude one of them.
    However, Prophet is fairly robust to multicollinearity in additional regressors,
    so it shouldn’t affect your final results significantly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为每个额外的回归器调用一次`add_regressor`，但请注意，我们省略了`cloudy`回归器。为了Prophet能够得到准确的预测结果，这并不是严格必要的。然而，由于包含所有四个二元列将引入**多重共线性**，这使得解释每个条件的个体效应变得困难，因此我们将排除其中一个。但是，Prophet对额外回归器中的多重共线性相当稳健，所以它不应该对您的最终结果产生重大影响。
- en: 'When we called `pd.get_dummies` earlier, we could have specified the `drop_first=True`
    argument to exclude one of the conditions, but I decided not to so we could choose
    for ourselves which column to exclude. The `cloudy` condition is by far the most
    frequent so, by excluding it, we are essentially stating that `cloudy` is the
    *default* weather condition and the other conditions will be stated as deviations
    from it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前调用`pd.get_dummies`时，我们可以指定`drop_first=True`参数来排除一个条件，但我决定不这样做，这样我们就可以自己选择要排除的列。`cloudy`条件是最频繁的，因此，通过排除它，我们实际上是在声明`cloudy`是*默认*天气条件，其他条件将作为对其的偏差来陈述：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, remembering that we need future data for our additional regressors and
    we’re only going to forecast out two weeks, we need to artificially reduce our
    training data by two weeks to simulate having two future weeks of weather data
    but no ridership data. To do that, we’ll need to import `timedelta` from Python’s
    built-in `datetime` package.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们需要为我们的额外回归器提供未来数据，而我们只预测两周，我们需要人为地将我们的训练数据减少两周，以模拟有两个未来周的天气数据但没有乘客数据。为此，我们需要从Python的内置`datetime`包中导入`timedelta`。
- en: 'Using Boolean indexing in pandas, we will create a new DataFrame for training
    data, called `train`, by selecting all dates that are less than the final date
    (`df[''ds''].max()`) minus two weeks (`timedelta(weeks=2)`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pandas中的布尔索引，我们将通过选择所有小于最终日期（`df['ds'].max()`）减去两周（`timedelta(weeks=2)`）的日期来创建一个新的训练数据DataFrame，称为`train`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, we are essentially saying that our data ends not on December
    31, 2017 (as our `df` DataFrame does), but on December 16, 2017, and that we have
    a weather forecast for those two missing weeks. We now fit our model on this `train`
    data and create our `future` DataFrame with 14 days.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上是在说我们的数据不是在2017年12月31日结束（正如我们的`df` DataFrame所做的那样），而是在2017年12月16日结束，并且我们有这两周缺失的天气预报。我们现在在这个`train`数据上拟合我们的模型，并创建一个包含14天的`future`
    DataFrame。
- en: At this point, we need to add those additional regressor columns into our `future`
    DataFrame. Because we created that `train` DataFrame instead of `future` modifying
    our original `df` DataFrame, those values for the weather are stored in `df` and
    we can take them to use in our `future` DataFrame. Finally, we will predict on
    the future.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要将这些附加回归器列添加到我们的`future` DataFrame中。因为我们创建的是`train` DataFrame而不是直接修改我们的原始`df`
    DataFrame，所以这些天气值存储在`df`中，我们可以将它们用于我们的`future` DataFrame。最后，我们将对未来进行预测。
- en: 'The forecast plot is going to look similar to our previous Divvy forecasts,
    so let’s just skip it and go straight to the `components` plot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 预测图将类似于我们之前的Divvy预测，所以我们就跳过它，直接看`components`图：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This time, you will see a new subplot included with the other components. The
    following image is a crop of the full `components` plot and only shows the yearly
    seasonality and this new component:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，您将看到一个新的子图与其它组件一起显示。以下图像是完整`components`图的裁剪，只显示了年度季节性和这个新组件：
- en: '![Figure 9.3 – Cropped components plot of binary additional regressors](img/Fig_9.3.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 二元附加回归器的裁剪组件图](img/Fig_9.3.jpg)'
- en: Figure 9.3 – Cropped components plot of binary additional regressors
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 二元附加回归器的裁剪组件图
- en: The trend, weekly seasonality, and yearly seasonality, which were cropped out,
    look much the same as we’ve seen before with this dataset. However, we have a
    new addition to the `components` plot, called `extra_regressors_multiplicative`.
    Had we specified some of those regressors as `additive`, we would see a second
    subplot here, called `extra_regressors_additive`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 被裁剪的趋势、每周季节性和年度季节性看起来与我们之前在这个数据集中看到的基本相同。然而，我们在`components`图中增加了一个新元素，称为`extra_regressors_multiplicative`。如果我们指定了一些回归器为`additive`，我们在这里将看到第二个子图，称为`extra_regressors_additive`。
- en: On dates where the value is at 0%, these are our *baseline* dates when the weather
    was cloudy, which we left out of the additional regressors. The other dates are
    those where the weather deviated from cloudy, which we included. We’ll take a
    more in-depth look at this in a bit. But first, let’s bring the temperature into
    our model and add a **continuous regressor**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在值为0%的日期上，这些是我们的*基准*日期，当时天气多云，我们将其排除在附加回归器之外。其他日期是那些天气偏离多云的日期，我们将其包括在内。我们将在稍后更深入地探讨这个问题。但首先，让我们将温度纳入我们的模型，并添加一个**连续回归器**。
- en: Adding continuous regressors
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加连续回归器
- en: 'In this example, we will take everything from the previous example and simply
    add one more regressor for temperature. Let’s begin by looking at the temperature
    data:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将从上一个例子中取出所有内容，并简单地添加一个温度回归器。让我们首先查看温度数据：
- en: '![Figure 9.4 – Chicago temperature over time](img/Fig_9.4.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 时间上的芝加哥温度](img/Fig_9.4.jpg)'
- en: Figure 9.4 – Chicago temperature over time
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 时间上的芝加哥温度
- en: There’s nothing too surprising about the preceding plot; daily temperatures
    rise in summer and fall in winter. It does look a lot like *Figure 5**.6* from
    [*Chapter 5*](B19630_05.xhtml#_idTextAnchor254), *Working with Seasonality*, but
    without that increasing trend. Clearly, Divvy ridership and the temperature rise
    and fall together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表并没有什么令人惊讶的地方；夏季气温上升，冬季气温下降。它看起来很像[*第5章*](B19630_05.xhtml#_idTextAnchor254)中的*图5.6*，*处理季节性*，但没有那个上升趋势。显然，Divvy的骑行量和气温的升降是一致的。
- en: 'Adding temperature, a continuous variable, is no different than adding binary
    variables. We simply add another `add_regressor` call to our Prophet instance,
    specifying `''temp''` for the name, and also including the temperature forecast
    in our `future` DataFrame. As we did before, we are fitting our model on the `train`
    DataFrame we created, which excludes the final 2 weeks’ worth of data. Finally,
    we plot the components to see what we’ve got:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 添加温度，一个连续变量，与添加二元变量没有区别。我们只需在Prophet实例中添加另一个`add_regressor`调用，指定名称为`'temp'`，并将温度预测包含在我们的`future`
    DataFrame中。像之前一样，我们在我们创建的`train` DataFrame上拟合我们的模型，该DataFrame排除了最后两周的数据。最后，我们绘制组件图以查看结果：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the `extra_regressors_multiplicative` plot shows the same fluctuations
    that our `temperature` plot displayed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`extra_regressors_multiplicative`图显示了与我们的`temperature`图相同的波动：
- en: '![Figure 9.5 – Cropped components plot of both binary and continuous additional
    regressors](img/Fig_9.5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 二元和连续附加回归器的裁剪组件图](img/Fig_9.5.jpg)'
- en: Figure 9.5 – Cropped components plot of both binary and continuous additional
    regressors
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 二元和连续附加回归器的裁剪组件图
- en: Also note that in *Figure 9**.3*, the `yearly` plot peaked at 60% effect magnitude.
    However, now we can see that temperature accounts for some of that effect. The
    `yearly` plot in *Figure 9**.5* shows a peak 30% effect, while the `extra_regressors_multiplicative`
    plot shows a 40% increase on certain summertime dates and a massive 80% decrease
    in ridership on certain wintertime dates. To break this down further, we now need
    to discuss how to interpret this data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在*图9*.*3*中，`yearly`图达到了60%的效果幅度峰值。然而，现在我们可以看到温度占了一些效果。*图9*.*5*中的`yearly`图显示了一个30%的峰值效果，而`extra_regressors_multiplicative`图显示在某些夏日日期上增加了40%，而在某些冬日日期上乘客量大幅下降了80%。为了进一步分析，我们现在需要讨论如何解释这些数据。
- en: Interpreting the regressor coefficients
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释回归器系数
- en: 'Now let’s look at how to inspect the effects of these additional regressors.
    Prophet includes a package called `utilities`, which has a function that will
    come in handy here, called `regressor_coefficients`. Let’s import it now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何检查这些额外回归器的影响。Prophet包括一个名为`utilities`的包，其中有一个在这里非常有用的函数，称为`regressor_coefficients`。现在让我们导入它：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using it is straightforward. Just pass the model as an argument and it will
    output a DataFrame with some helpful information about the extra regressors included
    in the model:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它很简单。只需将模型作为参数传递，它将输出一个DataFrame，其中包含关于模型中包含的额外回归器的某些有用信息：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s take a look at this DataFrame:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个DataFrame：
- en: '![Figure 9.6 – The regressor coefficients DataFrame](img/Fig_9.6.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 回归器系数DataFrame](img/Fig_9.6.jpg)'
- en: Figure 9.6 – The regressor coefficients DataFrame
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 回归器系数DataFrame
- en: It features a row for each extra regressor in your model. In this case, we have
    one for temperature and three more for the weather conditions we included. The
    `regressor_mode` column naturally will have strings of either `additive` or `multiplicative`,
    depending upon the effect of each specific regressor on `'y'`. The mean value
    of the pre-standardized regressor (the raw input data) is saved in the `center`
    column. If the regressor wasn’t standardized, then the value will be zero.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它为模型中的每个额外回归器提供一行。在这种情况下，我们有一个用于温度的，还有三个用于我们包含的天气条件。`regressor_mode`列自然会有`additive`或`multiplicative`的字符串，这取决于每个特定回归器对`'y'`的影响。预标准化回归器的平均值（即原始输入数据）保存在`center`列中。如果回归器没有标准化，那么该值将为零。
- en: The `coef` column is the one you really want to pay attention to. It denotes
    the expected value of the coefficient – that is, the expected impact on `'y'`
    of a unit increase in the regressor. In the preceding DataFrame, the `coef` for
    `temp` is `0.012282`. This coefficient tells us that for every degree higher than
    the `center` (`53.4`, in this case), the expected effect on ridership will be
    `0.012282`, or a 1.2% increase.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`coef`列是你真正需要关注的。它表示系数的预期值 – 即，回归器增加一个单位对`''y''`的预期影响。在前面的DataFrame中，`temp`的`coef`是`0.012282`。这个系数告诉我们，对于比`center`（在本例中为`53.4`）高出的每一度，对乘客量的预期影响将是`0.012282`，即增加1.2%。'
- en: For the `rain or snow` row, which is a binary regressor, it tells us that on
    those rainy or snowy days, then ridership will be down 20.6% compared to cloudy
    days, as that was the regressor we left out. Had we included all four weather
    conditions, to interpret this value, you would say ridership would be down 20.6%
    compared to the value predicted for the same day if modeled without including
    weather conditions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`雨或雪`行，这是一个二元回归器，它告诉我们，在那些雨天或雪天，乘客量将比多云天气低20.6%，因为这是我们留下的回归器。如果我们包括了所有四种天气条件，为了解释这个值，你会说乘客量将比如果不包括天气条件预测的同一天的值低20.6%。
- en: Finally, the columns for `'coef_lower'` and `'coef_upper'` indicate the lower
    and upper bounds, respectively, of the uncertainty interval around the coefficient.
    They are only of interest if `mcmc_samples` is set to a value greater than zero.
    `mcmc_samples` is left at the default value, as in these examples, `'coef_lower'`
    and `'coef_upper'` will be equal to `coef`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`coef_lower`和`coef_upper`列分别表示围绕系数的不确定性区间的下限和上限。只有当`mcmc_samples`设置为大于零的值时，它们才有意义。`mcmc_samples`保留默认值，在这些例子中，`coef_lower`和`coef_upper`将等于`coef`。
- en: 'Now, to conclude, we can plot each of these extra regressors individually with
    the `plot_forecast_component` function we first used in [*Chapter 6*](B19630_06.xhtml#_idTextAnchor375),
    *Forecasting Holiday Effects*. After importing it from Prophet’s `plot` package,
    we will loop through each regressor in that `regressor_coefficients` DataFrame
    to plot it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了总结，我们可以使用我们最初在[*第6章*](B19630_06.xhtml#_idTextAnchor375)，“预测假日效应”中使用的`plot_forecast_component`函数单独绘制这些额外回归变量。在从Prophet的`plot`包中导入它之后，我们将遍历`regressor_coefficients`
    DataFrame中的每个回归变量来绘制它：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We plotted all of those as subplots in one figure, resulting in the following
    diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些数据作为子图绘制在一个图中，结果如下所示：
- en: '![Figure 9.7 – Divvy extra regressor plots](img/Fig_9.7.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – Divvy额外回归变量图](img/Fig_9.7.jpg)'
- en: Figure 9.7 – Divvy extra regressor plots
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – Divvy额外回归变量图
- en: At last, we can visualize the effects of these regressors individually. The
    magnitudes of these plots should match the `coef` values in the DataFrame created
    with the `regressor_coefficients` function seen in *Figure 9**.6*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以单独可视化这些回归变量的影响。这些图的幅度应该与使用`regressor_coefficients`函数在*图9**.6*中创建的DataFrame中的`coef`值相匹配。
- en: 'One final note regarding additional regressors in Prophet: they are always
    modeled as a linear relationship. This means that, for example, our extra regressor
    of temperature, which was found to increase ridership by 1.2% for every degree
    increase, is modeling a trend that will continue to infinity. That is, if the
    temperature were to spike to 120 degrees Fahrenheit, there’s no way for us to
    change the linear relationship and inform Prophet that ridership will probably
    decrease now that it’s getting so hot outside.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Prophet中的额外回归变量还有一个最后的注意事项：它们总是被建模为线性关系。这意味着，例如，我们发现温度这个额外回归变量每增加一度，乘客量就会增加1.2%，这是在建模一个将持续到无限的趋势。也就是说，如果温度突然升高到华氏120度，我们无法改变线性关系并告知Prophet，由于天气变得非常热，乘客量可能会减少。
- en: Although this is a limitation of Prophet as currently designed, in practice,
    it is not always a great problem. A linear relationship is very often a good proxy
    for the actual relationship, especially for a small range of data, and will still
    add a lot of additional information to your model to enrich your forecasts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在目前Prophet的设计中是一个限制，但在实际应用中，这通常并不是一个大问题。线性关系通常很好地代表了实际关系，尤其是在数据范围较小的情况下，并且会给你的模型添加很多额外的信息来丰富你的预测。
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a generalized method to add any additional regressors
    beyond the holidays, which you learned how to add earlier. You learned that adding
    both binary regressors (such as weather conditions) and continuous regressors
    (such as temperature) uses the same `add_regressor` method. You also learned how
    to use the `regressor_coefficients` function in Prophet’s `utilities` package
    to inspect the effects of your additional regressors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了一种通用的方法来添加任何额外的回归变量，这些变量是在之前学习的。你了解到添加二元回归变量（如天气条件）和连续回归变量（如温度）都使用相同的`add_regressor`方法。你还学习了如何使用Prophet的`utilities`包中的`regressor_coefficients`函数来检查你的额外回归变量的影响。
- en: Although you may now want to add all sorts of extra regressors to your forecasts,
    you also learned that Prophet requires all additional regressors to have defined
    values going into the future or else there’s no information to inform a forecast.
    This is why we only forecasted 2 weeks out when using weather data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你现在可能想要向你的预测中添加各种额外的回归变量，但你同时也了解到Prophet要求所有额外的回归变量在未来的定义值，否则就没有信息来告知预测。这就是为什么我们使用天气数据时只预测了2周。
- en: In the next chapter, we are going to look at how Prophet handles outliers and
    how you can exert greater control over the process yourself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Prophet如何处理异常值，以及你如何可以自己更多地控制这个过程。
