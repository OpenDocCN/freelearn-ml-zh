- en: How to Solve All Machine Learning Problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何解决所有机器学习问题
- en: Welcome to the book *Go Machine Learning Projects*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎阅读《Go Machine Learning Projects》这本书。
- en: This is a rather odd book. It's not a book about how **machine learning** (**ML**)
    works. In fact, originally it was decided that we will assume that the readers
    are familiar with the **machine learning** (**ML**) algorithms I am to introduce
    in these chapters. Doing so would yield a rather empty book, I feared. If the
    reader knows the ML algorithm, what happens next is to simply apply the ML algorithm
    in the correct context of the problem! The ten or so chapters in this book would
    be completed in under 30 pages—anyone who's written a grant report for government
    agencies would have experience writing such things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本相当奇特的书。它不是一本关于**机器学习**（**ML**）如何工作的书。事实上，最初的决定是我们将假设读者熟悉我在这些章节中将要介绍的**机器学习**（**ML**）算法。这样做会得到一本相当空洞的书，我担心。如果读者知道ML算法，接下来要做的就是简单地将ML算法应用于问题的正确上下文中！这本书的10章左右的内容可以在不到30页内完成——任何为政府机构撰写过拨款报告的人都会有这样的写作经验。
- en: So what is this book going to be about?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这本书将要讲述些什么呢？
- en: It's going to be about applying ML algorithms within a specific, given context
    of the problem. These problems are concrete, and are specified by me on a whim.
    But in order to explore the avenues of the application of ML algorithms to problems,
    the reader must first be familiar with algorithms and the problems! So, this book
    has to strike a very delicate balance between understanding the problem, and understanding
    the specific algorithm used to solve the problem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书将要讲述的是在特定的问题上下文中应用ML算法。这些问题是具体的，由我一时兴起指定的。但是，为了探索ML算法应用于问题的途径，读者必须首先熟悉算法和问题！因此，这本书必须在理解问题和理解解决问题的具体算法之间找到一个非常微妙的平衡。
- en: But before we go too far, what is a problem? And what do I mean when I say *algorithm*?
    And what's with this *machine learning* business?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们走得太远之前，什么是问题？当我提到*算法*时，我指的是什么？还有这个*机器学习*是怎么回事？
- en: What is a problem?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是问题？
- en: In colloquial use, a problem is something to be overcome. When people say they
    have money problems, the problem may be overcome simply by having more money.
    When someone has a mathematical problem, the problem may be overcome by mathematics.
    The thing or process used to overcome a problem is called a **solution**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常用语中，问题是要克服的事情。当人们说他们有金钱问题时，问题可能仅仅通过拥有更多的钱就能解决。当某人有一个数学问题时，问题可能通过数学就能解决。用来克服问题的东西或过程被称为**解决方案**。
- en: At this point, it may seem a little strange for me to define what is a common
    word. Ah, but precision and clarity of mind are required in order to solve problems
    with ML. You have to be precise about what exactly you are trying to solve.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我定义一个常见的词可能看起来有点奇怪。啊，但为了用机器学习解决问题，需要精确和清晰的思维。你必须精确地知道你到底在尝试解决什么。
- en: Problems can be broken down into subproblems. But at some point, it no longer
    makes sense to break down those problems any further. I put it to the reader that
    there are different types of problems out there. So numerous are the types of
    problems that it is not worthwhile enumerating them all. Nonetheless, the urgency
    of a problem should be considered.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 问题可以被分解为子问题。但到了某个点，进一步分解这些问题就不再有意义了。我向读者提出，世界上有不同类型的问题。问题的类型如此之多，以至于不值得一一列举。尽管如此，问题的紧迫性应该被考虑。
- en: If you're building a photo organization tool (perhaps you are planning to rival
    Google Photos or Facebook), then recognizing faces in a photo is less urgent than
    knowing where to store, and how to retrieve a photo. If you do not know how to
    solve the latter, all the knowledge in the world to solve the former would be
    wasted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个照片组织工具（也许你打算与谷歌照片或Facebook竞争），那么在照片中识别人脸的紧迫性不如知道照片存储在哪里以及如何检索照片。如果你不知道如何解决后者，那么解决前者所需的所有知识都将浪费。
- en: I argue that urgency, despite its subjectivity, is a good metric to use when
    considering subproblems of the larger problem. To use a set of more concrete examples,
    consider three scenarios that all require some sort of ML solutions, but the solutions
    required are of different urgency. These examples are clearly made up examples,
    and have little or no bearing on real life. Their entire purpose is to make a
    point.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，尽管紧迫性具有主观性，但在考虑更大问题的子问题时，紧迫性是一个很好的衡量标准。使用一些更具体的例子，考虑三种都需要某种机器学习解决方案的场景，但所需的解决方案的紧迫性不同。这些例子明显是虚构的，与现实生活关系不大。它们全部的目的只是为了说明一个观点。
- en: First, consider a real estate intelligence business. The entire survival of
    the business depends on being able to correctly predict the prices of houses to
    be sold, although perhaps they also make their money on some form of second market.
    To them, the ML problem faced is **urgent**. They would have to fully understand
    the ins and outs of the solution, otherwise they risk going out of business. In
    the view of the popular urgency/importance split, the ML problem can also be considered
    **important** and **urgent**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑一个房地产智能业务。整个业务的生存依赖于能否正确预测即将出售的房屋价格，尽管也许他们还通过某种形式的二级市场赚钱。对他们来说，面临的机器学习问题是**紧迫**的。他们必须完全理解解决方案的来龙去脉，否则他们可能会面临倒闭的风险。在流行的紧迫性/重要性划分中，机器学习问题也可以被认为是**重要**且**紧迫**的。
- en: Second, consider an online supermarket. They would like to know which groupings
    of products sell best together so they can bundle them to appear more competitive.
    This is not the core business activity, hence the ML problem faced is less urgent
    than the previous example. Some knowledge about how the solution works would be
    necessary. Imagine their algorithm says that they should bundle diarrhea medication
    with their home brand food products. They'd need to be able to understand how
    the solution came to that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑一个在线超市。他们想知道哪些产品组合的销售最好，以便他们可以捆绑销售以更具竞争力。这并不是核心业务活动，因此他们面临的机器学习问题比前一个例子不那么紧迫。了解解决方案的工作原理是必要的。想象一下，他们的算法说他们应该将腹泻药物与他们的自有品牌食品产品捆绑销售。他们需要能够理解解决方案是如何得出这个结论的。
- en: Lastly, consider the aforementioned photo application. Facial recognition is
    a nice *bonus* feature, but not the main feature. Therefore, the ML problem is
    least urgent amongst the three.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑前面提到的照片应用程序。面部识别是一个很好的**额外**功能，但不是主要功能。因此，在三个问题中，机器学习问题最不紧迫。
- en: Different urgencies lead to different requirements when it comes to solving
    the problems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的紧迫性会导致在解决问题时产生不同的需求。
- en: What is an algorithm?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是算法？
- en: The previous section has been pretty diligent in the use of the term *algorithm*.
    Throughout this book, the term is liberally sprinkled, but is always used judiciously.
    But what is an algorithm?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节在术语*算法*的使用上相当勤奋。在这本书中，这个术语被广泛使用，但总是谨慎使用。但什么是算法？
- en: To answer that, well, we must first ask, what is a program? A program is a series
    of steps to be performed by the computer. An algorithm is a set of rules that
    will solve the problem. A ML algorithm is hence a set of rules to solve a problem.
    They are implemented as a program on a computer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，首先，我们必须先问，什么是程序？程序是一系列由计算机执行的步骤。算法是一套解决问题的规则。因此，机器学习算法是一套解决问题的规则。它们作为程序在计算机上实现。
- en: One of the most eye-opening moments in truly and deeply understanding what exactly
    an algorithm is for me was an experience I had about 15 years ago. I was staying
    over at a friend's place. My friend had a seven year old child, and the friend
    was exasperated at trying to get her child to learn programming as her child had
    been too stubborn to learn the discipline of syntax. The root cause, I surmised,
    was that the child had not understood the idea of an algorithm. So the following
    morning, we tasked the child to make his own breakfast. Except he wasn't to make
    his own breakfast. He was to write down a series of steps that his mother was
    to follow to the letter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，真正深入理解算法究竟是什么的一个启发性的时刻是大约15年前的一次经历。我在一个朋友家过夜。我的朋友有一个七岁的孩子，朋友在试图让孩子学习编程时感到非常沮丧，因为孩子太固执，不愿意学习语法规则。我推测，根本原因在于孩子没有理解算法的概念。所以第二天早上，我们让孩子自己准备早餐。但他不是自己准备早餐。他需要写下一系列步骤，他的母亲必须严格按照这些步骤执行。
- en: The breakfast was simple—a bowl of cornflakes in milk. Nonetheless, it took
    the child some eleven attempts to get a bowl of cereal. It ended in tears and
    plenty of milk and cereal on the countertop, but it was a lesson well learned
    for the child.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 早餐很简单——一碗牛奶玉米片。然而，孩子尝试了十一次才得到一碗谷物食品。结果是泪水、大量的牛奶和谷物食品洒在台面上，但对孩子来说，这是一次很好的学习。
- en: This may seem like wanton child abuse. but it served me well too. In particular,
    the child said to his mother and me, in paraphrase, *But you already know how
    to make cereal; why do you need instructions to do so?* His mum responded, *think
    of this as teaching me how to to make computer games*. Here we have a meta notion
    of an algorithm. The child giving instructions on how to make cereal is teaching
    the child how to program; is itself an algorithm!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是任意的儿童虐待，但这也对我大有裨益。特别是，孩子对他的母亲和我（用概括的方式）说：“但你已经知道如何制作谷物食品；为什么你需要指令来做这件事？”他的母亲回答：“把这看作是教我如何制作电脑游戏。”这里有一个关于算法的元概念。那个指导如何制作谷物食品的孩子正在教孩子如何编程；本身就是一个算法！
- en: A ML algorithm can refer to the algorithm that is learned, or the algorithm
    that teaches the machine to use the correct algorithm. For the most part of this
    book, we shall refer to the latter, but it's quite useful to think of the former
    as well, if only as a mental exercise of sorts. For the most parts since Turing,
    we can substitute algorithm with machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习算法可以指被学习的算法，或者指教机器使用正确算法的算法。在这本书的大部分内容中，我们将指后者，但将前者视为一种精神锻炼也是很有用的。自从图灵以来，我们可以用机器来代替算法。
- en: Take some time to go through these sentences after reading the following section.
    It will help in clarifying what I mean upon a second read.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读以下部分之后，花些时间通读这些句子。这有助于在第二次阅读时澄清我的意思。
- en: What is machine learning?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是机器学习？
- en: So what then is ML? As the word may hint, it's the ML to do something. Machines
    cannot learn the same way as humans can, but they can definitely emulate some
    parts of human learning. But what are they supposed to learn? Different algorithms
    learn different things, but the shared themes are that the machines learn a program.
    Or to put in less specific terms, the machine learns to *do* the correct thing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是机器学习（ML）？正如这个词可能暗示的，它是做某事的机器学习。机器不能像人类那样学习，但它们确实可以模仿人类学习的一些部分。但它们应该学习什么呢？不同的算法学习不同的事情，但共同的主题是机器学习一个程序。或者用不那么具体的话来说，机器学习如何*做*正确的事情。
- en: What then is the correct thing? Not wanting to open a philosophical can of worms,
    the correct thing is what we, as human programmers of the computer, define as
    the correct thing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是正确的事情？不想打开一个哲学的罐头，正确的事情是我们作为计算机的人类程序员定义的正确的事情。
- en: 'There are multiple classification schemes of ML systems, but amongst the most
    common classification schemes, is one that splits ML into two types: supervised
    learning and unsupervised learning. Throughout this book we will see examples
    of both, but it''s my opinion that such forms of classification are squarely in
    the *good to know but not operationally important* area of the brain. I say so
    because outside of a few well-known algorithms, unsupervised learning is still
    very much under active research. Supervised learning algorithms are too, but have
    been used in industry for longer than the unsupervised algorithms. That is not
    to say that unsupervised learning is not of value—a few have escaped the ivory
    towers of academia and have proven to be quite useful. We shall explore **K-means**
    and **k-Nearest Neighbors** (**KNN**) in one of the chapters.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习系统有多种分类方案，但在最常见的分类方案中，是将机器学习分为两种类型：监督学习和无监督学习。在这本书的整个过程中，我们将看到这两种类型的例子，但在我看来，这种分类形式完全属于“知道好但操作上不重要”的大脑领域。我之所以这么说，是因为除了少数著名的算法之外，无监督学习仍然非常活跃地处于研究之中。监督学习算法也是如此，但它们在工业界的使用时间比无监督学习算法要长。这并不是说无监督学习没有价值——一些已经从学术象牙塔中走出来，并被证明非常有用。我们将在其中一章中探讨**K-means**和**k-最近邻**（**KNN**）。
- en: Let's suppose for now we have a machine learning algorithm. The algorithm is
    a black box - we don't know what goes on inside. We feed it some data. And through
    its internal mechanisms, it produces an output. The output may not be correct.
    So it checks for whether the output is correct or not. If the output is not correct,
    it changes its internal mechanism, and tries again and again until the output
    is correct. This is how machine learning algorithms work in general. This is called
    **training**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设现在我们有一个机器学习算法。这个算法是一个黑盒——我们不知道里面发生了什么。我们给它一些数据。然后通过其内部机制，它产生一个输出。输出可能不正确。所以它会检查输出是否正确。如果输出不正确，它会改变其内部机制，并一次又一次地尝试，直到输出正确。这就是机器学习算法通常是如何工作的。这被称为**训练**。
- en: There are notions of what "correct" means of course. In supervised learning
    situations, we, the humans provide the machine with examples of correct data.
    In unsupervised learning situations, the notion of correctness relies on other
    metrics like distances between values. Each algorithm has its own specifics, but
    in general machine learning algorithms are as described.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有关于“正确”含义的概念。在监督学习的情况下，我们人类向机器提供正确数据的示例。在无监督学习的情况下，正确性的概念依赖于其他指标，如值之间的距离。每个算法都有其特定的细节，但一般来说，机器学习算法正如描述的那样。
- en: Do you need machine learning?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要机器学习吗？
- en: 'Perhaps the most surprising question to ask, is whether you need machine learning
    to solve your problem. There is after all, a good reason why this section is the
    fourth in the chapter—we must understand what exactly is a problem is; and understand
    what an algorithm is before we can raise the question: do you need machine learning?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最令人惊讶的问题是，你是否需要机器学习来解决你的问题。毕竟，这个章节的这一节是第四部分，有一个很好的理由——我们必须了解问题究竟是什么；在提出问题之前，我们必须了解算法是什么：你是否需要机器学习？
- en: 'The first question to ask is of course: do you have a problem you need to solve?
    I assume the answer is yes, because we live in the world and are part of the world.
    Even ascetics have problems they need solved. But perhaps the question should
    be more specific: do you have a problem that can be solved with machine learning?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，首先要问的问题是：你有没有需要解决的问题？我假设答案是肯定的，因为我们生活在这个世界上，是这个世界的一部分。即使是苦行僧也有需要解决的问题。但也许问题应该更具体：你有没有可以用机器学习解决的问题？
- en: I've consulted a fair bit, and in my early days of consulting, I'd eagerly say
    yes to most enquiries. Ah, the things one does when one is young and inexperienced.
    The problems would often show up after I said yes. It turns out many of these
    consulting enquiries would be better served by having a more thorough understanding
    of the business domain and a more thorough understanding of computer science in
    general.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我咨询过很多次，在我咨询的早期，我会毫不犹豫地接受大多数咨询请求。啊，年轻时无知所做的事情。问题往往在我答应之后出现。结果发现，许多这些咨询请求最好通过更深入地了解业务领域和更深入地了解计算机科学来解决。
- en: 'A common variant of a problem that is brought to me often requires information
    retrieval solutions, not machine learning solutions. Consider the following request
    I received several years ago:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 经常带到我面前的一个常见问题需要信息检索解决方案，而不是机器学习解决方案。考虑以下几年前的请求：
- en: Hi Xuanyi,
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Hi Xuanyi，
- en: I am XXXX. We met at YYYY meetup a few months ago. My company is currently building
    a machine learning system that extracts relationships between entities. Wondering
    if you may be interested to catch up for coffee?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我是XXXX。我们几个月前在YYYY聚会上见过面。我的公司目前正在构建一个提取实体之间关系的机器学习系统。想知道你是否愿意一起喝咖啡？
- en: Naturally, this piqued my interest—relationship extraction is a particularly
    challenging task in machine learning. I was young, and ever so eager to get my
    hands on tough problems. So I sat down with the company, and we worked out what
    was needed based on surface information. I suggested several models, all of which
    were greeted with enthusiasm. We finally settled on an SVM-based model. Then I
    got to work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这激起了我的兴趣——关系抽取是机器学习中一个特别具有挑战性的任务。我那时年轻，对解决难题充满热情。所以我坐下来与公司一起工作，根据表面信息确定需要什么。我提出了几个模型，所有这些模型都受到了热情的欢迎。我们最终确定了一个基于SVM的模型。然后我开始着手工作。
- en: The first step in any machine learning project is to collect data. So I did.
    Much to my surprise, the data was already neatly classified, and entities already
    identified. Further, the entities have a static, unchanging relationship. One
    type of entity would have a permanent relationship with another type of entity.
    What was the machine learning problem?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任何机器学习项目的第一步是收集数据。所以我做了。令我惊讶的是，数据已经被整齐地分类，实体已经被识别。此外，实体之间有一种静态的、不变的关系。一种类型的实体将与另一种类型的实体保持永久的关系。那么机器学习问题是什么？
- en: I brought this up after one and a half month's worth of data gathering. What
    was going on? We have clean data, we have clean relationships. All new data had
    clean relationships. Where is the need for machine learning?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集了一个半月的数据之后，我提出了这个问题。发生了什么？我们有干净的数据，我们有干净的关系。所有新的数据都有干净的关系。机器学习的需求在哪里？
- en: It later emerged that the data came from manual data input, which was at the
    time required by law. The entity relationships were defined fairly strictly. The
    only data requirement they really needed was a cleaned up database entity-relationship
    diagram. Because their database structure was so convoluted, they could not really
    see that all they needed to do was to define a foreign-key relationship to enforce
    the relationship. When I had requested the data, the data had came from individual
    SQL queries. There was no need for machine learning!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 后来发现，数据来自手动数据输入，这在当时是法律要求的。实体关系被相当严格地定义。他们真正需要的数据要求只是一个清理过的数据库实体关系图。因为他们的数据库结构如此复杂，他们实际上看不到他们真正需要做的是定义一个外键关系来强制关系。当我要求数据时，数据是从单个SQL查询中获得的。根本不需要机器学习！
- en: To their DBA's credit, that was what their DBA had been saying all along.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的数据库管理员（DBA）值得赞扬，他们的DBA一直在说。
- en: 'This taught me a lesson: Always find out if someone really needs machine learning
    solutions before spending time working on it.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我一个教训：在花费时间工作之前，一定要弄清楚某人是否真的需要机器学习解决方案。
- en: I've since settled on a very easy way of determining if someone needs machine
    learning. These are my rules of thumb
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经确定了一种非常简单的方法来判断某人是否需要机器学习。这些是我的经验法则
- en: 'Can the problem in this form: "Given X, I want to predict Y"'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个问题能否以这样的形式表达：“给定X，我想预测Y”
- en: 'A what-question is generally suspect. A what question looks like this: "I want
    to know what is our conversion rate for XYZ product"'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个“是什么”的问题通常是有问题的。一个“是什么”问题看起来像这样：“我想知道XYZ产品的转化率是多少”
- en: The general problem solving process
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般的问题解决过程
- en: 'Only if the general rules of thumbs are fulfilled then will I engage to further.
    The general problem solving process goes as follows for me:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当一般性的经验法则得到满足时，我才会进一步参与。对我来说，一般的问题解决过程如下：
- en: Identify clearly the problems.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确识别问题。
- en: Translate the problems into a more concrete statement.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将问题转化为更具体的状态。
- en: Gather data
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集数据
- en: Perform exploratory data analysis
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行探索性数据分析
- en: Determine the correct machine learning solution to use
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定正确的机器学习解决方案
- en: Build a model.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立模型。
- en: Train the model.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练模型。
- en: Test the model.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试模型。
- en: Throughout the chapters in this book, the pattern above will be followed. The
    exploratory data analysis sections will be only done for the first few chapters.
    It's implicit that those would have been done in the later chapters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的各章节中，将遵循上述模式。探索性数据分析部分将只在前几章中进行。这隐含着这些工作会在后面的章节中完成。
- en: I have attempted to be clear in the section headings on what exactly are we
    trying to solve, but writing is a difficult task, so I may miss some.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图在章节标题中清楚地说明我们试图解决什么问题，但写作是一项困难的任务，所以我可能遗漏了一些。
- en: What is a model?
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模型？
- en: '**All models are wrong; but some are useful.**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有模型都是错误的；但有些是有用的**。'
- en: Now it would be very remarkable if any system existing in the real world could
    be exactly represented by any simple model. However, cunningly chosen parsimonious
    models often do provide remarkably useful approximations. For example, the law
    ![](img/e38bd216-7a23-49a8-a7bc-d7b57fbd5cb9.png) relating pressure ![](img/69e846db-b496-4c31-8c87-d999f5dd8cd3.png),
    volume ![](img/ce303fd4-6e01-4d71-9a0b-98191ffe55c8.png)and temperature ![](img/16692458-a958-4fcd-935c-6abb17dd6bff.png)of
    an "ideal" gas via a constant R is not exactly true for any real gas, but it frequently
    provides a useful approximation and furthermore its structure is informative since
    it springs from a physical view of the behavior of gas molecules.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果任何存在于现实世界中的系统能够被任何简单的模型**精确**地表示，那将是非常了不起的。然而，巧妙选择的简约模型通常确实提供了非常有用的近似。例如，通过常数R关联压力![图片](img/e38bd216-7a23-49a8-a7bc-d7b57fbd5cb9.png)、体积![图片](img/69e846db-b496-4c31-8c87-d999f5dd8cd3.png)和温度![图片](img/16692458-a958-4fcd-935c-6abb17dd6bff.png)的“理想”气体的定律对于任何真实气体来说并不完全正确，但它经常提供有用的近似，而且它的结构是有启发性的，因为它源于对气体分子行为的物理观点。
- en: For such a model there is no need to ask the question "Is the model true?".
    If "truth" is to be the "whole truth" the answer must be "No". The only question
    of interest is "Is the model illuminating and useful?".
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的模型，没有必要问“模型是否正确？”如果“真理”是“全部真理”，那么答案必须是“不”。唯一有趣的问题是“模型是否具有启发性和实用性？”
- en: '- George Box (1978)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '- 乔治·博克斯（1978年）'
- en: Model train are a fairly common hobby, despite being lampooned by the likes
    of The Big Bang Theory. A model train is not a real train. For one, the sizes
    are different. Model trains do not work exactly the same way a real train does.
    There are gradations of model trains, each being more similar to actual trains
    than the previous.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 模型火车是一种相当常见的爱好，尽管像《生活大爆炸》这样的节目对其进行讽刺。模型火车不是真正的火车。首先，尺寸不同。模型火车的运作方式并不完全像真正的火车。模型火车有不同等级，每个等级都比前一个更接近实际火车。
- en: A model is in that sense a representation of reality. What do we represent it
    with? By and large, numbers. A model is a bunch of numbers that describes reality,
    and a bit more.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，模型是现实的表示。我们用什么来表示它？总的来说，是数字。模型是一组描述现实的数字，还有更多。
- en: Every time I try to explain what a model is I inevitably get responses along
    the lines of "You can't just reduce us to a bunch of numbers!". So what do I mean
    "numbers"?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我试图解释什么是模型时，我不可避免地会得到类似“你不能把我们简化为一堆数字！”这样的回应。那么我所说的“数字”是什么意思呢？
- en: 'Consider the following right angle triangle:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下直角三角形：
- en: '![](img/2175de40-79f6-4240-81e4-4ce91476d7e6.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2175de40-79f6-4240-81e4-4ce91476d7e6.png)'
- en: 'How do we describe *all* right angle triangles? We might say something like
    this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何描述**所有**直角三角形？我们可能会这样说：
- en: '![](img/0e78b35e-6940-4502-a75b-1143e54c59dd.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e78b35e-6940-4502-a75b-1143e54c59dd.png)'
- en: This says that the sum of all angles in a right angle adds up to 180 degrees,
    and there exists an angle that is 90 degrees. This is sufficient to describe *all*
    right angle triangles in Cartesian space.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着直角三角形中所有角度的总和为180度，并且存在一个90度的角度。这足以描述笛卡尔空间中的**所有**直角三角形。
- en: But is the description the triangle itself? It is not. This issue has plagued
    philosophers ever since the days of Aristotle.  We shall not enter into a philosophical
    discussion for such a discussion will only serve to prolong the agony of this
    chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，描述的是三角形本身吗？不是的。自从亚里士多德时代以来，这个问题一直困扰着哲学家。我们不会进入哲学讨论，因为这样的讨论只会延长本章的痛苦。
- en: So for our purposes in this chapter, we'll say that a model is the values that
    describe reality, *and* the algorithm that produces those values. These values
    are typically numbers, though they may be of other types as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章的用途中，我们将说，模型是描述现实的值，**以及**产生这些值的算法。这些值通常是数字，尽管它们也可能是其他类型。
- en: What is a good model?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是好的模型？
- en: A model is a bunch of values that describe the world, alongside the program
    that produces these values. That much, we have concluded from the previous section.
    Now we have to pass some value judgments on models - whether a model is good or
    bad.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是一组描述世界的值，以及产生这些值的程序。这一点，我们从上一节中得出结论。现在我们必须对模型进行一些价值判断——模型是好是坏。
- en: A good model needs to describe the world accurately. This is said in the most
    generic way possible. Described thus, this statement about a good model encompasses
    many notions. We shall have to make this abstract idea a bit more concrete to
    proceed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的模型需要准确地描述世界。这是以最通用的方式表达的。这样描述，关于一个好的模型的说法涵盖了多个概念。我们必须使这个抽象的想法更加具体，以便继续前进。
- en: A machine learning algorithm is trained on a bunch of data. To the machine,
    this bunch of data is the world. But to us, the data that we feed the machine
    in for training is not the world. To us humans, there is much more to the world
    than what the machine may know about. So when I say "a good model needs to describe
    the world accurately", there are two senses to the word "world" that applies -
    the world as the machine knows, and the world as we know it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习算法是在大量数据上训练的。对机器来说，这堆数据就是世界。但对我们来说，我们为训练机器提供的数据并不是世界。对我们人类来说，世界比机器可能知道的要复杂得多。所以当我说“一个好的模型需要准确地描述世界”时，这里的“世界”有两个含义——机器所知道的世界，以及我们所知道的世界。
- en: The machine has only seen portions of the world as we know it. There are parts
    of the world the machine has not seen. So it is then a good machine learning model
    when it is able to provide the correct outputs for inputs it has not seen yet.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 机器只看到了我们所知道的世界的一部分。有些世界的一部分机器没有看到。因此，当机器能够为它尚未看到的输入提供正确的输出时，它就是一个好的机器学习模型。
- en: As a concrete example, let's once again suppose that we have a machine learning
    algorithm that determines if an image is that of a hot dog or not. We feed the
    model images of hot dogs and hamburgers. To the machine, the world are simply
    images of hot dogs and hamburgers. What happens when we pass in as input, an image
    of vegetables? A good model would be able to **generalize** and say it's not a
    hot dog. A poor model would simply crash.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体的例子，让我们再次假设我们有一个机器学习算法，该算法用于确定一张图片是否是热狗。我们向模型提供热狗和汉堡的图片。对机器来说，世界仅仅是热狗和汉堡的图片。当我们输入蔬菜的图片时会发生什么？一个好的模型能够**泛化**并说这不是热狗。一个差的模型会直接崩溃。
- en: And thus with this analogy, we have defined a good model to be one that generalizes
    well to unknown situations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过这个类比，我们定义了一个好的模型，即能够很好地泛化到未知情况。
- en: Often, as part of the process of building machine learning systems, we would
    want to put this notion to test. So we would have to split our dataset into testing
    and training datasets. The machine would be trained on the training dataset, and
    to test how good the model is once the training has completed, we will then feed
    in the testing dataset to the machine. It's assumed of course that the machine
    has never seen the testing dataset. A good machine learning model hence would
    be able to generate the correct output for the testing dataset, despite never
    having seen it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，作为构建机器学习系统过程的一部分，我们可能想要对这个概念进行测试。因此，我们必须将我们的数据集分成测试集和训练集。机器将在训练集上训练，为了测试模型在训练完成后有多好，我们将测试集输入到机器中。当然，假设机器从未见过测试集。因此，一个好的机器学习模型应该能够为测试集生成正确的输出，尽管它从未见过它。
- en: On writing and chapter organization
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于写作和章节组织
- en: A note on the writing in this book. As you may already have guessed, I have
    decided to settle upon a more conversational tone. I find this tone to be friendlier
    to the reader who may be intimidated by machine algorithms. I am also, if you
    have not yet noticed, quite opinionated in my writing. I strive to make clear,
    through my writing, what is and what ought to be. Application of Hume's fork is
    at the discretion at the reader. But as a quick guide, when talking about algorithms
    and how they work, they are `is` statements. When talking about what should be
    done, and organization of code, they are ought statements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本书的写作。正如你可能已经猜到的，我决定采用更口语化的语气。我发现这种语气对那些可能被机器算法吓到的读者来说更友好。如果你还没有注意到，我在写作中也很有自己的观点。我努力通过我的写作阐明什么是事实，什么是应该做的。应用休谟的划分标准由读者自行决定。但作为一个快速指南，当我们谈论算法及其工作原理时，它们是“是”的陈述。当我们谈论应该做什么，以及代码的组织时，它们是“应该”的陈述。
- en: There are two general patterns in the design of the chapters of this book. First,
    the problems get harder as the chapters go on. Second, one may optionally want
    to mentally divide the chapters into three different parts. Part 1—[Chapters 2](12c81095-6fcf-4da9-b554-6367d45b34f8.xhtml),
    *Linear Regression - House Price Prediction*, [Chapter 3](d0447032-8c26-4198-a13c-b41ec20c02e8.xhtml),
    *Classification - Spam Email Detection*, [Chapter 4](fdb27bce-1c0b-4264-94bd-6c56382b36bc.xhtml),
    *Decomposing CO2 Trends Using Time Series Analysis*, [Chapter 7](4c71e400-fde5-467f-a1ee-52300e326504.xhtml),
    *Convolutional Neural Networks - MNIST Handwriting Recognition*, [Chapter 8](26529196-995f-4689-91d7-0039b62337e9.xhtml),
    *Basic Facial Detection*) correspond to readers who have an urgent ML problem.
    Part 2—[Chapters 5](d6a6876a-eca1-44f0-8ee6-9d949e694b6e.xhtml), *Clean Up Your
    Personal Twitter Timeline by Clustering Tweets*, [Chapter 9](c0a3360f-762c-49b4-a013-d1a99a23fcfa.xhtml),
    *Hot Dog or Not Hot Dog - Using External Services*, [Chapter 6](d54b14d1-3403-4f2a-a98e-dd12adfe585a.xhtml),
    *Neural Networks; MNIST Handwriting Recognition*, [Chapter 7](4c71e400-fde5-467f-a1ee-52300e326504.xhtml),
    *Convolutional Neural Networks - MNIST Handwriting Recognition*, [Chapter 8](26529196-995f-4689-91d7-0039b62337e9.xhtml),
    *Basic Facial Detection*) are for those who have ML problems akin to the second
    example. Part 3, the last two chapters, are for people whose machine learning
    problems are not as urgent, but still require a solution.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本书章节的设计中存在两种一般模式。首先，随着章节的进行，问题会变得越来越难。其次，有人可能希望将章节心理上分为三个不同的部分。第一部分——[第2章](12c81095-6fcf-4da9-b554-6367d45b34f8.xhtml)，*线性回归
    - 房价预测*，[第3章](d0447032-8c26-4198-a13c-b41ec20c02e8.xhtml)，*分类 - 垃圾邮件检测*，[第4章](fdb27bce-1c0b-4264-94bd-6c56382b36bc.xhtml)，*使用时间序列分析分解CO2趋势*，[第7章](4c71e400-fde5-467f-a1ee-52300e326504.xhtml)，*卷积神经网络
    - MNIST手写识别*，[第8章](26529196-995f-4689-91d7-0039b62337e9.xhtml)，*基本人脸检测*）对应于那些有紧急机器学习问题需求的读者。第二部分——[第5章](d6a6876a-eca1-44f0-8ee6-9d949e694b6e.xhtml)，*通过聚类推文清理个人Twitter时间线*，[第9章](c0a3360f-762c-49b4-a013-d1a99a23fcfa.xhtml)，*热狗还是不是热狗
    - 使用外部服务*，[第6章](d54b14d1-3403-4f2a-a98e-dd12adfe585a.xhtml)，*神经网络；MNIST手写识别*，[第7章](4c71e400-fde5-467f-a1ee-52300e326504.xhtml)，*卷积神经网络
    - MNIST手写识别*，[第8章](26529196-995f-4689-91d7-0039b62337e9.xhtml)，*基本人脸检测*）是为那些有类似第二个例子中机器学习问题的人准备的。第三部分，最后两章，是为那些机器学习问题不那么紧急但仍需要解决方案的人准备的。
- en: Up to [Chapter 8](26529196-995f-4689-91d7-0039b62337e9.xhtml), *Basic Facial
    Detection*, for each chapter there will typically be one or two sections dedicated
    to the explanation of the algorithm itself. I strongly believe that one cannot
    write any meaningful program without at least a basic understanding of the algorithms
    they are using. Sure, you may **use** an algorithm that has been provided by someone
    else, but, without a proper understanding, it's **meaningless**. Sometimes meaningless
    programs may produce results, just as sometimes an elephant may appear to know
    how to do arithmetic, or a pet dog may appear to do a sophisticated feat, like
    speak.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到[第8章](26529196-995f-4689-91d7-0039b62337e9.xhtml)，*基本人脸检测*，为止，对于每一章，通常会有一个或两个专门用于解释算法本身的章节。我坚信，如果不至少对所使用的算法有一个基本理解，就无法编写出任何有意义的程序。当然，你可以**使用**别人提供的算法，但如果没有恰当的理解，它就是**无意义的**。有时无意义的程序可能会产生结果，就像有时大象似乎知道如何做算术，或者宠物狗似乎能完成复杂的动作，比如说话。
- en: This also means that I may sound rather dismissive of some ideas. For example,
    I am dismissive of using ML algorithms to predict stock prices. I do not believe
    that doing so will be a productive endeavor, because of an understanding of the
    basic processes that generate prices in a stock market, and the confounding effects
    of time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我可能听起来对某些想法相当轻视。例如，我对使用机器学习算法来预测股价持轻视态度。我不相信这样做将是一项富有成效的努力，因为我对生成股市价格的基本过程以及时间的影响有深刻的理解。
- en: Time, however, will tell if I am right or wrong. It may well be that one day
    someone will invent a ML algorithm that will work perfectly well on dynamical
    systems, but not right now, right here. We are at the dawn of a new era of computation,
    and we must strive to understand things as best as we can. Often you can learn
    quite a bit from history. Therefore, I also strive to insert important historical
    anecdotes on how certain things came to be. These are by no means a comprehensive
    survey. In fact, it is done without much regularity. However, I do rather hope
    that it adds to the flavor of the book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，时间会证明我是对还是错。也许有一天，有人会发明一个在动态系统上完美工作的机器学习算法，但现在还不是时候，就在这里。我们正处于计算新时代的黎明，我们必须尽力去理解事物。通常，你可以从历史中学到很多东西。因此，我也努力插入一些重要的历史轶事，说明某些事物是如何形成的。这些绝对不是全面的调查。事实上，这是没有多少规律性的。然而，我非常希望它能增加这本书的风味。
- en: Why Go?
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Go？
- en: This book is a book on ML using Go. Go is a rather opinionated programming language.
    There's the Go way, or no other way at all. This may sound rather fascist, but
    it has resulted in a very enjoyable programming experience. It also makes working
    in teams rather efficient.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于使用 Go 进行机器学习的书籍。Go 是一种相当有偏见的编程语言。有 Go 的方式，或者完全没有其他方式。这听起来可能有些法西斯主义，但它确实带来了一种非常愉快的编程体验。这也使得团队合作非常高效。
- en: Further, Go is a fairly efficient language when compared to Python. I have moved
    on almost exclusively to using Go to do my ML and data science work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与 Python 相比，Go 是一种相当高效的编程语言。我几乎完全转向使用 Go 来做我的机器学习和数据科学工作。
- en: Go also has the benefit of working well cross-platform. At work, developers
    may choose to work on different operating systems. Go works well across all of
    them. The programs that are written in Go can be trivially cross-compiled for
    other platforms. This makes deployment a lot easier. There's no unnecessary mucking
    around with Docker or Kubernetes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还有一个好处，那就是它可以在跨平台上很好地工作。在工作时，开发者可能会选择在不同的操作系统上工作。Go 在所有这些操作系统上都能很好地工作。用 Go
    编写的程序可以轻松地交叉编译到其他平台。这使得部署变得容易得多。无需使用 Docker 或 Kubernetes 进行不必要的混乱。
- en: Are there drawbacks when using Go for ML? Only as a library author. In general,
    **using** Go ML libraries is painless. But in order for it to be painless, you
    must let go of any previous ways you programmed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 进行机器学习有缺点吗？仅作为库的作者。一般来说，**使用** Go 机器学习库是无痛的。但为了使其无痛，你必须放弃任何之前编程的方式。
- en: Quick start
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速开始
- en: First install Go, which can be found at [https://golang.org](https://golang.org).
    It provides comprehensive guides to Go. And now, quick start.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先安装 Go，可以在[https://golang.org](https://golang.org)找到。它提供了关于 Go 的全面指南。现在，快速开始。
- en: Functions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are the main way that anything is computed in Go.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 Go 中计算任何事物的主要方式。
- en: 'This is a function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We call `func addInt(a, b int) int`, which is the **function signature**. The
    function signature is composed of the function name, parameters, and return type(s).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `func addInt(a, b int) int`，这是 **函数签名**。函数签名由函数名称、参数和返回类型组成。
- en: The name of the function is `addInt`. Note the formatting being used. The function
    name is in camelCase—this is the preferred casing of names in Go. The first letter
    of any name, when capitalized, like `AddInt` indicates that it should be exported.
    By and large in this book we shan't worry about exported or unexported names,
    as we will be mostly using functions. But if you are writing a package, then it
    matters. Exported names are available from outside a package.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称是 `addInt`。注意所使用的格式。函数名称使用驼峰式命名法——这是 Go 中名称的首选命名方式。任何名称的首字母大写，如 `AddInt`，表示它应该被导出。总的来说，在这本书中，我们不会担心导出或未导出的名称，因为我们主要会使用函数。但如果你正在编写一个包，那么这很重要。导出的名称可以在包外部访问。
- en: 'Next, note that `a` and `b` are parameters, and both have the type `int`. We''ll
    discuss types in a bit, but the same function can also be written as:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意 `a` 和 `b` 是参数，并且它们都有 `int` 类型。我们稍后会讨论类型，但同一个函数也可以这样写：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Following that, this is what the function returns. This function `addInt` returns
    an `int`. This means when a function is called correctly, like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，这就是函数返回的内容。这个名为 `addInt` 的函数返回一个 `int` 类型。这意味着当函数被正确调用时，就像这样：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`z` will have a type `int`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`z` 将有一个 `int` 类型。'
- en: After the return type is defined, `{...}` denotes the body. When `{...}` is
    written in this book, it means the content of the function body is not as important
    for the discussion at hand. Some parts of the book may have snippets of function
    bodies, but without the signature `func foo(...)`. Again those snippets are the
    snippets under discussion. It's expected that the reader will piece together the
    function from context in the book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回类型定义之后，`{...}` 表示函数体。当本书中提到 `"{...}"` 时，意味着函数体的内容对于当前讨论并不重要。书中可能包含一些函数体的片段，但它们没有
    `func foo(...)` 的签名。再次强调，这些片段是讨论的片段。预期读者将根据书中的上下文拼凑出函数。
- en: 'A Go function may return multiple results. The function signature looks something
    like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Go 函数可以返回多个结果。函数签名看起来可能像这样：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, the difference is mainly in naming the return values. In the second example,
    the return values are named `retVal` and `err` respectively. `retVal` is of type
    `uint` and `err` is of type `error`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，区别主要在于返回值的命名。在第二个例子中，返回值分别命名为 `retVal` 和 `err`。`retVal` 是 `uint` 类型，而 `err`
    是 `error` 类型。
- en: Variables
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'This is a variable declaration:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个变量声明：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It says `a` is an `int`.  That means `a` can contain any value that has the
    type `int`. Typical `int` would be like `0`, `1`, `2`, and so on and so forth.
    It may seem odd to read the previous sentence, but *typically* is used correctly.
    All values of type `int` are typically `int`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它说 `a` 是一个 `int`。这意味着 `a` 可以包含任何具有 `int` 类型的值。典型的 `int` 值可能是 `0`、`1`、`2` 等等。阅读上一句话可能看起来有些奇怪，但
    “typically” 是正确使用的。所有 `int` 类型的值都是典型的 `int`。
- en: 'This is a variable declaration, followed by putting a value into the variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个变量声明，随后是将值放入变量中：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we're saying, define `s` as a `string`, and let the value be `"Hello World"`.
    The `:=` syntax can only be used within a function body. The main reason for this
    is not to cause the programmer to have to type `var s string = "Hello World"`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们说的是，将 `s` 定义为 `string` 类型，并让值为 `"Hello World"`。`:=` 语法只能在函数体内使用。这样做的主要原因不是让程序员不得不输入
    `var s string = "Hello World"`。
- en: 'A note about the use of variables: variables in Go should be thought of as
    buckets with a name on them, in that they hold values. The names are important
    insofar as they inform the readers about the values they are supposed to hold.
    However, names do not necessarily have to cross barriers. I frequently name my
    return values with `retVal`, but give it a different name elsewhere. A concrete
    example is shown:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量使用的一个注意事项：在 Go 中，变量应该被视为带有名称的桶，它们持有值。名称的重要性在于它们向读者传达了它们应该持有的值。然而，名称并不一定需要跨越障碍。我经常用
    `retVal` 命名返回值，但在其他地方会使用不同的名称。一个具体的例子如下：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I have taught programming and ML for a number of years now, and I believe that
    this is a hump every programmer has got to get over. Frequently students or junior
    team members may get confused by the difference in naming. They would rather prefer
    something like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经教授编程和机器学习（ML）多年，我相信这是每个程序员都必须克服的一个障碍。学生或初级团队成员可能会对命名差异感到困惑。他们更愿意看到如下这样的东西：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is fine. However again, speaking strictly from experience, this tends to
    dampen the ability to think abstractly, which is a useful skill to have, especially
    in ML. My advice is, get used to using different names, it makes you think more
    abstractly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的。然而，严格从经验来说，这往往会削弱抽象思维能力，而抽象思维能力是一种有用的技能，尤其是在机器学习（ML）中。我的建议是，习惯于使用不同的名称，这会让你更加抽象地思考。
- en: In particular, names do not persist past what my friend James Koppel calls an
    **abstraction barrier**. What is an abstraction barrier? A function is an abstraction
    barrier. Whatever happens inside the function body, happens inside the function
    body and cannot be accessed by other things in the language. Therefore if you
    name a value `fooBar` inside the function body, the meaning of `fooBar` is only
    valid within the function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，名称不会跨越我的朋友詹姆斯·科佩尔（James Koppel）所说的**抽象障碍**。什么是抽象障碍？函数是一个抽象障碍。函数体内发生的事情都在函数体内发生，并且不能被语言中的其他东西访问。因此，如果在函数体内命名一个值为
    `fooBar`，则 `fooBar` 的含义仅在函数内部有效。
- en: Later we will see another form of abstraction barrier—the package.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 后续我们将看到另一种形式的抽象障碍——包。
- en: Values
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值
- en: A value is what a program deals with. If you wrote a calculator program, then
    the values of the program are numbers. If you wrote a text search program, then
    the values are strings.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 值是程序处理的内容。如果你编写了一个计算器程序，那么程序中的值就是数字。如果你编写了一个文本搜索程序，那么值就是字符串。
- en: The programs we deal with nowadays as programmers are much more complicated
    than calculators. We deal with different types of values, ranging from number
    types (`int`, `float64`, and so on) to text (string).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在作为程序员所处理的程序，比计算器要复杂得多。我们处理不同类型的值，从数字类型（`int`、`float64`等）到文本（字符串）。
- en: 'A variable holds a value:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 变量持有值：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding line indicates that `a` is a variable that holds an `int` with
    the value `1`. We've seen previous examples with the `"Hello World"` string.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行表明`a`是一个持有`int`类型值为`1`的变量。我们之前已经看到了使用`"Hello World"`字符串的例子。
- en: Types
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Like all major programming languages (yes, including Python and JavaScript),
    values in Go are typed. Unlike Python or JavaScript however, Go''s functions and
    variables are also typed, and strongly so. What this means is that the following
    code will cause the program not to compile:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有主要的编程语言（是的，包括Python和JavaScript）一样，Go中的值是有类型的。然而，与Python或JavaScript不同的是，Go的函数和变量也是有类型的，而且非常严格。这意味着以下代码将导致程序无法编译：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sort of behavior is known outside the academic world as *strongly-typed*.
    Within academic circles, *strongly-typed* is generally meaningless.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在学术界外被称为*强类型*。在学术界，*强类型*通常没有意义。
- en: 'Go allows programmers to define their own types too:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Go也允许程序员定义他们自己的类型：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we're defining a new type `email`. The underlying kind of data is a `string`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个新的类型`email`。其底层数据类型是`string`。
- en: 'Why would you want to do this? Consider this function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么要这样做呢？考虑这个函数：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If both are `string`, it would be very easy to make a mistake—we might accidentally
    do something like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者都是`string`，就很容易出错——我们可能会不小心做些这样的事情：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In fact, you could even do this: `emailSomeone(person, address)` and the program
    would still compile correctly!'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你甚至可以这样做：`emailSomeone(person, address)`，而程序仍然可以正确编译！
- en: 'Imagine, however, if `emailSomeone` is defined thus:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，想象一下如果`emailSomeone`是这样定义的：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then the following will fail to compile:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下代码将无法编译：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a good thing—it prevents bad things from happening. No more shall be
    said on this matter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一件好事——它防止了不好的事情发生。关于这个问题就不再多说了。
- en: 'Go also allows programmers to define their own complex types:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Go也允许程序员定义他们自己的复杂类型：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we defined a new type called `Record`. It''s a `struct` that contains
    two values: `Name` of type `string` and `Age` of type `int`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了一个名为`Record`的新类型。它是一个包含两个值的`struct`：`Name`类型为`string`和`Age`类型为`int`。
- en: What is a `struct`?  Simply put, a `struct` is a data structure. The `Name`
    and `Age` in `Record` are called the **fields of the** `struct`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是`struct`？简单来说，`struct`是一种数据结构。在`Record`中的`Name`和`Age`被称为`struct`的**字段**。
- en: A `struct`, if you come from Python, is equivalent to a tuple, but acts as a
    `NamedTuple`, if you are familiar with those. The closest equivalent in JavaScript
    is that it's an object. Likewise the closest equivalent in Java is that it's a
    plain old Java object. The closest equivalent in C# would be a plain old CLR object.
    In C++, the equivalent would be plain old data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Python，`struct`相当于元组，但如果熟悉`NamedTuple`，它就像一个`NamedTuple`。在JavaScript中，最接近的等效物是一个对象。同样，在Java中，最接近的等效物是一个普通的Java对象。在C#中，最接近的等效物是一个普通的CLR对象。在C++中，等效物是普通的数据。
- en: Note my careful use of the words *closest equivalent* and *equivalent*. The
    reason why I have delayed introduction to `struct` is because in most modern languages
    that the reader is likely to come from, it may have some form of Java-esque object
    orientation. A `struct` is not a class. It's just a definition of how data is
    arranged in the CPU. Hence the comparison with Python's tuples instead of Python's
    classes, or even Python's new data classes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我谨慎使用“最接近的等效物”和“等效物”这两个词。我之所以推迟介绍`struct`，是因为在读者可能来自的大多数现代语言中，它可能有一些类似Java的对象导向形式。`struct`不是一个类。它只是CPU中数据排列的定义。因此，与Python的元组相比，而不是Python的类，甚至Python的新数据类相比。
- en: 'Given a value that is of type `Record`, one might want to extract its inner
    data. This can be done as so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个类型为`Record`的值，可能需要提取其内部数据。这可以这样完成：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The snippet here showcases a few things:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码片段展示了几个方面：
- en: How to write a struct—kinded value—simply write the name of the type, and then
    fill in the fields.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写一个结构化值——简单写出类型的名称，然后填写字段。
- en: How to read the fields of a struct—the `.Name`  syntax is used.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取结构体的字段——使用`.Name`语法。
- en: Throughout this book, I shall use `.FIELDNAME` as a notation to get the field
    name of a particular data structure. It is expected that the reader is able to
    understand which data structure I am talking about from context. Occasionally
    I may use a full term, like `r.Name`, to make it clear which fields I am talking
    about.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将使用 `.FIELDNAME` 作为获取特定数据结构字段名的符号。预期读者能够从上下文中理解我在谈论哪种数据结构。偶尔，我可能会使用全称，如
    `r.Name`，以明确指出我在谈论哪些字段。
- en: Methods
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'Let''s say we wrote these functions, and we have defined `email` as before:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们编写了这些函数，并且我们已经像之前那样定义了 `email`：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Observe that `email` is always the first type in the function parameters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `email` 总是函数参数中的第一个类型。
- en: 'Calling the functions look something like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数看起来像这样：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We may want to make that into a method of the `email` type. We can do so as
    follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要将这个变成 `email` 类型的方法。我们可以这样做：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`(e email)` is called the **receiver** of the method.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`(e email)` 被称为方法的**接收者**。'
- en: 'Having defined the methods thus, we may then proceed to call them:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这样定义了方法之后，我们就可以继续调用它们：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Observe the difference between the functions and methods. `check(e)` becomes
    `e.check()`. `send(e, "Hello World")` becomes `e.send("Hello World")`. What's
    the difference other than syntactic difference? The answer is, not much.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 观察函数和方法之间的区别。`check(e)` 变为 `e.check()`。`send(e, "Hello World")` 变为 `e.send("Hello
    World")`。除了语法上的区别之外，还有什么区别？答案是，没有多少。
- en: A method in Go is exactly the same as a function in Go, with the receiver of
    the method as the first parameter of the function. It is unlike methods of classes
    in object-oriented programming languages.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的方法与 Go 中的函数完全相同，方法的接收者作为函数的第一个参数。这与面向对象编程语言中类的方法定义不同。
- en: 'So why bother with methods? For one, it solves the expression problem quite
    neatly. To see how, we''ll look at the feature of Go that ties everything together
    nicely: interfaces.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么还要使用方法呢？一方面，它非常巧妙地解决了表达式问题。要了解如何做到这一点，我们将查看将一切联系在一起的 Go 的特性：接口。
- en: Interfaces
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'An interface is a set of methods. We can define an interface by listing out
    the methods it''s expected to support. For example, consider the following interface:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一组方法。我们可以通过列出它预期支持的方法来定义一个接口。例如，考虑以下接口：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we are defining `a` to be a variable that has the type `interface{ check()
    }`. What on earth does that mean?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义 `a` 为一个具有类型 `interface{ check() }` 的变量。这究竟是什么意思呢？
- en: It means that you can put any value into `a`, as long as the value has a type
    that has a method called `check()`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以将任何值放入 `a` 中，只要这个值具有名为 `check()` 的方法。
- en: 'Why is this valuable? It''s valuable when considering multiple types that do
    similar things. Consider the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么价值呢？当考虑执行类似操作的多种类型时，它很有价值。考虑以下情况：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we want to write a function `do`, which does two things:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想编写一个 `do` 函数，它做两件事：
- en: Check that an email address is correct
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查电子邮件地址是否正确
- en: Send `"Hello World"` to the email
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向电子邮件发送 `"Hello World"`
- en: 'You would need two `do` functions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要两个 `do` 函数：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Instead, if that''s all the bodies of the functions are, we may opt to do this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果函数体就这些，我们可能会选择这样做：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is quite hard to read. So let''s give the interface a name:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当难以阅读。所以让我们给接口起个名字：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we can simply redefine `do` to be the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地重新定义 `do` 为以下内容：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A note on naming interfaces in Go. It is customary to name interfaces with a
    `-er` suffix. If a type implements `check()`, then the interface name should be
    called `checker`. This encourages the interfaces to be small. An interface should
    only define a small number of methods—larger interfaces are signs of poor program
    design.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在 Go 中命名接口的注意事项。通常，接口会使用 `-er` 后缀命名。如果一个类型实现了 `check()`，那么接口名称应该是 `checker`。这鼓励接口保持小巧。接口应该只定义少量方法——较大的接口是程序设计不佳的迹象。
- en: Packages and imports
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包和导入
- en: Finally, we come to the concept of packages and imports. For the majority of
    the book, the projects described live in something called a `main` package. The
    `main` package is a special package. Compiling a `main` package will yield an
    executable file that you can run.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到包和导入的概念。对于本书的大部分内容，描述的项目都存在于一个名为 `main` 的包中。`main` 包是一个特殊的包。编译 `main`
    包将生成一个可执行文件，你可以运行它。
- en: Having said that, it's also often a good idea to organize your code into multiple
    packages. Packages are a form of abstraction barrier that we discussed previously
    with regards to variables and names. Exported names are accessible from outside
    the package. Exported fields of structs are also accessible from outside the package.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，将代码组织成多个包也是一个很好的主意。包是一种抽象屏障，我们之前在讨论变量和名称时已经讨论过。导出的名称可以从包外部访问。结构体的导出字段也可以从包外部访问。
- en: 'To import a package, you need to invoke an import statement at the top of the
    file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入一个包，你需要在文件顶部调用一个导入语句：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Throughout this book I will be explicit in what to import, especially with external
    libraries that cannot be found in the Go standard library. We will be using a
    number of those, so I will be explicit.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我会明确指出需要导入的内容，特别是那些在 Go 标准库中找不到的外部库。我们将使用其中的一些库，因此我会明确指出。
- en: Go enforces code hygiene. If you import a package and don't use it, your program
    will not compile. Again, this is a good thing as it makes it less likely to confuse
    yourself at a later point in time. I personally use a tool called `goimports`
    to manage my imports for me. Upon saving my file, `goimports` adds the import
    statements for me, and removes any unused packages from my import statements.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Go 强制执行代码卫生。如果你导入了一个包但没有使用它，你的程序将无法编译。再次强调，这是一件好事，因为它可以减少你在以后某个时间点混淆自己的可能性。我个人使用一个名为
    `goimports` 的工具来管理我的导入。在保存我的文件后，`goimports` 会为我添加导入语句，并从我的导入语句中删除任何未使用的包。
- en: 'To install `goimports`, run the following command in your Terminal:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `goimports`，请在您的终端中运行以下命令：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's Go!
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'In this chapter we''ve covered what a problem is and how to model a problem
    as a machine learning problem. Then we learned the basics of using Go. In the
    next chapter we will dive into our first problem: linear regression.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了什么是问题以及如何将问题建模为机器学习问题。然后我们学习了使用 Go 的基础知识。在下一章中，我们将深入探讨我们的第一个问题：线性回归。
- en: I highly encourage you to practice some Go beforehand. But if you already know
    how to use Go, well, let's Go!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你在学习 Go 之前先练习一下。但如果你已经知道如何使用 Go，那么，让我们开始吧！
