- en: 'Chapter 1: Getting Started with Graphs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：图形入门
- en: Graphs are mathematical structures that are used for describing relations between
    entities and are used almost everywhere. For example, social networks are graphs,
    where users are connected depending on whether one user "*follows*" the updates
    of another user. They can be used for representing maps, where cities are linked
    through streets. Graphs can describe biological structures, web pages, and even
    the progression of neurodegenerative diseases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图是用于描述实体之间关系的数学结构，几乎无处不在都被使用。例如，社交网络是图，用户根据是否一个用户"*关注*"另一个用户的更新而相互连接。它们可以用来表示地图，城市通过街道相互连接。图可以描述生物结构、网页，甚至神经退行性疾病的进展。
- en: '**Graph theory**, the study of graphs, has received major interest for years,
    leading people to develop algorithms, identify properties, and define mathematical
    models to better understand complex behaviors.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**图论**，对图的研究，多年来一直受到广泛关注，促使人们开发算法、识别属性和定义数学模型，以更好地理解复杂行为。'
- en: This chapter will review some of the concepts behind graph-structured data.
    Theoretical notions will be presented, together with examples to help you understand
    some of the more general concepts and put them into practice. In this chapter,
    we will introduce and use some of the most widely used libraries for the creation,
    manipulation, and study of the structure dynamics and functions of complex networks,
    specifically looking at the Python `networkx` library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将回顾图形结构数据背后的某些概念。将介绍理论概念，并辅以示例，帮助您理解一些更普遍的概念并将它们付诸实践。在本章中，我们将介绍并使用一些最广泛使用的库来创建、操作和研究复杂网络的结构动态和功能，特别是关注Python的`networkx`库。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to graphs with `networkx`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`networkx`介绍图
- en: Plotting graphs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制图
- en: Graph properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的性质
- en: Benchmarks and repositories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准和仓库
- en: Dealing with large graphs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大型图
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will be using Jupyter Notebooks with *Python 3.8* for all of our exercises.
    In the following code snippet, we show a list of Python libraries that will be
    installed for this chapter using `pip` (for example, run `pip install networkx==2.5`
    on the command line, and so on):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带有*Python 3.8*的Jupyter Notebooks进行所有练习。在以下代码片段中，我们展示了使用`pip`为本章安装的Python库列表（例如，在命令行中运行`pip
    install networkx==2.5`，等等）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this book, the following Python commands will be referred to:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，以下Python命令将被提及：
- en: '`import networkx as nx`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import networkx as nx`'
- en: '`import pandas as pd`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import pandas as pd`'
- en: '`import numpy as np`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import numpy as np`'
- en: 'For more complex data visualization tasks, Gephi ([https://gephi.org/](https://gephi.org/))
    is also required. The installation manual is available here: [https://gephi.org/users/install/](https://gephi.org/users/install/).
    All code files relevant to this chapter are available at [https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter01](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter01).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的数据可视化任务，还需要Gephi ([https://gephi.org/](https://gephi.org/))。安装手册在此处可用：[https://gephi.org/users/install/](https://gephi.org/users/install/)。所有与本章节相关的代码文件均可在[https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter01](https://github.com/PacktPublishing/Graph-Machine-Learning/tree/main/Chapter01)找到。
- en: Introduction to graphs with networkx
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`networkx`介绍图
- en: In this section, we will give a general introduction to graph theory. Moreover,
    in order to merge theoretical concepts with their practical implementation, we
    will enrich our explanation with code snippets in Python, using `networkx`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对图论进行一般介绍。此外，为了将理论概念与其实际应用相结合，我们将通过Python代码片段丰富我们的解释，使用`networkx`。
- en: A **simple undirected graph** (or simply, a graph) *G* is defined as a couple
    *G=(V,E)* , where *V={*![](img/Formula_01_001.png)*, ..,* ![](img/Formula_01_002.png)*}*
    is a set of nodes (also called **vertices**) and *E={{*![](img/Formula_01_003.png)*,*![](img/Formula_01_004.png)
    *.., {*![](img/Formula_01_005.png)*,*![](img/Formula_01_006.png)*}}* is a set
    of two-sets (set of two elements) of edges (also called **links**), representing
    the connection between two nodes belonging to *V*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单无向图**（或简称图）*G*被定义为对*G=(V,E)*的二元组，其中*V={*![](img/Formula_01_001.png)*, ..,*
    ![](img/Formula_01_002.png)*}*是一个节点集合（也称为**顶点**），而*E={{*![](img/Formula_01_003.png)*,*![](img/Formula_01_004.png)
    *.., {*![](img/Formula_01_005.png)*,*![](img/Formula_01_006.png)*}}*是边的两元素集合（也称为**链接**）的集合，表示属于*V*的两个节点之间的连接。'
- en: It is important to underline that since each element of *E* is a two-set, there
    is no order between each edge. To provide more detail, *{*![](img/Formula_01_007.png)*,*![](img/Formula_01_008.png)
    and *{*![](img/Formula_01_009.png)*,*![](img/Formula_01_010.png) represent the
    same edge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，由于 *E* 的每个元素都是一个两集合，因此每条边之间没有顺序。为了提供更多细节，*{*![](img/Formula_01_007.png)*,*![](img/Formula_01_008.png)
    和 *{*![](img/Formula_01_009.png)*,*![](img/Formula_01_010.png) 代表同一条边。
- en: 'We now provide definitions for some basic properties of graphs and nodes, as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在提供一些基本图和节点属性的定义，如下所示：
- en: The **order** of a graph is the number of its vertices *|V|*. The **size** of
    a graph is the number of its edges *|E|*.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的**阶**是其顶点的数量 *|V|*。图的**大小**是其边的数量 *|E|*。
- en: The **degree** of a vertex is the number of edges that are adjacent to it. The
    **neighbors** of a vertex *v* in a graph *G* is a subset of vertex ![](img/Formula_01_011.png)
    induced by all vertices adjacent to *v*.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点的**度**是与它相邻的边的数量。图 *G* 中顶点 *v* 的**邻居**是由所有与 *v* 相邻的顶点诱导的顶点子集 ![](img/Formula_01_011.png)。
- en: The **neighborhood graph** (also known as an ego graph) of a vertex *v* in a
    graph *G* is a subgraph of *G*, composed of the vertices adjacent to *v* and all
    edges connecting vertices adjacent to *v*.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中顶点 *v* 的**邻域图**（也称为自我图）是 *G* 的一个子图，由与 *v* 相邻的顶点和连接这些顶点的所有边组成。
- en: 'An example of what a graph looks like can be seen in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图的示例可以在以下屏幕截图中看到：
- en: '![Figure 1.1 – Example of a graph'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 图的示例'
- en: '](img/B16069_01_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_01_01.jpg)'
- en: Figure 1.1 – Example of a graph
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 图的示例
- en: 'According to this representation, since there is no direction, an edge from
    `4` (there are, in total, four vertices and four edges). The `2`, `3`, and `1`.
    The neighbors for each node are shown in the following list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这种表示，由于没有方向，从 `4`（总共有四个顶点和四个边）。到 `2`、`3` 和 `1`。每个节点的邻居如下所示：
- en: '`Paris` = {`Milan`, `Dublin`}'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Paris` = {`Milan`, `Dublin`}'
- en: '`Milan` = {`Paris`, `Dublin`, `Rome`}'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Milan` = {`Paris`, `Dublin`, `Rome`} '
- en: '`Dublin` = {`Paris`, `Milan`}'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dublin` = {`Paris`, `Milan`} '
- en: '`Rome` = {`Milan`}'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rome` = {`Milan`} '
- en: 'The same graph can be represented in `networkx`, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的图可以用 `networkx` 表示，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since by default, the `nx.Graph()` command generates an undirected graph, we
    do not need to specify both directions of each edge. In `networkx`, nodes can
    be any hashable object: strings, classes, or even other `networkx` graphs. Let''s
    now compute some properties of the graph we previously generated.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认情况下，`nx.Graph()` 命令生成一个无向图，我们不需要指定每条边的两个方向。在 `networkx` 中，节点可以是任何可哈希的对象：字符串、类，甚至是其他
    `networkx` 图。现在让我们计算之前生成的图的某些属性。
- en: 'All the nodes and edges of the graph can be obtained by running the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下代码来获取图的所有节点和边：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the output of the previous commands:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面命令的输出：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also compute the graph order, the graph size, and the degree and neighbors
    for each of the nodes, using the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以使用以下命令计算图阶、图大小以及每个节点的度数和邻居： '
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result will be the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we can also compute an ego graph of a specific node for the graph
    `G`, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以计算图 `G` 中特定节点的自我图，如下所示：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result will be the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是以下内容：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The original graph can be also modified by adding new nodes and/or edges, as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加新的节点和/或边来修改原始图，如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would output the following lines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下行：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Removal of nodes can be done by running the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行以下代码来删除节点：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the result of the preceding commands:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面命令的结果：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As expected, all the edges that contain the removed nodes are automatically
    deleted from the edge list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，所有包含已删除节点的边都会自动从边列表中删除。
- en: 'Also, edges can be removed by running the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以通过运行以下代码来删除边：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The final result will be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果如下：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `networkx` library also allows us to remove a single node or a single edge
    from a graph `G` by using the following commands: `G. remove_node(''Dublin'')`
    and `G.remove_edge(''Dublin'', ''Paris'')`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` 库还允许我们使用以下命令从图 `G` 中删除单个节点或单个边：`G.remove_node(''Dublin'')` 和 `G.remove_edge(''Dublin'',
    ''Paris'')`。'
- en: Types of graphs
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图的类型
- en: In the previous section, we described how to create and modify simple undirected
    graphs. Here, we will show how we can extend this basic data structure in order
    to encapsulate more information, thanks to the introduction of **directed graphs**
    (**digraphs**), weighted graphs, and multigraphs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们描述了如何创建和修改简单的无向图。在这里，我们将展示如何通过引入 **有向图**（**有向图**）、加权图和多重图来扩展这种基本数据结构，以封装更多信息。
- en: Digraphs
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有向图
- en: A digraph *G* is defined as a couple *G=(V, E)*, where *V={*![](img/Formula_01_012.png)*,
    ..,* ![](img/Formula_01_013.png)*}* is a set of nodes and *E={(*![](img/Formula_01_014.png)*,*![](img/Formula_01_015.png)
    *.., (*![](img/Formula_01_016.png)*,*![](img/Formula_01_017.png)*)}* is a set
    of ordered couples representing the connection between two nodes belonging to
    *V*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有向图 *G* 定义为一个对 *G=(V, E)*，其中 *V={*![](img/Formula_01_012.png)*, ..,* ![](img/Formula_01_013.png)*}*
    是节点集合，*E={(*![](img/Formula_01_014.png)*,*![](img/Formula_01_015.png) *.., (*![](img/Formula_01_016.png)*,*![](img/Formula_01_017.png)*)}*
    是表示属于 *V* 的两个节点之间连接的有序对集合。
- en: Since each element of *E* is an ordered couple, it enforces the direction of
    the connection. The edge ![](img/Formula_01_018.png)*,*![](img/Formula_01_019.png)
    means *the node* ![](img/Formula_01_020.png) *goes into* ![](img/Formula_01_021.png).
    This is different from ![](img/Formula_01_022.png)*,*![](img/Formula_01_023.png)
    since it means *the node* ![](img/Formula_01_024.png) *goes to* ![](img/Formula_01_025.png).The
    starting node ![](img/Formula_01_026.png) is called the *head*, while the ending
    node is called the *tail*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *E* 的每个元素都是一个有序对，它强制了连接的方向。边 ![](img/Formula_01_018.png)*,*![](img/Formula_01_019.png)
    表示 *节点* ![](img/Formula_01_020.png) *进入* ![](img/Formula_01_021.png)。这与 ![](img/Formula_01_022.png)*,*![](img/Formula_01_023.png)
    不同，因为它表示 *节点* ![](img/Formula_01_024.png) *到达* ![](img/Formula_01_025.png)。起始节点
    ![](img/Formula_01_026.png) 被称为 *头节点*，而结束节点被称为 *尾节点*。
- en: Due to the presence of edge direction, the definition of node degree needs to
    be extended.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在边方向，节点度数的定义需要扩展。
- en: Indegree and outdegree
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 入度和出度
- en: For a vertex *v*, the number of head ends adjacent to *v* is called the **indegree**
    (indicated by ![](img/Formula_01_027.png) of *v*, while the number of tail ends
    adjacent to *v* is its **outdegree** (indicated by ![](img/Formula_01_028.png)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个顶点 *v*，与 *v* 相邻的头节点数量称为 **入度**（用 *v* 的 ![](img/Formula_01_027.png) 表示），而与
    *v* 相邻的尾节点数量称为其 **出度**（用 ![](img/Formula_01_028.png) 表示）。
- en: 'An example of what a digraph looks like is available in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了有向图的一个示例：
- en: '![Figure 1.2 – Example of a digraph'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 有向图的示例'
- en: '](img/B16069_01_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_01_02.jpg)'
- en: Figure 1.2 – Example of a digraph
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 有向图的示例
- en: The direction of the edge is visible from the arrow—for example, **Milan** ->
    **Dublin** means from **Milan** to **Dublin**. **Dublin** has ![](img/Formula_01_029.png)
    *= 2* and ![](img/Formula_01_030.png) *= 0*, **Paris** has ![](img/Formula_01_031.png)
    *= 0* and ![](img/Formula_01_032.png) *= 2*, **Milan** has ![](img/Formula_01_033.png)
    *= 1* and ![](img/Formula_01_034.png) *= 2*, and **Rome** has ![](img/Formula_01_035.png)
    *= 1* and ![](img/Formula_01_036.png) *= 0*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 边的方向从箭头中可见——例如，**米兰** -> **都柏林**表示从 **米兰** 到 **都柏林**。**都柏林**有 ![](img/Formula_01_029.png)
    *= 2* 和 ![](img/Formula_01_030.png) *= 0*，**巴黎**有 ![](img/Formula_01_031.png)
    *= 0* 和 ![](img/Formula_01_032.png) *= 2*，**米兰**有 ![](img/Formula_01_033.png)
    *= 1* 和 ![](img/Formula_01_034.png) *= 2*，而 **罗马**有 ![](img/Formula_01_035.png)
    *= 1* 和 ![](img/Formula_01_036.png) *= 0*。
- en: 'The same graph can be represented in `networkx`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个图可以用 `networkx` 表示，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The definition is the same as that used for simple undirected graphs; the only
    difference is in the `networkx` classes that are used to instantiate the object.
    For digraphs, the `nx.DiGraph()`class is used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义与用于简单无向图的定义相同；唯一的区别在于用于实例化对象的 `networkx` 类。对于有向图，使用 `nx.DiGraph()` 类。
- en: '`Indegree` and `Outdegree` can be computed using the following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令计算 **入度** 和 **出度**：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The results will be as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As for the undirected graphs, `G.add_nodes_from()`, `G.add_edges_from()`, `G.remove_nodes_from()`,
    and `G.remove_edges_from()` functions can be used to modify a given graph `G`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无向图，可以使用 `G.add_nodes_from()`、`G.add_edges_from()`、`G.remove_nodes_from()`
    和 `G.remove_edges_from()` 函数来修改给定的图 `G`。
- en: Multigraph
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多重图
- en: We will now introduce the multigraph object, which is a generalization of the
    graph definition that allows multiple edges to have the same pair of start and
    end nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍多重图对象，它是图定义的推广，允许有多个边具有相同的起始和结束节点对。
- en: A **multigraph G** is defined as *G=(V, E)*, where *V* is a set of nodes and
    *E* is a multi-set (a set allowing multiple instances for each of its elements)
    of edges.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重图 G** 定义为 *G=(V, E)* ，其中 *V* 是节点集，*E* 是边的多重集（允许其元素有多个实例的集合）。'
- en: A multigraph is called a **directed multigraph** if *E* is a multi-set of ordered
    couples; otherwise, if *E* is a multi-set of two-sets, then it is called an **undirected
    multigraph**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *E* 是有序对的有序多重集，则多重图被称为**有向多重图**；否则，如果 *E* 是两个集合的有序多重集，则称为**无向多重图**。
- en: 'An example of a directed multigraph is available in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了有向多重图的示例：
- en: '![Figure 1.3 – Example of a multigraph'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 多重图的示例'
- en: '](img/B16069_01_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_01_03.jpg)'
- en: Figure 1.3 – Example of a multigraph
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 多重图的示例
- en: 'In the following code snippet, we show how to use `networkx` in order to create
    a directed or an undirected multigraph:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们展示了如何使用`networkx`来创建有向或无向多重图：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only difference between a directed and an undirected multigraph is in the
    first two lines, where two different objects are created: `nx.MultiDiGraph()`
    is used to create a directed multigraph, while `nx.MultiGraph()` is used to build
    an undirected multigraph. The function used to add nodes and edges is the same
    for both objects.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有向多重图和无向多重图之间的唯一区别在于前两行，其中创建了两个不同的对象：使用`nx.MultiDiGraph()`创建有向多重图，而使用`nx.MultiGraph()`构建无向多重图。添加节点和边所使用的函数对这两个对象都是相同的。
- en: Weighted graphs
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加权图
- en: We will now introduce directed, undirected, and multi-weighted graphs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍有向、无向和多权重图。
- en: An **edge-weighted graph** (or simply, a weighted graph) *G* is defined as *G=(V,
    E ,w)* where *V* is a set of nodes, *E* is a set of edges, and ![](img/Formula_01_037.png)
    is the weighted function that assigns at each edge ![](img/Formula_01_038.png)
    a weight expressed as a real number.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**边加权图**（或简称为加权图） *G* 定义为 *G=(V, E ,w)* ，其中 *V* 是节点集，*E* 是边集，而 ![](img/Formula_01_037.png)
    是将权重函数分配给每个边 ![](img/Formula_01_038.png) 的权重，该权重以实数表示。'
- en: A **node-weighted graph** *G* is defined as *G=*(*V, E ,w*) ,where *V* is a
    set of nodes, *E* is a set of edges, and ![](img/Formula_01_039.png) is the weighted
    function that assigns at each node ![](img/Formula_01_040.png) a weight expressed
    as a real number.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**节点加权图** *G* 定义为 *G=*(*V, E ,w*) ，其中 *V* 是节点集，*E* 是边集，而 ![](img/Formula_01_039.png)
    是将权重函数分配给每个节点 ![](img/Formula_01_040.png) 的权重，该权重以实数表示。'
- en: 'Please keep the following points in mind:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下要点：
- en: If *E* is a set of ordered couples, then we call it a **directed weighted graph**.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *E* 是有序对的集合，则我们称之为**有向加权图**。
- en: If *E* is a set of two-sets, then we call it an **undirected weighted graph**.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *E* 是两个集合的集合，则我们称之为**无向加权图**。
- en: If *E* is a multi-set, we will call it a **weighted multigraph** (**directed
    weighted multigraph**).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *E* 是多重集，我们将称之为**加权多重图**（**有向加权多重图**）。
- en: If *E* is a multi-set of ordered couples, it is an **undirected weighted multigraph**.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*E*是有序对的有序多重集，则它是一个**无向加权多重图**。
- en: 'An example of a directed edge-weighted graph is available in the following
    screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了有向边加权图的示例：
- en: '![Figure 1.4 – Example of a directed edge-weighted graph'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – 有向边加权图的示例'
- en: '](img/B16069_01_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_01_04.jpg)'
- en: Figure 1.4 – Example of a directed edge-weighted graph
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 有向边加权图的示例
- en: From *Figure 1.4*, it is easy to see how the presence of weights on graphs helps
    to add useful information to the data structures. Indeed, we can imagine the edge
    weight as a "cost" to reach a node from another node. For example, reaching `19`,
    while reaching `11`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *图1.4* 中，很容易看出图上权重的存在如何有助于向数据结构添加有用的信息。确实，我们可以将边权重想象为从一个节点到达另一个节点的“成本”。例如，到达`19`，而到达`11`。
- en: 'In `networkx`, a directed weighted graph can be generated as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`networkx`中，可以通过以下方式生成有向加权图：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Bipartite graphs
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二部图
- en: 'We will now introduce another type of graph that will be used in this section:
    multipartite graphs. Bi- and tripartite graphs—and, more generally, kth-partite
    graphs—are graphs whose vertices can be partitioned in two, three, or more k-th
    sets of nodes, respectively. Edges are only allowed across different sets and
    are not allowed within nodes belonging to the same set. In most cases, nodes belonging
    to different sets are also characterized by particular node types. In *Chapters
    7, Text Analytics and Natural Language Processing Using Graphs,* and [*Chapter
    8*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129), *Graphs Analysis for Credit
    Cards Transaction*, we will deal with some practical examples of graph-based applications
    and you will see how multipartite graphs can indeed arise in several contexts—for
    example, in the following scenarios:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍本节中将使用的一种图形类型：多部分图。二部分图和三分图——以及更一般地，第k部分图——是顶点可以被划分为两个、三个或更多k个节点集合的图的统称。边只允许在不同集合之间，不允许在同一集合内的节点之间。在大多数情况下，属于不同集合的节点也由特定的节点类型来表征。在*第7章，使用图形进行文本分析和自然语言处理*和[*第8章*](B16069_08_Final_JM_ePub.xhtml#_idTextAnchor129)，*信用卡交易图分析*中，我们将处理一些基于图形应用的实际例子，你将看到多部分图确实可以在几个场景中产生——例如，在以下场景中：
- en: When processing documents and structuring the information in a bipartite graph
    of documents and entities that appear in the documents
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理文档并将文档中出现的实体信息以二部分图的形式结构化时
- en: When dealing with transactional data, in order to encode the relations between
    the buyers and the merchants
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处理交易数据时，为了编码买家和商家之间的关系
- en: 'A bipartite graph can be easily created in `networkx` with the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`networkx`中，可以使用以下代码轻松创建一个二部分图：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The network can also be conveniently plotted using the `bipartite_layout` utility
    function of `networkx`, as illustrated in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该网络也可以方便地使用`networkx`的`bipartite_layout`实用函数绘制，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `bipatite_layout` function produces a graph, as shown in the following
    screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`bipatite_layout`函数生成一个图，如下面的屏幕截图所示：'
- en: '![Figure 1.5 – Example of a bipartite graph'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.5 – 二部分图的示例'
- en: '](img/B16069_01_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_05.jpg](img/B16069_01_05.jpg)'
- en: Figure 1.5 – Example of a bipartite graph
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.5 – 二部分图的示例
- en: Graph representations
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表示
- en: As described in the previous sections, with `networkx`, we can actually define
    and manipulate a graph by using node and edge objects. In different use cases,
    such a representation would not be as easy to handle. In this section, we will
    show two ways to perform a compact representation of a graph data structure—namely,
    an adjacency matrix and an edge list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，使用`networkx`，我们实际上可以通过使用节点和边对象来定义和操作一个图。在不同的用例中，这种表示可能不太容易处理。在本节中，我们将展示两种执行图数据结构紧凑表示的方法——即邻接矩阵和边列表。
- en: Adjacency matrix
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: 'The **adjacency matrix** *M* of a graph *G=(V,E)* is a square matrix *(|V|
    × |V|*) matrix such that its element ![](img/Formula_01_041.png) is 1 when there
    is an edge from node *i* to node *j*, and 0 when there is no edge. In the following
    screenshot, we show a simple example where the adjacency matrix of different types
    of graphs is displayed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图G=(V,E)的**邻接矩阵**M是一个方阵(|V| × |V|)，其元素![img/Formula_01_041.png](img/Formula_01_041.png)在节点i到节点j之间存在边时为1，不存在边时为0。在下面的屏幕截图中，我们展示了不同类型图的邻接矩阵的简单示例：
- en: '![Figure 1.6 – Adjacency matrix for an undirected graph, a digraph, a multigraph,
    and a weighted graph'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.6 – 无向图、有向图、多重图和加权图的邻接矩阵'
- en: '](img/B16069_01_006.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_006.jpg](img/B16069_01_006.jpg)'
- en: Figure 1.6 – Adjacency matrix for an undirected graph, a digraph, a multigraph,
    and a weighted graph
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.6 – 无向图、有向图、多重图和加权图的邻接矩阵
- en: It is easy to see that adjacency matrices for undirected graphs are always symmetric,
    since no direction is defined for the edge. The symmetry instead is not guaranteed
    for the adjacency matrix of a digraph due to the presence of constraints in the
    direction of the edges. For a multigraph, we can instead have values greater than
    1 since multiple edges can be used to connect the same couple of nodes. For a
    weighted graph, the value in a specific cell is equal to the weight of the edge
    connecting the two nodes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，无向图的邻接矩阵总是对称的，因为边没有定义方向。由于边方向的约束存在，有向图的邻接矩阵的对称性不能保证。对于多重图，我们可以有大于 1 的值，因为可以使用多条边连接相同的节点对。对于加权图，特定单元格的值等于连接两个节点的边的权重。
- en: 'In `networkx`, the adjacency matrix for a given graph can be computed in two
    different ways. If `G` is the `networkx` of *Figure 1.6*, we can compute its adjacency
    matrix as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `networkx` 中，给定图的邻接矩阵可以通过两种不同的方式计算。如果 `G` 是 *图 1.6* 中的 `networkx`，我们可以按照以下方式计算其邻接矩阵：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the first and second line, we get the following results respectively:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一行和第二行，我们分别得到以下结果：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since a `numpy` matrix cannot represent the name of the nodes, the order of
    the element in the adjacency matrix is the one defined in the `G.nodes` list.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `numpy` 矩阵不能表示节点的名称，邻接矩阵中元素的位置是 `G.nodes` 列表中定义的。
- en: Edge list
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边列表
- en: As well as an adjacency matrix, an edge list is another compact way to represent
    graphs. The idea behind this format is to represent a graph as a list of edges.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了邻接矩阵之外，边列表也是表示图的一种紧凑方式。这种格式的思想是将图表示为边的列表。
- en: 'The **edge list** *L* of a graph *G=(V,E)* is a list of size *|E|* matrix such
    that its element ![](img/Formula_01_042.png) is a couple representing the tail
    and the end node of the edge *i*. An example of the edge list for each type of
    graph is available in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *G=(V,E)* 的 **边列表** *L* 是一个大小为 *|E|* 的矩阵，其元素 ![](img/Formula_01_042.png) 是一个表示边
    *i* 的尾节点和终节点的对。每种类型图的边列表的示例可以在以下屏幕截图找到：
- en: '![Figure 1.7 – Edge list for an undirected graph, a digraph, a multigraph,
    and a weighted graph'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 无向图、有向图、多重图和加权图的边列表'
- en: '](img/B16069_01_007.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_01_007.jpg)'
- en: Figure 1.7 – Edge list for an undirected graph, a digraph, a multigraph, and
    a weighted graph
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 无向图、有向图、多重图和加权图的边列表
- en: 'In the following code snippet, we show how to compute in `networkx` the edge
    list of the simple undirected graph *G* available in *Figure 1.7*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们展示了如何在 `networkx` 中计算 *图 1.7* 中可用的简单无向图 *G* 的边列表：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By running the preceding command, we get the following result:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的命令，我们得到以下结果：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Other representation methods, which we will not discuss in detail, are also
    available in `networkx`. Some examples are `nx.to_dict_of_dicts(G)` and `nx.to_numpy_array(G)`,
    among others.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` 中还有其他一些我们不会详细讨论的表示方法。其中一些例子包括 `nx.to_dict_of_dicts(G)` 和 `nx.to_numpy_array(G)`
    等。'
- en: Plotting graphs
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制图形
- en: As we have seen in previous sections, graphs are intuitive data structures represented
    graphically. Nodes can be plotted as simple circles, while edges are lines connecting
    two nodes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，图是直观的图形数据结构。节点可以绘制为简单的圆圈，而边是连接两个节点的线条。
- en: Despite their simplicity, it could be quite difficult to make a clear representation
    when the number of edges and nodes increases. The source of this complexity is
    mainly related to the position (space/Cartesian coordinates) to assign to each
    node in the final plot. Indeed, it could be unfeasible to manually assign to a
    graph with hundreds of nodes the specific position of each node in the final plot.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们很简单，但当边和节点的数量增加时，可能很难清楚地表示。这种复杂性的来源主要是与在最终绘图中将每个节点分配到位置（空间/笛卡尔坐标）有关。实际上，手动将数百个节点的特定位置分配到最终绘图可能是不可行的。
- en: 'In this section, we will see how we can plot graphs without specifying coordinates
    for each node. We will exploit two different solutions: `networkx` and Gephi.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何在不指定每个节点的坐标的情况下绘制图形。我们将利用两种不同的解决方案：`networkx` 和 Gephi。
- en: networkx
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: networkx
- en: '`networkx` offers a simple interface to plot graph objects through the `nx.draw`
    library. In the following code snippet, we show how to use the library in order
    to plot graphs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` 通过 `nx.draw` 库提供了一个简单的接口来绘制图形对象。在以下代码片段中，我们展示了如何使用该库来绘制图形：'
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `nodes_position` is a dictionary where the keys are the nodes and the
    value assigned to each key is an array of length 2, with the Cartesian coordinate
    used for plotting the specific node.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`nodes_position` 是一个字典，其键是节点，分配给每个键的值是一个长度为 2 的数组，用于绘制特定节点的笛卡尔坐标。
- en: The `nx.draw` function will plot the whole graph by putting its nodes in the
    given positions. The `with_labels` option will plot its name on top of each node
    with the specific `font_size` value. `node_size` and `edge_color` will respectively
    specify the size of the circle, representing the node and the color of the edges.
    Finally, `arrowsize` will define the size of the arrow for directed edges. This
    option will be used when the graph to be plotted is a digraph.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`nx.draw` 函数将通过将节点放置在给定的位置来绘制整个图。`with_labels` 选项将在每个节点上方绘制其名称，并使用特定的 `font_size`
    值。`node_size` 和 `edge_color` 分别指定表示节点的圆的大小和边的颜色。最后，`arrowsize` 将定义有向边的箭头大小。当要绘制的图是一个有向图时，将使用此选项。'
- en: 'In the following code example, we show how to use the `draw_graph` function
    previously defined in order to plot a graph:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们展示了如何使用之前定义的 `draw_graph` 函数来绘制一个图：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result of the plot is available to view in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图的结果可在以下截图查看：
- en: '![Figure 1.8 – Result of the plotting function'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.8 – 绘图函数的结果]'
- en: '](img/B16069_01_08.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_08.jpg](img/B16069_01_08.jpg)'
- en: Figure 1.8 – Result of the plotting function
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.8 – 绘图函数的结果
- en: 'The method previously described is simple but unfeasible to use in a real scenario
    since the `node_position` value could be difficult to decide. In order to solve
    this issue, `networkx` offers a different function to automatically compute the
    position of each node according to different layouts. In *Figure 1.9*, we show
    a series of plots of an undirected graph, obtained using the different layouts
    available in `networkx`. In order to use them in the function we proposed, we
    simply need to assign `node_position` to the result of the layout we want to use—for
    example, `node_position = nx.circular_layout(G)`. The plots can be seen in the
    following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的方法简单，但在实际场景中不可行，因为 `node_position` 的值可能难以决定。为了解决这个问题，`networkx` 提供了一个不同的函数来自动根据不同的布局计算每个节点的位置。在
    *图 1.9* 中，我们展示了一系列使用 `networkx` 中可用的不同布局得到的无向图绘制。为了在所提出的函数中使用它们，我们只需将 `node_position`
    分配给我们要使用的布局的结果——例如，`node_position = nx.circular_layout(G)`。以下截图显示了这些绘制：
- en: '![Figure 1.9 – Plots of the same undirected graph with different layouts'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.9 – 使用不同布局绘制的相同无向图]'
- en: '](img/B16069_01_009.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_009.jpg](img/B16069_01_009.jpg)'
- en: Figure 1.9 – Plots of the same undirected graph with different layouts
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.9 – 使用不同布局绘制的相同无向图
- en: '`networkx` is a great tool for easily manipulating and analyzing graphs, but
    it does not offer good functionalities in order to perform complex and good-looking
    plots of graphs. In the next section, we will investigate another tool to perform
    complex graph visualization: Gephi.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` 是一个易于操作和分析图的优秀工具，但它不提供良好的功能来执行复杂且美观的图绘制。在下一节中，我们将探讨另一个用于执行复杂图可视化的工具：Gephi。'
- en: Gephi
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gephi
- en: In this section, we will show how `Les Miserables.gexf` sample (a weighted undirected
    graph), which can be selected in the **Welcome** window when the application starts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用 `Les Miserables.gexf` 样本（一个加权无向图），在应用程序启动时可以在 **欢迎** 窗口中选择。
- en: 'The main interface of Gephi is shown in *Figure 1.10*. It can be divided into
    four main areas, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Gephi 的主界面如 *图 1.10* 所示。它可以分为四个主要区域，如下所述：
- en: '**Graph**: This section shows the final plot of the graph. The image is automatically
    updated each time a filter or a specific layout is applied.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图**：此部分显示图的最终绘制结果。每次应用过滤器或特定的布局时，图像都会自动更新。'
- en: '**Appearance**: Here, it is possible to specify the appearance of nodes and
    edges.'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**外观**：在此，可以指定节点和边的外观。'
- en: '`networkx`) to adjust the node position in the graph. Different algorithms,
    from a simple random position generator to a more complex Yifan Hu algorithm,
    are available.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`networkx`) 来调整图中的节点位置。不同的算法，从简单的随机位置生成器到更复杂的 Yifan Hu 算法，都是可用的。'
- en: '**Filters & Statistics**: In this set area, two main functions are available,
    outlined as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过滤器 & 统计**：在此区域，有两个主要功能可用，概述如下：'
- en: 'a. **Filters**: In this tab, it is possible to filter and visualize specific
    subregions of the graph according to a set property computed using the **Statistics**
    tab.'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. **过滤器**：在此选项卡中，可以根据使用 **统计信息** 选项卡计算的一组属性过滤和可视化图形的特定子区域。
- en: 'b. **Statistics**: This tab contains a list of available graph metrics that
    can be computed on the graph using the **Run** button. Once metrics are computed,
    they can be used as properties to specify the edges'' and nodes'' appearance (such
    as node and edge size and color) or to filter a specific subregion of the graph.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. **统计信息**：此选项卡包含可以在图形上使用 **运行** 按钮计算的可用图形度量。一旦计算了度量，它们可以用作属性来指定边和节点的外观（例如节点和边的大小和颜色）或用于过滤图形的特定子区域。
- en: 'You can see the main interface of Gephi in the following screenshot:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在下面的屏幕截图中看到 Gephi 的主界面：
- en: '![Figure 1.10 – Gephi main window'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.10 – Gephi 主窗口'
- en: '](img/B16069_01_010.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_010.jpg](img/B16069_01_010.jpg)'
- en: Figure 1.10 – Gephi main window
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.10 – Gephi 主窗口
- en: Our exploration of Gephi starts with the application of different layouts to
    the graph. As previously described, in `networkx` the layouts allow us to assign
    to each node a specific position in the final plot. In Gephi 1.2, different layouts
    are available. In order to apply a specific layout, we have to select from the
    **Layout** area one of the available layouts, and then click on the **Run** button
    that appears after the selection.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 Gephi 的探索从将不同的布局应用于图形开始。如前所述，在 `networkx` 中，布局允许我们为每个节点在最终绘制中分配一个特定的位置。在
    Gephi 1.2 中，有多个布局可供选择。为了应用特定的布局，我们必须从 **布局** 区域中选择一个可用的布局，然后点击选择后出现的 **运行** 按钮。
- en: 'The graph representation, visible in the **Graph** area, will be automatically
    updated according to the new coordinates defined by the layout. It should be noted
    that some layouts are parametric, hence the final graph plot can significantly
    change according to the parameters used. In the following screenshot, we propose
    several examples for the application of three different layouts:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可在 **图形** 区域中看到的图形表示，将根据布局定义的新坐标自动更新。需要注意的是，某些布局是参数化的，因此最终的图形绘制可以根据所使用的参数显著改变。在下面的屏幕截图中，我们提出了三个不同布局的应用示例：
- en: '![Figure 1.11 – Plot of the same graph with different layout'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.11 – 不同布局下的同一图形'
- en: '](img/B16069_01_011.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_011.jpg](img/B16069_01_011.jpg)'
- en: Figure 1.11 – Plot of the same graph with different layout
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 不同布局下的同一图形
- en: We will now introduce the available options in the **Appearance** menu visible
    in *Figure 1.10*. In this section, it is possible to specify the style to be applied
    to edges and nodes. The style to be applied can be static or can be dynamically
    defined by specific properties of the nodes/edges. We can change the color and
    the size of the nodes by selecting the **Nodes** option in the menu.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍在 *图 1.10* 中可见的 **外观** 菜单中的可用选项。在本节中，可以指定要应用于边和节点的样式。要应用的样式可以是静态的，也可以由节点/边的特定属性动态定义。我们可以通过在菜单中选择
    **节点** 选项来更改节点的大小和颜色。
- en: In order to change the color, we have to select the color palette icon and decide,
    using the specific button, if we want to assign a **Unique** color, a **Partition**
    (discrete values), or a **Ranking** (range of values) of colors. For **Partition**
    and **Ranking**, it is possible to select from the drop-down menu a specific **Graph**
    property to use as reference for the color range. Only the properties computed
    by clicking **Run** in the **Statistics** area are available in the drop-down
    menu. The same procedure can be used in order to set the size of the nodes. By
    selecting the concentric circles icon, it is possible to set a **Unique** size
    to all the nodes or to specify a **Ranking** of size according to a specific property.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改颜色，我们必须选择调色板图标，并使用特定的按钮决定我们想要分配一个 **唯一** 的颜色、一个 **分区**（离散值）或一个 **排名**（值范围）。对于
    **分区** 和 **排名**，可以从下拉菜单中选择一个特定的 **图形** 属性作为颜色范围的参考。只有通过在 **统计信息** 区域中点击 **运行**
    计算的属性才在下拉菜单中可用。相同的程序可以用来设置节点的大小。通过选择同心圆图标，可以设置所有节点的 **唯一** 大小或根据特定属性指定大小的一个 **排名**。
- en: As for the nodes, it is also possible to change the style of the edges by selecting
    the **Edges** option in the menu. We can then select to assign a **Unique** color,
    a **Partition** (discrete values), or a **Ranking** (range of values) of colors.
    For **Partition** and **Ranking**, the reference value to build the color scale
    is defined by a specific **Graph** property that can be selected from the drop-down
    menu.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于节点，用户也可以通过在菜单中选择**边**选项来更改边的样式。然后我们可以选择分配**唯一**颜色、**分区**（离散值）或**排名**（值范围）的颜色。对于**分区**和**排名**，构建颜色刻度的参考值由一个特定的**图形**属性定义，该属性可以从下拉菜单中选择。
- en: 'It is important to remember that in order to apply a specific style to the
    graph, the **Apply** button should be clicked. As a result, the graph plot will
    be updated according to the style defined. In the following screenshot, we show
    an example where the color of the nodes is given by the **Modularity Class** value
    and the size of each node is given by its degree, while the color of each edge
    is defined by the edge weight:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，为了应用特定的样式到图形，应该点击**应用**按钮。结果，图形绘制将根据定义的样式更新。在下述屏幕截图中，我们展示了节点颜色由**模块化类**值给出，每个节点的尺寸由其度数给出，而每条边的颜色由边权重定义的示例：
- en: '![Figure 1.12 – Example of graph plot changing nodes’ and edges’ appearance'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12 – 图形绘制示例，改变节点和边的外观'
- en: '](img/B16069_01_012.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_012.jpg](img/B16069_01_012.jpg)'
- en: Figure 1.12 – Example of graph plot changing nodes' and edges' appearance
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 – 图形绘制示例，改变节点和边的外观
- en: Another important section that needs to be described is **Filters & Statistics**.
    In this menu, it is possible to compute some statistics based on graph metrics.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要描述的重要部分是**过滤器和统计**。在此菜单中，可以根据图形度量计算一些统计数据。
- en: Finally, we conclude our discussion on Gephi by introducing the functionalities
    available in the **Statistics** menu, visible in the right panel in *Figure 1.10*.
    Through this menu, it is possible to compute different statistics on the input
    graph. Those statistics can be easily used to set some properties of the final
    plot, such as nodes'/edges' color and size, or to filter the original graph to
    plot just a specific subset of it. In order to compute a specific statistic, the
    user then needs to explicitly select one of the metrics available in the menu
    and click on the **Run** button (*Figure 1.10*, right panel).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过介绍**统计**菜单中的功能来结束对Gephi的讨论，该菜单在*图1.10*的右侧面板中可见。通过此菜单，可以计算输入图中不同的统计数据。这些统计数据可以轻松地用于设置最终图表的一些属性，例如节点/边的颜色和大小，或者过滤原始图以仅绘制其特定子集。为了计算特定的统计数据，用户需要明确选择菜单中可用的一个度量标准，然后点击**运行**按钮（*图1.10*，右侧面板）。
- en: Moreover, the user can select a subregion of the graph, using the options available
    in the **Filters** tab of the **Statistics** menu, visible in the right panel
    in *Figure 1.10*. An example of filtering a graph can be seen in *Figure 1.13*.
    To provide more details of this, we build and apply to the graph a filter, using
    the **Degree** property. The result of the filters is a subset of the original
    graph, where only the nodes (and their edges) having the specific range of values
    for the degree property are visible.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户可以使用**统计**菜单的**过滤器**选项卡中的选项选择图形的子区域，该菜单在*图1.10*的右侧面板中可见。*图1.13*中可以看到过滤图形的示例。为了提供更多细节，我们构建并应用一个**度数**属性过滤器到图形上。过滤器的结果是原始图形的一个子集，其中只有具有特定度数属性值范围的节点（及其边）是可见的。
- en: 'This is illustrated in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下述屏幕截图中有说明：
- en: '![Figure 1.13 – Example of a graph filtered according to a range of values
    for Degree'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13 – 根据度数范围过滤的图形示例'
- en: '](img/B16069_01_013.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16069_01_013.jpg](img/B16069_01_013.jpg)'
- en: Figure 1.13 – Example of a graph filtered according to a range of values for
    Degree
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 根据度数范围过滤的图形示例
- en: Of course, Gephi allows us to perform more complex visualization tasks and contains
    a lot of functionalities that cannot be fully covered in this book. Some good
    references to better investigate all the features available in Gephi are the official
    Gephi guide ([https://gephi.org/users/](https://gephi.org/users/)) or the *Gephi
    Cookbook* book by Packt Publishing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Gephi允许我们执行更复杂的可视化任务，并包含许多本书无法完全涵盖的功能。一些更好的参考资料以更好地调查Gephi中所有可用的功能是官方的Gephi指南([https://gephi.org/users/](https://gephi.org/users/))或Packt出版社的*Gephi食谱*书籍。
- en: Graph properties
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形属性
- en: As we have already learned, a *graph* is a mathematical model that is used for
    describing relations between entities. However, each complex network presents
    intrinsic properties. Such properties can be measured by particular metrics, and
    each measure may characterize one or several local and global aspects of the graph.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经学到的，**图**是一个用于描述实体之间关系的数学模型。然而，每个复杂网络都表现出固有的属性。这些属性可以通过特定的指标来衡量，每个指标可能表征图的一个或多个局部和全局方面。
- en: In a graph for a social network such as Twitter, for example, users (represented
    by the *nodes* of the graph) are connected to each other. However, there are users
    that are more connected than others (influencers). On the Reddit social graph,
    users with similar characteristics tend to group into communities.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Twitter这样的社交网络图中，用户（由图的**节点**表示）相互连接。然而，有些用户比其他用户更连接（影响者）。在Reddit社交图中，具有相似特征的用户倾向于组成社区。
- en: 'We have already mentioned some of the *basic features* of graphs, such as the
    *number of nodes and edges* in a graph, which constitute the size of the graph
    itself. Those properties already provide a good description of the structure of
    a network. Think about the Facebook graph, for example: it can be described in
    terms of the number of nodes and edges. Such numbers easily allow it to be distinguished
    from a much smaller network (for example, the social structure of an office) but
    fail to characterize more complex dynamics (for example, how *similar* nodes are
    connected). To this end, more advanced graph-derived **metrics** can be considered,
    which can be grouped into four main categories, outlined as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了一些图的**基本特征**，例如图中**节点和边的数量**，这些构成了图本身的大小。这些属性已经很好地描述了网络的结构。例如，考虑Facebook图：它可以由节点和边的数量来描述。这些数字很容易将其与一个远小的网络（例如，办公室的社会结构）区分开来，但无法表征更复杂的动态（例如，节点之间的**相似性**）。为此，可以考虑更高级的图衍生**指标**，这些指标可以分为以下四个主要类别，如下概述：
- en: '**Integration metrics**: These measure how nodes tend to be interconnected
    with each other.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整合度指标**：这些指标衡量节点之间相互连接的倾向。'
- en: '**Segregation metrics**: These quantify the presence of groups of interconnected
    nodes, known as communities or modules, within a network.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离度指标**：这些指标量化了网络中存在的一些相互连接的节点群，称为社区或模块。'
- en: '**Centrality metrics**: These assess the importance of individual nodes inside
    a network.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心度指标**：这些指标评估网络中单个节点的重要性。'
- en: '**Resilience metrics**: These can be thought of as a measure of how much a
    network is able to maintain and adapt its operational performance when facing
    failures or other adverse conditions.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性度指标**：这些指标可以被视为衡量网络在面对故障或其他不利条件时能够维持和适应其操作性能的程度。'
- en: Those metrics are defined as **global** when expressing a measure of an overall
    network. On the other hand, **local** metrics measure values of individual network
    elements (nodes or edges). In weighted graphs, each property may or may not account
    for the *edge weights*, leading to **weighted and unweighted metrics**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标在表达整体网络的度量时被定义为**全局**的。另一方面，**局部**指标衡量单个网络元素（节点或边）的值。在加权图中，每个属性可能或可能不考虑到**边权重**，导致**加权和无权重指标**。
- en: In the following section, we describe some of the most commonly used metrics
    that measure global and local properties. For simplicity, unless specified differently
    in the text, we illustrate the global unweighted version of the metric. In several
    cases, this is obtained by averaging the local unweighted properties of the node.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述一些最常用的衡量全局和局部属性的指标。为了简单起见，除非文本中另有说明，我们将展示该指标的全球无权重版本。在几个案例中，这是通过平均节点的局部无权重属性获得的。
- en: Integration metrics
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合度指标
- en: In this section, some of the most frequently used integration metrics will be
    described.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述一些最常用的整合度指标。
- en: Distance, path, and shortest path
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 距离、路径和最短路径
- en: The concept of **distance** in a graph is often related to the number of edges
    to traverse in order to reach a target node from a given source node.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的**距离**概念通常与从给定的源节点到达目标节点所需跨越的边的数量相关。
- en: In particular, consider a source node ![](img/Formula_01_043.png) and a target
    node ![](img/Formula_01_044.png). The set of edges connecting node ![](img/Formula_01_045.png)
    to node![](img/Formula_01_046.png) is called a **path**. When studying complex
    networks, we are often interested in finding the **shortest path** between two
    nodes. A shortest path between a source node ![](img/Formula_01_047.png) and a
    target node ![](img/Formula_01_048.png) is the path having the lowest number of
    edges compared to all the possible paths between ![](img/Formula_01_049.png) and
    ![](img/Formula_01_050.png). The **diameter** of a network is the number of edges
    contained in the longest shortest path among all possible shortest paths.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是考虑一个源节点![](img/Formula_01_043.png)和一个目标节点![](img/Formula_01_044.png)。连接节点![](img/Formula_01_045.png)到节点![](img/Formula_01_046.png)的边集被称为**路径**。在研究复杂网络时，我们通常对在两个节点之间找到**最短路径**感兴趣。源节点![](img/Formula_01_047.png)和目标节点![](img/Formula_01_048.png)之间的最短路径是与所有可能的路径相比具有最少边的路径。网络的**直径**是所有可能最短路径中最长最短路径中包含的边的数量。
- en: 'Take a look at the following screenshot. There are different paths to reach
    **Tokyo** from **Dublin**. However, one of them is the shortest (the edges on
    the shortest path are highlighted):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的截图。从**都柏林**到**东京**有不同路径可走。然而，其中有一条是最短的（最短路径上的边被突出显示）：
- en: '![Figure 1.14 – The shortest path between two nodes'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14 – 两个节点之间的最短路径'
- en: '](img/B16069_01_014.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_01_014.jpg)'
- en: Figure 1.14 – The shortest path between two nodes
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 两个节点之间的最短路径
- en: 'The `shortest_path` function of the `networkx` Python library enables users
    to quickly compute the shortest path between two nodes in a graph. Consider the
    following code, in which a seven-node graph is created by using `networkx`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`networkx` Python库的`shortest_path`函数允许用户快速计算图中两个节点之间的最短路径。考虑以下代码，其中使用`networkx`创建了一个包含七个节点的图：'
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The shortest path between a source node (for example, `''Dublin''`, identified
    by the key 1) and a target node (for example, `''Tokyo''`, identified by the key
    7) can be obtained as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式获得源节点（例如，`'Dublin'`，由键1标识）和目标节点（例如，`'Tokyo'`，由键7标识）之间的最短路径：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This should output the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, `[1,3,4,5,7]` are the nodes contained in the shortest path between `'Tokyo'`
    and `'Dublin'`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`[1,3,4,5,7]`是`'Tokyo'`和`'Dublin'`之间最短路径中包含的节点。
- en: Characteristic path length
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特征路径长度
- en: 'The **characteristic path length** is defined as the average of all the shortest
    path lengths between all possible pair of nodes. If ![](img/Formula_01_051.png)
    is the average path length between the node![](img/Formula_01_052.png) and all
    the other nodes, the characteristic path length is computed as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**特征路径长度**定义为所有可能节点对之间最短路径长度的平均值。如果![](img/Formula_01_051.png)是节点![](img/Formula_01_052.png)与所有其他节点之间的平均路径长度，则特征路径长度计算如下：'
- en: '![](img/Formula_01_053.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_053.jpg)'
- en: 'Here, ![](img/Formula_01_054.png) is the set of nodes in the graph and ![](img/Formula_01_055.png)
    represents its *order*. This is one of the most commonly used measures of how
    efficiently information is spread across a network. Networks having shorter characteristic
    path lengths promote the quick transfer of information and reduce costs. Characteristic
    path length can be computed through `networkx` using the following function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![](img/Formula_01_054.png)是图中的节点集，![](img/Formula_01_055.png)代表其*阶数*。这是衡量信息在网络中传播效率的最常用指标之一。具有较短特征路径长度的网络促进了信息的快速传输并降低了成本。特征路径长度可以通过`networkx`使用以下函数计算：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should give us the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给出以下结果：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, this metric cannot be always defined since it is not possible to compute
    a path among all the nodes in *disconnected graphs*. For this reason, **network
    efficiency** is also widely used.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个指标并不总是可以定义的，因为在*断开连接的图*中无法计算所有节点之间的路径。因此，**网络效率**也被广泛使用。
- en: Global and local efficiency
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局和局部效率
- en: '**Global efficiency** is the average of the inverse shortest path length for
    all pairs of nodes. Such a metric can be seen as a measure of how efficiently
    information is exchanged across a network. Consider that ![](img/Formula_01_056.png)
    is the shortest path between a node ![](img/Formula_01_057.png) and a node ![](img/Formula_01_058.png).
    The network efficiency is defined as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局效率**是所有节点对之间最短路径长度的倒数平均值。这样的指标可以被视为衡量信息在网络中交换效率的度量。考虑 ![](img/Formula_01_056.png)
    是节点 ![](img/Formula_01_057.png) 和节点 ![](img/Formula_01_058.png) 之间的最短路径。网络效率定义为以下：'
- en: '![](img/Formula_01_059.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_059.jpg)'
- en: Efficiency is at a maximum when a graph is fully connected, while it is minimal
    for completely disconnected graphs. Intuitively, the shorter the path, the lower
    the measure.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当图完全连接时，效率达到最大，而对于完全断开的图，效率最小。直观上，路径越短，度量值越低。
- en: 'The `networkx` using the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令的 `networkx`：
- en: '[PRE32]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output should be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是以下内容：
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Average local efficiency is computed in `networkx` using the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 平均局部效率在 `networkx` 中使用以下命令计算：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output should be as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是以下内容：
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the following screenshot, two examples of graphs are depicted. As observed,
    a fully connected graph on the left presents a higher level of efficiency compared
    to a circular graph on the right. In a fully connected graph, each node can be
    reached from any other node in the graph, and information is exchanged rapidly
    across the network. However, in a circular graph, several nodes should instead
    be traversed to reach the target node, making it less efficient:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，展示了两个图的示例。如观察到的，左边的完全连接图比右边的环形图具有更高的效率。在完全连接图中，图中的每个节点都可以从任何其他节点访问，信息在网络中快速交换。然而，在环形图中，需要遍历多个节点才能到达目标节点，这使得其效率较低：
- en: '![Figure 1.15 – Global efficiency of a fully connected graph (left) and a circular
    graph (right)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.15 – 完全连接图（左）和环形图（右）的全局效率'
- en: '](img/B16069_01_015.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_01_015.jpg)'
- en: Figure 1.15 – Global efficiency of a fully connected graph (left) and a circular
    graph (right)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 完全连接图（左）和环形图（右）的全局效率
- en: Integration metrics well describe the connection among nodes. However, more
    information about the presence of groups can be extracted by considering segregation
    metrics.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 集成指标很好地描述了节点之间的连接。然而，通过考虑隔离度指标，可以提取更多关于群体存在的信息。
- en: Segregation metrics
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离度指标
- en: In this section, some of the most common segregation metrics will be described.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，将描述一些最常见的隔离度指标。
- en: Clustering coefficient
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚类系数
- en: 'The `networkx` using the following command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令的 `networkx`：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should output the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The local clustering coefficient is computed in `networkx` using the following
    command:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 局部聚类系数在 `networkx` 中使用以下命令计算：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This should output the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is a Python dictionary containing, for each node (identified by
    the respective key), the corresponding value. In the graph represented in *Figure
    1.16*, two clusters of nodes can be easily identified. By computing the clustering
    coefficient for each single node, it can be observed that **Rome** has the lowest
    value. **Tokyo** and **Moscow**, as well as **Paris** and **Dublin**, are instead
    very well connected within their respective groups (notice the size of each node
    is drawn proportionally to each node''s clustering coefficient). The graph can
    be seen in the following screenshot:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个 Python 字典，其中包含每个节点（由相应的键标识）的对应值。在 *图 1.16* 所示的图中，可以轻松地识别出两个节点簇。通过计算每个单独节点的聚类系数，可以观察到
    **罗马** 具有最低的值。**东京**、**莫斯科**以及**巴黎**和**都柏林**在其各自群体内连接得非常好（注意每个节点的大小是按每个节点的聚类系数成比例绘制的）。以下截图显示了该图：
- en: '![Figure 1.16 – Local clustering coefficient representation'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.16 – 局部聚类系数表示'
- en: '](img/B16069_01_16.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16069_01_16.jpg)'
- en: Figure 1.16 – Local clustering coefficient representation
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 局部聚类系数表示
- en: Transitivity
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递性
- en: 'A common variant of the clustering coefficient is known as `networkx`, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数的一个常见变体被称为 `networkx`，如下所示：
- en: '[PRE40]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output should be as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是以下内容：
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Modularity
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块度
- en: '**Modularity** was designed to quantify the division of a network in aggregated
    sets of highly interconnected nodes, commonly known as **modules**, **communities**,
    **groups**, or **clusters**. The main idea is that networks having high modularity
    will show dense connections within the module and sparse connections between modules.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块度**被设计用来量化网络在高度互连的节点聚合集合中的划分，通常称为 **模块**、**社区**、**群体**、**簇** 或 **集群**。主要思想是，具有高模块度的网络将在模块内显示密集的连接，而在模块之间显示稀疏的连接。'
- en: 'Consider a social network such as Reddit: members of communities related to
    video games tend to interact much more with other users in the same community,
    talking about recent news, favorite consoles, and so on. However, they will probably
    interact less with users talking about fashion. Differently from many other graph
    metrics, modularity is often computed by means of optimization algorithms.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个像 Reddit 这样的社交网络：与视频游戏相关的社区成员往往与其他社区成员互动更多，谈论最新新闻、最喜欢的游戏机等等。然而，他们可能不会与谈论时尚的用户互动很多。与许多其他图度量不同，模块度通常通过优化算法计算。
- en: 'Modularity in `networkx` is computed using the `modularity` function of the
    `networkx.algorithms.community` module, as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `networkx` 中，使用 `networkx.algorithms.community` 模块的 `modularity` 函数计算模块度，如下所示：
- en: '[PRE42]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, the second argument—`communities`—is a list of sets, each representing
    a partition of the graph. The output should be as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第二个参数—`communities`—是一个集合列表，每个集合代表图的某个划分。输出应如下所示：
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Segregation metrics help to understand the presence of groups. However, each
    node in a graph has its own *importance*. To quantify it, we can use centrality
    metrics.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔度量标准有助于理解群组的存在。然而，图中的每个节点都有其自身的 *重要性*。为了量化它，我们可以使用中心性度量。
- en: Centrality metrics
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中心性度量
- en: In this section, some of the most common centrality metrics will be described.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，将描述一些最常见的中心性度量。
- en: Degree centrality
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 度中心性
- en: One of the most common and simple centrality metrics is the **degree centrality**
    metric. This is directly connected with the *degree* of a node, measuring the
    number of *incident* edges on a certain node ![](img/Formula_01_060.png).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见且简单的中心性度量之一是 **度中心性**度量。这与节点的 *度* 直接相关，测量某个节点 ![](img/Formula_01_060.png)
    上的 *入边* 数量。
- en: 'Intuitively, the more a node is connected to an other node, the more its degree
    centrality will assume high values. Note that, if a graph is *directed*, the `networkx`
    by using the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，一个节点与其他节点连接得越多，其度中心性就会越高。请注意，如果图是 *有向的*，则 `networkx` 使用以下命令：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output should be as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Closeness centrality
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接近中心性
- en: 'The **closeness centrality** metric attempts to quantify how much a node is
    close (well connected) to other nodes. More formally, it refers to the average
    distance of a node ![](img/Formula_01_061.png) to all other nodes in the network.
    If ![](img/Formula_01_062.png) is the shortest path between node ![](img/Formula_01_063.png)
    and node ![](img/Formula_01_064.png), the closeness centrality is defined as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**接近中心性**度量试图量化一个节点与其他节点有多接近（连接良好）。更正式地说，它指的是节点 ![](img/Formula_01_061.png)
    到网络中所有其他节点的平均距离。如果 ![](img/Formula_01_062.png) 是节点 ![](img/Formula_01_063.png)
    和节点 ![](img/Formula_01_064.png) 之间的最短路径，则接近中心性定义为以下：'
- en: '![](img/Formula_01_065.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_065.jpg)'
- en: 'Here, *V* is the set of nodes in the graph. Closeness centrality can be computed
    in `networkx` using the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*V* 是图中节点的集合。接近中心性可以使用 `networkx` 中的以下命令计算：
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output should be as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Betweenness centrality
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介数中心性
- en: The **betweenness centrality** metric evaluates how much a node acts as a **bridge**
    between other nodes. Even if poorly connected, a node can be strategically connected,
    helping to keep the whole network connected.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**介数中心性**度量评估一个节点作为其他节点之间 **桥梁** 的作用程度。即使连接性较差，一个节点也可以通过战略性地连接，帮助保持整个网络的连接。'
- en: 'If ![](img/Formula_01_066.png) is the total number of shortest paths between
    node ![](img/Formula_01_067.png) and node ![](img/Formula_01_068.png) and ![](img/Formula_01_069.png)
    is the total number of shortest paths between ![](img/Formula_01_070.png) and
    ![](img/Formula_01_071.png) passing through node ![](img/Formula_01_072.png),
    then the betweenness centrality is defined as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ![](img/Formula_01_066.png) 是节点 ![](img/Formula_01_067.png) 和节点 ![](img/Formula_01_068.png)
    之间最短路径的总数，而 ![](img/Formula_01_069.png) 是通过节点 ![](img/Formula_01_072.png) 连接 ![](img/Formula_01_070.png)
    和 ![](img/Formula_01_071.png) 的最短路径的总数，那么介数中心性定义为以下：
- en: '![](img/Formula_01_073.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_01_073.jpg)'
- en: 'If we observe the formula, we can notice that the higher the number of shortest
    paths passing through node ![](img/Formula_01_074.png), the higher the value of
    the betweenness centrality. Betweenness centrality is computed in `networkx` by
    using the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察公式，我们可以注意到，通过节点![](img/Formula_01_074.png)经过的最短路径数量越多，中介中心性的值就越高。中介中心性在`networkx`中通过以下命令计算：
- en: '[PRE48]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output should be as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In *Figure 1.17*, we illustrate the difference between *degree centrality*,
    *closeness centrality*, and *betweenness centrality*. **Milan** and **Naples**
    have the highest degree centrality. **Rome** has the highest closeness centrality
    since it is the closest to any other node. It also shows the highest betweenness
    centrality because of its crucial role in connecting the two visible clusters
    and keeping the whole network connected.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1.17*中，我们展示了*度中心性*、*接近中心性*和*中介中心性*之间的差异。**米兰**和**那不勒斯**具有最高的度中心性。**罗马**具有最高的接近中心性，因为它与其他任何节点距离最近。它还显示出最高的中介中心性，因为其在连接两个可见集群并保持整个网络连通方面发挥着关键作用。
- en: 'You can see the differences here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到差异：
- en: '![Figure 1.17 – Degree centrality (left), closeness centrality (center), and
    betweenness centrality (right)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.17 – 度中心性（左），接近中心性（中），和中介中心性（右）]'
- en: '](img/B16069_01_017.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16069_01_017.jpg)'
- en: Figure 1.17 – Degree centrality (left), closeness centrality (center), and betweenness
    centrality (right)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17 – 度中心性（左），接近中心性（中），和中介中心性（右）
- en: Centrality metrics allow us to measure the importance of a node inside the network.
    Finally, we will mention resilience metrics, which enable us to measure the vulnerability
    of a graph.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性度量允许我们衡量网络中节点的相对重要性。最后，我们将提到弹性度量，它使我们能够衡量图的脆弱性。
- en: Resilience metrics
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性度量
- en: There are several metrics that measure a network's resilience. Assortativity
    is one of the most used.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种度量指标可以衡量网络的弹性。配对性是最常用的之一。
- en: Assortativity coefficient
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配对系数
- en: '`networkx` by using the following command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令：
- en: '[PRE50]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output should be as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE51]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Social networks are mostly assortative. However, the so-called *influencers*
    (famous singers, football players, fashion bloggers) tend to be *followed* (incoming
    edges) by several standard users, while tending to be connected with each other
    and showing a disassortative behavior.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 社交网络大多是配对的。然而，所谓的*影响者*（著名歌手、足球运动员、时尚博主）往往被几个标准用户*跟随*（入边），同时倾向于相互连接并表现出去配对行为。
- en: It is important to remark that the previously presented properties are a subset
    of all the possible metrics used to describe graphs. A wider set of metrics and
    algorithms can be found at [https://networkx.org/documentation/stable/reference/algorithms/](https://networkx.org/documentation/stable/reference/algorithms/).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是指出，之前提出的性质是描述图的所有可能度量指标的一个子集。更广泛的度量指标和算法可以在[https://networkx.org/documentation/stable/reference/algorithms/](https://networkx.org/documentation/stable/reference/algorithms/)找到。
- en: Benchmarks and repositories
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准和存储库
- en: Now that we have understood the basic concepts and notions about graphs and
    network analysis, it is now time to dive into some practical examples that will
    help us to start to put into practice the general concepts we have learned so
    far. In this section, we will present some examples and toy problems that are
    generally used to study the properties of networks, as well as benchmark performances
    and effectiveness of networks' algorithms. We will also provide some useful links
    of repositories where network datasets can be found and downloaded, together with
    some tips on how to parse and process them.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了关于图和网络分析的基本概念和概念，现在是时候深入一些实际例子，这些例子将帮助我们开始将我们迄今为止学到的通用概念付诸实践。在本节中，我们将展示一些通常用于研究网络性质、基准性能和网络算法有效性的示例和玩具问题。我们还将提供一些有用的链接，其中可以找到并下载网络数据集，以及一些关于如何解析和处理它们的技巧。
- en: Examples of simple graphs
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单图的示例
- en: 'We start by looking at some very simple examples of networks. Fortunately,
    `networkx` already comes with a number of graphs already implemented, ready to
    be used and played with. Let''s start by creating a **fully connected undirected
    graph**, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看一些非常简单的网络示例。幸运的是，`networkx`已经包含了一些已经实现好的图，可以用来使用和玩耍。让我们首先创建一个**完全连接的无向图**，如下所示：
- en: '[PRE52]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This has ![](img/Formula_01_075.png) edges and a clustering coefficient *C=1*.
    Although fully connected graphs are not very interesting on their own, they represent
    a fundamental building block that may arise within larger graphs. A fully connected
    subgraph of *n* nodes within a larger graph is generally referred to as a **clique**
    of size *n*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这有![](img/Formula_01_075.png)条边和一个聚类系数*C=1*。虽然完全连接的图本身可能不太有趣，但它们代表了一个基本构建块，可能在更大的图中出现。在更大的图中，*n*个节点的完全连接子图通常被称为大小为*n*的**团**。
- en: Definition
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 定义
- en: A **clique**, *C*, in an undirected graph is defined a subset of its vertices, *C *![](img/Formula_01_077.png)* V*,
    such that every two distinct vertices in the subset are adjacent. This is equivalent
    to the condition that the induced subgraph of *G* induced by *C* is a fully connected
    graph.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在无向图中的一个**团**，记为*C*，定义为它的顶点的一个子集，*C*![](img/Formula_01_077.png)*V*，使得子集中的每两个不同的顶点都是相邻的。这等价于条件，即由*C*诱导的*G*的子图是一个完全连接的图。
- en: Cliques represent one of the basic concepts in graph theory and are often also
    used in mathematical problems where relations need to be encoded. Besides, they
    also represent the simplest unit when constructing more complex graphs. On the
    other hand, the task of finding cliques of a given size *n* in larger graphs (clique
    problem) is of great interest and it can be shown that it is a **nondeterministic
    polynomial-time complete** (**NP-complete**) problem often studied in computer
    science.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 团是图论中的基本概念之一，也常用于需要编码关系的数学问题中。此外，它们也代表构建更复杂图时的最简单单元。另一方面，在更大的图中找到给定大小*n*的团的任务（团问题）非常有趣，并且可以证明它是一个在计算机科学中经常研究的**非确定性多项式时间完备**（**NP-完备**）问题。
- en: 'Some simple examples of `networkx` graphs can be seen in the following screenshot:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`networkx`图的简单示例：
- en: '![Figure 1.18 – Simple examples of graphs with networkx. (left) fully connected
    graph; (center) lollipop graph; (right) barbell graph](img/B16069_01_18.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图1.18 – 使用networkx的图简单示例。（左）完全连接图；（中）棒棒糖图；（右）哑铃图](img/B16069_01_18.jpg)'
- en: 'Figure 1.18 – Simple examples of graphs with networkx: (left) fully connected
    graph; (center) lollipop graph; (right) barbell graph'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18 – 使用networkx的图简单示例：（左）完全连接图；（中）棒棒糖图；（右）哑铃图
- en: 'In *Figure 1.18*, we showed a complete graph along with two other simple examples
    containing cliques that can be easily generated with `networkx`, outlined as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1.18*中，我们展示了一个完整的图以及两个其他包含可以通过`networkx`轻松生成的团的其他简单示例，如下所述：
- en: 'A **lollipop graph** formed by a clique of size *n* and a branch of *m* nodes,
    as shown in the following code snippet:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由大小为*n*的团和*m*个节点的分支组成的**棒棒糖图**，如下代码片段所示：
- en: '[PRE53]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A **barbell graph** formed by two cliques of size *m1* and *m2* joined by a
    branch of nodes, which resembles the sample graph we used previously to characterize
    some of the global and local properties. The code to generate this is shown in
    the following snippet:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由两个大小为*m1*和*m2*的团通过节点分支连接而成的**哑铃图**，这与我们之前用来描述一些全局和局部属性的样本图相似。生成此图的代码如下所示：
- en: '[PRE54]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Such simple graphs are basic building blocks that can be used to generate more
    complex networks by combining them. Merging subgraphs is very easy with `networkx`
    and can be done with just a few lines of code, as shown in the following code
    snippet, where the three graphs are merged together into a single graph and some
    random edges are placed to connect them:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这类简单图是基本构建块，可以通过组合它们来生成更复杂的网络。使用`networkx`合并子图非常容易，只需几行代码即可完成，如下代码片段所示，其中三个图合并成一个图，并放置了一些随机边来连接它们：
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Other very simple graphs (that can then be merged and played around with) can
    be found at [https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 其他非常简单的图（然后可以合并并加以利用）可以在[https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.classic)找到。
- en: Generative graph models
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成图模型
- en: Although creating simple subgraphs and merging them is a way to generate new
    graphs of increasing complexity, networks may also be generated by means of **probabilistic
    models** and/or **generative models** that let a graph grow by itself. Such graphs
    usually share interesting properties with real networks and have long been used
    to create benchmarks and synthetic graphs, especially in times when the amount
    of data available was not as overwhelming as today. Here, we present some examples
    of random generated graphs, briefly describing the models that underlie them.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过创建简单的子图并将它们合并是生成越来越复杂的新图的一种方法，但网络也可以通过**概率模型**和/或**生成模型**来生成，这些模型允许图自行增长。这类图通常与真实网络共享有趣的属性，并且长期以来一直被用来创建基准和合成图，尤其是在数据量不像今天这样庞大的时代。在这里，我们展示了随机生成的图的示例，并简要描述了它们背后的模型。
- en: Watts and Strogatz (1998)
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Watts和Strogatz（1998）
- en: 'This model was used by the authors to study the behavior of **small-world networks**—that
    is to say, networks that resemble, to some extent, common social networks. The
    graph is generated by first displacing *n* nodes in a ring and connecting each
    node with its *k* neighbors. Each edge of such a graph then has a probability
    *p* of being rewired to a randomly chosen node. By ranging *p*, the Watts and
    Strogatz model allows a shift from a regular network (*p=0*) to a completely random
    network (*p=1*). In between, graphs exhibit small-world features; that is, they
    tend to bring this model closer to social network graphs. These kinds of graphs
    can be easily created with the following command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 作者使用此模型研究了**小世界网络**的行为——也就是说，在某种程度上类似于常见社交网络的网络。首先将*n*个节点放置在环中，然后连接每个节点与其*k*个邻居。然后，此类图的每条边都有一个概率*p*，可能会重新布线到随机选择的节点。通过调整*p*，Watts和Strogatz模型允许从规则网络（*p=0*）过渡到完全随机网络（*p=1*）。在此之间，图表现出小世界特征；也就是说，它们倾向于使此模型更接近社交网络图。这些类型的图可以通过以下命令轻松创建：
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Barabási-Albert (1999)
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 巴巴什-阿尔伯特（1999）
- en: 'The model proposed by Albert and Barabási is based on a generative model that
    allows the creation of random scale-free networks by using a **preferential attachment**
    schema, where a network is created by progressively adding new nodes and attaching
    them to already existing nodes, with a preference for nodes that have more neighbors.
    Mathematically speaking, the underlying idea of this model is that the probability
    for a new node to be attached to an existing node *i* depends on the degree of
    the *i*-th node, according to the following formula:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔伯特和巴巴什提出的模型基于一个生成模型，该模型通过使用**优先连接**方案允许通过创建随机无标度网络，其中网络是通过逐步添加新节点并将它们连接到已存在的节点来创建的，优先连接到具有更多邻居的节点。从数学上讲，该模型的基本思想是，新节点连接到现有节点*i*的概率取决于*i*节点度，根据以下公式：
- en: '![](img/Formula_01_076.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![img/Formula_01_076.jpg](img/Formula_01_076.jpg)'
- en: Thus, nodes with a large number of edges (hubs) tend to develop even more edges,
    whereas nodes with few links will not develop other links (periphery). Networks
    generated by this model exhibit a *power-law distribution* for the connectivity
    (that is, degree) between nodes. Such a behavior is also found in real networks
    (for example, the `networkx`) to also allow the preferential attachment of new
    edges or rewiring of existing edges.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具有大量边（枢纽）的节点倾向于发展更多的边，而具有少量链接的节点则不会发展其他链接（边缘）。由该模型生成的网络在节点之间的连接度（即度）上表现出**幂律分布**。这种行为也存在于真实网络中（例如，`networkx`），也允许新边的优先连接或现有边的重新布线。
- en: 'The Barabási-Albert model is illustrated in the following screenshot:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了巴巴什-阿尔伯特模型：
- en: '![Figure 1.19 – Barabási-Albert model (left) with 20 nodes (right) distribution
    of connectivity with n=100.000 nodes, showing the scale-free power law distribution](img/B16069_01_19.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 1.19 – 巴巴什-阿尔伯特模型（左）具有20个节点（右）的连接度分布，n=100.000个节点，显示了无标度幂律分布](img/B16069_01_19.jpg)'
- en: Figure 1.19 – Barabási-Albert model (left) with 20 nodes (right) distribution
    of connectivity with n=100.000 nodes, showing the scale-free power law distribution
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19 – 巴巴什-阿尔伯特模型（左）具有20个节点（右）的连接度分布，n=100,000个节点，显示了无标度幂律分布
- en: 'In *Figure 1.19*, we showed an example of the Barabasi-Albert model for a small
    network, where you can already observe the emergence of hubs (on the left), as
    well as the probability distribution of the degree of the nodes, which exhibits
    a scale-free power-law behavior (on the right). The preceding distribution can
    easily be replicated in `networkx`, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图1.19**中，我们展示了小网络的Barabási-Albert模型的一个示例，您已经可以观察到中心节点的出现（在左侧），以及节点的度数概率分布，它表现出无标度幂律行为（在右侧）。前面的分布可以很容易地在`networkx`中复制，如下所示：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Benchmarks
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试
- en: Digitalization has profoundly changed our lives, and today, any activity, person,
    or process generates data, providing a huge amount of information to be drilled,
    analyzed, and used to promote data-driven decision making. A few decades ago,
    it was hard to find datasets ready to be used to develop or test new algorithms.
    On the other hand, there exist today plenty of repositories that provide us with
    datasets, even of fairly large dimensions, to be downloaded and analyzed. These
    repositories, where people can share datasets, also provide a benchmark where
    algorithms can be applied, validated, and compared with each other.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 数字化深刻地改变了我们的生活，如今，任何活动、个人或过程都会产生数据，提供了大量需要挖掘、分析和用于促进数据驱动决策的信息。几十年前，很难找到可用于开发或测试新算法的数据集。另一方面，现在有大量的存储库为我们提供了数据集，甚至是一些相当大的数据集，可以下载和分析。这些允许人们共享数据集的存储库，还提供了一个基准，算法可以在其中应用、验证和相互比较。
- en: In this section, we will briefly go through some of the main repositories and
    file formats used in network science, in order to provide you with all the tools
    needed to import datasets—of different sizes—to analyze and play around with.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要介绍网络科学中使用的某些主要存储库和文件格式，以便为您提供所有必要的工具来导入不同大小的数据集，以便分析和实验。
- en: In such repositories, you will find network datasets coming from some of the
    common areas of network science, such as social networks, biochemistry, dynamic
    networks, documents, co-authoring and citations networks, and networks arising
    from financial transactions. In *Part 3*, *Advanced Applications of Graph Machine
    Learning*, we will discuss some of the most common type of networks (social networks,
    graphs arising when processing corpus documents, and financial networks) and analyze
    them more thoroughly by applying the techniques and algorithms described in *Part
    2*, *Machine Learning on Graphs*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些存储库中，您将找到来自网络科学的一些常见领域的网络数据集，例如社交网络、生物化学、动态网络、文档、共同作者和引用网络，以及由金融交易产生的网络。在**第3部分**，**图机器学习的先进应用**中，我们将讨论一些最常见的网络类型（社交网络、处理语料库文档时产生的图和金融网络），并通过应用在第2部分**图上的机器学习**中描述的技术和算法，对这些网络进行更深入的分析。
- en: Also, `networkx` already comes with some basic (and very small) networks that
    are generally used to explain algorithms and basic measures, which can be found
    at [https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social).
    These datasets are, however, generally quite small. For larger datasets, refer
    to the repositories we present next.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`networkx`已经包含了一些基本（且非常小）的网络，通常用于解释算法和基本度量，这些可以在[https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social](https://networkx.org/documentation/stable/reference/generators.html#module-networkx.generators.social)找到。然而，这些数据集通常相当小。对于更大的数据集，请参考我们接下来介绍的存储库。
- en: Network Data Repository
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络数据存储库
- en: The **Network Data Repository** is surely one of the largest repositories of
    network data ([http://networkrepository.com/](http://networkrepository.com/))
    with several thousand different networks, featuring users and donations from all
    over the world and top-tier academic institutions. If a network dataset is freely
    available, chances are that you will find it there. Datasets are classified in
    about *30 domains*, including biology, economics, citations, social network data,
    industrial applications (energy, road), and many others. Besides providing the
    data, the website also provides a tool for interactive visualization, exploration,
    and comparison of datasets, and we suggest you check it out and explore it.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络数据仓库**无疑是最大的网络数据仓库之一（[http://networkrepository.com/](http://networkrepository.com/)），拥有数千个不同的网络，包括来自世界各地和顶级学术机构的用户和捐赠。如果一个网络数据集是免费提供的，那么你很可能在那里找到它。数据集被分为大约**30个领域**，包括生物学、经济学、引用、社交网络数据、工业应用（能源、道路）等。除了提供数据外，该网站还提供了一种用于交互式可视化、探索和比较数据集的工具，我们建议您查看并探索它。'
- en: The data in the Network Data Repository is generally available under the **Matrix
    Market Exchange Format** (**MTX**) file format. The MTX file format is basically
    a file format for specifying dense or sparse matrices, real or complex, via readable
    text files (**American Standard Code for Information Interchange**, or **ASCII**).
    For more details, please refer to [http://math.nist.gov/MatrixMarket/formats.html#MMformat](http://math.nist.gov/MatrixMarket/formats.html#MMformat).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 网络数据仓库中的数据通常以**矩阵市场交换格式**（**MTX**）文件格式提供。MTX文件格式基本上是一种通过可读文本文件（美国信息交换标准代码，或**ASCII**）指定密集或稀疏矩阵、实数或复数的文件格式。有关更多详细信息，请参阅[http://math.nist.gov/MatrixMarket/formats.html#MMformat](http://math.nist.gov/MatrixMarket/formats.html#MMformat)。
- en: 'A file in MTX format can be easily read in Python using `scipy`. Some of the
    files we downloaded from the Network Data Repository seemed slightly corrupted
    and required a minimal fix on a 10.15.2 OSX system. In order to fix them, just
    make sure the header of the file is compliant with the format specifications;
    that is, with a double `%` and no spaces at the beginning of the line, as in the
    following line:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`scipy`可以轻松地在Python中读取MTX格式的文件。我们从网络数据仓库下载的一些文件似乎略有损坏，并在10.15.2的OSX系统上需要最小的修复。为了修复它们，只需确保文件的标题与格式规范一致；即，行首有一个双`%`符号且没有空格，如下面的行所示：
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Matrices should be in coordinate format. In this case, the specification points
    also to an unweighted, undirected graph (as understood by `pattern` and `symmetric`).
    Some of the files have some comments after the first header line, which are preceded
    by a single `%`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵应以坐标格式表示。在这种情况下，规范也指向一个无权、无向图（由`pattern`和`symmetric`理解）。一些文件在第一行标题之后有一些注释，这些注释由单个`%`符号开头。
- en: 'As an example, we consider the **Astro Physics** (**ASTRO-PH**) collaboration
    network. The graph is generated using all the scientific papers available from
    the e-print *arXiv* repository published in the *Astrophysics* category in the
    period from January 1993 to April 2003\. The network is built by connecting (via
    undirected edges) all the authors that co-authored a publication, thus resulting
    in a clique that includes all authors of a given paper. The code to generate the
    graph can be seen here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们考虑**天体物理学**（**ASTRO-PH**）合作网络。该图是通过使用从1993年1月到2003年4月期间在*arXiv*存档中发布的*天体物理学*类别下的所有科学论文生成的。该网络是通过连接（通过无向边）共同撰写出版物的所有作者来构建的，从而形成一个包括给定论文所有作者的团。生成图的代码可以在以下位置查看：
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The dataset has 17,903 nodes, connected by 196,072 edges. Visualizing so many
    nodes cannot be done easily, and even if we were to do it, it might not be very
    informative, as understanding the underlying structure would not be very easy
    with so much information. However, we can get some insights by looking at specific
    subgraphs, as we will do next.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集有17,903个节点，通过196,072条边连接。可视化如此多的节点并不容易，即使我们尝试这样做，也可能不太有用，因为如此多的信息下，理解底层结构可能并不容易。然而，我们可以通过查看特定的子图来获得一些见解，正如我们接下来将要做的。
- en: 'First, we can start by computing some basic properties we described earlier
    and put them into a pandas `DataFrame` for our convenience to later use, sort,
    and analyze. The code to accomplish this is illustrated in the following snippet:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以从计算我们之前描述的一些基本属性开始，并将它们放入pandas `DataFrame`中以方便我们稍后使用、排序和分析。完成此操作的代码如下所示：
- en: '[PRE60]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can easily find out that the node with the largest `6933`, which has 503
    neighbors (surely a very popular and important scientist in astrophysics!), as
    illustrated in the following code snippet:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地发现具有最大 `6933` 的节点，它有 503 个邻居（肯定是一位在天体物理学中非常受欢迎和重要的科学家！），如下面的代码片段所示：
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Of course, also plotting its `C_i` values. The code to accomplish this is shown
    in the following code snippet:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以绘制其 `C_i` 值。完成此操作的代码如下所示：
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can then define a simple function for extracting and plotting a subgraph
    that includes only the nodes related to certain indices, as shown in the following
    code snippet:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义一个简单的函数来提取和绘制只包含与某些索引相关的节点的子图，如下面的代码片段所示：
- en: '[PRE63]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Using the preceding function, we can plot the different subgraphs, obtained
    by filtering the ego network using the three different criteria, based on random
    sampling, centrality, and the clustering coefficient we presented previously.
    An example is provided here:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的函数，我们可以绘制出通过使用随机抽样、中心性和我们之前提到的聚类系数这三个不同标准过滤自我网络所获得的不同子图。这里提供了一个示例：
- en: '[PRE64]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In *Figure 1.20*, we compare these results where the other networks have been
    obtained by changing the key value to `centrality` and `C_i`. The random representation
    seems to show some emerging structure with separated communities. The graph with
    the most central nodes clearly shows an almost fully connected network, possibly
    made up of all full professors and influential figures in astrophysics science,
    publishing on multiple topics and collaborating frequently with each other. Finally,
    the last representation, on the other hand, highlights some specific communities,
    possibly connected with a specific topic, by selecting the nodes that have a higher
    clustering coefficient. These nodes might not have a large degree of centrality,
    but they very well represent specific topics. You can see examples of the ego
    subgraph here:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 1.20* 中，我们比较了这些结果，其中其他网络是通过将键值更改为 `centrality` 和 `C_i` 获得的。随机表示似乎显示出一些分离的社区结构。具有最多中心节点的图显然是一个几乎完全连接的网络，可能由所有全职教授和天体物理学科学界有影响力的人物组成，他们在多个主题上出版并频繁合作。最后，另一种表示方式通过选择具有更高聚类系数的节点来突出显示一些特定的社区，这些社区可能与特定主题相关。这些节点可能没有很大的中心度，但它们很好地代表了特定主题。您可以在以下位置看到自我子图的示例：
- en: '![Figure 1.20 – Examples of the ego subgraph for the node that has largest
    degree in the ASTRO-PH dataset. Neighbors are sampled with a ratio=0.1\. (left)
    random sampling; (center) nodes with largest betweenness centrality; (right) nodes
    with largest clustering coefficient](img/B16069_01_20.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20 – ASTRO-PH 数据集中度最大的节点的自我子图示例。邻居以比率=0.1 进行抽样。（左）随机抽样；（中）具有最大介数中心性的节点；（右）具有最大聚类系数的节点](img/B16069_01_20.jpg)'
- en: Figure 1.20 – Examples of the ego subgraph for the node that has largest degree
    in the ASTRO-PH dataset. Neighbors are sampled with a ratio=0.1\. (left) random
    sampling; (center) nodes with largest betweenness centrality; (right) nodes with
    largest clustering coefficient
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – ASTRO-PH 数据集中度最大的节点的自我子图示例。邻居以比率=0.1 进行抽样。（左）随机抽样；（中）具有最大介数中心性的节点；（右）具有最大聚类系数的节点
- en: 'Another option to visualize this in `networkx` could also be to use the *Gephi*
    software that allows for fast filtering and visualizations of graphs. In order
    to do so, we need to first export the data as **Graph Exchange XML Format** (**GEXF**)
    (which is a file format that can be imported in Gephi), as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在 `networkx` 中可视化的选项是使用允许快速过滤和图形可视化的 *Gephi* 软件。为了做到这一点，我们首先需要将数据导出为 **Graph
    Exchange XML Format** （**GEXF**）（这是一种可以导入 Gephi 的文件格式），如下所示：
- en: '[PRE65]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Once data is imported in Gephi, with few filters (by centrality or degree) and
    some computations (modularity), you can easily do plots as nice as the one shown
    in *Figure 1.21*, where nodes have been colored using modularity in order to highlight
    clusters. Coloring also allows us to easily spot nodes that connect the different
    communities and that therefore have large betweenness.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被导入 Gephi，通过少量过滤器（如中心性或度）和一些计算（如模块度），你可以轻松地绘制出如图 *图 1.21* 所示的漂亮图表，其中节点已根据模块度着色，以突出显示聚类。着色还使我们能够轻松地识别连接不同社区并因此具有较大介数的节点。
- en: Some of the datasets in the Network Data Repository may also be available in
    the `networkx` is to convert them by simply rewriting its header. Take, for instance,
    the **Digital Bibliography and Library** (**DBLP**) citation network.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 网络数据存储库中的某些数据集也可能在 `networkx` 中可用，通过简单地重写其标题即可转换。例如，**数字文献和图书馆**（**DBLP**）引用网络。
- en: 'A sample plot can be seen in the following screenshot:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图可以看到一个示例图表：
- en: '![Figure 1.21 – Example of the visualization ASTRO-PH dataset with Gephi. Nodes
    are filtered by degree centrality and colored by modularity class; node sizes
    are proportional to the value of the degree](img/B16069_01_21.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.21 – 使用 Gephi 可视化 ASTRO-PH 数据集的示例。节点通过度中心性进行筛选，并按模块化类别着色；节点大小与度值成比例](img/B16069_01_21.jpg)'
- en: Figure 1.21 – Example of the visualization ASTRO-PH dataset with Gephi. Nodes
    are filtered by degree centrality and colored by modularity class; node sizes
    are proportional to the value of the degree
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21 – 使用 Gephi 可视化 ASTRO-PH 数据集的示例。节点通过度中心性进行筛选，并按模块化类别着色；节点大小与度值成比例
- en: 'Here is the code for the header of the file:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文件标题的代码：
- en: '[PRE66]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This can be easily converted to comply with the MTX file format by replacing
    these lines with the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过用以下代码替换这些行来轻松地转换为符合 MTX 文件格式：
- en: '[PRE67]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Then, you can use the import functions described previously.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用之前描述的导入函数。
- en: Stanford Large Network Dataset Collection
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 斯坦福大型网络数据集集合
- en: Another valuable source of network datasets is the website of the **Stanford
    Network Analysis Platform** (**SNAP**) ([https://snap.stanford.edu/index.html](https://snap.stanford.edu/index.html)),
    which is a general-purpose network analysis library that was written in order
    to handle even fairly large graphs, with hundreds of millions of nodes and billions
    of edges. It is written in *C++* to achieve top computational performance, but
    it also features interfaces with Python in order to be imported and used in native
    Python applications.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个网络数据集的有价值来源是 **斯坦福网络分析平台**（**SNAP**）([https://snap.stanford.edu/index.html](https://snap.stanford.edu/index.html))
    的网站，这是一个通用网络分析库，旨在处理甚至相当大的图，拥有数亿个节点和数十亿条边。它用 *C++* 编写以实现顶级计算性能，但它还提供了与 Python
    的接口，以便在原生 Python 应用程序中导入和使用。
- en: Although `networkx` is currently the main library to study `networkx`, SNAP
    or other libraries (more on this shortly) can be orders of magnitude faster than
    `networkx`, and they may be used in place of `networkx` for tasks that require
    higher performance. In the SNAP website, you will find a specific web page for
    **Biomedical Network Datasets** ([https://snap.stanford.edu/biodata/index.html](https://snap.stanford.edu/biodata/index.html)),
    besides other more general networks ([https://snap.stanford.edu/data/index.html](https://snap.stanford.edu/data/index.html)),
    covering similar domains and datasets as the Network Data Repository described
    previously.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `networkx` 目前是研究 `networkx` 的主要库，但 SNAP 或其他库（稍后将有更多介绍）可能比 `networkx` 快几个数量级，并且可以在需要更高性能的任务中替代
    `networkx`。在 SNAP 网站上，你可以找到一个专门的网页用于 **生物医学网络数据集** ([https://snap.stanford.edu/biodata/index.html](https://snap.stanford.edu/biodata/index.html))，除了其他更通用的网络
    ([https://snap.stanford.edu/data/index.html](https://snap.stanford.edu/data/index.html))，覆盖了与之前描述的网络数据存储库类似的领域和数据集。
- en: 'Data is generally provided in a `networkx` in one code line, using the following
    command:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常在一行代码中提供 `networkx`，使用以下命令：
- en: '[PRE68]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Some graphs might have extra information, other than about edges. Extra information
    is included in the archive of the dataset as a separated file—for example, where
    some metadata of the nodes is provided and is related to the graph via the *id*
    node.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一些图可能包含关于边之外的信息。这些额外信息包含在数据集的存档中，作为一个单独的文件——例如，提供了节点的某些元数据，并且通过 *id* 节点与图相关联。
- en: 'Graphs can also be read directly using the SNAP library and its interface via
    Python. If you have a working version of SNAP on your local machine, you can easily
    read the data as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以直接使用 SNAP 库及其通过 Python 的接口读取。如果你在本地机器上有一个可工作的 SNAP 版本，你可以轻松地按以下方式读取数据：
- en: '[PRE69]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Keep in mind that at this point, you will have an instance of a `PNGraph` object
    of the SNAP library, and you can''t directly use `networkx` functionalities on
    this object. If you want to use some `networkx` functions, you first need to convert
    the `PNGraph` object to a `networkx` object. To make this process simpler, in
    the supplementary material for this book (available at [https://github.com/PacktPublishing/Graph-Machine-Learning](https://github.com/PacktPublishing/Graph-Machine-Learning)),
    we have written some functions that will allow you to seamlessly swap back and
    forth between `networkx` and SNAP, as illustrated in the following code snippet:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在此阶段，你将有一个SNAP库中的`PNGraph`对象的实例，并且你不能直接在这个对象上使用`networkx`的功能。如果你想使用一些`networkx`函数，你首先需要将`PNGraph`对象转换为`networkx`对象。为了使这个过程更简单，在这本书的补充材料（可在[https://github.com/PacktPublishing/Graph-Machine-Learning](https://github.com/PacktPublishing/Graph-Machine-Learning)找到）中，我们编写了一些函数，允许你在`networkx`和SNAP之间无缝切换，如下面的代码片段所示：
- en: '[PRE70]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Open Graph Benchmark
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开放图基准
- en: 'This is the most recent update (dated May 2020) in the graph benchmark landscape,
    and this repository is expected to gain increasing importance and support in the
    coming years. The **Open Graph Benchmark** (**OGB**) has been created to address
    one specific issue: current benchmarks are actually too small compared to real
    applications to be useful for **machine learning** (**ML**) advances. On one hand,
    some of the models developed on small datasets turn out to not be able to scale
    to large datasets, proving them unsuitable in real-world applications. On the
    other hand, large datasets also allow us to increase the capacity (complexity)
    of the models used in ML tasks and explore new algorithmic solutions (such as
    neural networks) that can benefit from a large sample size to be efficiently trained,
    allowing us to achieve very high performance. The datasets belong to diverse domains
    and they have been ranked on three different dataset sizes (small, medium, and
    large) where the small-size graphs, despite their name, already have more than
    100,000 nodes and/or more than 1 million edges. On the other hand, large graphs
    feature networks with more than 100 million nodes and more than 1 billion edges,
    facilitating the development of scalable models.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最新的图基准更新（日期为2020年5月），并且预计在未来几年中，这个仓库将获得越来越重要和广泛的支持。**开放图基准**（**OGB**）的创建是为了解决一个特定问题：与实际应用相比，当前的基准实际上太小，无法为**机器学习**（**ML**）的进步提供帮助。一方面，一些在小数据集上开发的模型最终无法扩展到大数据集，证明它们在现实世界应用中不适用。另一方面，大数据集也允许我们增加在ML任务中使用的模型的容量（复杂性），并探索新的算法解决方案（如神经网络），这些解决方案可以从大量样本中受益，以便有效地训练，从而实现非常高的性能。数据集属于不同的领域，并且它们已经在三个不同的数据集大小（小、中、大）上进行了排名，其中小尺寸图，尽管名称如此，已经拥有超过10万个节点和/或超过100万个边。另一方面，大型图具有超过1亿个节点和超过10亿个边的网络，这有助于可扩展模型的开发。
- en: Beside the datasets, the OGB also provides, in a *Kaggle fashion*, an end-to-end
    ML pipeline that standardizes the data loading, experimental setup, and model
    evaluation. OGB creates a platform to compare and evaluate models against each
    other, publishing a *leaderboard* that allows tracking of the performance evolution
    and advancements on specific tasks of node, edge, and graph property prediction.
    For more details on the datasets and on the OGB project, please refer to [https://arxiv.org/pdf/2005.00687.pdf](https://arxiv.org/pdf/2005.00687.pdf).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据集之外，OGB还以**Kaggle**风格提供了一套端到端的ML流程，该流程标准化了数据加载、实验设置和模型评估。OGB创建了一个平台，用于比较和评估模型之间的性能，发布了一个**排行榜**，允许跟踪特定任务（节点、边和图属性预测）的性能演变和进步。有关数据集和OGB项目的更多详细信息，请参阅[https://arxiv.org/pdf/2005.00687.pdf](https://arxiv.org/pdf/2005.00687.pdf)。
- en: Dealing with large graphs
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理大型图
- en: When approaching a use case or an analysis, it is very important to understand
    how large the data we focus on is or will be in the future, as the dimension of
    the datasets may very well impact both the technologies we use and the analysis
    that we can do. As already mentioned, some of the approaches that have been developed
    on small datasets hardly scale to real-world applications and larger datasets,
    making them useless in practice.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当接近一个用例或分析时，了解我们关注的数据的大小或未来将有多大非常重要，因为数据集的维度可能会极大地影响我们使用的技术和我们能够进行的分析。如前所述，一些在小数据集上开发的方法几乎无法扩展到现实世界应用和更大的数据集，这使得它们在实践中无用。
- en: When dealing with (possibly) large graphs, it is crucial to understand potential
    bottlenecks and limitation of the tools, technologies, and/or algorithms we use,
    assessing which part of our application/analysis may not scale when increasing
    the number of nodes or edges. Even more importantly, it is crucial to structure
    a data-driven application, however simple or at early **proof of concept** (**POC**)
    stages, in a way that would allow its scaling out in the future when data/users
    would increase, without rewriting the whole application.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理（可能）大型图时，理解我们所使用的工具、技术和/或算法的潜在瓶颈和限制至关重要，评估在增加节点或边数时，我们应用程序/分析的哪一部分可能无法扩展。更重要的是，无论数据驱动应用程序多么简单，或处于早期**概念验证**（**POC**）阶段，都需要以允许其未来在数据/用户增加时扩展的方式构建，而无需重写整个应用程序。
- en: Creating a data-driven application that resorts to graphical representation/modeling
    is a challenging task that requires a design and implementation that is a lot
    more complicated than simply importing `networkx`. In particular, it is often
    useful to decouple the component that processes the graph—named **graph processing
    engine**—from the one that allows querying and traversing the graph—the **graph
    storage layer**. We will further discuss these concepts in [*Chapter 9*](B16069_09_Final_JM_ePub.xhtml#_idTextAnchor141),
    *Building a Data-Driven Draft-Powered Application*. Nevertheless, given the focus
    of the book on ML and analytical techniques, it makes sense to focus more on graph
    processing engines than on graph storage layers. We therefore find it useful to
    provide you already at this stage with some of the technologies that are used
    for graph processing engines to deal with large graphs, crucial when scaling out
    an application.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个依赖于图形表示/建模的数据驱动应用程序是一项具有挑战性的任务，其设计和实现比简单地导入`networkx`要复杂得多。特别是，将处理图的组件（称为**图处理引擎**）与允许查询和遍历图的组件（**图存储层**）解耦通常很有用。我们将在[*第9章*](B16069_09_Final_JM_ePub.xhtml#_idTextAnchor141)《构建数据驱动应用程序》中进一步讨论这些概念。然而，鉴于本书的重点是机器学习和分析技术，更多地关注图处理引擎而不是图存储层是有意义的。因此，我们认为在当前阶段向您提供一些用于处理大型图的图处理引擎技术是有用的，这对于扩展应用程序至关重要。
- en: In this respect, it is important to classify graph processing engines into two
    categories (that impact the tools/libraries/algorithms to be used), depending
    whether the graph can fit a *shared memory machine* or requires *distributed architectures*
    to be processed and analyzed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，根据图是否可以适应**共享内存机器**或需要**分布式架构**来处理和分析，将图处理引擎分为两类（这会影响要使用的工具/库/算法）是很重要的。
- en: Note that there is no absolute definition of large and small graphs, but it
    also depends on the chosen architecture. Nowadays, thanks to the vertical scaling
    of infrastructures, you can find servers with **random-access memory** (**RAM**)
    larger than 1 **terabyte** (**TB**) (usually called *fat nodes*), and with tens
    of thousands of **central processing units** (**CPUs**) for multithreading in
    most cloud-provider offerings, although these infrastructures might not be economically
    viable. Even without scaling out to such extreme architectures, graphs with millions
    of nodes and tens of millions of edges can nevertheless be easily handled in single
    servers with ~100 **gigabytes** (**GB**) of RAM and ~50 CPUs.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有关于大型和小型图的绝对定义，这还取决于所选的架构。如今，得益于基础设施的垂直扩展，你可以找到具有大于1 **TB**（通常称为*胖节点*）的**随机存取内存**（**RAM**）的服务器，以及大多数云服务提供商提供的具有数万个**中央处理单元**（**CPUs**）用于多线程的基础设施，尽管这些基础设施可能在经济上不可行。即使没有扩展到这种极端的架构，具有数百万个节点和数千万条边的图也可以在具有约100
    **GB**（**GB**）的RAM和约50个CPU的单个服务器上轻松处理。
- en: 'Although `networkx` is a very popular, user-friendly, and intuitive library,
    when scaling out to such reasonably large graphs it may not be the best available
    choice. `networkx`, being natively written in pure Python, which is an interpreted
    language, can be substantially outperformed by other graph engines fully or partly
    written in more performant programming languages (such as C++ and Julia) and that
    make use of multithreading, such as the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`networkx`是一个非常受欢迎、用户友好且直观的库，但当扩展到这样合理的大型图时，它可能不是最佳选择。`networkx`是纯Python编写的，Python是一种解释型语言，在性能上可能远不如完全或部分用性能更好的编程语言（如C++和Julia）编写的其他图引擎，并且使用了多线程，如下所示：
- en: '**SNAP** ([http://snap.stanford.edu/](http://snap.stanford.edu/)), which we
    have already seen in the previous section, is a graph engine developed at Stanford
    and is written in C++ with available bindings in Python.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SNAP** ([http://snap.stanford.edu/](http://snap.stanford.edu/))，我们在上一节中已经见过，是斯坦福大学开发的一个图引擎，是用
    C++ 编写的，并且提供了 Python 的绑定。'
- en: '**igraph** ([https://igraph.org/](https://igraph.org/)) is a C library and
    features bindings in Python, R, and Mathematica.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**igraph** ([https://igraph.org/](https://igraph.org/)) 是一个 C 库，并且提供了 Python、R
    和 Mathematica 的绑定。'
- en: '**graph-tool** ([https://graph-tool.skewed.de/](https://graph-tool.skewed.de/)),
    despite being a Python module, has core algorithms and data-structures written
    in C++ and uses OpenMP parallelization to scale on multi-core architectures.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**graph-tool** ([https://graph-tool.skewed.de/](https://graph-tool.skewed.de/))，尽管是一个
    Python 模块，但其核心算法和数据结构是用 C++ 编写的，并使用 OpenMP 并行化以在多核架构上扩展。'
- en: '**NetworKit** ([https://networkit.github.io/](https://networkit.github.io/))
    is also written in C++ with OpenMP boost for parallelization for its core functionalities,
    integrated in a Python module.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NetworKit** ([https://networkit.github.io/](https://networkit.github.io/))
    也是用 C++ 编写的，其核心功能集集成了 OpenMP 并行化，并集成在 Python 模块中。'
- en: '`networkx` functionalities in a more performant and robust library.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个性能更优且更健壮的库中实现 `networkx` 的功能。
- en: All the preceding libraries are valid alternatives to `networkx` when achieving
    better performance becomes an issue. Improvements can be very substantial, with
    speed-ups varying from 30 to 300 times faster, with the best performance generally
    achieved by LightGraphs.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的上述库在需要提高性能时都是 `networkx` 的有效替代品。改进可能非常显著，速度提升从 30 到 300 倍不等，最佳性能通常由 LightGraphs
    实现。
- en: In the forthcoming chapters, we will mostly focus on `networkx` in order to
    provide a consistent presentation and provide the user with basic concepts on
    network analysis. We want you to be aware that other options are available, as
    this becomes extremely relevant when pushing the edge from a performance standpoint.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将主要关注 `networkx`，以提供一致性的展示，并为用户提供网络分析的基本概念。我们希望您知道还有其他选项可用，因为从性能角度来看，这变得极其相关。
- en: Summary
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we refreshed concepts such as graphs, nodes, and edges. We
    reviewed graph *representation* methods and explored how to *visualize* graphs.
    We also defined *properties* that are used to characterize networks, or parts
    of them.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了诸如图、节点和边等概念。我们回顾了图的 *表示* 方法，并探讨了如何 *可视化* 图。我们还定义了用于表征网络或其部分 *属性*。
- en: We went through a well-known Python library to deal with graphs, `networkx`,
    and learned how to use it to apply theoretical concepts in practice.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个著名的 Python 图库 `networkx` 来处理图，并学习了如何将其应用于实践中的理论概念。
- en: We then ran examples and toy problems that are generally used to study the properties
    of networks, as well as benchmark performance and effectiveness of network algorithms.
    We also provided you with some useful links of repositories where network datasets
    can be found and downloaded, together with some tips on how to parse and process
    them.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后运行了通常用于研究网络特性的示例和玩具问题，以及网络算法的性能和有效性基准测试。我们还为您提供了可以找到和下载网络数据集的存储库的一些有用链接，以及一些解析和处理它们的技巧。
- en: In the next chapter, we will go beyond defining notions of ML on graphs. We
    will learn how more advanced and latent properties can be automatically found
    by specific ML algorithms.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将超越在图上定义机器学习（ML）的概念。我们将学习如何通过特定的 ML 算法自动找到更高级和潜在的特性。
