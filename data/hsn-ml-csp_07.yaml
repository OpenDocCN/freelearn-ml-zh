- en: Facial and Motion Detection – Imaging Filters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部检测和运动检测 – 图像过滤器
- en: You have seen and heard of it everywhere. Facial recognition, motion detection.
    We have motion sensors in our homes as part of our security systems. Everybody
    is doing facial recognition—there are security cameras on our streets, in our
    airports, and probably even in our homes. And if we think about everything that
    an autonomous vehicle must do, wow! There is a recent link (at the time of writing)
    on how facial recognition technology identified a suspect amongst a crowd of 50,000
    faces! [https://www.digitaltrends.com/cool-tech/facial-recognition-china-50000/](https://www.digitaltrends.com/cool-tech/facial-recognition-china-50000/)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您无处不在都见过和听说过它。面部识别，运动检测。我们家里的安全系统中就有运动传感器。每个人都正在进行面部识别——我们的街道、机场，甚至可能在我们家里都有安全摄像头。如果我们考虑自动驾驶汽车必须完成的所有事情，哇！在写作的时候，有一个关于面部识别技术如何在5万名面孔的群众中识别出嫌疑人的链接。[https://www.digitaltrends.com/cool-tech/facial-recognition-china-50000/](https://www.digitaltrends.com/cool-tech/facial-recognition-china-50000/)
- en: But what exactly does that mean? How does it do what it does? What happens behind
    the scenes? And how can I use it in my applications? In this chapter, we are going
    to show two separate examples, one for facial detection and the other for motion
    detection. We'll show you exactly what goes on and just how fast you can add these
    capabilities into your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但这究竟意味着什么？它是如何做到这一点的？幕后发生了什么？我如何在应用程序中使用它？在本章中，我们将展示两个独立的示例，一个用于面部检测，另一个用于运动检测。我们将向您展示具体发生了什么，以及您如何快速将这些功能添加到您的应用程序中。
- en: 'In this chapter we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Facial detection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面部检测
- en: Motion detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动检测
- en: Adding detection to your application
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将检测添加到您的应用程序
- en: Facial detection
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部检测
- en: Let's start out with facial detection. In our example, I'm going to use my friendly
    little French Bulldog, Frenchie, as our assistant. Tried to get my beautiful wife
    to do the honors but makeup, hair; well, I'm sure you know that story! Frenchie
    the Bulldog, however, had no complaints.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从面部检测开始。在我们的例子中，我将使用我那友好的小法国斗牛犬Frenchie作为我们的助手。我曾试图让我的美丽妻子来完成这个任务，但化妆、发型；嗯，我相信您知道那个故事！然而，Frenchie这只斗牛犬却没有怨言。
- en: Before I start, please re-read the chapter title. No matter how many times you
    read it, you'll probably miss the key point here, and it's so very important.
    Notice it says **facial detection** and not **facial recognition**. This is so
    very important that I needed to stop and re-stress it. We are not trying to identify
    Joe, Bob, or Sally. We are trying to identify that, out of everything we see via
    our camera, we can detect a face. We are not concerned with whose face it is,
    just the fact that it is a face! It is so important that we understand this before
    moving on! Otherwise, your expectations will be so incorrectly biased (another
    buzzword for your checklist) that you'll make yourself confused and upset, and
    we don't want that!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始之前，请重新阅读章节标题。无论您读多少次，您可能都会错过这里的关键点，它非常重要。注意它说的是**面部检测**而不是**面部识别**。这一点非常重要，以至于我需要停下来再次强调。我们不是试图识别乔、鲍勃或萨莉。我们试图识别的是，通过我们的摄像头看到的所有事物中，我们可以检测到一张脸。我们并不关心这是谁的脸，只是它是一张脸！这一点非常重要，在我们继续之前我们必须理解这一点！否则，您的期望可能会被错误地偏向（另一个清单上的时髦词）而让您自己感到困惑和沮丧，我们不希望这样！
- en: Facial detection, as I will stress again later, is the first part of facial
    recognition, a much more complicated beast. If you can't identify that there are
    one or more faces out of all the things on the screen, then you'll never be able
    to recognize whose face that is!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 面部检测，就像我稍后会再次强调的那样，是面部识别的第一部分，这是一个更加复杂的生物。如果您不能从屏幕上的所有事物中识别出一张或更多张脸，那么您将永远无法识别那是谁的脸！
- en: 'Let''s start things off by taking a quick look at our application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速看一下我们的应用程序：
- en: '![](img/76680c1c-486b-4f1a-b1c6-dff6bb74f804.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76680c1c-486b-4f1a-b1c6-dff6bb74f804.png)'
- en: 'As you can see, we have a very simple screen. In our case, the laptop camera
    is our video capture device. Frenchie is kindly posing in front of the camera
    for us, just standing there enjoying life. But, as soon as we enable facial tracking,
    watch what happens:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个非常简单的屏幕。在我们的案例中，笔记本电脑的摄像头是我们的视频捕获设备。Frenchie友好地站在摄像头前，享受着生活。但是，当我们启用面部追踪时，看看会发生什么：
- en: '![](img/40008629-0a3a-459a-bd61-60d66bd3a4d9.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40008629-0a3a-459a-bd61-60d66bd3a4d9.png)'
- en: The facial features of Frenchie are now being tracked. What you see surrounding
    Frenchie are the tracking containers (white boxes), which tell us we know that
    there is a face and where it is, and our angle detector (red line), which provides
    some insight into the horizontal aspect of our face .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Frenchie 的面部特征现在正在被追踪。你所看到围绕 Frenchie 的追踪容器（白色方框），它们告诉我们我们知道有一个面部以及它的位置，还有我们的角度检测器（红色线条），它为我们面部水平方向提供了一些洞察。
- en: 'As we move Frenchie around, the tracking container and angle detector will
    track him. That''s all well and good, but what happens if we enable facial tracking
    on a real human face? As you see here, the tracking containers and angles are
    tracking the facial figures of our guest poser, just like they did for Frenchie:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移动 Frenchie 时，追踪容器和角度检测器会追踪他。这很好，但是如果我们在一个真实的人脸上启用面部追踪会发生什么呢？正如你所看到的，追踪容器和角度正在追踪我们客座者的面部特征，就像它们追踪
    Frenchie 一样：
- en: '![](img/857c656a-62f6-4f80-a86b-5eead320ed31.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/857c656a-62f6-4f80-a86b-5eead320ed31.png)'
- en: 'As our poser moves his head from side to side, the camera tracks this and you
    can see the angle detectors adjusting to what it recognizes as the horizontal
    angle of the face. In this case, you will notice that the Color space is in black
    and white and not color. This is a histogram back projection and is an option
    that you can change:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的模特从一侧移动到另一侧时，相机会追踪这个动作，你可以看到角度检测器正在调整以适应它所识别的面部水平角度。在这种情况下，你会注意到色彩空间是黑白而非彩色。这是一个直方图反向投影，这是一个你可以更改的选项：
- en: '![](img/88668c56-7e07-4141-b90e-cde7763e75a9.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88668c56-7e07-4141-b90e-cde7763e75a9.png)'
- en: 'Even as we move farther away from the camera, where other objects come into
    view, the facial detector can keep track of our face among the noise, as shown
    in the following screenshot. This is exactly how the facial recognition systems
    you see in movies work, albeit more advanced; and, using the code and samples
    we''ll show you shortly, you too can be up and running with your own facial recognition
    application in minutes! We''ll provide the detection; you provide the recognition:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使当我们远离相机，其他物体进入视野时，面部检测器也能在噪声中追踪我们的面部，如下面的截图所示。这正是电影中你看到的面部识别系统的工作方式，尽管更高级；而且，使用我们很快就会展示的代码和示例，你也能在几分钟内启动自己的面部识别应用！我们将提供检测；你提供识别：
- en: '![](img/c941ebd9-8f3e-42d6-9a83-bdf0ae6cbd84.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c941ebd9-8f3e-42d6-9a83-bdf0ae6cbd84.png)'
- en: Now that we've seen how our application appears from the outside, let's look
    under the hood at what is going on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们的应用从外部看起来是什么样子，让我们来看看引擎盖下正在发生的事情。
- en: Let's start by asking ourselves exactly what the problem is that we are trying
    to solve here. As we mentioned in previous sections, we are trying to detect (notice
    again I did not say recognize) facial images. While this is easy for a human,
    a computer needs very detailed instruction sets to accomplish this feat.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先问问自己，我们在这里试图解决什么问题。正如我们在前面的章节中提到的，我们试图检测（再次提醒，我没有说是识别）面部图像。虽然这对人类来说很容易，但计算机需要非常详细的指令集来完成这个壮举。
- en: Luckily, there is a very famous algorithm called the Viola-Jones algorithm that
    will do the heavy lifting for us. Why did we pick this algorithm?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个非常著名的算法叫做 Viola-Jones 算法，它将为我们完成繁重的工作。我们为什么选择这个算法？
- en: It has very high detection rates and very low false positives.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它具有非常高的检测率和非常低的误报率。
- en: It is very good at real-time processing.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它非常擅长实时处理。
- en: It is very good at detecting faces from non-faces. Detecting faces is the first
    step in facial recognition!
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它非常擅长从非面部检测面部。检测面部是面部识别的第一步！
- en: This algorithm requires that the camera has a full frontal, upright view of
    the face. To be detected, the face will need to point straight towards the camera,
    not tilted and not looking up or down. Remember again; for the moment, we are
    just interested in facial detection!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法要求相机有一个完整的正面、垂直的面部视图。为了被检测到，面部需要直视相机，不能倾斜，也不能向上或向下看。再次提醒；目前，我们只对面部检测感兴趣！
- en: 'To delve into the technical side of things, our algorithm will require four
    stages to accomplish its job. They are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解技术方面，我们的算法需要四个阶段来完成其任务。它们是：
- en: Haar feature selection
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Haar 特征选择
- en: Creating an integral image
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个积分图像
- en: AdaBoost training
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AdaBoost 训练
- en: Cascading classifiers
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级联分类器
- en: Let's think about what facial detection actually accomplished. All faces, be
    it human, animal, or otherwise, share some similar properties. For example, the
    eye is darker than the upper cheeks, the nose bridge is brighter than the eyes,
    and your forehead may be lighter than the rest of your face. Our algorithm matches
    these intuitions up by using what is known as **Haar features**. We can come up
    with matchable facial features by looking at the location and size of the eyes,
    mouth, bridge of the nose, and so forth. However, we do have an obstacle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下面部检测实际上完成了什么。无论是人类、动物还是其他生物，所有面部都具备一些相似的特征。例如，眼睛比上脸颊要暗，鼻梁比眼睛要亮，而你的额头可能比脸部其他部分要亮。我们的算法通过使用所谓的**Haar特征**来匹配这些直觉。我们可以通过观察眼睛、嘴巴、鼻梁等部位的位置和大小来得出可匹配的面部特征。然而，我们确实面临一个障碍。
- en: In a 24x24 pixel window, there are a total of 162,336 possible features. Obviously,
    to try and evaluate them all would be prohibitively expensive in both time and
    computation, if it works at all. So, we are going to work with a technique known
    as **adaptive boosting**, or more commonly, **AdaBoost**. It's another one for
    your buzzword-compliant list. If you have delved into or researched machine learning,
    I'm sure you've heard about a technique called **boosting.** That's exactly what
    AdaBoost is. Our learning algorithm will use AdaBoost to select the best features
    and train classifiers to use them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个24x24像素的窗口中，总共有162,336个可能的特征。显然，如果试图评估它们所有，无论是时间还是计算成本都会非常高昂，而且如果真的能工作的话。因此，我们将使用一种称为**自适应提升**的技术，或者更常见的是，**AdaBoost**。这是你
    buzzword-compliant 列表中的另一个。如果你已经深入研究或研究过机器学习，我敢肯定你已经听说过一种称为**提升**的技术。这正是AdaBoost。我们的学习算法将使用AdaBoost来选择最佳特征，并训练分类器来使用它们。
- en: AdaBoost can be used with many types of learning algorithms and is considered
    the best out-of-the-box algorithm for many tasks where boosting is required. You
    usually won't notice how good and fast it is until you switch to a different algorithm
    and benchmark it. I have done this countless number of times, and I can tell you
    that the difference is very noticeable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AdaBoost可以与许多类型的机器学习算法一起使用，并且被认为是许多需要提升的任务中最好的现成算法。你通常不会注意到它有多好、有多快，直到你切换到另一个算法并对其进行基准测试。我已经做了无数次这样的测试，我可以告诉你，这种差异是非常明显的。
- en: Let's give a little more definition to boosting before we continue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们先对提升（boosting）的概念进行更详细的定义。
- en: '**Boosting** takes the output from other **weak-learning** algorithms and combines
    them with a weighted sum that is the final output of the boosted classifier. The
    adaptive part of AdaBoost comes from the fact that subsequent learners are tweaked
    in favor of those instances that have been incorrectly classified by previous
    classifiers. We must be careful with our data preparation though, as AdaBoost
    is sensitive to noisy data and outliers (remember how we stressed those in [Chapter
    1](7a1f2cca-1be5-426a-8e8a-6a4a3828cd76.xhtml), *Machine Learning Basics*). The
    algorithm tends to **overfit** the data more than other algorithms, which is why,
    in our earlier chapters, we stressed on data preparation for missing data and
    outliers. In the end, if weak learning algorithms are better than random guessing,
    AdaBoost can be a valuable addition to our process.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**提升**算法将其他**弱学习**算法的输出与一个加权求和结合起来，这个加权求和是提升分类器的最终输出。AdaBoost的自适应部分来自于后续的学习者被调整以有利于那些被先前分类器错误分类的实例。然而，我们必须小心我们的数据准备，因为AdaBoost对噪声数据和异常值（记得我们在[第一章](7a1f2cca-1be5-426a-8e8a-6a4a3828cd76.xhtml)，*机器学习基础*中强调的那些）很敏感。该算法比其他算法更容易对数据进行过度拟合，这就是为什么在我们早期的章节中，我们强调了缺失数据和异常值的数据准备。最终，如果弱学习算法比随机猜测更好，AdaBoost可以成为我们流程中的一个宝贵补充。'
- en: With that brief description behind us, let's look under the covers at what's
    happening. For this example, we will again use the **Accord framework** and we
    will work with the vision face tracking sample.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个简短的描述之后，让我们揭开面纱，看看背后发生了什么。在这个例子中，我们再次使用**Accord框架**，并且我们将与视觉面部跟踪样本一起工作。
- en: We start by creating a `FaceHaarCascade` object. This object holds a collection
    of Haar-like features' weak classification stages. There will be many stages provided,
    each containing a set of classifier trees which will be used in the decision-making
    process. We are now technically working with a decision tree. The beauty of the
    Accord framework is that `FaceHaarCascade` automatically creates all these stages
    and trees for us without exposing us to the details.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `FaceHaarCascade` 对象。此对象包含一组类似Haar特征的弱分类阶段。将提供许多阶段，每个阶段都包含一组用于决策过程的分类树。我们现在实际上是在处理一个决策树。Accord框架的美丽之处在于
    `FaceHaarCascade` 会自动为我们创建所有这些阶段和树，而不暴露给我们细节。
- en: 'Let''s see what a particular stage might look like:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看特定阶段可能的样子：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now don't let that scare you off. As you can see, we are building a decision
    tree underneath the hood by providing the nodes for each stage with the numeric
    values for each feature.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要被吓到。正如你所见，我们通过为每个阶段的节点提供每个特征的数值，在底层构建了一个决策树。
- en: 'Once created, we can use our cascade object to create our `HaarObjectDetector`,
    which is what we will use for our detection. It takes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，我们可以使用我们的 cascade 对象来创建我们的 `HaarObjectDetector`，这是我们用于检测的工具。它需要：
- en: Our facial cascade objects
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 facial cascade 对象
- en: The minimum window size to use when searching for objects
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索对象时使用的最小窗口大小
- en: Our search mode, given that we are searching for only a single object
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的搜索模式，鉴于我们正在搜索单个对象
- en: The re-scaling factor to use when re-scaling our search window during the search
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索过程中重新调整搜索窗口时使用的缩放因子
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we are ready to tackle the topic of our video collection source. In our
    examples, we will simply use the local camera to capture all images. However,
    the Accord.NET framework makes it easy to use other sources for image capture,
    such as a `.avi` files, animated `.jpg` files, and so forth.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好处理视频收藏源的话题。在我们的例子中，我们将简单地使用本地摄像头来捕捉所有图像。然而，Accord.NET 框架使得使用其他图像捕获源变得容易，例如
    `.avi` 文件、动画的 `.jpg` 文件等等。
- en: 'We connect to the camera, select the resolution, and are then ready to go:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们连接到摄像头，选择分辨率，然后就可以开始了：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the application now running and our video source selected, our application
    will look like this. Once again, enter Frenchie the Bulldog! Please excuse the
    mess; Frenchie is not the tidiest of assistants and he even left his empty cup
    of coffee on my table!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，并且我们已选择了视频源，我们的应用程序将看起来像这样。再次，请输入法尼奇牛头犬！请原谅这儿的混乱；法尼奇不是一个整洁的助手，他甚至把他的空咖啡杯留在了我的桌子上！
- en: '![](img/d88366e3-4ffc-46f6-8270-91654ffd5c7d.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d88366e3-4ffc-46f6-8270-91654ffd5c7d.png)'
- en: For this demonstration, you will notice that Frenchie is facing the camera,
    and in the background, we have two 55" monitors as well as many other items my
    wife likes to refer to as junk. I myself prefer to think of it as stochastic noise!
    This is done to show how the face detection algorithm can distinguish Frenchie's
    face amongst everything else. If our detector cannot handle this, it is going
    to get lost in the noise and be of little use to us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，你会注意到法尼奇正对着摄像头，在背景中，我们还有两个55英寸的显示器以及许多我妻子喜欢称之为垃圾的其他物品。我自己更喜欢把它看作是随机噪声！这是为了展示人脸检测算法如何在其他所有东西中区分法尼奇的脸。如果我们的检测器无法处理这种情况，它就会在噪声中迷失方向，对我们几乎没有用处。
- en: 'With our video source now coming in, we need to be notified when a new frame
    is received so that we can process it, apply our markers, and so on. We do this
    by attaching to the `NewFrameReceived` event handler of the video source player.
    As a C# developer I am assuming that you are familiar with events such as this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了视频源输入，我们需要在接收到新帧时得到通知，以便我们可以处理它，应用我们的标记等等。我们通过附加到视频源播放器的 `NewFrameReceived`
    事件处理器来完成此操作。作为一个C#开发者，我假设你熟悉此类事件：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have a video source and video coming in, let's look at what happens
    each time we are notified that a new video frame is available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了视频源和视频输入，让我们看看每次我们收到通知说有新的视频帧可用时会发生什么。
- en: 'The first thing that we need to do is `downsample` the image to make it easier
    to work with:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是 `downsample` 图像，使其更容易处理：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the image in a more manageable size, we will process the frame. If we
    have not found a facial region, we will stay in tracking mode waiting for a frame
    that has a detectable face. Once we have found a facial region, we will reset
    our tracker, locate the face, reduce its size in order to flush away any background
    noise, initialize the tracker, and apply the marker window to the image. All of
    this is accomplished with the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在将图像大小调整为更易于管理后，我们将处理帧。如果我们没有找到面部区域，我们将保持在跟踪模式中等待一个具有可检测面部的帧。一旦我们找到了面部区域，我们将重置我们的跟踪器，定位面部，减小其尺寸以清除任何背景噪声，初始化跟踪器，并将标记窗口应用于图像。所有这些操作都通过以下代码完成：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once a face is detected, our image frame looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到面部，我们的图像帧看起来像这样：
- en: '![](img/e0b15633-e9ba-4100-8815-3634799816a6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e0b15633-e9ba-4100-8815-3634799816a6.png)'
- en: 'If Frenchie tilts his head to the side, our image now looks like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果法式倾斜他的头，我们的图像现在看起来像这样：
- en: '![](img/f1e9e136-2b6e-4d68-bb99-3722d5328748.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1e9e136-2b6e-4d68-bb99-3722d5328748.png)'
- en: Motion detection
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运动检测
- en: You can already see that we are not only doing facial detection, but motion
    detection as well. So let's turn our focus to be a bit wider scale and detect
    any motion, not just faces. Again, we'll use Accord.NET for this and use the motion
    detection sample. As with facial detection, you will see just how simple it is
    to add this capability to your applications and instantly become a hero at work!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以看到，我们不仅在进行面部检测，还在进行运动检测。所以让我们将注意力扩大到更广泛的范围，检测任何运动，而不仅仅是面部。同样，我们将使用 Accord.NET
    来此，并使用运动检测示例。就像面部检测一样，你将看到如何简单地将此功能添加到您的应用程序中，并立即成为工作中的英雄！
- en: 'With motion detection, we will highlight anything that moves on the screen
    in red. The amount of movement is indicated by the thickness of red in any one
    area. So, using the following image, you can see that the fingers are moving but
    that everything else is motionless:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运动检测，我们将用红色突出显示屏幕上移动的任何东西。运动的量由任何区域中红色的厚度表示。所以，使用以下图像，你可以看到手指在移动，但其他一切都没有运动：
- en: '![](img/3e8ac5b7-d62c-4b78-b197-dc58104d1f08.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e8ac5b7-d62c-4b78-b197-dc58104d1f08.png)'
- en: 'As the movement of the hand increases, you can see increased movement in the
    entire hand:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着手部运动的增加，你可以看到整个手部的运动增加：
- en: '![](img/fa75855d-ffc6-4101-90df-0c00238cdaf5.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa75855d-ffc6-4101-90df-0c00238cdaf5.png)'
- en: 'Once the entire hand starts to move, you can see not only more red but also
    the total amount of red increasing relative to the movement:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦整个手开始移动，你不仅能看到更多的红色，还能看到相对于移动的红色总量增加：
- en: '![](img/6b01b4ad-3a56-45f1-a8fa-0787d465a1ed.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b01b4ad-3a56-45f1-a8fa-0787d465a1ed.png)'
- en: 'If we do not wish to process the entire screen area for motion, we can define
    Motion Regions; motion detection will occur only in those regions. In the following
    image, you can see that I''ve defined a Motion Regions. You will notice in upcoming
    images that this is the only area that motion will be processed from:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望处理整个屏幕区域进行运动检测，我们可以定义运动区域；运动检测将仅在这些区域内发生。在以下图像中，你可以看到我已经定义了一个运动区域。你将在接下来的图像中注意到，这是唯一一个将处理运动的区域：
- en: '![](img/35721f38-ec53-4718-9b7b-aef3520b9aa9.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35721f38-ec53-4718-9b7b-aef3520b9aa9.png)'
- en: 'Now, if we create some motion for the camera (fingers moving), we will see
    that only motion from our defined region is being processed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们为相机创建一些运动（手指移动），我们将看到只有我们定义区域内的运动被处理：
- en: '![](img/b428b005-8bf3-4f60-94e7-eb929444dd42.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b428b005-8bf3-4f60-94e7-eb929444dd42.png)'
- en: 'You can also see that, with a Motion Regions defined and Peter the meditating
    Gnome in front of the region, we are still able to detect motion behind him while
    filtering out non-interesting items; but his face is not a part of the recognition.
    You could, of course, combine both processes to have the best of both worlds:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到，在定义了运动区域并且彼得这个冥想的哥布林在区域前面时，我们仍然能够检测到他后面的运动，同时过滤掉不感兴趣的项目；但他的面部不是识别的一部分。当然，你可以结合这两个过程，以获得两者的最佳效果：
- en: '![](img/ce20e943-3941-4e92-9a21-906edc8af75b.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce20e943-3941-4e92-9a21-906edc8af75b.png)'
- en: 'Another option that we can use is grid motion highlighting. This makes the
    motion detected region highlighted in red squares based on a defined grid. Basically,
    the motion area is now a red box, as you can see here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用的另一个选项是网格运动高亮。这将在定义的网格中用红色方块突出显示检测到的运动区域。基本上，运动区域现在是一个红色框，正如你所看到的那样：
- en: '![](img/5a5657c4-837e-423e-ad74-62f4877516fa.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a5657c4-837e-423e-ad74-62f4877516fa.png)'
- en: Adding detection to your application
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将检测添加到您的应用程序中
- en: Here's a simple example of all you need to do to add video recognition to your
    application. As you can see, it couldn't be any easier!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单示例，展示了你需要在应用程序中添加视频识别所需的所有操作。正如你所见，这简直不能再简单了！
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we receive a new video frame, that''s when all the magic happens. Here''s
    all the code it takes to make processing a new video frame a success:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接收到一个新的视频帧时，所有的魔法就开始了。以下是使处理新视频帧成功所需的全部代码：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The key here is detecting the amount of motion that is happening in the frame,
    which is done with the following code. For this example, we are using a motion
    alarm level of `2`, but you can use whatever you like. Once this threshold has
    been passed, you can implement your desired logic, such as sending an alert email,
    a text, and starting video capture, and so forth:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于检测帧中发生的运动量，这可以通过以下代码完成。对于这个例子，我们使用的是运动警报级别`2`，但你可以使用你喜欢的任何值。一旦这个阈值被超过，你可以实现你想要的逻辑，例如发送警报电子邮件、短信，以及开始视频捕获等等：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about facial and motion detection. We discovered
    various algorithms you can employ in your current environment to easily integrate
    this functionality into your applications. We also showed some easy and simple
    code you can use to quickly add such capabilities. In the next chapter, we are
    going to step into the world of artificial neural networks and tackle some very
    exciting problems!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了面部和动作检测。我们发现了你可以在当前环境中使用，以便轻松将此功能集成到你的应用程序中的各种算法。我们还展示了一些简单且易于使用的代码，你可以用它们快速添加这些功能。在下一章中，我们将步入人工神经网络的世界，解决一些非常激动人心的问题！
