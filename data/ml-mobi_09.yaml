- en: Neural Networks on Mobile
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动设备上的神经网络
- en: In [Chapter 2](1b52495b-c6cb-4197-8fcd-a1e764c1f1c2.xhtml), *Supervised and
    Unsupervised Learning Algorithms,* when we introduced you to TensorFlow, its components,
    and how it works, we talked briefly about **convolutional neural networks** (**CNNs**) and
    how they work. In this chapter, we will delve into the basic concepts of neural
    networks. We will explore the similarities and variations between machine learning
    and neural networks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](1b52495b-c6cb-4197-8fcd-a1e764c1f1c2.xhtml)“监督学习和无监督学习算法”中，当我们向您介绍
    TensorFlow、其组件以及其工作原理时，我们简要地谈到了**卷积神经网络**（**CNNs**）以及它们是如何工作的。在本章中，我们将深入探讨神经网络的基本概念。我们将探讨机器学习和神经网络之间的相似性和差异。
- en: We will also go through some of the challenges of executing deep learning algorithms
    on mobile devices. We will briefly go through the various deep learning and neural
    network SDKs available for mobile applications that can be run on mobile devices
    directly. Toward the end of this chapter, we will create an interesting assignment
    that will utilize both TensorFlow and Core ML.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论在移动设备上执行深度学习算法的一些挑战。我们将简要介绍适用于移动设备的各种深度学习和神经网络 SDK。在本章的末尾，我们将创建一个有趣的作业，该作业将利用
    TensorFlow 和 Core ML。
- en: 'In this chapter, we will be cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Creating a TensorFlow image recognition model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 TensorFlow 图像识别模型
- en: Converting the TensorFlow model into a Core ML model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 TensorFlow 模型转换为 Core ML 模型
- en: Creating an iOS mobile application that utilizes the Core ML model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个利用 Core ML 模型的 iOS 移动应用程序
- en: Introduction to Keras
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Keras 简介
- en: Creating a handwritten digit recognition solution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个手写数字识别解决方案
- en: In this chapter, we are going to implement all of the major topics we have gone
    through in this book. Before proceeding, make sure you have gone through all the
    previous chapters in this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现本书中我们已经讨论过的所有主要主题。在继续之前，请确保你已经阅读了本书的所有前几章。
- en: Introduction to neural networks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络简介
- en: A neural network is a system of hardware and/or software that is modeled on
    the operation of neurons in the human brain. The design behind neural networks
    is inspired by the human brain and its functionality. Let's understand the design
    of the human brain. The neuron is the basic working unit of the brain. It's a
    specialized cell that can transmit information to other nerve cells. The brain
    is made up of approximately 100,000,000,000 neurons. A neuron's main function
    is to process and transmit information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络是一个基于人类大脑神经元操作的硬件和/或软件系统。神经网络的设计灵感来源于人脑及其功能。让我们了解人脑的设计。神经元是大脑的基本工作单元。它是一种专门细胞，可以传递信息到其他神经细胞。大脑由大约
    100,000,000,000 个神经元组成。神经元的主要功能是处理和传输信息。
- en: Communication steps of  a neuron
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经元的通信步骤
- en: 'Neuron communication follows a four-step path:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 神经元通信遵循四个步骤：
- en: A neuron receives information from the external environment or from other neurons.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经元从外部环境或其他神经元接收信息。
- en: The neuron integrates, or processes, the information from all of its input and
    determines whether to send an output signal. This integration takes place both
    in time (the duration of the input and the time between input) and space (across
    the surface of the neuron).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经元整合或处理来自所有输入的信息，并确定是否发送输出信号。这种整合在时间（输入的持续时间和输入之间的时间）和空间（神经元表面）上都会发生。
- en: The neuron propagates the signal along its length at a high speed.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经元以高速在其长度上传播信号。
- en: The neuron converts this electrical signal to a chemical one and transmits it
    to another neuron or to an effect such as a muscle or gland.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神经元将这个电信号转换为化学信号，并将其传输到另一个神经元或到肌肉或腺体等效应器。
- en: To get a better understanding of how neurons—the basic building blocks of the
    human brain—work, check out [http://www.biologyreference.com/Mo-Nu/Neuron.html#ixzz5ZD78t97u](http://www.biologyreference.com/Mo-Nu/Neuron.html#ixzz5ZD78t97u).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解神经元——人类大脑的基本构建块——是如何工作的，请查看[http://www.biologyreference.com/Mo-Nu/Neuron.html#ixzz5ZD78t97u](http://www.biologyreference.com/Mo-Nu/Neuron.html#ixzz5ZD78t97u)。
- en: Now, coming to the neurons' artificial neural networks, the function of these
    neurons is to take in some input and fire an output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，谈到人工神经网络中的神经元，这些神经元的职能是接收一些输入并产生输出。
- en: The activation function
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活函数
- en: 'To express this categorically, the neuron is a placeholder function that takes
    in inputs, processes them by applying the function on the input, and produces
    the output. Any simple function can be put in the defined placeholder:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确分类，神经元是一个占位符函数，它接收输入，通过在输入上应用函数来处理这些输入，并产生输出。任何简单的函数都可以放入定义的占位符中：
- en: '![](img/78af82c6-15f8-4bd3-b35b-b92752f37f05.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78af82c6-15f8-4bd3-b35b-b92752f37f05.png)'
- en: 'The function that''s used in a neuron is generally called an activation function. In
    the human body, there are three types of neurons: sensory neurons, motor neurons,
    and interneurons. In the artificial world, the activation function would probably
    create the different capability and functionality of the neuron.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在神经元中使用的函数通常被称为激活函数。在人体中，有三种类型的神经元：感觉神经元、运动神经元和中间神经元。在人工世界中，激活函数可能会创建神经元的不同能力和功能。
- en: 'Here are a few commonly used activation functions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常用的激活函数：
- en: step
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步进
- en: sigmoid
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sigmoid
- en: tanh
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tanh
- en: ReLU-Rectified
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReLU-Rectified
- en: Linear Unit (used mostly in deep learning)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性单元（主要用于深度学习）
- en: It is outside the scope of this book to delve into the details of each function.
    However, it will be good for you to understand these functions and their intricacies
    if you want to study neural networks further.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 详细介绍每个函数的细节超出了本书的范围。然而，如果您想进一步研究神经网络，了解这些函数及其复杂性将是有益的。
- en: Arrangement of neurons
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经元的排列
- en: Let's look at the arrangement of neurons in the human body. A typical neuron
    has several dendrites, normally arranged in an extremely branched fashion, in
    order to establish contact with many other neurons. Neurons in the human body
    are also arranged in layers. The number of these layers varies across different
    parts of the body and brain, but normally is ranges from three to six layers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看人体中神经元的排列。一个典型的神经元有几个树突，通常以极其分支的方式排列，以便与其他许多神经元建立联系。人体中的神经元也按层排列。这些层的数量因身体和大脑的不同部位而异，但通常在三层到六层之间。
- en: 'In the artificial world, these neurons are also arranged as layers. The following
    diagram will help you understand the organization of neurons:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工世界中，这些神经元也按层排列。以下图表将帮助您了解神经元的组织结构：
- en: '![](img/9de5a4d1-7ae1-4dca-9f82-aed22bd28c18.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9de5a4d1-7ae1-4dca-9f82-aed22bd28c18.png)'
- en: The leftmost layer of the network is called the **input layer**, and the rightmost
    layer is called the **output layer**. The middle layer of neurons is called the **hidden
    layer** because its values are not observed in the training set.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 网络最左侧的层被称为**输入层**，最右侧的层被称为**输出层**。神经元的中层被称为**隐藏层**，因为其值在训练集中未被观察到。
- en: In this sample neural network, there are three inputs, three hidden units, and
    one output unit. Any neural network will have at least one input and one output
    layer. The number of hidden layers can vary.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例神经网络中，有三个输入、三个隐藏单元和一个输出单元。任何神经网络都将至少有一个输入层和一个输出层。隐藏层的数量可以变化。
- en: The activation function used in each hidden layer can be different for the same
    network. This means that the activation function for hidden layer 1 and the b
    activation function for hidden layer 2 of the same network.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个隐藏层中使用的激活函数可以相同网络中的不同。这意味着同一网络中隐藏层1的激活函数和隐藏层2的b激活函数可以不同。
- en: Types of neural networks
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神经网络类型
- en: 'Neural networks vary based on the number of hidden layers and the activation
    functions used in each layer. Here are some of the common types of neural networks:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络根据隐藏层的数量和每层使用的激活函数而有所不同。以下是一些常见的神经网络类型：
- en: '**Deep neural networks**: Networks with more than one hidden layer.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度神经网络**：具有多个隐藏层的网络。'
- en: '**CNN**: Commonly used in computer-vision-related learning problems. The CNN
    hidden layer uses convolution functions as the activation function.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CNN**：常用于与计算机视觉相关的学习问题。CNN隐藏层使用卷积函数作为激活函数。'
- en: '**Recurrent neural networks**: Commonly used in problems related to natural
    language processing.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环神经网络**：常用于与自然语言处理相关的问题。'
- en: 'Current projects/research in the field of improving neural networks in mobile
    devices include the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当前在移动设备神经网络改进领域的研究/项目包括以下内容：
- en: MobileNet
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobileNet
- en: MobileNet V2
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MobileNet V2
- en: MNasNet—implementing reinforcement learning in mobile devices
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MNasNet—在移动设备上实现强化学习
- en: Image recognition solution
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像识别解决方案
- en: Imagine you go to a restaurant with your friends. Assume you are a fitness freak
    and though you have come to the party to enjoy the buffet, as a fitness freak,
    you are calorie conscious and don't want to go overboard.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你和朋友们去了一家餐厅。假设你是一个健身狂热者，尽管你来到派对是为了享受自助餐，但作为一个健身狂热者，你很注意卡路里，不想过量。
- en: 'Now, imagine you have a mobile application that comes to your rescue: it takes
    a picture of the dish, identifies its ingredients, and calculates the caloric
    value of the food! You could take a picture of every dish and calculate its caloric
    value and can then decide whether to put it on your plate. Further, this app keeps
    on learning the different dishes that you take pictures of and continues to learn
    and master itself in this trade so that it can take very good care of your health.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你有一个移动应用程序可以救你于水火之中：它拍摄食物的照片，识别其成分，并计算食物的卡路里值！你可以拍摄每一道菜并计算其卡路里值，然后决定是否将其放在你的盘子里。此外，这个应用程序会不断学习你拍摄的不同菜肴，并在这个领域继续学习和精通，以便它能很好地照顾你的健康。
- en: 'I can see the sparkle in your eyes. Yes, this is the mobile application we
    want to try in this chapter. We also want to utilize both TensorFlow and Core
    ML to accomplish this activity. We will be performing the following steps to create
    the application that we just discussed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我能看到你眼中的光芒。是的，这是我们本章想要尝试的移动应用程序。我们还想利用TensorFlow和Core ML来完成这项活动。我们将执行以下步骤来创建我们刚才讨论的应用程序：
- en: Create the TensorFlow image recognition model
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建TensorFlow图像识别模型
- en: Convert it into a `.ml` model file
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其转换为`.ml`模型文件
- en: Create an iOS/SWIFT app to use that model
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个iOS/SWIFT应用程序来使用该模型
- en: We will go through each of these steps in detail in the upcoming sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细讲解这些步骤。
- en: Creating a TensorFlow image recognition model
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TensorFlow图像识别模型
- en: TensorFlow is an open source software library for data flow programming across
    a range of tasks. It is a symbolic math library and is also used for machine learning
    applications, such as neural networks. It is used for both research and production
    at Google, often replacing its closed source predecessor, DistBelief. TensorFlow
    was developed by the Google Brain team for internal Google use. It was released
    under the Apache 2.0 open source license on November 9, 2015.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow是一个开源软件库，用于在一系列任务中进行数据流编程。它是一个符号数学库，也用于机器学习应用，如神经网络。它被用于谷歌的研究和生产，经常取代其封闭源代码的前身DistBelief。TensorFlow是由谷歌大脑团队为谷歌内部使用而开发的。它于2015年11月9日以Apache
    2.0开源许可证发布。
- en: 'TensorFlow is cross-platform. It runs on nearly everything: GPUs and CPUs–including
    mobile and embedded platforms–and even **tensor processing units** (**TPUs**),
    which are specialized hardware for performing tensor math.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow是跨平台的。它几乎在所有设备上运行：GPU和CPU，包括移动和嵌入式平台，甚至**张量处理单元**（**TPUs**），这是专门用于执行张量数学的硬件。
- en: What does TensorFlow do?
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TensorFlow做什么？
- en: 'To keep it simple, let''s assume you want two numbers. Now, if you want to
    write a program in a regular programming language, such as Python, you would use
    the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，让我们假设你想要两个数字。现在，如果你想在常规编程语言中编写程序，比如Python，你会使用以下代码：
- en: '*a = 1*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*a = 1*'
- en: '*b = 2*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*b = 2*'
- en: '*print(a+b)*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*print(a+b)*'
- en: 'If you run the program, you will see the output as *3*, and then you''ll see
    the same implementation on `tensorflow`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行程序，你将看到输出为*3*，然后你将在`tensorflow`上看到相同的实现：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let me explain the preceding code. First, we are creating a constant with node
    name `x`, adding `5` to it, and storing it in another variable/node `y`. If you
    can see the output of the console of y at this point, you will find the definition
    of the node, but not the value of 40.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下前面的代码。首先，我们创建了一个名为`x`的常量，将其加5，并将其存储在另一个变量/节点`y`中。如果你现在能看到`y`的输出控制台，你会找到节点的定义，但不是40的值。
- en: Here, you are defining the nodes of the graph and its corresponding operations.
    You can make use of the graph once you initialize the variables and create and
    get a session/instance of the graph.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在定义图的节点及其相应的操作。一旦初始化变量并创建和获取图的会话/实例，你就可以使用图。
- en: 'The following diagram will help you understand this concept:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将帮助你理解这个概念：
- en: '![](img/30384711-7433-40c5-823d-61651eae7f2e.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30384711-7433-40c5-823d-61651eae7f2e.png)'
- en: In TensorFlow, all of the constants, placeholders, and variables we will use
    to create the definition and the linkage between nodes will create one graph,
    which is just like your class concept in object-oriented programming. Think of
    the graph as a class and the nodes as data members, `tf.globalvariableinitilizer()`
    as calling the static method to initialize the constants and variable, and `session.run()`
    as calling the constructor of a class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TensorFlow 中，我们将使用所有常量、占位符和变量来创建节点定义和链接，这将创建一个图，这与面向对象编程中的类概念类似。将图视为一个类，节点视为数据成员，`tf.globalvariableinitilizer()`
    视为调用静态方法来初始化常量和变量，而 `session.run()` 视为调用类的构造函数。
- en: Retraining the model
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新训练模型
- en: To create an image classifier, we need to go through many things and do a lot
    of coding. To keep it simple, we will be showing you how to create it using the
    Google Code Lab provided code. The following content was taken from Google's Code
    Lab tutorial.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个图像分类器，我们需要经历很多事情，编写很多代码。为了保持简单，我们将向您展示如何使用 Google Code Lab 提供的代码来创建它。以下内容摘自
    Google 的 Code Lab 教程。
- en: This was made using CNNs. Explaining all of this is outside the scope of this
    book. We briefly explored CNN in the introduction of this chapter. However that
    is very less, compared to what is an ocean. For more information, interested readers
    can check out [https://colah.github.io/posts/2014-07-Conv-Nets-Modular/](https://colah.github.io/posts/2014-07-Conv-Nets-Modular/).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过卷积神经网络（CNNs）实现的。解释所有这些内容超出了本书的范围。我们在本章的引言中简要探讨了 CNN。然而，与海洋相比，这非常少。更多信息，感兴趣的读者可以查看
    [https://colah.github.io/posts/2014-07-Conv-Nets-Modular/](https://colah.github.io/posts/2014-07-Conv-Nets-Modular/)。
- en: 'Let''s see how easily we can create an image classifier in `tensorflow`. To
    get started, we need to install anaconda and then run the following commands:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们有多容易在 `tensorflow` 中创建一个图像分类器。要开始，我们需要安装 anaconda，然后运行以下命令：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you run the preceding command, you will get the following prompt:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行前面的命令，你会得到以下提示：
- en: '![](img/d3c99d03-b167-4c91-8900-b847e37cbf0c.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3c99d03-b167-4c91-8900-b847e37cbf0c.png)'
- en: 'Type `y` to proceed. Once the command has successfully executed, you will see
    the following screen:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `y` 以继续。一旦命令成功执行，你会看到以下屏幕：
- en: '![](img/8cd762ea-10d1-40bb-82c2-41f442366a7c.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cd762ea-10d1-40bb-82c2-41f442366a7c.png)'
- en: 'Type `activate` project. Once the project has been activated, you will see
    the prompt, like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `activate` 项目。一旦项目被激活，你会看到这样的提示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, type the following commands:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the following command to verify the installed packages:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令来验证已安装的包：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It has to produce the following result. If you don''t see some of these packages
    in your machine, reinstall them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须产生以下结果。如果你在你的机器上看不到这些包中的某些，请重新安装它们：
- en: '![](img/7e896abf-5d1e-4f8b-b96e-020738b91779.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e896abf-5d1e-4f8b-b96e-020738b91779.png)'
- en: Now, we have successfully installed `tensorflow` and its dependencies. Let's
    get the code from Google Code Labs that will do the classification. For this,
    make sure you have installed Git on your machine. There are several ways to install
    it, but the simplest way is through `npm`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功安装了 `tensorflow` 及其依赖项。让我们从 Google Code Labs 获取进行分类的代码。为此，请确保你的机器上已安装
    Git。有多种安装方法，但最简单的方法是通过 `npm`。
- en: 'To check that Git is properly installed, type `git` in the opened command prompt.
    You will see all the options available for that command. If it is prompting as
    `invalid command`, please try to install it correctly. Now, let''s execute the
    command to clone the repository:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Git 是否已正确安装，在打开的命令提示符中输入 `git`。你会看到该命令的所有可用选项。如果它提示为 `invalid command`，请尝试正确安装它。现在，让我们执行克隆存储库的命令：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you are done, go to `tensorflow-for-poets-2` using the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用以下命令进入 `tensorflow-for-poets-2`：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following folder contains all of the that are scripts required to train
    a model for image recognition. If you check the `tf_file` folder, it will be empty.
    Here, we will be using this folder to keep the training images and train the model
    using the scripts in the scripts folder.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件夹包含所有必需的脚本，用于训练图像识别模型。如果你检查 `tf_file` 文件夹，它将是空的。在这里，我们将使用这个文件夹来保存训练图像，并使用脚本文件夹中的脚本训练模型。
- en: To input the images, you need to first download the images. For our sample,
    we are using food images with four class labels. You can download it from our
    Git repository, `project/food_photos`, and then paste that folder into `tf_files`.
    If you are unable to execute this command, open the folder in Internet Explorer,
    and then download the in `tensorflow-for-poets-2/tf_files` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要输入图像，您首先需要下载图像。在我们的示例中，我们使用带有四个类别标签的食品图像。您可以从我们的 Git 仓库下载它，`project/food_photos`，然后将该文件夹粘贴到`tf_files`。如果您无法执行此命令，请使用
    Internet Explorer 打开文件夹，然后从`tensorflow-for-poets-2/tf_files`文件中下载。
- en: 'Extract the files into flat files, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件提取为平面文件，如下所示：
- en: '![](img/6af75a10-bc53-4b36-9597-133b76e45a2f.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6af75a10-bc53-4b36-9597-133b76e45a2f.png)'
- en: 'Now, we are going to retrain the model using the following script. Execute
    the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下脚本重新训练模型。执行以下命令：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The previous Python script is used to retrain a model that has many arguments,
    but we will use and discuss only a few important arguments, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 Python 脚本用于重新训练一个具有许多参数的模型，但我们将只使用和讨论几个重要的参数，如下所示：
- en: '`bottleneck_dir`: This will save these files to the bottlenecks/ directory.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottleneck_dir`：这些文件将被保存到bottlenecks/目录下。'
- en: '`how_many_training_steps`: This will a number below 4,000\. A higher number
    will give your model greater accuracy, but takes too much time to build, and the
    model file will be too big.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`how_many_training_steps`：这将是一个低于 4,000 的数字。更高的数字将使您的模型具有更高的精度，但需要太长时间来构建，并且模型文件会变得太大。'
- en: '`model_dir`:This tells us where to save the model.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model_dir`：这告诉我们模型应该保存的位置。'
- en: '`summaries_dir`: Contains the training summaries.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`summaries_dir`：包含训练摘要。'
- en: '`output_graph`:Where to save the output graph. This is the resultant model
    that we will use in mobiles.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output_graph`：输出图的保存位置。这是我们将在移动设备上使用的模型。'
- en: '`output_labels`:This is the file that holds the class labels. Usually, the
    class label for an image is the folder name.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output_labels`：这是包含类别标签的文件。通常，图像的类别标签是文件夹名称。'
- en: '`architecture`:This tells us which architecture to use. Here, we are using
    the mobilenet model with a 0.50 relative size of the model and a 244 image size.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`architecture`：这告诉我们应该使用哪种架构。在这里，我们使用的是具有 0.50 相对模型大小和 244 图像大小的 mobilenet
    模型。'
- en: '`image_dir`:Inputs the images directory, in this case, `food_photos`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_dir`：输入图像目录，在这种情况下，`food_photos`。'
- en: 'Executing the previous command will give you the following as output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令将给出以下输出：
- en: '![](img/8238586a-3f12-49b0-8fc9-2eac78dba889.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8238586a-3f12-49b0-8fc9-2eac78dba889.png)'
- en: About bottlenecks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于瓶颈
- en: Here, we will try to understand how the retraining process works. The ImageNet
    models we are using are made up of many layers stacked on top of each other. These
    layers are pre-trained and already have sufficient information that will help
    in image classification. All we are trying to do is train the very last layer, `final_training_ops` , when
    all the previous layers retrain their already trained state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将尝试理解重新训练过程是如何工作的。我们使用的 ImageNet 模型由许多堆叠在一起的层组成。这些层已经过预训练，并且已经拥有足够的信息，有助于图像分类。我们试图做的只是训练最后一层，`final_training_ops`，当所有之前的层重新训练它们已经训练的状态时。
- en: 'The following screenshot is taken from TensorBoard. You can open TensorBoard
    in your browser to get a better look at it. You will find it in the Graphs tab:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图来自 TensorBoard。您可以在浏览器中打开 TensorBoard 来更好地查看它。您可以在“Graphs”标签下找到它：
- en: '![](img/61b41369-49ff-4f91-9bd5-e310aaf4f503.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61b41369-49ff-4f91-9bd5-e310aaf4f503.png)'
- en: In the preceding diagram, the softmax node on the left-hand side is the output
    layer of the original model. All the nodes to the right of softmax were added
    by the retraining script.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，左侧的 softmax 节点是原始模型的输出层。softmax 右侧的所有节点都是由重新训练脚本添加的。
- en: Note that this will only work after the retrain script finishes generating the
    **bottleneck** files.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只有在重新训练脚本完成生成**瓶颈**文件后才会生效。
- en: Bottleneck is the term used to refer to the layer just before the final output
    layer that does the classification. Bottleneck does not imply its conventional
    meaning of something that slows down the whole process. We use the term bottleneck
    because, near the output, the representation is much more compact than in the
    main body of the network.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 瓶颈是指位于最终输出层之前，执行分类的层。瓶颈并不暗示其传统意义上的减缓整个过程的含义。我们使用瓶颈这个术语，因为接近输出时，表示比网络主体部分更加紧凑。
- en: 'Every image is reused multiple times during training. Calculating the layers
    behind the bottleneck for each image takes a significant amount of time. Since
    these lower layers of the network are not being modified, their output can be
    cached and reused. Now, you have the TensorFlow retrained model in your hand.
    Let''s test the model that we just trained using the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图像在训练过程中被多次使用。计算每个图像瓶颈后面的层需要花费大量的时间。由于这些网络的底层没有被修改，它们的输出可以被缓存并重用。现在，你手中有了TensorFlow重新训练的模型。让我们使用以下命令测试我们刚刚训练的模型：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Executing the previous code block will give you the class that the food image
    belongs to. Now, let''s go to the next task: converting the `tensorflow` model
    into the Core ML format.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码块将给出食物图像所属的类别。现在，让我们进行下一个任务：将`tensorflow`模型转换为Core ML格式。
- en: Converting the TensorFlow model into the Core ML model
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将TensorFlow模型转换为Core ML模型
- en: 'The TensorFlow team has developed a package that is used to convert the models
    created in TensorFlow into Core ML, which in through is used in iOS apps. To use
    this, you must have macOS with Python 3.6 and TensorFlow installed. Using this,
    we can convert the TensorFlow model file (`.pb`) into the Core ML format (`.mlmodel`).
    First, you need to execute the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow团队开发了一个用于将TensorFlow中创建的模型转换为Core ML的包，这最终用于iOS应用。要使用此包，你必须有安装了Python
    3.6和TensorFlow的macOS。使用此包，我们可以将TensorFlow模型文件（`.pb`）转换为Core ML格式（`.mlmodel`）。首先，你需要执行以下命令：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once this is installed, write the following code in your Python file, name
    it `inspect.py`, and save it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，请在你的Python文件中写下以下代码，将其命名为`inspect.py`并保存：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will take the model file as an input argument, and save
    all the operations and input/output node names with a description in a text file
    that we supply as input. To run this, enter the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将模型文件作为输入参数，并将所有操作和输入/输出节点名称及其描述保存在我们提供的输入文本文件中。要运行此命令，请输入以下命令：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this command, you are executing the `inspect.py` code you saved before. This
    will also input the graph file obtained from the previous section and, path of
    a text file where you want to save the summaries.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，你正在执行之前保存的`inspect.py`代码。这也会输入从上一节获得的图文件以及你想要保存摘要的文本文件路径。
- en: 'Once you execute this command, `summeries.txt` will be created with all the
    summaries, as shown here. These will be added into that file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，`summaries.txt`将创建包含所有摘要的文件，如上图所示。这些将被添加到该文件中：
- en: '![](img/4b83a234-07e4-42b9-8eb8-5e64f215a9fd.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b83a234-07e4-42b9-8eb8-5e64f215a9fd.png)'
- en: 'In this file, you can see all the operations, input and output names, and their
    shapes; you can also see the overall operators:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你可以看到所有操作、输入和输出名称及其形状；你还可以看到整体操作符：
- en: '![](img/ba72d5a4-2aab-4881-9f57-f3df430b5dd2.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba72d5a4-2aab-4881-9f57-f3df430b5dd2.png)'
- en: 'Toward the end of the file, you will find the definition of the end node; in
    our case, it is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文件末尾，你会找到结束节点的定义；在我们的例子中，如下所示：
- en: '![](img/7e6d02c2-44c4-4846-bf2b-7c3c39f4e891.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e6d02c2-44c4-4846-bf2b-7c3c39f4e891.png)'
- en: 'Here, you can see that the end node operation type is `Softmax`, and the output
    that it will produce will be stored in the `final_result:0` name. Now, check out
    the following code block, which is used to generate a corresponding Core ML model:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到结束节点操作类型是`Softmax`，它将产生的输出将存储在`final_result:0`名称中。现在，查看以下用于生成相应Core
    ML模型的代码块：
- en: '![](img/5c1fdba4-e5f6-40ec-a2fe-db4c29da5825.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c1fdba4-e5f6-40ec-a2fe-db4c29da5825.png)'
- en: 'Let''s understand the previous code block in detail. You must have noticed
    that we imported the `tfcoreml` package in the first line, and then used its **convert**
    function. The following are its arguments:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解前面的代码块。你必须已经注意到我们在第一行导入了`tfcoreml`包，然后使用了它的**convert**函数。以下是其参数：
- en: '`Tf_model_path`: The (`.pb`) file path that you generated in the previous section, *Converting
    the TensorFlow model into the Core ML model*.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tf_model_path`：你在上一节中生成的（`.pb`）文件路径，*将TensorFlow模型转换为Core ML模型*。'
- en: '`Mlmodel_path`: The output model file path where you want to generate the model.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mlmodel_path`：你想要生成模型的输出模型文件路径。'
- en: '`Output_feature_names`: In this, we will get the output variable name that
    you obtained from the previous text file that was generated by our model-inspection
    code.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Output_feature_names`：在这里，我们将获得从之前由我们的模型检查代码生成的文本文件中获得的输出变量名称。'
- en: '`Image_input_names`: Name you want to give for the image input. In Core ML/iOS,
    this will be the image buffer.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image_input_names`：您想要为图像输入指定的名称。在Core ML/iOS中，这将是一个图像缓冲区。'
- en: '`Class_labels`: This is the file you will get in the training step.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Class_labels`：这是在训练步骤中您将获得的文件。'
- en: Once you run the preceding code, you will see the generated `converted``.mlmodel`
    file in your directory. You can import this into your Xcode project and make use
    of it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行前面的代码，您将在您的目录中看到生成的`converted``.mlmodel`文件。您可以将它导入到Xcode项目中并使用它。
- en: Writing the iOS mobile application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写iOS移动应用程序
- en: In this section, we are going to create an app to make use of the image recognition
    model that we've created to predict images using your iOS mobile camera.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个应用程序，利用我们创建的图像识别模型，通过您的iOS移动摄像头预测图像。
- en: 'To start, you need a Mac PC running Xcode version 9+. Download the source code
    (x-code project) from the Git repository and navigate to the project folder. Open
    the `recognition.xcodeproj` image in Xcode. The following screenshot shows the
    folder structure of the project:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个运行Xcode版本9+的Mac PC。从Git仓库下载源代码（Xcode项目），然后导航到项目文件夹。在Xcode中打开`recognition.xcodeproj`图像。以下截图显示了项目的文件夹结构：
- en: '![](img/6d539950-49bf-4128-9e77-b64d2d50d73d.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d539950-49bf-4128-9e77-b64d2d50d73d.png)'
- en: 'The main file we are going to view is `con``troller.swift`. It contains the
    following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的主要文件是`con``troller.swift`。它包含以下代码：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'These are the outlets for the image-view control and title-label control in
    the main storyboard:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主Storyboard中图像视图控件和标题标签控件的输出：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the instance of the model that was generated when we added the `core-ml`
    file we created in the previous section:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们添加上一节中创建的`core-ml`文件时生成的模型实例：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We hardcoded the contents to display in the title label for the corresponding
    class label we trained:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们硬编码了要显示在标题标签中的内容，以对应于我们训练的相应类标签：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These are the images we have added to the project; they''ll serve as input
    for our prediction app:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们添加到项目中的图像；它们将作为我们的预测应用程序的输入：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we trained our model with 224 px images, we are also resizing the images
    of the input and converting it into an image buffer, which we want to give to
    the prediction method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用224像素的图像训练了我们的模型，因此我们也在调整输入图像的大小，并将其转换为图像缓冲区，这是我们想要提供给预测方法的：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we are inputting the image and getting the prediction results:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们输入图像并获取预测结果：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, depending on the class label, we are displaying the
    content to the user:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，根据类标签，我们向用户显示内容：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This completes the application''s creation. Now, we will execute the application
    to find the following images as output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了应用程序的创建。现在，我们将执行应用程序以找到以下图像作为输出：
- en: '![](img/10423fe5-1a92-4003-a7fd-b82cdca9a808.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10423fe5-1a92-4003-a7fd-b82cdca9a808.png)'
- en: 'Click on Next to find the our next image:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”以找到我们的下一张图像：
- en: '![](img/8ac3a3ed-ef50-4d24-88d0-4cb66649060e.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ac3a3ed-ef50-4d24-88d0-4cb66649060e.png)'
- en: Handwritten digit recognition solution
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手写数字识别解决方案
- en: Previously, we created an application that helped us get insights into the implementation
    of a neural network image recognition program using the TensorFlow model for mobile
    devices. Now, we will create another application that uses the concept of a neural
    network and Keras for an image recognition program of handwritten digits. In this
    section, we will create an application for a handwritten digit recognition solution
    on mobile devices using Keras. Then, we will convert this Keras model into a Core
    ML model and use it to build an iOS mobile application. Let's start by introducing
    you to Keras.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们创建了一个应用程序，帮助我们了解使用移动设备上的TensorFlow模型实现的神经网络图像识别程序的实现。现在，我们将创建另一个应用程序，使用神经网络和Keras的概念来实现手写数字的图像识别程序。在本节中，我们将创建一个用于移动设备上的手写数字识别解决方案的应用程序。然后，我们将此Keras模型转换为Core
    ML模型，并使用它来构建iOS移动应用程序。让我们先向您介绍Keras。
- en: Introduction to Keras
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Keras简介
- en: Keras is a high-level neural network API, written in Python and capable of running
    on top of TensorFlow, CNTK, or Theano. It was developed with the aim of enabling
    fast experimentation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Keras是一个高级神经网络API，用Python编写，能够在TensorFlow、CNTK或Theano之上运行。它旨在使快速实验成为可能。
- en: 'Here are some of the key uses of Keras:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些Keras的关键用途：
- en: Allows for easy and fast prototyping (through user-friendliness, modularity,
    and extensibility)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许轻松快速地进行原型设计（通过用户友好性、模块化和可扩展性）
- en: Supports both convolutional networks and recurrent networks, as well as a combination
    of the two
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持卷积网络和循环网络，以及两者的组合
- en: Runs seamlessly on CPU and GPU
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CPU和GPU上无缝运行
- en: 'Keras was designed on the following principles:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Keras的设计基于以下原则：
- en: User-friendliness
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户友好性
- en: Modularity
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化
- en: Easy extensibility
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展
- en: Compatibility with Python
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容Python
- en: To learn more about Keras, check out [https://keras.io/](https://keras.io/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Keras的信息，请查看[https://keras.io/](https://keras.io/)。
- en: Installing Keras
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Keras
- en: As we already discussed, Keras doesn't have its own backend system. As it is
    running on top of TensorFlow, CNTK, or Theano, we need to install one of these—personally,
    we recommend TensorFlow.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，Keras没有自己的后端系统。因为它运行在TensorFlow、CNTK或Theano之上，我们需要安装其中之一——个人推荐TensorFlow。
- en: 'We need to install the `h5py` library, with the help of the `pip` package manager,
    in order to save the Keras models to disk:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`pip`包管理器安装`h5py`库，以便将Keras模型保存到磁盘上：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding commands will install the basic required libraries for the model,
    which we are going to create now.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将安装创建模型所需的基本库。
- en: Solving the problem
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决问题
- en: In this section, we are going to see a practical implementation of a neural
    network. We will define the problem statement, then we will understand the dataset
    we are going to use to solve the problem, whereupon we will create the model in
    Keras to solve the problem. Once the model is created in Keras, we will convert
    it into a model that's compatible with Core ML. This Core ML model will be imported
    into an iOS application, and a program will be written to use this model and interpret
    the handwritten digits.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到神经网络的实际实现。我们将定义问题陈述，然后理解我们将用于解决问题的数据集，接着在Keras中创建模型以解决问题。一旦在Keras中创建了模型，我们将将其转换为与Core
    ML兼容的模型。这个Core ML模型将被导入iOS应用程序中，并编写一个程序来使用这个模型并解释手写数字。
- en: Defining the problem statement
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义问题陈述
- en: We are going to tackle the problem of recognizing handwritten digits through
    a machine learning model that we'll implement in an iOS mobile application. The
    first step is to have the database of handwritten digits that can be used for
    model training and testing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在iOS移动应用程序中实现的机器学习模型来解决识别手写数字的问题。第一步是拥有用于模型训练和测试的手写数字数据库。
- en: The MNIST digits dataset ([http://yann.lecun.com/exdb/mnist/](http://yann.lecun.com/exdb/mnist/))
    provides a database of handwritten digits, and has a training set of 60,000 examples
    and a test set of 10,000 examples. It is a subset of a larger set that's available
    from MNIST. The digits have been size-normalized and centered in a fixed-size
    image. It is a good database for people who want to learn techniques and pattern
    recognition methods on real-world data while exerting minimal effort on preprocessing
    and formatting.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: MNIST数字数据集([http://yann.lecun.com/exdb/mnist/](http://yann.lecun.com/exdb/mnist/))提供了一个手写数字数据库，包含60,000个训练示例和10,000个测试示例。它是MNIST中更大集合的一个子集。这些数字已经被尺寸归一化，并放置在固定大小的图像中。这是一个很好的数据库，对于想要在真实世界数据上学习技术和模式识别方法，同时尽量减少预处理和格式化工作的人来说非常有用。
- en: 'Before solving this problem, we will spend some time understanding the problem
    to see where the neural network can help. We can split the problem of recognizing
    handwritten digits into two sub-problems. Suppose we are given a handwritten number,
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决这个问题之前，我们将花一些时间来理解问题，看看神经网络可以在哪里提供帮助。我们可以将识别手写数字的问题分解成两个子问题。假设我们被给了一个手写的数字，如下所示：
- en: '![](img/11dd29c2-990c-4b00-a60e-24afae4c2880.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11dd29c2-990c-4b00-a60e-24afae4c2880.png)'
- en: 'First, we need to break an image containing many digits into a sequence of
    separate images, each containing a single digit. For example, we''d like to break
    this image into seven separate images, as shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将包含许多数字的图像分解成一系列单独的图像，每个图像包含一个单独的数字。例如，我们希望将这个图像分解成七个单独的图像，如下所示：
- en: '![](img/ae98dc4e-966b-481c-a6ee-c709aff7d024.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae98dc4e-966b-481c-a6ee-c709aff7d024.png)'
- en: For humans, the digits can be easily separated, but it is very challenging for
    machines to do this simple task. Once the digits are separated, the program needs
    to classify each individual digit. So, for instance, we'd like our program to
    recognize that the first digit is a **5**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类来说，数字可以很容易地分开，但对于机器来说，完成这个简单的任务却非常具有挑战性。一旦数字被分开，程序需要分类每个单独的数字。例如，我们希望我们的程序能够识别第一个数字是**5**。
- en: 'We are now trying to focus on the second part of the problem: to recognize
    the individual digits and classify them. We are going to use a neural network
    to solve the problem of recognizing individual, handwritten digits.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在试图专注于问题的第二部分：识别单个数字并对它们进行分类。我们将使用神经网络来解决识别单个手写数字的问题。
- en: We can solve this problem using a 3-layer neural network, with the output layers
    having 10 neurons. The input layer and the hidden layers are where the processing
    happens. in the output layer, based on the neuron that fires, we can easily infer
    the digit that was recognized. Neurons 0 to 9 each identify one digit.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个具有 10 个神经元的输出层的 3 层神经网络来解决此问题。输入层和隐藏层是处理发生的地方。在输出层，根据激活的神经元，我们可以轻松推断出识别的数字。神经元
    0 到 9 分别识别一个数字。
- en: Problem solution
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题解决方案
- en: 'The problem solution consists of the following key steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决方案包括以下关键步骤：
- en: Preparing the data
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备数据
- en: Defining the model
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义模型
- en: Training and fitting the model
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练和拟合模型
- en: Converting the trained Keras model into a Core ML model
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将训练好的 Keras 模型转换为 Core ML 模型
- en: Writing the iOS mobile application
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 iOS 移动应用程序
- en: Now, let's go through the steps one by one and see what we need to do in each
    of these steps.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个步骤进行，看看在每个步骤中我们需要做什么。
- en: Preparing the data
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据
- en: 'The first activity is the data preparation. To start, let''s import all the
    required libraries. As we discussed earlier, we are going to use the MNIST database
    for the dataset of handwritten digits:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个活动是数据准备。首先，让我们导入所有必需的库。如我们之前讨论的，我们将使用 MNIST 数据库作为手写数字数据集：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`mnist` is the dataset that contains the handwritten digits database, so we
    need to import that, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`mnist` 是包含手写数字数据库的数据集，因此我们需要按照以下方式导入它：'
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code imports the `Sequential` model type from Keras. This is
    simply a linear stack of neural network layers:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从 Keras 导入了 `Sequential` 模型类型。这只是一个神经网络层的线性堆叠：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we need to import the core layers from Keras. These are the layers that
    are used in almost any neural network:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从 Keras 导入核心层。这些是在几乎任何神经网络中使用的层：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Import the CNN layers from Keras. These are the convolutional layers that will
    help us efficiently train on image data:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Keras 导入 CNN 层。这些是卷积层，将帮助我们有效地在图像数据上训练：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Import Utils. This will help us do data transformation later:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Utils。这将帮助我们稍后进行数据转换：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`coremltools` will help us convert the Keras model into the Core ML model:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`coremltools` 将帮助我们将 Keras 模型转换为 Core ML 模型：'
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Load the pre-shuffled MNIST data into train and test sets:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将预洗牌的 MNIST 数据加载到训练集和测试集中：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run the preceding code, it will show the shape of X, Y, and also the
    first record of X.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，它将显示 X、Y 的形状，以及 X 的第一条记录。
- en: 'So, we have 60,000 samples in our training set, and the images are 28 x 28
    pixels each. We can confirm this by plotting the first sample in `matplotlib`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的训练集中有 60,000 个样本，每个图像都是 28 x 28 像素。我们可以通过在 `matplotlib` 中绘制第一个样本来确认这一点：
- en: '![](img/60504c64-3e01-40f5-8435-9597e1956068.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60504c64-3e01-40f5-8435-9597e1956068.png)'
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This statement will use the `matplotlib` library to plot the first record of `x_train`,
    which will give the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句将使用 `matplotlib` 库绘制 `x_train` 的第一条记录，将给出以下输出：
- en: '![](img/9a458001-b1a7-4714-8b7c-a5d60ec0a224.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a458001-b1a7-4714-8b7c-a5d60ec0a224.png)'
- en: 'The following lines will print the `y_train` shape and the first 10 elements
    in `y_train`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将打印 `y_train` 的形状和 `y_train` 中的前 10 个元素：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code will find the input shape of the image. The MNIST image
    data values are of the `uint8` type, in the *[0, 255]* range, but Keras needs
    values of the `float32` type in the *[0, 1]* range:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将找到图像的输入形状。MNIST 图像数据值是 `uint8` 类型，范围在 *[0, 255]*，但 Keras 需要范围在 *[0, 1]*
    的 `float32` 类型的值：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using the following code, we are converting the datatype to be compatible with
    the datatype that is defined in Keras:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，我们将数据类型转换为与 Keras 中定义的数据类型兼容：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we have a one-dimensional of 60,000 elements in `y`. Let''s convert it
    into a 60,000 x 10 array, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`y` 中有一个包含 60,000 个元素的向量。让我们将其转换为 60,000 x 10 的数组，如下所示：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, `y_train` will look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`y_train` 将看起来像这样：
- en: '![](img/ba98ae88-78d7-428e-90ae-8f42166b6a71.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba98ae88-78d7-428e-90ae-8f42166b6a71.png)'
- en: In the preceding array, we can find that for the presence of digits, the corresponding
    position will be filled with 1—all others will be filled with 0\. For the first
    record, we can understand that the predicted digit is 5, because the 6th position
    (starting from 0) was filled with 1.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数组中，我们可以发现对于数字的存在，相应的位置将被填充为 1——所有其他位置都将填充为 0。对于第一条记录，我们可以理解预测的数字是 5，因为从
    0 开始的第 6 个位置被填充了 1。
- en: Now that the data preparation is complete, we need to define the model's architecture.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据准备已完成，我们需要定义模型的架构。
- en: Defining the model's architecture
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模型的架构
- en: 'Once the data preparation is completed, the next step is to define the model
    and create it, so let''s create the model:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备完成后，下一步是定义模型并创建它，所以让我们创建模型：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding line will create a sequential model that will process the layers
    in the sequential way they are arranged. There are two ways to build Keras models, sequential and functional:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行将创建一个顺序模型，该模型将以它们排列的顺序处理层。有两种方法可以构建 Keras 模型，顺序和功能：
- en: '**The sequential API**: This allows us to create models layer-by-layer. Through
    this, we cannot create models that share layers or have multiple input or output.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序 API**：这允许我们逐层创建模型。通过这种方式，我们无法创建共享层的模型或具有多个输入或输出的模型。'
- en: '**The functional ****API**: This allows us to create models that are more than
    and can have complex connection layers—you can literally connect from any layer
    to any other layer:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能 API**：这允许我们创建比顺序模型更复杂、可以具有复杂连接层的模型——你可以从任何层连接到任何其他层：'
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The input shape parameter should be the shape of `1` sample. In this case, it's
    the same `(1, 28, 28)`, which corresponds to the (depth, width, height) of each
    digit image.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输入形状参数应该是 `1` 个样本的形状。在这种情况下，它与每个数字图像的 (深度，宽度，高度) 相同，即 `(1, 28, 28)`。
- en: 'But what do the other parameters represent? They correspond to the number of
    convolutional filters to use, the number of rows in each convolution kernel, and
    the number of columns in each convolution kernel, respectively:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但其他参数代表什么？它们分别对应要使用的卷积滤波器的数量、每个卷积核的行数和每个卷积核的列数：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`MaxPooling2D` is a way to reduce the number of parameters in our model by
    sliding a 2 x 2 pooling filter across the previous layer and taking the max of
    the 4 values in the 2 x 2 filter:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaxPooling2D` 是通过在上一层滑动一个 2 x 2 的池化滤波器并取 2 x 2 滤波器中 4 个值的最大值来减少我们模型中参数数量的方法：'
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is a method for regularizing our model in order to prevent overfitting:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于正则化我们的模型以防止过拟合的方法：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once you run the preceding lines of code, the model architecture''s names of
    the layers will be printed in the console:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行前面的代码行，模型架构的层的名称将在控制台中打印出来：
- en: '![](img/e2d7f91a-f566-4497-bec5-356f3064bb0f.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2d7f91a-f566-4497-bec5-356f3064bb0f.png)'
- en: Compiling and fitting the model
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和调整模型
- en: The next step is to compile and train the model. We put the model through the
    training phase with a series of iterations. Epochs determine the number of iterations
    to be done on a model in the training phase. The weights will be passed to the
    layers defined in the model. A good number of Epochs will give greater accuracy
    and minimum loss. Here, we are using 10 Epochs.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编译和训练模型。我们通过一系列迭代将模型放入训练阶段。Epochs 决定了训练阶段中模型要进行的迭代次数。权重将被传递到模型中定义的层。足够的
    Epochs 将提供更高的准确率和最小的损失。在这里，我们使用 10 个 Epochs。
- en: 'Keras has a callback mechanism that will be called during each training iteration
    of the model, that is, at the end of each Epoch. In the callback method, we save
    the computed weights of that Epoch:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Keras 具有回调机制，该机制将在模型的每次训练迭代期间被调用，即在每个 Epoch 结束时。在回调方法中，我们保存该 Epoch 计算出的权重：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, compile the model using the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下代码编译模型：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `categorical_crossentropy` loss function measures the distance between the
    probability distribution calculated by the CNN, and the true distribution of the
    labels.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`categorical_crossentropy` 损失函数衡量 CNN 计算出的概率分布与标签的真实分布之间的距离。'
- en: 'An `optimizer` is the stochastic gradient descent algorithm that tries to minimize
    the loss function by following the gradient at just the right speed. `accuracy` the
    fraction of the images that were correctly classified—this is the most common
    metric monitored during training and testing:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `optimizer` 是一种随机梯度下降算法，它试图通过跟随正确的速度的梯度来最小化损失函数。`accuracy` 是正确分类的图像的比例——这是训练和测试期间最常监控的指标：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, fit the model using the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下代码拟合模型：
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once the program finishes executing, you will find files in your running directory
    with the `best_model.01-0.15.h5` name. This states `best_model.{epoch number}-{loss
    value}.h5`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序执行完成，你将在运行目录中找到名为`best_model.01-0.15.h5`的文件。这表示`best_model.{epoch number}-{loss
    value}.h5`。
- en: This the Keras model that was created and trained for the given dataset.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为给定数据集创建和训练的Keras模型。
- en: Converting the Keras model into the Core ML model
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Keras模型转换为Core ML模型
- en: 'Now that the Keras model has been created, the next step is to convert the
    Keras model into the Core ML model. For the first argument, use the filename of
    the newest `.h5` file in the notebook folder:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Keras模型已经创建，下一步是将Keras模型转换为Core ML模型。对于第一个参数，使用笔记本文件夹中最新的`.h5`文件的文件名：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you successfully run the code, you will find the `minsit_classifer.mlmodel` file
    created in your directory. We are going to use this to create an iOS mobile application
    to detect the digits.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功运行代码，你将在你的目录中找到创建的`minsit_classifer.mlmodel`文件。我们将使用这个文件来创建一个iOS移动应用程序以检测数字。
- en: Creating the iOS mobile application
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建iOS移动应用程序
- en: Now, we are going to create the iOS app. You can download the code from our
    Packt GitHub repository in the `ImageClassificationwithVisionandCoreML` folder.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建iOS应用程序。你可以从我们的Packt GitHub仓库的`ImageClassificationwithVisionandCoreML`文件夹中下载代码。
- en: 'Open the project in Xcode9+; the project structure will look like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode9+中打开项目；项目结构将如下所示：
- en: '![](img/0e59ce2a-bd3d-4f4d-b86f-ce982b01de99.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e59ce2a-bd3d-4f4d-b86f-ce982b01de99.png)'
- en: 'If you open `main.storyboard` in your designer, you will see the following
    UI:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开设计师中的`main.storyboard`，你会看到以下UI：
- en: '![](img/bade5a63-117d-4e93-ad49-65b8b28b932f.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bade5a63-117d-4e93-ad49-65b8b28b932f.png)'
- en: 'Most code is common iOS code. Check out the following piece of code, which
    is of specific interest to us, and includes the handwritten digit prediction code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码是常见的iOS代码。查看以下代码片段，它对我们特别感兴趣，并包括手写数字预测代码：
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It contains two buttons at the bottom: one to pick an image from mobile and
    another option to take a snapshot. Please note that the camera will not work if
    you are running this in simulators.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 它在底部包含两个按钮：一个用于从手机中选择图像，另一个选项用于拍照。请注意，如果你在模拟器中运行此应用程序，相机将无法工作。
- en: You can build and run the app in a simulator. Once the app successfully opens
    in a simulator, drag the image of the handwritten digit 6 into the folder example
    image into the simulator–this will save the file in the simulator's memory.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模拟器中构建和运行应用程序。一旦应用程序在模拟器中成功打开，将手写数字6的图像拖拽到模拟器中的example image文件夹中–这将保存文件到模拟器的内存中。
- en: 'Return to the app and select the dragged image that was saved in the device''s
    memory. It will show the following output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 返回应用程序并选择保存在设备内存中的拖拽图像。它将显示以下输出：
- en: '![](img/add4696c-39dc-4307-9f16-b797634bef23.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/add4696c-39dc-4307-9f16-b797634bef23.png)'
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the concept of neural networks and their use in
    the field of mobile machine learning. We created an application to recognize images
    using TensorFlow and Core ML in iOS and Xcode. We also explored the Keras deep
    learning framework. We tried to solve the handwritten digit recognition problem
    using a neural network in Keras. We built the Keras machine learning model to
    solve this problem. Then, we converted this model into a Core ML model using Core
    ML conversion tools. We used this Core ML model in an iOS mobile application to
    perform the handwritten digit recognition.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了神经网络的概念及其在移动机器学习领域的应用。我们创建了一个应用程序，使用TensorFlow和Core ML在iOS和Xcode中识别图像。我们还探讨了Keras深度学习框架。我们尝试使用Keras中的神经网络解决手写数字识别问题。我们构建了Keras机器学习模型来解决这个问题。然后，我们使用Core
    ML转换工具将此模型转换为Core ML模型。我们使用这个Core ML模型在iOS移动应用程序中执行手写数字识别。
- en: In the next chapter, we will learn how to use the Google Cloud Vision label
    detection technique in Android.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在Android中使用Google Cloud Vision标签检测技术。
