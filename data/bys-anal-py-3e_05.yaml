- en: Chapter 6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Modeling with Bambi
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bambi建模
- en: A good tool improves the way you work. A great tool improves the way you think.
    – Jeff Duntemann
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一件好工具能改善你的工作方式，一件伟大的工具能改善你的思维方式。——Jeff Duntemann
- en: In *Chapter [4](CH04.xhtml#x1-760004)*, we described the basic ingredients of
    linear regression models and how to generalize them to better fit our needs. In
    this chapter, we are going to keep learning about linear models, but this time,
    we are going to work with Bambi [[Capretto et al.](Bibliography.xhtml#XCapretto_2022), [2022](Bibliography.xhtml#XCapretto_2022)],
    a high-level Bayesian model-building interface written on top of PyMC. Bambi is
    designed to make it extremely easy to fit linear models, including hierarchical
    ones. We will see that Bambi’s domain is more comprehensive than just linear models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第[4章](CH04.xhtml#x1-760004)*中，我们描述了线性回归模型的基本成分以及如何将其推广以更好地适应我们的需求。在这一章中，我们将继续学习线性模型，但这次，我们将使用Bambi
    [[Capretto et al.](Bibliography.xhtml#XCapretto_2022), [2022](Bibliography.xhtml#XCapretto_2022)]，一个基于PyMC构建的高层贝叶斯模型构建接口。Bambi旨在使拟合线性模型，包括分层模型，变得极其简单。我们将看到Bambi的领域不仅限于线性模型。
- en: 'We are going to learn about:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习以下内容：
- en: Using Bambi to build and fit models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bambi构建并拟合模型
- en: Analyzing results with Bambi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bambi分析结果
- en: Polynomial regression and splines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式回归与样条函数
- en: Distributional models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布模型
- en: Categorical predictors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类预测变量
- en: Interactions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互作用
- en: Variable selection with Kulprit
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kulprit进行变量选择
- en: 6.1 One syntax to rule them all
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 一种语法解决所有问题
- en: PyMC has a very simple and expressive syntax that allows us to build arbitrary
    models. That’s usually a blessing, but it can be a burden too. Bambi instead focuses
    on regression models, and this restriction leads to a more focused syntax and
    features, as we will see.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PyMC有一个非常简单而富有表现力的语法，它允许我们构建任意模型。这通常是一个福音，但有时也可能成为负担。Bambi则专注于回归模型，这种限制使得语法和功能更加专注，正如我们将看到的那样。
- en: Bambi uses a Wilkinson-formula syntax similar to the one used by many R packages
    like nlme, lme4, and brms. Let’s assume `data` is a pandas DataFrame like the
    one shown in *Table [6.1](#x1-121002r1)*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Bambi使用了类似许多R包（如nlme、lme4和brms）所用的Wilkinson公式语法。假设`data`是一个像*表格[6.1](#x1-121002r1)*中展示的那样的pandas
    DataFrame。
- en: '|  | *y* | *x* | *z* | *g* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  | *y* | *x* | *z* | *g* |'
- en: '| 0 | -0.633494 | -0.196436 | -0.355148 | Group A |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 0 | -0.633494 | -0.196436 | -0.355148 | A组 |'
- en: '| 1 | 2.32684 | 0.0163941 | -1.22847 | Group B |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2.32684 | 0.0163941 | -1.22847 | B组 |'
- en: '| 2 | 0.999604 | 0.107602 | -0.391528 | Group C |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.999604 | 0.107602 | -0.391528 | C组 |'
- en: '| 3 | -0.119111 | 0.804268 | 0.967253 | Group A |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 3 | -0.119111 | 0.804268 | 0.967253 | A组 |'
- en: '| 4 | 2.07504 | 0.991417 | 0.590832 | Group B |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2.07504 | 0.991417 | 0.590832 | B组 |'
- en: '| 5 | -0.412135 | 0.691132 | -2.13044 | Group C |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 5 | -0.412135 | 0.691132 | -2.13044 | C组 |'
- en: '**Table 6.1**: A dummy pandas DataFrame'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 6.1**：一个示例pandas DataFrame'
- en: 'Using this data, we want to build a linear model that predicts `y` from `x`.
    Using PyMC, we would do something like the model in the following code block:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些数据，我们想要构建一个从`x`预测`y`的线性模型。使用PyMC，我们会做类似以下代码块中的模型：
- en: '**Code 6.1**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.1**'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The formula syntax used by Bambi allows us to define an equivalent model in
    a much more compact way:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Bambi使用的公式语法让我们可以更紧凑地定义一个等效的模型：
- en: '**Code 6.2**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.2**'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On the left side of the tilde (∼), we have the dependent variable, and on the
    right side, the independent variable(s). With this syntax, we are just specifying
    the mean (*μ* in the PyMC’s model `lm`). By default, Bambi assumes the likelihood
    is Gaussian; you can change this with the `family` argument. The formula syntax
    does not specify priors distribution, just how the dependent and independent variables
    are related. Bambi will automatically define (very) weakly informative priors
    for us. We can get more information by printing a Bambi model. If you print `a_model`,
    you should get something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在波浪符号（∼）的左侧是因变量，右侧是自变量（们）。通过这种语法，我们只是指定了均值（在PyMC模型`lm`中的*μ*）。默认情况下，Bambi假设似然函数是高斯分布；你可以通过`family`参数来更改这一点。公式语法并没有指定先验分布，只是描述了因变量和自变量之间的关系。Bambi会自动为我们定义（非常）弱的信息先验。我们可以通过打印Bambi模型来获取更多信息。如果你打印`a_model`，你应该会看到类似如下的内容：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first line shows the formula we used to define the model, and the second
    line is the likelihood. The third line is the link function. Then we have the
    number of observations used to fit the model, and the next is telling us we are
    linearly modeling the parameter `mu` of the Gaussian. The latter part of the output
    shows the model structure: the common-level effects, in this case, the intercept
    (`Intercept`) and the slope (`x`), and the auxiliary parameters, i.e., all the
    parameters not linearly modeled, in this case, the standard deviation of the Gaussian.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示了我们用来定义模型的公式，第二行是似然函数。第三行是链接函数。然后我们有用于拟合模型的观测数量，接下来告诉我们我们正在线性建模高斯的参数`mu`。输出的后半部分显示了模型结构：共同水平效应，在本例中是截距(`Intercept`)和斜率(`x`)，以及辅助参数，即所有非线性建模的参数，本例中是高斯标准差。
- en: 'You can override the default priors by passing a dictionary to the `priors`
    argument to `bmb.Model`. For instance, if we want to define a custom prior for
    the coefficient of the variable `x` and also for the auxiliary parameter `sigma`,
    we can do this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将字典传递给`bmb.Model`的`priors`参数来覆盖默认先验分布。例如，如果我们想为变量`x`的系数和辅助参数`sigma`定义自定义先验分布，我们可以这样做：
- en: '**Code 6.3**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.3**'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a result, we will get the following model specifications:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们将得到以下模型规范：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to omit the intercept from your model, you can do it like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从模型中省略截距，可以这样做：
- en: 'Code 6.4:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 6.4：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or even like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至这样做：
- en: 'Code 6.5:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 6.5：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Print the model `no_intercept_model`, and you will see that the intercept is
    not there anymore.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 打印模型`no_intercept_model`，您会看到截距不再存在。
- en: 'What if we want to include more variables? We can do it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要包含更多变量怎么办？我们可以这样做：
- en: '**Code 6.6**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.6**'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also include group-level effects (hierarchies); for example, if we want
    to use the variable `g` to partially pool the estimates of `x`, we can do it like
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以包含组级效应（层次结构）；例如，如果我们想要使用变量`g`来部分汇总`x`的估计值，我们可以这样做：
- en: '**Code 6.7**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.7**'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see a visual representation of this model in *Figure [6.1](#x1-121081r1)*.
    Notice the variables `1|g_offset` and `x|g_offset`. By default, Bambi fits a noncentered
    hierarchical model; you can change this with the argument `noncentered`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图 [6.1](#x1-121081r1)*中看到这个模型的视觉表示。注意变量`1|g_offset`和`x|g_offset`。默认情况下，Bambi拟合一个非居中的分层模型；您可以通过参数`noncentered`来更改这一点。
- en: '![PIC](img/file169.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file169.png)'
- en: '**Figure 6.1**: A visual representation of `model_h`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.1**：`model_h`的视觉表示'
- en: The formula syntax is very simple, but it is also very powerful. We have just
    scratched the surface of what we can do with it. Instead of describing the syntax
    all at once, we are going to show it by example. If you want to go deeper, you
    can check Formulae documentation [https://bambinos.github.io/formulae/](https://bambinos.github.io/formulae/).
    formulae is the Python package in charge of parsing Wilkinson’s formulas for Bambi.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 公式语法非常简单，但也非常强大。我们只是初步展示了可以使用它做什么。如果您想深入了解，可以查看公式文档 [https://bambinos.github.io/formulae/](https://bambinos.github.io/formulae/)。
    formulae是负责解析威尔金森公式用于Bambi的Python包。
- en: 6.2 The bikes model, Bambi’s version
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 自行车模型，Bambi版本
- en: 'The first model we are going to use to illustrate how to use Bambi is the bikes
    model from *Chapter [4](CH04.xhtml#x1-760004)*. We can load the data with:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用自行车模型来说明如何使用Bambi，该模型来自*第 [4](CH04.xhtml#x1-760004)*章。我们可以通过以下方式加载数据：
- en: '**Code 6.8**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.8**'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can build and fit the model:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建和拟合模型：
- en: '**Code 6.9**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.9**'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Figure [6.2](#x1-122009r2)* shows a visual representation of the model. If
    you want to visually inspect the priors, you can use `model.plot_priors()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.2](#x1-122009r2)*展示了模型的视觉表示。如果您想要直观地检查先验分布，可以使用`model.plot_priors()`：'
- en: '![PIC](img/file170.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file170.png)'
- en: '**Figure 6.2**: A visual representation of the bikes model, computed with the
    command `model.graph()`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.2**：用命令`model.graph()`计算的自行车模型的视觉表示'
- en: 'Let’s now plot the posterior mean and the posterior predictive distribution
    (predictions). Omitting some details needed to make the plots look nice, the code
    to do this is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们绘制后验均值和后验预测分布（预测）。为了使图表看起来漂亮，省略了一些细节，做这些操作的代码是：
- en: '**Code 6.10**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.10**'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`plot_predictions` is a function from Bambi’s submodule `interpret`. This function
    helps to analyze regression models by plotting conditional adjusted predictions,
    visualizing how a parameter of the (conditional) response distribution varies
    as a function of (some) interpolated explanatory variables. We can see the result
    of this code in *Figure [6.3](#x1-122018r3)*. The left panel shows the posterior
    mean and the 94% HDI, while the right panel shows the posterior predictive distribution
    (the predicted distribution of the rented bikes). Notice that the uncertainty
    for the predictions is much larger than the uncertainty for the mean (`pps=False`).
    This is because the posterior predictive distribution accounts for the uncertainty
    in the model parameters and the uncertainty in the data, whereas the posterior
    distribution of the mean only accounts for the uncertainty in the intercept and
    slope parameters.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_predictions` 是 Bambi 子模块 `interpret` 中的一个函数。这个函数通过绘制条件调整预测，帮助分析回归模型，展示（条件）响应分布中的某个参数如何随（某些）插值的解释变量变化。我们可以在*图
    [6.3](#x1-122018r3)*中看到这段代码的结果。左侧面板显示后验均值和 94% HDI，而右侧面板显示后验预测分布（租用自行车的预测分布）。请注意，预测的不确定性远大于均值的不确定性（`pps=False`）。这是因为后验预测分布考虑了模型参数的不确定性以及数据的不确定性，而均值的后验分布仅考虑了截距和斜率参数的不确定性。'
- en: '![PIC](img/file171.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file171.png)'
- en: '**Figure 6.3**: Posterior mean and posterior predictive distribution for the
    bikes model'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.3**：自行车模型的后验均值和后验预测分布'
- en: 'The utility of `plot_cap` becomes more evident when we have more than one explanatory
    variable. For example, let’s fit a model that uses both temperature and humidity
    to predict the number of rented bikes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多个解释变量时，`plot_cap` 的实用性变得更加明显。例如，假设我们拟合一个模型，使用温度和湿度来预测租赁的自行车数量：
- en: '**Code 6.11**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.11**'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In *Figure [6.4](#x1-122029r4)*, we can see five panels, each one showing the
    change of the number of rented bikes with the temperature at different values
    of `humidity`. As you can see, the number of rented bikes increases with temperature,
    but the slope is larger when humidity is low.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 [6.4](#x1-122029r4)*中，我们可以看到五个面板，每个面板展示了在不同湿度值下，租赁自行车数量随温度变化的情况。正如你所看到的，租赁的自行车数量随温度上升而增加，但在湿度较低时，斜率更大。
- en: '![PIC](img/file172.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file172.png)'
- en: '**Figure 6.4**: Posterior mean for the bikes model with temperature and humidity'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.4**：带有温度和湿度的自行车模型的后验均值'
- en: 6.3 Polynomial regression
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 多项式回归
- en: 'One way to fit curves using a linear regression model is by building a polynomial,
    like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性回归模型拟合曲线的一种方法是构建一个多项式，像这样：
- en: '![μ = 𝛽0 + 𝛽1x + 𝛽2x2 + 𝛽3x3 + 𝛽4x4...𝛽mxm ](img/file173.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![μ = 𝛽0 + 𝛽1x + 𝛽2x2 + 𝛽3x3 + 𝛽4x4...𝛽mxm ](img/file173.jpg)'
- en: We call *m* the degree of the polynomial.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称*m*为多项式的次数。
- en: There are two important things to notice. First, polynomial regression is still
    linear regression; the linearity refers to the coefficients (the *β*s), not the
    variables (the *x*s). The second thing to note is that we are creating new variables
    out of thin air. The only observed variable is `x`, the rest are just powers of
    `x`. Creating new variables from observed ones is a perfectly valid ”trick” when
    doing regression; sometimes the transformation can be motivated or justified by
    theory (like taking the square root of the length of babies), but sometimes it
    is just a way to fit a curve. The intuition with polynomials is that for a given
    value of `x`, the higher the degree of the polynomial, the more flexible the curve
    can be. A polynomial of degree 1 is a line, a polynomial of degree 2 is a curve
    that can go up or down, a polynomial of degree 3 is a curve that can go up and
    then down (or the other way around), and so on. Notice I said ”can” because if
    we have a polynomial of degree 3, like *β*[0] + *β*[1]*x* + *β*[2]*x*² + *β*[3]*x*³,
    but the coefficients *β*[2] and *β*[3] are 0 (or practically 0), then the curve
    will be a line.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有两点需要注意。首先，多项式回归仍然是线性回归；线性是指系数（*β*），而不是变量（*x*）。第二点需要注意的是，我们正在凭空创建新变量。唯一被观测到的变量是`x`，其余的只是`x`的幂。通过观察到的变量创造新变量是回归中完全有效的“技巧”；有时这种变换可以通过理论来解释或说明（比如取婴儿身长的平方根），但有时它仅仅是为了拟合曲线。多项式的直观理解是，对于给定的`x`值，阶数越高的多项式，曲线的灵活性越强。1阶多项式是直线，2阶多项式是可以向上或向下的曲线，3阶多项式是可以先上升再下降的曲线（或反之），以此类推。注意我说的是“可以”，因为如果我们有一个3阶多项式，比如
    *β*[0] + *β*[1]*x* + *β*[2]*x*² + *β*[3]*x*³，但系数*β*[2]和*β*[3]是0（或几乎为0），那么曲线就会是一条直线。
- en: 'There are two ways to define a polynomial regression with Bambi. We can write
    the *raw* polynomials:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bambi定义多项式回归有两种方式。我们可以写出*原始*多项式：
- en: '**Code 6.12**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.12**'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we use the identity function `I()` to make it clear that we want to elevate
    *x* to some power. We need this because the `**` operator has a special meaning
    for Bambi. If we use this syntax, we are telling Bambi to model the mean of *y*
    as *α* + *β*[0]*x* + *β*[0]*x*² + *β*[0]*x*³ + *β*[0]*x*⁴.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用恒等函数`I()`来明确表示我们希望将*x*提升到某个幂次。我们需要这样做，因为`**`操作符在Bambi中有特殊的含义。如果我们使用这种语法，实际上是在告诉Bambi将*y*的均值建模为
    *α* + *β*[0]*x* + *β*[0]*x*² + *β*[0]*x*³ + *β*[0]*x*⁴。
- en: 'Alternatively, we can write:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以写：
- en: '**Code 6.13**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.13**'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will also generate a polynomial of degree 4, but the polynomial terms will
    be orthogonal to each other, meaning the correlation between the terms is reduced.
    Without going into the mathematical details, this has at least two important consequences
    with respect to the *standard* polynomial. First, the estimation can be numerically
    more stable, and second, the interpretation of the coefficients is different.
    In `standard` polynomial regression, the coefficients can be difficult to interpret,
    as changing the value of one coefficient affects the entire polynomial. In contrast,
    orthogonal polynomials allow you to interpret the effect of each term more clearly,
    as they are independent of each other. While the interpretation of the coefficients
    is different, other results remain the same. For instance, you should get the
    same predictions with both approaches.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会生成一个4阶的多项式，但多项式项之间是正交的，这意味着项之间的相关性被降低了。不深入数学细节，这至少有两个重要的结果与*标准*多项式相比。首先，估计可能在数值上更稳定；其次，系数的解释方式不同。在`标准`多项式回归中，系数可能很难解释，因为改变一个系数的值会影响整个多项式。相比之下，正交多项式可以让你更清晰地解释每个项的影响，因为它们彼此独立。尽管系数的解释不同，但其他结果保持不变。例如，使用这两种方法你应该得到相同的预测结果。
- en: 'Let’s build an orthogonal polynomial of degree 4 to model the bike data. For
    this example, we are going to use the `hour` variable:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个4阶的正交多项式来拟合自行车数据。在这个例子中，我们将使用`hour`变量：
- en: '**Code 6.14**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.14**'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Figure [6.5](#x1-123014r5)* shows the posterior mean and the posterior predictive
    distribution. On the first row, you will see a polynomial of degree 1, which is
    equivalent to a linear model. On the second row, you will see a polynomial of
    degree 4.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.5](#x1-123014r5)* 显示了后验均值和后验预测分布。在第一行，你将看到一个1阶的多项式，它相当于一个线性模型。在第二行，你将看到一个4阶的多项式。'
- en: '![PIC](img/file174.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file174.png)'
- en: '**Figure 6.5**: Posterior mean and posterior predictive distribution for the
    bikes model with temperature and humidity'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.5**：温度和湿度下的自行车模型的后验均值和后验预测分布'
- en: One problem with polynomials is that they act *globally*. When we apply a polynomial
    of degree *m*, we are saying that the relationship between the independent and
    dependent variables is of degree *m* for the entire dataset. This can be problematic
    when different regions of our data need different levels of flexibility. This
    could lead, for example, to curves that are too flexible. As the degree increases,
    the fit becomes more sensitive to the removal of points, or equivalently to the
    addition of future data. In other words, as the degree increases, the model becomes
    more prone to overfitting. Bayesian polynomial regression usually suffers less
    of this ”excess” of flexibility because we usually don’t use flat priors, and
    we do not compute a single set of coefficients, but the entire posterior distribution.
    Still, we can do better.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式的一个问题是它们作用*全局*。当我们应用一个阶数为*m*的多项式时，我们实际上是在说自变量与因变量之间的关系在整个数据集中都是阶数*m*。当数据的不同区域需要不同灵活性时，这可能会造成问题。例如，这可能导致曲线过于灵活。随着阶数的增加，拟合变得更加敏感于数据点的移除，或者等同于对未来数据的加入。换句话说，随着阶数的增加，模型更容易发生过拟合。贝叶斯多项式回归通常较少遭遇这种“过度”灵活性，因为我们通常不使用平坦的先验，并且我们不会计算单一的系数集，而是计算整个后验分布。不过，我们还是可以做得更好。
- en: 6.4 Splines
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 样条曲线
- en: 'A general way to write very flexible models is to apply functions *B*[*m*]
    to *X*[*m*] and then multiply them by coefficients *β*[*m*]:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，写出非常灵活的模型的方法是将函数*B*[*m*]应用于*X*[*m*]，然后将它们与系数*β*[*m*]相乘：
- en: '![μ = 𝛽0 + 𝛽1B1 (X1) + 𝛽2B2(X2 )+ ⋅⋅⋅+ 𝛽mBm (Xm ) ](img/file175.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![μ = 𝛽0 + 𝛽1B1 (X1) + 𝛽2B2(X2 )+ ⋅⋅⋅+ 𝛽mBm (Xm ) ](img/file175.jpg)'
- en: We are free to pick *B*[*m*] as we wish; for instance, we can pick polynomials.
    But we can also pick other functions. A popular choice is to use B-splines; we
    are not going to discuss their definition, but we can think of them as a way to
    create smooth curves in such a way that we get flexibility, as with polynomials,
    but less prone to overfitting. We achieve this by using piecewise polynomials,
    that is, polynomials that are restricted to affect only a portion of the data.
    *Figure [6.6](#x1-124002r6)* shows three examples of piecewise polynomials of
    increasing degrees. The dotted vertical lines show the ”knots,” which are the
    points used to restrict the regions, the dashed gray line represents the function
    we want to approximate, and the black lines are the piecewise polynomials.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自由选择*B*[*m*]，例如，我们可以选择多项式。但我们也可以选择其他函数。一种常见的选择是使用B样条；我们不打算讨论它们的定义，但可以将它们视为一种创建平滑曲线的方式，使得我们在获得像多项式一样的灵活性时，过拟合的可能性较小。我们通过使用分段多项式来实现这一点，即将多项式限制在仅影响数据的一部分的区域内。*图
    [6.6](#x1-124002r6)* 显示了逐步增加阶数的分段多项式的三个示例。虚线垂直线表示“节点”，它们是用于限制区域的点，虚灰线表示我们要逼近的函数，黑线表示分段多项式。
- en: '![PIC](img/file176.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file176.png)'
- en: '**Figure 6.6**: Piecewise polynomials of increasing degrees'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.6**：逐步增加阶数的分段多项式'
- en: '*Figure [6.7](#x1-124004r7)* shows examples of splines of degree 1 and 3; the
    dots at the bottom represent the knots, and the dashed lines are the B-splines.
    At the top, we have all the B-splines with equal weight; we use grayscale to highlight
    that we have many B-splines. On the bottom panel, each B-spline is weighted differently
    (we multiply them by *β*[*m*] coefficients); if we sum the weighted B-splines,
    we get the black line as a result. This black line is what we usually call ”the
    spline.” We can use Bayesian statistics to find the proper weights for the B-splines.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.7](#x1-124004r7)* 显示了1阶和3阶样条的示例；底部的点表示“节点”，虚线表示B样条。在顶部，我们展示了所有具有相等权重的B样条；我们使用灰度来突出显示我们有多个B样条。在底部面板中，每个B样条的权重不同（我们通过*β*[*m*]系数对它们进行加权）；如果我们对加权后的B样条进行求和，最终得到的黑线就是结果。这条黑线通常被称为“样条曲线”。我们可以使用贝叶斯统计来找到B样条的适当权重。'
- en: '![PIC](img/file177.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file177.png)'
- en: '**Figure 6.7**: B-splines of degree 1 (piecewise linear) or 3 (cubic spline)
    and the resulting splines.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6.7**：1阶（分段线性）或3阶（立方样条）的B样条及其结果样条曲线。'
- en: 'We can use B-splines with Bambi by using the `bs` function. For example, let’s
    fit a spline of degree 3 to the bikes data:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`bs`函数，在Bambi中使用B样条。例如，让我们对自行车数据拟合一个3阶的样条曲线：
- en: '**Code 6.15**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码6.15**'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Figure [6.8](#x1-124013r8)* shows that the number of rental bikes is at the
    lowest number late at night. There is then an increase, probably as people wake
    up and go to work or school, or do other activities. We have a first peak at around
    hour 8, then a slight decline, followed by the second peak at around hour 18,
    probably because people commute back home, after which there is a steady decline.
    Notice that the curve is not very smooth; this is not because of the spline but
    because of the data. We have measurements at discrete times (every hour).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.8](#x1-124013r8)* 显示了租赁自行车数量在深夜时最低。然后有一个增加，可能是因为人们醒来去上班、上学或做其他活动。我们在大约第8小时左右有一个第一个高峰，然后略微下降，接着在大约第18小时出现第二个高峰，可能是因为人们下班回家，之后出现稳定的下降。注意，曲线并不是非常平滑；这并不是因为样条模型的原因，而是因为数据的原因。我们的测量是在离散的时间点（每小时）进行的。'
- en: '![PIC](img/file178.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file178.png)'
- en: '**Figure 6.8**: Posterior mean for the spline model'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.8**：样条模型的后验均值'
- en: When working with splines, one important decision we must make is determining
    the number and placement of knots. This can be a somewhat daunting task since
    the optimal number of knots and their spacing are not immediately apparent. A
    useful suggestion for determining the knot locations is to consider placing them
    based on quantiles rather than uniformly – something like `knots = np.quantile(bikes.hour,
    np.linspace(0, 1, num_knots))`. By doing so, we would position more knots in areas
    where we have a greater amount of data, while placing fewer knots in areas with
    less data. This results in a more adaptable approximation that effectively captures
    the variability in regions with a higher density of data points. Additionally,
    we may want to fit splines with varying numbers of knots and positions and then
    evaluate the results, using tools such as LOO, as we saw in *Chapter [5](CH05.xhtml#x1-950005)*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理样条时，我们必须做出一个重要的决策，那就是确定结点的数量和位置。这可能是一个相当令人头疼的任务，因为最佳的结点数量及其间距并不立刻显现出来。一个有用的建议是考虑基于分位数而非均匀分布来确定结点的位置——像这样
    `knots = np.quantile(bikes.hour, np.linspace(0, 1, num_knots))`。通过这样做，我们会在数据量较大的区域放置更多的结点，而在数据量较少的区域放置较少的结点。这样可以得到一个更具适应性的近似，从而有效地捕捉数据点密度较高区域的变化。此外，我们可能希望尝试使用不同数量和位置的结点来拟合样条，然后评估结果，使用诸如LOO等工具，就像我们在*第[5章](CH05.xhtml#x1-950005)*中看到的那样。
- en: 6.5 Distributional models
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 分布模型
- en: We saw earlier that we can use linear models for parameters other than the mean
    (or location parameter). For example, we can use a linear model for the mean and
    a linear model for the standard deviation of a Gaussian distribution. These models
    are usually called distributional models. The syntax for distributional models
    is very similar; we just need to add a line for the auxiliary parameters we want
    to model. For instance, *σ* for a Gaussian, or *α* for a NegativeBinomial.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，可以使用线性模型来表示均值（或位置参数）以外的其他参数。例如，我们可以为高斯分布的均值和标准差分别使用线性模型。这些模型通常被称为分布模型。分布模型的语法非常相似；我们只需要为我们想要建模的辅助参数添加一行。例如，高斯分布的*σ*，或负二项分布的*α*。
- en: 'Let’s now reproduce an example from *Chapter [4](CH04.xhtml#x1-760004)*, the
    babies example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重现*第[4章](CH04.xhtml#x1-760004)*中的一个例子——婴儿示例：
- en: '**Code 6.16**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.16**'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Figure [6.9](#x1-125011r9)* shows the posterior distribution values of sigma
    for `model_dis` (varying sigma) and for a model with constant sigma. We can see
    that when sigma is allowed to vary, we obtain values below and above the estimate
    for a constant sigma, meaning that we are both under- and over-estimating this
    parameter when we don’t allow it to change.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.9](#x1-125011r9)* 显示了 `model_dis`（变化的 sigma）和常数 sigma 模型的后验分布值。我们可以看到，当
    sigma 允许变化时，得到的值既低于也高于常数 sigma 的估计值，这意味着当我们不允许 sigma 改变时，我们会低估或高估这个参数。'
- en: '![PIC](img/file179.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file179.png)'
- en: '**Figure 6.9**: Constant and varying sigma for the babies data'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.9**：婴儿数据的常数与变化的 sigma'
- en: '*Figure [6.10](#x1-125012r10)* shows the posterior fit for `model_dis`. Notice
    that the model can capture the increase in variability as the babies grow. This
    figure is very similar to *Figure [4.13](CH04.xhtml#x1-88022r13)*.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.10](#x1-125012r10)* 显示了 `model_dis` 的后验拟合。注意，模型能够捕捉到婴儿成长过程中变化的变异性。这个图与*图
    [4.13](CH04.xhtml#x1-88022r13)*非常相似。'
- en: '![PIC](img/file180.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file180.png)'
- en: '**Figure 6.10**: Posterior fit for `model_dis`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.10**：`model_dis`的后验拟合'
- en: 'When working with PyMC, we saw that sampling from the posterior predictive
    distribution, at not observed values, requires us to define the ”Xs” as `Mutable
    data` and then update the variable before computing the posterior predictive distribution.
    With Bambi, this is not necessary. We can use the `predict` method to predict
    new values by passing the new values to the `data` argument. For example, let’s
    predict the length of a baby at 0.5 months (15 days):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PyMC时，我们看到从后验预测分布中进行采样时，需要定义“Xs”作为`可变数据`，然后在计算后验预测分布之前更新该变量。而在Bambi中，这不需要。我们可以使用`predict`方法，通过将新值传递给`data`参数来预测新值。例如，让我们预测一只小企鹅在0.5个月（15天）时的体长：
- en: '**Code 6.17**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.17**'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 6.6 Categorical predictors
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 类别预测变量
- en: 'A categorical variable represents distinct groups or categories that can take
    on a limited set of values from those categories. These values are typically labels
    or names that don’t possess numerical significance on their own. Some examples
    are:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类别变量表示不同的组或类别，这些类别只能从有限的集合中取值。通常，这些值是标签或名称，本身不具备数值意义。以下是一些例子：
- en: 'Political affiliation: conservative, liberal, or progressive.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 政治立场：保守派、自由派或进步派。
- en: 'Sex: female or male.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性别：女性或男性。
- en: 'Customer satisfaction level: very unsatisfied, unsatisfied, neutral, satisfied,
    or very satisfied.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户满意度：非常不满意、不满意、中立、满意或非常满意。
- en: Linear regression models can easily accommodate categorical variables; we just
    need to encode the categories as numbers. There are a few options to do so. Bambi
    can easily handle the details for us. The devil is in the interpretation of the
    results, as we will explore in the next two sections.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归模型可以轻松地处理类别变量；我们只需要将类别编码为数字。可以通过几种方式做到这一点，Bambi可以轻松地为我们处理这些细节。真正的难点在于结果的解释，我们将在接下来的两节中深入探讨。
- en: 6.6.1 Categorical penguins
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 类别企鹅
- en: For the current example, we are going to use the palmerpenguins dataset, [Horst
    et al.](Bibliography.xhtml#Xpenguins) [[2020](Bibliography.xhtml#Xpenguins)],
    which contains 344 observations of 8 variables. For the moment, we are interested
    in modeling the mass of the penguins as a function of the length of their bills.
    It is expected that the mass of the penguins increases as the bill length increases.
    The novelty of this example is that we are going to consider the categorical variable,
    `species`. In this dataset, we have 3 categories or levels for the species variable,
    namely, Adelie, Chinstrap, and Gentoo. *Figure [6.11](#x1-127002r11)* shows a
    scatter plot for the variables we want to model.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前的例子，我们将使用palmerpenguins数据集，[Horst等人](Bibliography.xhtml#Xpenguins)[[2020](Bibliography.xhtml#Xpenguins)]，该数据集包含344个观测值和8个变量。目前，我们关心的是将企鹅的体重建模为喙长的函数。预计随着喙长的增加，企鹅的体重也会增加。本例的新颖之处在于，我们将考虑类别变量`species`。在这个数据集中，物种变量有3个类别或级别，分别是Adelie、Chinstrap和Gentoo。*图
    [6.11](#x1-127002r11)* 显示了我们要建模的变量的散点图。
- en: '![PIC](img/file181.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file181.png)'
- en: '**Figure 6.11**: Bill length vs mass for 3 species of penguins'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.11**：3种企鹅的喙长与体重的关系'
- en: 'Let’s load the data and fit the model:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载数据并拟合模型：
- en: '**Code 6.18**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.18**'
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that there is no special syntax to define Bambi’s model for categorical
    variables. Bambi can detect and handle them automatically.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，定义Bambi模型中的类别变量时没有特殊的语法。Bambi可以自动检测并处理它们。
- en: '*Figure [6.12](#x1-127011r12)* show a forest plot for `model_p`. Notice something
    unexpected? There are no posterior values for Adelie. This is no mistake. By default,
    Bambi encodes categorical variables with N levels (3 species) as N-1 dummy variables
    (2 species). Thus the coefficients species-Chinstrap and species-Gentoo are modeled
    as deflections from the baseline model:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.12](#x1-127011r12)* 显示了`model_p`的森林图。注意到什么意外情况了吗？Adelie没有后验值。这不是错误。默认情况下，Bambi将具有N个级别（3个物种）的类别变量编码为N-1个虚拟变量（2个物种）。因此，物种-Chinstrap和物种-Gentoo的系数被建模为与基线模型的偏差：'
- en: '![mass = 𝛽0 + 𝛽1bill length ](img/file182.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![质量 = 𝛽0 + 𝛽1喙长](img/file182.jpg)'
- en: To make this more clear, let’s check a couple of plots. We can read *Figure
    [6.12](#x1-127011r12)* as saying that the body mass of Chinstrap is, on average,
    -0.89 relative to Adelie’s body mass. The same goes for Gentoo, but this time,
    we have to add 0.66 to the mean of the baseline model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这一点，我们来查看几个图表。我们可以通过*图 [6.12](#x1-127011r12)* 理解为，Chinstrap的体重平均比Adelie轻0.89。Gentoo也是如此，不过这次我们需要在基线模型的均值上加上0.66。
- en: '![PIC](img/file183.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file183.png)'
- en: '**Figure 6.12**: Forest plot from `model_p`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.12**: 来自 `model_p` 的森林图'
- en: You can check that these two statements are true by looking at *Figure [6.13](#x1-127012r13)*.
    See how the three lines are essentially parallel to each other with Adelie in
    the middle, Chinstrap below (-0.89), and Gentoo above (0.58).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看*图 [6.13](#x1-127012r13)* 来验证这两个陈述的真实性。注意中间是阿德利（Adelie），下方是拟企鹅（Chinstrap，-0.89），上方是根趾企鹅（Gentoo，0.58），它们的三条线基本平行。
- en: '![PIC](img/file184.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file184.png)'
- en: '**Figure 6.13**: Mean in-sample predictions from `model_p`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.13**: 来自 `model_p` 的平均样本预测'
- en: 6.6.2 Relation to hierarchical models
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 关于分层模型的关系
- en: In *Chapter [3](CH03.xhtml#x1-670003)*, we discussed and contrasted pooled and
    hierarchical (or partially pooled) models. There we showed that it is often the
    case that we take advantage of the structure or hierarchies in data. Following
    the logic of that chapter, you could argue that Adelie, Gentoo, and Chinstrap,
    while being different species, are all penguins. So modeling their body masses
    hierarchically may be a good idea. And you would be right to think so. So what
    is the difference between such a model and the one we used in this section?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 [3](CH03.xhtml#x1-670003)* 章中，我们讨论了并对比了汇集模型和分层（或部分汇集）模型。我们在那里展示了通常情况下，我们利用数据的结构或层次。遵循该章节的逻辑，你可以认为阿德利、根趾企鹅和拟企鹅虽然是不同的物种，但都是企鹅。因此，分层建模它们的体重可能是个好主意。你这样想是正确的。那么这种模型与我们在本节中使用的模型有什么区别呢？
- en: 'The distinguishing factor lies in the subtleties of the slope and intercept
    components. In the case of the latter, the slope remains the same across all three
    penguin species, while the intercepts can vary: `Intercept + 0` for Adelie, `Intercept
    + species[Chinstrap]` for Chinstrap, and `Intercept + species[Gentoo]` for Gentoo.
    Thus, this model highlights the distinct intercepts while keeping the slope uniform.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 区分因素在于斜率和截距的微妙组成部分。在后者的情况下，斜率在三种企鹅物种中保持不变，而截距可以变化：阿德利的`Intercept + 0`，拟企鹅的`Intercept
    + species[Chinstrap]`，根趾企鹅的`Intercept + species[Gentoo]`。因此，该模型突出了不同的截距，同时保持了统一的斜率。
- en: If instead we had built the hierarchical model `body_mass ~(bill_length|species)`,
    we would have been asking for a partially pooled slope and intercept. And if instead
    we had modeled `body_mass ~(0 + bill_length | species)`, we would have been asking
    for a partially pooled slope and a common intercept.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们建立了层次模型 `body_mass ~(bill_length|species)`，我们将请求部分汇集的斜率和截距。如果我们建立了模型 `body_mass
    ~(0 + bill_length | species)`，我们将请求部分汇集的斜率和公共截距。
- en: Besides these particular models, when thinking about using a predictor as a
    grouping variable or as a categorical predictor, it is usually useful to ask if
    the variable includes all possible categories (like all days of the week, all
    species, and so on) or only a subgroup (some schools, or a few musical genres).
    If we have all possible categories, then we may prefer to model it as a categorical
    predictor, otherwise, as a grouping variable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些特定的模型外，在考虑将预测变量作为分组变量或分类预测变量使用时，通常有必要问问该变量是否包括所有可能的类别（例如所有星期的所有天，所有物种等），还是仅包括子组（某些学校或少数音乐流派）。如果我们有所有可能的类别，那么我们可能更喜欢将其建模为分类预测变量，否则建模为分组变量。
- en: As we already discussed, we often create more than one model before deciding
    which one we like the most. The *best* model is the one that aligns with the goals
    of your analysis, provides meaningful insights, and accurately represents the
    underlying patterns in your data. It’s often a good idea to explore multiple models,
    compare their performance using appropriate criteria (such as those discussed
    in *Chapter [5](CH05.xhtml#x1-950005)*), and consider the practical implications
    of each model for your research or decision-making process.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，通常在决定哪一个模型最佳之前，我们会创建多个模型。*最佳*模型是与你分析目标一致、提供有意义的见解，并准确代表数据潜在模式的模型。探索多个模型，使用适当的标准（例如*第
    [5](CH05.xhtml#x1-950005)* 章中讨论的标准）比较它们的性能，并考虑每个模型对研究或决策过程的实际影响通常是个好主意。
- en: 6.7 Interactions
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 交互作用
- en: 'An interaction effect, or statistical interaction, happens when the effect
    of an independent variable on the response changes depending on the value of another
    independent variable. An interaction can occur between two or more variables.
    Some examples are:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '交互效应或统计交互效应发生在独立变量对响应的影响因另一个独立变量的值而变化时。交互作用可以发生在两个或多个变量之间。一些例子包括:'
- en: '**Education level and income impact**: Higher education may have a stronger
    positive effect on income for one gender compared to the other, resulting in an
    interaction between education and gender.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教育水平和收入的影响**：较高的教育水平可能对某一性别的收入产生更强的正向影响，从而形成教育和性别之间的交互作用。'
- en: '**Medication efficacy and age**: A drug that works better for older individuals
    than younger ones.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**药物疗效与年龄**：一种对年长者效果更好的药物，而对年轻人效果较差。'
- en: '**Exercise and diet effects on weight loss**: It could be that the diet’s effect
    on weight loss is small for people who do little or no exercise and large for
    people who do moderate exercise.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动和饮食对减重的影响**：对于做很少或不做运动的人来说，饮食对减重的影响可能较小；而对于做中等强度运动的人来说，饮食对减重的影响可能较大。'
- en: '**Temperature and humidity for crop growth**: Some crops could thrive in hot
    and humid conditions, while others might perform better in cooler and less humid
    environments.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作物生长的温度和湿度**：一些作物可能在高温高湿的环境中茁壮成长，而其他作物则可能在较凉爽、湿度较低的环境中表现更好。'
- en: 'We have an interaction when the combined effect of two or more variables acting
    together is not equal to the sum of their individual effects. So we cannot model
    an interaction if we have a model like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多变量的联合效应不等于它们单独效应的总和时，我们就有了交互作用。因此，如果我们有如下模型，我们就无法建模交互作用：
- en: '![μ = 𝛼 + 𝛽0X0 + 𝛽1X1 ](img/file185.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![μ = 𝛼 + 𝛽0X0 + 𝛽1X1 ](img/file185.jpg)'
- en: 'The most common way to model an interaction effect is by multiplying two (or
    more) variables. Take, for example, a model like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 建模交互作用效应的最常见方法是将两个（或更多）变量相乘。例如，考虑以下这样的模型：
- en: '![ main terms ◜----◞◟----◝ μ = 𝛼 + 𝛽0X0 + 𝛽1X1 + 𝛽◟2X0◝X◜1◞ interaction term
    ](img/file186.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![ 主要术语 ◜----◞◟----◝ μ = 𝛼 + 𝛽0X0 + 𝛽1X1 + 𝛽◟2X0◝X◜1◞ 交互作用项 ](img/file186.jpg)'
- en: It is common when modeling interaction effects to also include the main effect/terms.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模交互作用效应时，通常还会包括主效应/项。
- en: New predictors
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 新的预测因子
- en: Multiplying two variables can be seen as a trick, similar to the one we use
    for polynomial regression (or any transformation of a given variable). Instead
    of multiplying a predictor with itself, we multiply two different predictors and
    obtain a new one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个变量相乘可以看作是一种技巧，类似于我们在多项式回归（或对给定变量的任何变换）中使用的方法。我们不是将一个预测因子与自身相乘，而是将两个不同的预测因子相乘，得到一个新的预测因子。
- en: 'Defining an interaction between two variables is easy for a PyMC model; we
    just need to multiply the two predictors together and also add a coefficient.
    For a Bambi model, it is even easier; we use the `:` operator. To make the difference
    crystal clear, let’s look at an example of a model with and without interactions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyMC 模型中定义两个变量之间的交互作用非常简单；我们只需要将这两个预测因子相乘，并添加一个系数。对于 Bambi 模型来说，更加简单；我们使用
    `:` 运算符。为了让区别更加清晰，让我们看看一个有交互作用和没有交互作用的模型示例：
- en: '**Code 6.19**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.19**'
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now use Bambi’s `plot_prediction` to compare how different values of `bill_length`
    affect `body_mass` as a function of `bill_depth` generate. *Figure [6.14](#x1-129015r14)*
    shows the result. We have the mean regression fit for `bill_depth` evaluated at
    5 fixed values of `bill_length`. On the left, we have the result for `model_noint`
    (no interactions), and on the right, for `model_int` (with interactions). We can
    see that when we don’t have interactions, the fitted lines for `bill_depth` are
    parallel at different levels of `bill_length`. Instead, when we have interactions,
    the lines are no longer parallel, precisely because the effect of changing `bill_depth`
    on how much `body_mass` changes is no longer constant but modulated by the values
    of `bill_length`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用 Bambi 的 `plot_prediction` 来比较不同 `bill_length` 值如何作为 `bill_depth` 的函数影响
    `body_mass`。*图 [6.14](#x1-129015r14)* 显示了结果。我们为 `bill_depth` 在 5 个固定的 `bill_length`
    值下计算了平均回归拟合。左侧是 `model_noint`（无交互作用）结果，右侧是 `model_int`（有交互作用）结果。我们可以看到，当没有交互作用时，`bill_depth`
    的拟合曲线在不同的 `bill_length` 水平上是平行的。相反，当存在交互作用时，这些曲线不再平行，正因为 `bill_depth` 的变化对 `body_mass`
    变化的影响不再是常数，而是受到 `bill_length` 值的调节。
- en: '![PIC](img/file187.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file187.png)'
- en: '**Figure 6.14**: Mean in-sample predictions from `model_noint` (left) and `model_int`
    (right)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.14**：`model_noint`（左）和 `model_int`（右）的样本内平均预测'
- en: If you generate a figure like *Figure [6.14](#x1-129015r14)*, but instead of
    fixing `bill_length`, you decide to fix `bill_depth`, you will observe a similar
    behavior.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你生成了像*图 [6.14](#x1-129015r14)* 这样的图，但不是固定 `bill_length`，而是决定固定 `bill_depth`，你将观察到类似的行为。
- en: In the GitHub repository for this book ( [https://github.com/aloctavodia/BAP3](https://github.com/aloctavodia/BAP3)),
    you are going to find the file `interactions.ipynb`. This script generates a figure
    in 3D, which I hope will help you build intuition about what we are doing when
    adding interactions. If you run it, you will see that when there are no interactions,
    we are fitting a 2D plane, a flat surface like a sheet of paper. But when adding
    interactions, you are fitting a curved surface. Compare the result of `interactions.ipynb`
    with *Figure [6.14](#x1-129015r14)*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的GitHub仓库中（[https://github.com/aloctavodia/BAP3](https://github.com/aloctavodia/BAP3)），你将找到文件
    `interactions.ipynb`。这个脚本生成一个3D图形，我希望它能帮助你建立关于添加交互项时我们所做工作的直觉。如果你运行它，你会看到，当没有交互项时，我们拟合的是一个2D平面，一张像纸一样的平坦表面。但是，当添加交互项时，你会拟合一个弯曲的表面。将
    `interactions.ipynb` 的结果与 *图 [6.14](#x1-129015r14)* 进行比较。
- en: We have just seen visually that interpreting linear models with interactions
    is not as easy as interpreting linear models without them. Let’s see this mathematically.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过可视化看到，解释包含交互项的线性模型并不像解释没有交互项的线性模型那样简单。让我们从数学上来看一下。
- en: 'Let’s assume we have a model with 2 variables, *X*[0] and *X*[1], and an interaction
    between them:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含2个变量 *X*[0] 和 *X*[1] 以及它们之间的交互作用的模型：
- en: '![μ = 𝛼 + 𝛽0X0 + 𝛽1X1 + 𝛽2X0X1 ](img/file188.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![μ = 𝛼 + 𝛽0X0 + 𝛽1X1 + 𝛽2X0X1 ](img/file188.jpg)'
- en: 'We can rewrite this model as:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个模型重写为：
- en: '![μ = 𝛼+ (◟𝛽0-+◝𝛽◜2X1-)◞X0 + 𝛽1X1 slope of X0 ](img/file189.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![μ = 𝛼+ (◟𝛽0-+◝𝛽◜2X1-)◞X0 + 𝛽1X1 X0的斜率](img/file189.jpg)'
- en: 'Or even like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至像这样：
- en: '![μ = 𝛼+ 𝛽0X0 + (◟𝛽1 +◝𝛽◜2X0-)◞X1 slope of X1 ](img/file190.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![μ = 𝛼+ 𝛽0X0 + (◟𝛽1 +◝𝛽◜2X0-)◞X1 X1的斜率](img/file190.jpg)'
- en: 'From this expression, we can see that:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个表达式中，我们可以看到：
- en: The interaction term can be understood as a linear model inside a linear model.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互项可以理解为线性模型中的线性模型。
- en: The interaction is symmetric; we can think of it as the slope of *X*[0] as a
    function of *X*[1] and at the same time as the slope of *X*[1] as a function of
    *X*[0]. This can also be seen from the interactive figure.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互作用是对称的；我们可以将其理解为 *X*[0] 作为 *X*[1] 的函数的斜率，同时也是 *X*[1] 作为 *X*[0] 的函数的斜率。这也可以从交互式图形中看到。
- en: We know from before that the *β*[0] coefficient can be interpreted as the amount
    of change of *μ* per unit change of *X*[0] (that is why we call it the slope).
    If we add an interaction term, then this is only true at *X*[1] = 0\. Try using
    the interactive figure to see this by yourself. Mathematically, this is true because
    when *X*[1] = 0, then *β*[2]*X*[1] = 0, and thus the slope of *X*[0] reduces to
    *β*[0]*X*[0]. By symmetry, the same reasoning can be applied to *β*[1].
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们之前知道，*β*[0] 系数可以解释为 *μ* 对 *X*[0] 单位变化的响应量（这就是我们称之为斜率的原因）。如果我们添加一个交互项，那么只有当
    *X*[1] = 0 时，这个关系才成立。试着使用交互式图形自己看看。数学上，这是真的，因为当 *X*[1] = 0 时，*β*[2]*X*[1] = 0，因此
    *X*[0] 的斜率简化为 *β*[0]*X*[0]。通过对称性，同样的推理可以应用于 *β*[1]。
- en: 6.8 Interpreting models with Bambi
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 使用Bambi解释模型
- en: We have been using `bmb.interpret_plot_predictions` a lot in this chapter. But
    that’s not the only tool that Bambi offers us to help us understand models. One
    of them is `bmb.interpret_plot_comparisons`. This tool helps us answer the question,
    ”What is the expected predictive difference when we compare two values of a given
    variable while keeping all the rest at constant values?”.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经多次使用了 `bmb.interpret_plot_predictions`。但这并不是 Bambi 提供的唯一帮助我们理解模型的工具。另一个工具是
    `bmb.interpret_plot_comparisons`。这个工具帮助我们回答这样的问题：“当我们比较某个变量的两个值时，保持其他所有值不变，预测差异是什么？”
- en: 'Let’s use `model_int` from the previous section, so we don’t need to fit a
    new model. We use the following code block to generate *Figure [6.15](#x1-130007r15)*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上一节的 `model_int`，因此无需重新拟合模型。我们使用以下代码块生成 *图 [6.15](#x1-130007r15)*：
- en: '**Code 6.20**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.20**'
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Figure [6.15](#x1-130007r15)* shows that when comparing a hypothetical penguin
    with `bill_depth` of 1.8 against one with `bill_depth` of 1.4, the expected difference
    is:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.15](#x1-130007r15)* 显示了当将假设的企鹅的 `bill_depth` 从 1.8 比较到 1.4 时，期望的差异是：'
- en: Approx 0.8 kg for a bill length of 3.5 cm
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约 0.8 千克，当喙长为 3.5 厘米时
- en: -0.6 kg for a bill length of 4.5 cm
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -0.6 千克，当喙长为 4.5 厘米时
- en: Approx -2 kg for a bill length of 5.5 cm
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大约 -2 千克，当喙长为 5.5 厘米时
- en: '![PIC](img/file191.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file191.png)'
- en: '**Figure 6.15**: Contrast of `bill_depth` from 1.8 to 1.4 cm for 3 fixed values
    of `bill_length`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.15**：在 3 个固定的 `bill_length` 值下，将 `bill_depth` 从 1.8 厘米对比到 1.4 厘米'
- en: If you want the information in tabular form, use the function `bmb.interpret.comparisons`
    and you will get a DataFrame instead of a plot.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望以表格形式查看信息，可以使用函数`bmb.interpret.comparisons`，这样你将得到一个DataFrame而不是图表。
- en: 'Another useful function is `bmb.interpret_plot_slopes`, which can be used to
    compute the ”instant rate of change” or slope at a given value. We use the following
    code block to generate *Figure [6.16](#x1-130014r16)*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的函数是`bmb.interpret_plot_slopes`，它可用于计算给定值下的“瞬时变化率”或斜率。我们使用以下代码块生成*图 [6.16](#x1-130014r16)*：
- en: '**Code 6.21**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.21**'
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Figure [6.16](#x1-130014r16)* shows that the slopes at a `bill_depth` of 1.8
    are:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 [6.16](#x1-130014r16)* 显示了`bill_depth`为1.8时的斜率：'
- en: ≈ 2 kg/cm for a bill length of 3.5 cm
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ≈ 2 kg/cm，适用于鸟嘴长度为3.5 cm时
- en: -1.4 kg/cm for a bill length of 4.5 cm
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -1.4 kg/cm，适用于鸟嘴长度为4.5 cm时
- en: ≈ -5 kg/cm for a bill length of 5.5 cm
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ≈ -5 kg/cm，适用于鸟嘴长度为5.5 cm时
- en: '![PIC](img/file192.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file192.png)'
- en: '**Figure 6.16**: Slopes of `bill_depth` at 1.8 cm for 3 fixed values of `bill_length`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.16**：对于`bill_length`的三个固定值，`bill_depth`在1.8 cm时的斜率'
- en: If you want the information in tabular form, use the function `bmb.interpret.slopes`
    and you will get a DataFrame instead of a plot.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望以表格形式查看信息，可以使用函数`bmb.interpret.slopes`，这样你将得到一个DataFrame而不是图表。
- en: In this section, we have just scratched the surface of what we can do with the
    tools in the `bmb.interpret` module. This module is a very useful feature of Bambi,
    especially for models with interactions and/or models with link functions other
    than the identity function. I highly recommend you read the Bambi documentation
    for more examples and details not covered here.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们仅仅触及了`bmb.interpret`模块工具的表面。这个模块是Bambi的一个非常有用的功能，尤其适用于含有交互作用和/或具有除恒等函数之外链接函数的模型。我强烈建议你阅读Bambi文档，获取更多未在此介绍的示例和细节。
- en: 6.9 Variable selection
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 变量选择
- en: Variable selection refers to the process of identifying the most relevant variables
    in a model from a larger set of potential predictors. We perform variable selection
    under the assumption that only a subset of variables have a considerable impact
    on the outcome of interest, while others contribute little or no additional value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 变量选择是指从一组潜在预测变量中识别出对模型结果最相关的变量的过程。我们进行变量选择时假设，只有一部分变量对感兴趣的结果有显著影响，而其他变量几乎没有或没有额外的价值。
- en: Arguably the ”most Bayesian thing to do” when building a model is to include
    all the variables that we may think of in a single model and then use the posterior
    from that model to make predictions or gain an understanding of the relationships
    of the variables. This is the ”most Bayesian” approach because we are using as
    much data as possible and incorporating in the posterior the uncertainty about
    the importance of the variables. However, being *more Bayesian than Bayes* is
    not always the best idea. We already saw in *Chapter [5](CH05.xhtml#x1-950005)*
    that Bayes factors can be problematic, even when they are a direct consequence
    of Bayes’ theorem.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模型时，最“贝叶斯”的做法可能是将我们可能想到的所有变量都包含在一个模型中，然后利用该模型的后验分布进行预测或了解变量之间的关系。这是最“贝叶斯”的方法，因为我们尽可能地使用数据，并在后验中纳入变量重要性的未知性。然而，比贝叶斯更“贝叶斯”并不总是最佳选择。我们在*第[5章](CH05.xhtml#x1-950005)*中已经看到，即使贝叶斯因子是贝叶斯定理的直接结果，它们也可能存在问题。
- en: 'Performing variable selection is a good idea when:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下情况出现时，执行变量选择是一个好主意：
- en: We need to reduce the measurement cost. For instance, in medicine, we may have
    the money and resources to run a pilot study and measure 30 variables for 200
    patients. But we cannot do the same for thousands. Or we may be able to place
    a lot of sensors in an open field to better model crop gains, but we cannot extend
    that to the size of a country. Reducing costs is not always about money or time;
    when working with humans or other animals, reducing pain and discomfort is important
    too. For example, we may want to predict the risk of a patient having a heart
    attack. We can do this by measuring a lot of variables, but we can also do it
    by measuring just a few variables that are less invasive.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要降低测量成本。例如，在医学中，我们可能有资金和资源进行一项试点研究，测量200名患者的30个变量。但是我们无法对数千人做同样的事情。或者，我们可能能在开阔地带放置大量传感器来更好地建模作物收益，但我们无法将其扩展到一个国家的规模。降低成本并不总是意味着金钱或时间；在与人类或其他动物工作时，减少疼痛和不适也很重要。例如，我们可能想预测患者发生心脏病发作的风险。我们可以通过测量很多变量来做到这一点，但我们也可以通过测量少量更不具侵入性的变量来实现。
- en: We want to reduce the computational cost. This is not a problem for small and
    simple models, but when we have a lot of variables, a lot of data, or both, the
    computational cost can be prohibitive.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望减少计算成本。这对于小型和简单模型来说不是问题，但当我们有大量变量、大量数据或两者兼有时，计算成本可能会变得无法承受。
- en: 'We seek a better understanding of significant correlation structures. That
    is, we are interested in understanding which variables provide better predictions.
    It is important to state that we are not talking about causality. While statistical
    models, in particular, GLMS, can be used to infer causality, doing so requires
    extra steps and assumptions. In this book, we do not discuss how to perform causal
    inference. For a very gentle introduction to causal inference, please see this
    video: [https://www.youtube.com/watch?v=gV6wzTk3o1U](https://www.youtube.com/watch?v=gV6wzTk3o1U).
    If you are more serious, you can check out the online book Causal Inference: The
    Mixtape by Scott Cunningham [[Cunningham](Bibliography.xhtml#Xcunningham2021causal), [2021](Bibliography.xhtml#Xcunningham2021causal)]
    [https://mixtape.scunning.com/](https://mixtape.scunning.com/).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们寻求更好地理解重要的关联结构。也就是说，我们有兴趣理解哪些变量提供更好的预测。需要明确的是，我们不是在讨论因果关系。虽然统计模型，尤其是广义线性模型（GLMS），可以用来推断因果关系，但这需要额外的步骤和假设。在本书中，我们不讨论如何进行因果推断。如果你想要一个非常基础的因果推断介绍，请参见这个视频：[https://www.youtube.com/watch?v=gV6wzTk3o1U](https://www.youtube.com/watch?v=gV6wzTk3o1U)。如果你更加严肃，您可以查阅Scott
    Cunningham的在线书籍《因果推断：混音带》[[Cunningham](Bibliography.xhtml#Xcunningham2021causal)，[2021](Bibliography.xhtml#Xcunningham2021causal)]
    [https://mixtape.scunning.com/](https://mixtape.scunning.com/)。
- en: When we desire a model that is more resilient to changes in the data-generating
    distribution, we can see variable selection as a method to make the model more
    robust against unrepresentative data.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们希望获得一个对数据生成分布变化更具韧性的模型时，我们可以将变量选择视为一种使模型对不具代表性数据更加稳健的方法。
- en: 6.9.1 Projection predictive inference
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.1 投影预测推断
- en: There are many methods to perform variable selection. In this section, we will
    focus on one of them called projection predictive inference [[Piironen et al.](Bibliography.xhtml#XPiironen2020), [2020](Bibliography.xhtml#XPiironen2020), [McLatchie
    et al.](Bibliography.xhtml#Xmclatchie2023), [2023](Bibliography.xhtml#Xmclatchie2023)].
    The main reason we are focusing on this single method is that it has shown very
    good performance across a broad range of fields.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以执行变量选择。在本节中，我们将重点介绍其中一种叫做投影预测推断的方法[[Piironen等人](Bibliography.xhtml#XPiironen2020)，[2020](Bibliography.xhtml#XPiironen2020)，[McLatchie等人](Bibliography.xhtml#Xmclatchie2023)，[2023](Bibliography.xhtml#Xmclatchie2023)]。我们专注于这种方法的主要原因是，它在广泛的领域中表现出了非常好的性能。
- en: 'The main steps of projective prediction inference are:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 投影预测推断的主要步骤如下：
- en: Generate a reference model, i.e., a model with all the variables you think can
    be relevant and/or you were able to measure.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个参考模型，即包含所有你认为可能相关和/或你能够测量的变量的模型。
- en: Generate a set of submodels, i.e., models that only include some subset of the
    variables in the reference model.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一组子模型，即仅包含参考模型中某些子集变量的模型。
- en: Project the reference model’s posterior distribution into the submodels.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参考模型的后验分布投影到子模型中。
- en: Pick the smallest model that makes predictions close enough to the reference
    model.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个预测结果与参考模型足够接近的最小模型。
- en: When doing projection predictive inference, we only need to perform Bayesian
    inference once, just for the reference model. For the submodels, the posteriors
    are projected. Without going into the technical details, the projection consists
    of finding the parameters for the submodels in such a way that the predictions
    of the submodels are as close as possible to the predictions of the reference
    model. The projection can be done in a computationally efficient way so the cost
    of estimating a posterior is orders of magnitude cheaper than with MCMC methods.
    This is relevant because the total number of possible submodels explodes as we
    increase the number of variables in the reference model. Consider that we need
    to evaluate all possible combinations, without repeating variables. For instance,
    say we have four variables (*A*, *B*, *C*, and *D*) and we need to evaluate 7
    models, namely, *A*, *B*, *C*, *AB*, *BC*, *AC*, and the reference model *ABC*.
    Seven does not sound like a lot, but by the time we reach 8 variables, we will
    need to evaluate 92 different models. See, we double the number of variables,
    and the number of models increases more than 10 times!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行投影预测推断时，我们只需要执行一次贝叶斯推断，仅针对参考模型。对于子模型，后验分布是通过投影得到的。不深入讨论技术细节，投影过程是通过某种方式找到子模型的参数，使得子模型的预测尽可能接近参考模型的预测。这个投影过程可以以计算效率高的方式进行，因此估计后验分布的成本比使用MCMC方法低几个数量级。这一点很重要，因为当我们增加参考模型中的变量数时，可能的子模型总数会呈指数增长。考虑一下我们需要评估所有可能的组合，不重复变量。例如，假设我们有四个变量（*A*，*B*，*C*
    和 *D*），需要评估7个模型，分别是 *A*，*B*，*C*，*AB*，*BC*，*AC* 和参考模型 *ABC*。七个模型听起来不多，但当我们增加到8个变量时，我们将需要评估92个不同的模型。看到没有，我们将变量数翻倍，模型的数量却增加了10倍以上！
- en: Of course, there are ways to reduce the total number of submodels to explore.
    For instance, we could use some cheap method to filter out the most promising
    variables and only do projection predictive inference on those. Another alternative
    is known as forward search; that is, we first fit as many models as the variables
    we have. We then select one model/variable, the one generating the closest predictions
    to the reference model. We then generate all the submodels with 2 variables that
    included the variable selected in the previous step and so on. If we do this forward
    procedure for a reference model with 8 variables instead of 92 different models,
    we will need to evaluate just 36.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，减少需要探索的子模型总数是有办法的。例如，我们可以使用某些廉价方法筛选出最有前景的变量，然后只对这些变量进行投影预测推断。另一个替代方案被称为前向搜索；也就是说，我们首先拟合与我们所拥有的变量数量相等的模型。然后选择一个模型/变量，即生成与参考模型的预测最接近的那个模型。接着，我们生成所有包含上一阶段选择变量的两个变量子模型，依此类推。如果我们对一个包含8个变量的参考模型进行这种前向程序，而不是92个不同的模型，我们只需要评估36个模型。
- en: Another aspect that is relevant to consider when doing projection predictive
    inference is that we only provided priors for the reference model. The submodels
    don’t have explicit priors; they just inherit, somehow, the priors of the reference
    model through the projection procedure.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在进行投影预测推断时需要考虑的因素是，我们只为参考模型提供了先验分布。子模型没有明确的先验分布；它们只是通过投影过程继承了参考模型的先验分布。
- en: One reason projective prediction works in practice is thanks to the use of a
    reference model. By fitting the submodels to the in-sample predictions made by
    the reference model, instead of the observed data, we are filtering out the noise
    in the data. This helps separate the more relevant variables from the less relevant
    ones. Another factor is the use of cross-validation in selecting the submodels,
    as discussed in *Chapter [5](CH05.xhtml#x1-950005)*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 投影预测在实践中有效的原因之一，正是得益于参考模型的使用。通过将子模型拟合到参考模型在样本中的预测，而不是拟合观察到的数据，我们能够过滤掉数据中的噪声。这有助于将更相关的变量与不太相关的变量区分开。另一个因素是，在选择子模型时使用了交叉验证，如在*第[5](CH05.xhtml#x1-950005)章*中所讨论的那样。
- en: 6.9.2 Projection predictive with Kulprit
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9.2 使用Kulprit进行投影预测
- en: Kulprit is a Python package for projection predictive inference. It works with
    Bambi, as we can pass a reference model built with it and Kulprit will do all
    the hard work for us. To illustrate how to use Kulprit, we are going to use the
    body fat dataset [[Penrose et al.](Bibliography.xhtml#Xpenrose1985), [1985](Bibliography.xhtml#Xpenrose1985)].
    This dataset has measurements from 251 individuals, including their age, weight,
    height, the circumference of the abdomen, etc. Our purpose is to predict the percentage
    of body fat (as estimated by the `siri` variable). Since obtaining accurate measurements
    of body fat is expensive and potentially annoying for patients, we want to reduce
    the measurements while keeping a good predictive accuracy for `siri`. The original
    dataset included 13 variables; to keep this example really simple, I have preselected
    6.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Kulprit 是一个用于投影预测推断的 Python 包。它与 Bambi 配合使用，我们可以传递一个用 Bambi 构建的参考模型，Kulprit
    会为我们完成所有复杂的工作。为了说明如何使用 Kulprit，我们将使用体脂数据集 [[Penrose et al.](Bibliography.xhtml#Xpenrose1985),
    [1985](Bibliography.xhtml#Xpenrose1985)]。这个数据集包含了251个个体的测量数据，包括他们的年龄、体重、身高、腹围等。我们的目的是预测体脂百分比（通过
    `siri` 变量估算）。由于获得准确的体脂测量既昂贵又可能对患者造成困扰，我们希望在减少测量数量的同时保持 `siri` 的良好预测准确性。原始数据集包含13个变量；为了简化示例，我已经预先选择了6个变量。
- en: 'The first thing we need to do is to define and fit a Bambi model, as usual.
    We have to be sure that we include the argument `idata_kwargs=’log_likelihood’:True`.
    Internally, Kulprit computes the ELPD, and as we discussed in *Chapter [5](CH05.xhtml#x1-950005)*,
    we need the log likelihood in the InferenceData object to be able to estimate
    the ELPD:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要像往常一样定义并拟合一个 Bambi 模型。我们必须确保包含参数 `idata_kwargs=’log_likelihood’:True`。Kulprit
    内部会计算 ELPD，正如我们在 *第 [5](CH05.xhtml#x1-950005) 章* 中讨论的那样，我们需要在 InferenceData 对象中包含对数似然值，以便能够估算
    ELPD：
- en: '**Code 6.22**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.22**'
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After this, we are ready to use Kulprit. First, we need to call the `ProjectionPredictive`
    class and pass the Bambi model and the idata resulting from the fit of that model.
    Then we ask Kulprit to perform a search; by default, it will do a forward search:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们就可以开始使用 Kulprit 了。首先，我们需要调用 `ProjectionPredictive` 类，并传入 Bambi 模型和从该模型拟合得到的
    idata。然后我们让 Kulprit 执行搜索；默认情况下，它会进行前向搜索：
- en: 'Code 6.23:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 6.23：
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the search has finished, we can ask Kulprit to compare the submodels in
    terms of the ELPD. The submodels will show ordered from lowest ELPD to highest,
    as in *Figure [6.17](#x1-133012r17)*. On the x-axis, we have the submodel size,
    i.e., number of variables; we start at zero because we include the intercept-only
    model. The dashed gray line corresponds to the ELPD for the reference model.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索完成后，我们可以让 Kulprit 根据 ELPD 比较各个子模型。子模型会按 ELPD 从低到高排序，如 *图 [6.17](#x1-133012r17)*
    所示。在 x 轴上，我们有子模型的大小，即变量的数量；我们从零开始，因为我们包含了仅有截距的模型。虚线灰色线表示参考模型的 ELPD。
- en: '![PIC](img/file193.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file193.png)'
- en: '**Figure 6.17**: Comparison of the submodels obtained with Kulprit. Generated
    with `ppi.plot_compare`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.17**：使用 Kulprit 得到的子模型比较。由 `ppi.plot_compare` 生成。'
- en: 'We can see then that a submodel of size 3 is practically equivalent to the
    reference model. But what variables are exactly included in this and the other
    submodels? If we print the `ppi` object, after performing a search, we will get
    an ordered list of the formulas for the submodels matching the order in the plot
    obtained with the command `ppi.plot_compare`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以看到，大小为 3 的子模型几乎与参考模型等效。但具体包含了哪些变量呢？如果我们在执行搜索后打印 `ppi` 对象，我们将得到一个子模型公式的有序列表，列表顺序与通过命令
    `ppi.plot_compare` 得到的图中的顺序相匹配：
- en: '**Code 6.24**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.24**'
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then we can see that the model of size 3 is the one including the variables
    `abdomen`, `wrist`, and `height`. This result tells us that if we want to choose
    a model with fewer variables than the reference model but with similar predictive
    accuracy, then this is a good choice. Depending on the context, other submodels
    may also be a good idea. For instance, we may argue that the difference between
    the submodel of sizes 2 and 3 is rather small. Thus, we may be willing to sacrifice
    some accuracy in favor of an even smaller model. For this example, measuring the
    height of patients may not be that problematic, but for other scenarios, adding
    a third variable could be expensive, annoying, dangerous, etc.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以看到，大小为 3 的模型是包含变量 `abdomen`（腹部）、`wrist`（手腕）和 `height`（身高）的模型。这个结果告诉我们，如果我们想选择一个比参考模型更少变量的模型，但预测精度相似，那么这是一个不错的选择。根据不同的情境，其他子模型也可能是一个好选择。例如，我们可能会认为大小为
    2 和 3 的子模型之间的差异非常小。因此，我们可能愿意牺牲一些精度来选择一个更小的模型。对于这个例子来说，测量患者身高可能不会带来太大问题，但在其他场景下，添加第三个变量可能会很昂贵、麻烦、危险等等。
- en: Another way to interpret *Figure [6.17](#x1-133012r17)* is by noticing how close
    the ELPDs are for models with size 3 or larger. It may be the case that if we
    repeat the analysis with a slightly different dataset, or even the same dataset
    but with more posterior samples, we could get a slightly different order. Thus,
    if we have many models of size 3 with potentially the same practical predictive
    accuracy, we could justify the selection of the third variable by external factors
    such as how easy or cheap it is to measure, or which one will be less painful
    for patients, etc. In summary, as with other statistical tools, results should
    not be taken blindly but in context; you should have the final word and the tools
    should help you inform your decisions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解释 *图 [6.17](#x1-133012r17)* 的方式是注意到大小为 3 或更大的模型的 ELPD 值是非常接近的。可能的情况是，如果我们使用稍微不同的数据集，甚至是相同的数据集，但增加更多的后验样本，我们可能会得到一个略有不同的顺序。因此，如果我们有许多大小为
    3 的模型，它们可能具有相同的实际预测精度，我们可以通过外部因素来为选择第三个变量提供理由，比如它的测量是否容易或便宜，或者哪个对患者来说更不痛苦等等。总之，和其他统计工具一样，结果不应盲目接受，而是要结合上下文来解读；你应该有最终的决定权，工具应帮助你做出决策。
- en: 'OK, let’s say that we are indeed interested in the submodel of size 3 computed
    by Kulprit; we can get it with:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，假设我们确实对 Kulprit 计算的大小为 3 的子模型感兴趣；我们可以通过以下方式获取它：
- en: '**Code 6.25**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码 6.25**'
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the `submodel` object, we can then retrieve some useful information like
    Bambi’s model `submodel.model` or the InferenceData object `submodel.idata`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `submodel` 对象中，我们可以检索一些有用的信息，比如 Bambi 的模型 `submodel.model` 或 InferenceData
    对象 `submodel.idata`。
- en: One word of caution about interpreting these two objects—`submodel.model` is
    a Bambi model generated from a formula. Thus, its priors will be those automatically
    computed by Bambi. But, the posterior that Kulprit computes, which is stored in
    `submodel.idata.posterior`, does not come directly from this model. Instead, it
    is computed using projection predictive inference (not MCMC) with priors that
    are implicitly inherited during the projection step (not explicit priors). *Figure
    [6.18](#x1-133019r18)* shows such a projected posterior.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解释这两个对象，有一点需要注意——`submodel.model` 是一个由公式生成的 Bambi 模型。因此，它的先验将是 Bambi 自动计算的那些。但
    Kulprit 计算的后验，存储在 `submodel.idata.posterior` 中，并非直接来自该模型。相反，它是使用投影预测推理（而非 MCMC）计算的，先验是在投影步骤中隐式继承的（而非显式先验）。*图
    [6.18](#x1-133019r18)* 展示了这种投影后的后验。
- en: '![PIC](img/file194.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file194.png)'
- en: '**Figure 6.18**: Projected posterior for submodel of size 3'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.18**：大小为 3 的子模型的投影后验'
- en: 'Can we trust projected posteriors? Under very general conditions this should
    be a valid posterior so we can trust it. It should be enough to give you an approximate
    idea of the values of the parameters and, of course, it is enough for variable
    selection. The lack of explicit priors could make the interpretation of the model
    more difficult, but if you only care about predictions, that should not be an
    issue. Of course, you can always use Bambi (or PyMC) to explicitly compute the
    full posterior as usual and specify the priors yourself if needed. *Figure [6.19](#x1-133020r19)*
    shows a forest plot for the posterior of the submodel as computed with Bambi (True)
    and approximated with Kulprit (Projected). Notice that there are two possible
    sources of differences here: the intrinsic differences between MCMC and projection
    predictive methods and the different priors for both models.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以信任预测的后验分布吗？在非常一般的条件下，这应该是一个有效的后验分布，因此我们可以信任它。它应该足够提供参数值的大致概念，当然，这对于变量选择也是足够的。缺乏显式的先验可能会使模型的解释更加困难，但如果你只关心预测，这应该不是问题。当然，你始终可以使用Bambi（或PyMC）像往常一样显式地计算完整的后验，并在需要时自己指定先验。*图
    [6.19](#x1-133020r19)* 显示了通过Bambi（真实）计算的子模型后验的森林图和通过Kulprit（预测）近似的子模型后验。请注意，这里有两个可能的差异来源：MCMC方法与投影预测方法之间的内在差异，以及两个模型的不同先验。
- en: '![PIC](img/file195.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file195.png)'
- en: '**Figure 6.19**: Comparison of the posterior of the submodel (`siri ~abdomen
    + wrist + height`) as computed by Kulprit and the reference model as computed
    by Bambi; variables not shared by both models have been omitted'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 6.19**：通过Kulprit计算的子模型（`siri ~abdomen + wrist + height`）后验与通过Bambi计算的参考模型后验的比较；未在两个模型中共享的变量已被省略'
- en: Kulprit is a very new library that will keep evolving, and users can expect
    numerous enhancements and refinements shortly. If Kulprit interests you, you can
    help with its development by reporting issues, suggesting ideas, improving the
    documentation, or working on its codebase at [https://github.com/bambinos/kulprit](https://github.com/bambinos/kulprit).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Kulprit是一个非常新的库，将不断发展，用户可以期待不久后会有大量的增强和改进。如果Kulprit引起了你的兴趣，你可以通过报告问题、提出建议、改进文档或参与其代码库的开发来帮助其发展，网址是[https://github.com/bambinos/kulprit](https://github.com/bambinos/kulprit)。
- en: 6.10 Summary
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10 小结
- en: In this chapter, we have seen how to use Bambi to fit Bayesian models as an
    alternative to the pure PyMC model. We start with the simplest case, a model with
    a single predictor, and then move to more complex models, including polynomials,
    splines, distributional models, models with categorical predictors, and interactions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到如何使用Bambi拟合贝叶斯模型，作为纯PyMC模型的替代方案。我们从最简单的情况开始，一个包含单一预测变量的模型，然后过渡到更复杂的模型，包括多项式、样条、分布模型、包含分类预测变量的模型以及交互作用模型。
- en: The main advantage of Bambi is that it is very easy to use; it is very similar
    to R’s `formula` syntax. And internally, Bambi defines weakly informative priors
    and handles details that can be cumbersome for complex models. The main disadvantage
    is that it is not as flexible as PyMC. The range of models that Bambi can handle
    is a small subset of those from PyMC. Still, this subset contains many of the
    most commonly used statistical models in both industry and academia. The strength
    of Bambi is not just easy model building, but easier model interpretation. Across
    the chapter, we have seen how to use Bambi’s `interpret` module to gain a better
    understanding of the models we fit. Finally, we have seen how to use Kulprit to
    perform projection predictive inference and perform variable selection. Projection
    predictive inference offers a promising approach to variable selection, and Kulprit
    is a promising Pythonic way of doing it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Bambi的主要优势在于它非常易于使用；它与R的`formula`语法非常相似。内部，Bambi定义了弱信息量的先验，并处理了复杂模型中可能繁琐的细节。主要的缺点是它不像PyMC那样灵活。Bambi能够处理的模型范围是PyMC模型范围的一个小子集。不过，这个子集包含了工业界和学术界中最常用的许多统计模型。Bambi的优势不仅仅在于轻松构建模型，还在于更容易的模型解释。在本章中，我们已经看到如何使用Bambi的`interpret`模块更好地理解我们拟合的模型。最后，我们还看到了如何使用Kulprit进行投影预测推断并进行变量选择。投影预测推断为变量选择提供了一种有前景的方法，而Kulprit则是一种有前景的Python化方式。
- en: 6.11 Exercises
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.11 练习
- en: Read the Bambi documentation ( [https://bambinos.github.io/bambi/](https://bambinos.github.io/bambi/))
    and learn how to specify custom priors.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读Bambi文档（[https://bambinos.github.io/bambi/](https://bambinos.github.io/bambi/)）并学习如何指定自定义先验。
- en: Apply what you learned in the previous point and specify a HalfNormal prior
    for the slope of `model_t`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用前一点学到的内容，为 `model_t` 的斜率指定一个 HalfNormal 先验分布。
- en: Define a model like `model_poly4`, but using `raw` polynomials, compare the
    coefficients and the mean fit of both models.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类似 `model_poly4` 的模型，但使用 `raw` 多项式，比较两个模型的系数和均值拟合效果。
- en: Explain in your own words what a distributional model is.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你自己的话解释什么是分布模型。
- en: Expand `model_spline` to a distributional model. Use another spline to model
    the *α* parameter of the NegativeBinomial family.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `model_spline` 扩展为一个分布模型。使用另一个样条来建模 NegativeBinomial 家族的 *α* 参数。
- en: Create a model named `model_p2` for the `body_mass` with the predictors `bill_length`,
    `bill_depth`, `flipper_length`, and `species`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `model_p2` 的模型，用于预测 `body_mass`，其预测变量为 `bill_length`、`bill_depth`、`flipper_length`
    和 `species`。
- en: Use LOO to compare the model in the previous point and `model_p.`
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 LOO 方法比较前一点中的模型和 `model_p`。
- en: Use the functions in the `interpret` module to interpret `model_p2`. Use both
    plots and tables.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `interpret` 模块中的函数来解释 `model_p2`，并同时使用图表和表格。
- en: Join our community Discord space
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 5000 members at: [https://packt.link/bayesian](https://packt.link/bayesian)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区，与志同道合的人一起学习，并与超过5000名成员共同成长，访问链接：[https://packt.link/bayesian](https://packt.link/bayesian)
- en: '![PIC](img/file1.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
