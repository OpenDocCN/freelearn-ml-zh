- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Personalized Product Recommendations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个性化产品推荐
- en: With the advancements in technology and the rising amount of data being collected,
    personalization is everywhere. From streaming services, such as Netflix and Hulu,
    to marketing messages and advertisements you see on your phones, most of the content
    shown to you is personalized nowadays. In marketing, personalized or targeted
    marketing campaigns have proven to work significantly better for driving customer
    engagements and conversions compared to generic or mass marketing campaigns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的进步和收集的数据量的增加，个性化无处不在。从流媒体服务，如Netflix和Hulu，到你在手机上看到的营销信息和广告，现在展示给你的大部分内容都是个性化的。在营销中，个性化的或目标营销活动已被证明比通用的或大众营销活动在推动客户参与和转化方面效果显著。
- en: In this chapter, we are going to discuss building personalized recommendation
    models with which we can better target customers with the products that interest
    them the most. We will be examining how to conduct **market basket analysis**
    in Python, which helps marketers better understand which items are frequently
    bought together, how to build **collaborative filtering** algorithms in two approaches
    for personalized product recommendations, and what other approaches are taken
    for recommending products that are personalized to individual customers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何构建个性化的推荐模型，以便我们能更好地针对客户推荐他们最感兴趣的产品。我们将探讨如何在Python中执行**市场篮子分析**，这有助于营销人员更好地理解哪些商品经常一起购买，如何构建两种方法的**协同过滤**算法以实现个性化产品推荐，以及为推荐针对个别客户的个性化产品所采取的其他方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Product analytics with market basket analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于市场篮子的产品分析
- en: User-based versus item-based collaborative filtering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于用户和基于项目的协同过滤
- en: Other frequently used recommendation methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他常用的推荐方法
- en: Product analytics with market basket analysis
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于市场篮子的产品分析
- en: 'The classic example of **market basket analysis** is that researchers have
    found that customers who buy diapers tend to buy beer as well. Although beer and
    diapers seem too distant items to go together, this finding shows that there are
    hidden associations between different products that we can find from data. The
    goal of market basket analysis is to find these hidden relationships between products
    and efficiently arrange for or recommend the products to customers. Market basket
    analysis helps answer questions like the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**市场篮子分析**的经典例子是研究人员发现，购买尿布的客户也倾向于购买啤酒。尽管啤酒和尿布看起来像是太远的商品而无法搭配，但这一发现表明，我们可以从数据中找到不同产品之间隐藏的关联。市场篮子分析的目标是找到这些产品之间的隐藏关系，并有效地为或向客户安排或推荐产品。市场篮子分析有助于回答以下问题：'
- en: Which products should be recommended to customers who are buying product X?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该向购买产品X的客户推荐哪些产品？
- en: What products should be close together in the store so that customers can easily
    find the products that they want to buy?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在商店中，哪些产品应该放在一起，以便客户可以轻松找到他们想要购买的产品？
- en: 'To answer these questions, association rules of the market basket analysis
    should be found. An association rule, simply put, shows how confidently or significantly
    an itemset occurs in a transaction using a rule-based machine learning approach.
    An association rule has two parts: the antecedent, which is the condition of a
    rule, and the consequent, which is the result of a rule. Consider the following
    statement:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，需要找到市场篮子分析的关联规则。简单来说，关联规则通过基于规则的机器学习方法展示一个项集在交易中出现的信心或显著性。一个关联规则有两个部分：先行词，即规则的条件，和结果词，即规则的结果。考虑以下陈述：
- en: “Customers who buy diapers are likely to buy beer.”
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “购买尿布的客户很可能也会购买啤酒。”
- en: 'In this statement, diapers are the antecedent and beer is the consequent. Five
    metrics are used to evaluate the strengths of these association rules:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个陈述中，尿布是先行词，啤酒是结果词。使用五个指标来评估这些关联规则的强度：
- en: '**Support**: Support signals how frequently an itemset occurs in the dataset.
    The equation to calculate the support for an itemset (*X*, *Y*) is:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持**：支持表示一个项集在数据集中出现的频率。计算项集(*X*, *Y*)的支持的方程式是：'
- en: '![](img/B30999_07_001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_001.png)'
- en: For example, if there are 3 transactions of diapers in all 10 transactions in
    the data, the support of diapers is 3/10 or 0.3\. If there are 2 transactions
    of diapers and beer in all 10 transactions in the data, the support of diapers
    and beer is 2/10 or 0.2.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果数据中的10笔交易中有3笔是尿布交易，那么尿布的支持度为3/10或0.3。如果数据中的10笔交易中有2笔是尿布和啤酒的交易，那么尿布和啤酒的支持度为2/10或0.2。
- en: '**Confidence**: Confidence is a conditional probability of the itemset (*X*,
    *Y*) occurring given that the antecedent *X* has occurred. The equation to calculate
    the confidence for the consequent *Y* given the antecedent *X* is:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**置信度**：置信度是在前导事件X发生的情况下，项集(*X*, *Y*)发生的条件概率。计算给定前导事件X的后续事件Y的置信度的公式为：'
- en: '![](img/B30999_07_002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_002.png)'
- en: For example, if there are 3 transactions of diapers and 2 transactions of diapers
    and beer in all 10 transactions, the confidence of buying beer given diapers is
    2/3 or 0.67\. The confidence value will be 1 if the consequent always occurs with
    the antecedent.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果数据中的10笔交易中有3笔是尿布交易，2笔是尿布和啤酒的交易，那么在尿布购买的情况下购买啤酒的置信度为2/3或0.67。如果后续事件总是与前导事件一起发生，置信度值将为1。
- en: '**Lift**: Lift is a metric to measure how much more often the itemset (X, Y)
    occurs together than if the antecedent and consequent were independent events.
    The equation for the lift for the antecedent X and consequent Y is:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升比**：提升比是一个度量项集(X, Y)与前导事件和后续事件独立事件相比同时发生的频率的指标。前导事件X和后续事件Y的提升比公式为：'
- en: '![](img/B30999_07_003.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_003.png)'
- en: For example, if the confidence of diapers and beer was 2/3 and the support of
    beer was 5/10, then the lift of diapers to beer would be 2/3 divided by 5/10,
    which is 20/15 or 4/3\. If the antecedent and the consequent are independent,
    the lift score will be 1.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果尿布和啤酒的置信度为2/3，啤酒的支持度为5/10，那么尿布对啤酒的提升比为2/3除以5/10，即20/15或4/3。如果前导事件和后续事件是独立的，提升分数将为1。
- en: '**Leverage**: Leverage is a metric used to measure the difference between the
    frequency of the antecedent and the consequent occurring together and the frequency
    of the antecedent and the consequent if they were independent. The equation for
    the leverage is:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**杠杆率**：杠杆率是一个度量前导事件和后续事件同时发生的频率与它们独立时发生的频率之间差异的指标。杠杆率的公式为：'
- en: '![](img/B30999_07_004.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_004.png)'
- en: For example, if diapers and beer occurred in 4 transactions out of 10 total
    transactions and the support of diapers and beer were 0.6 and 0.5 respectively,
    then the leverage will be 0.4 – (0.6 * 0.5), which is 0.1\. Leverage values range
    between –1 and 1 and if the antecedent and the consequent were independent, the
    leverage value will be 0.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果尿布和啤酒在总共10笔交易中的4笔交易中发生，尿布和啤酒的支持度分别为0.6和0.5，那么杠杆率将是0.4减去(0.6 * 0.5)，即0.1。杠杆率的值介于-1和1之间，如果前导事件和后续事件是独立的，杠杆率值将为0。
- en: '**Conviction**: Conviction measures how much the consequent depends on the
    antecedent. The equation for the conviction is:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信念度**：信念度衡量后续事件对前导事件依赖的程度。信念度的公式为：'
- en: '![](img/B30999_07_005.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_005.png)'
- en: For example, if the confidence between diapers and beer is `0.67` and the support
    of beer is `0.2`, meaning there were 2 transactions of beer in 10 total transactions,
    the conviction would have been about `2.42`. If the antecedent and the consequent
    are independent, then the conviction will be 1\. On the other hand, if the confidence
    of the antecedent and consequent is 1 or if the consequent always occurs together
    with the antecedent, then the denominator becomes 0 and the conviction value becomes
    infinite.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果尿布和啤酒之间的置信度为`0.67`，啤酒的支持度为`0.2`，意味着在总共10笔交易中有2笔是啤酒交易，那么信念度大约为`2.42`。如果前导事件和后续事件是独立的，那么信念度将为1。另一方面，如果前导事件和后续事件的置信度为1，或者后续事件总是与前导事件一起发生，那么分母变为0，信念度值变为无穷大。
- en: With this foundation, let’s dive into finding the association rules within an
    e-commerce dataset. We will be using an online retail dataset and the `mlxtend`
    package to show how market basket analysis can be performed with Python.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，让我们深入探讨如何在电子商务数据集中寻找关联规则。我们将使用在线零售数据集和`mlxtend`包来展示如何使用Python进行市场篮子分析。
- en: '**Source code and data**: [https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/tree/main/ch.7](https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/tree/main/ch.7
    )'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码和数据**: [https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/tree/main/ch.7](https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/tree/main/ch.7)'
- en: '**Data source**: [https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/blob/main/ch.7/data.csv](https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/blob/main/ch.7/data.csv
    )'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据来源**: [https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/blob/main/ch.7/data.csv](https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/blob/main/ch.7/data.csv)'
- en: 'Here is the link for the original data source: [https://archive.ics.uci.edu/dataset/352/online+retail](https://archive.ics.uci.edu/dataset/352/online+retail)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始数据源的链接：[https://archive.ics.uci.edu/dataset/352/online+retail](https://archive.ics.uci.edu/dataset/352/online+retail)
- en: 'The following is the command for installing the `mlxtend` package:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为安装`mlxtend`包的命令：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Apriori algorithm – finding frequent itemsets
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apriori算法 – 寻找频繁项集
- en: 'The Apriori algorithm is used to identify and generate the association rules
    that we discussed previously. We will discuss how to run the Apriori algorithm
    for market basket analysis in Python with an example. Let’s first load the data
    into a DataFrame using the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori算法用于识别和生成我们之前讨论的关联规则。我们将通过一个示例来讨论如何在Python中使用Apriori算法进行市场篮子分析。首先，我们使用以下代码将数据加载到DataFrame中：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once we run this code, we now have all the purchases that the customers made.
    If you recall what we have discussed previously about the market basket analysis,
    the two key components are finding the itemsets and finding the rules among the
    itemsets. In this section, we are going to focus on finding the itemsets, which
    are the combinations of items.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行此代码，我们现在就有所有客户所做的购买。如果你还记得我们之前讨论过的市场篮子分析，两个关键组件是找到项集和找到项集之间的规则。在本节中，我们将专注于找到项集，即商品的组合。
- en: 'When you run the `df["StockCode"].nunique()` command, you will see that there
    are 3,684 unique items or products in this data. As you can imagine, the number
    of combinations of the items you can create grows exponentially with the number
    of items. The number of all possible combinations of items is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`df["StockCode"].nunique()`命令时，你会看到在这个数据集中有3,684个独特的商品或产品。正如你可以想象的那样，你可以创建的商品组合的数量会随着商品数量的增加而呈指数增长。所有可能商品组合的数量是：
- en: '![](img/B30999_07_006.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_006.png)'
- en: With over 3,000 items in our dataset, it will be unrealistic to check all the
    possible itemsets, as there are 2^(3684)-1 itemsets to check. This is where the
    **Apriori** algorithm comes in. Intuitively, the items or itemsets with low transaction
    frequency or low support are going to have less value in the findings. Thus, the
    Apriori algorithm extracts the itemsets that are considered frequent enough by
    the predefined threshold of support.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据集中有超过3,000个商品，检查所有可能的项集是不切实际的，因为有2^(3684)-1个项集需要检查。这就是Apriori算法发挥作用的地方。直观地说，交易频率低或支持度低的商品或项集在结果中可能价值较低。因此，Apriori算法提取了被认为足够频繁的项集，这些项集由预定义的支持度阈值确定。
- en: 'To find the frequent itemsets using the Apriori algorithm, we need to convert
    the DataFrame in a way that it is a matrix where each row represents the customers
    and each column represents the items or products. Take a look at the following
    code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Apriori算法找到频繁项集，我们需要将DataFrame转换成一种矩阵形式，其中每一行代表客户，每一列代表商品或产品。看看以下代码：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we are using the `pivot_table` function to create a customer-to-item
    matrix and each value will be the total quantity of each item that each customer
    bought. With this customer-to-item matrix, we can run the Apriori algorithm to
    find the frequent itemsets using the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`pivot_table`函数来创建一个客户到商品的矩阵，每个值将代表每个客户购买的商品的总数量。有了这个客户到商品的矩阵，我们可以使用以下代码运行Apriori算法来找到频繁项集：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see from this code, we are using the `apriori` function within the
    `mlxtend` package. We have defined the minimum support required for each itemset
    to be `0.03` with the `min_support` parameter, which means we are going to ignore
    those itemsets that occur in less than 3% of the transactions. Then, we add a
    column, `n_items`, which simply counts the number of items in each itemset.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，我们正在使用 `mlxtend` 包中的 `apriori` 函数。我们使用 `min_support` 参数定义每个项集所需的最低支持为
    `0.03`，这意味着我们将忽略那些在交易中发生次数少于 3% 的项集。然后，我们添加一个名为 `n_items` 的列，它简单地计算每个项集中的项目数量。
- en: 'The final DataFrame looks like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 DataFrame 看起来如下所示：
- en: '![](img/B30999_07_01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_01.png)'
- en: 'Figure 7.1: The frequent_items DataFrame'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：频繁项 DataFrame
- en: If you recall, the total number of possible combinations of itemsets was 2^(3684)-1\.
    However, as you can see from this result of applying the Apriori algorithm, we
    now have 1,956 items, which is a manageable and reasonable amount of itemsets
    that we can examine the association rules for.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，项集的可能组合总数是 2^(3684)-1。然而，正如您从应用 Apriori 算法的结果中可以看到的，我们现在有 1,956 个项，这是一个可管理的合理数量的项集，我们可以检查其关联规则。
- en: Association rules
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联规则
- en: 'With the frequent itemsets we have built, we can now generate the association
    rules that will tell us which itemsets are frequently bought together. Take a
    look at the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们构建的频繁项集，我们现在可以生成关联规则，这些规则将告诉我们哪些项集经常一起购买。请看以下代码：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we are using the `association_rules` function in the `mlxtend` package.
    There are a few key parameters to consider:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `mlxtend` 包中的 `association_rules` 函数。有几个关键参数需要考虑：
- en: '`metric`: This parameter defines which metric to use for selecting the association
    rules. Here, we are using `confidence` to choose association rules with high confidence,
    but you can also use `lift` if you are interested in finding the rules with high
    lift.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metric`：此参数定义了用于选择关联规则要使用的指标。在这里，我们使用 `confidence` 来选择具有高 confidence 的关联规则，但如果您对找到具有高
    lift 的规则感兴趣，也可以使用 `lift`。'
- en: '`min_threshold`: This parameter defines the threshold for the selection of
    association rules based on the metric you have chosen. Here, we are only interested
    in finding the rules with confidence above the 60% threshold.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_threshold`：此参数定义了基于您选择的指标选择关联规则的阈值。在这里，我们只对找到 confidence 超过 60% 阈值的规则感兴趣。'
- en: '`support_only`: You can set this parameter to `True` if you are only interested
    in computing the support of the rules or if other metrics cannot be computed due
    to some data missing. Here, we set this to `False` as we are interested in finding
    the rules with high confidence.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`support_only`：如果您只对计算规则的 support 感兴趣，或者由于某些数据缺失而无法计算其他指标，可以将此参数设置为 `True`。在这里，我们将其设置为
    `False`，因为我们对找到具有高 confidence 的规则感兴趣。'
- en: 'The output of these rules should look like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则的输出应如下所示：
- en: '![](img/B30999_07_02.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_02.png)'
- en: 'Figure 7.2: Association rules based on confidence above 60%'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：基于 confidence 超过 60% 的关联规则
- en: 'The association rule output contains antecedents, consequents, and key metrics,
    such as `support`, `confidence`, and `lift`. You can sort by each metric and generate
    insights on which itemsets have close relationships. For example, you may want
    to find the top 20 itemsets that have the highest lift or the top 10 itemsets
    that have the highest confidence. You can also visualize these relationships so
    that you can easily view the relationships and the strengths of the relationships.
    Take a look at the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则输出包含先行项、后续项和关键指标，例如 `support`、`confidence` 和 `lift`。您可以按每个指标排序，并生成关于哪些项集具有紧密关系的见解。例如，您可能希望找到具有最高
    lift 的前 20 个项集或具有最高 confidence 的前 10 个项集。您还可以可视化这些关系，以便您可以轻松查看关系及其强度。请看以下代码：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we first select the top 20 rules with the highest lift by using the `sort_values`
    function. Then, we pivot the table so that each row is the antecedent, each column
    is the consequent, and the value of a cell is the lift. A heatmap can be used
    to visualize the strengths of these rules easily. The following code can be used
    to visualize these 20 rules with the highest lift:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用 `sort_values` 函数选择具有最高 lift 的前 20 个规则。然后，我们将表格进行转置，使得每一行是先行项，每一列是后续项，单元格的值是
    lift。可以使用热图轻松可视化这些规则的强度。以下代码可以用于可视化这 20 个具有最高 lift 的规则：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will generate a heatmap that looks like the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如下所示的热图：
- en: '![](img/B30999_07_03.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_03.png)'
- en: 'Figure 7.3: The top 20 association rules with the highest lift'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：具有最高升力的前20个关联规则
- en: In this chart, the lighter the color is, the higher the lift is for a given
    rule. For example, when the antecedent itemset is `GREEN REGENCY TEACUP AND SAUCER`,
    `REGENCY TEA PLATE ROSES` and the consequent itemset is `ROSES REGENCY TEACUP
    AND SAUCER`, `REGENCY TEA PLATE GREEN`, the lift is about 26 and the highest.
    On the other hand, when the antecedent itemset is `ROSES REGENCY TEACUP AND SAUCER`,
    `REGENCY TEA PLATE ROES` and the consequent itemset is `GREEN REGENCY TEACUP AND
    SAUCER`, `REGENCY TEA PLATE GREEN`, the lift is about 20 and the lowest among
    the top 20 rules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，颜色越浅，给定规则的升力就越高。例如，当前提项目集是`GREEN REGENCY TEACUP AND SAUCER`、`REGENCY
    TEA PLATE ROSES`，而结果项目集是`ROSES REGENCY TEACUP AND SAUCER`、`REGENCY TEA PLATE GREEN`时，升力约为26，是最高的。另一方面，当前提项目集是`ROSES
    REGENCY TEACUP AND SAUCER`、`REGENCY TEA PLATE ROES`，而结果项目集是`GREEN REGENCY TEACUP
    AND SAUCER`、`REGENCY TEA PLATE GREEN`时，升力约为20，是前20条规则中最低的。
- en: As you can see from this example, with the association rules, we can easily
    find out which products are bought together and their relationships with one another.
    This can be used in personalized marketing, where certain products are recommended
    based on these rules. If a customer purchased itemset A, then naturally you can
    recommend itemset B, which has high confidence or lift as the association rule
    suggests that A and B are frequently bought together with significance. This is
    one step closer to recommending individualized product sets in marketing messages
    rather than blindly recommending random product sets in the hopes that customers
    express interest in purchasing them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，通过关联规则，我们可以轻松地找出哪些产品是共同购买的，以及它们之间的关系。这可以用于个性化营销，根据这些规则推荐某些产品。如果一个客户购买了项目集A，那么自然可以推荐项目集B，因为关联规则表明A和B经常一起购买，具有显著性。这比在营销信息中盲目推荐随机产品集，希望客户对购买它们表示兴趣，更接近一步推荐个性化的产品集。
- en: 'Lastly, if you recall, lift has a linear relationship with confidence and an
    inverse relationship with support, as lift is defined as:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你还记得，升力与置信度呈线性关系，与支持度呈反向关系，因为升力定义为：
- en: '![](img/B30999_07_007.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_007.png)'
- en: 'This relationship can be easily shown from the rules we have found with the
    `mlxtend` package. Take a look at the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关系可以通过我们用`mlxtend`包找到的规则轻松展示。看看下面的代码：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have lift values on the y-axis and support and confidence values on
    the x-axis. The chart will look as the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，y轴上有升力值，x轴上有支持度和置信度值。图表将如下所示：
- en: '![](img/B30999_07_04.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_04.png)'
- en: 'Figure 7.4: The relationships between lift and confidence and between lift
    and support'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：升力与置信度以及升力与支持之间的关系
- en: As you can see from this chart, the top x-axis shows the confidence values and
    the scatter plot of lift against confidence shows a linear relationship, where
    the lift values increase as the confidence values increase. On the other hand,
    the bottom x-axis shows the support values and the scatter plot of lift against
    support shows an inverse relationship, where the lift values decrease as the support
    values increase.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图表中可以看出，x轴的顶部显示了置信度值，升力与置信度的散点图显示了一种线性关系，即随着置信度值的增加，升力值也增加。另一方面，x轴的底部显示了支持度值，升力与支持度的散点图显示了一种反向关系，即随着支持度值的增加，升力值减少。
- en: Collaborative filtering
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协同过滤
- en: 'There are various approaches in building recommendation systems and often multiple
    approaches take part. Some of the frequently used AI/ML-driven approaches in building
    recommendation systems are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建推荐系统中有各种方法，通常有多种方法参与其中。在构建推荐系统中，一些常用的基于AI/ML的方法包括：
- en: '**Collaborative filtering**: This method uses previous user behaviors, such
    as pages they viewed, products they purchased, or ratings they have given previously.
    This algorithm leverages this kind of data to find similar products or content
    to those that the users have shown interest in previously. For example, if a user
    viewed a few thriller movies on a streaming platform, some other thriller movies
    may be recommended to this user. Or, if a customer bought dress shirts and dress
    shoes on an e-commerce platform, dress pants may be recommended to this customer.
    The collaborative filtering algorithms are often built based on the similarities
    between users or items:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作过滤**：这种方法使用之前用户的行为，如他们查看的页面、购买的产品或之前给出的评分。该算法利用这类数据来找到与用户之前表示兴趣的产品或内容相似的产品或内容。例如，如果用户在流媒体平台上观看了几部惊悚电影，可能会向这位用户推荐其他一些惊悚电影。或者，如果一位客户在电子商务平台上购买了连衣裙衬衫和连衣裙鞋，可能会向这位客户推荐连衣裙裤。协作过滤算法通常基于用户或项目之间的相似性构建：'
- en: '**User-based** collaborative filtering uses data to find similar users based
    on the pages viewed or products purchased previously.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于用户的**协作过滤使用数据来根据之前查看的页面或购买的产品找到相似的用户。'
- en: '**Item-based** collaborative filtering uses data to find items that are often
    bought or viewed together.'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于项目的**协作过滤使用数据来寻找经常一起购买或查看的项目。'
- en: '**Content-based filtering**: As the name suggests, this method uses the characteristics
    of products, contents, or users. Where the collaborative filtering algorithm focuses
    on user-to-user or item-to-item similarities, the content-based filtering algorithm
    focuses on characteristic similarities, such as genres, keywords, and metadata.
    For example, if you are recommending movies to watch, this approach may look at
    the descriptions, genres, or actors of movies and recommend those that match a
    user’s preferences. On the other hand, if you are recommending fashion items,
    then this approach may look at the product categories, descriptions, and brands
    to recommend certain items to users.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于内容的过滤**：正如其名所示，这种方法使用产品、内容或用户的特征。协作过滤算法侧重于用户到用户或项目到项目的相似性，而基于内容的过滤算法侧重于特征相似性，例如流派、关键词和元数据。例如，如果你正在推荐观看的电影，这种方法可能会查看电影的描述、流派或演员，并推荐那些符合用户偏好的电影。另一方面，如果你正在推荐时尚商品，那么这种方法可能会查看产品类别、描述和品牌，以向用户推荐某些商品。'
- en: '**Predictive modeling**: As discussed in *Chapter 6*, predictive models can
    be built for recommendation systems as well. Previous content that the users viewed,
    products that they have purchased, or web session history can be the features
    to identify the items that the users are highly likely to be interested in seeing
    or purchasing. The probability output of these predictive models can be used to
    rank the items so that more likely items are shown to the users before other less
    likely items.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测建模**：如第6章所述，也可以为推荐系统构建预测模型。用户之前查看的内容、他们购买的产品或网页会话历史可以作为识别用户很可能感兴趣查看或购买的项目特征。这些预测模型的概率输出可以用来对项目进行排序，以便在显示其他不太可能的项目之前向用户展示更可能的项目。'
- en: '**Hybrid models**: Oftentimes, recommendation systems are built with all of
    the previously mentioned approaches. Blending different approaches for recommendations
    can help improve the recommendation accuracy that single-approach recommendation
    systems may miss.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合模型**：通常，推荐系统会结合之前提到的所有方法来构建。将不同的推荐方法混合使用可以帮助提高推荐准确性，这是单一方法推荐系统可能遗漏的。'
- en: In this chapter, we are going to focus on the *collaborative filtering* algorithm
    as it is a frequently used backbone of lots of recommender systems, and more specifically,
    how to build recommendation systems using user-based collaborative filtering and
    item-based collaborative filtering algorithms. This technique is frequently used
    in recommendation systems as it captures the interactions among the users and
    items very well in a very intuitive way. Lots of organizations where recommendations
    are critical in their businesses, such as Netflix, Amazon, and Spotify, use collaborative
    filtering algorithms as part of their recommendation systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注**协同过滤**算法，因为它作为许多推荐系统常用的骨干算法，并且更具体地，我们将探讨如何使用基于用户的协同过滤和基于商品的协同过滤算法来构建推荐系统。这种技术在推荐系统中经常被使用，因为它以非常直观的方式很好地捕捉了用户和商品之间的交互。许多在业务中推荐至关重要的组织，如Netflix、Amazon和Spotify，都将协同过滤算法作为其推荐系统的一部分。
- en: The key to the collaborative filtering algorithms is to find similar users or
    items. There can be various metrics that can be used to measure the similarities
    between users or items, such as Euclidean distance, Manhattan distance, or Jaccard
    distance. However, cosine similarity is one of the most frequently used similarity
    metrics in collaborative filtering, as it focuses more on the directional similarity
    over the magnitude of the distance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤算法的关键是找到相似的用户或商品。可以有多种度量标准来衡量用户或商品之间的相似性，例如欧几里得距离、曼哈顿距离或Jaccard距离。然而，余弦相似度是协同过滤中最常用的相似性度量之一，因为它更多地关注距离的定向相似性，而不是距离的大小。
- en: '**Cosine similarity** is simply the cosine of the angle between two vectors.
    Here, vectors can be user vectors or item vectors in our case of collaborative
    filtering algorithms. As cosine similarity has strength in high-dimensional space,
    it is often chosen as the distance metric for collaborative filtering algorithms.
    The equation for computing the cosine similarity between two vectors looks as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**余弦相似度**简单地说就是两个向量之间角度的余弦值。在这里，向量可以是协同过滤算法中的用户向量或商品向量。由于余弦相似度在高维空间中具有优势，它通常被选为协同过滤算法的距离度量。计算两个向量之间余弦相似度的方程如下：'
- en: '![](img/B30999_07_008.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_008.png)'
- en: In this equation,*V*[1][i] and *V*[2][i] represent each item in each vector,
    which can be a user vector or an item vector. These cosine similarity values range
    between -1 and 1\. If the 2 vectors are similar, the cosine similarity value will
    be close to 1; if the 2 vectors are independent, then the cosine similarity value
    will be 0; if the 2 vectors are the opposite vectors, then the cosine similarity
    value will be close to -1.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*V*[1][i]和*V*[2][i]代表每个向量中的每个商品，这些向量可以是用户向量或商品向量。这些余弦相似度值介于-1和1之间。如果两个向量相似，余弦相似度值将接近1；如果两个向量独立，则余弦相似度值将为0；如果两个向量是相反向量，则余弦相似度值将接近-1。
- en: 'To build collaborative filtering algorithms, we will first need to build the
    customer-to-item matrix. We will be using the same code that we have used for
    the market basket analysis, which looks like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建协同过滤算法，我们首先需要构建客户-商品矩阵。我们将使用与市场篮子分析相同的代码，如下所示：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As before, this matrix shows the quantities purchased for each item (column)
    by each customer (row). Instead of using the raw quantities of items purchased,
    we are going to one-hot encode so that the values are 1 if a given customer bought
    a given item or 0 if not, as in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个矩阵显示了每个客户（行）为每个商品（列）购买的量。我们不是使用商品购买的原始数量，而是将要使用独热编码，使得如果某个客户购买了某个商品，则值为1，如果没有购买，则值为0，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `customer_item_matrix` matrix should look like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer_item_matrix`矩阵应该看起来像下面这样：'
- en: '![](img/B30999_07_05.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_05.png)'
- en: 'Figure 7.5: The customer-to-item matrix'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：客户-商品矩阵
- en: As expected, each row represents whether a given user bought each item or not.
    This matrix will be the foundational matrix that we will use to build user-based
    collaborative filtering and item-based collaborative filtering algorithms in the
    following sections.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，每一行代表一个特定用户是否购买了每个商品。这个矩阵将成为我们在以下章节中构建基于用户协同过滤和基于商品协同过滤算法的基础矩阵。
- en: User-based collaborative filtering
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤
- en: 'The first step to building a user-based collaborative filtering model is to
    build a matrix of similar users. Take a look at the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构建基于用户的协同过滤模型的第一步是构建相似用户矩阵。看看下面的代码：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you recall, the cosine similarity measure is one of the most frequently used
    similarity metrics for collaborative filtering algorithms. Here, we are using
    the scikit-learn package’s `cosine_similarity` function to compute cosine similarities
    between users. The newly created variable, `user_user_sim_matrix`, will be a matrix
    where each row and column represents a user and the similarities between two users.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，余弦相似度度量是协同过滤算法中最常用的相似度指标之一。在这里，我们使用scikit-learn包的`cosine_similarity`函数来计算用户之间的余弦相似度。新创建的变量`user_user_sim_matrix`将是一个矩阵，其中每一行和每一列代表一个用户，以及两个用户之间的相似度。
- en: 'Take a look at the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/B30999_07_06.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_06.png)'
- en: 'Figure 7.6: A sample of user-to-user similarities'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：用户之间的相似性样本
- en: This example shows the user-to-user cosine similarity metrics. As expected,
    the diagonal values are 1 since they represent the similarities between a user
    and itself. For example, users `12349` and `12350` have a cosine similarity of
    about `0.057` and users `12349` and `12352` have a cosine similarity of `0.138`.
    This suggests that user `12349` is more similar to user `12352` than to user `12350`.
    This way, you can identify and rank the users by how similar they are to a target
    user.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例显示了用户之间的余弦相似度指标。正如预期的那样，对角线上的值是1，因为它们代表用户与其自身的相似度。例如，用户`12349`和`12350`的余弦相似度约为`0.057`，而用户`12349`和`12352`的余弦相似度为`0.138`。这表明用户`12349`与用户`12352`的相似度高于与用户`12350`的相似度。这样，你可以通过用户与目标用户的相似度来识别和排名用户。
- en: 'Let’s pick one customer and see how we may be able to build a recommendation
    system. We will select the user with ID `14806` as an example for this exercise:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择一个客户来看看我们如何可能构建一个推荐系统。我们将选择用户ID`14806`作为这个练习的示例：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we select the top 10 users that have the highest cosine similarity measures,
    by selecting `TARGET_CUSTOMER` in the `user_user_sim_matrix` matrix and sorting
    the values in descending order. The output should look like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过在`user_user_sim_matrix`矩阵中选择`TARGET_CUSTOMER`并按降序排序值，选择具有最高余弦相似度测量的前10个用户。输出应如下所示：
- en: '![](img/B30999_07_07.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_07.png)'
- en: 'Figure 7.7: Similar customers to the target customer'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：与目标客户相似的客户
- en: Here, you can see that customer `13919` is the most similar to the target customer,
    `14806`, customer `12561` comes second, and customer `13711` follows in third.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到客户`13919`与目标客户`14806`最相似，客户`12561`排在第二位，客户`13711`排在第三位。
- en: Recommending by the most similar customer
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过最相似客户进行推荐
- en: The simplest approach to recommend products to the target customer is to see
    which items the target customer has bought already and compare them against the
    most similar customer, `13919`. Then, recommend the products that the target customer
    has not bought yet that the most similar customer has bought. This is based on
    the assumption, as discussed previously, that customers similar to each other
    are likely to behave similarly or share similar interests and they are likely
    to purchase similar products.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 向目标客户推荐产品的最简单方法就是查看目标客户已经购买的商品，并将它们与最相似客户`13919`进行比较。然后，推荐目标客户尚未购买但最相似客户已经购买的商品。这是基于之前的讨论，即相似的客户可能具有相似的行为或兴趣，并且他们可能购买相似的产品。
- en: 'To do this, we can follow these steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以遵循以下步骤：
- en: 'We will first find out the items that the target customer has bought already,
    using the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先找出目标客户已经购买的商品，使用以下代码：
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will get all the items that the target customer has bought and store them
    in the `items_bought_by_target` variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取目标客户购买的所有商品，并将它们存储在`items_bought_by_target`变量中。
- en: 'Next, we need to get all the items the most similar customer, `13919`, has
    bought. Take a look at the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取与最相似客户`13919`购买的所有商品。看看下面的代码：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This finds out all the items that the most similar customer, `13919`, has bought
    and stores them in the `items_bought_by_sim` variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找出最相似客户`13919`购买的所有商品，并将它们存储在`items_bought_by_sim`变量中。
- en: 'Using the `set` operation, it is easy to find out the items that the most similar
    customer has bought but not bought by the target customer, as shown in the following
    code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`set`操作，很容易找出最相似客户购买但目标客户未购买的商品，如下所示代码所示：
- en: '[PRE15]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we simply subtract the `items_bought_by_target` set from the
    other set, `items_bought_by_sim`. This will get all the items that the target
    customer has not yet bought but were bought by the most similar customer and store
    them in `items_bought_by_sim_but_not_by_target`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是从`items_bought_by_target`集合中减去另一个集合`items_bought_by_sim`，这将得到所有目标客户尚未购买但最相似客户已购买的商品，并将它们存储在`items_bought_by_sim_but_not_by_target`中。
- en: 'We can get the details about these items using the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码获取这些商品的详细信息：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This output should look like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出应如下所示：
- en: '![](img/B30999_07_08.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_08.png)'
- en: 'Figure 7.8: Items to recommend to the target customer'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：推荐给目标客户的项目
- en: This is the list of items that the most similar customer, `13919`, has bought
    but have not been bought by the target customer, and their descriptions. In the
    most simple approach to recommending products, this list can be shown to the target
    customer as the recommended items.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是购买但尚未被目标客户购买的最相似客户`13919`购买的商品及其描述列表。在推荐产品的最简单方法中，此列表可以显示给目标客户作为推荐商品。
- en: Since these two customers have shown similar interests by having bought similar
    items in the past, it is more likely for the target customer to purchase some
    of these items rather than a random selection of products. You can apply the same
    process for each customer and build sets of products to recommend based on the
    most similar customers’ historical purchases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个客户在过去购买相似商品时表现出相似的兴趣，因此目标客户购买这些商品的可能性比随机选择产品要高。您可以为每个客户应用相同的流程，并根据最相似客户的购买历史构建推荐产品集合。
- en: Recommending by the top products bought by similar customers
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据相似客户购买的前列产品进行推荐
- en: Another approach is to rank the products by how frequently they were bought
    by the most similar customers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是按照最相似客户购买产品的频率来对产品进行排名。
- en: 'We can start with the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从以下代码开始：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we first get the top 10 most similar customers by the cosine similarity.
    Then, for each similar customer, we iterate through the items that were bought
    by the similar customer but not by the target customer. We count the number of
    times similar customers bought the given product, sort by the purchase frequency
    in the reverse order, and store it in the `potential_rec_items` variable. The
    result should look like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先通过余弦相似度得到前10个最相似客户。然后，对于每个相似客户，我们遍历那些由相似客户购买但目标客户未购买的商品。我们计算相似客户购买指定产品的次数，按购买频率降序排序，并将结果存储在`potential_rec_items`变量中。结果应如下所示：
- en: '![](img/B30999_07_09.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_09.png)'
- en: 'Figure 7.9: Top products purchased by similar customers'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：相似客户购买的前列产品
- en: 'This suggests that 7 out of 10 customers have bought the `21500` and `21499`
    products, 4 out of 10 customers have bought the `21498` and `POST` products, and
    so forth. We can query to get the product descriptions from these product IDs
    using the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明10个客户中有7个购买了`21500`和`21499`产品，10个客户中有4个购买了`21498`和`POST`产品，等等。我们可以通过以下代码查询从这些产品ID获取产品描述：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This output should look like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出应如下所示：
- en: '![](img/B30999_07_10.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_10.png)'
- en: 'Figure 7.10: Top products purchased by similar customers'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：相似客户购买的前列产品
- en: This approach, however, does not account for how similar or dissimilar each
    customer was to the target customer. It just counted the number of top 10 similar
    customers for each product and recommended based on the simple sum.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法并没有考虑到每个客户与目标客户之间的相似度或差异度。它只是对每个产品的前10个相似客户进行了计数，并基于简单的总和进行推荐。
- en: 'Since we have similarity measures for each of the top 10 similar customers,
    we may also want to consider that when we recommend products. Instead of simple
    counts, we can do weighted counts. Take a look at the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为前10个相似客户中的每一个都设置了相似度度量，因此在我们推荐产品时，我们也可能想要考虑这一点。我们不仅可以进行简单的计数，还可以进行加权计数。请看以下代码：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you may notice, the only part that is different from the previous code is
    `potential_rec_items[each_item] += cos_sim`. Instead of simply counting, we are
    now adding the cosine similarity metric that measures how similar or dissimilar
    each customer is to the target customer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能注意到的，与之前的代码不同的是`potential_rec_items[each_item] += cos_sim`。我们不再只是计数，现在我们正在添加一个余弦相似度指标，该指标衡量每个客户与目标客户相似或不同的程度。
- en: 'When we query the top 10 items weighted by the cosine similarity, the results
    look as in the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们根据余弦相似度查询前10个物品时，结果如下所示：
- en: '![](img/B30999_07_11.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_11.png)'
- en: 'Figure 7.11: Top products purchased by similar customers (weighted by cosine
    similarity)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：类似客户购买的前列产品（按余弦相似度加权）
- en: In this example, the output from the simple count is the same as the output
    from the weighted count. Not only can you do the weighted sum of cosine similarities
    but you can also do the weighted average. There are many other ways you can aggregate
    the scores and recommend products, so being creative is the key to building the
    final recommendation output from the cosine similarity measures.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，简单计数的结果与加权计数的结果相同。您不仅可以做余弦相似度的加权求和，还可以做加权平均。您还有许多其他方法可以聚合分数并推荐产品，所以富有创意是构建最终推荐输出的关键，这个输出是基于余弦相似度度量的。
- en: As you can see from these examples, we can build product sets to recommend based
    on the customers who have shown similar behaviors in the past. Oftentimes, people
    with similar tastes buy similar items, so this user-based collaborative filtering
    works well when recommending products based on the similarities among your customer
    base. On top of recommending based on customer similarities, we can also recommend
    based on how similar individual items are to others. We are going to discuss how
    to build recommendation systems based on item-based collaborative filtering in
    the following section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这些示例中可以看到，我们可以构建基于过去表现出相似行为的客户的产品集进行推荐。通常情况下，有相似口味的人会购买相似的商品，所以当根据客户群中的相似性推荐产品时，基于用户的协同过滤效果很好。除了基于客户相似性进行推荐外，我们还可以根据单个物品与其他物品的相似性进行推荐。在下一节中，我们将讨论如何基于物品的协同过滤构建推荐系统。
- en: Item-based collaborative filtering
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤
- en: 'As in the case of user-based collaborative filtering, the key starting point
    of building an item-based collaborative filtering algorithm is to build an item-to-item
    similarity matrix. From the customer-item matrix we built previously, we can use
    the following code to build an item-to-item similarity matrix:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于用户的协同过滤的情况一样，构建基于物品的协同过滤算法的关键起点是构建一个物品-物品相似度矩阵。从我们之前构建的客户-物品矩阵中，我们可以使用以下代码来构建一个物品-物品相似度矩阵：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As shown in this code, we transpose the customer-item matrix, `customer_item_matrix`,
    first, which will make it an item-to-customer matrix where each row is an item,
    each column is a customer, and each value is 0 or 1 representing whether a given
    item is bought by a given column. Then, we compute cosine similarity by using
    the `cosine_similarity` function and save the results as a pandas DataFrame in
    an `item_item_sim_matrix` variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，我们首先转置客户-物品矩阵，`customer_item_matrix`，这将使其成为一个物品-客户矩阵，其中每一行是一个物品，每一列是一个客户，每个值是0或1，表示给定列是否购买了给定物品。然后，我们使用`cosine_similarity`函数计算余弦相似度，并将结果保存为名为`item_item_sim_matrix`的pandas
    DataFrame变量。
- en: 'The results should look like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像以下这样：
- en: '![](img/B30999_07_12.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_12.png)'
- en: 'Figure 7.12: Item-to-item similarity matrix'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：物品-物品相似度矩阵
- en: Recommending by the most similar items
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据最相似物品进行推荐
- en: The simplest approach to generating recommendations based on item similarities
    is to find the most similar items for a given item and recommend them. When a
    person is viewing a certain product and you want to show related or similar items,
    this approach can be used. For example, when you search for a product on Amazon
    and click on one of the products shown on the search page, Amazon will show related
    or similar items at the bottom of the page that are often bought together. This
    is where item-based collaborative filtering can be used and, more specifically,
    when you want to recommend products based on one given product.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 基于项目相似性生成推荐的最简单方法是为给定项目找到最相似的项目并推荐它们。当一个人查看某个产品时，您想展示相关或相似的项目，可以使用这种方法。例如，当您在亚马逊上搜索产品并点击搜索页面上的某个产品时，亚马逊将在页面底部显示经常一起购买的相关或相似项目。这就是基于项目的协同过滤可以发挥作用的地方，更具体地说，当您想根据一个给定的产品推荐产品时。
- en: 'Using our example dataset, let’s assume a customer is looking at a product,
    `MEDIUM CERAMIC TOP STORAGE JAR`, which has a product code of `23166`. From the
    item-to-item matrix, `item_item_sim_matrix`, that we have just built, we can find
    the top 10 most similar items with the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的示例数据集，假设一位客户正在查看一个产品，“中号陶瓷顶盖储物罐”，其产品代码为“23166”。从我们刚刚构建的项目到项目矩阵`item_item_sim_matrix`中，我们可以使用以下代码找到最相似的10个项目：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see in this code, we are selecting the top 10 most similar items
    by ordering the items by the cosine similarity in descending order. The output
    should look like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在这段代码中所见，我们通过按余弦相似度降序排列项目来选择最相似的10个项目。输出结果应如下所示：
- en: '![](img/B30999_07_13.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_13.png)'
- en: 'Figure 7.13: Top 10 similar items to product 23166'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：与产品23166最相似的10个项目
- en: 'We can also query the descriptions based on these product codes as in the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以根据这些产品代码查询描述，如下所示：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, we are excluding product `23166` as it is the target item or
    the item that the customer is currently viewing and showing the rest of the 10
    most similar items. The output should look like the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们排除了产品“23166”，因为它是要查看的目标项目或客户当前查看的项目，并展示了其余的10个最相似的项目。输出结果应如下所示：
- en: '![](img/B30999_07_14.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_07_14.png)'
- en: 'Figure 7.14: Top 10 items similar to product 23166, including itself'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：包括自身在内的与产品23166最相似的10个项目
- en: As you can imagine, we can show these 10 items, including itself, on the page
    while the customer is viewing the target product. This way, we are showing the
    most similar or the most frequently bought together items so that the customer
    has more options to choose from or more items to purchase.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，当客户查看目标产品时，我们可以在页面上展示这10个项目，包括它本身。这样，我们展示了最相似或最常一起购买的项目，以便客户有更多选择或更多商品可以购买。
- en: Recommending by the purchase history
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据购买历史推荐
- en: Expanding on the previous example of recommending products based on a single
    item, we can also build an item-based collaborative filtering recommendation system
    for multiple items. Especially when you may be sending out marketing emails or
    newsletters, you may want to send product recommendations along with them. In
    this case, it will be useful to consider the purchase history of customers, such
    as what kinds of products they have purchased, what product pages they have viewed
    online, or what products they have put in the cart. Using this information, we
    can build personalized product recommendations that are different for each customer
    using the item-based collaborative filtering algorithm.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前基于单个项目推荐产品的例子基础上，我们还可以为多个项目构建基于项目的协同过滤推荐系统。特别是当您可能正在发送营销邮件或新闻通讯时，您可能希望随邮件或通讯发送产品推荐。在这种情况下，考虑客户的购买历史将很有用，例如他们购买过哪些产品，他们在线查看过哪些产品页面，或者他们放入购物车中的产品。使用这些信息，我们可以利用基于项目的协同过滤算法为每位客户构建个性化的产品推荐，这些推荐对每位客户都是不同的。
- en: 'Using our example dataset as an example, let’s assume a customer has bought
    three items with product codes `23166`, `22720`, and `23243`. These items on our
    dataset are `SET OF 3 CAKE TINS PANTRY DESIGN`, `MEDIUM CERAMIC TOP STORAGE JAR`,
    and `SET OF TEA COFFEE SUGAR TINS PANTRY`. You can get the top 10 most similar
    items for these items using the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的示例数据集为例，假设一位客户购买了三个产品，产品代码分别为“23166”、“22720”和“23243”。在我们的数据集中，这些项目是“3个蛋糕托盘储物设计套装”、“中号陶瓷顶盖储物罐”和“茶咖啡糖罐储物套装”。您可以使用以下代码为这些项目获取最相似的10个项目：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see from this code, we query the item-to-item matrix for those three
    items that the customer has bought and take the mean of the cosine similarities.
    Then, we sort these average values in descending order to get the top 10 most
    similar items to the given 3 items. The output should look like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下代码中看到的，我们查询了客户购买的那3个物品的物品到物品矩阵，并计算了余弦相似度的平均值。然后，我们将这些平均值按降序排序，以获取给定3个物品的最相似的前10个物品。输出应如下所示：
- en: '![](img/B30999_07_15.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_15.png)'
- en: 'Figure 7.15: Top 10 similar items to the given 3 items'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：与给定3个物品最相似的10个物品
- en: 'Excluding the items that were already bought, product `22722` comes first and
    is the most similar item to the given itemset, and `23165` follows the second.
    We can query the data to get the product descriptions of these top 10 similar
    items. Take a look at the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 排除已经购买的商品，产品`22722`排在第一位，是与给定项目集最相似的物品，其次是`23165`。我们可以查询数据以获取这些最相似的前10个物品的产品描述。请看以下代码：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we exclude the 3 items that the customer has already bought from the
    recommendation list and retrieve the top 10 items that are the most similar or
    the most frequently bought together with these 3 items. The output of this query
    should look like the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从推荐列表中排除了客户已经购买的那3个物品，并检索了与这3个物品最相似或最常一起购买的顶级10个物品。此查询的输出应如下所示：
- en: '![](img/B30999_07_16.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_07_16.png)'
- en: 'Figure 7.16: Top 10 similar items to the given 3 items'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：与给定3个物品最相似的10个物品
- en: As you can imagine, these product recommendations based on the item-based collaborative
    filtering algorithm results can be used for any marketing campaign. If you are
    building an email marketing campaign, you can run this item-based collaborative
    filtering algorithm to select the top similar products based on previous purchases,
    page views, or cart items and include them as part of the marketing emails. You
    can also have pop-up windows on web pages for when this user logs into your online
    page next time. Giving discounts or some other promotions on these items can also
    result in higher chances of conversions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，这些基于物品协同过滤算法结果的产品推荐可以用于任何营销活动。如果您正在构建电子邮件营销活动，您可以使用这个基于物品的协同过滤算法来选择基于先前购买、页面浏览或购物车项目的前相似产品，并将它们作为营销电子邮件的一部分。您还可以在网页上设置弹出窗口，以便当用户下次登录您的在线页面时使用。对这些商品提供折扣或其他促销活动也可以提高转换率。
- en: There are numerous ways you can apply user-based and item-based collaborative
    filtering for recommendation systems. It will be wise to keep track of how your
    recommendations perform and tune how you use them as you progress with your recommendation
    systems. You will most likely want to track, of those items that you have recommended,
    how many of them have converted.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以多种方式应用基于用户和基于物品的协同过滤来构建推荐系统。随着您在推荐系统中的进展，跟踪您的推荐表现并调整您对它们的使用方式将是明智的。您很可能会想要跟踪您推荐的项目中有多少已经转换。
- en: As discussed in *Chapter 2* when we discussed KPIs, tracking conversion and
    other KPIs among the recommended items can tell you the effectiveness of your
    recommendation systems and which approach works better.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第2章中讨论KPI时所述，跟踪推荐项目中的转换和其他KPI可以告诉您您的推荐系统的有效性以及哪种方法更有效。
- en: Other frequently used recommendation methods
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他常用的推荐方法
- en: We have discussed the market basket analysis and collaborative filtering in
    depth for building personalized recommendation systems. However, there are various
    other ways these recommendation systems can be built. As previously mentioned,
    some of the common AI/ML-based approaches are association rules and collaborative
    filtering algorithms, which we have covered in this chapter; predictive modeling
    approaches are often used as well, and nowadays a hybrid of all these approaches
    is a typical method of building more comprehensive recommendation systems.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入讨论了市场篮子分析和协同过滤来构建个性化推荐系统。然而，还有许多其他方法可以构建这些推荐系统。如前所述，一些常见的基于AI/ML的方法是关联规则和协同过滤算法，这些我们在本章中已经介绍；预测建模方法也经常被使用，如今，所有这些方法的混合是构建更全面的推荐系统的典型方法。
- en: 'Not only are there AI/ML-driven approaches for recommendation systems but there
    can be various other ways to recommend products or content without even using
    AI/ML. The following are some common methods used for making recommendations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅存在AI/ML驱动的推荐系统方法，还可以有各种其他方式来推荐产品或内容，甚至无需使用AI/ML。以下是一些常用的推荐方法：
- en: '**Bestsellers or top views**: As the name suggests, recommendations based on
    the bestselling products or the most frequently viewed content are still used
    frequently. This helps new users or customers acquaint themselves with your products
    or platforms by easily viewing what others view or purchase the most on your platform.
    These can also be a great way to build your introductory marketing content.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**畅销书或热门观看**：正如其名所示，基于畅销产品或最常观看的内容的推荐仍然被频繁使用。这有助于新用户或客户通过轻松查看他人查看或购买最多的内容来熟悉您的产品或平台。这也可以是构建您的入门级营销内容的好方法。'
- en: '**Trending**: Similar to bestsellers, trending items show what is rising in
    popularity at a given moment. There can be some events, such as disasters in certain
    regions, breaking news at certain moments, or holiday events happening around
    the neighborhoods, that spike customer interest sporadically. It’s wise to adjust
    for these events as these special events trigger certain customer behaviors and
    can be great marketing opportunities.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**趋势**：与畅销书类似，趋势商品显示了在特定时刻流行的内容。可能会有一些事件，例如某些地区的灾难、特定时刻的突发新闻或社区周围的假日活动，这些事件会偶尔激发客户的兴趣。对这些事件进行调整是明智的，因为这些特殊事件会触发某些客户行为，并且可以成为极佳的营销机会。'
- en: '**New arrivals**: As marketers, you most likely would not want to miss an opportunity
    to promote new products. Customers, existing or new, are often attracted to new
    arrival items, and this can be a great marketing opportunity to retain existing
    customers, as well as gain new customers. By recommending new arrivals to customers
    who have shown interest in similar items, the marketing campaign can result in
    great success.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新品上市**：作为营销人员，您很可能不想错过推广新产品的机会。现有客户或新客户通常会被新品吸引，这可以是一个很好的营销机会，以保留现有客户，同时吸引新客户。通过向对类似商品表示过兴趣的客户推荐新品，营销活动可以取得巨大成功。'
- en: '**Promotions**: Not only can you recommend products or content by their popularity
    or relevance but you can also recommend products or content that are going on
    promotion. Customers are often attracted to special deals and you would want to
    expose and market special promotions as actively as possible. These are great
    ways to clear out overstocked inventories, raise brand awareness, bring in new
    customers, and retain inactive customers.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促销**：您不仅可以根据流行度或相关性推荐产品或内容，还可以推荐正在促销的产品或内容。客户通常会被特别优惠所吸引，您希望尽可能积极地展示和营销特别促销。这些是清理过剩库存、提高品牌知名度、吸引新客户和保留不活跃客户的好方法。'
- en: As you can see, there can be various ways you can build recommendation systems
    on top of utilizing AI/ML-driven methodologies. Given the competitive landscape
    and abundance of marketing campaigns basically by all businesses around the world,
    using only one approach in recommending products or content is not going to be
    that successful. The more comprehensive recommendation system you have, the more
    successful you will be in attracting and retaining customers. When you are designing
    recommendation systems, it would be wise to consider all the approaches mentioned
    in this chapter and apply them at the right moments and places.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您可以在利用AI/ML驱动的技术基础上，以多种方式构建推荐系统。鉴于竞争环境和全球范围内几乎所有企业进行的营销活动丰富多样，仅使用一种方法来推荐产品或内容不太可能取得成功。您拥有的推荐系统越全面，您在吸引和保留客户方面就越成功。在设计推荐系统时，明智的做法是考虑本章中提到的所有方法，并在适当的时间和地点应用它们。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed building personalized product recommendation systems.
    First, we discussed how to identify interrelationships between products by analyzing
    which itemsets are frequently bought together. We covered how to conduct market
    basket analysis in Python using the Apriori algorithm and association rules. Then,
    we dove deep into one of the AI/ML-driven approaches to building recommendation
    systems. We saw how user-based and item-based collaborative filtering algorithms
    can be used to identify similar users or items and products that are frequently
    bought together. In turn, these findings can then be used to recommend certain
    products that other customers are highly likely to be interested in and purchase.
    Lastly, we discussed various other approaches that can be used for recommending
    products and content. We showed how combining non-AI/ML approaches can result
    in a more comprehensive and diverse recommendation system.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了构建个性化产品推荐系统。首先，我们讨论了如何通过分析哪些项目集经常一起购买来识别产品之间的关系。我们介绍了如何使用 Apriori
    算法和关联规则在 Python 中进行市场篮子分析。然后，我们深入探讨了构建推荐系统的一种 AI/ML 驱动方法。我们看到了如何使用基于用户和基于物品的协同过滤算法来识别相似的用户或物品以及经常一起购买的产品。反过来，这些发现可以用来推荐其他客户很可能感兴趣并购买的产品。最后，我们讨论了可用于推荐产品和内容的各种其他方法。我们展示了如何结合非
    AI/ML 方法可以导致一个更全面和多样化的推荐系统。
- en: In the following chapter, we will continue our discussion around personalized
    and targeted marketing efforts. More specifically, we are going to cover how customer
    segmentations can be done in Python and why having an in-depth understanding of
    different customer segments within your customer base helps and affects the successes
    and failures of your marketing efforts.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论个性化的精准营销努力。更具体地说，我们将探讨如何在 Python 中进行客户细分，以及为什么深入了解您客户群中不同的客户细分有助于并影响您营销活动的成功与失败。
- en: Join our book’s Discord space
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们书籍的 Discord 空间
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 5000 members at:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区，与志同道合的人相聚，并在以下超过 5000 名成员的陪伴下学习：
- en: '[https://packt.link/genai](https://packt.link/genai)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/genai](https://packt.link/genai)'
- en: '![](img/QR_Code12856128601808671.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code12856128601808671.png)'
