- en: Linear and Logistic Regression
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性和逻辑回归
- en: After the insights we gained by grouping similar information using common features,
    it's time to get a bit more mathematical and start to search for a way to describe
    the data by using a distinct function that will condense a large amount of information,
    and will allow us to predict future outcomes, assuming that the data samples maintain
    their previous properties.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用共同特征对相似信息进行分组后，我们获得了洞察力，现在是时候稍微更数学化，开始寻找一种方法来使用一个独特的函数来描述数据，该函数将压缩大量信息，并允许我们预测未来的结果，假设数据样本保持其先前的属性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Linear regression with a step-by-step implementation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归的逐步实现
- en: Polynomial regression
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式回归
- en: Logistic regression and its implementation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑回归及其实现
- en: Softmax regression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Softmax回归
- en: Regression analysis
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归分析
- en: 'This chapter will begin with an explanation of the general principles. So,
    let''s ask the fundamental question: w*hat''s regression?*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从解释一般原则开始。那么，让我们提出一个基本问题：什么是回归？*
- en: Before all considerations, regression is basically a **statistical process*****.***
    As we saw in the introductory section, regression will involve a set of data that
    has some particular probability distribution. In summary, we have a population
    of data that we need to characterize.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有考虑因素之前，回归基本上是一个**统计过程**。正如我们在介绍部分所看到的，回归将涉及一组具有特定概率分布的数据。总之，我们有一组需要特征化的数据。
- en: And what elements are we looking for in particular, in the case of regression? We
    want to determine the relationship between an independent variable and a dependent
    variable that optimally adjusts to the provided data. When we find such a functionbetween
    the described variables, it will be called the **regression function**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在回归的情况下，我们特别寻找哪些元素？我们希望确定自变量和因变量之间的关系，该关系能够最佳地调整到提供的数据。当我们找到描述变量之间的这种函数时，它将被称为**回归函数**。
- en: There are a large number of function types available to help us model our current
    data, the most common example being the linear, polynomial, and exponential.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量函数类型可供我们帮助建模当前数据，最常见的例子是线性、多项式和对数。
- en: These techniques will aim to determine an objective function, which in our case
    will output a finite number of unknown optimum parameters of the function, called
    **parametric regression** techniques.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术旨在确定一个目标函数，在我们的情况下，它将输出函数的有限个未知最优参数，称为**参数回归**技术。
- en: Applications of regression
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归的应用
- en: Regression is normally applied in order to predict future variable values, and
    it's a very commonly employed technique for initial data modeling in data analysis
    projects, but it also can be used to optimize processes, finding common ground
    between related but dispersed data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回归通常用于预测未来的变量值，并且它是数据分析项目中初始数据建模的一个非常常用的技术，但它也可以用于优化流程，找到相关但分散的数据之间的共同点。
- en: 'Here we will list a number of the possible application of regression analysis:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将列出回归分析的一些可能的应用：
- en: In social sciences, to predict the future values of all kinds of metrics, such
    as unemployment and population
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在社会科学中，预测各种指标的未来的值，例如失业率和人口
- en: In economics, to predict future inflation rates, interest rates, and similar
    indicators
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在经济学中，预测未来的通货膨胀率、利率和类似指标
- en: In earth sciences, to predict future phenomena, such as the thickness of the
    ozone layer
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地球科学中，为了预测未来的现象，例如臭氧层的厚度
- en: To help with all elements of the normal corporate dashboard, adding probabilistic
    estimations for production throughput, earnings, spending, and so on
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助正常企业仪表盘的所有元素，添加生产吞吐量、收入、支出等的概率估计
- en: Proving the dependencies and relevancies between two phenomena
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明两种现象之间的依赖性和相关性
- en: Finding the optimum mix of components in reaction experiments
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在反应实验中找到成分的最优组合
- en: Minimizing the risk portfolio
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化风险投资组合
- en: Understanding how sensitive a corporation’s sales are to changes in advertising
    expenditure
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解一家公司的销售额对广告支出变化的敏感度
- en: Seeing how a stock's price is affected by changes to the interest rate
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看股票价格如何受到利率变化的影响
- en: Quantitative versus qualitative variables
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定量变量与定性变量
- en: 'In day-to-day work with data, not all the elements we encounter are the same,
    and thus they require special treatment, depending on their properties. A very
    important distinction we can make to recognize how appropriate the problem variables
    are is by dividing the data types into quantitative and qualitative data variables
    using the following criteria:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常数据工作中，我们遇到的所有元素并不都是相同的，因此它们需要根据其特性进行特殊处理。我们可以通过以下标准将数据类型划分为定量数据和定性数据变量，以识别问题变量是否适当：
- en: '**Quantitative variables**: In the realm of physical variables or measurements,
    we normally work with real numbers, or qualitative variables, because what matters
    the most is the quantity we are measuring. In this group, we have ordinal variables,
    that is, when we work with orders and rankings in an activity. Both of these variable
    types fall within the quantitative variables category.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定量变量**：在物理变量或测量的领域中，我们通常处理实数或定性变量，因为最重要的是我们测量的数量。在这个组中，我们有有序变量，即当我们在一个活动中处理顺序和排名时。这两种变量类型都属于定量变量类别。'
- en: '**Qualitative variables:** On the other hand, we have measurements that show
    which class a sample belongs to. This can''t be expressed by a number, in the
    sense of a quantity; it is usually assigned a label, tag, or categorical value
    representing the group to which the sample belongs. We call these variables qualitative
    variables.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定性变量**：另一方面，我们有显示样本属于哪个类别的测量。这不能以数量的方式表达；它通常被分配一个标签、标记或分类值，代表样本所属的组。我们称这些变量为定性变量。'
- en: '![](img/0a815a32-cec0-4afd-adbd-043f0be978dd.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a815a32-cec0-4afd-adbd-043f0be978dd.png)'
- en: Reference table addressing the differences between quantitative and qualitative
    analysis
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 针对定量和定性分析差异的参考表
- en: Now let's address the question of which types of variable are suitable to apply
    to regression problems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨哪些类型的变量适合应用于回归问题。
- en: The clear answer is quantitative variables, because the modeling of the data
    distribution can only be done through functions we use to detect a regular correspondence
    between those variables, and not on classes or types of elements. Regression requires
    one continuous output variable, which is only the case with quantitative metrics.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的答案是定量变量，因为数据分布的建模只能通过我们用来检测这些变量之间规律对应关系的函数来完成，而不是基于类别或元素类型。回归需要一个连续的输出变量，而这只有定量指标才能满足。
- en: In the case of qualitative variables, we assign the data to classification problems
    because the very definition of it is to search for non-numeric labels or tags
    to assign to a sample. This is the mission of classification, which we will see
    in the following chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于定性变量，我们将数据分配给分类问题，因为它的定义本身就是寻找非数字标签或标记来分配给样本。这是分类的任务，我们将在下一章中看到。
- en: Linear regression
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性回归
- en: So, it's time to start with the simplest yet still very useful abstraction for
    our data–a linear regression function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候开始使用我们数据中最简单但仍然非常有用的抽象——线性回归函数了。
- en: 'In linear regression, we try to find a linear equation that minimizes the distance
    between the data points and the modeled line. The model function takes the following
    form:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性回归中，我们试图找到一个线性方程，它最小化了数据点与模型线之间的距离。模型函数具有以下形式：
- en: y[i] = ßx[i] +α+ε[i]
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: y[i] = ßx[i] + α + ε[i]
- en: Here, *α* is the intercept and *ß* is the slope of the modeled line. The variable
    *x* is normally called the independent variable, and *y* the dependent one, but
    it can also be called the regressor and the response variables.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*α* 是模型的截距，*ß* 是模型线的斜率。变量 *x* 通常被称为自变量，而 *y* 被称为因变量，但它们也可以被称为回归变量和响应变量。
- en: The ε[i] variable is a very interesting element, and it's the error or distance
    from the sample *i* to the regressed line.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ε[i] 变量是一个非常有趣的元素，它是样本 *i* 到回归线的误差或距离。
- en: '![](img/7b75fbf6-d475-493d-91d9-c7426807bc65.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b75fbf6-d475-493d-91d9-c7426807bc65.png)'
- en: Depiction of the components of a regression line, including the original elements,
    the estimated ones (in red), and the error (ε)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 回归线组成部分的描述，包括原始元素、估计的元素（红色）和误差（ε）
- en: The set of all those distances, calculated in the form of a function called
    the *cost* function, will give us, as a result of the solution process, the values
    of the unknown parameters that minimize the cost. Let's get to work on it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些距离的集合，以称为 *成本* 函数的形式计算，作为求解过程的结果，将给出未知参数的值，这些值最小化了成本。让我们开始工作吧。
- en: Determination of the cost function
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成本函数的确定
- en: As with all machine learning techniques, the process of learning depends on
    a minimized loss function, which shows us how right or wrong we are when predicting
    an outcome, depending on the stage of learning we are in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有机器学习技术一样，学习过程依赖于一个最小化损失函数，它告诉我们当我们预测一个结果时，我们处于学习的哪个阶段，我们的预测是正确还是错误。
- en: The most commonly used cost function for linear regression is called *least
    squares*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归中最常用的成本函数被称为 *最小二乘法*。
- en: 'Let''s define this cost function taking, for simplification a 2D regression,
    where we have a list of number tuples *(x[0], y[0])*, *(x[1], y[1])* ... *(x[n],
    y[n])* and the values to find, which are *β[0]*  and *β[1]*. The least squares
    cost function in this case can be defined as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义这个成本函数，为了简化，我们考虑一个二维回归，其中我们有一个数字元组的列表 *(x[0], y[0])*, *(x[1], y[1])* ...
    *(x[n], y[n])* 以及要找到的值，即 *β[0]* 和 *β[1]*。在这种情况下，最小二乘成本函数可以定义为以下：
- en: '![](img/68886061-ae2a-4eb5-954c-92219745fc37.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68886061-ae2a-4eb5-954c-92219745fc37.png)'
- en: Least squares function for a linear equation, using the standard variables β[0]
    and β[1] that will be used in the next sections
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程的最小二乘函数，使用标准变量β[0]和β[1]，这些将在下一节中使用
- en: The summation for each of the elements gives a unique global number, which gives
    a global idea of the total differences between all the values (y[i]), and the
    corresponding point in our ideal regressing line (β[0] + β1*x*[i]).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个元素的求和给出一个唯一的全局数，这给出了所有值（y[i]）与我们的理想回归线（β[0] + β1*x*[i]）中相应点的总差异的全局概念。
- en: 'The rationale for this operation is pretty clear:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的原理非常清晰：
- en: The summation gives us a unique global number
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 求和给我们一个唯一的全局数
- en: The difference model-real point gives us the distance or L1 error
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-实际点之间的差异给出了距离或L1误差
- en: Squaring this gives us a positive number, which also penalizes distances in
    an non-linear way, passing the one-error limit, so the more errors we commit,
    the more willing we will be to increase our penalization rate
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其平方后，我们得到一个正数，这也会以非线性的方式惩罚距离，超过一个误差限制，因此我们犯的错误越多，我们越愿意增加我们的惩罚率
- en: Another way of phrasing this is that this process minimizes the sum of squared
    residuals, the residual being the difference between the value we get from the
    dataset and the expected value computed by the model, for the same input value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表述方式是，这个过程最小化了平方残差的和，残差是我们从数据集中得到的价值与模型计算出的预期价值之间的差异，对于相同的输入值。
- en: The many ways of minimizing errors
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化误差的多种方法
- en: 'The least squares error function has several ways of getting a solution:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘误差函数有几种得到解的方法：
- en: The analytical way
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析方法
- en: Using the covariance and correlation values
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协方差和相关性值
- en: The most familiar way to the machine learning family of methods — the gradient
    descent way
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于机器学习方法家族来说，最熟悉的方式——梯度下降法
- en: Analytical approach
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析方法
- en: The analytical approach employs several linear algebra techniques in order to
    get an exact solution.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 解析方法采用几种线性代数技术，以便得到精确的解。
- en: We are presenting this technique in a very succinct way because it's not directly
    related to the machine learning techniques we are reviewing in this book. We are
    presenting it for completeness.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以非常简洁的方式介绍这项技术，因为它与我们在这本书中回顾的机器学习技术没有直接关系。我们介绍它是为了完整性。
- en: 'First of all, we represent the error in a function in a matrix form:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们以矩阵形式表示误差：
- en: '![](img/a982ccbd-7d43-4efa-9f55-564990c6a257.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a982ccbd-7d43-4efa-9f55-564990c6a257.png)'
- en: Canonical form of the linear regression equation in the matrix form
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归方程的矩阵形式的规范形式
- en: 'Here, *J* is the cost function and has an analytical solution of:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*J* 是成本函数，具有以下解析解：
- en: '![](img/26ba2a70-39a9-468f-88f9-ab93374edb34.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26ba2a70-39a9-468f-88f9-ab93374edb34.png)'
- en: Analytical solution of the matrix form of linear regression
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归矩阵形式的解析解
- en: Pros and cons of the analytical approach
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析方法的优缺点
- en: The approach of using linear algebra techniques to calculate the minimum error
    solution is an easier one, given the fact that we can give a really simple representation
    that is deterministic, so there is no additional guessing involved after applying
    the operations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们可以给出一个简单且确定性的表示，使用线性代数技术来计算最小误差解法是一个更简单的方法，因此在进行操作后不需要额外的猜测。
- en: 'But there are some possible problems with this approach:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法可能存在一些问题：
- en: First, matrix inversion and multiplication are very computationally intensive
    operations. They typically have a lower bound of approximately *O(n²**)* to *O(n³)*,
    so when the number of samples increases, the problem can become intractable.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，矩阵求逆和乘法是非常计算密集的操作。它们通常有大约 *O(n²)* 到 *O(n³)* 的下限，因此当样本数量增加时，问题可能变得难以处理。
- en: Additionally, and depending on the implementation, this direct approach could
    also have limited accuracy, because we can normally use the limits of the floating
    point capacity of the current hardware.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，根据实现方式，这种直接方法也可能具有有限的精度，因为我们通常可以使用当前硬件浮点容量的限制。
- en: Covariance/correlation method
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协方差/相关方法
- en: Now it's time to introduce a new way of estimating the coefficient of our regressing
    line, and in the process, we will learn additional statistical measures, such
    as covariance and correlation, which will also help us when analyzing a dataset
    for the first time and drawing our first conclusions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍一种新的方法来估计回归线的系数了，在这个过程中，我们将学习额外的统计度量，如协方差和相关性，这些也将帮助我们第一次分析数据集并得出初步结论。
- en: Covariance
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协方差
- en: '**Covariance** is a statistical term, and can be canonically defined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**协方差**是一个统计术语，可以规范地定义为以下内容：'
- en: A measure of the systematic relationship between a pair of random variables
    wherein a change in one variable is reciprocated by an equivalent change in another
    variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一对随机变量之间系统关系的度量，其中一个变量的变化由另一个变量等效的变化所抵消。
- en: Covariance can take any value between -∞ to +∞, wherein a negative value is
    an indicator of a negative relationship, whereas a positive value represents a
    positive relationship. It also ascertains a linear relationship between the variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差可以取从 -∞ 到 +∞ 的任何值，其中负值表示负相关关系，而正值表示正相关关系。它还确定了变量之间的线性关系。
- en: Therefore, when the value is zero, it indicates no direct linear relationship,
    and the values tend to form a blob-like distribution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当值为零时，表示没有直接的线性关系，值倾向于形成类似团块状的分布。
- en: 'Covariance is not affected by the unit of measure, that is, there is no change
    in the strength of the relationship between two variables when changing units.
    Nevertheless, the value of covariance will change. It has the following formula,
    which needs the mean of each axis as a prerequisite:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差不受度量单位的影响，也就是说，当改变单位时，两个变量之间关系的强度不会改变。然而，协方差值会改变。它有以下公式，需要每个轴的平均值作为先决条件：
- en: '![](img/fa14cc01-27e4-4d77-b042-68aaa589d1cc.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa14cc01-27e4-4d77-b042-68aaa589d1cc.png)'
- en: Correlation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关系数
- en: 'Remember when we described the process of normalization of a variable? We centered
    the variable by subtracting the mean and scaling it with the standard deviation
    of the dataset with the following formula:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们描述变量标准化过程时吗？我们通过减去平均值并使用数据集的标准差进行缩放来使变量居中，以下公式：
- en: '![](img/3cf792e8-9f8e-456e-ae89-880e7c5e2ddb.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3cf792e8-9f8e-456e-ae89-880e7c5e2ddb.png)'
- en: Analytical form of the data normalization operation
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 数据标准化操作的解析形式
- en: This will be the starting point of our analysis, and we will be extending it
    towards each axis with the correlation value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的分析起点，我们将沿着每个轴扩展，使用相关值。
- en: 'The correlation value determines the degree to which two or more random variables
    move in tandem. During the study of two variables, if it has been observed that
    the movement of one variable is concordant with an equivalent movement in another
    variable, then the variables are said to be correlated, with the exact correlation
    value given by the following formula:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系值决定了两个或更多随机变量协同移动的程度。在研究两个变量时，如果观察到其中一个变量的移动与另一个变量等效的移动一致，则称这些变量是相关的，确切的相关值由以下公式给出：
- en: '![](img/0d9fb1b3-720a-4fd9-97fa-ef1a5326c698.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d9fb1b3-720a-4fd9-97fa-ef1a5326c698.png)'
- en: Canonical definition of correlation
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性的规范定义
- en: As a real value-based metric, it can be of two types, positive or negative.
    The variables are positively or directly correlated when the two variables move
    in the same direction. When the two variables move in opposite direction, the
    correlation is negative or inverse.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基于真实值的度量标准，它可以是两种类型，正或负。当两个变量朝同一方向移动时，变量是正相关的或直接相关的。当两个变量朝相反方向移动时，相关性是负的或逆的。
- en: 'The value of correlation lies between *-1* to *+1*, wherein values close to
    *+1* represent a strong positive correlation and values close to *-1* are an indicator
    of a strong negative correlation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数的值介于*-1*到*+1*之间，其中接近*+1*的值表示强烈的正相关，而接近*-1*的值是强烈负相关的指标：
- en: '![](img/0c75050d-fd72-437f-b0e2-21759ec14479.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c75050d-fd72-437f-b0e2-21759ec14479.png)'
- en: Graphic depiction of how the distribution of the samples affects the correlation
    values
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 样本分布如何影响相关值的图形描述
- en: There are other ways of measuring correlation. In this book, we will be talking
    mainly about linear correlation. There are other methods of studying non-linear
    correlation, which won't be covered in this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他测量相关性的方法。在这本书中，我们将主要讨论线性相关性。还有研究非线性相关性的其他方法，这些方法不会在本书中介绍。
- en: '![](img/ec163393-6f45-416d-bba8-1238a9438b08.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec163393-6f45-416d-bba8-1238a9438b08.png)'
- en: Depiction of the difference between linear correlation and non-linear correlation
    measures
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 线性相关性和非线性相关性度量之间的差异描述
- en: Within the practical exercises of this chapter, you will find an implementation
    of both linear covariance and correlation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的实践练习中，你将找到线性协方差和相关的实现。
- en: Searching for the slope and intercept with covariance and correlation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协方差和相关性搜索斜率和截距
- en: 'As we have known from the beginning, what we need is to find the equation of
    a line, representing the underlying data, in the following form:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们一开始就知道的，我们需要找到以下形式的表示底层数据的直线方程：
- en: '![](img/d10261e6-ae1e-43dd-9245-aed8cb9f4cde.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d10261e6-ae1e-43dd-9245-aed8cb9f4cde.png)'
- en: Approximate definition of a linear equation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程的近似定义
- en: 'As we know that this line passes through the average of all the points, we
    can estimate the intercept, with the only unknown being the estimated slope:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道这条线穿过所有点的平均值，我们可以估计截距，唯一未知的是估计的斜率：
- en: '![](img/63f6700e-7d98-4c47-b89e-f2d66fd10257.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63f6700e-7d98-4c47-b89e-f2d66fd10257.png)'
- en: Derived definition of intercept
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 截距的导出定义
- en: The slope represents the change in the dependent variable divided by the change
    in the independent variable. In this case, we are dealing with variation in data
    rather than absolute differences between coordinates.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 斜率表示因变量变化与自变量变化的比值。在这种情况下，我们处理的是数据的变化，而不是坐标之间的绝对差异。
- en: 'As the data is of non-uniform nature, we are defining the slope as the proportion
    of the variance in the independent variable that covaries with the dependent variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据是非均匀的，我们将斜率定义为与因变量协变的自变量方差的比率：
- en: '![](img/c12db851-a7b6-4b75-aca2-47ea376f313f.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c12db851-a7b6-4b75-aca2-47ea376f313f.png)'
- en: Estimated slope coefficient
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 估计斜率系数
- en: 'As it happens, if our data actually looks like a circular cloud when we plot
    it, our slope will become *zero*, suggesting no causal relationship between the
    variation in *x and *y*, *expressed in the following form:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好，如果我们绘制的数据看起来像圆形云，我们的斜率将变为*零*，这表明*x和y*的变化之间没有因果关系，以下形式表示：
- en: '![](img/c519abdc-078f-4cd4-aa61-4077e22947a9.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c519abdc-078f-4cd4-aa61-4077e22947a9.png)'
- en: Expanded form of the estimated slope coefficient
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 估计斜率系数的展开形式
- en: 'Applying the formulas we have shown previously, we can finally simplify the
    expression of the slope of the estimated regression line to the following expression:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们之前展示的公式，我们最终可以将估计回归线的斜率表达式简化为以下表达式：
- en: '![](img/4fde6a3d-5fab-4bb1-a91c-c7db6eda7d31.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4fde6a3d-5fab-4bb1-a91c-c7db6eda7d31.png)'
- en: Final form of the slope coefficient
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 斜率系数的最终形式
- en: Here, *S[y]* is the standard deviation in *y*, and *S[x]* is the standard deviation
    in *x.*
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*S[y]*是*y*的标准差，而*S[x]*是*x*的标准差。
- en: 'With the help of the remaining elements in the equation, we can simply derive
    the intercept based on the knowledge that the line will reach the mean dataset
    point:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程中剩余元素的帮助下，我们可以简单地根据直线将到达均值数据点的知识推导出截距：
- en: '![](img/c0d9968f-f485-406a-bd3b-5f974da7435c.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0d9968f-f485-406a-bd3b-5f974da7435c.png)'
- en: Final form of the approximated intercept coefficient
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 近似截距系数的最终形式
- en: So, we are done with a very summarized expression of two preliminary forms of
    regression, which have also left many analysis elements for us to use. Now it's
    time to introduce the star of the current machine learning techniques, one that
    you will surely use in many projects as a practitioner, called **gradient descent**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经完成了两种初步回归形式的非常简化的表达，这也为我们留下了许多分析元素。现在，是时候介绍当前机器学习技术的明星了，你作为从业者肯定会在许多项目中使用，称为**梯度下降**。
- en: Gradient descent
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 梯度下降
- en: It's time to talk about the method that will take us to the core of modern machine
    learning. The method explained here will be used with many of the more sophisticated
    models in a similar fashion, with increased difficulty but with the same principles.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候讨论将带我们进入现代机器学习核心的方法了。这里解释的方法将被用于许多更复杂的模型，以类似的方式使用，难度增加，但原理相同。
- en: Some intuitive background
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些直观的背景
- en: To introduce gradient descent, we will first take a look at our objective—the
    fitting of a line function to a set of provided data. And what do we have as elements?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍梯度下降，我们首先来看我们的目标——将线函数拟合到一组提供的数据。那么我们有哪些元素呢？
- en: A model function
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模型函数
- en: An error function
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个误差函数
- en: 'Another element that we could get is a representation of all the possible errors
    for any of the combinations of the parameters. That would be cool, right? But
    look at what such a function looks like just for a problem with a simple line
    as the solution. This curve represents *z= x² + y²*, which follows the form of
    the least squares error function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以得到的一个元素是所有可能误差的表示，对于任何参数组合。那会很好，对吧？但看看这样一个函数在只有一个简单直线作为解的问题中的样子。这个曲线代表的是
    *z= x² + y²*，它遵循最小二乘误差函数的形式：
- en: '![](img/a1b2619c-d444-44e4-bb91-5876156fa5ad.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1b2619c-d444-44e4-bb91-5876156fa5ad.png)'
- en: Least squares error surface, in the case of two variables. In the case of linear
    regression, they are the slope and the intersect
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个变量的情况下，最小二乘误差曲面。在线性回归的情况下，它们是斜率和交点
- en: 'As you can see, calculating all the possible outcomes per line parameter would
    consume too much CPU time. But we have an advantage: we know that the surface
    of such a curve is **c****onvex** (a discussion beyond the scope of this book),
    so it roughly looks like a bowl, and it has a unique minimum value (as seen in
    the previous folder). This will spare us the problem of locating local points
    that look like a minimum, but in fact are just bumps on the surface.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，计算每个线参数的所有可能结果会消耗太多的CPU时间。但我们有一个优势：我们知道这种曲线的表面是**凸**的（这超出了本书的范围），所以它大致看起来像一个碗，并且有一个唯一的最低值（如前一个文件夹中所示）。这将避免我们定位看似最小但实际上只是表面上的波峰的问题。
- en: The gradient descent loop
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 梯度下降循环
- en: 'So it''s time to look for a method to converge to the minimum of a function,
    knowing only where I am on the surface, and possibly the gradient at the point
    on the surface I am standing on:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是时候寻找一种方法来收敛到函数的最小值，只知道我在曲面上的位置，以及可能是我站立在曲面上的点的梯度：
- en: Start at a random position (remember, we don't know anything about the surface
    yet)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个随机位置开始（记住，我们对曲面一无所知）
- en: Look for the direction of maximum change (as the function is convex, we know
    it will guide us to the minimum)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最大变化的方向（因为函数是凸的，我们知道它会引导我们到最小值）
- en: Advance over the error surface in that direction, proportionally to the error
    amount
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着误差表面朝那个方向前进，与误差量成比例
- en: Adjust the starting point of the next step to the new point on the surface where
    we landed and repeat the process
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将下一步的起点调整到我们着陆的曲面上的新点，并重复这个过程
- en: This method allows us to discover the path for the minimization of our values
    in an iterative way and in a limited time, when compared to a brute force method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们以迭代的方式，在有限的时间内发现我们值最小化的路径，与暴力方法相比。
- en: 'The process for two parameters and the least squares function goes like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个参数和最小二乘函数的过程是这样的：
- en: '![](img/8b1ff442-6ed4-42e6-9ce5-eb2d53028ba7.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b1ff442-6ed4-42e6-9ce5-eb2d53028ba7.png)'
- en: Depiction of the gradient descent algorithm, Beginning from a starting high
    error point, and descending in the direction of maximum change
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降算法的描述，从起始的高误差点开始，沿着最大变化的方向下降
- en: This gives us an idea of how the process functions work in a normal setting,
    when we use and choose good and appropriate initial parameters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们对在正常设置下，当我们使用和选择良好且适当的初始参数时，过程是如何工作的有一个概念。
- en: In the upcoming chapters, we will cover the process of gradient descent in more
    detail, including how choosing different elements (that we will call hyper-parameters)
    changes the behavior of the process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地介绍梯度下降的过程，包括选择不同的元素（我们将称之为超参数）如何改变过程的行为。
- en: Formalizing our concepts
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正式化我们的概念
- en: Now let's go over the mathematical side of our process, so we have a reference
    of all the parts involved, before using them in practice.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们过程的数学方面，这样我们就有了一个参考，在将它们用于实践之前，了解所有涉及的各个部分。
- en: 'The elements or our equations are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方程的元素如下：
- en: The linear function variables, *β*[*0*] and *β[1]*
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性函数变量，*β*[*0*] 和 *β[1]*
- en: The number of samples in the sampleset, *m*
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本集中的样本数量，*m*
- en: The different elements in the sampleset, *x^((i))* and *y^((i))*
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本集中的不同元素，*x^((i))* 和 *y^((i))*
- en: 'Let''s start with our error function, *J*. It was defined in previous sections
    under the name of the least squares function. We will add, for practicality, the
    term 1/2m at the start of the equation, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的误差函数 *J* 开始，它在前面几节中被称为最小二乘函数。为了实用性，我们将在方程的开始处添加 1/2m 项，如下所示：
- en: '![](img/487739d9-a92a-4574-b71b-7a8f7976693c.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/487739d9-a92a-4574-b71b-7a8f7976693c.png)'
- en: Least squares error function
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘误差函数
- en: Let's introduce a new operator, which is the basis of all the following work,
    gradient.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一个新的运算符，这是所有后续工作的基础，即梯度。
- en: 'To build the concept of it, we have the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个概念，我们有以下内容：
- en: A function of one or more independent variables
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个独立变量的函数
- en: The partial derivative of the function for all independent variables
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有独立变量的函数的偏导数
- en: 'As we already know how partial derivatives work at the moment, it''s enough
    to say that the gradient is a vector containing all of the already mentioned partial
    derivatives; in our case, it will be as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们目前所知，如何计算偏导数，因此我们只需说梯度是一个包含所有已提到的偏导数的向量；在我们的情况下，它将如下所示：
- en: '![](img/aaf9f35f-f5c2-4095-88a8-921b55522b1d.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aaf9f35f-f5c2-4095-88a8-921b55522b1d.png)'
- en: Gradient of the error function
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 误差函数的梯度
- en: What's the purpose of such an operator? If we are able to calculate it, it will
    give us the direction of change of the whole function at a single point.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的运算符的目的是什么？如果我们能够计算它，它将给出整个函数在单一点上变化的方向。
- en: First, we calculate the partial derivative. You can try to derive it; basically,
    it uses the chain rule of deriving a squared expression and then multiplies it
    by the original expression.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算偏导数。你可以尝试推导它；基本上，它使用求导平方表达式的链式法则，然后乘以原始表达式。
- en: 'In the second part of the equation, we simplify the linear function by the
    name of the model function, *h[a]*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程的第二部分，我们通过模型函数 *h[a]* 的名称简化线性函数：
- en: '![](img/c81125f1-7fcb-4559-91a4-40788b068f26.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c81125f1-7fcb-4559-91a4-40788b068f26.png)'
- en: Partial derivative of the error function for the β[1] variable
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 β[1] 变量的误差函数的偏导数
- en: 'In the case of *β[1]* we get the additional factor of the *x^((i))* element
    because the derivative of *β[1]x*^(*(i)* )is *x^((i))*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 β[1] 的情况下，我们得到 *x^((i))* 元素的附加因子，因为 *β[1]x*^(*(i)* 的导数是 *x^((i))*：
- en: '![](img/5c6376e9-d5cd-4a6e-8629-82cd539945c7.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c6376e9-d5cd-4a6e-8629-82cd539945c7.png)'
- en: Partial derivative of the error function for the β[1] variable
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 β[1] 变量的误差函数的偏导数
- en: Now we introduce the recursion expression, which will provide (when iterating
    and if conditions are met) a combination of parameters that decrease the total
    error in a convergent way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们引入递归表达式，它将在迭代且条件满足的情况下提供一组参数，以收敛的方式减少总误差。
- en: 'Here, we introduce a really important element: the step size, with the name α.
    What''s the purpose of it? It will allow us to scale how much we will advance
    in one step. We will discover that not choosing the right amount of power can
    lead to disastrous consequences, including the divergence of the error to the
    infinite.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们引入一个非常重要的元素：步长，命名为 α。它的目的是什么？它将允许我们调整我们在每一步中前进的距离。我们将发现，如果没有选择正确数量的幂，可能会导致灾难性的后果，包括误差发散到无穷大。
- en: 'Note that the second formula only has the tiny difference of being multiplied
    by the current *x* value:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二个公式只有微小的差异，就是乘以当前的 *x* 值：
- en: '![](img/e90f1ce1-08a6-4af4-9111-125caf313f1a.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e90f1ce1-08a6-4af4-9111-125caf313f1a.png)'
- en: Recursion equation for the  model functions
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 模型函数的递归方程
- en: 'So, we are ready to go! Now we will just add a bit of mathematical spice in
    order to produce a more compact representation of the algorithm. Let''s now express
    the unknowns in vector form, so all the expressions will be expressed as a whole:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们准备出发了！现在我们只需添加一点数学调味料，以便产生算法的更紧凑表示。现在让我们以向量形式表示未知数，这样所有的表达式都将作为一个整体来表示：
- en: '![](img/f828048c-302b-4b06-a2c2-f67d83f54625.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f828048c-302b-4b06-a2c2-f67d83f54625.png)'
- en: Expression of β in vector form
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: β 的向量表示
- en: 'With this new expression, our recursion steps can be expressed in this simple
    and easy-to-remember expression:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的表达式，我们的递归步骤可以用这个简单且易于记忆的表达式来表示：
- en: '![](img/6ad85c8a-f5a5-432c-a237-d03e03297180.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ad85c8a-f5a5-432c-a237-d03e03297180.png)'
- en: Expression of the gradient descent recursion in vector form
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降递归的向量表示
- en: Expressing recursion as a process
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将递归表示为过程
- en: 'The whole method of finding the minimum error can alternatively be expressed
    in a flowchart, so that we can have all the elements in the same place and understand
    how easy it looks if we, for a moment don''t take into account the somewhat complex
    analytic mechanisms:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找最小误差的整个方法可以交替地用流程图表示，这样我们就可以将所有元素放在同一个地方，并理解如果我们暂时不考虑相对复杂的分析机制，它看起来是多么简单：
- en: '![](img/5b239fa1-5f80-47f7-bcf6-70b9f2ff0d7e.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b239fa1-5f80-47f7-bcf6-70b9f2ff0d7e.png)'
- en: Flow diagram of the gradient descent method. Note the simple building blocks,
    without taking into account the subtle mathematics it involves
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降方法的流程图。注意其简单的构建模块，没有考虑到它所涉及的微妙数学。
- en: 'So, with this last procedural vision of the gradient descent process, we are
    ready to go on to the more practical parts of this chapter. We hope you enjoyed
    this journey towards finding an answer to the question: What''s the best way to
    represent our data in a simple way? And rest assured we will use much more powerful
    tools in the following sections.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了这个关于梯度下降过程的最后程序性视角，我们准备继续本章更实用的部分。我们希望您喜欢这段寻找答案的旅程：我们如何以简单的方式表示我们的数据？请放心，在接下来的章节中，我们将使用更强大的工具。
- en: Going practical – new tools for new methods
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用性 - 新方法的新工具
- en: In this section, we will introduce a new library that will help us with covariance
    and correlation, especially in the data visualization realm.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个新库，它将帮助我们处理协方差和相关性，尤其是在数据可视化领域。
- en: What is **Seaborn**?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Seaborn** 是什么？'
- en: Seaborn is a library for making attractive and informative statistical graphics
    in Python. Moreover, it also provides very useful multivariate analysis primitives,
    which will help you decide whether or not and how to apply determinate regression
    analysis to your data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn 是一个用于在 Python 中创建吸引人且信息丰富的统计图形的库。此外，它还提供了非常有用的多元分析原语，这将帮助您决定是否以及如何将确定回归分析应用于您的数据。
- en: 'Some of the features that Seaborn offers are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn 提供的一些功能如下：
- en: Several built-in themes of very high quality
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种非常高质量的内置主题
- en: Tools for choosing color palettes to make beautiful plots that reveal patterns
    in the data
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择调色板以制作美丽图表的工具，这些图表可以揭示数据中的模式
- en: Very important functions for visualizing univariate and bivariate distributions
    or for comparing them between subsets of data
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于可视化单变量和双变量分布或比较数据子集之间分布的重要函数
- en: Tools that fit and visualize linear regression models for different kinds of
    independent and dependent variables
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合并可视化不同类型独立和依赖变量的线性回归模型的可视化工具
- en: Plotting functions which try to do something useful when called with a minimal
    set of arguments; they expose a number of customizable options through additional
    parameters
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用最小参数集调用时尝试做些有用的事情的绘图函数；它们通过额外的参数暴露出许多可定制的选项
- en: An important additional feature is, given that Seaborn uses matplotlib, the
    graphics can be further tweaked using those tools and rendered with any of the
    matplotlib backends.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的附加功能是，由于 Seaborn 使用 matplotlib，可以使用这些工具进一步调整图形，并使用 matplotlib 的任何后端进行渲染。
- en: Now let's explore the most useful utilities that Seaborn will bring.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索 Seaborn 将带来的最有用的实用工具。
- en: Useful diagrams for variable explorations – pairplot
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于变量探索的有用图表 - 对数图
- en: 'For the stage of data exploration, one of the most useful measures we can have
    is a graphical depiction of how all the features in the dataset interact, and
    discover the joint variations in an intuitive manner:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据探索阶段，我们可以拥有的最有用的度量之一是数据集中所有特征的交互关系的图形表示，并以直观的方式发现联合变化：
- en: '![](img/09c1ba22-b1bf-49f0-a9f6-c2ac41f11b70.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09c1ba22-b1bf-49f0-a9f6-c2ac41f11b70.png)'
- en: Pairplot for the variables in the Iris dataset
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Iris数据集中变量的对图
- en: Correlation plot
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关性图
- en: 'The correlation plot allows us to summarize the variable dependency in a much
    more succinct way, because it shows the direct correlation between variable pairs,
    using a color pallet. The diagonal values are of course 1, because all variables
    have a maximum correlation with themselves:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 相关性图允许我们以更简洁的方式总结变量之间的依赖关系，因为它使用颜色板显示了变量对之间的直接相关性。对角线值当然是1，因为所有变量都与自身具有最大相关性：
- en: '![](img/21467333-0c02-4339-9102-565e8c79026e.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21467333-0c02-4339-9102-565e8c79026e.png)'
- en: Correlation plot of the San Francisco housing dataset.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 旧金山住房数据集的相关性图
- en: Data exploration and linear regression in practice
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据探索和线性回归实践
- en: In this section, we will start using one of the most well-known *toy* datasets,
    explore it, and select one of the dimensions to learn how to build a linear regression
    model for its values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始使用最著名的*玩具*数据集之一，对其进行探索，并选择一个维度来学习如何为其值构建线性回归模型。
- en: 'Let''s start by importing all the libraries (`scikit-learn`, `seaborn`, and
    `matplotlib`); one of the excellent features of Seaborn is its ability to define
    very professional-looking style settings. In this case, we will use the `whitegrid`
    style:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入所有库（`scikit-learn`、`seaborn`和`matplotlib`）；Seaborn的一个优秀特性是它能够定义非常专业的样式设置。在这种情况下，我们将使用`whitegrid`样式：
- en: '[PRE0]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Iris dataset
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iris数据集
- en: 'It’s time to load the *Iris* dataset. This is one of the most well-known historical
    datasets. You will find it in many books and publications. Given the good properties
    of the data, it is useful for classification and regression examples. The Iris
    dataset ([https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris))
    contains 50 records for each of the three types of iris, 150 lines in a total
    over five fields. Each line is a measurement of the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候加载*Iris*数据集了。这是最著名的传统数据集之一。你会在许多书籍和出版物中找到它。鉴于数据的好性质，它对分类和回归示例非常有用。Iris数据集([https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris))包含三种鸢尾花类型各50条记录，总共有150行，分布在五个字段中。每一行都是以下测量值：
- en: Sepal length in cm
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花萼长度（单位：厘米）
- en: Sepal width in cm
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花萼宽度（单位：厘米）
- en: Petal length in cm
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣长度（单位：厘米）
- en: Petal width in cm
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣宽度（单位：厘米）
- en: 'The final field is the type of flower (*setosa*, *versicolor*, or *virginica*).
    Let’s use the `load_dataset` method to create a matrix of values from the dataset:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段是花的类型（*setosa*、*versicolor*或*virginica*）。让我们使用`load_dataset`方法从数据集中创建一个值矩阵：
- en: '[PRE1]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to understand the dependencies between variables, we will implement
    the covariance operation. It will receive two arrays as parameters and will return
    the `covariance(x,y)` value:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解变量之间的依赖关系，我们将实现协方差操作。它将接收两个数组作为参数，并返回`covariance(x,y)`值：
- en: '[PRE2]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s try the implemented function and compare it with the NumPy function.
    Note that we calculated `cov(a,b)`, and NumPy generated a matrix of all the combinations
    `cov(a,a)`, `cov(a,b)`, so our result should be equal to the values `(1,0)` and
    `(0,1)` of that matrix:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下实现的功能，并将其与NumPy函数进行比较。请注意，我们计算了`cov(a,b)`，而NumPy生成了一个包含所有组合`cov(a,a)`、`cov(a,b)`的矩阵，因此我们的结果应该等于该矩阵的`(1,0)`和`(0,1)`值：
- en: '[PRE3]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Having done a minimal amount of testing of the correlation function as defined
    earlier, receive two arrays, such as `covariance`, and use them to get the final
    value:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在对之前定义的关联函数进行最小测试后，接收两个数组，例如`covariance`，并使用它们来获取最终值：
- en: '[PRE4]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s test this function with two sample arrays, and compare this with the
    `(0,1)` and `(1,0)` values of the correlation matrix from NumPy:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用两个样本数组测试这个函数，并将其与NumPy的相关矩阵的`(0,1)`和`(1,0)`值进行比较：
- en: '[PRE5]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Getting an intuitive idea with Seaborn pairplot
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Seaborn对对图获得直观想法
- en: A very good idea when starting worked on a problem is to get a graphical representation
    of all the possible variable combinations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始解决问题时，获取所有可能变量组合的图形表示是一个非常不错的想法。
- en: Seaborn’s `pairplot` function provides a complete graphical summary of all the
    variable pairs, represented as scatterplots, and a representation of the univariate
    distribution for the matrix diagonal.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Seaborn的`pairplot`函数提供了所有变量对的一个完整的图形摘要，以散点图的形式表示，并在矩阵对角线上表示单变量分布。
- en: 'Let’s look at how this plot type shows all the variables dependencies, and
    try to look for a linear relationship as a base to test our regression methods:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种图表类型如何显示所有变量的依赖关系，并尝试寻找线性关系作为测试回归方法的基础：
- en: '[PRE6]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/00ae62c1-69b8-41b1-8105-3989b5102bdf.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00ae62c1-69b8-41b1-8105-3989b5102bdf.png)'
- en: Pairplot of all the variables in the dataset.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集中所有变量的对数图。
- en: 'Lets'' select two variables that, from our initial analysis, have the property
    of being linearly dependent. They are `petal_width` and `petal_length`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择两个变量，从我们的初步分析来看，它们具有线性依赖的性质。它们是`petal_width`和`petal_length`：
- en: '[PRE7]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s now take a look at this variable combination, which shows a clear linear
    tendency:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这个变量组合，它显示出明显的线性趋势：
- en: '[PRE8]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the representation of the chosen variables, in a scatter type graph:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所选变量的表示，在一个散点图类型中：
- en: '![](img/492acb6c-06e9-40f5-9a6c-9261ab328337.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/492acb6c-06e9-40f5-9a6c-9261ab328337.png)'
- en: This is the current distribution of data that we will try to model with our
    linear prediction function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将尝试用我们的线性预测函数建模的当前数据分布。
- en: Creating the prediction function
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建预测函数
- en: 'First, let''s define the function that will abstractedly represent the modeled
    data, in the form of a linear function, with the form *y=beta*x+alpha*:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个函数，它将以线性函数的形式抽象地表示建模数据，形式为*y=beta*x+alpha*：
- en: '[PRE9]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Defining the error function
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义误差函数
- en: 'It’s now time to define the function that will show us the difference between
    predictions and the expected output during training. As we will explain in depth
    in the next chapter, we have two main alternatives: measuring the absolute difference
    between the values (or L1), or measuring a variant of the square of the difference
    (or L2). Let’s define both versions, including the first formulation inside the
    second:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候定义一个函数，它将显示在训练过程中预测值与预期输出之间的差异。正如我们将在下一章中深入解释的，我们有两个主要的选择：测量值之间的绝对差异（或L1），或者测量差异平方的变体（或L2）。让我们定义两种版本，包括第一个公式在第二个公式中：
- en: '[PRE10]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Correlation fit
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关性拟合
- en: 'Now, we will define a function implementing the correlation method to find
    the parameters for our regression:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个函数来实现相关性方法，以找到回归的参数：
- en: '[PRE11]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s then run the fitting function and print the guessed parameters:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行拟合函数并打印猜测的参数：
- en: '[PRE12]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s now graph the regressed line with the data in order to intuitively show
    the appropriateness of the solution:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将绘制回归线与数据，以直观地显示解决方案的适当性：
- en: '[PRE13]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the final plot we will get with our recently calculated slope and intercept:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用最近计算出的斜率和截距得到的最终图：
- en: '![](img/0873604a-4bd0-4782-ac23-c86db29e98fa.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0873604a-4bd0-4782-ac23-c86db29e98fa.png)'
- en: Final regressed line.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最终回归线。
- en: Polynomial regression and an introduction to underfitting and overfitting
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项式回归以及欠拟合和过拟合的介绍
- en: When looking for a model, one of the main characteristics we look for is the
    power of generalizing with a simple functional expression. When we increase the
    complexity of the model, it's possible that we are building a model that is good
    for the training data, but will be too optimized for that particular subset of
    data.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找模型时，我们寻找的主要特征之一是使用简单的函数表达式进行泛化的能力。当我们增加模型的复杂性时，我们可能会构建一个对训练数据很好的模型，但对于那个特定数据子集来说可能过于优化。
- en: Underfitting, on the other hand, applies to situations where the model is too
    simple, such as this case, which can be represented fairly well with a simple
    linear model.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，欠拟合适用于模型过于简单的情况，例如这个案例，可以用一个简单的线性模型很好地表示。
- en: In the following example, we will work on the same problem as before, using
    the scikit-learn library to search higher-order polynomials to fit the incoming
    data with increasingly complex degrees.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将使用scikit-learn库来搜索更高阶的多项式，以使用越来越复杂的度数来拟合传入的数据。
- en: 'Going beyond the normal threshold of a quadratic function, we will see how
    the function looks to fit every wrinkle in the data, but when we extrapolate,
    the values outside the normal range are clearly out of range:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 超出二次函数的正常阈值，我们将看到函数如何拟合数据的每一个细节，但当我们将数据外推时，超出正常范围之外的值显然超出了范围：
- en: '[PRE14]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The combined graph shows how the different polynomials' coefficients describe
    the data population in different ways. The 20 degree polynomial shows clearly
    how it adjusts perfectly for the trained dataset, and after the known values,
    it diverges almost spectacularly, going against the goal of generalizing for future
    data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 合并图显示了不同的多项式系数如何以不同的方式描述数据总体。20次方的多项式清楚地显示了它如何完美地调整训练数据集，在已知值之后，它几乎以惊人的方式发散，违背了为未来数据泛化的目标。
- en: '![](img/bf696898-ba33-4679-a61a-b6eb42ed6443.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf696898-ba33-4679-a61a-b6eb42ed6443.png)'
- en: Curve fitting of the initial dataset, with polynomials of increasing values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 初始数据集的曲线拟合，使用递增值的多项式。
- en: Linear regression with gradient descent in practice
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的线性回归和梯度下降
- en: 'So now we are working with gradient descent techniques in practice for the
    first time! The concepts we are now practicing will serve us well during the rest
    of the book. Let''s start by importing the prerequisite library, as always. We
    will use NumPy for numeric processing, and Seaborn and matplotlib for representation:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们第一次在实践中使用梯度下降技术！我们现在正在练习的概念将在本书的其余部分为我们提供良好的服务。让我们首先导入必备的库，就像往常一样。我们将使用NumPy进行数值处理，以及Seaborn和matplotlib进行表示：
- en: '[PRE15]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The loss function will be the guide for us to know how well we are doing. As
    we saw in the theoretical section, the least squares method will be used.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 损失函数将是我们了解我们做得如何的指南。正如我们在理论部分所看到的，将使用最小二乘法。
- en: You can review the *J* or loss function definition and properties in the previous
    sections.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的章节中回顾*J*或损失函数的定义和属性。
- en: 'So, this `least_squares` function will receive the current regression line
    parameters, *b[0]* and b[0], and the data elements to measure how good our representation
    of reality is:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个`least_squares`函数将接收当前回归线的参数，即*b[0]*和*b[1]*，以及数据元素来衡量我们对现实表示的好坏：
- en: '[PRE16]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we will define each step of the recurrence. As parameters, we will receive
    the current *b*[0] and *b*[1], the points used to train the model, and the learning
    rate. On line five of the `step_gradient` function, we see the calculation of
    both gradients, and then we create the `new_b0` and `new_b1` variables, updating
    their values in the error direction, scaled by the learning rate. On the last
    line, we return the updated values and the current error level after all points
    have been used for the gradient:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义递归的每一步。作为参数，我们将接收当前的*b*[0]和*b*[1]，用于训练模型的点，以及学习率。在`step_gradient`函数的第5行，我们看到计算了两个梯度，然后我们创建了`new_b0`和`new_b1`变量，通过学习率按误差方向更新它们的值。在最后一行，我们在所有点都用于梯度后返回更新的值和当前误差水平：
- en: '[PRE17]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we define a function that will run a complete training outside the model
    so we can check all the combinations of parameters in one place. This function
    will initialize the parameters and will repeat the gradient step a fixed number
    of times:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个函数，将在模型外部运行完整的训练，这样我们就可以在一个地方检查所有参数的组合。这个函数将初始化参数，并将重复梯度步骤固定次数：
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This process could prove inefficient when the convergence rate is high, wasting
    precious CPU iterations. A more clever stop condition would consist of adding
    an acceptable error value, which would stop the iteration.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当收敛速度很高时，这个过程可能会证明效率低下，浪费宝贵的CPU迭代次数。一个更聪明的停止条件将包括添加一个可接受的误差值，这将停止迭代。
- en: 'Well, time to try our model! Let''s start loading the Iris dataset again, for
    reference, and as a means of checking the correctness of our results. We will
    use the `petal_width` and `petal_length` parameters, which we have already seen
    and decided they are good candidates for linear regression. The `dstack` command
    from NumPy allows us to merge the two columns, which we converted to a list to
    discard the column headers. The only caveat is that the resulting list has an
    unused extra dimension, which we discard using the `[0]` index selector:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是时候尝试我们的模型了！让我们再次加载Iris数据集，作为参考，并检查我们结果的正误。我们将使用`petal_width`和`petal_length`参数，我们已经看到并决定它们是线性回归的良好候选者。NumPy的`dstack`命令允许我们将两列合并，我们将它们转换为列表以删除列标题。唯一的缺点是生成的列表有一个未使用的额外维度，我们使用`[0]`索引选择器来丢弃它：
- en: '[PRE19]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, let''s try our model with what seem to be good initial parameters, a `0.0001`
    learning rate, initial parameters at `0`, and `1000` iterations; lets see how
    it behaves:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试我们的模型，使用看起来很好的初始参数，`0.0001`的学习率，初始参数在`0`，以及`1000`次迭代；看看它的表现如何：
- en: '[PRE20]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/1bddad51-5230-49f5-b989-aad474339736.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1bddad51-5230-49f5-b989-aad474339736.png)'
- en: 'Well, that''s bad; clearly, we are not yet there. Let''s see what happened
    with the error during training:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这不好；显然，我们还没有达到那里。让我们看看训练过程中的错误发生了什么：
- en: '[PRE21]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/c854daf0-1fef-458e-ab5a-507a2bd34a3d.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c854daf0-1fef-458e-ab5a-507a2bd34a3d.png)'
- en: 'The process seems to be working, but it''s a bit slow. Maybe we can try to
    increase the step by a factor of 10 to see if it converges quickly? Let''s check:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程看起来似乎在起作用，但有点慢。也许我们可以尝试将步长增加10倍，看看它是否快速收敛？让我们检查一下：
- en: '[PRE22]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/41808f98-370f-4132-824a-ac418872dc86.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41808f98-370f-4132-824a-ac418872dc86.png)'
- en: 'That was better! The process converges much more quickly. Let''s check how
    the regressed line looks now:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这比之前好多了！过程收敛得更快。让我们看看现在回归线的样子：
- en: '[PRE23]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](img/dace0203-d296-4d39-8683-b5beae83a51b.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dace0203-d296-4d39-8683-b5beae83a51b.png)'
- en: 'Yes! It looks much better. We could think we are done, but a developer always
    wants to go faster. Let''s see what would occur if we wanted to go faster, with
    an enormous step of `2`, for example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！看起来好多了。我们可能会认为我们已经完成了，但开发者总是希望更快。让我们看看如果我们想要更快，比如用巨大的步长`2`，会发生什么：
- en: '[PRE24]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](img/0ba9dc83-0d77-4b5c-9a5c-093df03947ea.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ba9dc83-0d77-4b5c-9a5c-093df03947ea.png)'
- en: 'This is a bad move; as you can see, the error finally went to infinity! What
    happens here? Simply, the steps we are taking are so radical that instead of slicing
    the imaginary bowl we described before, we are just jumping around the surface,
    and as the iterations advance, we began to escalate the accumulated errors without
    control. Another measure that could be taken is to improve our seed values, which,
    as you have seen started, with a value of `0`. This is a very bad idea in general
    for this technique, especially when you are working with data that is not normalized.
    There are more reasons for this, which you can find in more advanced literature.
    So, let''s try to initialize the parameter on a pseudo-random location in order
    to allow the graphics to be the same across the code examples, and see what happens:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个糟糕的举动；正如你所见，错误最终变成了无穷大！这里发生了什么？简单来说，我们采取的步骤太过激进，以至于我们并没有像之前描述的那样切割那个想象中的碗，而是在表面跳跃，随着迭代的进行，我们开始无法控制地累积错误。另一个可以采取的措施是改进我们的种子值，正如你所见，它从`0`开始。这在一般情况下对这个技术来说是一个非常糟糕的想法，尤其是在你处理未归一化的数据时。这里有更多原因，你可以在更高级的文献中找到。所以，让我们尝试在伪随机位置初始化参数，以便让代码示例中的图形保持一致，看看会发生什么：
- en: '[PRE25]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/6cd0d7cb-29fd-4ecd-8c3d-d72f9df03d12.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cd0d7cb-29fd-4ecd-8c3d-d72f9df03d12.png)'
- en: 'As you can see, even if you have the same sloppy error rate, the initial error
    value decreases tenfold (from 2e5 to 2e4). Now let''s try a final technique to
    improve the convergence of the parameters based on the normalization of the input
    values. As you have already studied in [Chapter 2](fa27740b-e9e0-4ad1-ab13-dfe57b30a956.xhtml), *The
    Learning Process,* it consists of centering and scaling the data. What''s the
    effect of that operation on the data? Using a graphical image, when data is not
    normalized, the error surface tends to be shallow and the values oscillate a lot.
    The normalization transforms that data into a more deep surface, with more definite
    gradients towards the center:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，即使你有相同的粗略错误率，初始错误值也减少了十倍（从2e5到2e4）。现在让我们尝试一种最终的技术来改进基于输入值归一化的参数收敛。正如你在[第二章](fa27740b-e9e0-4ad1-ab13-dfe57b30a956.xhtml)，“学习过程”中所学到的，它包括对数据进行中心化和缩放。这个操作对数据有什么影响？使用图形图像，当数据未归一化时，错误表面往往很浅，值波动很大。归一化将那些数据转换成一个更深层次的表面，有更明确的梯度指向中心：
- en: '[PRE26]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](img/35b4c6f1-dc4f-4b94-820d-f884d3b3a0e1.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35b4c6f1-dc4f-4b94-820d-f884d3b3a0e1.png)'
- en: 'Now that we have this set of clean and tidy data, let''s try again with the
    last slow convergence parameters, and see what happens to the error minimization
    speed:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这组干净整洁的数据，让我们再次尝试使用最后的慢收敛参数，看看错误最小化速度会发生什么：
- en: '[PRE27]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/fd5f8a31-a6a3-40d4-bfa7-a795cc34616d.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd5f8a31-a6a3-40d4-bfa7-a795cc34616d.png)'
- en: A very good starting point indeed! Just by normalizing the data, we have half
    the initial error values, and the error went down 20% after 1,000 iterations.
    The only thing we have to remember is to denormalize after we have the results,
    in order to have the initial scale and data center. So, that's all for now on
    gradient descent. We will be revisiting it in the next chapters for new challenges.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 确实是一个非常好的起点！仅仅通过归一化数据，我们就将初始错误值减少了一半，经过1,000次迭代后，错误下降了20%。我们唯一要记住的是，在得到结果后，我们需要去归一化，以便保持初始的尺度和数据中心。所以，关于梯度下降就到这里。我们将在下一章中重新讨论它，以面对新的挑战。
- en: Logistic regression
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑回归
- en: The way of this book is one of generalizations. In the first chapter, we began
    with simpler representations of the reality, and so simpler criteria for grouping
    or predicting information structures.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的方法之一是概括。在第一章中，我们从现实世界的简单表示开始，因此也开始了对信息结构进行分组或预测的简单标准。
- en: After having reviewed linear regression, which is used mainly to predict a real
    value following a modeled linear function, we will advance to a generalization
    of it, which will allow us to separate binary outcomes (indicating that a sample
    belongs to a class), starting from a previously fitted linear function. So let's
    get started with this technique, which will be of fundamental use in almost all
    the following chapters of this book.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了主要用于预测遵循建模线性函数的实值的线性回归之后，我们将进一步探讨其推广，这将使我们能够从先前拟合的线性函数开始，分离二元结果（表示一个样本属于一个类别）。因此，让我们开始这项技术，它将在本书的几乎所有后续章节中具有基本用途。
- en: Problem domain of linear regression and logistic regression
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性回归和逻辑回归的问题域
- en: To intuitively understand the problem domain of the logistic regression, we
    will employ a graphical representation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直观地理解逻辑回归的问题域，我们将使用图形表示。
- en: In the first we show the linear fitting function, which is the main objective
    of the whole model building process, and at the bottom, the target data distribution.
    As you clearly see, data is now of a binary nature, and a sample belongs to one
    or another options, nothing in the middle. Additionally, we see that the modelling
    function is of a new type; we will later name it and study its properties. You
    may wonder what this has it to do with a linear function? Well, as we will see
    later, it will be inside of that s-like function, adapting its shape.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们展示了线性拟合函数，这是整个模型构建过程的主要目标，底部是目标数据分布。正如你清楚地看到的，数据现在是二元的，一个样本属于一个或另一个选项，中间没有其他东西。此外，我们还看到建模函数是一种新型；我们稍后将命名并研究其特性。你可能想知道这与线性函数有什么关系？好吧，正如我们稍后将会看到的，它将位于那个s形函数内部，适应其形状。
- en: '![](img/08c9647f-ab32-48d8-8a56-c50c4190de98.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08c9647f-ab32-48d8-8a56-c50c4190de98.png)'
- en: Simplified depiction of the common data distributions where Linear or Logistic
    regression are applied.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的数据分布描述，其中应用了线性或逻辑回归。
- en: Summarizing, Linear regression can be imagined as a continuum of increasingly
    growing values. The other is a domain where the output can have just two different
    values based on the *x* value. In the particular case shown in the image, we can
    see a clear trend towards one of the possible outcomes, as the independent variable
    increases, and the sigmoid function allows us to transition from two outcomes,
    which don't have a clear separation in time, which gives us an estimated probability
    in the overlap zone of the non-occurrence/occurrence zone.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，线性回归可以想象为一个不断增长值的连续体。另一个领域是输出可以根据 *x* 值具有两个不同值的领域。在图像中显示的特定情况下，我们可以看到随着自变量的增加，向一个可能结果的趋势变得明显，而sigmoid函数使我们能够从两个在时间上没有明显分离的输出之间过渡，这给我们提供了一个在非发生/发生区域重叠区的估计概率。
- en: In some ways the terminology is a bit confusing, given that we are doing a regression
    that is obtaining a continuous value, but in reality, the final objective is building
    a prediction for a classification problem with discrete variables.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，术语有些令人困惑，因为我们正在进行回归，得到的是一个连续值，但现实中，最终目标是构建一个对离散变量分类问题的预测。
- en: The key here is to understand that we will obtain probabilities of an item pertaining
    to a class and not a totally discrete value.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于理解我们将获得一个项目属于一个类别的概率，而不是一个完全离散的值。
- en: Logistic function predecessor – the logit functions
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑函数的前身——对数几率函数
- en: Before we study the logistic function, we will review the original function
    on which it is based, the logit function, which gives it some of its more general
    properties.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究逻辑函数之前，我们将回顾其基础函数，即对数几率函数，它赋予它一些更一般的特性。
- en: Essentially, when we talk about the logit function, we are working with the
    function of a random variable *p*; more specifically, one corresponding with a
    Bernoulli distribution.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，当我们谈论对数几率函数时，我们是在处理随机变量 *p* 的函数；更具体地说，是与伯努利分布相对应的函数。
- en: Link function
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接函数
- en: As we are trying to build a **generalized linear model**, we want to start from
    a linear function and obtain a mapping to a probability distribution from the
    dependent variable.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在尝试构建一个**广义线性模型**，我们希望从一个线性函数开始，并从因变量获得一个映射到概率分布。
- en: Since the output type of our model is of a binary nature, the normally chosen
    distribution is the Bernoulli distribution, and the link function, leaning toward
    the logistic function, is the **logit function**.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们模型的输出类型是二进制的，通常选择的分布是伯努利分布，而链接函数，倾向于逻辑函数，是**logit 函数**。
- en: Logit function
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logit 函数
- en: 'One of the possible variables that we could utilize is the natural logarithm
    of the odds, that *p* equals one. This function is called the logit function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的可能变量之一是几率的自然对数，即 *p* 等于 1。这个函数被称为 logit 函数：
- en: '![](img/2ee45e25-bf32-4991-aad0-1ca557eab066.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ee45e25-bf32-4991-aad0-1ca557eab066.png)'
- en: We can also call the logit function a log-odd function, because we are calculating
    the log of the odds *(p/1-p)* for a given probability *p*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以称 logit 函数为对数几率函数，因为我们正在计算给定概率 *p* 的对数几率 *(p/1-p)*。
- en: Logit function properties
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logit 函数的性质
- en: So, as we can visually infer, we are replacing *x* with a combination of the
    independent variables, no matter their values, and replacing *x* with any occurrence
    from minus infinity to infinity. We are scaling the response to be between *0*
    and *1*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们可以直观推断的那样，我们用独立变量的组合替换 *x*，无论它们的值如何，并用任何从负无穷大到无穷大的出现替换 *x*。我们将响应缩放到 *0*
    到 *1* 之间。
- en: '![](img/580123ba-396c-452e-8ff2-5ad2f6b8979b.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/580123ba-396c-452e-8ff2-5ad2f6b8979b.png)'
- en: Depiction of the main range characteristics of the logit function
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Logit 函数的主要范围特性的描述
- en: The importance of the logit inverse
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logit 逆函数的重要性
- en: 'Suppose that we calculate the inverse of the logit function. The simple inverse
    transformation of the logit will give us the following expression:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们计算 logit 函数的逆。logit 的简单逆变换将给出以下表达式：
- en: '![](img/fadf7d1d-7327-4ac1-af90-14a2c064d5d7.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fadf7d1d-7327-4ac1-af90-14a2c064d5d7.png)'
- en: Analytical definition of the logit function
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Logit 函数的解析定义
- en: This function is nothing less than a **sigmoid function**.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数就是 Sigmoid 函数。
- en: The sigmoid or logistic function
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sigmoid 或逻辑函数
- en: 'The logistic function will represent the binary options we are representing
    in our new regression tasks. The logistic function is defined as follows (changing the
    independent variable from α to *t* for clarity):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑函数将代表我们在新的回归任务中要表示的二进制选项。逻辑函数定义为如下（为了清晰起见，将自变量从 α 改为 *t*）：
- en: '![](img/55f11a91-4e1a-4fc9-815c-d1c3a170bb38.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55f11a91-4e1a-4fc9-815c-d1c3a170bb38.png)'
- en: 'You will find this new figure common in the following sections, because it
    will be used very frequently as an activation function for neural networks and
    other applications. In the following figure, you will find the graphical representation
    of the sigmoid function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在以下章节中找到这个新图形很常见，因为它将被非常频繁地用作神经网络和其他应用的激活函数。在以下图中，你可以找到 Sigmoid 函数的图形表示：
- en: '![](img/f6177f95-f5bc-4103-8581-894a78bd5007.png)Standard sigmoid'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/f6177f95-f5bc-4103-8581-894a78bd5007.png)标准 Sigmoid'
- en: 'How can we interpret and give this function a meaning for our modeling tasks?
    The normal interpretation of this equations is that *t* represents a simple independent
    variable, but we will improve this model, assuming that *t* is a linear function
    of a single explanatory variable *x* (the case where *t* is a linear combination
    of multiple explanatory variables is treated similarly), expressing it as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解释并给这个函数赋予意义以用于我们的建模任务？这个方程的正常解释是 *t* 代表一个简单的自变量，但我们将改进这个模型，假设 *t* 是单个解释变量
    *x* 的线性函数（*t* 是多个解释变量的线性组合的情况类似处理），如下所示：
- en: '![](img/bc0dc978-01a0-44d4-a46e-efed47460598.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc0dc978-01a0-44d4-a46e-efed47460598.png)'
- en: 'So, we can start again from the original logit equation:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以再次从原始的 logit 方程开始：
- en: '![](img/7d527bcb-6f1d-4939-a9d8-43d56d3e170c.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d527bcb-6f1d-4939-a9d8-43d56d3e170c.png)'
- en: 'We will reach to the regression equation, which will give us the regressed
    probability with the following equation:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将到达回归方程，该方程将给出以下方程的回归概率：
- en: '![](img/0bd65ee9-f49d-45f8-8033-7480823ef98d.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bd65ee9-f49d-45f8-8033-7480823ef98d.png)'
- en: Note that *p* (hat) denotes an estimated probability. What will give us a measure
    of how approximate we are to the solution? Of course, a carefully chosen loss
    function!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*p*（帽）表示一个估计概率。什么将给我们一个如何接近解的度量？当然，一个精心选择的损失函数！
- en: 'The following image shows how the mapping from an infinite domain of possible
    outcomes which will be finally reduced to the *[0,1]* range, with *p* being the
    probability of the occurrence of the event being represented. This is shown in
    a simple schema, which is the  structure and domain transformation of the logit
    function (from a linear one to a probability modeled by a Sigmoid):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了从可能的无限结果域到最终被减少到 *[0,1]* 范围的映射，其中 *p* 是表示事件发生的概率。这在一个简单的方案中显示，这是 logit
    函数的结构和域转换（从线性到由 Sigmoid 模型的概率）：
- en: '![](img/d0643bfd-984e-4cb5-8beb-7adfc19ae8c1.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0643bfd-984e-4cb5-8beb-7adfc19ae8c1.png)'
- en: Function mapping for the logit of a linear equation, resulting in a sigmoid
    curve
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程的 logit 的函数映射，结果是一个 sigmoid 曲线
- en: What changes will affect the parameters of the linear function? They are the
    values that will change the central slope and the displacement from zero of the
    sigmoid function, allowing it to more exactly reduce the error between the regressed
    values and the real data points.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些变化将影响线性函数的参数？它们是那些将改变 sigmoid 函数的中心斜率和从零的位移的值，从而使它更精确地减少回归值与实际数据点之间的误差。
- en: Properties of the logistic function
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑函数的性质
- en: 'Every curve in the function space can be described by the possible objectives
    it could be applied to. In the case of the logistic function, they are as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 函数空间中的每一条曲线都可以用它可以应用到的可能目标来描述。在逻辑函数的情况下，它们如下所示：
- en: Model the probability of an event *p*, depending on one or more independent
    variables. For example, the probability of being awarded a prize, given previous
    qualifications
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据一个或多个独立变量建模事件 *p* 的概率。例如，根据先前资格获得奖项的概率
- en: Estimate (this is the regression part) *p* for a determined observation, related
    to the possibility of the event not occurring.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计（这是回归部分）与事件不发生的可能性相关的特定观测值的 *p*。
- en: Predict the effect of the change of independent variables using a binary response.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二元响应预测独立变量变化的影响。
- en: Classify observations by calculating the probability of an item being of a determined
    class.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过计算一个项目属于特定类的概率来对观测值进行分类。
- en: Multiclass application – softmax regression
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多类应用 - softmax 回归
- en: Up until now, we have been classifying in the case of only having two classes,
    or in probabilistic language, event occurrence probabilities *p*. But this logistic
    regression can also be conveniently generalized to account for many classes.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只对只有两个类别的情况进行分类，或者用概率语言来说，是事件发生的概率 *p*。但这个逻辑回归也可以方便地推广到许多类的情况。
- en: As we saw before, in logistic regression we assumed that the labels were binary
    (*y(i)∈{0,1})*, but softmax regression allows us to handle *y(i)∈{1,…,K}*, where
    *K* is the number of classes and the label *y* can take on *K* different values,
    rather than only two.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，在逻辑回归中，我们假设标签是二元的 (*y(i)∈{0,1}*)，但softmax 回归允许我们处理 *y(i)∈{1,…,K}*，其中
    *K* 是类别的数量，标签 *y* 可以取 *K* 个不同的值，而不仅仅是两个。
- en: 'Given a test input *x*, we want to estimate the probability that *P(y=k|x)* for
    each value of *k=1,…,K*. The softmax regression will make this output a *K*-dimensional
    vector (whose elements sum to 1), giving us our *K* estimated probabilities:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个测试输入 *x*，我们想要估计对于每个 *k=1,…,K* 的值，*P(y=k|x)* 的概率。softmax 回归将使这个输出成为一个 *K*-维向量（其元素之和为
    1），从而给出我们的 *K* 个估计概率：
- en: '![](img/ea26194c-e41f-48e6-8a94-de9c5a9e6376.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea26194c-e41f-48e6-8a94-de9c5a9e6376.png)'
- en: Comparison between the univariate logisic regression outcome and N classes softmax
    regression
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 单变量逻辑回归结果与 N 类 softmax 回归的比较
- en: Practical example – cardiac disease modeling with logistic regression
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际示例 - 使用逻辑回归进行心脏病建模
- en: It's time to finally solve a practical example with the help of the very useful
    logistic regression. In this first exercise, we will work on predicting the probability
    of having coronary heart disease, based on the age of the population. It's a classic
    problem, which will be a good start for understanding this kind of regression
    analysis.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候借助非常有用的逻辑回归来解决一个实际示例了。在这个第一个练习中，我们将基于人口年龄预测患有冠状动脉心脏病的概率。这是一个经典问题，将是理解这类回归分析的良好开端。
- en: The CHDAGE dataset
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CHDAGE 数据集
- en: For the first simple example, we will use a very simple and often studied dataset,
    which was published in *Applied Logistic Regression*, from *David W. Hosmer*,
    *Jr. Stanley Lemeshow and **Rodney X. Sturdivant*. We list the age in years (`AGE`)
    and the presence or absence of evidence of significant **coronary heart disease**
    (**CHD**) for 100 subjects in a hypothetical study of risk factors for heart disease.
    The table also contains an identifier variable (`ID`) and an age group variable
    (`AGEGRP`).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个简单的例子，我们将使用一个非常简单且经常研究的数据集，该数据集发表在《应用逻辑回归》中，由David W. Hosmer, Jr.、Stanley
    Lemeshow和**Rodney X. Sturdivant**所著。我们列出100个受试者的年龄（`AGE`）和是否存在显著**冠心病**（**CHD**）的证据，在一个假设的心脏病风险因素研究中。表格还包含一个标识变量（`ID`）和一个年龄组变量（`AGEGRP`）。
- en: The outcome variable is `CHD`, which is coded with a value of `0` to indicate
    that `CHD` is absent, or `1` to indicate that it is present in the individual.
    In general, any two values could be used, but we have found it most convenient
    to use zero and one. We refer to this dataset as the `CHDAGE` data.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 结果变量是`CHD`，用`0`表示`CHD`不存在，或用`1`表示它在个体中存在。一般来说，可以使用任何两个值，但我们发现使用零和一最为方便。我们将这个数据集称为`CHDAGE`数据。
- en: Dataset format
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据集格式
- en: The `CHDAGE` dataset is a two-column CSV file that we will download from an
    external repository. In the first chapter, we used native TensorFlow methods to
    read the dataset. In this chapter, we will alternatively use a complementary and
    popular library to get the data. The cause for this new addition is that, given
    that the dataset only has 100 tuples, it is practical to just read it in one line,
    and also, we can get simple but powerful analysis methods for free from the pandas
    library.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHDAGE`数据集是一个两列的CSV文件，我们将从外部仓库下载它。在第一章中，我们使用了原生的TensorFlow方法来读取数据集。在这一章中，我们将使用一个互补且流行的库来获取数据。新增这一部分的原因是，鉴于数据集只有100个元组，直接读取一行是实用的，而且我们还可以从pandas库中免费获得简单但强大的分析方法。'
- en: In the first stage of this project, we will start loading an instance of the
    `CHDAGE` dataset. Then we will print vital statistics about the data, and then
    proceed to preprocessing. After doing some plots of the data, we will build a
    model composed of the activation function, which will be a softmax function, for
    the special case where it becomes a standard logistic regression, that is, when
    there are only two classes (existence or not of the illness).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的第一阶段，我们将开始加载`CHDAGE`数据集的一个实例。然后我们将打印关于数据的关键统计数据，接着进行预处理。在绘制了一些数据图表之后，我们将构建一个由激活函数组成的模型，该激活函数将是一个softmax函数，对于它变成标准逻辑回归的特殊情况，即当只有两个类别（疾病的有无）时。
- en: 'Let''s start by importing the required libraries:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入所需的库：
- en: '[PRE29]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s read the dataset from the CSV original file using `read_csv` from pandas,
    and draw the data distribution using the scatter function of matplotlib. As we
    can see, there is a definite pattern through the years that correlates to the
    presence of cardiac disease with increasing age:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用pandas的`read_csv`函数从CSV原始文件中读取数据集，并使用matplotlib的散点函数绘制数据分布。正如我们所看到的，通过年份，确实存在一种与随着年龄增长而出现的冠心病相关的模式：
- en: '[PRE30]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is the current plot of the original data:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原始数据的当前图表：
- en: '![](img/5f4526d5-8e60-43e6-830f-fecc8d7db99c.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f4526d5-8e60-43e6-830f-fecc8d7db99c.png)'
- en: 'Now we will create a logistic regression model using the logistic regression
    object from scikit-learn, and then we will call the `fit` function, which will
    create a sigmoid optimized to minimize the prediction error for our training data:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用scikit-learn的逻辑回归对象创建一个逻辑回归模型，然后调用`fit`函数，该函数将创建一个sigmoid函数，以最小化我们的训练数据的预测误差：
- en: '[PRE31]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now it's time to represent the results. Here, we will generate a linear space
    from 10 to 90 years with 100 subdivisions.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是展示结果的时候了。在这里，我们将从10岁到90岁生成一个线性空间，包含100个细分。
- en: For each sample of the domain, we will show the probability of occurrence (1)
    and not occurrence (0, or the inverse of the previous one).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '对于域的每个样本，我们将展示发生概率（1）和不发生概率（0，或前一个值的逆）。 '
- en: 'Additionally, we will show the predictions along with the original data points,
    so we can match all the elements in a single graphic:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将展示预测结果以及原始数据点，这样我们就可以在单个图形中匹配所有元素：
- en: '[PRE32]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/73dd7c53-d8cc-4c9a-afe2-a8b01d1e1c8c.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73dd7c53-d8cc-4c9a-afe2-a8b01d1e1c8c.png)'
- en: Simultaneous plot of the original data distribution, the modeling logistic curve,
    and its inverse
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据分布、建模逻辑曲线及其逆函数的同步绘图
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've reviewed the main ways to approach the problem of modeling
    data using simple and definite functions.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了使用简单和确定性的函数来建模数据的主要方法。
- en: In the next chapter, we will be using more sophisticated models that can reach
    greater complexity and tackle higher-level abstractions, and can be very useful
    for the amazingly varied datasets that have emerged recently, starting with simple
    **feedforward networks**.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用更复杂的模型，这些模型可以达到更高的复杂性，处理更高级的抽象，并且对于最近出现的各种各样的大量数据集非常有用，从简单的**前馈网络**开始。
- en: References
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Galton, Francis, "*Regression towards mediocrity in hereditary stature.*" The
    Journal of the Anthropological Institute of Great Britain and Ireland 15 (1886):
    246-263.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 高尔顿，弗朗西斯，"*遗传身高的回归到中等水平*"。《大不列颠及爱尔兰人类学学会杂志》第15卷（1886年）：246-263。
- en: 'Walker, Strother H., and David B. Duncan, "*Estimation of the probability of
    an event as a function of several independent variables.*" Biometrika 54.1-2 (1967):
    167-179.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 沃克，斯特罗瑟·H.，和大卫·B.邓肯，"*将事件概率作为几个独立变量的函数进行估计*"。《生物计量学》第54卷第1-2期（1967年）：167-179。
- en: 'Cox, David R, "*The regression analysis of binary sequences.*" Journal of the
    Royal Statistical Society. Series B (Methodological)(1958): 215-242.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 科克斯，大卫·R，"*二元序列的回归分析*"。《皇家统计学会会刊。方法系列》（1958年）：215-242。
