- en: Machine Learning Services with R for DBAs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为DBAs提供的R机器学习服务
- en: R integration (along with Python integration in SQL Server 2017) offered a wide
    range of possibilities that one can use. And the targeted group of people has
    just increased in terms of people (job roles or departments) using R Services.
    DBAs (and also SysAdmins) will for sure gain a lot from this. Not only do R and
    statistics give them some additional impetus for discovering and gaining insights
    on their captured data, but also they might help them to find some hidden nuggets
    that they might have missed before. The mixture of different languages-and I am
    not solely talking about R, but also other languages-for sure bring new abilities
    to track, capture, and analyze captured data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: R集成（以及SQL Server 2017中的Python集成）提供了一系列可以使用的机会。而且，使用R服务的人群在人数（工作角色或部门）方面已经增加。DBAs（以及系统管理员）肯定会从中受益良多。R和统计学不仅为他们发现和深入了解他们捕获的数据提供了额外的动力，而且也可能帮助他们找到他们之前可能错过的隐藏宝藏。不同语言的混合——我不仅是在谈论R，还包括其他语言——无疑为跟踪、捕捉和分析捕获数据带来了新的能力。
- en: One thing is clear, if you have R (any Python) so close to the database, several
    people can switch from monitoring tasks to predicting tasks. This literally means
    that instead of taking actions when something has already happened, people can
    now diagnose and predict what might happen. I'm not saying this is an easy task,
    since we all know that the complexity, for example, of one query all of a sudden
    running slow, can have one or more hidden reasons, that might not be seen immediately,
    R in-database will for sure help find this hidden reason in near real time. Contrary
    to data-mining in SSAS, which in my personal opinion is still a very strong and
    good tool, there might be more  latency in comparison to sending and analyzing
    data through R Engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一件事很清楚，如果你有R（任何Python）如此接近数据库，那么几个人可以从监控任务切换到预测任务。这实际上意味着人们现在可以诊断和预测可能会发生的事情，而不仅仅是当事情已经发生时采取行动。我并不是说这是一项容易的任务，因为我们都知道，例如，一个查询突然运行缓慢的复杂性可能有一个或多个隐藏的原因，这些原因可能不会立即被发现，R在数据库中的集成将肯定有助于在近实时中找到这个隐藏的原因。与SSAS中的数据挖掘相比，在我看来，它仍然是一个非常强大和好的工具，但与通过R引擎发送和分析数据相比，可能会有更多的延迟。
- en: 'This chapter will capture the important steps on how to help DBAs (or other
    roles to tackle similar issues) to get the advantages of R:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将概述如何帮助DBAs（或其他角色处理类似问题）获取R的优势的重要步骤：
- en: Gathering data relevant for DBAs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集对数据库管理员（DBAs）相关的数据
- en: Exploring and analyzing data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和分析数据
- en: Creating predictions with R Services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R服务创建预测
- en: Improving monitoring with predictions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过预测改进监控
- en: Gathering relevant data
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集相关数据
- en: Gathering data - simple as it might be - is a task that needs to be well crafted.
    There are a few reasons for that. The first and most important is that we want
    to gather data in a way that will have minimum or zero impact on the production
    environment. This means that the process of collecting and storing data should
    not disturb any on-going process. The second important thing is storage. Where
    and how do you want to store the data and the retention policy of the stored data?
    At the beginning, this might seem a very trivial case, but over time, storage
    itself will play an important role. The third and also utterly important thing
    is which data you want to gather. Of course, we all want to have smart data present,
    that is, having all the data relevant for solving or improving our business processes.
    But in reality, gathering smart is neither that difficult nor that easy. First
    of all, one must understand the concept of the database feature and furthermore,
    how to capture the relevant indicators and how this particular feature will work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 收集数据——尽管这可能很简单——是一项需要精心设计的任务。这有几个原因。首先也是最重要的原因是，我们希望以对生产环境影响最小或零的方式收集数据。这意味着收集和存储数据的过程不应干扰任何正在进行的流程。第二重要的是存储。你希望在何处以及如何存储数据，以及存储数据的保留策略？一开始，这可能会显得非常微不足道，但随着时间的推移，存储本身将扮演一个重要的角色。第三，也是绝对重要的，是你想要收集哪些数据。当然，我们都希望拥有智能数据，也就是说，拥有所有与解决或改进我们的业务流程相关的数据。但在现实中，收集智能数据既不困难也不容易。首先，必须理解数据库功能的概念，而且还要了解如何捕捉相关指标以及这个特定功能将如何运作。
- en: Let's see where and how one can see performance improvements, if you know where
    and how to look for them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在哪里以及如何可以看到性能改进，如果你知道如何寻找它们的话。
- en: For example, delayed durability is a feature that has been in SQL Server since
    SQL Server 2014, but can in some scenarios help improve performance for compromising
    the durability (durability is part of the ACID acronym-atomic, consistent, isolation,
    and durability-and prevents, in the case of a failure or system restart, committed
    data from not being saved or saved in an incorrect state). **Write-ahead log**
    (**WAL**) is a system that SQL Server uses, which means that all the changes are
    written to the log first, before they are allowed to be committed to the database
    table.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，延迟耐久性是自SQL Server 2014以来SQL Server就有的一个功能，但在某些场景下可以帮助提高性能，但会牺牲耐久性（耐久性是ACID（原子性、一致性、隔离性和耐久性）的一部分，防止在发生故障或系统重启时，已提交的数据没有被保存或保存到错误的状态）。**写入前日志（WAL**）是SQL
    Server使用的一个系统，这意味着所有更改首先写入日志，然后才允许它们提交到数据库表。
- en: 'For this quick demo, we will create an empty database with `DELAYED_DURABILITY`
    set to allowed with `NO_WAIT`. An additional and important step to this test is
    to set the backup of the database to `NUL`, which is similar to the command `with
    truncate_only`. This statement discards any inactive logs (when the database is
    in full or bulk-logged recovery mode; for simple recovery mode, this does not
    hold water) and from the point when a full backup of the database is done, any
    inactive log records get discarded (deleted). This could be simulated. When a
    checkpoint runs, the attempt to back up the log will result in an error message.
    In other words, a database could be running in simple recovery mode. Essentially,
    the `NUL` command simply stores and discards the log:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个快速演示，我们将创建一个空数据库，将`DELAYED_DURABILITY`设置为允许，并设置为`NO_WAIT`。这个测试的一个重要步骤是将数据库的备份设置为`NUL`，这与`with
    truncate_only`命令类似。这个语句丢弃任何非活动日志（当数据库处于完全或批量日志恢复模式时；对于简单恢复模式，这并不适用）以及从数据库完成完全备份的那一刻起，任何非活动日志记录都会被丢弃（删除）。这可以被模拟。当检查点运行时，尝试备份日志将导致错误消息。换句话说，数据库可能正在以简单恢复模式运行。本质上，`NUL`命令只是存储和丢弃日志：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I will create a sample table to do the inserts:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个示例表来进行插入：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Having created a table, we can now test two types of insert, with and without
    delayed durability:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了表之后，我们现在可以测试两种类型的插入，带有延迟耐久性和不带延迟耐久性：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And the result is obvious: with the delayed durability set to on, one can gain
    in performance when doing so many inserts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结果很明显：将延迟耐久性设置为开启时，在进行大量插入时可以提高性能：
- en: '![](img/00154.gif)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00154.gif)'
- en: 'I could have also used the query stress to simulate several threads, each doing
    the same number of inserts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以使用查询压力来模拟多个线程，每个线程执行相同数量的插入：
- en: '![](img/00155.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00155.jpeg)'
- en: 'And with such heavy stress tool testing, the question is, How can we monitor
    and track the behavior of the delayed durability? One can test the performance
    with the performance monitor:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种重压下的工具测试中，问题是，我们如何监控和跟踪延迟耐久性的行为？一个人可以通过性能监控器来测试性能：
- en: '![](img/00156.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00156.jpeg)'
- en: 'Alternatively, you can test the performance with the activity monitor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用活动监控器来测试性能：
- en: '![](img/00157.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00157.jpeg)'
- en: But soon you will realize that either you need to store this information for
    later analysis or you need to get some additional know-how as to, which performance
    pointers or extended events are worth monitoring in this case.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但很快你就会意识到，你可能需要存储这些信息以供后续分析，或者你需要获取一些额外的知识，了解在这种情况下哪些性能指标或扩展事件值得监控。
- en: 'So, in this case, you will need to check the wait resources on logging in:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，你需要在登录时检查等待资源：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will also need to either add some mechanism to capture those wait statistics
    in a table for later analysis or capture the performance monitor or use profiler,
    XE, and others. Querying data in runtime and capturing statistics is rather tedious
    job; imagine merging statistics from `sys.dm_os_wait_stats` and combining them
    with `sys.dm_io_virtual_file_stats`. All in all the, more data you try to gather,
    the more complicated querying these statistics might becomes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要添加一些机制来捕获这些等待统计信息到一个表中，以供后续分析，或者捕获性能监控器或使用分析器、XE等。在运行时查询数据并捕获统计信息是一项相当繁琐的工作；想象一下将`sys.dm_os_wait_stats`中的统计信息合并并与`sys.dm_io_virtual_file_stats`结合。总的来说，你试图收集的数据越多，查询这些统计信息可能就越复杂。
- en: 'Capturing with performance monitor of both queries from earlier, the picture
    looks as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用性能监控器捕获之前两个查询的结果，截图如下所示：
- en: '![](img/00158.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00158.jpeg)'
- en: The above screenshot shows, on the left-hand side (1), how delayed durability
    is working and how log flushing is happening in a sequential period of time. Comparing
    this to the right-hand side (2), we can see how delayed durability is turned off
    and log flushing is not active.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了左侧（1）延迟持久性如何工作以及日志刷新如何在一段时间内按顺序发生。与右侧（2）相比，我们可以看到延迟持久性被关闭且日志刷新不活跃。
- en: Extracting raw data from the performance monitor may not be the right approach,
    but storing the same set of data through extended events will be much more lightweight
    on the system, as well as the users, for later analysis.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能监视器中提取原始数据可能不是正确的方法，但通过扩展事件存储相同的数据集对系统以及用户来说将更加轻量，便于后续分析。
- en: 'Setting up the extended event you will need for your analysis can be done fast
    and easily. But rather than choosing too many events, focus on the ones that are
    really needed, because, the log file might get big very quickly:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您分析所需的扩展事件可以快速且轻松完成。但与其选择过多的事件，不如专注于真正需要的那些，因为日志文件可能会很快变得很大：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After starting the event, read the content of the file by breaking down the
    XML structure:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动事件后，通过分解XML结构来读取文件内容：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also, getting the information out of XML is another important task to tackle
    extended events correctly:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从XML中获取信息也是正确处理扩展事件的重要任务：
- en: '![](img/00159.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00159.jpeg)'
- en: 'Coming back to the starting point, gathering data for DBAs and further analysis
    is of the utmost importance. One thing can also be seen from this example: if
    we also add to log file growth, one of the logs needs to grow additionally by
    adding new VLF files. Adding delayed durability gives faster inserts as compared
    to transactions with delayed durability turned off. Sometimes adding new `XE`
    or measures can dramatically increase the logging file, where the data is being
    gathered. Using statistical analysis, we can optimize measure selection or later
    find that they give us additional insight information. Working on exploring and
    later analyzing data can give you a huge pay-off, in terms of workloads and in
    terms of different data gathered.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回到起点，为数据库管理员和进一步分析收集数据至关重要。从这个例子中还可以看出：如果我们也添加到日志文件的增长，其中一个日志需要通过添加新的VLF文件来额外增长。与关闭延迟持久性的事务相比，添加延迟持久性可以提供更快的插入。有时添加新的`XE`或度量可以显著增加日志文件，其中数据正在被收集。使用统计分析，我们可以优化度量选择，或者稍后发现它们为我们提供了额外的洞察信息。在探索和后续分析数据方面的工作可以带来巨大的回报，无论是在工作负载方面还是在收集到的不同数据方面。
- en: Exploring and analyzing data
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和分析数据
- en: 'In a similar way, gathering data using event features can give you a rich way
    to a lot of system information data. Deriving from the previous sample, with the
    following demo, we will see how measures of a server can be used for advanced
    statistical analyses and how to help reduce the amount of different information,
    and pin-point the relevant measures. A specific database and a stage table will
    be created:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，使用事件特征收集数据可以为您提供丰富的方式来获取大量系统信息数据。从之前的示例中，通过以下演示，我们将看到如何使用服务器的度量值进行高级统计分析，以及如何帮助减少不同信息量，并精确定位相关度量。将创建一个特定的数据库和一个阶段表：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, import the measure that can be found in the accompanying code file. There
    are 433 measuring points from 32 different extended events for the purpose of
    understanding the server and its environment settings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，导入附带的代码文件中可以找到的度量。有433个测量点来自32个不同的扩展事件，目的是理解服务器及其环境设置。
- en: 'After the initial load, the table will be populated with measures of different
    extended events that have also been discretized and cleaned for further data analysis:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始加载后，表将填充不同扩展事件的度量值，这些度量值也已经过离散化和清理，以便进行进一步的数据分析：
- en: '![](img/00160.gif)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00160.gif)'
- en: 'The `boxplot` function enables users to explore the distribution of each of
    the measures and find potential outliers. Use only R code to explore the data:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`boxplot`函数使用户能够探索每个度量的分布并找到潜在的异常值。仅使用R代码来探索数据：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following graph gives a quick overview:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表提供了一个快速概述：
- en: '![](img/00161.gif)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00161.gif)'
- en: Boxplot shows that there are four events, where the value is vastly exceeding
    the average and third quartile. Cleaning these outliers will make the data easier
    to read and not result in abnormal distribution and skewed results. Note that
    there are particular analyses that deal with outliers and searching for such values.
    For this demo, we will recode these values into N/A.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图显示有四个事件，其值远远超过平均值和第三四分位数。清理这些异常值将使数据更容易阅读，并且不会导致异常分布和偏斜结果。请注意，有一些特定的分析处理异常值并寻找这样的值。对于这个演示，我们将这些值重新编码为N/A。
- en: 'After cleaning, adding summary statistics and a correlation is a relevant way
    to see how all of the events are correlating with one another:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理、添加汇总统计量和相关性之后，这是一个相关的方法来查看所有事件是如何相互关联的：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A correlation matrix of server features is a nice way to represent which events
    are correlating and which are not, and how:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器特征的关联矩阵是表示哪些事件相关以及如何不相关的一种很好的方式：
- en: '![](img/00162.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00162.jpeg)'
- en: Going a step further, let's reduce these extended event measures, because it
    is obvious that not all are playing an important role and some might be just overhead.
    From the preceding heat map, it is hard to see which correlations for certain
    measures are not working out; therefore, we will use factor analysis. This observes
    correlations among the variables in such a way that it reflects the lower number
    of underlying variables. A factor is an underlying variable, that is, a latent
    variable that gets structured based on the observed and correlated variables.
    Structure is created by each of the factors being loaded with the response of
    correlated variable. This means that factor 1 can be, for example, loaded 25%
    with variable `A`, 65% with variable `B`, and 10% with variable `C`. So factor
    1 will take the majority (65%) of the features from variable `A` and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，让我们减少这些扩展事件度量，因为很明显，并非所有都在扮演重要角色，有些可能只是额外开销。从前面的热图中，很难看出某些度量之间的相关性是否不起作用；因此，我们将使用因子分析。这种分析观察变量之间的相关性，以反映更少的潜在变量。因子是一个潜在变量，即基于观察和相关性变量的结构化变量。结构是通过每个因子加载响应变量来创建的。这意味着因子1可以是，例如，变量`A`加载25%，变量`B`加载65%，变量`C`加载10%。因此，因子1将主要（65%）从变量`A`中提取特征，依此类推。
- en: In this manner, factor analysis will try to reduce the number of original correlated
    variables (our measures of extended events) and try to create new structured variables.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，因子分析将尝试减少原始相关变量的数量（我们扩展事件的度量），并尝试创建新的结构化变量。
- en: 'Exploring data with R code, a simple exploratory factor analysis can reveal
    a number of factors:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用R代码探索数据，简单的探索性因子分析可以揭示多个因子：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screen plot reveals that there are seven factors available for
    extraction:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示有七个因子可用于提取：
- en: '![](img/00163.gif)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00163.gif)'
- en: 'In the following way, this will also reveal the loadings for the factors themselves;
    simply call the R function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下方式，这也会揭示因子的加载情况；只需调用R函数：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following diagram shows how loading construct each of the factor.:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了加载构建每个因子的方式：
- en: '![](img/00164.gif)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00164.gif)'
- en: 'Storing loadings back into the database for further analysis and factor naming
    are a common practice and given the ability to incorporate factors into any further
    analysis (for example: classification or clustering methods) . Now that we know
    the number of factors, we can store the loadings into the database:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将加载存储回数据库以进行进一步分析和因子命名是一种常见做法，并且考虑到可以将因子纳入任何进一步的分析（例如：分类或聚类方法）。现在我们知道因子的数量，我们可以将加载存储到数据库中：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The results can be interpreted as: the higher the value (positive or negative),
    the more loaded is a particular measure is with the accompanying factor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以解释为：值（正或负）越高，特定度量与伴随因子的加载就越多：
- en: '![](img/00165.gif)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00165.gif)'
- en: 'Factor 1, `PA1`, is mostly loaded with XE03 (`0.680`), XE13 (`0.640`), XE18
    (`-0.578`), and XE28 (`0.652`). All four are measuring the transactions of query
    and are as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因子1，`PA1`，主要加载了XE03 (`0.680`)、XE13 (`0.640`)、XE18 (`-0.578`)和XE28 (`0.652`)。这四个都是测量查询交易，如下面的截图所示：
- en: '![](img/00166.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00166.jpeg)'
- en: Here, the negative value is the free space in tempdb (KB) that is negatively
    loaded and it only means the relationship to the factor. But having the ability
    to reduce the number of extended events, and to have them combined through the
    advanced statistical analysis, is a very neat approach to a potentially complex
    problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，负值是tempdb中的空闲空间（KB），它是负负载的，并且仅表示与因素的关系。但是，能够减少扩展事件的数目，并通过高级统计分析将它们结合起来，是一种处理潜在复杂问题的非常整洁的方法。
- en: 'With loadings in the database, I can additionally represent how these factors
    are being dispersed on a scatterplot. I have exported the results of the preceding
    query to Power BI and used the clustering visual. Furthermore, you can see clusters
    of these factor loadings and the ones that are similar. The red group (to the
    left) is again something that DBAs and data scientists should look at together
    for further examination:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库负载中，我还可以通过散点图表示这些因素是如何分布的。我已经将先前查询的结果导出到Power BI，并使用了聚类视觉。此外，您可以看到这些因素负载的集群以及相似的集群。红色组（在左侧）又是DBA和数据科学家应该一起进一步检查的内容：
- en: '![](img/00167.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00167.jpeg)'
- en: Creating a baseline and workloads, and replaying
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基线和负载，并重新播放
- en: Given the ability to reduce and create new measures that are tailored and adapted
    to your particular server or environment, now we want to understand how the system
    is behaving with all the other parameters unchanged (in Latin, *ceteris paribus*).
    This is the baseline. And with the baseline, we establish what is normal, or in
    other words, what the performance is under normal conditions. A baseline is used
    for comparing what might be or seem abnormal or out of the ordinary. It can also
    serve as a control group for any future tests (this works well especially when
    new patches are rolled out an upgrade of a particular environment/server needs
    to be performed).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 给定减少和创建针对您特定服务器或环境的定制和适应性的新度量标准的能力，现在我们想了解在所有其他参数保持不变的情况下（拉丁语，*ceteris paribus*）系统是如何表现的。这是基线。有了基线，我们确定了什么是正常的，换句话说，在正常条件下的性能。基线用于比较可能或看似异常或不寻常的情况。它还可以作为任何未来测试的控制组（这在新补丁推出或特定环境/服务器的升级需要执行时尤其有效）。
- en: 'A typical corporate baseline would be described as follows over a period of
    one day (24 hours) in the form of the number of database requests from users or
    machines:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的企业基线可以描述为以下一天（24小时）内用户或机器发起的数据库请求数量：
- en: '![](img/00168.gif)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00168.gif)'
- en: When all requests are represented as a breakdown for each of the corporate processes,
    immediate patterns can be seen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有请求都表示为每个企业流程的细分时，可以立即看到模式。
- en: 'The ERP system usually peak when people are at their workplace-on a normal
    day between 8.00 AM and 5.00 PM with two distinct peaks and a very obvious lunch
    break from 11.00 AM until 1.00 PM:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 企业资源规划（ERP）系统通常在人们在工作场所时达到峰值——在正常工作日的上午8:00至下午5:00之间，有两个明显的峰值，以及从上午11:00至下午1:00的非常明显的午餐休息时间：
- en: '![](img/00169.gif)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00169.gif)'
- en: 'Adding ETL jobs for daily ERP system maintenance, it is obvious where and when
    DBAs and SysAdmins usually try to squeeze these important jobs and how this is
    also limited and narrated by daily ERP workloads:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常ERP系统维护中添加ETL作业，很明显DBA和系统管理员通常在哪里以及何时尝试压缩这些重要作业，以及这如何也受到日常ERP工作负载的限制和描述：
- en: '![](img/00170.gif)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00170.gif)'
- en: 'A warehouse has a completely different behavior pattern, which means that it
    is usually the highest request in the morning hours 4.00 AM and 5.00 AM and somehow
    steady until evening hours:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库具有完全不同的行为模式，这意味着它通常在早晨4:00 AM和5:00 AM达到最高的请求，并且直到傍晚时分保持某种程度的稳定：
- en: '![](img/00171.gif)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00171.gif)'
- en: 'A bakery, on the contrary, has a reverse request to the database, since the
    majority of their activities are done starting from 9.00 PM until 3.00 AM, so
    that customers get fresh bread in the morning:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，面包店对数据库的请求是相反的，因为他们的大多数活动都是从晚上9:00开始，直到凌晨3:00，这样顾客就能在早上得到新鲜面包：
- en: '![](img/00172.gif)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00172.gif)'
- en: 'Lastly, websites can be understood as a constant database request resource
    with relatively slight daily changes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，网站可以被视为一个恒定的数据库请求资源，相对而言，每天的变动很小：
- en: '![](img/00173.gif)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00173.gif)'
- en: 'All these can be understood as a daily baseline and of course, things get even
    more complicated when this is projected on a monthly basis. Also, patterns emerge
    immediately. During the weekends (day 7, 14, and 21) the requests are diminished
    and toward the end of the month, the financial cycle needs to be closed; hence,
    there is additional load on the database:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以理解为日常基线，当然，如果按月度来考虑，事情会变得更加复杂。同时，模式会立即出现。在周末（第7天、第14天和第21天）请求减少，而在月底结束时，需要关闭财务周期；因此，数据库上有额外的负载：
- en: '![](img/00174.gif)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/00174.gif)'
- en: Showing all these is crucial to understand how the baseline of the system (or
    environment) must be understood. This data can be collected using performance
    counters, many of the DMV, using the query store, and other tools. What we usually
    gather is what we will be later monitoring and predicting. So choosing wisely
    is the most important task, since through these measures, counters, and values
    you will be defining when your system is healthy and when it is not. But usually
    general information on the system and database is crucial. Also, SQL Server information,
    and many configurable parameters, query-related information, and database-I/O,
    and RAM-related information need to be stored as well.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 展示所有这些对于理解系统（或环境）基线必须如何理解至关重要。这些数据可以通过性能计数器、许多DMV、使用查询存储和其他工具收集。我们通常收集的是我们稍后要监控和预测的内容。因此，明智地选择是最重要的任务，因为通过这些措施、计数器和值，您将定义系统何时健康以及何时不健康。但通常，关于系统和数据库的一般信息至关重要。此外，还需要存储SQL
    Server信息、许多可配置参数、与查询相关的信息、数据库-I/O和与RAM相关的信息。
- en: 'After having a baseline, we need to have the workload created. Usually, the
    workload is captured against the baseline in the production server, and a restore
    of capture statistics is replayed on the test server/environment. Database tuning
    or changes in configuration can be alternated by replaying the captured workload
    from production on the test environment, by alternatively changing the values
    of a particular parameter. The next demo is a representation of the workload expressed
    through two parameters that have been changed when the same workload has been
    replied:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立基线后，我们需要创建工作负载。通常，工作负载是在生产服务器上针对基线捕获的，并在测试服务器/环境中回放捕获的统计信息。可以通过在测试环境中回放从生产环境中捕获的工作负载，通过交替更改特定参数的值来改变数据库调整或配置更改。下一个演示是表示通过两个参数表达的工作负载，当相同的工作负载被回放时，这些参数已被更改：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Querying the table `[dbo].[WLD]` is essentially just repeating the same workloads
    with changes on one or another parameter:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表 `[dbo].[WLD]` 实质上只是重复相同的工作负载，但其中一个或另一个参数有所变化：
- en: '![](img/00175.gif)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00175.gif)'
- en: 'First, we need to have the outlier analysis against the workload each time
    something has changed. T-SQL code with R can deliver a *Mahalanobis* graph, which
    clearly shows where the outliers are:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对每次有变化时的工作负载进行异常值分析。带有R的T-SQL代码可以生成一个*马氏距离*图，清楚地显示异常值所在的位置：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The graph was inserted into Power BI, where the workloads can be changed against
    both of the parameters. So DBAs cannot only change the workloads, they can also
    see which outliers have caused and needed extra attention when performing a replay
    on the restored workload:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表已插入Power BI中，可以在两个参数中更改工作负载。因此，数据库管理员不仅可以更改工作负载，还可以在回放恢复的工作负载时看到哪些异常值引起了额外关注：
- en: '![](img/00176.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/00176.jpeg)'
- en: 'ANOVA or MANOVA can also be performed to see specific changes among the workloads.
    R code can do just that:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ANOVA或MANOVA也可以执行，以查看工作负载中的特定变化。R代码可以做到这一点：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And the ANOVA statistics show the differences among the workloads and their
    changes in parameter settings:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ANOVA统计显示工作负载及其参数设置变化之间的差异：
- en: '![](img/00177.gif)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00177.gif)'
- en: Creating predictions with R - disk usage
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用R创建预测 - 磁盘使用情况
- en: Predictions involve spotting any unplanned and unwanted activities or unusual
    system behavior, especially when compared it to the baseline. In this manner,
    raising a red flag would result in fewer false positive states.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 预测涉及发现任何未计划、不希望的活动或异常的系统行为，尤其是与基线相比时。以这种方式，拉响警报将导致更少的误报状态。
- en: In addition, we always come across disk-size problems. Based on this problem,
    we will demo database growth, store the data, and then run predictions against
    the collected data to be able at the end to predict when a DBA can expect disk
    space problems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们总是遇到磁盘大小问题。基于这个问题，我们将演示数据库增长，存储数据，然后对收集到的数据进行预测，以便最终能够预测DBA何时可以期待磁盘空间问题。
- en: To illustrate this scenario, I will create a small database of 8 MB and no possibility
    of growth. I will create two tables. One will serve as a baseline, `DataPack_Info_SMALL`,
    and the other will serve as a so-called everyday log, where everything will be
    stored for unexpected cases or undesired behavior. This will persist in the `DataPack_Info_LARGE`
    table.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个场景，我将创建一个8MB的小型数据库，没有增长的可能性。我将创建两个表。一个将作为基线，`DataPack_Info_SMALL`，另一个将作为所谓的日常日志，其中将存储所有意外情况或不良行为。这将持久保存在`DataPack_Info_LARGE`表中。
- en: 'First, create a database:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个数据库：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `DataPack` table will serve as a storage place for all the generated inserts
    and later deletes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataPack`表将作为所有生成的插入和后续删除的存储位置：'
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Populating the `DataPack` table will be done with the following simple `WHILE`
    loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下简单的`WHILE`循环填充`DataPack`表：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Capturing disk space changes with the following query will be very important
    for the task:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下查询捕获磁盘空间变化对于任务来说非常重要：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Log` table will be filled along with the `DataPack` table in order to
    gather immediate changes in disk space:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log`表将与`DataPack`表一起填充，以便收集磁盘空间的即时变化：'
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will serve as our baseline when comparing the results. When we query the
    `DataPack_Log_Small` table, the results are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为我们比较结果的基础。当我们查询`DataPack_Log_Small`表时，结果如下：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a result, we get a strong and positive correlation between the `RowCounts`
    and `UsedSpaceKB` columns. This can easily be interpreted as: when the value for
    `RowCounts` goes up, the value for `UsedSpaceKB` also goes up. This is the only
    logical explanation. It would be somehow strange to have a negative correlation.
    Now, we will try to simulate random deletes and inserts and observe a similar
    behavior with the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们在`RowCounts`和`UsedSpaceKB`列之间得到了一个强烈和正的相关性。这可以很容易地解释为：当`RowCounts`的值增加时，`UsedSpaceKB`的值也增加。这是唯一的逻辑解释。出现负相关性会有些奇怪。现在，我们将尝试模拟随机的删除和插入，并使用以下代码观察类似的行为：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have added a `DELETE` statement, as well as `RowCounts`, so that the demo
    will not be so straightforward. By calculating the correlation coefficient, it
    is obvious, that we again get a very strong and positive correlation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`DELETE`语句，以及`RowCounts`，这样演示就不会那么直接。通过计算相关系数，很明显，我们再次得到了一个非常强烈和正的相关性。
- en: 'We will now compare our `LARGE` test with the baseline by running the same
    correlation coefficient on different datasets. The first is on our baseline (`DataPack_Info_SMALL`)
    and the second one is from our test table (`DataPack_Info_LARGE`):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过在不同的数据集上运行相同的相关系数来比较我们的`LARGE`测试与基线。第一个是在我们的基线（`DataPack_Info_SMALL`）上，第二个是从我们的测试表（`DataPack_Info_LARGE`）上：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The results are very interesting. The baseline shows no correlation between
    `UsedSpaceKB` and `UnusedSpaceKB` (it is `-0.049`), whereas our test shows an
    almost 3x stronger negative correlation (it is `-0.109`). A couple of words on
    this correlation: this shows that `UsedSpaceKB` is negatively correlated with
    `UnUsedSpaceKB`; this which is still too small to draw any concrete conclusions,
    but it shows how a slight change can cause a difference in a simple correlation.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结果非常有趣。基线显示`UsedSpaceKB`和`UnusedSpaceKB`之间没有相关性（它是`-0.049`），而我们的测试显示几乎3倍更强的负相关性（它是`-0.109`）。关于这个相关性的几点说明：这表明`UsedSpaceKB`与`UnUsedSpaceKB`呈负相关；这虽然还不足以得出任何具体的结论，但它显示了轻微的变化如何导致简单相关性中的差异。
- en: You can gather disk space usage information with T-SQL, by using PowerShell,
    by implementing .NET assembly, or creating a SQL Server job, or any other way.
    The important part and the biggest advantage is that, using R and the data collected,
    now you will not only be monitoring and reacting to the past data, but you will
    also be able to predict what will happen.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用T-SQL、通过PowerShell、通过实现.NET组件或创建SQL Server作业，或者任何其他方式来收集磁盘空间使用信息。重要的是，最大的优势是，使用R和收集到的数据，现在您不仅能够监控和反应过去的数据，而且还能预测将要发生的事情。
- en: 'Let''s go a step further and assume the following query and dataset taken from
    our sample created:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，假设以下查询和从我们的样本创建的数据集：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will give a prediction on the size of the `usedSpaceKB` based on historical
    data. Our input will be `TableName`, `Operation`, and `NofRowsOperation` for a
    given number to predict on. I will be using a general linear model (the GLM algorithm)
    for predicting `usedDiskSpace`! Before you all start saying this is absurd, this
    cannot be done due to DBCC caching, page brakes, indexes, stall statistics, and
    many other parameters, I would like to point out that all this information can
    be added into the algorithm and would make the prediction even better. Since my
    queries are very simple `INSERT` and `DELETE` statements, you should also know
    what kinds of queries are you predicting. In addition, such an approach can be
    good for code testing, unit testing, and stress testing before deployment.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于历史数据预测 `usedSpaceKB` 的大小。我们的输入将是用于预测的给定数字的 `TableName`、`Operation` 和 `NofRowsOperation`。我将使用通用线性模型（GLM
    算法）来预测 `usedDiskSpace`！在你们所有人开始说这是荒谬的，由于 DBCC 缓存、页面中断、索引、停滞统计和许多其他参数，无法完成之前，我想指出，所有这些信息都可以添加到算法中，从而使预测更加准确。由于我的查询非常简单，是
    `INSERT` 和 `DELETE` 语句，你们也应该知道你正在预测哪些类型的查询。此外，这种方法在部署前的代码测试、单元测试和压力测试中也可能很有用。
- en: 'With the following R code, we can start creating predictions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 R 代码，我们可以开始创建预测：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we can predict the size of `UsedSpaceKB` based on the following data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据以下数据预测 `UsedSpaceKB` 的大小：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have a few things to clear out first. The following R code with the `xp_execute_external_script`
    would work much better as a stored procedure with input parameters for these columns:
    `TableName`, `Operation`, `NofRowsOperation`, and `UnusedSpaceKB`. Furthermore,
    to avoid unnecessary computational time for model building, it is usually the
    practice to store a serialized model in a SQL table and just deserialize it when
    running predictions. At last, since this was just a demo, make sure that the numbers
    used in predictions make sense, As we saw in our example, the `UsedSpaceKB` would
    be predicted much better if absolutely calculated, rather than using the cumulative
    values. Only later is the cumulative value calculated.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要澄清一些事情。以下使用 `xp_execute_external_script` 的 R 代码，作为一个存储过程，对于这些列（`TableName`、`Operation`、`NofRowsOperation`
    和 `UnusedSpaceKB`）的输入参数会工作得更好。此外，为了避免在模型构建过程中不必要的计算时间，通常的做法是将序列化的模型存储在 SQL 表中，并在运行预测时进行反序列化。最后，由于这只是一个演示，请确保用于预测的数字是有意义的。正如我们在示例中看到的，如果绝对计算，`UsedSpaceKB`
    的预测会更好，而不是使用累积值。只有后来才会计算累积值。
- en: 'To sum up this rather long demo, let''s create a procedure and run some predictions
    to see how efficient this is. The stored procedure is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这个相当长的演示，让我们创建一个过程并运行一些预测，看看这是多么高效。存储过程如下：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we need to run the procedure two times in a row:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要连续运行该过程两次：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Both predictions on used space disk are based on our demo data but can be used
    on a larger scale and for predictions as well. Of course, for even better predictions,
    some baseline statistics could also be included. With every model, we also need
    to test the predictions to see how good they are.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对使用空间磁盘的预测都基于我们的演示数据，但也可以用于更大规模和预测。当然，为了获得更好的预测，也可以包括一些基线统计信息。对于每个模型，我们还需要测试预测，看看它们有多好。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Using SQL Server R for any kind of DBA task, as we have seen here, it is not
    always hardcore statistics or predictive analytics; we might also be some simple
    statistical understanding underlying the connection and relationships between
    the attribute's queries, gathered statistics, and indexes. Prognosing and predicting,
    for example, information from execution plans in order to prepare a better understanding
    of the query of cover missing index, is a crucial point. Parameter sniffing or
    a cardinality estimator would also be a great task to tackle along the usual statistics.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQL Server R 进行任何类型的 DBA 任务，正如我们在这里所看到的，并不总是涉及核心统计或预测分析；我们可能还需要了解一些简单的统计知识，这些知识隐藏在属性查询、收集的统计信息和索引之间的连接和关系之中。例如，预测和预测执行计划中的信息，以便更好地理解查询覆盖缺失索引，这是一个关键点。参数嗅探或基数估计器也是一项很好的任务，可以与常规统计一起解决。
- en: But we have seen that predicting events that are usually only monitored can
    be a huge advantage for a DBA and a very welcome feature for core systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们已经看到，预测通常只有监控的事件可以给 DBA 带来巨大优势，并且对于核心系统来说是一个非常受欢迎的功能。
- en: With R integration into SQL Server, such daily, weekly, or monthly tasks can
    be automated to different, before not uses yet, extent. And as such, it can help
    give different insight to DBAs and also people responsible for system maintenance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 R 集成到 SQL Server 中，这些日常、每周或每月的任务可以自动化到以前未曾使用过的不同程度。因此，它可以帮助数据库管理员以及负责系统维护的人员获得不同的见解。
- en: In next chapter, we will be covering extending features beyond R external procedure
    and how to use them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何扩展 R 外部过程的功能以及如何使用它们。
