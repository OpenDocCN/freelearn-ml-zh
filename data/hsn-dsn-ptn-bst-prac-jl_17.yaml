- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章
- en: '**What are the benefits of using design patterns?**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用设计模式有哪些好处？**'
- en: Design patterns help the programmer apply already-proven approaches to common
    problems. There will be less time wasted in searching for the proper solution
    or fixing a design issue after a sub-optimal implementation. Anti-patterns provide
    additional guidance for avoiding common design flaws.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式帮助程序员将已经证明有效的方法应用于常见问题。在次优实现之后，将节省更多时间用于寻找适当的解决方案或修复设计问题。反模式为避免常见设计缺陷提供了额外的指导。
- en: '**What are some of the key design principles?**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**有哪些关键的设计原则？**'
- en: The key design principles include SOLID, DRY, KISS, POLA, YAGNI, and POLP. These
    principles are widely recognized as good guidance for object-oriented programming,
    but they can be applied equally well in other programming paradigms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关键设计原则包括SOLID、DRY、KISS、POLA、YAGNI和POLP。这些原则被广泛认为是面向对象编程的良好指导，但它们同样适用于其他编程范式。
- en: '**What problem does the open/closed principle solve?**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放/封闭原则解决了什么问题？**'
- en: The open/closed principle encourages the programmer to design a system that
    is easy to extend without having to modify the component that is being extended.
    It promotes better reusability of software components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 开放/封闭原则鼓励程序员设计一个易于扩展的系统，而无需修改正在扩展的组件。它促进了软件组件更好的重用性。
- en: '**Why is interface segregation important for software reusability?**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么接口分离对于软件重用很重要？**'
- en: Interface segregation promotes a minimalistic design for interfaces so that software
    components can implement the respective interfaces more easily. A large, complex
    interface is difficult to implement and it makes the component less reusable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接口分离促进了接口的最简设计，以便软件组件更容易实现相应的接口。一个庞大而复杂的接口难以实现，并且使组件的可重用性降低。
- en: What are the simplest ways to develop maintainable software?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 开发可维护的软件的最简单方法是什么？
- en: The simplest way to is to adhere to the general design principles such as KISS,
    DRY, POLA, and SOLID.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方式是遵守KISS、DRY、POLA和SOLID等通用设计原则。
- en: '**What is a good practice for avoiding over-engineering and bloated software?**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免过度设计和臃肿软件的好习惯是什么？**'
- en: The best way to avoid over-engineering and bloated software is to only implement
    functionalities that are absolutely necessary according to the YAGNI principle.
    Also, keep it simple (KISS) and avoid duplicate code (DRY).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 避免过度设计和臃肿软件的最佳方式是根据YAGNI原则仅实现绝对必要的功能。同时，保持简单（KISS）并避免重复代码（DRY）。
- en: '**How does memory usage affect system performance?**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存使用如何影响系统性能？**'
- en: When the system allocates more memory, it also triggers the **Garbage Collector**
    (**GC**) more frequently. Garbage collection is a relatively expensive operation
    and, hence, it can slow down the system. Avoiding over memory allocation is usually
    one of the best ways to optimize application performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统分配更多内存时，它也会更频繁地触发**垃圾回收器**（**GC**）。垃圾回收是一个相对昂贵的操作，因此，它可能会减慢系统。避免过度内存分配通常是优化应用程序性能的最佳方法之一。
- en: Chapter 2
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: '**How do we create a new namespace?**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何创建一个新的命名空间？**'
- en: A namespace is created using a module block. Typically, a module is defined
    as part of a Julia package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是通过模块块创建的。通常，模块被定义为Julia包的一部分。
- en: '**How do we expose the functions of a module to the outside world?**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何将模块的功能暴露给外部世界？**'
- en: Functions and other objects defined within a module can be exposed using an
    export statement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用导出语句将模块内定义的函数和其他对象暴露出来。
- en: '**How do we reference the proper function when the same function name is exported
    from different packages?**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**当同一函数名从不同的包导出时，我们如何引用正确的函数？**'
- en: We can just prefix the function name with the package name. As an alternative,
    we can use a `using` statement for one package, and an import statement for the
    other, so that we can use the function name directly for the first package but
    use the prefix syntax for the other.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接在函数名前加上包名。作为替代方案，我们可以对一个包使用`using`语句，对另一个使用导入语句，这样我们就可以直接使用第一个包的函数名，而对其他包使用前缀语法。
- en: '**When do we separate code into multiple modules?**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们在什么时候将代码分离成多个模块？**'
- en: It is time to consider separating code into modules when the code becomes too
    big and too difficult to manage. We expect some refactoring to ensure the proper
    level of coupling between modules.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码变得太大，难以管理时，是时候考虑将代码分离成模块了。我们期望进行一些重构，以确保模块之间适当的耦合级别。
- en: '**Why is semantic versioning important in managing package dependencies?**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么语义版本化在管理包依赖时很重要？**'
- en: Semantic versioning defines a clear contract about when a breaking change is
    introduced in a new version. When used properly and consistently, it helps programmers
    to determine whether the change is compatible with the existing software and whether
    additional testing is required.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本化定义了在新版本中引入破坏性更改时的明确合同。当正确且一致地使用时，它有助于程序员确定更改是否与现有软件兼容，以及是否需要额外的测试。
- en: '**How is defining functional behavior for abstract types useful?**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义抽象类型的函数行为有何用途？**'
- en: It is useful to define functional behavior for abstract types because the same
    behavior can be applied for the respective subtypes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为抽象类型定义函数行为是有用的，因为可以将相同的行为应用于相应的子类型。
- en: '**When should we make a type mutable?**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时应该使类型可变？**'
- en: It is appropriate to make a type mutable when some parts of the data type are
    expected to be changed. It is also useful when memory allocation needs to be reduced
    for performance reasons.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当预期数据类型的一些部分需要更改时，将类型设置为可变是合适的。出于性能原因需要减少内存分配时，这也很有用。
- en: '**How are parametric types useful?**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数类型有何用途？**'
- en: Parametric types allow a concrete type to be defined without hardcoding the
    type of its fields, so the same type can be used to generate new variations for
    different purposes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 参数类型允许在不硬编码字段类型的情况下定义具体类型，因此可以使用相同的类型为不同的目的生成新的变体。
- en: Chapter 3
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: '**How are positional arguments different from keyword arguments?**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置参数与关键字参数有何不同？**'
- en: Position arguments must be passed in the same order as they are defined in the
    function signature. They are typically mandatory, but can be made optional when
    default values are provided. Keyword arguments can be passed in any order that
    they are written, and they are optional when default value is not provided.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数必须按照它们在函数签名中定义的顺序传递。它们通常是必需的，但可以通过提供默认值来使其可选。关键字参数可以按它们书写的任何顺序传递，并且当未提供默认值时是可选的。
- en: '**What is the difference between splatting and slurping?**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**展开和吸入有何区别？**'
- en: Splatting and slurping have the same syntax but mean different things in different
    contexts. Splatting refers to the automatic assignment of function arguments from
    a tuple or array. Slurping refers to the process of passing multiple function
    arguments, which becomes a single tuple variable accessible from the body of the
    function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 展开和吸入具有相同的语法，但在不同的上下文中意味着不同的事情。展开指的是从元组或数组自动分配函数参数。吸入指的是将多个函数参数传递为一个单一的元组变量，该变量可以从函数体中访问。
- en: '**What is the purpose of do-syntax?**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**do-syntax的目的是什么？**'
- en: Do-syntax is a convenient way of formatting a block of code that is needed to
    be wrapped as an anonymous function and passed to another function. It makes the
    code much more readable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Do-syntax是一种方便的方式来格式化需要作为匿名函数包装并传递给另一个函数的代码块。这使得代码更加易于阅读。
- en: '**What tool is available for detecting method ambiguities as related to multiple
    dispatch?**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**有什么工具可以检测与多重分派相关的方法歧义？**'
- en: The `detect_ambiguities` function from the `Test` package can be used to detect
    method ambiguities within a single module or across multiple modules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用来自`Test`包的`detect_ambiguities`函数来检测单个模块或多个模块内的方法歧义。
- en: '**How do we ensure that the same concrete type is passed to a function in a
    parametric method?**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何确保在参数方法中传递相同的具体类型？**'
- en: A convenient way to ensure that the same concrete type is passed for the arguments
    of a function is to designate these arguments as a type parameter (for example, `T`).
    Note that this works as long as the type parameter is used as a standalone type
    rather than part of a parametric type, for example, `AbstractVector{T}`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确保函数的参数传递相同的具体类型的一个方便方法是将这些参数指定为类型参数（例如，`T`）。请注意，只要类型参数作为独立类型使用，而不是参数类型的一部分，例如，`AbstractVector{T}`，这就会起作用。
- en: '**How are interfaces implemented without any formal language syntax?**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**在没有正式语言语法的情况下如何实现接口？**'
- en: Interfaces can be implemented according to the contract specified by the designer
    of the interface even though there is no formal syntax in Julia for specifying
    interfaces.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Julia没有指定接口的正式语法，也可以根据接口设计者的规范实现接口。
- en: '**How do we implement traits, and how are traits useful?**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何实现特质，特质有何用途？**'
- en: A trait can be implemented by a function that takes the specific data type(s)
    and returns a flag. Normally, a trait is defined to return a Boolean value, that
    is, whether the trait exists or not. However, it can also be designed to return
    multiple values to indicate various kinds of trait. Traits are useful if the developer
    needs to programmatically figure out whether a data type (or combination of data
    types) exhibits a specific behavior.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 特质可以通过一个函数来实现，该函数接受特定的数据类型并返回一个标志。通常，特质被定义为返回布尔值，即特质是否存在。然而，它也可以设计为返回多个值以指示各种特质。如果开发者需要通过编程方式确定数据类型（或数据类型的组合）是否具有特定行为，特质是有用的。
- en: Chapter 4
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: '**What are the two ways to quote expressions so the code can be manipulated
    later?**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**有哪两种方法可以引用表达式以便稍后进行代码操作？**'
- en: One way is to enclose an expression with `:(` and `)`. Another way is to put
    the code between `quote` and `end` keywords. In general, a quote block is used
    for multiline expressions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将表达式用`:(`和`)`括起来。另一种方法是将代码放在`quote`和`end`关键字之间。一般来说，quote块用于多行表达式。
- en: '**In which scope does the `eval` function execute the code on?**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**`eval`函数在哪个作用域中执行代码？**'
- en: The `eval` function evaluates the code in the global scope. So, if it is used
    from a function inside a module, then the code that is evaluated will be within
    the scope of the module.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`函数评估全局作用域中的代码。因此，如果它从一个模块内的函数中使用，那么被评估的代码将位于模块的作用域内。'
- en: '**How do we interpolate physical symbols into quoted expressions rather than
    being misinterpreted as source code?**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何将物理符号插入到引号表达式中，而不是将其误解释为源代码？**'
- en: To interpolate symbols into quoted expressions, create a `QuoteNode` object
    and interpolate that object normally.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要将符号插入到引号表达式，创建一个`QuoteNode`对象并正常插入该对象。
- en: '**What is the naming convention for a macro where it defines non-standard string
    literals?**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义非标准字符串字面量的宏的命名约定是什么？**'
- en: Non-standard string literals are defined as macros having names ending with `_str`.
    For example, when an `ip_str` macro is defined for an IP address, it can be written: `ip"192.168.1.1"`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 非标准字符串字面量定义为以`_str`结尾的宏。例如，当为IP地址定义`ip_str`宏时，它可以这样写：`ip"192.168.1.1"`。
- en: '**When do we use the `esc` function?**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用`esc`函数？**'
- en: The `esc` function is needed to ensure that the quoted expression is evaluated
    at the call site, which could be in the local scope of a function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`esc`函数需要确保引号表达式在调用点被评估，这可能是函数的局部作用域。'
- en: '**How are generated functions different from macros?**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成的函数与宏有何不同？**'
- en: Generated functions have access to the types of the arguments. They are functions
    by definition so, unlike macros, they do not have access to the source code. Macros
    operate at the syntax level and do not have any runtime information. Both generated
    functions and macros are expected to return expressions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的函数可以访问参数的类型。它们是按定义是函数，因此与宏不同，它们没有访问源代码的能力。宏在语法级别上操作，并且没有任何运行时信息。生成的函数和宏都应返回表达式。
- en: '**How do we debug metaprogramming code?**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何调试元编程代码？**'
- en: Debugging macros can be challenging. It comes down to making sure that the expression
    being returned is correct. We can use the `@macroexpand` macro (or the corresponding `macroexpand` function)
    to verify results. Also, because a macro or generated function is defined using
    regular Julia code, the same debugging technique, such as `println`, can be used.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 调试宏可能具有挑战性。这归结于确保返回的表达式是正确的。我们可以使用`@macroexpand`宏（或相应的`macroexpand`函数）来验证结果。此外，由于宏或生成的函数是使用常规Julia代码定义的，因此可以使用相同的调试技术，例如`println`。
- en: Chapter 5
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: '**How does delegation pattern work?**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**委托模式是如何工作的？**'
- en: Delegation pattern can be implemented by wrapping a parent object in a new object.
    The function for the new objects can be forwarded (or delegated) to the parent
    object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 委托模式可以通过将父对象包装在新对象中来实现。新对象的功能可以转发（或委托）给父对象。
- en: '**What is the purpose of traits?**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**特质的目的何在？**'
- en: The purpose of traits is to formally define the behavior of certain objects.
    Once a trait is defined, we can programmatically examine whether an object exhibits
    the trait.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 特质的目的是正式定义某些对象的行为。一旦定义了特质，我们就可以通过编程方式检查一个对象是否具有该特质。
- en: '**Are traits always binary?**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**特质总是二元的吗？**'
- en: Traits are typically binary, but there is no mandatory requirement. It would
    be fine as long as the traits are mutually exclusive. Julia's `Base.IteratorSize`
    trait is a good example of a multi-valued trait.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 特性通常是二元的，但没有强制性要求。只要特性是互斥的，那就没问题。Julia的`Base.IteratorSize`特性就是一个多值特性的好例子。
- en: '**Can traits be used for objects from a different type hierarchy?**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**能否将特性用于不同类型层次结构中的对象？**'
- en: Yes, traits are not restricted by how the abstract type hierarchy is defined.
    The same trait can be assigned to objects coming from different type hierarchies.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，特性不受抽象类型层次结构定义方式的限制。相同的特性可以分配给来自不同类型层次结构的对象。
- en: '**What are the benefits of parametric types?**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数类型有哪些好处？**'
- en: Parametric types allow us to define a template for data types. New data types
    can be created programmatically by filling in parameters. The primary benefit
    of parametric type is that the code becomes shorter because we do not need to
    spell out every possible concrete type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 参数类型允许我们为数据类型定义一个模板。可以通过填充参数来程序性地创建新的数据类型。参数类型的主要好处是代码变得更短，因为我们不需要列出每个可能的具体类型。
- en: '**How do we store information with a parametric type?**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何使用参数类型来存储信息？**'
- en: Additional information can be *stored* in the type itself as a parameter. It
    is quite convenient to access such data because it is first-class and is available
    in the function that takes parametric type arguments.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将额外的信息作为参数存储在类型本身中。访问此类数据非常方便，因为它是第一类数据，并且可以在接受参数类型参数的函数中使用。
- en: Chapter 6
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章
- en: '**Why does the use of global variables impact performance?**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用全局变量会影响性能？**'
- en: Global variables are not typed. Whenever it is used, the compiler must generate
    code that handles any possible data types that it may encounter. Hence, the compiler
    cannot generate highly-optimized code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量是无类型的。每次使用时，编译器都必须生成可以处理可能遇到的所有数据类型的代码。因此，编译器不能生成高度优化的代码。
- en: '**What would be a good alternative to using a global variable when it cannot
    be replaced by a constant?**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**当无法用常量替换时，使用全局变量的良好替代方案是什么？**'
- en: We can define a typed global constant as a placeholder. The `Ref` type may also
    be used to hold a single value for the variable. Because `Ref` contains the type
    of data, the compiler can generate more optimized code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个有类型的全局常量作为占位符。`Ref`类型也可以用来保存变量的单个值。因为`Ref`包含数据类型，编译器可以生成更优化的代码。
- en: '**Why does a struct of arrays perform better than an array of structs?**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么数组结构体比结构体数组表现更好？**'
- en: Modern CPUs can perform many numerical calculations in parallel. When the memory
    is aligned and packed together as in an array, the hardware cache can quickly
    look them up. An array of structs may have the objects scattered around in memory,
    which hurts performance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU可以并行执行许多数值计算。当内存对齐并打包成数组时，硬件缓存可以快速查找它们。结构体数组可能将对象散布在内存中，这会损害性能。
- en: '**What are the limitations of** `SharedArray`**?**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**`SharedArray`的局限性是什么？**'
- en: '`SharedArray` only supports bit types. If we need to process non-bits type
    data in parallel, then we cannot use SharedArrays.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedArray`只支持位类型。如果我们需要并行处理非位类型数据，那么就不能使用SharedArrays。'
- en: '**What is an alternative to multi-core computation instead of using parallel
    processes?**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**除了使用并行进程之外，有什么是替代多核计算的方法？**'
- en: An alternative is to use the multithreading facility. The Julia 1.3 release
    implemented a state-of-the-art multi-threading scheduler that supports multiple
    levels of parallelism.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方案是使用多线程功能。Julia 1.3版本实现了一个支持多级并行的最先进的多线程调度器。
- en: '**What kind of care must be taken when using the memoization pattern?**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**在使用缓存模式时，必须注意哪些问题？**'
- en: Memoization trades space with time. The use of a cache demands more memory space.
    Depending on the function result, it may or may not impact the memory footprint
    of the application. If memory is already constrained in the system, it may not
    be the best option.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存化以空间换取时间。使用缓存需要更多的内存空间。根据函数结果，它可能或可能不会影响应用程序的内存占用。如果系统中的内存已经受限，这可能不是最佳选择。
- en: '**What is the magic behind the barrier function in improving performance?**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能提升中屏障函数背后的魔法是什么？**'
- en: When using the `barrier` function, the compiler can specialize the function
    based upon the types of arguments being passed to the function. Even though the
    type of argument is unstable, when a new type is encountered, a new specialized
    function is compiled automatically.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`barrier`函数时，编译器可以根据传递给函数的参数类型来专门化函数。即使参数类型不稳定，当遇到新类型时，也会自动编译一个新的专门化函数。
- en: Chapter 7
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: '**What are afferent and efferent couplings?**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是输入耦合和输出耦合？**'
- en: Afferent coupling represents how many external components are depending on the
    current component. By contrast, efferent coupling represents how many external
    components the current one depends on. These measurements are useful in determining
    how tightly the current component is coupled with other ones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输入耦合表示有多少外部组件依赖于当前组件。相比之下，输出耦合表示当前组件依赖于多少外部组件。这些测量有助于确定当前组件与其他组件的耦合程度。
- en: '**Why are bi-directional dependencies bad from a maintainability perspective?**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**从可维护性的角度来看，双向依赖为什么不好？**'
- en: Bi-directional dependencies tend to introduce messy, spaghetti code. To comprehend
    a single component, the developer must work through and understand the other components 
    that it both uses and depends on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 双向依赖往往会引入混乱的意大利面条式代码。为了理解单个组件，开发者必须处理并理解它所使用和依赖的其他组件。
- en: '**What is an easy way to generate code on the fly?**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**有什么简单的方法可以即时生成代码？**'
- en: The `@eval` macro can be used to generate code. For example, it can be used
    inside a `for` loop so that variables can be interpolated into the definition
    of a function. The result is that multiple functions are defined, and they are
    all similar in terms of code structure and logic.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`@eval`宏可以用来生成代码。例如，它可以在`for`循环中使用，以便将变量插入到函数的定义中。结果是定义了多个函数，它们在代码结构和逻辑方面都相似。'
- en: '**What would be an alternative to code generation?**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码生成的替代方案是什么？**'
- en: Sometimes, code generation is not needed. Instead, the developer can choose
    to use a functional programming technique, such as closure, to reuse existing
    logic. Code generation may increase the program footprint and makes the program
    more difficult to debug. So, it would be prudent for a developer to consider other
    options before plunging into code generation technique.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，不需要代码生成。相反，开发者可以选择使用函数式编程技术，如闭包，来重用现有逻辑。代码生成可能会增加程序的大小，并使程序更难调试。因此，在深入代码生成技术之前，开发者考虑其他选项将是明智的。
- en: '**When and why should we consider building a domain-specific language?**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时以及为什么我们应该考虑构建一个特定领域的语言？**'
- en: A **Domain-Specific Language** (**DSL**) is often used for writing code that
    is clean and easy to understand for people in that particular domain. For example,
    the `DifferentialEquations` package allows the developer to write code in a syntax
    that is very similar to the corresponding mathematical equations. Because the
    syntax is user friendly, it allows the developer to focus on mathematic modeling
    rather than the coding aspect.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**特定领域语言（DSL**）通常用于编写特定领域内清晰且易于理解代码。例如，`DifferentialEquations`包允许开发者使用与相应数学方程非常相似的语法编写代码。由于语法友好，它允许开发者专注于数学建模而不是编码方面。'
- en: '**What are the tools available for developing a domain-specific language?**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发特定领域语言有哪些可用的工具？**'
- en: The `MacroTools` package provides several convenient macros that are very helpful
    in writing macros and, in particular, domain-specific languages. The `@capture`
    macro allows users to perform pattern matching and parse source code. The `prewalk`
    and `postwalk` functions allow us to surgically replace expressions in an abstract
    syntax tree. The combination of `@capture` and `prewalk`/`postwalk` makes it a
    very powerful tool for developing domain-specific languages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`MacroTools`包提供了几个方便的宏，这些宏在编写宏和特定领域语言中非常有帮助。`@capture`宏允许用户执行模式匹配和解析源代码。`prewalk`和`postwalk`函数允许我们在抽象语法树中手术性地替换表达式。`@capture`和`prewalk`/`postwalk`的组合使其成为开发特定领域语言的一个非常强大的工具。'
- en: Chapter 8
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: '**What are the benefits of developing assessor functions?**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发评估函数有哪些好处？**'
- en: Assessor functions are a great way to provide an official API to users of the
    particular object. The underlying implementation is therefore decoupled from the
    interface. Should there be any changes to the implementation, there will be zero
    impact on users of the object as long as the contract of the assessor functions
    is unchanged.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 评估函数是向特定对象的用户提供官方 API 的绝佳方式。因此，底层实现与接口解耦。如果实现有任何变化，只要评估函数的契约保持不变，就不会对对象的用户产生任何影响。
- en: '**What would be an easy way to discourage the use of internal fields of an
    object?**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**有什么简单的方法可以阻止使用对象的内部字段？**'
- en: The easiest way to discourage the use of internal fields of an object is to
    have a special naming convention. A commonly used convention is to have an underscore
    as the prefix of the field name. If the programmer tries to use the field, then
    they are reminded that the field is supposed to be private.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用特殊的命名约定来阻止使用对象的内部字段。常用的约定是将下划线作为字段名称的前缀。如果程序员尝试使用该字段，那么他们会提醒自己该字段应该是私有的。
- en: '**Which functions may be extended as part of the property interface?**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**哪些函数可以作为属性接口的一部分进行扩展？**'
- en: There are three functions from the `Base` package that can be extended to provide
    specific functionalities to the dot notation for field access. The functions are
    `getproperty`, `setproperty!`, and `propertynames`. An important point to remember
    is that once these functions are defined, all direct field access has to be changed
    to `getfield` and `setfield!` to avoid the recursion problem.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Base` 包中有三个函数可以被扩展以提供特定功能，用于字段访问的点表示法。这些函数是 `getproperty`、`setproperty!` 和
    `propertynames`。一个需要记住的重要点是，一旦这些函数被定义，所有直接的字段访问都必须改为 `getfield` 和 `setfield!`
    以避免递归问题。'
- en: '**How can we capture the stack trace from a catch-block after an exception
    has been caught?**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何在捕获异常后从 catch-block 中捕获堆栈跟踪？**'
- en: Once an exception is caught, we can use the `catch_backtrace` function to capture
    the stack frames right before the exception was caught. We can then pass the result
    to the `stacktrace` function to retrieve an array of `StackFrame` objects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦捕获到异常，我们可以使用 `catch_backtrace` 函数来捕获异常被捕获之前的堆栈帧。然后我们可以将结果传递给 `stacktrace`
    函数以检索 `StackFrame` 对象的数组。
- en: '**What is the best way to avoid the performance impact of a try-catch block
    for a system that requires optimal performance?**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何避免对需要最佳性能的系统中的 try-catch 块的性能影响？**'
- en: The best way to avoid the performance impact of a try-catch block is to not
    use it at all. We should find other ways to handle exceptions. For example, we
    can check for any condition that might cause a subsequent function to fail. In
    that case, we can proactively handle such a scenario. Another option is to catch
    the exception outside of a loop; hence, we would handle the exception at a higher
    level.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 try-catch 块的性能影响最好的方法是根本不使用它。我们应该找到其他处理异常的方法。例如，我们可以检查任何可能导致后续函数失败的条件。在这种情况下，我们可以主动处理这种情况。另一种选择是在循环外部捕获异常；因此，我们会在更高的级别处理异常。
- en: '**What are the benefits of using the `retry` function?**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 `retry` 函数有哪些好处？**'
- en: The `retry` function is a great way to automatically repeat an operation that
    may fail. Doing this ensures that important tasks are guaranteed to be completed,
    barring other types of unrecoverable exceptions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry` 函数是一种自动重复可能失败的操作的绝佳方式。这样做可以确保重要任务能够得到保证完成，除非有其他类型的不可恢复异常。'
- en: '**How do we hide away global variables and functions that are used internally
    in a module?**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何隐藏模块内部使用的全局变量和函数？**'
- en: We can use a let-block so that global variables are bound as part of the let-block
    and not exposed to the global scope of the module. Functions that are defined
    inside the let-block can be declared as global when we need to expose them to
    the module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 let-block，这样全局变量就被绑定在 let-block 中，而不是暴露在模块的全局作用域中。当需要将函数暴露给模块时，定义在 let-block
    内部的函数可以被声明为全局。
- en: Chapter 9
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: '**What predefined data type can be used to conveniently create new singleton
    types?**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**可以使用哪种预定义的数据类型方便地创建新的单例类型？**'
- en: The built-in `Val` type can be used to create new singleton types easily. The `Val` constructor
    function can accept any bits-type value and return a singleton of type `Val{X}`,
    where `X` is the value being passed to the constructor function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `Val` 类型可以轻松地创建新的单例类型。`Val` 构造函数可以接受任何位类型值，并返回类型为 `Val{X}` 的单例，其中 `X` 是传递给构造函数的值。
- en: '**What are the benefits of using singleton type dispatch?**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用单例类型分发的优点是什么？**'
- en: Using singleton type dispatch, we can eliminate conditional statements that
    depend on the data type. It also allows us to add new functionalities by just
    defining new functions, without having to modify an existing function. Because
    Julia does the dispatch natively, there is no need to create any custom function
    just for dispatch.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单例类型分发，我们可以消除依赖于数据类型的条件语句。它还允许我们通过仅定义新函数来添加新功能，而无需修改现有函数。因为Julia原生支持分派，所以不需要创建任何自定义函数仅用于分派。
- en: '**Why do we want to create stubs?**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么我们要创建模拟器？**'
- en: Stubs are very useful indeed in automated testing. First, if a function requires
    connecting to a remote web service, then it can be inconvenient or even costly
    to connect to the live service all of the time. In that case, a stub can be used
    to replace the service. Second, a stub can be designed to exercise all positive
    and negative scenarios so that desired tests can be included in the automated
    testing process.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器在自动化测试中非常有用。首先，如果一个函数需要连接到远程网络服务，那么始终连接到实时服务可能不方便，甚至可能成本高昂。在这种情况下，可以使用模拟器来代替服务。其次，模拟器可以被设计成测试所有正面和负面场景，以便将所需的测试包含在自动化测试过程中。
- en: '**What is the difference between mocking and stubbing?**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟和模拟之间的区别是什么？**'
- en: Stubbing focuses on state verification, that is, what comes out of the **Function
    Under Test** (**FUT**) after the stub is used. Mocking, on the other hand, focuses
    on behavior verification, that is, how the mocked function was used by the FUT.
    In general, mocking also includes state verification just like stubs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器关注的是状态验证，即在模拟器使用后**被测试函数**（**FUT**）的输出。另一方面，模拟关注的是行为验证，即模拟函数是如何被FUT使用的。一般来说，模拟也像模拟器一样包括状态验证。
- en: '**What does composability mean?**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合性意味着什么？**'
- en: Composability means how easy functions can be combined to create something greater.
    Composable functions allow applications to be built by reusing existing code.
    Because functions are first-class in Julia, they can be combined easily, as long
    as the functions accept only a single argument.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 组合性意味着函数可以组合起来创建更大的东西有多容易。可组合函数允许通过重用现有代码来构建应用程序。因为函数在Julia中是一等公民，所以只要函数只接受单个参数，它们就可以很容易地组合。
- en: '**What is the primary constraint for using functional pipes?**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用功能管道的主要约束是什么？**'
- en: The primary constraint of functional pipes is that functions participating in
    the pipe can only accept a single argument. Functions that need more than one
    argument can be transformed to a `curried` function such that the higher-order
    function can participate in the pipe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 功能管道的主要约束是管道中参与的功能只能接受单个参数。需要多个参数的函数可以被转换为一个`curried`函数，这样高阶函数就可以参与管道。
- en: '**How are functional pipes useful?**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能管道有什么用途？**'
- en: Functional pipes can be useful for data processing pipelines, especially if
    the process is linear in nature. The syntax is easy to read for some people.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 功能管道对于数据处理管道非常有用，特别是如果过程本质上是线性的。对于某些人来说，语法易于阅读。
- en: Chapter 10
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: '**What are the risks and potential benefits of Type I piracy?**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**一级盗版的风险和潜在好处是什么？**'
- en: Type I piracy refers to a situation where a third-party function is redefined
    with a custom implementation. The risk is that custom implementation may not conform
    to the contract as expected by the third-party module. Coded incorrectly, the
    system may become unstable and crash.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一级盗版指的是第三方功能被自定义实现重新定义的情况。风险在于自定义实现可能不符合第三方模块预期的合同。如果代码编写错误，系统可能会变得不稳定并崩溃。
- en: '**What kind of problems can arise due to Type II piracy?**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**由于二级盗版可能会出现什么问题？**'
- en: Type II piracy refers to a situation where a third-party function is extended
    without using your own types in the function arguments. It can be problematic
    because there is no guarantee that another dependent package also implements Type
    II piracy, conflicting with your pirate function. The result can be an unstable
    system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 二级盗版指的是在函数参数中不使用自己的类型扩展第三方功能的情况。这可能会出现问题，因为没有保证另一个依赖包也实现了二级盗版，可能与你的盗版函数冲突。结果可能是一个不稳定的系统。
- en: '**How does Type III piracy cause trouble?**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**三级盗版是如何引起麻烦的？**'
- en: Type III piracy refers to a situation where a third-party function is extended
    with your own types but for a different purpose. While the function is defined
    using a custom type in the argument, there is no guarantee that the third-party
    module does not end up using your own function due to duck typing. Hence, your
    pirate function leaks into the third-party module and causes unexpected results.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类型III盗用指的是一种情况，即第三方函数通过您的自定义类型进行了扩展，但目的不同。虽然函数定义使用自定义类型作为参数，但无法保证第三方模块不会因为鸭子类型而最终使用您的函数。因此，您的盗用函数泄漏到第三方模块中，导致意外结果。
- en: '**What should we watch out for when specifying function arguments?**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**在指定函数参数时，我们应该注意哪些问题？**'
- en: When specifying function arguments, we should avoid making the argument types
    too narrow. Arguments that are too narrow limit the reusability of the function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定函数参数时，我们应该避免使参数类型过于狭窄。过于狭窄的参数限制了函数的可重用性。
- en: '**How is system performance affected by using abstract function arguments?**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用抽象函数参数如何影响系统性能？**'
- en: System performance is not affected when function arguments are specified with
    abstract types. Julia always specifies the function depending on the type that
    is passed into the function. Hence, there is no runtime overhead.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用抽象类型指定函数参数时，系统性能不受影响。Julia总是根据传递给函数的类型来指定函数。因此，没有运行时开销。
- en: '**How is system performance affected by using abstract field types for composite
    types?**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用抽象字段类型为复合类型时，系统性能如何受到影响？**'
- en: System performance is affected negatively when abstract types are used for fields
    in a composite type. The Julia compiler must store pointers in memory for these
    objects because it has to support any data types relevant to those fields. Because
    pointers must be dereferenced to get to the data, system performance can be degraded
    greatly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当在复合类型的字段中使用抽象类型时，系统性能会受到负面影响。Julia编译器必须在内存中存储这些对象的指针，因为它必须支持与这些字段相关的任何数据类型。因为必须解引用指针才能访问数据，所以系统性能可能会大幅下降。
- en: Chapter 11
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: '**What technique can we use to implement the abstract factory pattern?**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们可以使用什么技术来实现抽象工厂模式？**'
- en: To implement the abstract factory pattern, we can create a hierarchy of abstract
    types. Then, we can implement concrete functions that take a singleton type in
    the argument. By way of multiple dispatches, we should be able to call the right
    function for the right platform or environment.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现抽象工厂模式，我们可以创建一个抽象类型的层次结构。然后，我们可以实现接受单例类型作为参数的具体函数。通过多分派，我们应该能够调用适合正确平台或环境的正确函数。
- en: '**How do we avoid a singleton from being initialized multiple times in a multithreaded
    application?**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何在多线程应用程序中避免单例被多次初始化？**'
- en: To avoid multiple initializations of a singleton, we can use a reentrant lock
    to synchronize the threads. The first thread would be able to obtain the lock
    and initialize the singleton, while the other threads should wait until the initialization
    is finished. The lock must be released at the end of the initialization.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免单例的多次初始化，我们可以使用可重入锁来同步线程。第一个线程将能够获取锁并初始化单例，而其他线程应在初始化完成后等待。必须在初始化结束时释放锁。
- en: '**What Julia feature is essential for implementing the observer pattern?**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现观察者模式时，Julia的哪个特性是必不可少的？**'
- en: We can implement the `setproperty!` function so that all updates to an object's
    field can be monitored and additional actions can be triggered.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现`setproperty!`函数，以便可以监控对象的字段的所有更新，并触发额外的操作。
- en: '**How can we customize an operation using the template method pattern?**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何使用模板方法模式来自定义操作？**'
- en: We can design the template function to take in customized functions via keyword
    arguments. A keyword argument may be defaulted to a standard implementation, and
    at the same time a custom function can be passed by the caller. The expected interface
    of the function should be clearly documented.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计模板函数，通过关键字参数接受自定义函数。关键字参数可以默认为标准实现，同时调用者也可以传递自定义函数。函数的预期接口应该有明确的文档说明。
- en: '**How do we make an adapter to implement a target interface?**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何制作适配器以实现目标接口？**'
- en: We can make an adapter by creating a new type that wraps the original type.
    Then, we can implement the expected interface on the new type. Using a delegation
    pattern, the new type can reuse existing functionality by forwarding specific
    functions to the original type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个新的类型来包装原始类型来制作一个适配器。然后，我们可以在新类型上实现预期的接口。使用委托模式，新类型可以通过将特定函数转发到原始类型来重用现有功能。
- en: '**What are the benefits of the flyweight pattern and what strategy can we use
    to achieve that?**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**享元模式有哪些好处，我们可以使用什么策略来实现它？**'
- en: We can potentially save a lot of memory space when using the flyweight pattern
    because objects are shared. The general technique is to maintain a reference table
    that uses a more compact data element as a lookup key. The key is used to look
    up the more memory-intensive objects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用享元模式时，由于对象是共享的，我们可以潜在地节省大量内存空间。一般技术是维护一个参考表，该表使用更紧凑的数据元素作为查找键。该键用于查找更占用内存的对象。
- en: '**What Julia feature can we use to implement the strategy pattern?**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们可以使用 Julia 的哪个特性来实现策略模式？**'
- en: We can implement the strategy pattern using singleton types as functional arguments.
    The function with the proper algorithm (strategy) is automatically selected at
    runtime by multiple dispatch.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单例类型作为函数参数来实现策略模式。具有适当算法（策略）的函数在运行时通过多重分派自动选择。
- en: Chapter 12
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章
- en: '**How does implementation inheritance differ from behavior subtyping?**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现继承与行为子类型化有何不同？**'
- en: Implementation inheritance allows a subclass to inherit both fields and methods
    from a super-class. Behavior subtyping allows a subtype to inherit methods defined
    for a super-type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承允许子类从超类继承字段和方法。行为子类型化允许子类型继承为超类型定义的方法。
- en: '**What are some major issues associated with implementation inheritance?**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**与实现继承相关的一些主要问题是什么？**'
- en: Implementation inheritance is problematic because sometimes, the subclass may
    not want to inherit the fields from a super-class even when it makes logical sense
    to define the parent-child relationship. As demonstrated from the square-rectangle
    problem, a subclass may be more restrictive and take away features rather than
    adding new functionality on top of the super-class. Second, implementation inheritance
    suffers from the fragile base class issue, for which changes to the super-class
    may unintentionally modify the behavior of the subclass.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实现继承是有问题的，因为有时，子类可能不想从超类继承字段，即使定义父子关系在逻辑上是有意义的。正如从正方形-矩形问题中所示，子类可能更加限制性，并移除功能，而不是在超类之上添加新功能。其次，实现继承受到脆弱基类问题的困扰，对超类的更改可能无意中修改了子类的行为。
- en: '**What is duck typing?**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是鸭式类型？**'
- en: Duck typing is a dynamic feature that allows a method to be dispatched without
    strong type checking. A function may be dispatched as long as it adheres to the
    expected interface contract.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭式类型是一种动态特性，它允许在不进行强类型检查的情况下分发方法。只要函数遵循预期的接口合约，就可以分发函数。
- en: '**What is the variance of method arguments and why?**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法参数的变异性是什么，为什么？**'
- en: Method arguments are covariant as they are consistent with the Liskov Substitution
    Principle, which states that a function that is defined to accept type *S* should
    be able to work with any subtype of *S*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数是协变的，因为它们与 Liskov 替换原则一致，该原则指出，定义为接受类型 *S* 的函数应该能够与 *S* 的任何子类型一起工作。
- en: '**Why are parametric types invariant in Julia?**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么在 Julia 中参数化类型是不变的？**'
- en: Parametric types are invariant in Julia for a very practical reason. The type
    parameter unambiguously determines the memory layout of the underlying container.
    When it is invariant, there is an opportunity to achieve high performance by compacting
    storage data consecutively without having to dereference pointers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，参数化类型是不变的，这是一个非常实际的原因。类型参数明确地确定了底层容器的内存布局。当它是不变的，就有机会通过连续压缩存储数据来达到高性能，而不需要解引用指针。
- en: '**When does the diagonal rule apply?**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**对角线规则何时适用？**'
- en: The diagonal rule is applied whenever a type variable occurs more than once
    in a covariance position. There is an exception to the rule when the same type
    variable is unambiguously determined from an invariant position such as in a parametric
    type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型变量在协变位置出现多次时，会应用对角线规则。当从不变位置（如参数化类型）明确确定相同的类型变量时，该规则存在例外。
