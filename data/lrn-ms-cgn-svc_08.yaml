- en: Chapter 8. Querying Structured Data in a Natural Way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 以自然方式查询结构化数据
- en: In the previous chapter, we learned how we can use the current context to extend
    our knowledge on a certain topic. Throughout this chapter, we will continue discussing
    about the knowledge APIs. More specifically, we will learn how to explore relationships
    between academic papers and journals. We will see how we can interpret natural
    language queries, and retrieve query expressions. Using these expressions, we
    will learn how to find academic entities. We will then focus more on how to set
    up this kind of service on your own. At the end of this chapter, we will look
    at QnA Maker to see how we can create FAQ services from existing content.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何利用当前上下文来扩展我们对某个主题的知识。在本章中，我们将继续讨论关于知识API的内容。更具体地说，我们将学习如何探索学术论文和期刊之间的关系。我们将看到如何解释自然语言查询，并检索查询表达式。使用这些表达式，我们将学习如何找到学术实体。然后，我们将更多地关注如何在个人设置中建立此类服务。在本章结束时，我们将探讨QnA
    Maker，看看如何从现有内容中创建FAQ服务。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Interpreting natural-language user queries using Project Academic Knowledge
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目学术知识解释自然语言用户查询
- en: Assisting the user with queries using autocomplete features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动完成功能协助用户进行查询
- en: Using autocomplete queries to retrieve academic entities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动完成查询检索学术实体
- en: Calculating the distribution of academic entities from queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从查询中计算学术实体的分布
- en: Hosting the Project Knowledge Exploration Service with your own schema
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自己的模式托管项目知识探索服务
- en: Creating an FAQ service from existing content using QnA Maker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QnA Maker从现有内容创建FAQ服务
- en: Tapping into academic content using the academic API
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用学术API获取学术内容
- en: '**Microsoft Academic Graph** (**MAG**) is a knowledge base for web-scale, heterogeneous
    entity graphs. Entities model scholarly activities, and contain information such
    as the field of study, author(s), institution, and more.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft Academic Graph** (**MAG**) 是一个用于网络规模、异构实体图的数据库。实体模型了学术活动，并包含诸如研究领域、作者、机构等信息。'
- en: Data contained in MAG is indexed from the Bing web index. As this is continuously
    indexed, the data is always up to date.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MAG中的数据是从Bing网络索引中索引的。由于这些数据持续被索引，因此数据始终是最新的。
- en: Using the Project Academic Knowledge API, we can tap into this knowledge base.
    This API allows us to combine search suggestions, research paper graph search
    results, and histogram distributions. The API enables a knowledge-driven and interactive
    dialog.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用项目学术知识API，我们可以访问这个知识库。此API允许我们结合搜索建议、研究论文图搜索结果和直方图分布。该API支持知识驱动和交互式对话。
- en: When a user searches for research papers, the API can provide query completion.
    It may suggest queries based on the input. With a complete query, we can evaluate
    a query expression. This will retrieve a set of matching paper entities from the
    knowledge base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户搜索研究论文时，API可以提供查询补全。它可能会根据输入建议查询。使用完整的查询，我们可以评估查询表达式。这将从知识库中检索一组匹配的论文实体。
- en: Setting up an example project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置示例项目
- en: To test Project Academic Knowledge, we will first want to create a new example
    project. We will create this from the MVVM template created in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Microsoft Cognitive Services"), *Getting Started
    with Microsoft Cognitive Services*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试项目学术知识，我们首先需要创建一个新的示例项目。我们将从[第1章](ch01.html "第1章. 使用Microsoft认知服务入门")中创建的MVVM模板开始，即*使用Microsoft认知服务入门*。
- en: Project Academic Knowledge does not have any client packages available. This
    means that we need to call the API ourselves. Copy the `WebRequest.cs` file from
    the `Model` folder in the smart house application and paste it into the `Model`
    folder of the newly created project. Make sure that you correct the namespace.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 项目学术知识没有提供任何客户端包。这意味着我们需要自己调用API。从智能家居应用程序的`Model`文件夹中复制`WebRequest.cs`文件，并将其粘贴到新创建的项目中的`Model`文件夹中。确保您已正确修改命名空间。
- en: To be able to compile this, we will need to add references to `System.Web` and
    `System.Runtime.Serializable`. We will also be working with JSON, so go ahead
    and add the `Newtonsoft.Json` package through the NuGet package manager.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够编译此内容，我们需要添加对`System.Web`和`System.Runtime.Serializable`的引用。我们还将处理JSON，因此请通过NuGet包管理器添加`Newtonsoft.Json`包。
- en: As this will be the only API tested in this sample project, we can add UI elements
    in the `MainView.xaml` file. Open this file now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将是本示例项目中唯一测试的 API，我们可以在 `MainView.xaml` 文件中添加 UI 元素。现在打开此文件。
- en: Our `View` should have a `TextBox` element for our input query. It should have
    a `ComboBox` element to list the suggested query expressions. We need three `Button`
    elements, one for `Interpret`, one for `Evaluate`, and one for `Histogram`, which
    are all functions we will be executing. Last but not least, we need a `TextBox`
    element to display our results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `View` 应该有一个 `TextBox` 元素用于我们的输入查询。它应该有一个 `ComboBox` 元素来列出建议的查询表达式。我们需要三个
    `Button` 元素，一个用于 `Interpret`，一个用于 `Evaluate`，一个用于 `Histogram`，这些都是我们将要执行的功能。最后但同样重要的是，我们需要一个
    `TextBox` 元素来显示我们的结果。
- en: In the `MainViewModel.cs` file, we will need to add corresponding properties.
    Add three `string` properties, one for the input query, one for the results, and
    one for the selected query expression. Add an `ObservableCollection` property
    of the `string` type for our available query expressions. We also need three `ICommand`
    properties, one for each of our buttons.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainViewModel.cs` 文件中，我们需要添加相应的属性。添加三个 `string` 类型的属性，一个用于输入查询，一个用于结果，一个用于选定的查询表达式。添加一个
    `ObservableCollection` 属性，类型为 `string`，用于我们的可用查询表达式。我们还需要三个 `ICommand` 属性，分别对应我们的按钮。
- en: 'Add a private member for our `WebRequest` object. Make the constructor look
    like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的 `WebRequest` 对象添加一个私有成员。使构造函数看起来如下：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have not already done so, sign up for an API key at [https://labs.cognitive.microsoft.com/en-us/project-academic-knowledge](https://labs.cognitive.microsoft.com/en-us/project-academic-knowledge)
    and click the **Subscribe** button.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请在 [https://labs.cognitive.microsoft.com/en-us/project-academic-knowledge](https://labs.cognitive.microsoft.com/en-us/project-academic-knowledge)
    上注册 API 密钥并点击 **Subscribe** 按钮。
- en: The `CanInterpret` parameter should return `true` if we have entered any text
    into the query textbox. The `CanExecuteCommands` parameter should return `true`
    if we have selected a query expression. We will cover `Interpret`, `Evaluate`,
    and the `CalculateHistogram` parameters in the upcoming sections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在查询文本框中输入任何文本时，`CanInterpret` 参数应返回 `true`。如果已选择查询表达式，则 `CanExecuteCommands`
    参数应返回 `true`。我们将在接下来的章节中介绍 `Interpret`、`Evaluate` 和 `CalculateHistogram` 参数。
- en: Make sure that the application compiles and runs before continuing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保应用程序可以编译并运行。
- en: Interpreting natural language queries
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释自然语言查询
- en: The query expressions that the API uses to evaluate a query are not in a natural
    language format. To ensure that users can make queries in a natural way, we need
    to interpret their input.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: API 用来评估查询的查询表达式不是自然语言格式。为了确保用户可以以自然的方式提出查询，我们需要解释他们的输入。
- en: When calling the `Interpret` feature of the API, it accepts a query string.
    This will be returned and formatted to reflect the user intent using academic
    grammar. In addition, this feature can be called as the user is writing, to provide
    an interactive experience.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 API 的 `Interpret` 功能时，它接受一个查询字符串。这将返回并格式化以反映用户意图，使用学术语法。此外，此功能可以在用户编写时调用，以提供交互式体验。
- en: 'The request is a `GET` request, as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请求是一个 `GET` 请求，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We start the call by creating a `queryString` variable. The parameters we can
    input are specified in the following table:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个 `queryString` 变量来开始调用。我们可以输入的参数如下表所示：
- en: '| Parameter | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `query` (required) | The query from the user. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `query` (必需) | 用户的查询。 |'
- en: '| `complete` (optional) | If this is set to `1`, then the service will return
    suggestions using the query as a prefix. A value of `0` means there will be no
    autocomplete. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `complete` (可选) | 如果设置为 `1`，则服务将使用查询作为前缀返回建议。值为 `0` 表示将没有自动完成。 |'
- en: '| `count` (optional) | The maximum number of interpretations to return. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `count` (可选) | 返回的最大解释数量。 |'
- en: '| `offset` (optional) | The index of the first interpretation. This is useful
    if a lot of results are expected and you need to add pagination. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `offset` (可选) | 首个解释的索引。如果预期有很多结果并且需要添加分页，这很有用。 |'
- en: '| `timeout` (optional) | The timeout specified in milliseconds. Only results
    found before this limit will be returned. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `timeout` (可选) | 指定的超时时间（毫秒）。只有在此限制之前找到的结果将被返回。 |'
- en: '| `model` (optional) | The name of the model you want to query. This defaults
    to the latest model. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `model` (可选) | 你想要查询的模型名称。默认为最新模型。 |'
- en: 'We call the API to get interpretations, as shown in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用API获取解释，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As this is a `GET` request, we do not need to specify any request bodies. We
    do, however, expect a result to be serialized into an `InterpretResponse` object.
    This is a data contract, containing properties from the result.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 `GET` 请求，我们不需要指定任何请求体。然而，我们期望结果被序列化为一个 `InterpretResponse` 对象。这是一个数据合约，包含来自结果属性。
- en: 'A successful call to the API will result in a JSON response, which looks as
    follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用API将导致JSON响应，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The result contains the original `query`. It also contains an array with `interpretations`.
    Each item in this array consists of the data shown in the following table:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结果包含原始 `query`。它还包含一个包含 `interpretations` 的数组。该数组中的每个项目都由以下表格中的数据组成：
- en: '| Data field | Description |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 数据字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `prob` | This is the probability of the current interpretation being correct.
    The scale goes from `0` to `1`, where `1` is the highest. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `prob` | 这是当前解释正确的概率。范围从 `0` 到 `1`，其中 `1` 是最高的。|'
- en: '| `parse` | This is an XML string showing interpretations for each part of
    the string. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `parse` | 这是一个XML字符串，显示了字符串每个部分的解释。|'
- en: '| `rules` | This is an array with one or more rules defined. There will always
    be one rule for the academic API. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `rules` | 这是一个包含一个或多个定义的规则的数组。对于学术API，始终有一个规则。|'
- en: '| `rules[x].name` | This is the name of the current rule. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `rules[x].name` | 这是当前规则的名称。|'
- en: '| `rules[x].output` | This is the output of the current rule. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `rules[x].output` | 这是当前规则的输出。|'
- en: '| `rules[x].output.type` | This is the type of the rule output. This will always
    be `query` for the academic API. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `rules[x].output.type` | 这是规则输出的类型。对于学术API，这始终是 `query`。|'
- en: '| `rules[x].output.value` | This is the output value for the rule. This will
    be a query expression string. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `rules[x].output.value` | 这是规则的输出值。这将是查询表达式字符串。|'
- en: Create the `InterpretResponse` data contract based on the preceding JSON output.
    We are interested in the last data field, `rules[x].output.value`. This is the
    query expression string, which we will use to evaluate queries.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的JSON输出创建 `InterpretResponse` 数据合约。我们感兴趣的是最后的数据字段，`rules[x].output.value`。这是查询表达式字符串，我们将用它来评估查询。
- en: 'When the API call has succeeded, we want to update the `ObservableCollection`
    class as to the available query expressions, using the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当API调用成功时，我们想要使用以下代码更新 `ObservableCollection` 类以反映可用的查询表达式：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We loop through all `interpretations`, adding the `outputvalue` from a rule
    to our `AvailableQueryExpressions`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历所有 `interpretations`，将规则中的 `outputvalue` 添加到我们的 `AvailableQueryExpressions`
    中。
- en: Finally, we set the selected `QueryExpression` as the first one available. This
    is just for our own convenience.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将选定的 `QueryExpression` 设置为第一个可用的。这只是为了我们自己的方便。
- en: 'A successful test run can generate the following results:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的测试运行可以生成以下结果：
- en: '![Interpreting natural language queries](img/B12373_08_01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![自然语言查询的解析](img/B12373_08_01.jpg)'
- en: 'An unsuccessful call will produce an error response code. The response codes
    that can be generated are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不成功的调用将产生错误响应代码。可以生成的响应代码如下：
- en: '| Response code | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 响应代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `400` | Bad argument; request parameter is missing |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 错误的参数；请求参数缺失 |'
- en: '| `401` | Invalid subscription key |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `401` | 无效的订阅密钥 |'
- en: '| `403` | The call volume quota has been exceeded |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `403` | 调用量配额已超过 |'
- en: '| `404` | The requested resources are not found |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `404` | 请求的资源未找到 |'
- en: '| `500` | Internal server error |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `500` | 内部服务器错误 |'
- en: Finding academic entities in query expressions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在查询表达式中查找学术实体
- en: Now that we have a query expression available, we can retrieve a set of academic
    entities using the `Evaluate` endpoint. This is a `GET` request, where we need
    to specify the attributes we want returned for each entity. We will cover the
    available attributes later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可用的查询表达式，我们可以使用 `Evaluate` 端点检索一组学术实体。这是一个 `GET` 请求，我们需要指定我们想要为每个实体返回的属性。我们将在稍后介绍可用的属性。
- en: 'We start by creating a query string, as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个查询字符串，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The parameters we can add are described in the following table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加的参数如下表所述：
- en: '| Parameter | Description |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `expr` (required) | This is the query expression found in the `Interpret`
    call. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `expr` (必需) | 这是 `Interpret` 调用中找到的查询表达式。|'
- en: '| `attributes` (optional) | This is a comma-separated list of attributes to
    be included in the response. Each attribute is case-sensitive. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `attributes` (可选) | 这是要包含在响应中的属性逗号分隔列表。每个属性都是大小写敏感的。 |'
- en: '| `model` (optional) | This is the model you wish to use for a query. This
    defaults to the latest model. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `model` (可选) | 这是要用于查询的模型。默认为最新模型。 |'
- en: '| `count` (optional) | This is the number of entities to return. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `count` (可选) | 这是要返回的实体数量。 |'
- en: '| `offset` (optional) | This is the index of the first result to return; it
    can be useful for pagination purposes. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `offset` (可选) | 这是要返回的第一个结果的索引；它可以用于分页目的。 |'
- en: '| `orderby` (optional) | This specifies the order in which to sort the entities.
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `orderby` (可选) | 这指定了排序实体的顺序。 |'
- en: Note that, while the `attributes` parameter is optional, you should specify
    which attributes you want. If none are specified, only the entity ID is returned.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然 `attributes` 参数是可选的，但您应该指定您想要的属性。如果没有指定任何属性，则只返回实体 ID。
- en: 'We call the API, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式调用 API：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As this is a `GET` request, we do not need any request bodies. With a successful
    call, we expect an `EvaluateResponse` object in return. This is a data contract,
    which will be deserialized from the JSON response.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 `GET` 请求，我们不需要任何请求体。成功的调用将返回一个 `EvaluateResponse` 对象。这是一个数据合约，它将从 JSON
    响应反序列化。
- en: 'A successful response will give a JSON response like the following code (depending
    on the attributes specified):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的响应将给出如下代码所示的 JSON 响应（取决于指定的属性）：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The response contains the query expression we used. It also contains an array
    of entities. Each item in this array will contain the probability of it being
    correct. It will also contain all the attributes that we specified, in the form
    of either string or numeric values. It can also be in the form of objects, which
    we will need to have data contracts for.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含我们使用的查询表达式。它还包含一个实体数组。数组中的每个项目将包含它正确的概率。它还将包含我们指定的所有属性，以字符串或数值形式呈现。它也可以是对象的形式，我们需要为这些对象提供数据合约。
- en: 'For our request, we specified some attributes. These were the entity ID, title,
    year and date of publication, citation count, and author name. Knowing these attributes,
    we can use the following code to output the result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的请求，我们指定了一些属性。这些是实体 ID、标题、出版年份和日期、引用次数和作者姓名。了解这些属性后，我们可以使用以下代码来输出结果：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A successful call can give the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用可以给出以下输出：
- en: '![Finding academic entities in query expressions](img/B12373_08_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![在查询表达式中查找学术实体](img/B12373_08_02.jpg)'
- en: Any error responses will produce response codes, as described previously.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 任何错误响应都将产生响应代码，如前所述。
- en: Calculating the distribution of attributes from academic entities
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算学术实体的属性分布
- en: Another feature of the academic API is the ability to calculate the distribution
    of attribute values for a set of paper entities. This can be done by calling the
    `calchistogram` API endpoint.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 学术 API 的另一个功能是能够计算一组论文实体的属性值分布。这可以通过调用 `calchistogram` API 端点来完成。
- en: 'This is a `GET` request, so we start by creating a query string, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `GET` 请求，因此我们首先创建一个查询字符串，如下所示：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The parameters we can specify are the same as with `Evaluate`, except that we
    do not have the `orderby` parameter. For this call, we want to get the year of
    publication (`Y`) and the name of the field of study (`F.FN`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定的参数与 `Evaluate` 相同，除了我们没有 `orderby` 参数。对于这个调用，我们想要获取出版年份（`Y`）和研究领域的名称（`F.FN`）。
- en: 'We make the call to the API without specifying any request bodies, as shown
    in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 API 时不指定任何请求体，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the call succeeds, we expect a `HistogramResponse` object in return. This
    is a data contract, which should contain the data from the JSON response.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用成功，我们期望返回一个 `HistogramResponse` 对象。这是一个数据合约，它应该包含来自 JSON 响应的数据。
- en: 'A successful request should give the following JSON response (depending on
    the requested attributes):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的请求应给出以下 JSON 响应（取决于请求的属性）：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The response contains the original query expression that we used. It will give
    us a count of the number of matching entities. An array of histograms will also
    be present. This will contain an item for each of the attributes we requested.
    The data for each item is described in the following table:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含我们使用的原始查询表达式。它将给出匹配实体的数量。还将出现一个直方图数组。这将包含我们请求的每个属性的项。每个项的数据在以下表格中描述：
- en: '| Data field | Description |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 数据字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `attribute` | This is the attribute name. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `attribute` | 这是属性名称。 |'
- en: '| `distinct_values` | This is the number of distinct values that match the
    entities for this attribute. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `distinct_values` | 这是匹配此属性实体的不同值的数量。 |'
- en: '| `total_count` | This is the total number of value instances among the matching
    entities for this attribute. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `total_count` | 这是匹配实体中此属性的所有值实例的总数。 |'
- en: '| `histogram` | This is an array containing the histogram data for this attribute.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `histogram` | 这是一个包含此属性直方图数据的数组。 |'
- en: '| `histogram[x].value` | This is the value for the current histogram. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `histogram[x].value` | 这是当前直方图的值。 |'
- en: '| `histogram[x].prob` | This is the probability that matching entities have
    this attribute value. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `histogram[x].prob` | 这是匹配实体具有此属性值的概率。 |'
- en: '| `histogram[x].count` | This is the number of matching entities that have
    this value. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `histogram[x].count` | 这是具有此值的匹配实体的数量。 |'
- en: 'With a successful response, we loop through the data, presenting it in the
    UI using the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 成功响应后，我们遍历数据，使用以下代码在UI中展示：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A successful call gives us the following result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的调用将返回以下结果：
- en: '![Calculating the distribution of attributes from academic entities](img/B12373_08_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![从学术实体中计算属性分布](img/B12373_08_03.jpg)'
- en: An unsuccessful API call will return an error, containing a response code. The
    potential response codes are the same as described in the previous section on
    the `Interpret` feature.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不成功的API调用将返回一个错误，包含一个响应代码。可能的响应代码与之前关于`Interpret`功能的章节中描述的相同。
- en: Entity attributes
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体属性
- en: A rather important element of this API is the usage of attributes. You will
    most definitely want to get some data from the query, but not all of the data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: API的一个重要元素是属性的用法。你肯定希望从查询中获取一些数据，但不是全部数据。
- en: 'We have previously seen how to specify attributes in each request. The following
    table describes all available attributes. Please make sure that all attributes
    specified in a request are correct per casing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到如何在每个请求中指定属性。以下表格描述了所有可用的属性。请确保请求中指定的所有属性都正确无误：
- en: '| Attribute | Description |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Id` | Entity ID |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `Id` | 实体ID |'
- en: '| `Ti` | Paper title |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `Ti` | 论文标题 |'
- en: '| `Y` | Paper year |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `Y` | 论文年份 |'
- en: '| `D` | Paper date |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 论文日期 |'
- en: '| `CC` | Citation count |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `CC` | 引用计数 |'
- en: '| `ECC` | Estimated citation count |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `ECC` | 估计引用计数 |'
- en: '| `AA.AuN` | Author name |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `AA.AuN` | 作者姓名 |'
- en: '| `AA.AuId` | Author ID |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `AA.AuId` | 作者ID |'
- en: '| `AA.AfN` | Author affiliation name |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `AA.AfN` | 作者所属机构名称 |'
- en: '| `AA.AfId` | Author affiliation ID |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `AA.AfId` | 作者所属机构ID |'
- en: '| `F.FN` | Name of field of study |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `F.FN` | 研究领域名称 |'
- en: '| `F.Fid` | Field of study ID |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `F.Fid` | 研究领域ID |'
- en: '| `J.JN` | Journal name |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `J.JN` | 期刊名称 |'
- en: '| `J.JId` | Journal ID |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `J.JId` | 期刊ID |'
- en: '| `C.CN` | Conference series name |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `C.CN` | 会议系列名称 |'
- en: '| `C.Cid` | Conference series ID |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `C.Cid` | 会议系列ID |'
- en: '| `Rid` | Reference ID |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `Rid` | 参考ID |'
- en: '| `W` | Words from the paper title/abstract for full text search |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `W` | 论文标题/摘要中的单词，用于全文搜索 |'
- en: '| `E` | Extended metadata |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `E` | 扩展元数据 |'
- en: 'The extended metadata is described in the following table:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展元数据在以下表格中描述：
- en: '| Attribute | Description |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DN` | Display name of the paper |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `DN` | 论文显示名称 |'
- en: '| `D` | Description |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 描述 |'
- en: '| `S` | Sources (web sources of the paper, sorted by static rank) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `S` | 来源（论文的网页来源，按静态排名排序） |'
- en: '| `S.Ty` | Source type (HTML/text/PDF/DOC/PPT/XLS/PS) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `S.Ty` | 来源类型（HTML/文本/PDF/DOC/PPT/XLS/PS） |'
- en: '| `S.U` | Source URL |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `S.U` | 来源URL |'
- en: '| `VFN` | Venue full name - full name of journal or conference |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `VFN` | 场地全名 - 期刊或会议的全名 |'
- en: '| `VSN` | Venue short name - short name of the journal or conference |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `VSN` | 场地简称 - 期刊或会议的简称 |'
- en: '| `V` | Journal volume |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `V` | 期刊卷号 |'
- en: '| `I` | Journal issue |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `I` | 期刊期号 |'
- en: '| `FP` | First page of paper |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `FP` | 论文第一页 |'
- en: '| `LP` | Last page of paper |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `LP` | 论文最后一页 |'
- en: '| `DOI` | Digital object identifier |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `DOI` | 数字对象标识符 |'
- en: Creating the backend using the Knowledge Exploration Service
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用知识探索服务创建后端
- en: The **Knowledge Exploration Service** (**KES**) is, in some ways, the backend
    for the academic API. It allows us to build a compressed index from structured
    data, authoring grammar to interpret natural language.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**知识探索服务**（**KES**）在某种程度上是学术API的后端。它允许我们从一个结构化数据中构建一个压缩索引，编写语法来解释自然语言。'
- en: To get started with the KES, we need to install the service locally.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用KES，我们需要在本地安装服务。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To download the KES installer, go to [https://www.microsoft.com/en-us/download/details.aspx?id=51488](https://www.microsoft.com/en-us/download/details.aspx?id=51488).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载KES安装程序，请访问 [https://www.microsoft.com/en-us/download/details.aspx?id=51488](https://www.microsoft.com/en-us/download/details.aspx?id=51488)。
- en: With the installation comes some example data, which we will use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程中会附带一些示例数据，我们将使用这些数据。
- en: 'The steps required to have a working service are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个工作的服务，所需的步骤如下：
- en: Define a schema
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个schema
- en: Generate data
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成数据
- en: Build the index
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建索引
- en: Author the grammar
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写语法
- en: Compile the grammar
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译语法
- en: Host the service
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 托管服务
- en: Defining attributes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义属性
- en: The `schema` file defines the attribute structure in our domain. When we previously
    discussed the academic API, we saw a list of different entity attributes, which
    we could retrieve through the queries. This is defined in a schema.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema` 文件定义了我们领域中的属性结构。当我们之前讨论学术API时，我们看到了一系列不同的实体属性，我们可以通过查询检索这些属性。这些在schema中定义。'
- en: If you open the `Academic.schema` file in the `Example` folder where the KES
    is installed, you will see the attributes defined. We have a title, year, and
    keyword, which are basic attribute types. In addition, we have a `Composite` attribute
    for the author. This attribute contains more attributes related to the author.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开KES安装的 `Example` 文件夹中的 `Academic.schema` 文件，你会看到定义的属性。我们有一个标题、年份和关键词，这些都是基本属性类型。此外，我们还有一个
    `Composite` 属性用于作者。这个属性包含与作者相关的更多属性。
- en: 'Each attribute will support all attribute operations. There may be cases where
    this is not desired. Explicitly defining the operations for a given attribute
    may reduce the index size. In the case of the author ID, we just want to be able
    to check whether it is equal to something, which we can achieve by adding the
    following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都将支持所有属性操作。可能存在不需要这种情况。为特定属性显式定义操作可能会减小索引大小。在作者ID的情况下，我们只想能够检查它是否等于某个值，这可以通过添加以下内容来实现：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding data
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据
- en: With a schema defined, we can add some data. The example contains a file, called
    `Academic.data`, which holds all the example data. Open the file to learn what
    the data can look like.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了schema之后，我们可以添加一些数据。示例中包含一个名为 `Academic.data` 的文件，它包含了所有示例数据。打开文件以了解数据可能的样子。
- en: Each line in the data file specifies the attribute values for an object. It
    can also contain a `logprob` value, which will indicate the return order of matching
    objects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数据文件中的每一行指定了一个对象的属性值。它也可以包含一个 `logprob` 值，这将指示匹配对象的返回顺序。
- en: Building the index
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建索引
- en: With the attribute schema and data file in place, we can build the compressed
    binary index. This will hold all our data objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了属性schema和数据文件之后，我们可以构建压缩的二进制索引。这将包含我们所有的数据对象。
- en: 'Using our example files, we can build the index by running the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的示例文件，我们可以通过运行以下命令来构建索引：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A successful execution should produce the `Academic.index` file, which we will
    use when we are hosting the service.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行应生成 `Academic.index` 文件，我们将用它来托管服务。
- en: 'When running the command, the application will continuously output the status,
    which can look like the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行命令时，应用程序将连续输出状态，可能看起来如下：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Understanding natural language
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自然语言
- en: After we have built an index, we can start creating our grammar file. This specifies
    what natural language the service can understand, and how it can translate into
    semantic query expressions. Open the `academic.xml` file to see an example of
    how a grammar file can look.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建索引之后，我们可以开始创建我们的语法文件。这指定了服务可以理解的自然语言，以及它如何将其翻译成语义查询表达式。打开 `academic.xml`
    文件，看看语法文件可以看起来像什么。
- en: The grammar is based on a **W3C** standard for speech recognition, called **SRGS**.
    The top-level element is the grammar element. This requires a `root` attribute
    to specify the root rule, which is the starting point of the grammar.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 语法基于一个名为**SRGS**的**W3C**语音识别标准。顶级元素是语法元素。这需要一个`root`属性来指定根规则，它是语法的起点。
- en: 'To allow attribute references, we add the `import` element. This needs to be
    a child of the `grammar` element, and should come before anything else. It contains
    two required attributes: the name of the schema file to import, and a name that
    elements can use for referencing the schema. Note that the schema file must be
    in the same folder as the grammar file.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许属性引用，我们添加`import`元素。这需要是`grammar`元素的子元素，并且应该在其他任何内容之前。它包含两个必需的属性：要导入的方案文件名称，以及元素可以用来引用方案的名字。请注意，方案文件必须与语法文件在同一个文件夹中。
- en: Next in line is the `rule` element. This defines a structural unit, which specifies
    what query expressions the service can interpret. A `rule` element requires an
    `id` attribute. Optionally, you can add an `example` element, which is used to
    describe phrases that may be accepted by the `rule` element. In that case, this
    will be a child element of the rule.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`rule`元素。这定义了一个结构单元，它指定了服务可以解释的查询表达式。`rule`元素需要一个`id`属性。可选地，你可以添加一个`example`元素，它用于描述可能被`rule`元素接受的短语。在这种情况下，这将是规则的子元素。
- en: A `rule` element also contains an `item` element. This groups a sequence of
    grammar constructs, and can be used to indicate repetitions of the sequence. Alternatively,
    it can be used to specify alternatives, together with one-of elements.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`rule`元素还包含一个`item`元素。这组成了一个语法构造的序列，可以用来指示序列的重复。或者，它可以用来指定替代方案，与one-of元素一起使用。'
- en: One-of elements specify expansions among one of the item elements. The item
    by may be defined as a one-of element, with written by and authored *by* as expansions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: One-of元素指定了项目元素之间的扩展。项目可以定义为one-of元素，其中“written by”和“authored by”作为扩展。
- en: Using the `ruleref` element allows us to create more complex expressions by
    using simpler rules. It simply references other rules by adding a URI attribute.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ruleref`元素，我们可以通过使用更简单的规则来创建更复杂的表达式。它只是通过添加URI属性来引用其他规则。
- en: The `attrref` element references an `index` attribute, which allows us to match
    against attributes in the index. The attribute URI is required, which must specify
    the index schema and attribute name to reference. This must match a schema that
    is imported through the `import` element.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`attrref`元素引用了`index`属性，这允许我们与索引中的属性进行匹配。属性URI是必需的，它必须指定要引用的索引模式和属性名称。这必须匹配通过`import`元素导入的模式。'
- en: The `tag` element defines the path through the grammar. This element allows
    you to assign variables or execute functions to help the flow of the grammar.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`元素定义了通过语法的路径。此元素允许你分配变量或执行函数以帮助语法的流程。'
- en: 'Once the grammar file is completed, we can compile it into binary grammar.
    This is done by running the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦语法文件完成，我们可以将其编译成二进制语法。这是通过运行以下命令来完成的：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running this command will produce output similar to the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将生成类似以下内容的输出：
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Local hosting and testing
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地托管和测试
- en: With the index and grammar in place, we can go on to test the service locally.
    Locally testing the service allows for rapid prototyping, which allows us to define
    the scheme and grammar quickly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引和语法就绪后，我们可以继续在本地测试服务。本地测试服务允许快速原型设计，这使我们能够快速定义方案和语法。
- en: When we are testing locally, the KES only supports up to 10,000 objects and
    10 requests per second. It also terminates after a total of 1,000 requests have
    been executed. We will learn how to bypass these restrictions in a bit.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本地测试时，KES仅支持最多10,000个对象和每秒10个请求。在执行了总共1,000个请求后，它也会终止。我们将在稍后学习如何绕过这些限制。
- en: 'To host the KES locally, run the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要本地托管KES，请运行以下命令：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will start up the service, running on port `8080`. To verify that it is
    working as intended, open your browser and go to `http://localhost:8080`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动在端口`8080`上运行的服务。为了验证它是否按预期工作，请打开您的浏览器并转到`http://localhost:8080`。
- en: 'Doing so should present you with the following screen:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做应该会显示以下屏幕：
- en: '![Local hosting and testing](img/B12373_08_04.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![本地托管和测试](img/B12373_08_04.jpg)'
- en: Running the KES as a local service also allows us to use the academic API for
    testing. We are going to make some modifications to our example application—created
    for the academic API—in order to support this.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将 KES 作为本地服务运行还允许我们使用学术 API 进行测试。我们将对我们的示例应用程序进行一些修改——为学术 API 创建的——以支持这一点。
- en: 'First, we are going to modify the `WebRequest.cs` file. We need to make sure
    that we can change the endpoint, so add the following function to the class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将修改 `WebRequest.cs` 文件。我们需要确保我们可以更改端点，因此向类中添加以下函数：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to add a new `TextBox` element to the `MainView.xaml` file. This
    will allow us to enter a URL. This needs a corresponding string property in the
    `MainViewModel.cs` file. When changing this property, we need to call `SetEndpoint`
    on the `_webRequest` object. This can look as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向 `MainView.xaml` 文件中添加一个新的 `TextBox` 元素。这将允许我们输入一个 URL。这需要在 `MainViewModel.cs`
    文件中有一个相应的字符串属性。当更改此属性时，我们需要在 `_webRequest` 对象上调用 `SetEndpoint`。这可以看起来如下所示：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we need to update the constructor of our `ViewModel`. Change the first
    line to the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的 `ViewModel` 构造函数。将第一行更改为以下内容：
- en: '[PRE21]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will let the default endpoint be the original API address, but allows us
    to use the application to test the KES locally.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使默认端点成为原始 API 地址，但允许我们使用应用程序在本地测试 KES。
- en: 'By testing the application with the local endpoint, the following result can
    be produced:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用本地端点测试应用程序，可以产生以下结果：
- en: '![Local hosting and testing](img/B12373_08_05.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![本地托管和测试](img/B12373_08_05.jpg)'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `evaluate` and `calchistogram` will need to update the attributes
    in the request of the test application for it to work with the local KES.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`evaluate` 和 `calchistogram` 将需要更新测试应用程序的请求中的属性，以便与本地 KES 一起工作。
- en: Going for scale
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻求规模效应
- en: While it is nice to be able to create local prototypes, the limitations ensure
    that we need to deploy the service elsewhere for production. In this case, this
    means deploying the KES to Microsoft Azure.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够创建本地原型很令人高兴，但限制确保我们需要在其他地方部署服务以进行生产。在这种情况下，这意味着将 KES 部署到 Microsoft Azure。
- en: We will now look at the steps required to deploy the KES to Microsoft Azure.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看将 KES 部署到 Microsoft Azure 所需的步骤。
- en: Hooking into Microsoft Azure
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到 Microsoft Azure
- en: The first step is to download the **Azure publish settings** file. This needs
    to be saved as `AzurePublishSettings.xml` and stored in the directory in which
    `kes.exe` runs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是下载 **Azure 发布设置** 文件。这个文件需要保存为 `AzurePublishSettings.xml` 并存储在 `kes.exe`
    运行的目录中。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the Azure publish settings file at [https://manage.windowsazure.com/publishsettings/](https://manage.windowsazure.com/publishsettings/).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://manage.windowsazure.com/publishsettings/](https://manage.windowsazure.com/publishsettings/)
    找到 Azure 发布设置文件。
- en: There are two ways to build and host the KES without restrictions. The first
    way is to boot up a **Windows virtual machine** in Azure. On this VM, you should
    follow the same steps that we took locally. This allows for rapid prototyping,
    but without any restrictions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以在没有限制的情况下构建和托管 KES。第一种方式是在 Azure 中启动一个 **Windows 虚拟机**。在这个虚拟机上，你应该遵循我们在本地采取的相同步骤。这允许快速原型设计，但没有任何限制。
- en: 'The second way is to run `kes.exe` locally, but adding `--remote` as a parameter.
    This will create a temporary Azure VM, build the index, and upload the index to
    a specified target blob storage. An example command could look as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是在本地运行 `kes.exe`，但添加 `--remote` 作为参数。这将创建一个临时的 Azure VM，构建索引，并将索引上传到指定的目标
    blob 存储。一个示例命令可能如下所示：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This process can take up to 10 minutes, so ideally, prototyping should be done
    locally, or through an Azure VM.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能需要长达 10 分钟，因此理想情况下，原型设计应在本地进行，或通过 Azure VM 进行。
- en: Deploying the service
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署服务
- en: With the grammar and index in place and prototyping done, we can deploy the
    service to a Microsoft Azure cloud service.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法和索引就位以及原型设计完成后，我们可以将服务部署到 Microsoft Azure 云服务。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn how to create a Microsoft Azure cloud service, head over to [https://azure.microsoft.com/en-us/documentation/articles/cloud-services-how-to-create-deploy/](https://azure.microsoft.com/en-us/documentation/articles/cloud-services-how-to-create-deploy/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何创建 Microsoft Azure 云服务，请访问 [https://azure.microsoft.com/en-us/documentation/articles/cloud-services-how-to-create-deploy/](https://azure.microsoft.com/en-us/documentation/articles/cloud-services-how-to-create-deploy/)。
- en: 'To deploy the service to a staging slot, run the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要将服务部署到预发布槽位，请运行以下命令：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will allow us to perform basic tests before deploying the service to a
    production slot. When the testing is done, we can deploy it to production by running
    the same command again, specifying `Production` as the last parameter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在将服务部署到生产槽之前执行基本测试。测试完成后，我们可以通过再次运行相同的命令并将“生产”作为最后一个参数来将其部署到生产环境。
- en: When the service is deployed, we can test it by visiting `http://<serviceName>.cloudapp.net`
    in a browser.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务部署后，我们可以在浏览器中访问 `http://<serviceName>.cloudapp.net` 来测试它。
- en: Answering FAQs using QnA Maker
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 QnA Maker 回答 FAQs
- en: QnA Maker allows us to use existing **frequently asked questions** (**FAQs**)
    to create a bot that answers these questions. We can generate a knowledge base
    from existing FAQs, and train a model from it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: QnA Maker 允许我们使用现有的**常见问题**（**FAQs**）来创建一个回答这些问题的机器人。我们可以从现有的 FAQs 中生成一个知识库，并从中训练一个模型。
- en: 'To get started, head over to [https://qnamaker.ai](https://qnamaker.ai). Log
    on or register by clicking Sign in, in the upper-right corner. This will present
    you with the following screen:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请转到 [https://qnamaker.ai](https://qnamaker.ai)。在右上角点击“登录”或注册。
- en: '![Answering FAQs using QnA Maker](img/B12373_08_06.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QnA Maker 回答 FAQs](img/B12373_08_06.jpg)'
- en: Creating a knowledge base from frequently asked questions
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从常见问题创建知识库
- en: 'If no services have been created, we can create one by clicking on the Create
    a knowledge base tab. This will present us with the following screen, as shown
    in the following two screenshots:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未创建任何服务，我们可以通过点击“创建知识库”标签来创建一个。这将显示以下屏幕，如下两个截图所示：
- en: '![Creating a knowledge base from frequently asked questions](img/B12373_08_07.jpg)![Creating
    a knowledge base from frequently asked questions](img/B12373_08_08.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![从常见问题创建知识库](img/B12373_08_07.jpg)![从常见问题创建知识库](img/B12373_08_08.jpg)'
- en: Create a QnA service in Microsoft Azure by clicking the blue button in **S****TEP
    1** in the screenshot.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击截图中的**步骤 1**中的蓝色按钮在 Microsoft Azure 中创建一个 QnA 服务。
- en: Connect the QnA service to the knowledge base.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 QnA 服务连接到知识库。
- en: Enter a name for the service.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务输入一个名称。
- en: Enter the baseline FAQs to use. This can either be in the form of one or more
    URLs, or a file containing question-and-answer pairs. For our example, we will
    be generating a knowledge base from the URL.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入要使用的基线 FAQs。这可以是单个或多个 URL 的形式，或者是一个包含问答对的文件。在我们的例子中，我们将从 URL 生成知识库。
- en: Let the rest of the settings be default.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让其余的设置保持默认。
- en: Click **Create your KB**.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建您的 KB**。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you do not have any FAQs to use, you can use [https://www.microsoft.com/en-us/software-download/faq](https://www.microsoft.com/en-us/software-download/faq)
    from Microsoft.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有可用的 FAQs，可以使用 [https://www.microsoft.com/en-us/software-download/faq](https://www.microsoft.com/en-us/software-download/faq)
    从 Microsoft 获取。
- en: 'Once the knowledge base has been created, you will be taken to a page with
    all the question-and-answer pairs. This is shown in the following screenshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了知识库，您将被带到包含所有问答对的页面。如下截图所示：
- en: '![Creating a knowledge base from frequently asked questions](img/B12373_08_09.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![从常见问题创建知识库](img/B12373_08_09.jpg)'
- en: On this page, we can look through all question-and-answer pairs, from all our
    FAQ sources. We can also add new pairs by clicking **Add QnA** pair.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个页面上，我们可以查看所有来自我们 FAQ 源的问答对。我们也可以通过点击**添加 QnA 对**来添加新的问答对。
- en: Training the model
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练模型
- en: Every time we make changes to the knowledge base, it is wise to click **Save**
    and **Train**. This will ensure that our model is up to date, with the most current
    question-and-answer pairs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们对知识库进行更改时，点击**保存**和**训练**都是明智的选择。这将确保我们的模型是最新的，包含最新的问答对。
- en: 'Once we have trained the model, we can test it. This can be done by clicking
    the **Test** button on the right-hand side. This will present us with the following
    chat window:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们训练了模型，我们就可以对其进行测试。这可以通过点击右侧的**测试**按钮来完成。这将显示以下聊天窗口：
- en: '![Training the model](img/B12373_08_10.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![训练模型](img/B12373_08_10.jpg)'
- en: From this chat dialog, we can test some or all of our questions to verify that
    we get the correct answers. We can also improve the model by asking questions
    in different ways. In some cases, this will present us with the wrong answer.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个聊天对话框中，我们可以测试一些或所有的问题来验证我们是否得到了正确的答案。我们也可以通过以不同的方式提问来改进模型。在某些情况下，这可能会给我们提供错误的答案。
- en: If we have been presented with the wrong answer, we can change this by selecting
    the correct one. With any given question, the possible answers will be listed
    by clicking the Inspect button beneath the question, ordered by probability. Selecting
    the correct answer and retraining the model will ensure a correct answer when
    asking the same question later.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到了错误的答案，我们可以通过选择正确的答案来更改它。对于任何给定的问题，可能的答案将通过点击问题下方的“检查”按钮列出，按概率排序。选择正确答案并重新训练模型将确保在稍后再次提出相同问题时得到正确答案。
- en: Publishing the model
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布模型
- en: 'Once we are done with training, it is time to publish the service. We can do
    so by clicking Publish in the top menu. Doing so will present us with a basic
    HTTP request that we can try, as shown in the following screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦训练完成，就是时候发布服务了。我们可以在顶部菜单点击“发布”来完成这一操作。这样做会显示一个基本的HTTP请求，我们可以尝试，如下面的截图所示：
- en: '![Publishing the model](img/B12373_08_11.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![发布模型](img/B12373_08_11.jpg)'
- en: In the preceding screenshot, we can see the endpoint to use, the required application
    ID, the subscription key, and a sample question in the request body. All those
    parameters are required to get a successful response.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到要使用的端点、所需的应用程序ID、订阅密钥以及请求体中的示例问题。所有这些参数都是获取成功响应所必需的。
- en: 'A successful call to the service will provide us with a JSON response as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用服务将提供以下JSON响应：
- en: '[PRE24]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we have an application that uses this, we can decide not to use the answer
    if the score has fallen below a certain threshold.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个使用此服务的应用程序，我们可以决定当分数低于某个阈值时不再使用答案。
- en: Typically, we would be using bots of different kinds to use this service. We
    can, for example, add this to a Skype bot or Slackbot, or simply integrate it
    with a chatbot on a customer support site.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会使用不同种类的机器人来使用此服务。例如，我们可以将其添加到Skype机器人或Slackbot中，或者简单地将其集成到客户支持网站的聊天机器人中。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have learned about the Project Academic Knowledge
    API and Project Knowledge Exploration Service. We looked at how to interpret natural
    language queries to get query expressions for evaluation. Through this evaluation,
    we have retrieved academic papers from the Microsoft Academic Graph knowledge
    base. From there, we learned how to set up the Knowledge Exploration Service itself,
    going from defining the schemas all the way to deploying it to a Microsoft Azure
    cloud service. In the end, we learned how to set up a simple QnA Maker service.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于项目学术知识API和项目知识探索服务的内容。我们了解了如何解释自然语言查询以获取用于评估的查询表达式。通过这次评估，我们从微软学术图知识库中检索了学术论文。从那里，我们学习了如何设置知识探索服务本身，从定义模式一直到将其部署到微软Azure云服务。最后，我们学习了如何设置一个简单的问答制作服务。
- en: In the next chapter, we will move on to looking at search APIs, learning how
    to utilize the different search APIs offered by Bing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨搜索API，学习如何利用必应提供的不同搜索API。
