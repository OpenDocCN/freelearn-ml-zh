- en: Using ML.NET with UWP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 UWP 中使用 ML.NET
- en: Now that we have established how to create a production-grade .NET Core console
    application, in this chapter, we will deep dive into creating a fully functional
    Windows 10 application with the **Universal Windows Platform** (**UWP**) framework.
    This application will utilize an ML.NET binary classification model to make web-page-content
    classifications, in order to determine if the content is benign or malicious.
    In addition, we will explore breaking your code into a component-based architecture,
    using a .NET Standard Library to share between our desktop application and the
    console application that will train our model. By the end of the chapter, you
    should have a firm grasp of designing and coding a production-grade UWP desktop
    application with ML.NET.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了如何创建生产级的 .NET Core 控制台应用程序，在本章中，我们将深入探讨使用 **通用 Windows 平台**（**UWP**）框架创建一个功能齐全的
    Windows 10 应用程序。此应用程序将利用 ML.NET 二元分类模型来对网页内容进行分类，以确定内容是良性的还是恶性的。此外，我们将探讨将代码分解为基于组件的架构，使用
    .NET Standard 库在桌面应用程序和将训练我们的模型的控制台应用程序之间共享。到本章结束时，您应该能够熟练地设计和编码带有 ML.NET 的生产级
    UWP 桌面应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Breaking down the UWP application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 UWP 应用程序
- en: Creating the web browser classification application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建网络浏览器分类应用程序
- en: Exploring additional production-application enhancements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索额外的生产级应用程序增强功能
- en: Breaking down the UWP architecture
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 UWP 架构
- en: At a high level, UWP provides an easy framework to create rich desktop applications
    for Windows 10\. As discussed, with .NET Core, UWP allows the targeting of x86,
    x64, and **Advanced RISC Machine** (**ARM**). At the time of this writing, ARM
    is not supported with ML.NET. In addition, UWP applications can also be written
    with JavaScript and HTML.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，UWP 提供了一个易于使用的框架来创建 Windows 10 的丰富桌面应用程序。正如所讨论的，使用 .NET Core，UWP 允许针对
    x86、x64 和 **高级精简指令集机器**（**ARM**）。在撰写本文时，ARM 不支持 ML.NET。此外，UWP 应用程序也可以使用 JavaScript
    和 HTML 编写。
- en: 'A typical UWP desktop application includes the following core code elements:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 UWP 桌面应用程序包括以下核心代码元素：
- en: Views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Models
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: View Models
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图模型
- en: These components form a common app architecture principle of the **Model**-**View**-**ViewModel**,
    otherwise known as **MVVM**. In addition to the code components, images and audio
    are also common, depending on the nature of your application or game.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件构成了 **模型**-**视图**-**视图模型**（**MVVM**）这一通用应用程序架构原则。除了代码组件外，图像和音频也是常见的，这取决于您应用程序或游戏的本质。
- en: Similarly to mobile apps on the Android and iOS platforms, each app is sandboxed
    to specific permissions that you, the developer, request upon installation. Therefore,
    as you develop your own UWP applications, request only the required access that
    your app absolutely requires.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Android 和 iOS 平台上的移动应用程序类似，每个应用程序在安装时都会被沙盒化，以特定的权限运行，这些权限由您，即开发者，在安装时请求。因此，在您开发自己的
    UWP 应用程序时，只请求您的应用程序绝对需要的访问权限。
- en: 'For the example application we will be creating in this chapter, we only require
    access to the internet as a client, as found in the Capabilities tab labeled Internet
    (Client), as shown in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章我们将创建的示例应用程序，我们只需要作为客户端访问互联网，正如在标记为“互联网（客户端）”的“功能”选项卡中所示，以下截图所示：
- en: '![](img/44a90379-b974-4863-bdcd-8b030ad9a880.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44a90379-b974-4863-bdcd-8b030ad9a880.png)'
- en: The Internet (Client) and other permissions are defined in the `Package.appxmanifest`file
    found in the root of UWP applications, under the Capabilities tab. This file is
    shown in the Visual Studio Solution Explorer screenshot in the later *Exploring
    the project architecture* section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网（客户端）和其他权限定义在位于 UWP 应用程序根目录下的 `Package.appxmanifest` 文件中，在“功能”选项卡下。此文件在后续的“探索项目架构”部分中的
    Visual Studio 解决方案资源管理器截图中有展示。
- en: To prepare for our deep dive into integrating ML.NET in a UWP application, let's
    dive into the three core components found in a UWP application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们深入探讨在 UWP 应用程序中集成 ML.NET，让我们深入了解 UWP 应用程序中发现的三个核心组件。
- en: Views
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Views, as we defined in the previous chapter's Blazor discussion, contain the
    **user interface** (**UI**) components of an application. Views in UWP development,
    such as those found in **Windows Presentation Foundation** (**WPF**) and Xamarin.Forms,
    use the **Extensible Application Markup Language** (**XAML**) syntax. Those familiar
    with modern web development with Bootstrap's Grid pattern will be able to quickly
    see the parallels as we deep dive into this later in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 视图，正如我们在上一章的Blazor讨论中所定义的，包含了应用程序的用户界面（UI）组件。在UWP开发中，如Windows Presentation Foundation（WPF）和Xamarin.Forms中的视图，使用可扩展应用程序标记语言（XAML）语法。那些熟悉使用Bootstrap的Grid模式进行现代Web开发的人，在我们深入本章内容时，将能够迅速看到其中的相似之处。
- en: The biggest differentiation between web development and UWP development is the
    powerful two-way binding XAML views when used with the MVVM principle. As you
    will see in the deep dive, XAML binding eliminates the manual setting and getting
    of values in code behinds, as you might have performed in Windows Forms or WebForms
    projects previously.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Web开发和UWP开发之间最大的区别在于，当与MVVM原则一起使用时，XAML视图具有强大的双向绑定功能。正如你将在深入探讨中看到的那样，XAML绑定消除了在代码后手动设置和获取值的需求，就像你可能在之前的Windows
    Forms或WebForms项目中执行的那样。
- en: For applications using the web approach, HTML would define your View as with
    our Blazor project in [Chapter 9](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml), *Using
    ML.NET with ASP.NET Core*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于采用Web方法的程序，HTML将定义你的视图，就像我们在第9章[使用ML.NET与ASP.NET Core](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml)中提到的Blazor项目一样。
- en: Models
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: Models provide the container of data between the View and View Model. Think
    of the Model as purely the transport for containing the data between the View
    and View Model. For example, if you had a movie list, a `List` collection of `MovieItems`
    would be defined in your `MovieListingModel` class. This container class would
    be instantiated and populated in the View Model, to be in turn bound in your View.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模型提供了视图和视图模型之间的数据容器。将模型视为纯粹是视图和视图模型之间包含数据的传输工具。例如，如果你有一个电影列表，你的`MovieListingModel`类中将定义一个`List`集合的`MovieItems`。这个容器类将在视图模型中实例化和填充，然后绑定到你的视图中。
- en: View Models
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型
- en: View Models provide the business-logic layer for populating your Model, and
    thereby your View indirectly. As mentioned previously, the MVVM binding provided
    in UWP development eases the management of trigger points to ensure your UI layer
    is up to date. This is achieved through the use of implementing the `INotifyPropertyChanged`
    interface in our View Model. For each property that we want to bind to our UI,
    we simply call `OnPropertyChanged`. The power behind this is that you can have
    complex forms with triggers within the setter of other properties, without having
    conditionals and endless code to handle the complexities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型提供了填充你的模型以及间接地你的视图的业务逻辑层。正如之前提到的，UWP开发中提供的MVVM绑定简化了触发点的管理，以确保你的UI层是最新的。这是通过在我们的视图模型中实现`INotifyPropertyChanged`接口来实现的。对于我们要绑定到UI的每个属性，我们只需调用`OnPropertyChanged`。其背后的力量在于，你可以在其他属性的设置器中拥有复杂的表单和触发器，而不需要条件语句和无尽的代码来处理复杂性。
- en: If you want to deep dive further into UWP development, Channel9 from Microsoft
    has a series called *Windows 10 Development for Absolute Beginners* that covers
    all of the main aspects of UWP development: [https://channel9.msdn.com/Series/Windows-10-development-for-absolute-beginners](https://channel9.msdn.com/Series/Windows-10-development-for-absolute-beginners).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要进一步深入UWP开发，微软的Channel9有一个名为*Windows 10 Development for Absolute Beginners*的系列，涵盖了UWP开发的各个方面：[https://channel9.msdn.com/Series/Windows-10-development-for-absolute-beginners](https://channel9.msdn.com/Series/Windows-10-development-for-absolute-beginners)。
- en: Creating the web browser classification application
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网络浏览器分类应用程序
- en: As mentioned earlier, the application we will be creating is a web browser classification
    application. Using the knowledge garnered in the logistic classification chapter,
    we will be using the `SdcaLogisticRegression` algorithm to take the text content
    of a web page, featurize the text, and provide a confidence level of maliciousness.
    In addition, we will be integrating this technique into a Windows 10 UWP application
    that mimics a web browser—effectively on navigation to a page—running the model,
    and making a determination as to whether the page was malicious. If found to be
    malicious, we redirect to a warning page. While in a real-world scenario this
    might prove too slow to run on every page, the benefits of a highly secured web
    browser, depending on the environment requirements might far outweigh the slight
    overhead running our model incurs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将创建的应用程序是一个网页浏览器分类应用程序。利用逻辑分类章节中获得的知识，我们将使用 `SdcaLogisticRegression`
    算法来获取网页的文本内容，对文本进行特征化，并提供恶意程度的置信度。此外，我们将把这个技术集成到一个模拟网页浏览器的 Windows 10 UWP 应用程序中——在导航到页面时运行模型，并判断页面是否恶意。如果发现页面是恶意的，我们将重定向到警告页面。虽然在现实场景中，这可能证明在每个页面上运行太慢，但高度安全的网页浏览器的优势，根据环境要求，可能远远超过运行我们的模型所造成的轻微开销。
- en: As with previous chapters, the completed project code, sample dataset, and project
    files can be downloaded from [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，完成的项目代码、样本数据集和项目文件可以从[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter10)下载。
- en: Exploring the project architecture
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目架构
- en: With this chapter, we will dive into a native Windows 10 desktop application.
    As mentioned in the first section of this chapter, we will be using the UWP framework
    to create our application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨一个本地的 Windows 10 桌面应用程序。如本章第一部分所述，我们将使用 UWP 框架来创建我们的应用程序。
- en: No additional ML.NET NuGet packages are needed for this sample application.
    However, we will be using the `HtmlAgilityPack` NuGet package to provide a quick
    method to extract the text from a given web page. At the time of this writing,
    version 1.11.18 was the latest version and is the version used in this example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例应用程序，不需要额外的 ML.NET NuGet 包。然而，我们将使用 `HtmlAgilityPack` NuGet 包提供一个快速的方法来从给定的网页中提取文本。在撰写本文时，版本
    1.11.18 是最新版本，也是本例中使用的版本。
- en: 'In the following screenshot, you will find the Visual Studio Solution Explorer
    view of the solution. Given that this example comprises three separate projects
    (more akin to a production scenario), the amount of both new and significantly
    modified files is quite large. We will review in detail each of the new files
    shown in the solution screenshot, later on in this section:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您将找到解决方案的 Visual Studio 解决方案资源管理器视图。鉴于这个示例包含三个独立的项目（更类似于生产场景），新增和显著修改的文件数量相当大。我们将在本节稍后详细审查解决方案屏幕截图中显示的每个新文件：
- en: '![](img/a9b4c475-b490-47d3-a201-c424ef6a8d04.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9b4c475-b490-47d3-a201-c424ef6a8d04.png)'
- en: 'The `sampledata.csv` file (found in the `Data` folder in the code repository)
    contains eight rows of extracted text from URLs found in the `trainingURLList.csv`
    file (also found in the `Data` folder). Feel free to adjust the URL list file
    to test websites you frequently visit. Here is a snippet of one such row:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledata.csv` 文件（位于代码存储库中的 `Data` 文件夹中）包含从 `trainingURLList.csv` 文件（也位于
    `Data` 文件夹中）中找到的 URL 提取的八行文本。您可以随意调整 URL 列表文件以测试您经常访问的网站。以下是此类行的一个样本：'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition to the `sampledata.csv` file, we also added the `testdata.csv` file
    that contains additional data points to test the newly trained model against and
    to evaluate. Here is a snippet of a sample row of the data inside of `testdata.csv`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `sampledata.csv` 文件外，我们还添加了 `testdata.csv` 文件，其中包含额外的数据点，用于测试新训练的模型并评估。以下是
    `testdata.csv` 文件中数据的一个样本行：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Due to the size of the example project, we will be diving into the code for
    each of the different components before running the applications at the end of
    this section in the following order:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于示例项目的规模，我们将在本节末尾运行应用程序之前，按照以下顺序深入到每个不同组件的代码中：
- en: .NET Standard Library for common code between the two applications
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 标准库，用于两个应用程序之间的通用代码
- en: Windows 10 UWP browser application
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10 UWP 浏览器应用程序
- en: .NET Core console application for feature extraction and training
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core console application for feature extraction and training
- en: Diving into the library
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Diving into the library
- en: Due to the nature of this application and that of production applications where
    there are multiple platforms and/or ways to execute shared code, a library is
    being used in this chapter's example application. The benefit of using a library
    is that all common code can reside in a portable and dependency-free manner. Expanding
    the functionality in this sample application to include other platforms such as
    Linux or Mac applications with Xamarin would be a much easier lift than having
    the code either duplicated or kept in the actual applications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Due to the nature of this application and that of production applications where
    there are multiple platforms and/or ways to execute shared code, a library is
    being used in this chapter's example application. The benefit of using a library
    is that all common code can reside in a portable and dependency-free manner. Expanding
    the functionality in this sample application to include other platforms such as
    Linux or Mac applications with Xamarin would be a much easier lift than having
    the code either duplicated or kept in the actual applications.
- en: 'Classes and enumerations that were changed or added in the library are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'Classes and enumerations that were changed or added in the library are as follows:'
- en: '`Constants`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Constants`'
- en: '`WebPageResponseItem`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebPageResponseItem`'
- en: '`Converters`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Converters`'
- en: '`ExtensionMethods`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExtensionMethods`'
- en: '`WebPageInputItem`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebPageInputItem`'
- en: '`WebPagePredictionItem`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebPagePredictionItem`'
- en: '`WebContentFeatureExtractor`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebContentFeatureExtractor`'
- en: '`WebContentPredictor`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebContentPredictor`'
- en: '`WebContentTrainer`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebContentTrainer`'
- en: The `Classification`, `TrainerActions`,and `BaseML `classes remain unmodified
    from [Chapter 9](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml), *Using ML.NET with
    ASP.NET Core*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: The `Classification`, `TrainerActions`,and `BaseML `classes remain unmodified
    from [Chapter 9](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml), *Using ML.NET with
    ASP.NET Core*.
- en: The Constants class
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The Constants class
- en: 'The `Constants` class, as used in all of our examples to this point, is the
    common class that contains our constant values used in our library, trainer, and
    UWP applications. For this chapter, the `MODEL_NAME` and `MALICIOUS_THRESHOLD`
    properties were added to hold our model''s name and an arbitrary threshold for
    when we should decide to classify our prediction as malicious or not, respectively.
    If you find your model too sensitive, try adjusting this threshold, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `Constants` class, as used in all of our examples to this point, is the
    common class that contains our constant values used in our library, trainer, and
    UWP applications. For this chapter, the `MODEL_NAME` and `MALICIOUS_THRESHOLD`
    properties were added to hold our model''s name and an arbitrary threshold for
    when we should decide to classify our prediction as malicious or not, respectively.
    If you find your model too sensitive, try adjusting this threshold, like this:'
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The WebPageResponseItem class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The WebPageResponseItem class
- en: 'The `WebPageResponseItem` class is our container class between our predictor
    and application. This class contains the properties we set after running the predictor
    and then use to display in our desktop application, as shown in the following
    code block:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `WebPageResponseItem` class is our container class between our predictor
    and application. This class contains the properties we set after running the predictor
    and then use to display in our desktop application, as shown in the following
    code block:'
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Converters class
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The Converters class
- en: 'The `Converters` class has been adjusted to provide an extension method to
    convert our container class into the type our model expects. In this example,
    we have the `Content` property, which simply maps to the `HTMLContent` variable
    in the `WebPageInputItem` class, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `Converters` class has been adjusted to provide an extension method to
    convert our container class into the type our model expects. In this example,
    we have the `Content` property, which simply maps to the `HTMLContent` variable
    in the `WebPageInputItem` class, as follows:'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The ExtensionMethods class
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The ExtensionMethods class
- en: 'The `ExtensionMethods` class, as discussed previously in [Chapter 9](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml),
    *Using ML.NET with ASP.NET Core*, has been expanded to include the `ToWebContentString`
    extension method. In this method, we pass in the URL from which we want to retrieve
    the web content. Using the previously mentioned `HtmlAgilityPack`, we create an `HtmlWeb`
    object and call the `Load`method, prior to iterating through the **Document Object
    Model** (**DOM**). Given most websites have extensive scripts and style sheets,
    our purpose in this example is just to examine the text in the page, thus the
    filters of script and style nodes in our code. Once the nodes have been traversed
    and added to a `StringBuilder` object, we return the typecast of that object to
    a string, as shown in the following code block:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在[第9章](5f67e3b8-56bd-47ab-8a72-4f00b239d517.xhtml)中讨论的`ExtensionMethods`类，已被扩展以包括`ToWebContentString`扩展方法。在这个方法中，我们传入我们想要检索网页内容的URL。使用之前提到的`HtmlAgilityPack`，我们创建一个`HtmlWeb`对象并调用`Load`方法，在遍历**文档对象模型**（**DOM**）之前。鉴于大多数网站都有大量的脚本和样式表，在这个例子中，我们的目的是检查页面中的文本，因此我们在代码中过滤了脚本和样式节点。一旦节点被遍历并添加到`StringBuilder`对象中，我们就返回该对象的类型转换字符串，如下面的代码块所示：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The WebPageInputItem class
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WebPageInputItem`类'
- en: 'The `WebPageInputItem` class is our input object to our model, containing both
    the label and extracted content of our web page, as shown in the following code
    block:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebPageInputItem`类是我们模型的输入对象，包含我们网页的标签和提取内容，如下面的代码块所示：'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The WebPagePredictionItem class
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WebPagePredictionItem`类'
- en: 'The `WebPagePredictionItem` class is the output object from our model, containing
    the prediction of whether a web page is malicious or benign, in addition to a
    probability score that the prediction is accurate and the `Score` value used in
    the evaluation phase of our model creation, as shown in the following code block:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebPagePredictionItem`类是我们模型的输出对象，包含对网页是否恶意或良性的预测，以及预测准确的概率分数和我们在模型创建评估阶段使用的`Score`值，如下面的代码块所示：'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The WebContentFeatureExtractor class
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WebContentFeatureExtractor`类'
- en: 'The `WebContentFeatureExtractor` class contains our `GetContentFile` and `Extract`
    methods, which operate as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebContentFeatureExtractor`类包含我们的`GetContentFile`和`Extract`方法，它们的工作方式如下：'
- en: 'First, our `GetContentFile` method takes the `inputFile` and `outputFile` values
    (the URL list CSV and feature-extracted CSV respectively). It then reads each
    URL, grabs the content, then outputs to the `outputFile` string, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们的`GetContentFile`方法接受`inputFile`和`outputFile`值（分别是URL列表CSV和特征提取CSV）。然后，它读取每个URL，获取内容，然后输出到`outputFile`字符串，如下所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we use the `Extract` method to call both the training and test extraction,
    passing in the output filenames for both, like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Extract`方法调用训练和测试提取，传递两个输出文件的名称，如下所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The WebContentPredictor class
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WebContentPredictor`类'
- en: 'The `WebContentPredictor` class provides the interface for both our command
    line and desktop applications, using an overloaded `Predict` method, described
    here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebContentPredictor`类为我们提供命令行和桌面应用程序的接口，使用重载的`Predict`方法，如下所述：'
- en: 'The first `Predict` method is for our command-line application that simply
    takes in the URL and calls into the overload in *Step 3*, after calling the `ToWebContentString`
    extension method, like this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个`Predict`方法是为我们的命令行应用程序设计的，它简单地接受URL并调用在*步骤3*中的重载，在调用`ToWebContentString`扩展方法之后，如下所示：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we create the `Initialize` method, in which we load our model from the
    embedded resource. If successful, the method returns `true`; otherwise, it returns
    `false`, as shown in the following code block:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建`Initialize`方法，在其中我们从嵌入式资源中加载我们的模型。如果成功，该方法返回`true`；否则，它返回`false`，如下面的代码块所示：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And finally, we call our `Predict` method that creates our prediction engine.
    Then, we call the predictor''s `Predict` method, and then update the `Confidence`
    and `IsMalicious` properties, prior to returning the updated `WebPageResponseItem`
    object, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用我们的`Predict`方法来创建预测引擎。然后，我们调用预测器的`Predict`方法，然后更新`Confidence`和`IsMalicious`属性，在返回更新后的`WebPageResponseItem`对象之前，如下所示：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The WebContentTrainer class
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`WebContentTrainer`类'
- en: 'The `WebContentTrainer`class contains all of the code to train and evaluate
    our model. As with previous examples, this functionality is self-contained within
    one method called `Train`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebContentTrainer`类包含所有用于训练和评估我们模型的代码。与之前的示例一样，这个功能包含在一个名为`Train`的方法中：'
- en: 'The first change is the use of the `WebPageInputItem` class to read the CSV
    into the `dataView` object separated by `|`, as shown in the following code block:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个更改是使用`WebPageInputItem`类将CSV读取到以`|`分隔的`dataView`对象中，如下面的代码块所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we map our file data features to create our pipeline. In this example,
    we simply featurize the `HTMLContent` property and pass it to the `SdcaLogisticRegression`
    trainer, like this:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将文件数据特征映射到创建我们的管道。在本例中，我们简单地特征化`HTMLContent`属性，并将其传递给`SdcaLogisticRegression`训练器，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we fit the model, and save the model to disk, like this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调整模型，并将模型保存到磁盘，如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we load in the testing file, and call the `BinaryClassification` evaluation,
    like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们加载测试文件，并调用`BinaryClassification`评估，如下所示：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Diving into the UWP browser application
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入UWP浏览器应用程序
- en: With the library code having been reviewed, the next component is the desktop
    application. As discussed in the opening section, our desktop application is a
    UWP application. For the scope of this example, we are using standard approaches
    for handling the application architecture, following the MVVM approach discussed
    in the opening section of this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了库代码之后，下一个组件是桌面应用程序。正如开篇部分所讨论的，我们的桌面应用程序是一个UWP应用程序。在本例的范围内，我们使用标准的处理应用程序架构的方法，遵循本章开篇部分讨论的MVVM方法。
- en: 'The files we will be diving into in this section are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中深入探讨的文件如下：
- en: '`MainPageViewModel`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainPageViewModel`'
- en: '`MainPage.xaml`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainPage.xaml`'
- en: '`MainPage.xaml.cs`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainPage.xaml.cs`'
- en: The rest of the files inside the UWP project, such as the tile images and app
    class files, are untouched from the default Visual Studio UWP application template.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: UWP项目内部的其他文件，例如磁贴图像和应用程序类文件，都未从默认的Visual Studio UWP应用程序模板中进行修改。
- en: The MainPageViewModel class
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MainPageViewModel`类'
- en: 'The purpose of the `MainPageViewModel` class is to contain our business logic
    and control the View:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPageViewModel`类的目的是包含我们的业务逻辑并控制视图：'
- en: 'The first thing we do is instantiate our previously discussed `WebContentPredictor`
    class to be used to run predictions, as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先实例化之前讨论的`WebContentPredictor`类，用于运行预测，如下所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next block of code handles the power of MVVM for our **GO** button, the
    web service URL field, and the web classification properties. For each of these
    properties, we call `OnPropertyChanged` upon a change in values, which triggers
    the binding of the View to refresh for any field bound to these properties, as
    shown in the following code block:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块处理了MVVM为我们**GO**按钮、web服务URL字段和web分类属性提供的功能。对于这些属性中的每一个，我们在值发生变化时调用`OnPropertyChanged`，这会触发视图与任何绑定到这些属性的域的绑定刷新，如下面的代码块所示：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we define the `Initialize` method, which calls the predictor''s `Initialize`
    method. The method will return false if the model can''t be loaded or found, as
    follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`Initialize`方法，它调用预测器的`Initialize`方法。如果模型无法加载或找到，该方法将返回false，如下所示：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we take the entered URL the user entered via the `WebServiceURL` property.
    From that value, we validate that either `http` or `https` is prefixed. If not,
    `http://` is prefixed to the URL prior to converting it to a URI, like this:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取用户通过`WebServiceURL`属性输入的URL。从这个值中，我们验证是否以`http`或`https`开头。如果没有，则在将其转换为URI之前，在URL前添加`http://`，如下所示：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, onto our `Classify` method that takes the URL entered from the user. This
    method calls our `Predict` method, builds our status bar text, and, if found to
    be malicious, builds the HTML response to send back to our `WebView` object, as
    follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`Classify`方法，该方法接受用户输入的URL。此方法调用我们的`Predict`方法，构建状态栏文本，如果发现是恶意内容，则构建发送回`WebView`对象的HTML响应，如下所示：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And lastly, we implement the `OnPropertyChanged` event handler and method that
    are the standard implementations of the `INotifyPropertyChanged` interface, as
    discussed in the opening section of this chapter and shown in the following code
    block:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现了`OnPropertyChanged`事件处理程序和方法，这是`INotifyPropertyChanged`接口的标准实现，正如本章开篇部分所讨论的，并在以下代码块中展示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: MainPage.xaml
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MainPage.xaml`'
- en: 'As discussed in the opening section describing UWP development, XAML markup
    is used to define your UI. For the scope of this application, our UI is relatively
    simple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如开篇部分所述的UWP开发描述，XAML标记用于定义你的UI。在本应用的范围内，我们的UI相对简单：
- en: 'The first thing we define is our `Grid`. In XAML, a `Grid` is a container similar
    to a `div` element in web development. We then define our Rows. Similar to Bootstrap,
    (but easier to understand, in my opinion) is to pre-define the height of each
    row. Setting a row to `Auto` will auto-size the height to the content''s height,
    while an asterisk translates to using all remaining height based on the main container''s
    height, as shown in the following code block:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义的是我们的 `Grid`。在 XAML 中，`Grid` 是一个类似于网络开发中 `div` 元素的容器。然后我们定义我们的行。与 Bootstrap
    类似（但在我看来更容易理解），是预先定义每行的长度。将行设置为 `Auto` 将自动调整高度以适应内容的高度，而星号则表示使用基于主要容器高度的所有剩余高度，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similar to the row definitions in *Step 1*, we pre-define columns. `"Auto"`
    and `"*"` equate to the same principle as they did for the rows, just in regard
    to width instead of height, as shown in the following code block:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 *步骤 1* 中的行定义类似，我们预先定义了列。`"Auto"` 和 `"*"` 与行中的用法相同，只是关于宽度而不是高度，如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then define our `TextBox` object for the URL entry. Note the `Binding`call
    in the `Text` value. This binds the textbox''s text field to the `WebServiceURL`
    property in our View Model, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后定义我们的 `TextBox` 对象用于 URL 输入。注意 `Text` 值中的 `Binding` 调用。这将文本框的文本字段绑定到视图模型中的
    `WebServiceURL` 属性，如下所示：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we add the button to mimic a browser''s **GO** button, which triggers
    the navigation. Also, note the use of `Binding` to enable or disable the button
    itself (which is bound based on text being entered into the URL textbox), as shown
    in the following code block:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加按钮来模拟浏览器的 **GO** 按钮，该按钮触发导航。同时，注意使用 `Binding` 来启用或禁用按钮本身（它基于输入到 URL 文本框中的文本进行绑定），如下面的代码块所示：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then add the `WebView` control that comes with UWP, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后添加了 UWP 中的 `WebView` 控件，如下所示：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lastly, we add our status bar grid and `TextBlock` control to show the classification
    along the bottom of the window, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加我们的状态栏网格和 `TextBlock` 控件，以在窗口底部显示分类，如下所示：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: MainPage.xaml.cs
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MainPage.xaml.cs`'
- en: 'The `MainPage.xaml.cs` file contains the code behind the XAML view discussed
    previously:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage.xaml.cs` 文件包含之前讨论的 XAML 视图的代码：'
- en: 'The first thing we define is a wrapper property around the `DataContext` property
    built into the base `Page` class, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义的是一个包装属性，围绕基 `Page` 类中内置的 `DataContext` 属性构建，如下所示：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we define the constructor for `MainPage` to initialize the `DataContext`
    to our `MainPageViewModel` object, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `MainPage` 的构造函数，以便将 `DataContext` 初始化为我们的 `MainPageViewModel` 对象，如下所示：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then override the base `OnNavigatedTo` method to initialize our View Model,
    and validate the model was loaded properly, as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后重写基类的 `OnNavigatedTo` 方法来初始化我们的视图模型，并验证模型是否正确加载，如下所示：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we add our `ShowMessage` wrapper to provide an easy one-liner to call
    throughout our application, like this:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加我们的 `ShowMessage` 包装器，以提供一个易于在应用程序中调用的单行代码，如下所示：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we handle the **GO** button click by calling the `Navigate` method, as
    follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `Navigate` 方法来处理 **GO** 按钮的点击，如下所示：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then create our `Navigate` wrapper method, which builds the URI and passes
    it to the `WebView` object, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建我们的 `Navigate` 包装方法，该方法构建 URI 并将其传递给 `WebView` 对象，如下所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also want to handle the keyboard input to listen for the user hitting the
    *Enter* key after entering a URL, to provide the user with the ability to either
    hit *Enter* or click the **GO** button, like this:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望处理键盘输入，以便在用户输入 URL 后监听用户按下 *Enter* 键，使用户能够按下 *Enter* 或点击 **GO** 按钮，如下所示：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Lastly, we block navigation until a classification can be obtained by hooking
    into the WebView''s `OnNavigationStarting` event, as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过挂钩到 WebView 的 `OnNavigationStarting` 事件来阻塞导航，直到可以获取分类，如下所示：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Diving into the trainer application
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入到训练应用程序
- en: Now that we have reviewed the shared library and the desktop application, let
    us dive into the trainer application. With the major architectural changes being
    performed in Chapter 8's example, by design the trainer application has only minimal
    changes to handle the specific class objects used in this chapter's example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了共享库和桌面应用程序，让我们深入到训练应用程序。由于在第 8 章的示例中进行了主要的架构变更，按照设计，训练应用程序只进行了最小变更来处理本章示例中使用的特定类对象。
- en: 'We will review the following files:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾以下文件：
- en: '`ProgramArguments`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgramArguments`'
- en: '`Program`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program`'
- en: The ProgramArguments class
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ProgramArguments` 类'
- en: 'Building off the work in Chapter 9''s `ProgramArguments` class, we are only
    making three additions to the class. The first two additions are to include both
    the `Training` and `Testing` output filenames to provide better flexibility with
    our example''s infrastructure. In addition, the `URL` property holds the URL you
    can pass, using the command line, into the trainer application to get a prediction,
    as shown in the following code block:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章的`ProgramArguments`类的工作基础上，我们对这个类只做了三个添加。前两个添加是将`Training`和`Testing`输出文件名包括在内，以提供更好的灵活性。此外，`URL`属性包含你可以通过命令行传递给训练应用程序以获取预测的URL，如下面的代码块所示：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Program class
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序类
- en: 'Inside the `Program` class, we will now modify the `switch case` statement
    to use the classes/methods from [Chapter 10](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml),
    *Using ML.NET with UWP*, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program`类内部，我们现在将修改`switch case`语句，以使用来自[第10章](9c105516-7e4f-4f99-b70f-8b0d6165d8c5.xhtml)，“使用ML.NET与UWP”的类/方法，如下所示：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Running the trainer application
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行训练应用程序
- en: 'To begin running the trainer application, we will need to first run the `chapter10.trainer` application
    to perform feature extraction prior to the training of our model. To run the trainer
    application, the process is nearly identical to Chapter 9''s sample application,
    with the addition of passing in the test dataset filename path when training:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始运行训练应用程序，我们首先需要运行`chapter10.trainer`应用程序，在训练我们的模型之前执行特征提取。要运行训练应用程序，过程几乎与第9章的示例应用程序相同，只是在训练时添加了传递测试数据集文件路径：
- en: 'Run the trainer application, passing in the paths to the training and test
    URL list CSVs to perform feature extraction, as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行训练应用程序，传递训练和测试URL列表CSV文件的路径以执行特征提取，如下所示：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the application to train the model, based on *Step 1*''s sample and test
    data exports, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据第1步的样本和测试数据导出，运行应用程序以训练模型，如下所示：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Feel free to modify the values and see how the prediction changes, based on
    the dataset on which the model was trained. A few areas of experimentation from
    this point might be to:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 随意修改值并查看预测如何根据模型训练的数据集而变化。从这个点开始，一些实验的领域可能包括：
- en: Tweak the hyperparameters reviewed in the `Trainer` class on the **Stochastic
    Dual Coordinate Ascent** (**SDCA**) algorithm, such as `MaximumNumberOfIterations`,
    to see how accuracy is affected.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整在**随机双坐标上升**（**SDCA**）算法的`Trainer`类上审查的超参数，例如`MaximumNumberOfIterations`，以查看精度如何受到影响。
- en: Add new features in addition to simply using the HTML content—perhaps the connection
    type or the number of scripts.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了简单地使用HTML内容外，还可以添加新的特征——例如连接类型或脚本数量。
- en: Add more variation to the training and sample set to get a better sampling of
    both benign and malicious content.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在训练和样本集中添加更多变化，以获得良性和恶意内容的更好采样。
- en: 'For convenience, the GitHub repository includes all of the following data files
    in the `Data` folder:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，GitHub仓库在`Data`文件夹中包含了以下所有数据文件：
- en: The `testdata.csv` and `sampledata.csv` feature-extracted CSV files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testdata.csv`和`sampledata.csv`特征提取的CSV文件'
- en: The `testingURLList.csv` and `trainingURLList.csv` URL list CSV files
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testingURLList.csv`和`trainingURLList.csv` URL列表CSV文件'
- en: Running the browser application
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行浏览器应用程序
- en: 'Now that our model has been trained, we can run our desktop application and
    test the efficacy of the model. To run the example, make sure the `chapter10_app`
    is the startup app and hit *F5*. Upon launching our browser application, enter
    `www.google.com`, as shown in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经训练了模型，我们可以运行我们的桌面应用程序并测试模型的功效。要运行示例，确保`chapter10_app`是启动应用程序，然后按*F5*。在启动我们的浏览器应用程序后，输入`www.google.com`，如下面的截图所示：
- en: '![](img/9ea1a926-8764-4ea7-a41e-9c20058c0a4d.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ea1a926-8764-4ea7-a41e-9c20058c0a4d.png)'
- en: 'Note the status bar below the web page content in the preceding screenshot,
    indicating the malicious percentage after running the model. Next, type `dasmalwerk.eu`
    into your browser (this is a website that the default training URL list pre-classified
    as malicious), and note the forced redirect, as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前一个截图下方网页内容下的状态栏，它显示了运行模型后的恶意百分比。接下来，在浏览器中输入`dasmalwerk.eu`（这是一个默认训练URL列表预先分类为恶意网站的网站），注意强制重定向，如下面的截图所示：
- en: '![](img/a1a7ca8d-2f87-4670-93be-a9ade98ee292.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1a7ca8d-2f87-4670-93be-a9ade98ee292.png)'
- en: Feel free to try various files on your machine to see the confidence score,
    and if you receive a false positive, perhaps add additional features to the model
    to correct the classification.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试你机器上的各种文件以查看置信度分数，如果你收到一个误报，可能需要向模型添加更多功能以纠正分类。
- en: Additional ideas for improvements
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进想法的额外建议
- en: Now that we have completed our deep dive, there are a couple of additional elements
    to possibly further enhance the application. A few ideas are discussed here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了深入探讨，还有一些额外的元素可能可以进一步增强应用程序。这里讨论了一些想法。
- en: Single-download optimization
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单次下载优化
- en: Currently, when a new URL is entered or the page is changed in the `WebView`
    UWP control, the navigation is halted until a classification can be made. When
    this occurs—as we detailed previously—with the use of the `HtmlAgilityPack` library,
    we download and extract the text. If the page is deemed to be clean (as one would
    more than likely encounter the majority of the time), we would effectively be
    downloading the content twice. An optimization here would be to store the text
    in the application's sandbox storage once classification is done, then point the
    `WebView` object to that stored content. In addition, if this approach is used,
    add a purge background worker to remove older data so that your end users don't
    end up with several gigabytes of web page content.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当在`WebView` UWP控件中输入新URL或更改页面时，导航会暂停，直到可以进行分类。当这种情况发生时——正如我们之前详细说明的——使用`HtmlAgilityPack`库，我们会下载并提取文本。如果页面被认为很干净（正如你可能会在大多数情况下遇到的那样），我们实际上会下载内容两次。这里的优化是将文本存储在应用程序的沙盒存储中，一旦完成分类，然后将`WebView`对象指向该存储内容。此外，如果采用这种方法，添加一个清除后台工作线程以删除旧数据，这样你的最终用户就不会最终拥有几个GB的网页内容。
- en: Logging
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: As with our previous chapter's deep dive into logging, adding logging could
    be crucial to remotely understand when an error occurs on a desktop application.
    Unlike our web application in the previous chapter, where your errors would be
    more than likely server-side and could be accessed remotely, your desktop application
    could be installed on any number of configurations of Windows 10, with an almost
    unlimited number of permutations. As mentioned previously, logging utilizing NLog ([https://nlog-project.org/](https://nlog-project.org/))
    or a similar open source project is highly recommended, coupled with a remote
    logging solution such as Loggly so that you can get error data from your user's
    machines. Given the **General Data Protection Regulation** (**GDPR**) and the
    recent **California Consumer Privacy Act** (**CCPA**), ensure that the fact this
    data is leaving the end user's machines is conveyed, and do not include personal
    data in these logs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章深入探讨日志记录时一样，添加日志对于远程了解桌面应用程序发生错误的时间可能是至关重要的。与上一章中的Web应用程序不同，你的错误更有可能是服务器端的，并且可以远程访问，而你的桌面应用程序可以安装在Windows
    10的任何配置上，几乎有无限多的排列组合。正如之前提到的，使用NLog ([https://nlog-project.org/](https://nlog-project.org/))
    或类似的开源项目进行日志记录，并配合远程日志解决方案如Loggly，以便你能从用户的机器上获取错误数据。鉴于**通用数据保护条例**（**GDPR**）和最近的**加州消费者隐私法案**（**CCPA**），确保传达这一数据正在离开最终用户的机器的事实，并且不要将这些日志中包含个人信息。
- en: Utilizing a database
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用数据库
- en: Users typically visit the same websites fairly frequently, therefore storing
    the classification of a particular website's URL in a local database such as LiteDB
    ([http://www.litedb.org/](http://www.litedb.org/)) would significantly improve
    the performance for the end user. One implementation method would be to store
    a SHA256 hash of the URL locally as the key, with the classification as the value.
    Longer term, you could provide a web URL reputation database, with the SHA256
    hash of the URL being sent up to a scalable cloud storage solution such as Microsoft's
    Cosmos DB. Storing the SHA256 hash of the URL avoids any questions from your end
    users about personally identifiable information and anonymity.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常会频繁访问相同的网站，因此将特定网站的URL的分类存储在本地数据库中，如LiteDB ([http://www.litedb.org/](http://www.litedb.org/))，将显著提高最终用户的性能。一种实现方法是将URL的SHA256哈希值作为键存储在本地，将分类作为值。从长远来看，你可以提供一个Web
    URL声誉数据库，将URL的SHA256哈希值发送到可扩展的云存储解决方案，如微软的Cosmos DB。存储URL的SHA256哈希值可以避免你的最终用户对个人可识别信息和匿名性的任何疑问。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we have deep dived into what goes into a production-ready
    Windows 10 UWP application architecture, using the work performed in previous
    chapters as a foundation. We also created a brand new web-page-classification
    Windows 10 application, utilizing the `SdcaLogisticRegression` algorithm from
    ML.NET. Lastly, we also discussed some ways to further enhance the example application
    (and production applications in general).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的讨论过程中，我们深入探讨了构建一个生产就绪的Windows 10 UWP应用程序架构需要哪些要素，并以前几章的工作为基础。我们还创建了一个全新的网页分类Windows
    10应用程序，利用了ML.NET中的`SdcaLogisticRegression`算法。最后，我们还讨论了一些进一步改进示例应用程序（以及一般的生产应用程序）的方法。
- en: With the conclusion of this chapter, this ends the real-world application section.
    The next section of the book includes both general machine learning practices
    in an agile production team and extending ML.NET with TensorFlow and **Open Neural
    Network Exchange** (**ONNX**) models. In the next chapter, we will focus on the
    former.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，现实世界的应用部分也随之结束。本书的下一部分将包括敏捷生产团队中的通用机器学习实践，以及使用TensorFlow和**Open Neural
    Network Exchange**（**ONNX**）模型扩展ML.NET。在下一章中，我们将重点关注前者。
