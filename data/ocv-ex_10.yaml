- en: Chapter 10. Developing Segmentation Algorithms for Text Recognition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。开发用于文本识别的分割算法
- en: In the previous chapters, we learned about a wide range of image processing
    techniques, such as thresholding, contour descriptors, and mathematical morphology.
    In this chapter, we will discuss the common problems with dealing with scanned
    documents, such as identifying where the text is or adjusting its rotation. We
    will also learn how to combine techniques presented in the previous chapters to
    solve these problems. Finally, we'll have segmented regions of text that can be
    sent to an **OCR** (**optical character recognition**) library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了许多图像处理技术，如阈值、轮廓描述符和数学形态学。在本章中，我们将讨论处理扫描文档时常见的常见问题，例如识别文本的位置或调整其旋转。我们还将学习如何结合前面章节中介绍的技术来解决这些问题。最后，我们将得到可以发送到**OCR**（**光学字符识别**）库的文本分割区域。
- en: 'By the end of this chapter, you should be able to answer the following questions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够回答以下问题：
- en: What kind of OCR applications exist?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些OCR应用存在？
- en: What are the common problems while writing an OCR application?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写OCR应用时常见的有哪些问题？
- en: How do we identify regions of documents?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何识别文档的区域？
- en: How do we deal with problems such as skewing and other elements in the middle
    of the text?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何处理文本中的倾斜和其他中间元素等问题？
- en: How do we use Tesseract OCR to identify the text?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用Tesseract OCR来识别文本？
- en: Introducing optical character recognition
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍光学字符识别
- en: 'Identifying text in an image is a very popular application for Computer Vision.
    This process is commonly called OCR and divided into the following steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中识别文本是计算机视觉中一个非常流行的应用。这个过程通常被称为OCR，并分为以下步骤：
- en: '**Text preprocessing and segmentation**: During this step, the computer must
    learn to deal with the image noise and rotation (skewing) and identify what areas
    are candidate text areas.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本预处理和分割**：在这个步骤中，计算机必须学会处理图像噪声和旋转（倾斜）并识别哪些区域是候选文本区域。'
- en: '**Text identification**: This is a process used to identify each letter in
    a text. Although this is also a Computer Vision topic, we will not show you how
    to do this in this book using OpenCV. Instead, we will show you how to use the
    Tesseract library to do this step, since it was integrated with OpenCV 3.0\. If
    you are interested in learning how to do what Tesseract does all by yourself,
    take a look at *Mastering OpenCV*, *Packt Publishing*, which presents a chapter
    about car license plate recognition.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本识别**：这是一个用于识别文本中每个字母的过程。尽管这也是一个计算机视觉主题，但在这本书中，我们不会使用OpenCV向您展示如何做这件事。相反，我们将向您展示如何使用Tesseract库来完成这一步，因为它与OpenCV
    3.0集成。如果您对学习如何完全自己完成Tesseract所做的一切感兴趣，请查看*Mastering OpenCV*，*Packt Publishing*，其中有一章关于车牌识别。'
- en: 'The preprocessing and segmentation phase can vary greatly depending on the
    source of the text. Let''s take a look at the common situations where preprocessing
    is done:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理和分割阶段可能因文本来源而异。让我们看看进行预处理的一些常见情况：
- en: 'Production OCR applications with a scanner, which is a very reliable source
    of text: In this scenario, the background of the image is usually white and the
    document is almost aligned with the scanner margins. The content that is being
    scanned basically contains text with almost no noise. This kind of application
    relies on simple preprocessing techniques that can adjust the text quickly and
    maintain a fast scanning pace. When writing production OCR software, it is common
    to delegate identification of important text regions to the user and create a
    quality pipeline for text verification and indexing.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扫描仪的生产OCR应用，这是一个非常可靠的文字来源：在这种情况下，图像的背景通常是白色的，文档几乎与扫描仪的边缘对齐。正在扫描的内容基本上包含几乎没有任何噪声的文本。这类应用依赖于简单的预处理技术，可以快速调整文本并保持快速扫描的速度。在编写生产OCR软件时，通常会将重要文本区域的识别委托给用户，并创建一个用于文本验证和索引的质量管道。
- en: 'Scanning text in a casually taken picture or in a video: This is a much more
    complex scenario, as there''s no indication of where the text can be. This scenario
    is called *Scene text recognition*, and OpenCV 3.0 introduces a brand new library
    to deal with it, which we will cover in [Chapter 11](ch11.html "Chapter 11. Text
    Recognition with Tesseract"), *Text Recognition with Tesseract*. Usually, the
    preprocessor will use texture analysis techniques to identify the text patterns.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在随意拍摄的图片或视频中扫描文本：这是一个更为复杂的场景，因为没有任何指示说明文本可能的位置。这种场景被称为*场景文本识别*，OpenCV 3.0引入了一个全新的库来处理这种情况，我们将在[第11章](ch11.html
    "第11章。使用Tesseract进行文本识别")，*使用Tesseract进行文本识别*中介绍。通常，预处理器会使用纹理分析技术来识别文本模式。
- en: 'Creating a production quality OCR for historical texts: Historical texts are
    also scanned.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为历史文本创建生产质量的OCR：历史文本也会被扫描。
- en: However, they have several additional problems, such as noise created by the
    old paper color and usage of ink. Other common problems are decorated letters,
    specific text fonts, and low-contrast content created by ink that has been degraded
    over time. It's not uncommon to write specific OCR software for documents at hand.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，它们有几个额外的问题，例如旧纸张颜色和墨水使用产生的噪声。其他常见问题包括装饰字母、特定的文本字体以及随着时间的推移而退化的墨水产生的低对比度内容。为手头文档编写特定的OCR软件并不罕见。
- en: 'Scanning maps, diagrams, and charts: Maps, diagrams, and charts pose a difficult
    scenario since the text is usually in any orientation and in the middle of an
    image''s content. For example, city names are often clustered, and ocean names
    often follow country shore contour lines. Some charts are heavily colored, with
    text appearing in both clear and dark tones.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描地图、图表和图表：地图、图表和图表构成了一个困难的场景，因为文本通常以任何方向出现在图像内容中。例如，城市名称通常成群，海洋名称通常遵循国家海岸轮廓线。一些图表颜色很深，文本以清晰和暗色调出现。
- en: OCR application strategies also vary according to the objective of the identification.
    Will they be used for a full text search? Or should the text be separated in a
    logical field to index a database with information for a structured search?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OCR应用策略也根据识别的目标而变化。它们将被用于全文搜索吗？或者应该将文本分离到逻辑字段中，以索引包含结构化搜索信息的数据库？
- en: 'In this chapter, we will focus on preprocessing scanned text or text photographed
    by a camera. We''ll assume that the text is the main purpose of the image, such
    as in a photograph, paper, or card; for example, take a look at the following
    parking ticket:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于预处理扫描的文本或由相机拍摄的文本。我们假设文本是图像的主要目的，例如在照片、纸张或卡片上；例如，看看下面的停车票：
- en: '![Introducing optical character recognition](img/B04283_10_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![介绍光学字符识别](img/B04283_10_01.jpg)'
- en: We'll try to remove the common noise, deal with text rotation (if any), and
    crop the possible text regions. While most OCR APIs already do these things automatically
    and probably with state-of-the-art algorithms, it still worth knowing how things
    happen under the hood. This will allow you to better understand most OCR APIs'
    parameters and will give you a better knowledge of potential OCR problems that
    you may face.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试去除常见的噪声，处理文本旋转（如果有），并裁剪可能的文本区域。虽然大多数OCR API已经自动执行这些操作，并且可能使用最先进的算法，但这仍然值得了解这些操作背后的原理。这将使您更好地理解大多数OCR
    API的参数，并为您提供更好的知识，了解您可能面临的潜在OCR问题。
- en: The preprocessing step
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理步骤
- en: Software that identifies letters do so by comparing text with a previously recorded
    data. Classification results can be improved greatly if the input text is clear,
    if the letters are in a vertical position, and if there are no other elements,
    such as images that are sent to the classification software. In this section,
    we'll learn how to adjust text. This stage is called **preprocessing**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 识别字母的软件通过将文本与先前记录的数据进行比较来进行。如果输入文本清晰，如果字母处于垂直位置，如果没有其他元素，例如发送到分类软件的图像，分类结果可以大大提高。在本节中，我们将学习如何调整文本。这个阶段被称为**预处理**。
- en: Thresholding the image
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阈值化图像
- en: 'We usually start the preprocessing stage by thresholding the image. This eliminates
    all the color information. Most OpenCV functions require information to be the
    written in white and the background to be black. So, let''s start with creating
    a threshold function to match this criterion:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过阈值化图像开始预处理阶段。这消除了所有颜色信息。大多数OpenCV函数都需要信息以白色书写，背景为黑色。因此，让我们从创建一个匹配此标准的阈值函数开始：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `binarize` function applies a threshold, similar to what we did in [Chapter
    4](ch04.html "Chapter 4. Delving into Histograms and Filters"), *Delving into
    Histograms and Filters*. However, we use the `Otsu` method by passing `THRESH_OTSU`
    to the fourth parameter of the function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`binarize`函数应用一个阈值，类似于我们在[第4章](ch04.html "第4章. 深入直方图和滤波器")，*深入直方图和滤波器*中所做的那样。然而，我们通过将`THRESH_OTSU`传递给函数的第四个参数来使用`Otsu`方法。'
- en: The `Otsu` method maximizes the inter-class variance. Since a threshold creates
    only two classes (the black and white pixels), this is the same as minimizing
    the intra-class variance. The method works using the image histogram. Then, it
    iterates through all the possible threshold values and calculates a measure of
    spread for the pixel values on each side of the threshold, that is, the pixels
    that are either in the background or in the foreground of the image. The purpose
    is to find the threshold value where the sum of both the spreads is at its minimum.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Otsu`方法最大化类间方差。由于阈值只创建两个类别（黑色和白色像素），这等同于最小化类内方差。该方法使用图像直方图进行工作。然后，它遍历所有可能的阈值值，并计算阈值两侧像素值的扩散度，即图像的背景或前景中的像素。目的是找到使两者扩散度之和最小的阈值值。'
- en: After the thresholding is done, the function counts the number of white pixels
    in the image. The black pixels are simply the total number of pixels in the image,
    given by the image area minus the white pixel count.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值处理完成后，函数会计算图像中的白色像素数量。黑色像素是图像中像素的总数，由图像面积减去白色像素计数得出。
- en: Since text is usually written on a plain background, we will check whether there
    are more white pixels than black. In this case, we are dealing with black text
    over a white background, so we invert the image for further processing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文本通常写在纯背景上，我们将检查是否有比黑色像素更多的白色像素。在这种情况下，我们处理的是黑色文本在白色背景上，因此我们需要对图像进行反转以进行进一步处理。
- en: 'The result of the thresholding process with the parking ticket image is shown
    in the following image:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用停车票图像进行阈值处理的结果如下所示：
- en: '![Thresholding the image](img/B04283_10_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![对图像进行阈值处理](img/B04283_10_02.jpg)'
- en: Text segmentation
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本分割
- en: 'The next step is to find where the text is located and extract it. There are
    two common strategies to do this, which are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到文本的位置并提取它。有两种常见的策略可以实现这一点，如下所示：
- en: Using the connected component analysis, we search for groups of connected pixels
    in the image. This is the technique that we will use in this chapter.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用连通分量分析，我们在图像中搜索连通像素组。这是我们将在本章中使用的技巧。
- en: Use classifiers to search for a previously trained letter texture pattern. Texture
    features such as Haralick features and wavelet transforms are often used. The
    other option is to identify **maximally stable extremal regions** (**MSERs**)
    in this task. This approach is more robust for text in a complex background and
    will be studied in the next chapter. You can read about Haralick features on his
    own website at [http://haralick.org/journals/TexturalFeatures.pdf](http://haralick.org/journals/TexturalFeatures.pdf).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分类器来搜索之前训练过的字母纹理模式。纹理特征，如Haralick特征和小波变换，通常被使用。另一个选择是在这个任务中识别**最大稳定极值区域**（**MSERs**）。这种方法对于复杂背景中的文本更加鲁棒，将在下一章中进行研究。你可以在他的个人网站上阅读有关Haralick特征的更多信息：[http://haralick.org/journals/TexturalFeatures.pdf](http://haralick.org/journals/TexturalFeatures.pdf)。
- en: Creating connected areas
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建连通区域
- en: If you take a closer look at the image, you'll notice that the letters are always
    grouped together in blocks that are formed by each of text paragraphs. So, how
    do we detect and remove these blocks?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察图像，你会注意到字母总是成块地聚集在一起，这些块是由每个文本段落形成的。那么，我们如何检测和移除这些块呢？
- en: 'The first step is to make these blocks even more evident. We can do this using
    the dilation morphological operator. In [Chapter 8](ch08.html "Chapter 8. Video
    Surveillance, Background Modeling, and Morphological Operations"), *Video Surveillance,
    Background Modeling, and Morphological Operations*, we learned how dilation makes
    the image elements thicker. Let''s take a look at the following code snippet that
    does the trick:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使这些块更加明显。我们可以使用膨胀形态学算子来完成这项工作。在[第8章](ch08.html "第8章. 视频监控、背景建模和形态学操作")，*视频监控、背景建模和形态学操作*中，我们学习了如何通过膨胀使图像元素变厚。让我们看看以下代码片段，它完成了这项工作：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we start by creating a 3 x 3 cross kernel that will be used in
    the morphological operation. Then, we apply the dilation five times, centered
    on this kernel. The exact kernel size and number of times vary according to the
    situation. Just make sure that the values glue all the letters in the same line
    together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先创建一个3 x 3的交叉核，该核将在形态学操作中使用。然后，我们以该核为中心进行五次膨胀。确切的核大小和次数根据情况而变化。只需确保这些值将同一行上的所有字母粘合在一起即可。
- en: 'The result of this operation is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的输出结果如下：
- en: '![Creating connected areas](img/B04283_10_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![创建连通区域](img/B04283_10_03.jpg)'
- en: Notice that now we have huge white blocks. They exactly match each paragraph
    of the text and also match other nontextual elements such as images or the border
    noise.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们有了巨大的白色块。它们正好与每个段落文本相匹配，也匹配其他非文本元素，如图像或边缘噪声。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The ticket image that comes with the code is a low resolution image. OCR engines
    usually work with high resolution images (200 or 300 DPI), so it may be necessary
    to apply dilation more than five times.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码附带的票据图像是低分辨率图像。OCR引擎通常使用高分辨率图像（200或300 DPI），因此可能需要应用超过五次的膨胀。
- en: Identifying paragraph blocks
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别段落块
- en: 'The next step is to perform connect component analysis to find blocks that
    correspond to paragraphs. OpenCV has a function to do this, which we previously
    used in [Chapter 5](ch05.html "Chapter 5. Automated Optical Inspection, Object
    Segmentation, and Detection"), *Automated Optical Inspection, Object Segmentation,
    and Detection*. It''s the `findContours` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是执行连通分量分析以找到对应于段落的块。OpenCV有一个函数可以做到这一点，我们之前在[第5章](ch05.html "第5章. 自动光学检测、对象分割和检测")中使用过，称为*自动光学检测、对象分割和检测*。它是`findContours`函数：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the first parameter, we pass our dilated image. The second parameter is
    the vector of detected contours. Then we use the option to retrieve only external
    contours and use simple approximation. The image contours are presented in the
    following figure. Each tone of gray represents a different contour:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个参数中，我们传递我们的膨胀图像。第二个参数是检测到的轮廓向量。然后我们使用选项仅检索外部轮廓并使用简单近似。图像轮廓在以下图中展示。每种灰度色调代表不同的轮廓：
- en: '![Identifying paragraph blocks](img/B04283_10_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![识别段落块](img/B04283_10_04.jpg)'
- en: The last step is to identify the minimum rotated bounding rectangle of each
    contour. OpenCV provides a handy function for this operation called `minAreaRect`.
    This function receives a vector of arbitrary points and returns a `RoundedRect`
    that contains the bounding box.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是识别每个轮廓的最小旋转边界矩形。OpenCV提供了一个方便的函数来完成此操作，称为`minAreaRect`。此函数接收一个任意点的向量，并返回一个包含边界框的`RoundedRect`。
- en: 'This is also a good opportunity to discard unwanted rectangles, that is, rectangles
    that are obviously **not** text. Since we are making a software for OCR, we''ll
    assume that the text contains a group of letters together. With this assumption,
    we''ll discard text in the following situations:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个丢弃不需要的矩形的好机会，即显然**不是**文本的矩形。由于我们正在制作OCR软件，我们将假设文本包含一组字母。基于这个假设，我们将丢弃以下情况下的文本：
- en: The rectangle width or size is too small, that is, smaller than 20 pixels. This
    will help you discard border noise and other small artifacts.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形的宽度或大小太小，即小于20像素。这将帮助您丢弃边缘噪声和其他小瑕疵。
- en: The rectangles of the images that have a width/height proportion smaller than
    two. That is, rectangles that resemble a square, such as image icons, or ones
    that are much taller and larger will also be discarded.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的矩形，其宽/高比例小于2。也就是说，类似于正方形的矩形，如图像图标，或者那些非常高大的矩形也将被丢弃。
- en: 'There''s a little caveat in the second condition. Since we are dealing with
    rotated bounding boxes, we must check whether the bounding box angle is not smaller
    than 45 degrees. If that''s the case, the text will be vertically rotated, so
    the proportion that must be taken into account is the height/width. Let''s take
    a look at this code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个条件中有一个小问题。由于我们正在处理旋转边界框，我们必须检查边界框的角度是否不小于45度。如果是这样，文本将是垂直旋转的，因此必须考虑的比例是高度/宽度。让我们看看这段代码：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s see the boxes that are selected by this algorithm:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个算法选择的盒子：
- en: '![Identifying paragraph blocks](img/B04283_10_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![识别段落块](img/B04283_10_05.jpg)'
- en: This is certainly a good result!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个好结果！
- en: Notice that the algorithm described in condition 2 will also discard single
    letters. This is not a big issue, since we are creating an OCR preprocessor, and
    single symbols are usually meaningless with the context information. One example
    of such a case is the page numbers. They will be discarded with this process since
    they usually appear alone at the bottom of the page and will definitely fail the
    size or proportion text. However, this will not be a problem, as after the text
    passes through the OCR, there will be a huge text file with no page division at
    all.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，条件2中描述的算法也会丢弃单个字母。这不是一个大问题，因为我们正在创建一个OCR预处理程序，而单个符号通常与上下文信息无关。一个这样的例子是页码。由于它们通常单独出现在页面底部，并且肯定会因为大小或比例文本而失败，因此它们将在这个过程中被丢弃。然而，这不会成为问题，因为文本通过OCR后，将会有一个没有页面分隔的巨大文本文件。
- en: 'We''ll place this code in a function with this signature:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这段代码放在一个具有此签名的函数中：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Text extraction and skew adjustment
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本提取和倾斜调整
- en: 'Now, all we need to do is extract the text and adjust text skew. This is done
    by the `deskewAndCrop` function, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要提取文本并调整文本倾斜。这是通过 `deskewAndCrop` 函数完成的，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we start by reading the desired region, angle, and size. As mentioned
    earlier, the angle can be less than 45 degrees. This means that the text is vertically
    aligned, so we need to add 90 degrees to the rotation angle and switch the width
    and height properties.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始读取所需的区域、角度和大小。如前所述，角度可以小于45度。这意味着文本是垂直对齐的，因此我们需要将旋转角度增加90度，并切换宽度和高度属性。
- en: 'Next, we need to rotate the text. First, we start by creating a 2D affine transformation
    matrix that describes the rotation. We do this using the `getRotationMatrix2D`
    OpenCV function. This function takes the following three parameters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要旋转文本。首先，我们开始创建一个2D仿射变换矩阵，该矩阵描述了旋转。我们使用 OpenCV 的 `getRotationMatrix2D`
    函数来完成此操作。此函数接受以下三个参数：
- en: '`CENTER`: This is the central position of the rotation. The rotation will pivot
    around this center. In our case, we use the box center.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CENTER`：这是旋转的中心位置。旋转将围绕这个中心旋转。在我们的情况下，我们使用框的中心。'
- en: '`ANGLE`: This is the rotation angle. If the angle is negative, the rotation
    will occur in the clockwise direction.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANGLE`：这是旋转角度。如果角度为负，则旋转将按顺时针方向进行。'
- en: '`SCALE`: This is an isotropic scale factor. We use 1.0 as we want to keep the
    box''s original scale untouched.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCALE`：这是一个各向同性的缩放因子。我们使用1.0，因为我们想保持框的原始比例不变。'
- en: 'The rotation itself is made using the `warpAffine` function. This function
    takes four mandatory arguments, which are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转本身是通过 `warpAffine` 函数实现的。此函数接受四个必选参数，如下所示：
- en: '`SRC`: This is the input `mat` array to be transformed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC`：这是要转换的输入 `mat` 数组。'
- en: '`DST`: This is the destination `mat` array.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DST`：这是目标 `mat` 数组。'
- en: '`M`: This is a transformation matrix. This matrix is a 2 x 3 affine transformation
    matrix. This may be a translation, scale, or rotation matrix. In our case, we
    just use the matrix that we recently created.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M`：这是一个转换矩阵。这个矩阵是一个2 x 3的仿射变换矩阵。这可能是一个平移、缩放或旋转矩阵。在我们的情况下，我们只使用我们最近创建的矩阵。'
- en: '`SIZE`: This is the size of the output image. We will generate an image with
    the same size as that of our input image.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIZE`：这是输出图像的大小。我们将生成与输入图像大小相同的图像。'
- en: 'The other three optional arguments are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个可选参数如下：
- en: '`FLAGS`: This indicates how the image should be interpolated. We use `BICUBIC_INTERPOLATION`
    for better quality. The default value is `LINEAR_INTERPOLATION`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLAGS`：这表示图像应该如何插值。我们使用 `BICUBIC_INTERPOLATION` 以获得更好的质量。默认值是 `LINEAR_INTERPOLATION`。'
- en: '`BORDER`: This is the border mode. We use the default `BORDER_CONSTANT`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BORDER`：这是边界模式。我们使用默认的 `BORDER_CONSTANT`。'
- en: '`BORDER VALUE`: This is the color of the border. We use the default value,
    which is black.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BORDER VALUE`：这是边界的颜色。我们使用默认值，即黑色。'
- en: 'Then, we use the `getRectSubPix` function. After we rotate our image, we need
    to crop the rectangular area of our bounding box. This function takes four mandatory
    arguments and one optional, and returns the cropped image:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `getRectSubPix` 函数。在我们旋转图像后，我们需要裁剪边界框的矩形区域。此函数接受四个必选参数和一个可选参数，并返回裁剪后的图像：
- en: '`IMAGE`: This is the image to be cropped.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMAGE`：这是要裁剪的图像。'
- en: '`SIZE`: This is a `cv::Size` object that describes the width and height of
    the box to be cropped.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIZE`：这是一个 `cv::Size` 对象，描述了要裁剪的框的宽度和高度。'
- en: '`CENTER`: This is the central pixel of the area to be cropped. Notice that
    as we rotate around the center, this point remains the same.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CENTER`: 这是裁剪区域的中心像素点。注意，当我们围绕中心旋转时，这个点保持不变。'
- en: '`PATCH`: This is the destination image.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`: 这是目标图像。'
- en: '`PATCH_TYPE`: This is the depth of the destination image. We use the default
    value, representing the same depth as that of the source image.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH_TYPE`: 这是目标图像的深度。我们使用默认值，表示与源图像相同的深度。'
- en: 'The final step is done by the `copyMakeBorder` function. This function adds
    a border around the image. This is important because the classification stage
    usually expects a margin around the text. The function parameters are very simple:
    the input and output images, the border thickness around the top, bottom, left,
    and right of the image, and the color of the new border.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步由`copyMakeBorder`函数完成。此函数在图像周围添加边框。这很重要，因为分类阶段通常期望文本周围有边距。函数参数非常简单：输入和输出图像，图像顶部、底部、左侧和右侧的边框厚度，以及新边框的颜色。
- en: 'For the card image, the following images will be generated:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于卡片图像，将生成以下图像：
- en: '![Text extraction and skew adjustment](img/B04283_10_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![文本提取和倾斜调整](img/B04283_10_06.jpg)'
- en: 'Now, it''s time to put every function together. Let''s present the main method
    that will do the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将每个功能组合在一起了。让我们展示以下主要方法：
- en: Load the ticket image
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载票据图像
- en: Call our `binarization` function
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用我们的`binarization`函数
- en: Find all text regions
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有文本区域
- en: 'Show each region in a window:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口中显示每个区域：
- en: '[PRE6]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the complete source code, take a look at the `segment.cpp` file that comes
    along with this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的源代码，请查看随本书附带的`segment.cpp`文件。
- en: Installing Tesseract OCR on your operating system
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的操作系统上安装Tesseract OCR
- en: Tesseract is an open source OCR engine originally developed by *Hewlett-Packard
    Laboratories, Bristol* and *Hewlett-Packard Co*. It has all the code licenses
    under the Apache License and is hosted on GitHub at [https://github.com/tesseract-ocr](https://github.com/tesseract-ocr).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Tesseract是一个开源OCR引擎，最初由*惠普实验室，布里斯托尔*和*惠普公司*开发。它所有的代码许可证都在Apache许可证下，并在GitHub上托管，网址为[https://github.com/tesseract-ocr](https://github.com/tesseract-ocr)。
- en: It is considered one of the most accurate OCR engines that is available. It
    can read a wide variety of image formats and can convert text written in more
    than 60 languages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它被认为是可用的最准确的OCR引擎之一。它可以读取多种图像格式，并且可以将60多种语言中写成的文本转换为文本。
- en: In this session, we will teach you how to install Tesseract on Windows or Mac.
    Since there are lots of Linux distributions, we will not teach you how to install
    on this operating system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次会话中，我们将教您如何在Windows或Mac上安装Tesseract。由于有大量的Linux发行版，我们不会教您如何在操作系统上安装。
- en: Normally, Tesseract offers installation packages in your package repository,
    so before you compile Tesseract, just search there.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Tesseract在其软件仓库中提供安装包，因此在编译Tesseract之前，只需在那里搜索即可。
- en: Installing Tesseract on Windows
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows上安装Tesseract
- en: Although Tesseract is hosted on GitHub, its latest Windows installer is still
    available in the old repository on Google Code. The latest installer version is
    3.02.02, and it's recommended that you use the installer. Download the installer
    from [https://code.google.com/p/tesseract-ocr/downloads/list](https://code.google.com/p/tesseract-ocr/downloads/list).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Tesseract托管在GitHub上，但其最新的Windows安装程序仍然可在Google Code的旧仓库中找到。最新的安装程序版本是3.02.02，建议您使用安装程序。从[https://code.google.com/p/tesseract-ocr/downloads/list](https://code.google.com/p/tesseract-ocr/downloads/list)下载安装程序。
- en: 'Once you have downloaded the installer, perform these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下载安装程序后，执行以下步骤：
- en: Look for the `tesseract-ocr-setup-3.02.02.exe` and `tesseract-3.02.02-win32-lib-include-dirs.zip`
    files, and download and run the executable installer![Installing Tesseract on
    Windows](img/B04283_10_07.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`tesseract-ocr-setup-3.02.02.exe`和`tesseract-3.02.02-win32-lib-include-dirs.zip`文件，下载并运行可执行安装程序![在Windows上安装Tesseract](img/B04283_10_07.jpg)
- en: To get past the **welcome screen**, read and accept the license agreement.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要跳过**欢迎屏幕**，请阅读并接受许可协议。
- en: Choose between installing for all users in the computer or just for your user.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算机上为所有用户安装或仅为您的用户安装之间进行选择。
- en: Then, choose a suitable location for your installation.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择合适的安装位置。
- en: Choose the folder of the installation. Tesseract points to the `program files`
    folder by default, since it has a command-line interface. You can change it to
    a more suitable folder, if you want. Then, go to the next screen:![Installing
    Tesseract on Windows](img/B04283_10_08.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择安装文件夹。Tesseract 默认指向`程序文件`文件夹，因为它有一个命令行界面。如果你想，可以将其更改为更合适的文件夹。然后，转到下一屏幕：![在
    Windows 上安装 Tesseract](img/B04283_10_08.jpg)
- en: Make sure you select **Tesseract development files**. This will install the
    `Leptonica` library files and source code. You can also choose language data for
    your native language. Tesseract has English selected by default.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您选择了**Tesseract 开发文件**。这将安装`Leptonica`库文件和源代码。您还可以选择您母语的语料库。Tesseract 默认选择英语。
- en: The installer will download and set up Tesseract dependencies.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装程序将下载并设置 Tesseract 依赖项。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'To test the Tesseract installation, you can run it via the command line. For
    example, to run Tesseract on the `parkingTicket.png` file, you can run the following
    command:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要测试 Tesseract 安装，您可以通过命令行运行它。例如，要在`parkingTicket.png`文件上运行 Tesseract，您可以运行以下命令：
- en: '[PRE7]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, go back to the downloaded `tesseract-3.02.02-win32-lib-include-dirs.zip`
    file. Unzip this file and copy the `lib` and `add` folders to your `tesseract`
    installation folder. There will be folders with the same name in this folder,
    but that's normal. This file will include `tesseract` files and libraries in the
    Tesseract installation. Ironically, Tesseract `libs` and `dlls` do not come with
    the installer.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到下载的`tesseract-3.02.02-win32-lib-include-dirs.zip`文件。解压此文件，并将`lib`和`add`文件夹复制到您的`tesseract`安装文件夹中。在这个文件夹中会有相同名称的文件夹，但这是正常的。此文件将包括
    Tesseract 文件和库在 Tesseract 安装中。具有讽刺意味的是，Tesseract `libs`和`dlls`不包括在安装程序中。
- en: Setting up Tesseract in Visual Studio
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中设置 Tesseract
- en: Since Visual Studio 2010 is the recommended IDE for Windows developers with
    Tesseract, it's important to set this up correctly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Visual Studio 2010 是推荐用于 Windows 开发者与 Tesseract 的 IDE，因此正确设置这一点很重要。
- en: 'The setup process is quite simple, and it''s divided into the following three
    steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 设置过程相当简单，分为以下三个步骤：
- en: Adjust the import and library paths.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整导入和库路径。
- en: Add the libraries to the linker input.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将库添加到链接器输入。
- en: Add Tesseract `dlls` to the windows path.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Tesseract `dlls` 添加到 windows 路径。
- en: Let's see each of these steps in the following sections.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的部分逐一查看这些步骤。
- en: Setting the import and library paths
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置导入和库路径
- en: The import path tells Visual Studio where to search for the `.h` files that
    will be available when an `#include` directive is performed in your code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 导入路径告诉 Visual Studio 在执行代码中的`#include`指令时在哪里搜索可用的`.h`文件。
- en: In solution explorer, right-click on your **project** and click on **properties**.
    Then, select **configuration properties** and **VC++ Directories**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，右键单击您的**项目**，然后单击**属性**。然后，选择**配置属性**和**VC++ 目录**。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have created a new project from scratch, make sure you added at least
    one `c++` file to the project to let Visual know that this is a `C++` project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从头创建的新项目，请确保您至少向项目中添加了一个`c++`文件，以便 Visual Studio 知道这是一个`C++`项目。
- en: 'Next, click on **Include Directories**. An arrow appears. Click on this arrow
    and then click on **Edit**:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击**包含目录**。出现一个箭头。点击此箭头，然后点击**编辑**：
- en: '![Setting the import and library paths](img/B04283_10_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![设置导入和库路径](img/B04283_10_09.jpg)'
- en: 'You must add two directories to this list:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须将两个目录添加到该列表中：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Replace the `TesseractInstallPath` with your Tesseract installation path; for
    example, `c:\Program Files\Tesseract-OCR`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将`TesseractInstallPath`替换为您的 Tesseract 安装路径；例如，`c:\Program Files\Tesseract-OCR`。
- en: 'Then, click on **Library Directories**, click on the arrow, and then on `Edit`,
    just like you did for **Include Directories**. You must add one directory to the
    list:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击**库目录**，点击箭头，然后点击`编辑`，就像你为**包含目录**所做的那样。你必须将一个目录添加到列表中：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Configuring the linker
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置链接器
- en: 'While still on the Property page, go to **Linker** | **Input**. Edit the **Additional
    Dependencies** row and include two libraries:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在仍然在属性页上时，转到**链接器** | **输入**。编辑**附加依赖项**行，并包含两个库：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the numbers in the `lib` name refer to the file version, the library names
    can change if you install a different version of Tesseract. To do this, just open
    the `lib` path in Windows Explorer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`lib`名称中的数字指的是文件版本，因此如果安装了不同版本的 Tesseract，库名称可能会更改。为此，只需在 Windows 资源管理器中打开`lib`路径即可。
- en: Unfortunately, the debug libraries (the ones that end with a *d* letter) do
    not work out of the box with Tesseract. If you really need to use them, you need
    to compile Tesseract and Leptonica yourself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，调试库（以 *d* 字母结尾的库）与 Tesseract 不兼容。如果你真的需要使用它们，你需要自己编译 Tesseract 和 Leptonica。
- en: Adding the libraries to the windows path
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将库添加到 Windows 路径中
- en: 'You must add two library files to the windows path. The first is located directly
    in `TesseractInstallPath` and it is called `liblept168.dll`. The second one is
    in `TesseractInstallPath\lib` and it is called `libtesseract302.dll`. There are
    two ways to do this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将两个库文件添加到 Windows 路径中。第一个位于 `TesseractInstallPath` 中，称为 `liblept168.dll`。第二个位于
    `TesseractInstallPath\lib` 中，称为 `libtesseract302.dll`。有两种方法可以实现这一点：
- en: Copy these files to a location where Visual Studio generates your executable
    file. This will not add the files to the Windows path but will allow the application
    to run.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些文件复制到 Visual Studio 生成可执行文件的位置。这不会将这些文件添加到 Windows 路径中，但允许应用程序运行。
- en: Copy these files to a folder that is configured in the Windows path. You can
    configure a new folder in the Windows path by changing the environment variables
    in **System Properties**.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些文件复制到配置在 Windows 路径中的文件夹。你可以通过更改 **系统属性** 中的环境变量来在 Windows 路径中配置新文件夹。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some internet tutorials teach you to include these files in folders, such as
    `Windows\System32`. Do not do this. If you do this, it can be hard to change the
    library version in the future, since this folder has a lot of other `dlls` systems,
    and you may lose track of what you already placed in there. Also, you can always
    disable a custom path to test an installer and check whether you forgot to pack
    a `dll` in your installation bundle.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些互联网教程教你将这些文件包含在文件夹中，例如 `Windows\System32`。不要这样做。如果你这样做，将来更改库版本可能会很困难，因为这个文件夹包含很多其他的
    `dlls` 系统，你可能会失去跟踪你已经在那里放置了什么。此外，你总是可以禁用自定义路径来测试安装程序并检查你是否忘记在你的安装包中打包 `dll`。
- en: Installing Tesseract on Mac
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Mac 上安装 Tesseract
- en: The easiest way to install Tesseract OCR on Mac is using Homebrew. If you don't
    have Homebrew installed, just go to the Homebrew site ([http://brew.sh/](http://brew.sh/)),
    open your console, and run the Ruby script that is on the front page. You may
    be required to type your administrator password.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上安装 Tesseract OCR 的最简单方法是使用 Homebrew。如果你还没有安装 Homebrew，只需访问 Homebrew 网站
    ([http://brew.sh/](http://brew.sh/))，打开你的控制台，并运行首页上的 Ruby 脚本。你可能需要输入管理员密码。
- en: 'After `homebrew` is installed, just type the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `homebrew` 后，只需输入以下命令：
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The English language is already included in this installation. If you want
    to install other language packs, just run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 英语语言已经包含在这个安装中。如果你想安装其他语言包，只需运行以下命令：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will install all language packs. Then, just go to the Tesseract installation
    directory and delete all unwanted languages. Homebrew usually installs stuff in
    `/usr/local/`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所有语言包。然后，只需转到 Tesseract 安装目录并删除所有不需要的语言。Homebrew 通常将软件安装到 `/usr/local/`。
- en: Using Tesseract OCR library
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tesseract OCR 库
- en: As Tesseract OCR is already integrated with OpenCV 3.0, it still worth studying
    its API since it allows a finer-grained control over Tesseract parameters. The
    integration will be studied in the next chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Tesseract OCR 已经与 OpenCV 3.0 集成，因此研究其 API 仍然值得，因为它允许更精细地控制 Tesseract 参数。集成将在下一章中研究。
- en: Creating a OCR function
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 OCR 函数
- en: 'We''ll change the previous example to work with Tesseract. We will start with
    adding `baseapi` and `fstream tesseracts` to the list:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改之前的示例以使用 Tesseract。我们将从向列表中添加 `baseapi` 和 `fstream tesseracts` 开始：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we''ll create a global `TessBaseAPI` object that represents our Tesseract
    OCR engine:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个全局的 `TessBaseAPI` 对象，它代表我们的 Tesseract OCR 引擎：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `ocr` engine is completely self-contained. If you want to create multithreaded
    OCR software, just add a different `TessBaseAPI` object to each thread, and the
    execution will be fairly thread-safe. You just need to guarantee that file writing
    is not done over the same file; otherwise, you'll need to guarantee safety for
    this operation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ocr` 引擎是完全自包含的。如果你想创建多线程 OCR 软件，只需为每个线程添加不同的 `TessBaseAPI` 对象，执行将相当线程安全。你只需要保证文件写入不是在同一个文件上；否则，你需要保证此操作的安全性。'
- en: 'Next, we will create a function called `identify` text that will run the OCR:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为 `identify` 的函数来运行 OCR：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s explain this function line by line. In the first line, we start initializing
    Tesseract. This is done by calling the `init` function. This function has the
    following signature:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解释这个函数。在第一行，我们开始初始化 Tesseract。这是通过调用 `init` 函数来完成的。此函数具有以下签名：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s explain each parameter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解释每个参数：
- en: '**Datapath**: This is the path to the `tessdata` files of the root directory.
    The path must end with a backslash / character. The `tessdata` directory contains
    the language files that you installed. Passing `NULL` to this parameter will make
    Tesseract search in its installation directory, which is the location where this
    folder is normally present. It''s common to change this value to `args[0]` when
    deploying an application and include the `tessdata` folder in your application
    path.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Datapath**: 这是根目录中 `tessdata` 文件的路径。路径必须以反斜杠 / 字符结尾。`tessdata` 目录包含您安装的语言文件。将
    `NULL` 传递给此参数将使 Tesseract 在其安装目录中搜索，这通常是此文件夹通常所在的位置。在部署应用程序时，通常将此值更改为 `args[0]`，并将
    `tessdata` 文件夹包含在应用程序路径中。'
- en: '**Language**: This is a three-letter word with the language code (for example,
    eng for English, por for Portuguese, or hin for Hindi). Tesseract supports loading
    of multiple language code using the `+` sign. So, passing *eng* + *por* will load
    both English and Portuguese. Of course, you can only use languages that you have
    previously installed; otherwise, the loading will fail. A language `config` file
    can specify that two or more languages must be loaded together. To prevent this,
    you can use a tilde `~`. For example, you can use `hin+~eng` to guarantee that
    English is not loaded with Hindi, even if it is configured to do so.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Language**: 这是一个由语言代码组成的三个字母的单词（例如，eng 代表英语，por 代表葡萄牙语，或 hin 代表印地语）。Tesseract
    支持使用 `+` 符号加载多个语言代码。因此，传递 *eng* + *por* 将加载英语和葡萄牙语。当然，您只能使用您之前安装的语言；否则，加载将失败。语言
    `config` 文件可以指定必须一起加载两个或多个语言。为了防止这种情况，您可以使用波浪号 `~`。例如，您可以使用 `hin+~eng` 来确保即使配置了这样做，也不会将英语与印地语一起加载。'
- en: '**OcrEngineMode**: These are OCR algorithms that will be used. They can have
    one of the following values:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OcrEngineMode**: 这些是将要使用的 OCR 算法。它们可以具有以下值之一：'
- en: '`OEM_TESSERACT_ONLY`: This uses just Tesseract. It''s the fastest method, but
    it also has less precision.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM_TESSERACT_ONLY`: 这仅使用 Tesseract。这是最快的方法，但精度较低。'
- en: '`OEM_CUBE_ONLY`: This uses cube engine. It''s slower, but it''s more precise.
    This will only work if your language was trained to support this engine mode.
    To check whether that''s the case, look for `.cube` files for your language in
    the `tessdata` folder. The support for English is guaranteed.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM_CUBE_ONLY`: 这使用 cube 引擎。它较慢，但更精确。这将仅适用于您的语言经过训练以支持此引擎模式的情况。要检查是否如此，请查看
    `tessdata` 文件夹中您语言对应的 `.cube` 文件。对英语的支持是保证的。'
- en: '`OEM_TESSERACT_CUBE_COMBINED`: This combines both Tesseract and Cube in order
    to achieve the best possible OCR classification. This engine has the best accuracy
    and the slowest execution time.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM_TESSERACT_CUBE_COMBINED`: 这将 Tesseract 和 Cube 结合起来，以实现最佳的 OCR 分类。此引擎具有最佳的准确性和最慢的执行时间。'
- en: '`OEM_DEFAULT`: This tries to infer the strategy based on the language `config`
    file and the command line `config` file, or in the absence of both, uses `OEM_TESSERACT_ONLY`.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OEM_DEFAULT`: 这尝试根据语言 `config` 文件和命令行 `config` 文件推断策略，或者在两者都缺失的情况下使用 `OEM_TESSERACT_ONLY`。'
- en: It's important to emphasize that the `init` function *can* be executed many
    times. If a different language or engine mode is provided, Tesseract will clear
    the previous configuration and start again. If the same parameters are provided,
    Tesseract is smart enough to simply ignore the command. The `init` function returns
    `0` for success and `-1` for failure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，`init` 函数**可以**执行多次。如果提供了不同的语言或引擎模式，Tesseract 将清除之前的配置并重新开始。如果提供了相同的参数，Tesseract
    足够智能，可以简单地忽略该命令。`init` 函数在成功时返回 `0`，在失败时返回 `-1`。
- en: 'Our program then proceeds by setting the page segmentation mode:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的程序继续设置页面分割模式：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are several segmentation modes available, which are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种分割模式可用，如下所示：
- en: '`PSM_OSD_ONLY`: Using this mode, Tesseract just runs its preprocessing algorithms
    to detect the orientation and script detection.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_OSD_ONLY`: 使用此模式，Tesseract 只运行其预处理算法以检测方向和脚本检测。'
- en: '`PSM_AUTO_OSD`: This tells Tesseract to perform automatic page segmentation
    with orientation and script detection.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_AUTO_OSD`: 这告诉 Tesseract 执行带有方向和脚本检测的自动页面分割。'
- en: '`PSM_AUTO_ONLY`: This does page segmentation, but avoids doing orientation,
    script detection, or OCR.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_AUTO_ONLY`: 这执行页面分割，但避免执行方向、脚本检测或OCR。'
- en: '`PSM_AUTO`: This does page segmentation and OCR, but avoids doing orientation
    or script detection.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_AUTO`: 这执行页面分割和OCR，但避免执行方向或脚本检测。'
- en: '`PSM_SINGLE_COLUMN`: This assumes that the text of variable sizes is displayed
    in a single column.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_COLUMN`: 这假设可变大小的文本显示在单个列中。'
- en: '`PSM_SINGLE_BLOCK_VERT_TEXT`: This treats the image as a single uniform block
    of a vertically aligned text.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_BLOCK_VERT_TEXT`: 这将图像视为一个垂直对齐的单一均匀文本块。'
- en: '`PSM_SINGLE_BLOCK`: This is a single block of text. This is the default configuration.
    We will use this flag since our preprocessing phase guarantees this condition.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_BLOCK`: 这是一个单独的文本块。这是默认配置。我们将使用此标志，因为我们的预处理阶段保证了这种条件。'
- en: '`PSM_SINGLE_LINE`: This indicates that the image contains only one line of
    text.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_LINE`: 这表示图像只包含一行文本。'
- en: '`PSM_SINGLE_WORD`: This indicates that the image contains just one word.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_WORD`: 这表示图像只包含一个单词。'
- en: '`PSM_SINGLE_WORD_CIRCLE`: This indicates that the image is just one word that
    is disposed in a circle.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_WORD_CIRCLE`: 这表示图像是一个圆形排列的单词。'
- en: '`PSM_SINGLE_CHAR`: This indicates that the image contains a single character.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSM_SINGLE_CHAR`: 这表示图像只包含一个字符。'
- en: Notice that Tesseract has already implemented `deskewing` and text segmentation
    algorithms, as most OCR libraries do. But it's interesting to know such algorithms
    as you can provide your own preprocessing phase for specific needs. This allows
    you to improve text detection is many cases. For example, if you are creating
    an OCR application for old documents, the default threshold used by Tesseract
    can create a dark background. Tesseract may also be confused by borders or severe
    text skewing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Tesseract已经实现了`deskewing`和文本分割算法，就像大多数OCR库一样。但了解这些算法是有趣的，因为您可以为特定需求提供自己的预处理阶段。这允许您在许多情况下改进文本检测。例如，如果您正在为旧文档创建OCR应用程序，Tesseract默认使用的阈值可能会创建一个深色背景。Tesseract还可能被边缘或严重的文本倾斜所困惑。
- en: 'Next, we call the `SetImage` method with the signature:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下签名调用`SetImage`方法：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The parameters are almost self-explanatory, and most of them can be read directly
    from our `mat` object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 参数几乎是自我解释的，其中大部分可以直接从我们的`mat`对象中读取：
- en: '`data`: This is a raw byte array that contains the image data. OpenCV contains
    a function called `data()` in the `Mat` class that provides a direct pointer to
    the data.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`: 这是一个包含图像数据的原始字节数组。OpenCV在`Mat`类中包含一个名为`data()`的函数，它提供对数据的直接指针。'
- en: '`width`: This is the image width.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`: 这是图像宽度。'
- en: '`height`: This is the image height.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`: 这是图像高度。'
- en: '`bytes_per_pixel`: This is the number of bytes per pixel. We use `1`, since
    we are dealing with a binary image. If you want to allow the code to be more generic,
    you can also use the `Mat::elemSize()` function that provides the same information.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes_per_pixel`: 这是每像素的字节数。我们使用`1`，因为我们处理的是二进制图像。如果您想允许代码更通用，您还可以使用`Mat::elemSize()`函数，它提供相同的信息。'
- en: '`bytes_per_line`: This is the number of bytes in a single line. We use the
    `Mat::step` property since some images add trailing bytes.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes_per_line`: 这是指单行中的字节数。我们使用`Mat::step`属性，因为有些图像会添加尾随字节。'
- en: Then, we call `GetUTF8Text` to run the recognition itself. The recognized text
    is returned, encoded with UTF8 without BOM (byte order mark). Before we return
    it, we also print some debug information.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`GetUTF8Text`来运行识别本身。识别的文本返回，以UTF8编码，不带BOM（字节顺序标记）。在我们返回之前，我们还打印了一些调试信息。
- en: 'The `MeanTextConf` returns a confidence index, which can be a number from `0`
    to `100`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeanTextConf`返回一个置信度指数，可以是`0`到`100`之间的数字：'
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sending the output to a file
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将输出发送到文件
- en: 'Let''s change our `main` method to send the recognized output to a file. We
    do this using a standard `ofstream`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的`main`方法更改为将识别的输出发送到文件。我们使用标准的`ofstream`来完成此操作：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice the following line:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下行：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This opens the file in binary mode. This is important since Tesseract returns
    a text encoded in UTF-8, taking into account the special characters available
    in Unicode. We also write the output directly using the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以二进制模式打开文件。这很重要，因为Tesseract返回的文本是以UTF-8编码的，考虑到Unicode中可用的特殊字符。我们还将输出直接使用以下命令写入：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this sample, we called `identify` using Portuguese as the input language
    (this is the language in which the ticket was written). You can use another photo,
    if you like.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用葡萄牙语作为输入语言调用了 `identify`（这是票据所写的语言）。如果你喜欢，可以使用另一张照片。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete source file is provided in the `segmentOcr.cpp` file, which comes
    along with this book.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码文件包含在 `segmentOcr.cpp` 文件中，该文件与本书一同提供。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`ticket.png` is a low resolution image, since we imagined that you would want
    to display a window with the image while studying this code. For this image, Tesseract
    results are rather poor. If you want to test it with a higher resolution image,
    the code is provided with a `ticketHigh.png` image. To test this image, change
    the dilation repetitions to 12 and the minimum box size from 20 to 60\. You''ll
    get a much higher confidence rate (about 87%) and the resulting text will be fully
    readable. The `segmentOcrHigh.cpp` file contains these modifications.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ticket.png` 是一个低分辨率的图片，因为我们想象你可能希望在研究这段代码的同时显示包含该图片的窗口。对于这张图片，Tesseract 的识别结果相当差。如果你想用更高分辨率的图片进行测试，代码中提供了一个
    `ticketHigh.png` 图片。要测试这张图片，将膨胀重复次数改为 12，并将最小框大小从 20 改为 60。你将获得更高的置信率（大约 87%），并且生成的文本将完全可读。`segmentOcrHigh.cpp`
    文件包含了这些修改。'
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we presented a brief introduction to OCR applications. We saw
    that the preprocessing phase of such systems must be adjusted according to the
    type of documents that we are planning to identify. We learned the common operations
    while preprocessing text files, such as thresholding, cropping, skewing, and text
    region segmentation. Finally, we learned how to install and use Tesseract OCR
    to convert our image to text.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了 OCR 应用。我们了解到，这类系统的预处理阶段必须根据我们计划识别的文档类型进行调整。我们学习了预处理文本文件时的常见操作，例如阈值化、裁剪、倾斜和文本区域分割。最后，我们学习了如何安装和使用
    Tesseract OCR 将我们的图片转换为文本。
- en: In the next chapter, we'll use a more sophisticated OCR technique to identify
    text in a casually taken picture or video—a situation known as scene text recognition.
    This is a much more complex scenario, since the text can be anywhere, in any font,
    and with different illuminations and orientations. There can be no text at all!
    We'll also learn how to use the OpenCV 3.0 text contribution module, which is
    fully integrated with Tesseract.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用更复杂的 OCR 技术来识别随意拍摄的图片或视频中的文本——这种情况被称为场景文本识别。这是一个更加复杂的场景，因为文本可能出现在任何地方，使用任何字体，并且具有不同的照明和方向。甚至可能完全没有文本！我们还将学习如何使用与
    Tesseract 完全集成的 OpenCV 3.0 文本贡献模块。
