- en: Chapter 8. Finding Patterns – Market Basket Analysis Using Association Rules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：发现模式—使用关联规则进行市场篮子分析
- en: Think back to the last time you made an impulse purchase. Maybe you were waiting
    in the grocery store checkout lane and bought a pack of chewing gum or a candy
    bar. Perhaps on a late-night trip for diapers and formula you picked up a caffeinated
    beverage or a six-pack of beer. You might have even bought this book on a whim
    on a bookseller's recommendation. These impulse buys are no coincidence, as retailers
    use sophisticated data analysis techniques to identify patterns that will drive
    retail behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你上一次冲动购买的经历。也许你在超市结账时买了一包口香糖或一块巧克力棒。也许你在深夜去买尿布和奶粉时顺便拿了一瓶含咖啡因的饮料或一六瓶啤酒。你可能甚至是在书店推荐下冲动地买了这本书。这些冲动购买可不是偶然的，零售商通过使用复杂的数据分析技术来识别那些能够驱动零售行为的模式。
- en: In years past, such recommendation systems were based on the subjective intuition
    of marketing professionals and inventory managers or buyers. More recently, as
    barcode scanners, computerized inventory systems, and online shopping trends have
    built a wealth of transactional data, machine learning has been increasingly applied
    to learn purchasing patterns. The practice is commonly known as **market basket
    analysis** due to the fact that it has been so frequently applied to supermarket
    data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，这种推荐系统主要依赖于营销专业人员和库存经理或采购员的主观直觉。近年来，随着条形码扫描仪、计算机化库存系统和在线购物趋势积累了大量的交易数据，机器学习被越来越多地应用于学习购买模式。由于这种技术经常应用于超市数据，因此这一实践通常被称为**市场篮子分析**。
- en: 'Although the technique originated with shopping data, it is useful in other
    contexts as well. By the time you finish this chapter, you will be able to apply
    market basket analysis techniques to your own tasks, whatever they may be. Generally,
    the work involves:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该技术起源于购物数据，但它在其他背景下也同样有用。当你读完这一章时，你将能够将市场篮子分析技术应用到你自己的任务中，无论这些任务是什么。一般而言，这项工作包括：
- en: Using simple performance measures to find associations in large databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的性能指标在大型数据库中寻找关联
- en: Understanding the peculiarities of transactional data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解交易数据的特殊性
- en: Knowing how to identify the useful and actionable patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道如何识别有用且可操作的模式
- en: The results of a market basket analysis are actionable patterns. Thus, as we
    apply the technique, you are likely to identify applications to your work, even
    if you have no affiliation with a retail chain.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 市场篮子分析的结果是可操作的模式。因此，当我们应用这项技术时，即使你与零售链没有任何关联，也很可能会识别出对你的工作有用的应用。
- en: Understanding association rules
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解关联规则
- en: 'The building blocks of a market basket analysis are the items that may appear
    in any given transaction. Groups of one or more items are surrounded by brackets
    to indicate that they form a set, or more specifically, an **itemset** that appears
    in the data with some regularity. Transactions are specified in terms of itemsets,
    such as the following transaction that might be found in a typical grocery store:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 市场篮子分析的基本构件是可能出现在任何给定交易中的商品。一个或多个商品组成的组被括号括起来，表示它们形成了一个集合，或者更具体地说，是一个在数据中有规律出现的**项集**。交易是通过项集来指定的，例如在典型的杂货店中可能找到的以下交易：
- en: '![Understanding association rules](img/B03905_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![理解关联规则](img/B03905_08_01.jpg)'
- en: 'The result of a market basket analysis is a collection of **association rules**
    that specify patterns found in the relationships among items he itemsets. Association
    rules are always composed from subsets of itemsets and are denoted by relating
    one itemset on the left-hand side (LHS) of the rule to another itemset on the
    right-hand side (RHS) of the rule. The LHS is the condition that needs to be met
    in order to trigger the rule, and the RHS is the expected result of meeting that
    condition. A rule identified from the example transaction might be expressed in
    the form:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 市场篮子分析的结果是一组**关联规则**，这些规则指定了在商品项集之间的关系中发现的模式。关联规则总是由项集的子集组成，并通过将规则的左侧（LHS）中的一个项集与右侧（RHS）中的另一个项集联系起来来表示。LHS是需要满足的条件，以触发规则，而RHS是满足该条件后预期的结果。一个从示例交易中识别出的规则可以表示为：
- en: '![Understanding association rules](img/B03905_08_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![理解关联规则](img/B03905_08_02.jpg)'
- en: In plain language, this association rule states that if peanut butter and jelly
    are purchased together, then bread is also likely to be purchased. In other words,
    "peanut butter and jelly imply bread."
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话来说，这个关联规则表示，如果花生酱和果冻一起购买，那么面包也很可能会被购买。换句话说，“花生酱和果冻意味着面包。”
- en: Developed in the context of retail transaction databases, association rules
    are not used for prediction, but rather for unsupervised knowledge discovery in
    large databases. This is unlike the classification and numeric prediction algorithms
    presented in previous chapters. Even so, you will find that association rule learners
    are closely related to and share many features of the classification rule learners
    presented in [Chapter 5](ch05.html "Chapter 5. Divide and Conquer – Classification
    Using Decision Trees and Rules"), *Divide and Conquer – Classification Using Decision
    Trees and Rules*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在零售交易数据库的背景下，关联规则不是用来进行预测，而是用于在大型数据库中进行无监督的知识发现。这与前几章介绍的分类和数值预测算法不同。尽管如此，你会发现关联规则学习器与[第5章](ch05.html
    "第5章。分而治之——使用决策树和规则进行分类")中的分类规则学习器紧密相关，并共享许多相同的特征，*分而治之——使用决策树和规则进行分类*。
- en: Because association rule learners are unsupervised, there is no need for the
    algorithm to be trained; data does not need to be labeled ahead of time. The program
    is simply unleashed on a dataset in the hope that interesting associations are
    found. The downside, of course, is that there isn't an easy way to objectively
    measure the performance of a rule learner, aside from evaluating them for qualitative
    usefulness—typically, an eyeball test of some sort.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关联规则学习器是无监督的，因此算法无需进行训练；数据无需提前标注。程序只是被释放到数据集上，希望能够发现有趣的关联。当然，缺点是，除了通过定性有用性评估规则学习器外，没有简单的方法来客观衡量其性能——通常需要某种形式的人工检查。
- en: 'Although association rules are most often used for market basket analysis,
    they are helpful for finding patterns in many different types of data. Other potential
    applications include:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关联规则最常用于市场篮分析，但它们在发现多种不同类型数据的模式中也很有帮助。其他潜在应用包括：
- en: Searching for interesting and frequently occurring patterns of DNA and protein
    sequences in cancer data
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在癌症数据中搜索有趣且频繁出现的DNA和蛋白质序列模式
- en: Finding patterns of purchases or medical claims that occur in combination with
    fraudulent credit card or insurance use
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找与信用卡或保险欺诈使用相关联的购买模式或医疗索赔模式
- en: Identifying combinations of behavior that precede customers dropping their cellular
    phone service or upgrading their cable television package
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别导致客户取消手机服务或升级有线电视套餐的行为组合
- en: Association rule analysis is used to search for interesting connections among
    a very large number of elements. Human beings are capable of such insight quite
    intuitively, but it often takes expert-level knowledge or a great deal of experience
    to do what a rule learning algorithm can do in minutes or even seconds. Additionally,
    some datasets are simply too large and complex for a human being to find the needle
    in the haystack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则分析用于在大量元素中搜索有趣的关联。人类能够凭直觉进行这样的洞察，但通常需要专家级的知识或大量经验，才能完成规则学习算法在几分钟甚至几秒钟内就能完成的任务。此外，一些数据集对于人类来说过于庞大和复杂，难以从中找到“针尖”。
- en: The Apriori algorithm for association rule learning
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联规则学习的Apriori算法
- en: Just as it is challenging for humans, transactional data makes association rule
    mining a challenging task for machines as well. Transactional datasets are typically
    extremely large, both in terms of the number of transactions as well as the number
    of items or features that are monitored. The problem is that the number of potential
    itemsets grows exponentially with the number of features. Given *k* items that
    can appear or not appear in a set, there are *2^k* possible itemsets that could
    be potential rules. A retailer that sells only 100 different items could have
    on the order of *2^100 = 1.27e+30* itemsets that an algorithm must evaluate—a
    seemingly impossible task.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如人类感到具有挑战性一样，交易数据使得关联规则挖掘对于机器来说也是一项挑战。交易数据集通常非常庞大，无论是交易数量还是监控的商品或特征数量都很庞大。问题在于，潜在项集的数量随着特征数量的增加呈指数级增长。假设有*k*个商品可能会出现在集合中或不出现在集合中，那么有*2^k*个潜在的项集可能成为规则。一个只卖100种商品的零售商，可能需要评估大约*2^100
    = 1.27e+30*个项集——这看似是不可能完成的任务。
- en: Rather than evaluating each of these itemsets one by one, a smarter rule learning
    algorithm takes advantage of the fact that, in reality, many of the potential
    combinations of items are rarely, if ever, found in practice. For instance, even
    if a store sells both automotive items and women's cosmetics, a set of *{motor
    oil, lipstick}* is likely to be extraordinarily uncommon. By ignoring these rare
    (and, perhaps, less important) combinations, it is possible to limit the scope
    of the search for rules to a more manageable size.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与其逐一评估这些项集，不如利用更智能的规则学习算法，利用许多潜在的商品组合在实践中很少出现这一事实。例如，即使商店同时出售汽车配件和女性化妆品，*{机油,
    口红}*这种组合也可能极其不常见。通过忽略这些稀有（而且可能不太重要）组合，可以将规则搜索的范围限制到一个更易管理的大小。
- en: Much work has been done to identify heuristic algorithms for reducing the number
    of itemsets to search. Perhaps the most-widely used approach for efficiently searching
    large databases for rules is known as **Apriori**. Introduced in 1994 by Rakesh
    Agrawal and Ramakrishnan Srikant, the Apriori algorithm has since become somewhat
    synonymous with association rule learning. The name is derived from the fact that
    the algorithm utilizes a simple prior (that is, *a priori*) belief about the properties
    of frequent itemsets.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 已经做了大量工作来识别启发式算法，以减少需要搜索的项集数量。也许最广泛使用的高效搜索大数据库中规则的方法是**Apriori**算法。该算法由Rakesh
    Agrawal和Ramakrishnan Srikant于1994年提出，此后已成为关联规则学习的代名词。其名称来源于该算法利用一种简单的先验信念（即*a
    priori*）关于频繁项集的属性。
- en: 'Before we discuss that in more depth, it''s worth noting that this algorithm,
    like all learning algorithms, is not without its strengths and weaknesses. Some
    of these are listed as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论之前，值得注意的是，这种算法与所有学习算法一样，并非没有优缺点。以下是其中的一些优缺点：
- en: '| Strengths | Weaknesses |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 优势 | 劣势 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Is capable of working with large amounts of transactional data
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理大量的交易数据
- en: Results in rules that are easy to understand
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生易于理解的规则
- en: Useful for "data mining" and discovering unexpected knowledge in databases
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于“数据挖掘”和发现数据库中的意外知识
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Not very helpful for small datasets
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于小型数据集不太有用
- en: Requires effort to separate the true insight from common sense
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要努力将真正的洞察力与常识区分开
- en: Easy to draw spurious conclusions from random patterns
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易从随机模式中得出虚假的结论
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'As noted earlier, the Apriori algorithm employs a simple *a priori* belief
    to reduce the association rule search space: all subsets of a frequent itemset
    must also be frequent. This heuristic is known as the **Apriori property**. Using
    this astute observation, it is possible to dramatically limit the number of rules
    to be searched. For example, the set *{motor oil, lipstick}* can only be frequent
    if both *{motor oil}* and *{lipstick}* occur frequently as well. Consequently,
    if either motor oil or lipstick is infrequent, any set containing these items
    can be excluded from the search.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Apriori算法通过简单的*a priori*信念来减少关联规则搜索空间：频繁项集的所有子集也必须是频繁的。这一启发式方法被称为**Apriori属性**。利用这一精明的观察，我们可以大幅限制需要搜索的规则数量。例如，*{机油,
    口红}*集只有在*{机油}*和*{口红}*都频繁出现时，才能是频繁的。因此，如果机油或口红出现频率较低，那么包含这些物品的任何集合都可以从搜索中排除。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For additional details on the Apriori algorithm, refer to: Agrawal R, Srikant
    R. Fast algorithms for mining association rules. *Proceedings of the 20th International
    Conference on Very Large Databases*. 1994:487-499.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解Apriori算法的更多细节，请参阅：Agrawal R, Srikant R. 快速挖掘关联规则的算法。*第20届国际大型数据库会议论文集*，1994:487-499。
- en: 'To see how this principle can be applied in a more realistic setting, let''s
    consider a simple transaction database. The following table shows five completed
    transactions in an imaginary hospital''s gift shop:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这一原则如何应用于更现实的场景，让我们考虑一个简单的交易数据库。下表显示了一个假想医院礼品店的五笔已完成交易：
- en: '| Transaction number | Purchased items |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 交易编号 | 购买的物品 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | *{flowers, get well card, soda}* |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *{花, 康复卡片, 苏打水}* |'
- en: '| 2 | *{plush toy bear, flowers, balloons, candy bar}* |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *{毛绒玩具熊, 花, 气球, 巧克力棒}* |'
- en: '| 3 | *{get well card, candy bar, flowers}* |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *{康复卡片, 巧克力棒, 花}* |'
- en: '| 4 | *{plush toy bear, balloons, soda}* |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *{毛绒玩具熊, 气球, 苏打水}* |'
- en: '| 5 | *{flowers, get well card, soda}* |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *{花, 康复卡片, 苏打水}* |'
- en: By looking at the sets of purchases, one can infer that there are a couple of
    typical buying patterns. A person visiting a sick friend or family member tends
    to buy a get well card and flowers, while visitors to new mothers tend to buy
    plush toy bears and balloons. Such patterns are notable because they appear frequently
    enough to catch our interest; we simply apply a bit of logic and subject matter
    experience to explain the rule.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看购买集，可以推断出一些典型的购买模式。拜访生病的朋友或家人时，人们往往会购买一张祝早日康复的卡片和鲜花，而拜访新妈妈的人则倾向于购买毛绒玩具熊和气球。这些模式之所以引人注目，是因为它们频繁出现，足以引起我们的兴趣；我们只需运用一些逻辑和专业经验来解释这些规则。
- en: In a similar fashion, the Apriori algorithm uses statistical measures of an
    itemset's "interestingness" to locate association rules in much larger transaction
    databases. In the sections that follow, we will discover how Apriori computes
    such measures of interest and how they are combined with the Apriori property
    to reduce the number of rules to be learned.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Apriori 算法通过使用项集“有趣性”的统计度量来定位更大事务数据库中的关联规则。在接下来的章节中，我们将探讨 Apriori 如何计算这些有趣性的度量，以及如何将它们与
    Apriori 属性结合起来，以减少需要学习的规则数量。
- en: Measuring rule interest – support and confidence
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 衡量规则兴趣 – 支持度与置信度
- en: 'Whether or not an association rule is deemed interesting is determined by two
    statistical measures: support and confidence measures. By providing minimum thresholds
    for each of these metrics and applying the Apriori principle, it is easy to drastically
    limit the number of rules reported, perhaps even to the point where only the obvious
    or common sense rules are identified. For this reason, it is important to carefully
    understand the types of rules that are excluded under these criteria.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 是否将某个关联规则视为有趣，取决于两个统计度量：支持度和置信度。通过为每个度量提供最小阈值，并应用 Apriori 原则，可以轻松地大幅度限制报告的规则数量，甚至可能只识别出显而易见或常识性的规则。因此，重要的是要仔细理解在这些标准下被排除的规则类型。
- en: 'The **support** of an itemset or rule measures how frequently it occurs in
    the data. For instance the itemset *{get well card, flowers}*, has support of
    *3 / 5 = 0.6* in the hospital gift shop data. Similarly, the support for *{get
    well card} → {flowers}* is also 0.6\. The support can be calculated for any itemset
    or even a single item; for instance, the support for *{candy bar}* is *2 / 5 =
    0.4*, since candy bars appear in 40 percent of purchases. A function defining
    support for the itemset *X* can be defined as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 项集或规则的**支持度**衡量它在数据中出现的频率。例如，项集 *{祝早日康复的卡片，鲜花}* 在医院礼品店数据中的支持度为 *3 / 5 = 0.6*。类似地，*{祝早日康复的卡片}
    → {鲜花}* 的支持度也是 0.6。支持度可以计算任何项集，甚至是单一项；例如，*{糖果棒}* 的支持度为 *2 / 5 = 0.4*，因为糖果棒出现在
    40% 的购买中。定义项集 *X* 的支持度的函数可以如下定义：
- en: '![Measuring rule interest – support and confidence](img/B03905_08_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![衡量规则兴趣 – 支持度与置信度](img/B03905_08_03.jpg)'
- en: Here, *N* is the number of transactions in the database and *count(X)* is the
    number of transactions containing itemset *X*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*N* 是数据库中事务的数量，而 *count(X)* 是包含项集 *X* 的事务数量。
- en: 'A rule''s **confidence** is a measurement of its predictive power or accuracy.
    It is defined as the support of the itemset containing both *X* and *Y* divided
    by the support of the itemset containing only *X*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一条规则的**置信度**是其预测能力或准确度的度量。它被定义为包含 *X* 和 *Y* 的项集的支持度除以仅包含 *X* 的项集的支持度：
- en: '![Measuring rule interest – support and confidence](img/B03905_08_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![衡量规则兴趣 – 支持度与置信度](img/B03905_08_04.jpg)'
- en: Essentially, the confidence tells us the proportion of transactions where the
    presence of item or itemset *X* results in the presence of item or itemset *Y*.
    Keep in mind that the confidence that *X* leads to *Y* is not the same as the
    confidence that *Y* leads to *X*. For example, the confidence of *{flowers} →
    {get well card}* is *0.6 / 0.8 = 0.75*. In comparison, the confidence of *{get
    well card} → {flowers}* is *0.6 / 0.6 = 1.0*. This means that a purchase involving
    flowers is accompanied by a purchase of a get well card 75 percent of the time,
    while a purchase of a get well card is associated with flowers 100 percent of
    the time. This information could be quite useful to the gift shop management.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，置信度告诉我们，在多少比例的交易中，物品或项集 *X* 的存在导致了物品或项集 *Y* 的存在。记住，*X* 导致 *Y* 的置信度和 *Y*
    导致 *X* 的置信度是不同的。例如，*{鲜花} → {祝贺卡}* 的置信度是 *0.6 / 0.8 = 0.75*。相比之下，*{祝贺卡} → {鲜花}*
    的置信度是 *0.6 / 0.6 = 1.0*。这意味着购买鲜花的交易有 75% 的可能性会同时购买祝贺卡，而购买祝贺卡的交易则有 100% 的可能性会购买鲜花。这些信息对于礼品店管理层非常有用。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may have noticed similarities between support, confidence, and the Bayesian
    probability rules covered in [Chapter 4](ch04.html "Chapter 4. Probabilistic Learning
    – Classification Using Naive Bayes"), *Probabilistic Learning – Classification
    Using Naive Bayes*. In fact, *support(A, B)* is the same as *P(A∩B)* and *confidence(A
    → B)* is the same as *P(B|A)*. It is just the context that differs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到支持度、置信度和贝叶斯概率规则之间的相似性，这些内容在[第4章](ch04.html "第4章 概率学习——使用朴素贝叶斯分类")，*概率学习——使用朴素贝叶斯分类*中有提到。事实上，*support(A,
    B)* 就是 *P(A∩B)*，而 *confidence(A → B)* 就是 *P(B|A)*。只是上下文不同。
- en: Rules like *{get well card} → {flowers}* are known as **strong rules**, because
    they have both high support and confidence. One way to find more strong rules
    would be to examine every possible combination of the items in the gift shop,
    measure the support and confidence value, and report back only those rules that
    meet certain levels of interest. However, as noted before, this strategy is generally
    not feasible for anything but the smallest of datasets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 *{祝贺卡} → {鲜花}* 的规则被称为**强规则**，因为它们具有较高的支持度和置信度。找到更多强规则的一种方法是检查礼品店中每一对物品的所有可能组合，衡量支持度和置信度的值，然后仅报告那些符合特定兴趣水平的规则。然而，如前所述，这种策略通常只适用于最小的数据集。
- en: In the next section, you will see how the Apriori algorithm uses the minimum
    levels of support and confidence with the Apriori principle to find strong rules
    quickly by reducing the number of rules to a more manageable level.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，你将看到 Apriori 算法如何利用最小支持度和置信度水平，并结合 Apriori 原则，通过减少规则数量到一个更易管理的水平，快速找到强规则。
- en: Building a set of rules with the Apriori principle
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apriori 原则构建规则集
- en: Recall that the Apriori principle states that all subsets of a frequent itemset
    must also be frequent. In other words, if *{A, B}* is frequent, then *{A}* and
    *{B}* must both be frequent. Recall also that by definition, the support indicates
    how frequently an itemset appears in the data. Therefore, if we know that *{A}*
    does not meet a desired support threshold, there is no reason to consider *{A,
    B}* or any itemset containing *{A}*; it cannot possibly be frequent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下，Apriori 原则指出，频繁项集的所有子集也必须是频繁的。换句话说，如果 *{A, B}* 是频繁的，那么 *{A}* 和 *{B}* 都必须是频繁的。还要记住，根据定义，支持度表示项集在数据中出现的频率。因此，如果我们知道
    *{A}* 未达到所需的支持度阈值，那么就没有理由考虑 *{A, B}* 或任何包含 *{A}* 的项集；它不可能是频繁的。
- en: 'The Apriori algorithm uses this logic to exclude potential association rules
    prior to actually evaluating them. The actual process of creating rules occurs
    in two phases:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Apriori 算法利用这种逻辑，在实际评估潜在的关联规则之前，先排除不可能的规则。创建规则的实际过程分为两个阶段：
- en: Identifying all the itemsets that meet a minimum support threshold.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定所有满足最小支持度阈值的项集。
- en: Creating rules from these itemsets using those meeting a minimum confidence
    threshold.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用满足最小置信度阈值的项集来创建规则。
- en: The first phase occurs in multiple iterations. Each successive iteration involves
    evaluating the support of a set of increasingly large itemsets. For instance,
    iteration 1 involves evaluating the set of 1-item itemsets (1-itemsets), iteration
    2 evaluates 2-itemsets, and so on. The result of each iteration *i* is a set of
    all the *i*-itemsets that meet the minimum support threshold.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段在多个迭代中进行。每次迭代都涉及评估一组越来越大的项集的支持度。例如，第一次迭代评估1项项集（1-itemsets），第二次迭代评估2项项集，以此类推。每次迭代*i*的结果是满足最低支持度阈值的所有*i*-项集的集合。
- en: All the itemsets from iteration *i* are combined in order to generate candidate
    itemsets for the evaluation in iteration *i + 1*. But the Apriori principle can
    eliminate some of them even before the next round begins. If *{A}*, *{B}*, and
    *{C}* are frequent in iteration 1 while *{D}* is not frequent, iteration 2 will
    consider only *{A, B}*, *{A, C}*, and *{B, C}*. Thus, the algorithm needs to evaluate
    only three itemsets rather than the six that would have been evaluated if the
    sets containing *D* had not been eliminated *a priori*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第*i*次迭代中的所有项集将被合并，以生成第*i + 1*次迭代的候选项集进行评估。但是，Apriori原理甚至可以在下一轮开始之前就排除其中的一些项集。如果在第一次迭代中*{A}*、*{B}*和*{C}*是频繁项集，而*{D}*不是，那么第二次迭代将只考虑*{A,
    B}*、*{A, C}*和*{B, C}*。因此，算法只需要评估三个项集，而不是评估包含*D*的六个项集，如果没有通过*先验*排除这些项集的话。
- en: Continuing with this thought, suppose during iteration 2, it is discovered that
    *{A, B}* and *{B, C}* are frequent, but *{A, C}* is not. Although iteration 3
    would normally begin by evaluating the support for *{A, B, C}*, it is not mandatory
    that this step should occur at all. Why not? The Apriori principle states that
    *{A, B, C}* cannot possibly be frequent, since the subset *{A, C}* is not. Therefore,
    having generated no new itemsets in iteration 3, the algorithm may stop.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个思路，假设在第二次迭代中，发现*{A, B}*和*{B, C}*是频繁项集，但*{A, C}*不是。尽管第三次迭代通常会通过评估*{A, B,
    C}*的支持度来开始，但并不强制要求这一步一定发生。为什么不呢？Apriori原理指出，由于子集*{A, C}*不是频繁的，*{A, B, C}*不可能是频繁项集。因此，在第三次迭代中没有生成新的项集，算法可能会停止。
- en: At this point, the second phase of the Apriori algorithm may begin. Given the
    set of frequent itemsets, association rules are generated from all possible subsets.
    For instance, *{A, B}* would result in candidate rules for *{A} → {B}* and *{B}
    → {A}*. These are evaluated against a minimum confidence threshold, and any rule
    that does not meet the desired confidence level is eliminated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Apriori算法的第二阶段可以开始。给定频繁项集的集合，从所有可能的子集生成关联规则。例如，*{A, B}*将生成*{A} → {B}*和*{B}
    → {A}*的候选规则。这些规则将根据最低置信度阈值进行评估，任何不满足所需置信度水平的规则都会被淘汰。
- en: Example – identifying frequently purchased groceries with association rules
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 – 使用关联规则识别常购商品
- en: As noted in this chapter's introduction, market basket analysis is used behind
    the scenes for the recommendation systems used in many brick-and-mortar and online
    retailers. The learned association rules indicate the combinations of items that
    are often purchased together. Knowledge of these patterns provides insight into
    new ways a grocery chain might optimize the inventory, advertise promotions, or
    organize the physical layout of the store. For instance, if shoppers frequently
    purchase coffee or orange juice with a breakfast pastry, it may be possible to
    increase profit by relocating pastries closer to coffee and juice.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章介绍所述，市场篮子分析在许多实体店和在线零售商的推荐系统背后默默发挥着作用。通过学习得到的关联规则能够指示出经常一起购买的商品组合。了解这些模式为杂货连锁店提供了新的洞察力，帮助优化库存、进行促销广告或组织商店的物理布局。例如，如果顾客经常购买咖啡或橙汁与早餐点心一起食用，那么通过将点心移近咖啡和橙汁的位置，可能会提高利润。
- en: In this tutorial, we will perform a market basket analysis of transactional
    data from a grocery store. However, the techniques could be applied to many different
    types of problems, from movie recommendations, to dating sites, to finding dangerous
    interactions among medications. In doing so, we will see how the Apriori algorithm
    is able to efficiently evaluate a potentially massive set of association rules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将对来自一家杂货店的交易数据进行市场篮子分析。然而，这些技术可以应用于许多不同类型的问题，从电影推荐到约会网站，再到寻找药物之间的危险相互作用。在这个过程中，我们将看到Apriori算法如何高效地评估一个潜在的庞大的关联规则集。
- en: Step 1 – collecting data
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步 – 收集数据
- en: Our market basket analysis will utilize the purchase data collected from one
    month of operation at a real-world grocery store. The data contains 9,835 transactions
    or about 327 transactions per day (roughly 30 transactions per hour in a 12-hour
    business day), suggesting that the retailer is not particularly large, nor is
    it particularly small.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的市场篮分析将利用来自一家现实世界杂货店运营一个月的购买数据。数据包含9,835笔交易，约合每天327笔交易（在一个12小时的营业日中大约30笔交易），表明该零售商规模既不特别大，也不特别小。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The dataset used here was adapted from the `Groceries` dataset in the `arules`
    R package. For more information, see: Hahsler M, Hornik K, Reutterer T. Implications
    of probabilistic data modeling for mining association rules. In: Gaul W, Vichi
    M, Weihs C, ed. *Studies in Classification, Data Analysis, and Knowledge Organization:
    from Data and Information Analysis to Knowledge Engineering*. New York: Springer;
    2006:598–605.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的数据集改编自`arules` R包中的`Groceries`数据集。有关更多信息，请参见：Hahsler M, Hornik K, Reutterer
    T. 概率数据建模对挖掘关联规则的影响。载：Gaul W, Vichi M, Weihs C, ed. *分类学、数据分析与知识组织研究：从数据与信息分析到知识工程*。纽约：Springer;
    2006:598–605。
- en: The typical grocery store offers a huge variety of items. There might be five
    brands of milk, a dozen different types of laundry detergent, and three brands
    of coffee. Given the moderate size of the retailer, we will assume that they are
    not terribly concerned with finding rules that apply only to a specific brand
    of milk or detergent. With this in mind, all brand names can be removed from the
    purchases. This reduces the number of groceries to a more manageable 169 types,
    using broad categories such as chicken, frozen meals, margarine, and soda.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的杂货店提供种类繁多的商品。可能会有五种不同品牌的牛奶、十几种不同类型的洗衣粉和三种品牌的咖啡。鉴于零售商的规模适中，我们假设他们并不太关心寻找只适用于某一特定品牌牛奶或洗衣粉的规则。考虑到这一点，可以从购买数据中去除所有品牌名称。这样，商品种类减少为169种，更易于管理，涵盖了鸡肉、冷冻餐、玛琪琳和苏打水等广泛类别。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you hope to identify highly specific association rules—such as whether customers
    prefer grape or strawberry jelly with their peanut butter—you will need a tremendous
    amount of transactional data. Large chain retailers use databases of many millions
    of transactions in order to find associations among particular brands, colors,
    or flavors of items.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望识别非常具体的关联规则——例如，客户是否喜欢将葡萄酒或草莓果酱与花生酱搭配——你将需要大量的事务数据。大型连锁零售商使用数百万笔交易的数据库来发现特定品牌、颜色或口味的物品之间的关联。
- en: Do you have any guesses about which types of items might be purchased together?
    Will wine and cheese be a common pairing? Bread and butter? Tea and honey? Let's
    dig into this data and see whether we can confirm our guesses.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你有什么猜测关于哪些类型的物品可能会一起购买吗？葡萄酒和奶酪会是常见的搭配吗？面包和黄油？茶和蜂蜜？让我们深入分析这些数据，看看是否能确认我们的猜测。
- en: Step 2 – exploring and preparing the data
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步——探索与准备数据
- en: Transactional data is stored in a slightly different format than that we used
    previously. Most of our prior analyses utilized data in the matrix form where
    rows indicated example instances and columns indicated features. Given the structure
    of the matrix format, all examples are required to have exactly the same set of
    features.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事务数据以与我们之前使用的格式略有不同的方式存储。我们以前的大多数分析使用的是矩阵形式的数据，其中行表示示例实例，列表示特征。由于矩阵格式的结构，所有示例都必须具有完全相同的特征集。
- en: In comparison, transactional data is a more free form. As usual, each row in
    the data specifies a single example—in this case, a transaction. However, rather
    than having a set number of features, each record comprises a comma-separated
    list of any number of items, from one to many. In essence, the features may differ
    from example to example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，事务数据的形式更加自由。像往常一样，数据中的每一行表示一个单独的示例——在这种情况下，是一次交易。然而，与其有固定数量的特征，每条记录由一个用逗号分隔的物品列表组成，数量从一个到多个不等。实质上，特征可能会因示例而异。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To follow along with this analysis, download the `groceries.csv` file from the
    Packt Publishing website and save it in your R working directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本次分析，请从Packt Publishing网站下载`groceries.csv`文件，并将其保存在你的R工作目录中。
- en: 'The first five rows of the raw `grocery.csv` file are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`grocery.csv` 文件的前五行如下：'
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These lines indicate five separate grocery store transactions. The first transaction
    included four items: citrus fruit, semi-finished bread, margarine, and ready soups.
    In comparison, the third transaction included only one item: whole milk.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行表示五个独立的杂货店交易。第一次交易包含了四个项目：柑橘类水果、半成品面包、玛格丽琳和即食汤。相比之下，第三次交易仅包含一个项目：全脂牛奶。
- en: 'Suppose we try to load the data using the `read.csv()` function as we did in
    the prior analyses. R would happily comply and read the data into a matrix form
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们像之前的分析那样，尝试使用 `read.csv()` 函数加载数据。R 会欣然执行，并将数据读取成如下的矩阵形式：
- en: '![Step 2 – exploring and preparing the data](img/B03905_08_05.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 2 – 探索和准备数据](img/B03905_08_05.jpg)'
- en: 'You will notice that R created four columns to store the items in the transactional
    data: `V1`, `V2`, `V3`, and `V4`. Although this may seem reasonable this, if we
    use the data in this form, we will encounter problems later may seem reasonable,
    R chose to create four variables because the first line had exactly four comma-separated
    values. However, we know that grocery purchases can contain more than four items;
    in the four column design such transactions will be broken across multiple rows
    in the matrix. We could try to remedy this by putting the transaction with the
    largest number of items at the top of the file, but this ignores another more
    problematic issue.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，R 创建了四列来存储事务数据中的项目：`V1`、`V2`、`V3` 和 `V4`。虽然这看起来合情合理，但如果我们使用这种格式的数据，后续会遇到问题。R
    选择创建四个变量是因为第一行恰好有四个用逗号分隔的值。然而，我们知道，杂货购买可能包含超过四个项目；在四列设计中，这样的交易会被拆分到矩阵中的多行。我们可以尝试通过将包含最多项目的交易放在文件的顶部来解决这个问题，但这忽略了另一个更为棘手的问题。
- en: By structuring data this way, R has constructed a set of features that record
    not just the items in the transactions, but also the order in which they appear.
    If we imagine our learning algorithm as an attempt to find a relationship among
    `V1`, `V2`, `V3`, and `V4`, then whole milk in `V1` might be treated differently
    than the whole milk appearing in `V2`. Instead, we need a dataset that does not
    treat a transaction as a set of positions to be filled (or not filled) with specific
    items, but rather as a market basket that either contains or does not contain
    each particular item.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式构建数据，R 创建了一组特征，不仅记录了交易中的商品，还记录了它们出现的顺序。如果我们把学习算法想象成是在尝试找出 `V1`、`V2`、`V3`
    和 `V4` 之间的关系，那么 `V1` 中的全脂牛奶可能会与 `V2` 中的全脂牛奶有所不同。相反，我们需要的是一个数据集，它不会把一笔交易视为一组需要填写（或不填写）特定商品的位置，而是将其视为一个市场购物篮，里面包含或不包含每一个特定商品。
- en: Data preparation – creating a sparse matrix for transaction data
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据准备 – 为事务数据创建稀疏矩阵
- en: The solution to this problem utilizes a data structure called a **sparse matrix**.
    You may recall that we used a sparse matrix to process text data in [Chapter 4](ch04.html
    "Chapter 4. Probabilistic Learning – Classification Using Naive Bayes"), *Probabilistic
    Learning – Classification Using Naive Bayes*. Just as with the preceding dataset,
    each row in the sparse matrix indicates a transaction. However, the sparse matrix
    has a column (that is, feature) for every item that could possibly appear in someone's
    shopping bag. Since there are 169 different items in our grocery store data, our
    sparse matrix will contain 169 columns.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用一种名为 **稀疏矩阵** 的数据结构。你可能还记得，我们在[第 4 章](ch04.html "第 4 章. 概率学习 – 使用朴素贝叶斯分类")中，*概率学习
    – 使用朴素贝叶斯分类*，使用了稀疏矩阵来处理文本数据。和前面的数据集一样，稀疏矩阵中的每一行表示一次交易。然而，稀疏矩阵为每个可能出现在某人购物袋中的商品提供了一个列（即特征）。由于我们的杂货店数据中有
    169 种不同的商品，所以我们的稀疏矩阵将包含 169 列。
- en: Why not just store this as a data frame as we did in most of our analyses? The
    reason is that as additional transactions and items are added, a conventional
    data structure quickly becomes too large to fit in the available memory. Even
    with the relatively small transactional dataset used here, the matrix contains
    nearly 1.7 million cells, most of which contain zeros (hence, the name "sparse"
    matrix—there are very few nonzero values). Since there is no benefit to storing
    all these zero values, a sparse matrix does not actually store the full matrix
    in memory; it only stores the cells that are occupied by an item. This allows
    the structure to be more memory efficient than an equivalently sized matrix or
    data frame.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接像我们在大多数分析中那样将其存储为数据框（data frame）呢？原因是随着更多的交易和商品被添加，传统的数据结构很快会变得太大，无法适应可用的内存。即使是这里使用的相对较小的交易数据集，矩阵也包含近170万个单元格，其中大多数是零（因此称为“稀疏”矩阵——非零值非常少）。由于存储所有这些零值没有任何意义，稀疏矩阵实际上并不会将整个矩阵存储在内存中；它只存储那些由项目占用的单元格。这使得该结构比同等大小的矩阵或数据框更节省内存。
- en: In order to create the sparse matrix data structure from the transactional data,
    we can use the functionality provided by the `arules` package. Install and load
    the package using the `install.packages("arules")` and `library(arules)` commands.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从交易数据中创建稀疏矩阵数据结构，我们可以使用`arules`包提供的功能。通过执行`install.packages("arules")`和`library(arules)`命令来安装和加载该包。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the arules package, refer to: Hahsler M, Gruen B, Hornik
    K. arules – a computational environment for mining association rules and frequent
    item sets. *Journal of Statistical Software. 2005; 14*.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多有关arules包的信息，请参考：Hahsler M, Gruen B, Hornik K. arules – a computational
    environment for mining association rules and frequent item sets. *Journal of Statistical
    Software. 2005; 14*。
- en: 'Since we''re loading the transactional data, we cannot simply use the `read.csv()`
    function used previously. Instead, `arules` provides a `read.transactions()` function
    that is similar to `read.csv()` with the exception that it results in a sparse
    matrix suitable for transactional data. The `sep = ","` parameter specifies that
    items in the input file are separated by a comma. To read the `groceries.csv`
    data into a sparse matrix named `groceries`, type the following line:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在加载交易数据，不能简单地使用之前的`read.csv()`函数。相反，`arules`提供了一个`read.transactions()`函数，类似于`read.csv()`，但其结果是适用于交易数据的稀疏矩阵。`sep
    = ","`参数指定输入文件中的项目由逗号分隔。要将`groceries.csv`数据读入名为`groceries`的稀疏矩阵，输入以下代码：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To see some basic information about the `groceries` matrix we just created,
    use the `summary()` function on the object:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们刚刚创建的`groceries`矩阵的基本信息，可以对该对象使用`summary()`函数：
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first block of information in the output (as shown previously) provides
    a summary of the sparse matrix we created. The output `9835 rows` refers to the
    number of transactions, and the output `169 columns` refers to the 169 different
    items that might appear in someone's grocery basket. Each cell in the matrix is
    `1` if the item was purchased for the corresponding transaction, or `0` otherwise.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的第一部分信息（如前所示）提供了我们创建的稀疏矩阵的摘要。输出中的`9835 rows`表示交易的数量，`169 columns`表示可能出现在购物篮中的169个不同商品。矩阵中的每个单元格，如果相应的交易中购买了该商品，则为`1`，否则为`0`。
- en: The **density** value of `0.02609146` (2.6 percent) refers to the proportion
    of nonzero matrix cells. Since there are *9,835 * 169 = 1,662,115* positions in
    the matrix, we can calculate that a total of *1,662,115 * 0.02609146 = 43,367*
    items were purchased during the store's 30 days of operation (ignoring the fact
    that duplicates of the same items might have been purchased). With an additional
    step, we can determine that the average transaction contained *43,367 / 8,835
    = 4.409* distinct grocery items. Of course, if we look a little further down the
    output, we'll see that the mean number of items per transaction has already been
    provided.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`0.02609146`（2.6%）的**密度**值表示矩阵中非零单元格的比例。由于矩阵中共有*9,835 * 169 = 1,662,115*个位置，我们可以计算出在商店的30天运营期间，共购买了*1,662,115
    * 0.02609146 = 43,367*个商品（忽略了同一商品可能重复购买的情况）。通过额外的步骤，我们可以确定平均每笔交易包含了*43,367 / 8,835
    = 4.409*个不同的杂货商品。当然，如果我们进一步查看输出结果，会看到每笔交易的商品平均数已经在输出中给出。'
- en: 'The next block of the `summary()` output lists the items that were most commonly
    found in the transactional data. Since *2,513 / 9,835 = 0.2555*, we can determine
    that whole milk appeared in 25.6 percent of the transactions. The other vegetables,
    rolls/buns, soda, and yogurt round out the list of other common items, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()`输出的下一个区块列出了在交易数据中最常见的项目。由于*2,513 / 9,835 = 0.2555*，我们可以确定全脂牛奶出现在25.6％的交易中。其他常见的项目包括其他蔬菜、卷/小圆面包、汽水和酸奶，具体如下：'
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we are presented with a set of statistics about the size of the transactions.
    A total of 2,159 transactions contained only a single item, while one transaction
    had 32 items. The first quartile and median purchase sizes are two and three items,
    respectively, implying that 25 percent of the transactions contained two or fewer
    items and the transactions were split in half between those with less than three
    items and those with more. The mean of 4.409 items per transaction matches the
    value we calculated by hand.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了一组关于交易大小的统计信息。共有2,159个交易仅包含单一项目，而有一个交易包含32个项目。第一四分位数和中位数购买大小分别为2和3个项目，这意味着25％的交易包含两个或更少的项目，并且交易在包含少于三个项目的和包含更多项目的交易之间平均分配。每个交易4.409个项目的平均值与我们手动计算的结果一致。
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `arules` package includes some useful features for examining transaction
    data. To look at the contents of the sparse matrix, use the `inspect()` function
    in combination with the vector operators. The first five transactions can be viewed
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`arules`包包含一些有用的功能，用于检查交易数据。要查看稀疏矩阵的内容，请将`inspect()`函数与向量操作符结合使用。可以按如下方式查看前五个交易：'
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These transactions match our look at the original CSV file. To examine a particular
    item (that is, a column of data), it is possible use the `[row, column]` matrix
    notion. Using this with the `itemFrequency()` function allows us to see the proportion
    of transactions that contain the item. This allows us, for instance, to view the
    support level for the first three items in the grocery data:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交易与我们查看原始CSV文件时的数据一致。要检查特定的项目（即一列数据），可以使用`[row, column]`矩阵概念。将其与`itemFrequency()`函数结合使用，可以查看包含该项目的交易比例。例如，这使我们能够查看`groceries`数据中前3个项目的支持度：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the items in the sparse matrix are sorted in columns by alphabetical
    order. Abrasive cleaner and artificial sweeteners are found in about 0.3 percent
    of the transactions, while baby cosmetics are found in about 0.06 percent of the
    transactions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，稀疏矩阵中的项目按字母顺序按列排序。磨砂清洁剂和人工甜味剂出现在大约0.3％的交易中，而婴儿化妆品出现在大约0.06％的交易中。
- en: Visualizing item support – item frequency plots
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化项目支持度 - 项目频率图
- en: To present these statistics visually, use the `itemFrequencyPlot()` function.
    This allows you to produce a bar chart depicting the proportion of transactions
    containing certain items. Since the transactional data contains a very large number
    of items, you will often need to limit the ones appearing in the plot in order
    to produce a legible chart.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直观展示这些统计信息，可以使用`itemFrequencyPlot()`函数。这允许你生成一张条形图，显示包含特定项目的交易比例。由于交易数据包含大量项目，你通常需要限制显示在图表中的项目，以便生成清晰的图表。
- en: 'If you require these items to appear in a minimum proportion of transactions,
    use `itemFrequencyPlot()` with the `support` parameter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望这些项目出现在交易的最低比例中，可以使用带有`support`参数的`itemFrequencyPlot()`：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As shown in the following plot, this results in a histogram showing the eight
    items in the `groceries` data with at least 10 percent support:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，这导致了一个显示`groceries`数据中至少有10％支持度的八个项目的直方图：
- en: '![Visualizing item support – item frequency plots](img/B03905_08_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![可视化项目支持度 - 项目频率图](img/B03905_08_06.jpg)'
- en: 'If you would rather limit the plot to a specific number of items, the `topN`
    parameter can be used with `itemFrequencyPlot()`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望限制图表中的项目数量，可以使用带有`topN`参数的`itemFrequencyPlot()`：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The histogram is then sorted by decreasing support, as shown in the following
    diagram of the top 20 items in the `groceries` data:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，直方图按支持度递减排序，如下图所示，展示了`groceries`数据中的前20个项目：
- en: '![Visualizing item support – item frequency plots](img/B03905_08_07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![可视化项目支持度 - 项目频率图](img/B03905_08_07.jpg)'
- en: Visualizing the transaction data – plotting the sparse matrix
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化交易数据 - 绘制稀疏矩阵
- en: 'In addition to looking at the items, it''s also possible to visualize the entire
    sparse matrix. To do so, use the `image()` function. The command to display the
    sparse matrix for the first five transactions is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看商品外，还可以可视化整个稀疏矩阵。为此，请使用`image()`函数。显示前五笔交易的稀疏矩阵的命令如下：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The resulting diagram depicts a matrix with 5 rows and 169 columns, indicating
    the 5 transactions and 169 possible items we requested. Cells in the matrix are
    filled with black for transactions (rows) where the item (column) was purchased.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表描绘了一个包含5行和169列的矩阵，表示我们请求的5笔交易和169个可能的商品。矩阵中的单元格用黑色填充，表示在某笔交易（行）中购买了某个商品（列）。
- en: '![Visualizing the transaction data – plotting the sparse matrix](img/B03905_08_08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![可视化交易数据 – 绘制稀疏矩阵](img/B03905_08_08.jpg)'
- en: Although the preceding diagram is small and may be slightly hard to read, you
    can see that the first, fourth, and fifth transactions contained four items each,
    since their rows have four cells filled in. You can also see that rows three,
    five, two, and four have an item in common (on the right side of the diagram).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的图表较小且可能略显难以阅读，但你可以看到第一、第四和第五行的交易每行都包含四个项目，因为它们的行中有四个单元格被填充。你还可以看到第三、第五、第二和第四行在右侧图表中有一个共同的项目。
- en: This visualization can be a useful tool for exploring data. For one, it may
    help with the identification of potential data issues. Columns that are filled
    all the way down could indicate items that are purchased in every transaction—a
    problem that could arise, perhaps, if a retailer's name or identification number
    was inadvertently included in the transaction dataset.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可视化可以成为探索数据的有用工具。首先，它可能有助于识别潜在的数据问题。完全填充的列可能表明在每一笔交易中都有购买某个商品——这可能是一个问题，例如，如果零售商的名称或识别号不小心包含在交易数据集中。
- en: Additionally, patterns in the diagram may help reveal actionable insights within
    the transactions and items, particularly if the data is sorted in interesting
    ways. For example, if the transactions are sorted by date, the patterns in black
    dots could reveal seasonal effects in the number or types of items purchased.
    Perhaps around Christmas or Hanukkah, toys are more common; around Halloween,
    perhaps candies become popular. This type of visualization could be especially
    powerful if the items were also sorted into categories. In most cases, however,
    the plot will look fairly random, like static on a television screen.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，图表中的模式可能有助于揭示交易和商品中的可操作见解，尤其是当数据以有趣的方式排序时。例如，如果交易按日期排序，黑色点的模式可能揭示购买的商品数量或类型的季节性变化。或许在圣诞节或光明节时，玩具更为常见；而在万圣节时，糖果可能变得受欢迎。如果商品也被分类，这种可视化可能尤其强大。然而，在大多数情况下，图表看起来将相当随机，就像电视屏幕上的雪花。
- en: 'Keep in mind that this visualization will not be as useful for extremely large
    transaction databases, because the cells will be too small to discern. Still,
    by combining it with the `sample()` function, you can view the sparse matrix for
    a randomly sampled set of transactions. The command to create random selection
    of 100 transactions is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种可视化对于极大的交易数据库来说并不那么有用，因为单元格会小到难以辨认。尽管如此，通过将其与`sample()`函数结合使用，你可以查看一个随机抽样的交易集的稀疏矩阵。创建100笔交易随机选择的命令如下：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This creates a matrix diagram with 100 rows and 169 columns:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个有100行和169列的矩阵图：
- en: '![Visualizing the transaction data – plotting the sparse matrix](img/B03905_08_09.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![可视化交易数据 – 绘制稀疏矩阵](img/B03905_08_09.jpg)'
- en: A few columns seem fairly heavily populated, indicating some very popular items
    at the store. But overall, the distribution of dots seems fairly random. Given
    nothing else of note, let's continue with our analysis.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些列看起来填充得相当密集，表明商店里有一些非常受欢迎的商品。但总体来说，点的分布似乎相当随机。既然没有其他值得注意的内容，我们继续进行分析。
- en: Step 3 – training a model on the data
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 3 – 在数据上训练模型
- en: 'With data preparation completed, we can now work at finding associations among
    shopping cart items. We will use an implementation of the Apriori algorithm in
    the `arules` package we''ve been using to explore and prepare the groceries data.
    You''ll need to install and load this package if you have not done so already.
    The following table shows the syntax to create sets of rules with the `apriori()`
    function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备完成后，我们现在可以开始寻找购物车物品之间的关联了。我们将使用`arules`包中的Apriori算法实现，这个包我们之前已经用来探索和准备杂货数据。如果你还没有安装和加载这个包，记得先操作。以下表格显示了使用`apriori()`函数创建规则集的语法：
- en: '![Step 3 – training a model on the data](img/B03905_08_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![步骤3 - 在数据上训练模型](img/B03905_08_10.jpg)'
- en: Although running the `apriori()` function is straightforward, there can sometimes
    be a fair amount of trial and error needed to find the `support` and `confidence`
    parameters that produce a reasonable number of association rules. If you set these
    levels too high, you might find no rules or rules that are too generic to be very
    useful. On the other hand, a threshold too low might result in an unwieldy number
    of rules, or worse, the operation might take a very long time or run out of memory
    during the learning phase.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管运行`apriori()`函数非常直接，但有时可能需要一定的试错过程来找到产生合理数量关联规则的`support`和`confidence`参数。如果你设定这些值过高，你可能找不到规则，或者找到的规则过于宽泛，无法提供实际价值。另一方面，阈值设定得过低可能会导致规则数量过多，甚至更糟，可能会导致学习阶段运行时间过长或内存不足。
- en: 'In this case, if we attempt to use the default settings of `support = 0.1`
    and `confidence = 0.8`, we will end up with a set of zero rules:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们尝试使用默认设置`support = 0.1`和`confidence = 0.8`，最终将得到一组零规则：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Obviously, we need to widen the search a bit.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要稍微扩大一下搜索范围。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you think about it, this outcome should not have been terribly surprising.
    Because `support = 0.1` by default, in order to generate a rule, an item must
    have appeared in at least *0.1 * 9,385 = 938.5* transactions. Since only eight
    items appeared this frequently in our data, it's no wonder that we didn't find
    any rules.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想一想，这个结果其实并不令人惊讶。因为`support = 0.1`是默认设置，要生成规则，一个项必须至少出现在*0.1 * 9,385 =
    938.5*次交易中。由于在我们的数据中只有八个项出现得如此频繁，因此我们没能找到任何规则也就不足为奇了。
- en: One way to approach the problem of setting a minimum support threshold is to
    think about the smallest number of transactions you would need before you would
    consider a pattern interesting. For instance, you could argue that if an item
    is purchased twice a day (about 60 times in a month of data), it may be an interesting
    pattern. From there, it is possible to calculate the support level needed to find
    only the rules matching at least that many transactions. Since 60 out of 9,835
    equals 0.006, we'll try setting the support there first.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 设定最小支持度阈值的一种方法是思考在什么样的最小交易数下，你会认为一个模式是有趣的。例如，你可以认为，如果某个项每天被购买两次（在一个月的数据中大约是60次），它可能是一个有趣的模式。从这里开始，你可以计算出需要的支持度水平，以便仅找到匹配至少那么多次交易的规则。由于60/9,835等于0.006，我们首先尝试将支持度设为这个值。
- en: Setting the minimum confidence involves a delicate balance. On one hand, if
    confidence is too low, we might be overwhelmed with a large number of unreliable
    rules—such as dozens of rules indicating the items commonly purchased with batteries.
    How would we know where to target our advertising budget then? On the other hand,
    if we set confidence too high, we will be limited to the rules that are obvious
    or inevitable—similar to the fact that smoke detectors are always purchased in
    combination with batteries. In this case, moving the smoke detectors closer to
    the batteries is unlikely to generate additional revenue, since the two items
    already were almost always purchased together.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设置最小置信度是一个微妙的平衡。一方面，如果置信度太低，我们可能会被大量不可靠的规则所淹没——例如，几十个规则显示电池通常会与其他物品一起购买。那么，我们怎么知道该将广告预算投向哪里呢？另一方面，如果我们将置信度设定得过高，那么规则将仅限于那些显而易见或不可避免的情况——类似于烟雾探测器总是与电池一起购买的事实。在这种情况下，将烟雾探测器放得更靠近电池可能不会带来额外的收益，因为这两种物品已经几乎总是一起购买了。
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The appropriate minimum confidence level depends a great deal on the goals of
    your analysis. If you start with a conservative value, you can always reduce it
    to broaden the search if you aren't finding actionable intelligence.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的最小置信度水平在很大程度上取决于你分析的目标。如果你从保守的值开始，若未找到可操作的情报，你总是可以减少置信度，扩大搜索范围。
- en: We'll start with a confidence threshold of 0.25, which means that in order to
    be included in the results, the rule has to be correct at least 25 percent of
    the time. This will eliminate the most unreliable rules, while allowing some room
    for us to modify behavior with targeted promotions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 0.25 的置信度阈值开始，这意味着为了被包括在结果中，规则必须至少正确 25% 的时间。这将剔除最不可靠的规则，同时为我们通过有针对性的促销调整行为提供一定的空间。
- en: We are now ready to generate some rules. In addition to the minimum `support`
    and `confidence` parameters, it is helpful to set `minlen = 2` to eliminate rules
    that contain fewer than two items. This prevents uninteresting rules from being
    created simply because the item is purchased frequently, for instance, *{}* *→*
    *whole milk*. This rule meets the minimum support and confidence because whole
    milk is purchased in over 25 percent of the transactions, but it isn't a very
    actionable insight.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以生成一些规则。除了最小的 `support` 和 `confidence` 参数外，设置 `minlen = 2` 也很有帮助，以排除那些包含少于两个项目的规则。这可以防止一些无趣的规则被创建，比如仅因为某个项目购买频繁而生成的规则，如
    *{}* *→* *whole milk*。这条规则符合最小支持度和置信度，因为全脂牛奶在超过 25% 的交易中被购买，但它并不是一个非常有行动价值的洞察。
- en: 'The full command to find a set of association rules using the Apriori algorithm
    is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apriori 算法查找关联规则的完整命令如下：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This saves our rules in a `rules` object, can take a peek into by typing its
    name:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们的规则保存在 `rules` 对象中，可以通过键入其名称来查看：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `groceryrules` object contains a set of 463 association rules. To determine
    whether any of them are useful, we'll have to dig deeper.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `groceryrules` 对象包含了一组 463 条关联规则。为了确定它们是否有用，我们需要深入挖掘。
- en: Step 4 – evaluating model performance
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 4 – 评估模型性能
- en: 'To obtain a high-level overview of the association rules, we can use `summary()`
    as follows. The rule length distribution tells us how many rules have each count
    of items. In our rule set, 150 rules have only two items, while 297 have three,
    and 16 have four. The `summary` statistics associated with this distribution are
    also given:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得关联规则的高层概览，我们可以按如下方式使用 `summary()`。规则长度分布告诉我们每条规则包含的项目数量。在我们的规则集中，150 条规则只有两个项目，297
    条规则有三个项目，16 条规则有四个项目。与此分布相关的 `summary` 统计数据也会提供：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As noted in the previous output, the size of the rule is calculated as the total
    of both the left-hand side (`lhs`) and right-hand side (`rhs`) of the rule. This
    means that a rule like *{bread}* *→* *{butter}* is two items and *{peanut butter,
    jelly}* *→* *{bread}* is three.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述输出所示，规则的大小是通过计算规则的左侧（`lhs`）和右侧（`rhs`）的总和来得出的。这意味着像 *{bread}* *→* *{butter}*
    这样的规则是两个项，而 *{peanut butter, jelly}* *→* *{bread}* 是三个。
- en: 'Next, we see the summary statistics of the rule quality measures: support,
    confidence, and lift. The support and confidence measures should not be very surprising,
    since we used these as selection criteria for the rules. We might be alarmed if
    most or all of the rules had support and confidence very near the minimum thresholds,
    as this would mean that we may have set the bar too high. This is not the case
    here, as there are many rules with much higher values of each.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到规则质量度量的汇总统计数据：支持度、置信度和提升度。支持度和置信度的度量不应该令人惊讶，因为我们使用这些作为规则的选择标准。如果大多数或所有规则的支持度和置信度接近最低阈值，我们可能会感到警觉，因为这意味着我们可能设置的标准过高。但这里并非如此，因为有许多规则的每个值都远高于这些最低值。
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The third column is a metric we have not considered yet. The *lift* of a rule
    measures how much more likely one item or itemset is purchased relative to its
    typical rate of purchase, given that you know another item or itemset has been
    purchased. This is defined by the following equation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列是我们尚未考虑的度量。规则的 *lift* 衡量的是在已知另一个项目或项目集被购买的情况下，某个项目或项目集的购买可能性相对于其通常购买率的提高程度。这个值通过以下方程定义：
- en: '![Step 4 – evaluating model performance](img/B03905_08_11.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 4 – 评估模型性能](img/B03905_08_11.jpg)'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unlike confidence where the item order matters, *lift(X → Y)* is the same as
    *lift(Y → X)*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与置信度不同，提升度 *lift(X → Y)* 与 *lift(Y → X)* 是相同的。
- en: For example, suppose at a grocery store, most people purchase milk and bread.
    By chance alone, we would expect to find many transactions with both milk and
    bread. However, if *lift(milk → bread)* is greater than one, it implies that the
    two items are found together more often than one would expect by chance. A large
    lift value is therefore a strong indicator that a rule is important, and reflects
    a true connection between the items.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在一家超市里，大多数人都购买牛奶和面包。仅凭偶然，我们就可以预期会有许多同时购买牛奶和面包的交易。然而，如果 *lift(牛奶 → 面包)*
    大于 1，这意味着这两种商品比偶然情况下更常一起出现。因此，较高的提升值是规则重要性的强烈指示，反映了商品之间的真实联系。
- en: 'In the final section of the `summary()` output, we receive mining information,
    telling us about how the rules were chosen. Here, we see that the `groceries`
    data, which contained 9,835 transactions, was used to construct rules with a minimum
    support of 0.0006 and minimum confidence of 0.25:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `summary()` 输出的最后部分，我们会看到挖掘信息，告诉我们规则是如何选择的。在这里，我们看到包含 9,835 个交易的 `groceries`
    数据被用来构建规则，最小支持度为 0.0006，最小置信度为 0.25：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can take a look at specific rules using the `inspect()` function. For instance,
    the first three rules in the `groceryrules` object can be viewed as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `inspect()` 函数查看特定规则。例如，可以通过以下方式查看 `groceryrules` 对象中的前三条规则：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Step 4 – evaluating model performance](img/B03905_08_12.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 4 – 评估模型性能](img/B03905_08_12.jpg)'
- en: The first rule can be read in plain language as, "if a customer buys potted
    plants, they will also buy whole milk." With support of 0.007 and confidence of
    0.400, we can determine that this rule covers 0.7 percent of the transactions
    and is correct in 40 percent of purchases involving potted plants. The lift value
    tells us how much more likely a customer is to buy whole milk relative to the
    average customer, given that he or she bought a potted plant. Since we know that
    about 25.6 percent of the customers bought whole milk (`support`), while 40 percent
    of the customers buying a potted plant bought whole milk (`confidence`), we can
    compute the lift value as *0.40 / 0.256 = 1.56*, which matches the value shown.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规则可以用简单的语言表述为：“如果顾客购买盆栽植物，他们也会购买全脂牛奶。”通过支持度为 0.007 和置信度为 0.400，我们可以确定这个规则覆盖了
    0.7% 的交易，并且在涉及盆栽植物的购买中正确率为 40%。提升值告诉我们，相比于平均顾客，购买盆栽植物的顾客购买全脂牛奶的可能性有多大。由于我们知道大约
    25.6% 的顾客购买了全脂牛奶（`support`），而 40% 购买盆栽植物的顾客购买了全脂牛奶（`confidence`），因此我们可以计算提升值为
    *0.40 / 0.256 = 1.56*，这与显示的值一致。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the column labeled `support` indicates the support value for the rule,
    not the support value for the `lhs` or `rhs` alone).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标有 `support` 的列表示的是规则的支持值，而不是 `lhs` 或 `rhs` 的支持值单独的支持值。
- en: In spite of the fact that the confidence and lift are high, does *{potted plants}*
    *→* *{whole milk}* seem like a very useful rule? Probably not, as there doesn't
    seem to be a logical reason why someone would be more likely to buy milk with
    a potted plant. Yet our data suggests otherwise. How can we make sense of this
    fact?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管置信度和提升值很高，*{盆栽植物}* *→* *{全脂牛奶}* 看起来仍然像是一个非常有用的规则吗？可能不是，因为似乎没有逻辑理由说明某人购买盆栽植物时更有可能购买牛奶。然而，我们的数据却暗示了不同的结果。我们如何解释这一事实呢？
- en: 'A common approach is to take the association rules and divide them into the
    following three categories:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法是将关联规则分为以下三类：
- en: Actionable
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可操作的
- en: Trivial
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微不足道的
- en: Inexplicable
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法解释的
- en: Obviously, the goal of a market basket analysis is to find **actionable** rules
    that provide a clear and useful insight. Some rules are clear, others are useful;
    it is less common to find a combination of both of these factors.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，市场篮分析的目标是找到**可操作的**规则，这些规则能提供明确且有用的洞察。有些规则很明确，有些规则很有用；同时具备这两者的组合则较为少见。
- en: So-called **trivial rules** include any rules that are so obvious that they
    are not worth mentioning—they are clear, but not useful. Suppose you were a marketing
    consultant being paid large sums of money to identify new opportunities for cross-promoting
    items. If you report the finding that *{diapers}* *→* *{formula}*, you probably
    won't be invited back for another consulting job.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的**微不足道规则**是指那些过于明显、没有价值的规则——它们很清晰，但没有用处。假设你是一名市场咨询师，受雇于客户，获取丰厚的报酬去识别新的交叉销售机会。如果你报告发现
    *{纸尿裤}* *→* *{奶粉}*，你可能不会被邀请回来进行下一次咨询工作。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Trivial rules can also sneak in disguised as more interesting results. For instance,
    say you found an association between a particular brand of children's cereal and
    a certain DVD movie. This finding is not very insightful if the movie's main character
    is on the front of the cereal box.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 微不足道的规则也可能伪装成更有趣的结果。例如，假设你发现某个特定品牌的儿童谷物和某部DVD电影之间存在关联。如果这部电影的主角出现在谷物盒的封面上，那么这个发现就没有太大意义。
- en: Rules are **inexplicable** if the connection between the items is so unclear
    that figuring out how to use the information is impossible or nearly impossible.
    The rule may simply be a random pattern in the data, for instance, a rule stating
    that *{pickles}* *→* *{chocolate ice cream}* may be due to a single customer,
    whose pregnant wife had regular cravings for strange combinations of foods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则之间的关联不明确，导致无法或几乎无法理解如何使用这些信息，则该规则是**无法解释的**。这个规则可能仅仅是数据中的一个随机模式，例如，一个规则表明*{腌黄瓜}*
    *→* *{巧克力冰淇淋}*，可能是因为某个顾客的孕妇妻子经常对奇怪的食物组合有特殊的渴望。
- en: The best rules are hidden gems—those undiscovered insights into patterns that
    seem obvious once discovered. Given enough time, one could evaluate each and every
    rule to find the gems. However, we (the one performing the market basket analysis)
    may not be the best judge of whether a rule is actionable, trivial, or inexplicable.
    In the next section, we'll improve the utility of our work by employing methods
    to sort and share the learned rules so that the most interesting results might
    float to the top.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳规则是隐藏的宝石——那些似乎一旦被发现就显而易见的模式洞察。给定足够的时间，可以评估每一条规则来发现这些宝石。然而，我们（执行市场购物篮分析的人）可能并不是判断规则是否具有可操作性、微不足道或无法解释的最佳人选。在接下来的部分中，我们将通过使用排序和共享已学规则的方法来提高我们的工作效用，从而使最有趣的结果能够浮到最上面。
- en: Step 5 – improving model performance
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 – 提高模型表现
- en: Subject matter experts may be able to identify useful rules very quickly, but
    it would be a poor use of their time to ask them to evaluate hundreds or thousands
    of rules. Therefore, it's useful to be able to sort rules according to different
    criteria, and get them out of R into a form that can be shared with marketing
    teams and examined in more depth. In this way, we can improve the performance
    of our rules by making the results more actionable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 专家可能能够非常迅速地识别有用的规则，但让他们评估成百上千的规则将是浪费他们时间。因此，能够根据不同标准对规则进行排序，并将它们从R中导出，以便与营销团队共享并深入研究是很有用的。通过这种方式，我们可以通过使结果更具可操作性来提高规则的表现。
- en: Sorting the set of association rules
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序关联规则集合
- en: Depending upon the objectives of the market basket analysis, the most useful
    rules might be the ones with the highest `support, confidence,` or `lift.` The
    `arules` package includes a `sort()` function that can be used to reorder the
    list of rules so that the ones with the highest or lowest values of the quality
    measure come first.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据市场购物篮分析的目标，最有用的规则可能是那些具有最高`support`、`confidence`或`lift`值的规则。`arules`包包含一个`sort()`函数，可以用来重新排序规则列表，使得具有最高或最低质量度量值的规则排在最前面。
- en: 'To reorder the `groceryrules` object, we can apply `sort()` while specifying
    a `"support"`, `"confidence"`, or `"lift"` value to the by parameter. By combining
    the `sort` function with vector operators, we can obtain a specific number of
    interesting rules. For instance, the best five rules according to the lift statistic
    can be examined using the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新排序`groceryrules`对象，我们可以在`by`参数中指定一个`"support"`、`"confidence"`或`"lift"`值并应用`sort()`函数。通过将`sort`函数与向量操作符结合使用，我们可以获得一个特定数量的有趣规则。例如，按照lift统计值排序，可以使用以下命令检查最佳的五条规则：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These output is shown as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Sorting the set of association rules](img/B03905_08_13.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![排序关联规则集合](img/B03905_08_13.jpg)'
- en: These rules appear to be more interesting than the ones we looked at previously.
    The first rule, with a `lift` of about 3.96, implies that people who buy herbs
    are nearly four times more likely to buy root vegetables than the typical customer—perhaps
    for a stew of some sort? Rule two is also interesting. Whipped cream is over three
    times more likely to be found in a shopping cart with berries versus other carts,
    suggesting perhaps a dessert pairing?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则似乎比我们之前查看的规则更有趣。第一条规则的`lift`约为3.96，意味着购买香草的人比普通顾客更可能购买根菜类蔬菜，其可能性是普通顾客的近四倍——也许是为了做某种炖菜？第二条规则也很有趣。打发奶油在购物车中与浆果一起出现的概率是其他购物车的三倍多，这或许暗示了一种甜点搭配？
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, the sort order is decreasing, meaning the largest values come first.
    To reverse this order, add an additional line, `parameterdecreasing = FALSE`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，排序顺序是降序的，意味着最大的值排在前面。要反转此顺序，只需添加一行 `parameterdecreasing = FALSE`。
- en: Taking subsets of association rules
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取关联规则的子集
- en: Suppose that given the preceding rule, the marketing team is excited about the
    possibilities of creating an advertisement to promote berries, which are now in
    season. Before finalizing the campaign, however, they ask you to investigate whether
    berries are often purchased with other items. To answer this question, we'll need
    to find all the rules that include berries in some form.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设根据前面的规则，营销团队对创建一个广告来推广当前正当季的浆果感到兴奋。然而，在最终确定活动之前，他们要求你调查一下浆果是否经常与其他商品一起购买。为了回答这个问题，我们需要找出所有包含浆果的规则。
- en: 'The `subset()` function provides a method to search for subsets of transactions,
    items, or rules. To use it to find any rules with `berries` appearing in the rule,
    use the following command. It will store the rules in a new object titled `berryrules`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`subset()` 函数提供了一种方法来查找交易、项目或规则的子集。要使用它查找任何包含 `berries` 的规则，可以使用以下命令。它会将规则存储在一个名为
    `berryrules` 的新对象中：'
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then inspect the rules as we did with the larger set:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像处理更大数据集时那样检查这些规则：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result is the following set of rules:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是以下一组规则：
- en: '![Taking subsets of association rules](img/B03905_08_14.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![获取关联规则的子集](img/B03905_08_14.jpg)'
- en: There are four rules involving berries, two of which seem to be interesting
    enough to be called actionable. In addition to whipped cream, berries are also
    purchased frequently with yogurt—a pairing that could serve well for breakfast
    or lunch as well as dessert.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及浆果的规则有四条，其中两条似乎足够有趣，可以称为可执行的。除了鲜奶油，浆果也经常与酸奶一起购买——这种搭配既适合早餐或午餐，也可以作为甜点。
- en: 'The `subset()` function is very powerful. The criteria for choosing the subset
    can be defined with several keywords and operators:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`subset()` 函数非常强大。选择子集的标准可以通过多个关键字和操作符来定义：'
- en: The keyword `items` explained previously, matches an item appearing anywhere
    in the rule. To limit the subset to where the match occurs only on the left- or
    right-hand side, use `lhs` and `rhs` instead.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面解释过的关键字 `items` 匹配规则中任何位置出现的项目。为了将子集限制为只匹配出现在左侧或右侧的项目，可以改用 `lhs` 和 `rhs`。
- en: The operator `%in%` means that at least one of the items must be found in the
    list you defined. If you want any rules matching either berries or yogurt, you
    could write `items %in%c("berries", "yogurt”)`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符 `%in%` 表示在你定义的列表中，至少有一个项目必须存在。如果你想要匹配浆果或酸奶的任何规则，可以写 `items %in%c("berries",
    "yogurt")`。
- en: 'Additional operators are available for partial matching (`%pin%`) and complete
    matching (`%ain%`). Partial matching allows you to find both citrus fruit and
    tropical fruit using one search: `items %pin% "fruit"`. Complete matching requires
    that all the listed items are present. For instance, `items %ain% c("berries",
    "yogurt")` finds only rules with both `berries` and `yogurt`.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还提供了额外的操作符，用于部分匹配（`%pin%`）和完全匹配（`%ain%`）。部分匹配允许你通过一个查询同时找到柑橘类水果和热带水果：`items
    %pin% "fruit"`。完全匹配要求所有列出的项目都必须出现。例如，`items %ain% c("berries", "yogurt")` 只会找到包含
    `berries` 和 `yogurt` 的规则。
- en: Subsets can also be limited by `support`, `confidence`, or `lift`. For instance,
    `confidence > 0.50` would limit you to the rules with confidence greater than
    50 percent.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子集还可以通过 `support`、`confidence` 或 `lift` 来限制。例如，`confidence > 0.50` 将限制为那些置信度大于
    50% 的规则。
- en: Matching criteria can be combined with the standard R logical operators such
    as and (`&`), or (`|`), and not (`!`).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配标准可以与标准的 R 逻辑运算符结合使用，如与（`&`）、或（`|`）和非（`!`）。
- en: Using these options, you can limit the selection of rules to be as specific
    or general as you would like.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项，你可以将规则的选择限制得尽可能具体或宽泛。
- en: Saving association rules to a file or data frame
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将关联规则保存到文件或数据框
- en: 'To share the results of your market basket analysis, you can save the rules
    to a CSV file with the `write()` function. This will produce a CSV file that can
    be used in most spreadsheet programs including Microsoft Excel:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分享你的市场购物篮分析结果，你可以使用 `write()` 函数将规则保存为 CSV 文件。这将生成一个可以在大多数电子表格程序（包括 Microsoft
    Excel）中使用的 CSV 文件：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Sometimes it is also convenient to convert the rules into an R data frame.
    This can be accomplished easily using the `as()` function, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将规则转换为 R 数据框也是很方便的。可以通过 `as()` 函数轻松实现，如下所示：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This creates a data frame with the rules in the factor format, and numeric
    vectors for `support`, `confidence`, and `lift`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个数据框，其中包含按因子格式表示的规则，以及`支持度`、`置信度`和`提升度`的数值向量：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might choose to do this if you want to perform additional processing on
    the rules or need to export them to another database.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对规则执行进一步处理或需要将它们导出到另一个数据库中，你可以选择这样做。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Association rules are frequently used to find provide useful insights in the
    massive transaction databases of large retailers. As an unsupervised learning
    process, association rule learners are capable of extracting knowledge from large
    databases without any prior knowledge of what patterns to seek. The catch is that
    it takes some effort to reduce the wealth of information into a smaller and more
    manageable set of results. The Apriori algorithm, which we studied in this chapter,
    does so by setting minimum thresholds of interestingness, and reporting only the
    associations meeting these criteria.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则通常用于在大型零售商的海量交易数据库中提供有用的洞察。作为一种无监督学习过程，关联规则学习器能够从大型数据库中提取知识，而无需提前了解要寻找什么样的模式。问题在于，它需要一定的努力才能将大量信息缩减为一个更小、更易管理的结果集。我们在本章中研究的Apriori算法通过设置最小兴趣阈值，并仅报告满足这些标准的关联，从而实现了这一目标。
- en: We put the Apriori algorithm to work while performing a market basket analysis
    for a month's worth of transactions at a moderately sized supermarket. Even in
    this small example, a wealth of associations was identified. Among these, we noted
    several patterns that may be useful for future marketing campaigns. The same methods
    we applied are used at much larger retailers on databases many times this size.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进行一个中型超市一个月交易数据的市场购物篮分析时，运用了Apriori算法。即使在这个小示例中，也发现了大量的关联。在这些关联中，我们注意到了一些可能对未来营销活动有用的模式。我们应用的相同方法也被用于更大规模的零售商，分析的数据集大小是这些的多倍。
- en: In the next chapter, we will examine another unsupervised learning algorithm.
    Much like association rules, it is intended to find patterns within data. But
    unlike association rules that seek patterns within the features, the methods in
    the next chapter are concerned with finding connections among the examples.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究另一种无监督学习算法。与关联规则类似，它也旨在在数据中找到模式。但与寻找特征间模式的关联规则不同，下一章中的方法更关注在示例之间发现联系。
