- en: Biometric Face Recognition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生物识别人脸识别
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Capturing and processing video from a webcam
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络摄像头捕获和处理视频
- en: Building a face detector using Haar cascades
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Haar级联构建人脸检测器
- en: Building eye and nose detectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建眼鼻检测器
- en: Performing principal component analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行主成分分析
- en: Performing kernel principal component analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行核主成分分析
- en: Performing blind source separation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行盲源分离
- en: Building a face recognizer using a local binary pattern histogram
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用局部二值模式直方图构建人脸识别器
- en: Recognizing faces using a HOG-based model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于HOG的模型识别人脸
- en: Facial landmarks recognition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面部特征点识别
- en: User authentication by face recognition
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过人脸识别进行用户身份验证
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To address the recipes in this chapter, you need the following files (available
    on GitHub):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理本章中的食谱，你需要以下文件（可在GitHub上找到）：
- en: '`video_capture.py`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`video_capture.py`'
- en: '`face_detector.py`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`face_detector.py`'
- en: '`eye_nose_detector.py`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eye_nose_detector.py`'
- en: '`pca.py`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pca.py`'
- en: '`kpca.py`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kpca.py`'
- en: '`blind_source_separation.py`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blind_source_separation.py`'
- en: '`mixture_of_signals.txt`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mixture_of_signals.txt`'
- en: '`face_recognizer.py`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`face_recognizer.py`'
- en: '`FaceRecognition.py`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FaceRecognition.py`'
- en: '`FaceLandmarks.py`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FaceLandmarks.py`'
- en: '`UserAuthentification.py`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserAuthentification.py`'
- en: Introduction
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Face recognition** refers to the task of identifying a person in a given
    image. This is different from face detection where we locate the face in a given
    image. During face detection, we don''t care who the person is; we just identify
    the region of the image that contains the face. Therefore, in a typical biometric
    face recognition system, we need to determine the location of the face before
    we can recognize it.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**人脸识别**指的是在给定图像中识别一个人的任务。这与人脸检测不同，人脸检测是在给定图像中定位人脸。在人脸检测过程中，我们不在乎这个人是谁；我们只是识别包含人脸的图像区域。因此，在典型的生物识别人脸识别系统中，在识别之前，我们需要确定人脸的位置。'
- en: Face recognition is very easy for humans. We seem to do it effortlessly, and
    we do it all the time! How do we get a machine to do the same thing? We need to
    understand what parts of the face we can use to uniquely identify a person. Our
    brain has an internal structure that seems to respond to specific features, such
    as edges, corners, motion, and so on. The human visual cortex combines all these
    features into a single coherent inference. If we want our machine to recognize
    faces with accuracy, we need to formulate the problem in a similar way. We need
    to extract features from the input image and convert them into a meaningful representation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 人脸识别对人类来说非常容易。我们似乎毫不费力地就能做到，而且我们一直在做！我们如何让机器做到同样的事情呢？我们需要了解我们可以用哪些面部特征来唯一地识别一个人。我们的大脑似乎有一种内部结构，能够对特定的特征做出反应，例如边缘、角点、运动等。人类视觉皮层将这些特征组合成一个单一的连贯推理。如果我们想让我们的机器以准确率识别人脸，我们需要以类似的方式制定问题。我们需要从输入图像中提取特征，并将它们转换为有意义的表示。
- en: Capturing and processing video from a webcam
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网络摄像头捕获和处理视频
- en: Webcams are certainly not an innovative technological innovation; their appearance
    dates back to the beginning of the 1990s and from then on, they gained increasing
    popularity thanks to the spread of video chat programs, street cams, and broadband
    internet connections. Currently, webcams are objects for everyone and are almost
    always integrated into the display frames of monitors, netbooks, and notebooks.
    The most common uses of a webcam are to transmit video streaming and record.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 网络摄像头当然不是一项创新技术；它们的出现可以追溯到20世纪90年代初，从那时起，由于视频聊天程序、街景摄像头和宽带互联网连接的普及，它们越来越受欢迎。目前，网络摄像头是每个人的对象，并且几乎总是集成在显示器框架中，如台式机、上网本和笔记本电脑。网络摄像头最常用的用途是传输视频流和录制。
- en: In the first case, webcams are used in video chat programs, television broadcasting,
    and street cams—cameras that film a fixed point of a given location. In the second
    case, webcams are used for creating photos and videos that you can then upload
    to the internet, for example, to YouTube or social networking sites. The advantage
    of these types of webcams is that they can replace the more classic uses of the
    camera, even if they are characterized by much poorer video quality.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，网络摄像头用于视频聊天程序、电视广播和街景摄像头——这些摄像头拍摄特定位置的固定点。在第二种情况下，网络摄像头用于创建可以上传到互联网的照片和视频，例如YouTube或社交网站。这些类型网络摄像头的优点是，它们可以取代更传统的相机使用方式，即使它们的视频质量较差。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use a webcam to capture video data. Let's see how we
    can capture video footage from a webcam using OpenCV-Python.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用网络摄像头来捕获视频数据。让我们看看如何使用OpenCV-Python从网络摄像头捕获视频片段。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how we can capture and process video from a webcam by following
    these steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何按照以下步骤捕获和处理网络摄像头的视频：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `video_capture.py` file that is provided for you):'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`video_capture.py`文件中给出）：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'OpenCV provides a video capture object that we can use to capture images from
    the webcam. The `0` input argument specifies the ID of the webcam. If you connect
    a USB camera, then it will have a different ID:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV提供了一个可以用来从网络摄像头捕获图像的视频捕获对象。`0`输入参数指定了网络摄像头的ID。如果你连接了一个USB摄像头，那么它将有一个不同的ID：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the scaling factor for frames that are captured using the webcam:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义使用网络摄像头捕获的帧的缩放因子。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start an infinite loop and keep capturing frames until you press the *Esc*
    key. Read the frame from the webcam:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个无限循环并持续捕获帧，直到你按下*Esc*键。从网络摄像头读取帧：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Resizing the frame is optional but still a useful thing to have in your code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整帧大小是可选的，但在你的代码中仍然是一个有用的功能：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Display the frame:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示帧：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Wait for 1ms before capturing the next frame:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在捕获下一帧之前等待1毫秒：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Release the video capture object:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放视频捕获对象：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Close all active windows before exiting the code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出代码之前关闭所有活动窗口：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run this code, you will see the video from the webcam.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你将看到网络摄像头的视频。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we used a webcam to capture video data via OpenCV-Python. To
    do this, the following operations have been performed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了网络摄像头通过OpenCV-Python捕获视频数据。为此，执行了以下操作：
- en: Initialize video capture object.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化视频捕获对象。
- en: Define the image size scaling factor.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义图像大小缩放因子。
- en: 'Loop until you hit the *Esc* key:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环直到你按下*Esc*键：
- en: Capture the current frame.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获当前帧。
- en: Resize the frame.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整帧大小。
- en: Display the image.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示图像。
- en: Detect whether the *Esc* key has been pressed.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测是否按下了*Esc*键。
- en: Release the video capture object.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放视频捕获对象。
- en: Close all active windows.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭所有活动窗口。
- en: There's more…
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: OpenCV provides a very simple interface to capture live streaming with webcams.
    To capture a video, you need to create a `VideoCapture` object. Its argument can
    be the device index or the name of a video file. Then we can acquire them frame
    by frame. However, we must not forget to release the capture.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个非常简单的接口来捕获网络摄像头的实时流。要捕获视频，你需要创建一个`VideoCapture`对象。它的参数可以是设备索引或视频文件的名称。然后我们可以逐帧获取它们。然而，我们不要忘记释放捕获。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation of the OpenCV library: [https://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html](https://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV库的官方文档：[https://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html](https://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html)
- en: Building a face detector using Haar cascades
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Haar级联构建人脸检测器
- en: As we discussed earlier, face detection is the process of determining the location
    of a face in an input image. In this recipe, we will use **Haar cascades** for
    face detection. This works by extracting many simple features from the image at
    multiple scales. These simple features are edge, line, and rectangle features
    that are very easy to compute. They are then trained by creating a cascade of
    simple classifiers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，人脸检测是确定输入图像中人脸位置的过程。在这个菜谱中，我们将使用**Haar级联**进行人脸检测。这是通过在多个尺度上从图像中提取许多简单特征来实现的。这些简单特征是边缘、线和矩形特征，它们很容易计算。然后通过创建简单分类器的级联来训练它们。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will learn how to determine the location of a face in the
    video frames that are captured by our webcam. The **adaptive boosting** technique
    is used to make this process robust.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何确定由我们的网络摄像头捕获的视频帧中人脸的位置。这个过程使用了**自适应增强**技术来提高其鲁棒性。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how we can build a face detector using Haar cascades:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Haar级联构建人脸检测器：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `face_detector.py` file that is provided for you):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`face_detector.py`文件中给出）：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Load the face detector cascade file. This is a trained model that we can use
    as a detector:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载人脸检测器级联文件。这是一个我们可以用作检测器的训练模型：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Check whether the cascade file loaded properly:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查级联文件是否正确加载：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the video capture object:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建视频捕获对象：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define the scaling factor for image downsampling:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义图像下采样的缩放因子：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Keep looping until you hit the *Esc* key:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续循环，直到按下*Esc*键：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Resize the frame:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整帧大小：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Convert the image to grayscale. We need grayscale images to run the face detector:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像转换为灰度图。我们需要灰度图像来运行人脸检测器：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the face detector on the grayscale image. The `1.3` parameter refers to
    the scale multiplier for each stage. The `5` parameter refers to the minimum number
    of neighbors that each candidate rectangle should have so that we can retain it.
    This candidate rectangle is basically a potential region where there is a chance
    of a face being detected:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在灰度图像上运行人脸检测器。`1.3`参数指的是每个阶段的缩放乘数。`5`参数指的是每个候选矩形应该具有的最小邻居数，以便我们保留它。这个候选矩形基本上是一个可能检测到人脸的潜在区域：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Draw a rectangle around each detected face region:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个检测到的人脸区域周围绘制矩形：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Display the output image:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示输出图像：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Wait for 1ms before going to the next iteration. If the user presses the Esc
    key, break out of the loop:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行下一次迭代之前等待1毫秒。如果用户按下Esc键，则跳出循环：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Release and destroy the objects before exiting the code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出代码之前释放和销毁对象：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you run this code, you will see the face being detected in the webcam video.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你将在摄像头视频中看到被检测到的人脸。
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we learned how to determine the location of a face in video
    frames that were captured by the webcam. To do this, the following operations
    were performed:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们学习了如何确定由摄像头捕获的视频帧中的人脸位置。为此，执行了以下操作：
- en: Load the face cascade file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载人脸级联文件。
- en: Check whether the face cascade file has been loaded.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查人脸级联文件是否已加载。
- en: Initialize the video capture object.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化视频捕获对象。
- en: Define the scaling factor.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义缩放因子。
- en: 'Loop until you hit the *Esc* key:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环直到按下*Esc*键：
- en: Capture the current frame and resize it.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获当前帧并调整其大小。
- en: Convert into grayscale.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换为灰度图。
- en: Run the face detector on the grayscale image.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在灰度图像上运行人脸检测器。
- en: Draw rectangles on the image.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图像上绘制矩形。
- en: Display the image.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示图像。
- en: Check if the *Esc* key has been pressed.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否按下了*Esc*键。
- en: Release the video capture object and close all windows.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放视频捕获对象并关闭所有窗口。
- en: There's more…
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Haar cascades is an approach, based on machine learning, in which a cascade
    function is trained by many positive and negative images. It is then used to detect
    objects in other images.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Haar级联是一种基于机器学习的方法，其中通过许多正负图像训练级联函数。然后，它被用来检测其他图像中的对象。
- en: See also
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Face Detection using Haar Cascades*:[ https://docs.opencv.org/3.1.0/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0](https://docs.opencv.org/3.1.0/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Haar级联进行人脸检测*：[https://docs.opencv.org/3.1.0/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0](https://docs.opencv.org/3.1.0/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0)'
- en: '*Rapid Object Detection using a Boosted Cascade of Simple Features*: [https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf](https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用简单特征的增强级联快速对象检测*：[https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf](https://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/viola-cvpr-01.pdf)'
- en: Building eye and nose detectors
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建眼睛和鼻子检测器
- en: In the previous recipe, *Building a face detector using Haar cascades*, we used
    the Haar cascades method to detect the location of a face in video frames that
    were captured by a webcam. This method can be extended to detect all types of
    object. This is what we will be covering here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，*使用Haar级联构建人脸检测器*，我们使用了Haar级联方法来检测由摄像头捕获的视频帧中的人脸位置。这种方法可以扩展到检测所有类型的对象。这正是我们将在这里讨论的内容。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will see how we can use the Haar cascades method to detect
    the eyes and nose of a person in an input video.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何使用Haar级联方法来检测输入视频中的人脸的眼睛和鼻子。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how we can build eye and nose detectors:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何构建眼睛和鼻子检测器：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `eye_nose_detector.py` file that is provided for you):'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`eye_nose_detector.py`文件中给出）：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Load the face, eyes, and nose cascade files:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载人脸、眼睛和鼻子级联文件：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Check whether the files have loaded correctly:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文件是否正确加载：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Initialize the video capture object:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化视频捕获对象：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define the scaling factor:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义缩放因子：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Keep looping until the user presses the *Esc* key:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持循环，直到用户按下*Esc*键：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Resize the frame:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整帧大小：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Convert the image into grayscale:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像转换为灰度：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the face detector on the grayscale image:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在灰度图像上运行人脸检测器：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since we know that faces always have eyes and noses, we can run these detectors
    only in the face region:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们知道面孔总是有眼睛和鼻子，我们只能在面部区域运行这些检测器：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Extract the face ROI:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取面部ROI：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the eye detector:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行眼睛检测器：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the nose detector:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行鼻子检测器：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Draw circles around the eyes:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在眼睛周围画圆圈：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Draw a rectangle around the nose:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在鼻子上画一个矩形：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Display the image:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示图像：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Wait for 1ms before going to the next iteration. If the user presses the *Esc*
    key, then break the loop:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行下一次迭代之前等待1毫秒。如果用户按下*Esc*键，则中断循环：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Release and destroy the objects before exiting the code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出代码之前释放和销毁对象：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you run this code, you will see the eyes and nose of the person being detected
    in the webcam video.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你将看到网络摄像头视频中检测到的人的眼睛和鼻子。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we learned how to detect the eyes and nose of a person in the
    input video. To do this, the following operations have been performed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何在输入视频中检测人的眼睛和鼻子。为此，已经执行了以下操作：
- en: Load the face, eye, and nose cascade files.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载面部、眼睛和鼻子级联文件。
- en: Check whether the face, eye, and nose cascade files have been loaded.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查面部、眼睛和鼻子级联文件是否已加载。
- en: Initialize a video capture object and define the scaling factor.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化视频捕获对象并定义缩放因子。
- en: 'Loop on the frame:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在帧上循环：
- en: Read the current frame, resize it, and convert it into grayscale.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取当前帧，调整大小，并将其转换为灰度。
- en: Run the face detector on the grayscale image.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在灰度图像上运行人脸检测器。
- en: Run the eye and nose detectors within each face rectangle.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个面部矩形内运行眼睛和鼻子检测器。
- en: Display the image.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示图像。
- en: Check whether the *Esc* key has been pressed.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否按下了*Esc*键。
- en: Release the video capture object and close all windows.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放视频捕获对象并关闭所有窗口。
- en: There's more…
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Identifying facial elements in a webcam can be useful for recognizing subjects.
    Both global visual information and local characteristics (eye and nose morphology)
    are fundamental in the perception and recognition of the face. In fact, studies
    on facial recognition document that men more easily identify faces with predominant
    elements such as aquiline nose, squinting eyes, and so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络摄像头中识别面部元素对于识别主题可能很有用。全局视觉信息和局部特征（眼睛和鼻子的形态）在面部感知和识别中是基本的。事实上，关于面部识别的研究表明，男性更容易识别具有突出特征的面孔，如鹰钩鼻、眯眼等。
- en: See also
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Classifier case study – *Viola-Jones Face Detector*: [http://www.cse.psu.edu/~rtc12/CSE586/lectures/violaJonesDetector.pdf ](http://www.cse.psu.edu/~rtc12/CSE586/lectures/violaJonesDetector.pdf)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类案例研究 - *Viola-Jones 人脸检测器*：[http://www.cse.psu.edu/~rtc12/CSE586/lectures/violaJonesDetector.pdf](http://www.cse.psu.edu/~rtc12/CSE586/lectures/violaJonesDetector.pdf)
- en: Performing principal component analysis
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行主成分分析
- en: '**Principal component analysis** (**PCA**) is a dimensionality reduction technique
    that''s used frequently in computer vision and machine learning. When we deal
    with features with large dimensionalities, training a machine learning system
    becomes prohibitively expensive. Therefore, we need to reduce the dimensionality
    of the data before we can train a system. However, when we reduce the dimensionality,
    we don''t want to lose the information that''s present in the data. This is where
    PCA comes into the picture! PCA identifies the important components of the data
    and arranges them in order of importance.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**主成分分析**（PCA）是一种常用于计算机视觉和机器学习的降维技术。当我们处理具有高维度的特征时，训练机器学习系统变得过于昂贵。因此，在训练系统之前，我们需要降低数据的维度。然而，当我们降低维度时，我们不想丢失数据中存在的信息。这就是PCA发挥作用的地方！PCA识别数据的重要成分，并按重要性顺序排列。'
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will see how we can perform PCA on input data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何对输入数据进行主成分分析（PCA）。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s see how we can perform a PCA on some input data:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何对一些输入数据进行PCA：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `pca.py` file that is provided for you):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`pca.py`文件中给出）：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s define five dimensions for our input data. The first two dimensions
    will be independent, but the next three dimensions will be dependent on the first
    two dimensions. This basically means that we can live without the last three dimensions
    because they do not give us any new information:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的输入数据定义五个维度。前两个维度将是独立的，但接下来的三个维度将依赖于前两个维度。这基本上意味着我们可以没有最后三个维度，因为它们不会给我们提供任何新的信息：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s create a dataset with these features:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建具有这些特征的数据库：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a PCA object:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个PCA对象：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Fit a PCA model on the input data:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输入数据上拟合PCA模型：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Print the variances of the dimensions:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印维度的方差：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If a particular dimension is useful, then it will have a meaningful value for
    the variance. Let''s set a threshold and identify the important dimensions:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果某个维度是有用的，那么它将为方差提供一个有意义的值。让我们设置一个阈值并识别重要的维度：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Just like we discussed earlier, PCA has identified that only two dimensions
    are important in this dataset:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，PCA已经确定在这个数据集中只有两个维度是重要的：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s convert the dataset from a five-dimensional set into a two-dimensional
    set:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将数据集从五维集转换为二维集：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you run this code, you will see the following on your Terminal:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你将在你的终端上看到以下内容：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can see, the first two components contain all of the variance of the model.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前两个成分包含了模型的所有方差。
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: PCA generates a new set of variables, among which there are uncorrelated variables,
    also known as principal components. Each main component is a linear combination
    of the original variables. All principal components are orthogonal to each other,
    so there is no redundant information.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: PCA生成了一组新的变量，其中包含不相关的变量，也称为主成分。每个主成分是原始变量的线性组合。所有主成分都是相互正交的，因此没有冗余信息。
- en: The principal components as a whole constitute an orthogonal basis for the data
    space. The goal of PCA is to explain the maximum amount of variance with the lowest
    number of principal components. PCA is a type of multidimensional scaling wherein
    the variables are linearly transformed into a lower dimensional space, thereby
    retaining the maximum amount of information possible about the variables. A principal
    component is therefore a combination of the original variables after a linear
    transformation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 主成分作为一个整体构成了数据空间的正交基。PCA的目标是用最少的几个主成分解释最大的方差。PCA是一种多维缩放，其中变量被线性变换到低维空间，从而保留关于变量的最大信息量。因此，主成分是原始变量经过线性变换后的组合。
- en: There's more…
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The variance measures how far a set of numbers are spread out from their mean.
    It represents the mean of the squares of deviations of individual values from
    their arithmetic mean.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 方差衡量一组数字从它们的平均值偏离的程度。它表示各个值从算术平均值偏差的平方的平均值。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Official documentation of the `sklearn.decomposition.PCA` function: [https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sklearn.decomposition.PCA`函数的官方文档: [https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html)'
- en: '*Principal components analysis* (by Andrew Ng from Stanford University): [http://cs229.stanford.edu/notes/cs229-notes10.pdf](http://cs229.stanford.edu/notes/cs229-notes10.pdf)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主成分分析*（由斯坦福大学的Andrew Ng提供）：[http://cs229.stanford.edu/notes/cs229-notes10.pdf](http://cs229.stanford.edu/notes/cs229-notes10.pdf)'
- en: '*Principle Component Analysis* (from Indiana University): [http://scholarwiki.indiana.edu/Z604/slides/week4-PCA.pdf](http://scholarwiki.indiana.edu/Z604/slides/week4-PCA.pdf)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主成分分析*（来自印第安纳大学）: [http://scholarwiki.indiana.edu/Z604/slides/week4-PCA.pdf](http://scholarwiki.indiana.edu/Z604/slides/week4-PCA.pdf)'
- en: Performing kernel principal component analysis
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行核主成分分析
- en: PCA is good at reducing the number of dimensions, but it works in a linear manner.
    If the data is not organized in a linear fashion, PCA fails to do the required
    job. This is where kernel PCA enters the picture.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: PCA擅长减少维度数量，但它以线性方式工作。如果数据不是以线性方式组织的，PCA将无法完成所需的工作。这就是核PCA出现的地方。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will see how we can perform a kernel PCA on the input data
    and compare the result to how PCA performs on the same data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何对输入数据进行核PCA，并将结果与PCA在相同数据上的表现进行比较。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we can perform a kernel PCA:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何执行核PCA：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `kpca.py` file that is provided for you):'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`kpca.py`文件中给出）：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the `seed` value for the random number generator. This is needed to
    generate data samples for analysis:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义随机数生成器的`seed`值。这是生成分析数据样本所需的：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Generate data that is distributed in concentric circles to demonstrate how
    PCA doesn''t work in this case:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成分布在内切圆中的数据以展示PCA在这种情况下不起作用：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Perform PCA on this data:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对这些数据进行PCA分析：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Perform kernel PCA on this data:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对这些数据进行核PCA分析：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Plot the original input data:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制原始输入数据：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Plot the PCA-transformed data:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制PCA转换后的数据：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Plot the kernel PCA-transformed data:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制核PCA转换后的数据：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Transform the data back to the original space using the Kernel method to show
    that the inverse is maintained:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用核方法将数据转换回原始空间，以显示逆变换是保持不变的：
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The full code is given in the `kpca.py` file that''s already provided to you
    for reference. If you run this code, you will see four diagrams. The first diagram
    is the original data:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的代码在提供的`kpca.py`文件中给出，供您参考。如果您运行此代码，您将看到四个图。第一个图是原始数据：
- en: '![](img/9a76365f-eae9-4d62-8bd7-850626d661e4.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a76365f-eae9-4d62-8bd7-850626d661e4.png)'
- en: 'The second diagram depicts the data that was transformed using PCA:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图展示了使用PCA转换后的数据：
- en: '![](img/67ef1a63-4853-4dcd-ac04-6f0abd5a4c19.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67ef1a63-4853-4dcd-ac04-6f0abd5a4c19.png)'
- en: 'The third diagram depicts the data that was transformed using the kernel PCA.
    Note how the points are clustered on the right-hand side of the diagram:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个图展示了使用核PCA转换后的数据。注意图中点在右侧是如何聚集的：
- en: '![](img/a2fbe42c-caea-4940-8512-59f4cd768dcd.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2fbe42c-caea-4940-8512-59f4cd768dcd.png)'
- en: 'The fourth diagram depicts the inverse transform of the data back to the original
    space:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个图展示了数据逆变换回原始空间：
- en: '![](img/03aa5817-7804-42a6-b4c0-2183452e54eb.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03aa5817-7804-42a6-b4c0-2183452e54eb.png)'
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**Kernel principal component analysis** (**kernel PCA**) is based on PCA while
    using the techniques of kernel methods. In PCA, the originally linear PCA operations
    are performed in a reproducing kernel Hilbert space.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**核主成分分析**（**核PCA**）基于PCA，同时使用核方法的技术。在PCA中，原始的线性PCA操作是在再生核Hilbert空间中执行的。'
- en: Kernel methods are a class of algorithms used for the analysis of patterns and
    schemes, and whose most well-known element are SVMs. Kernel methods solve a problem
    by mapping data into a multidimensional feature space, and in this space each
    coordinate corresponds to a feature of the element's data, transforming the data
    into a set of Euclidean space points.  Since the mapping can be general (for example,
    not necessarily linear), the relations that are found in this way are consequently
    very general.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 核方法是一类用于分析和模式方案的算法，其中最著名的元素是SVMs。核方法通过将数据映射到多维特征空间来解决一个问题，在这个空间中，每个坐标对应于元素数据的特征，将数据转换为一组欧几里得空间点。由于映射可以是通用的（例如，不一定是线性的），因此以这种方式找到的关系因此非常通用。
- en: There's more…
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Kernel methods are named after kernel functions, which are used to operate on
    the characteristic space without calculating the data coordinates in space, but
    rather by calculating the internal product among the images of all copies of data
    in the function space. Kernel methods are often computationally cheaper than the
    explicit calculation of coordinates. The kernel trick refers to this approach
    as **problem resolution**.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 核方法以核函数命名，核函数用于在特征空间上操作，而不必在空间中计算数据坐标，而是通过在函数空间中计算所有数据副本的图像之间的内积。核方法通常比显式计算坐标的计算成本低。核技巧将这种方法称为**问题解决**。
- en: See also
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考内容
- en: 'Official documentation of the `sklearn.decomposition.KernelPCA` function: [https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.KernelPCA.html](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.KernelPCA.html)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sklearn.decomposition.KernelPCA`函数的官方文档：[https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.KernelPCA.html](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.KernelPCA.html)'
- en: '*Kernel Principal Components Analysis* (by Max Welling from the University
    of Toronto): [https://www.ics.uci.edu/~welling/classnotes/papers_class/Kernel-PCA.pdf](https://www.ics.uci.edu/~welling/classnotes/papers_class/Kernel-PCA.pdf)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*核主成分分析*（由多伦多大学的Max Welling提出）：[https://www.ics.uci.edu/~welling/classnotes/papers_class/Kernel-PCA.pdf](https://www.ics.uci.edu/~welling/classnotes/papers_class/Kernel-PCA.pdf)'
- en: '*KERNEL PCA* (by Rita Osadchy from Haifa University): [http://www.cs.haifa.ac.il/~rita/uml_course/lectures/KPCA.pdf](http://www.cs.haifa.ac.il/~rita/uml_course/lectures/KPCA.pdf)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*核PCA*（由海法大学的Rita Osadchy提供）：[http://www.cs.haifa.ac.il/~rita/uml_course/lectures/KPCA.pdf](http://www.cs.haifa.ac.il/~rita/uml_course/lectures/KPCA.pdf)'
- en: Performing blind source separation
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行盲源分离
- en: '**Blind source separation** refers to the process of separating signals from
    a mixture. Let''s say a bunch of different signal generators generate signals
    and a common receiver receives all of these signals. Now, our job is to separate
    these signals from this mixture using the properties of these signals. We will
    use **independent component analysis** (**ICA**) to achieve this.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**盲源分离**指的是从混合信号中分离信号的过程。假设有一组不同的信号发生器生成信号，一个共同的接收器接收所有这些信号。现在，我们的任务是利用这些信号的特性，从混合中分离这些信号。我们将使用**独立成分分析**（**ICA**）来实现这一点。'
- en: Getting ready
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the data from a `.txt` file to separate the signals
    contained in it using **ICA**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用`.txt`文件中的数据，使用**ICA**来分离其中的信号。
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how we can perform a blind source separation:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何进行盲源分离：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `blind_source_separation.py` file that is provided for you):'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`blind_source_separation.py`文件中）：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will use data from the `mixture_of_signals.txt` file that''s already provided
    for you. Let''s load the data:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用提供的`mixture_of_signals.txt`文件中的数据。让我们加载数据：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create the ICA object:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建ICA对象：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Reconstruct the signals based on ICA:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据ICA重建信号：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Extract the mixing matrix:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取混合矩阵：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Perform PCA for comparison:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行PCA比较：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Define a list of signals to plot them:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个信号列表以绘制它们：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Specify the colors of the plots:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定图表的颜色：
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Plot the input signal:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制输入信号：
- en: '[PRE67]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Plot the ICA-separated signals:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制ICA分离的信号：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Plot subplots with different colors:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同颜色的子图绘制：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Plot the PCA-separated signals:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制PCA分离的信号：
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Use a different color in each subplot:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个子图中使用不同的颜色：
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If you run this code, you will see three diagrams. The first diagram depicts
    the input, which is a mixture of signals:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你会看到三个图表。第一个图表展示了输入，它是由信号混合而成的：
- en: '![](img/d6630815-f97e-4984-9dee-d55cfd91dd36.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d6630815-f97e-4984-9dee-d55cfd91dd36.png)'
- en: 'The second diagram depicts the signals, separated using ICA:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图表展示了使用ICA分离的信号：
- en: '![](img/021cd718-0d49-4cdb-9ef6-7d77696e5967.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/021cd718-0d49-4cdb-9ef6-7d77696e5967.png)'
- en: 'The third diagram depicts the signals, separated using PCA:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第三张图展示了使用PCA分离的信号：
- en: '![](img/02599066-72d7-4313-9bcd-6c8be9fdc2bd.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02599066-72d7-4313-9bcd-6c8be9fdc2bd.png)'
- en: How it works...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: ICA is a computational processing method that's used to separate a multivariant
    signal into its additive subcomponents, assuming that there is a mutual statistical
    independence of the source of non-Gaussian signals. This is a special case of
    blind source separation. This method finds the independent components, maximizing
    the statistical independence of the estimated components.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ICA是一种计算处理方法，用于将多变量信号分离成其加性子分量，假设非高斯信号的来源之间存在相互的统计独立性。这是盲源分离的一个特例。该方法通过最大化估计组件的统计独立性来找到独立成分。
- en: There's more…
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: An example of the application of ICA algorithms is in the field of **electroencephalography**
    (**EEG**), but it has also been widely exploited in the separation of the **electrocardiogram**
    (**ECG**) of the fetus from that of the `mother.ICA` techniques. This can be extended
    to the analysis of non-physical data that's either semantic or linguistic. For
    example, the ICA has been applied to make a computer understand the topic of discussion
    in a set of archives of news lists.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ICA算法的应用示例在**脑电图**（**EEG**）领域，但它也被广泛用于从`mother.ICA`技术中分离出胎儿的**心电图**（**ECG**）。这可以扩展到对非物理数据的分析，这些数据可以是语义的或语言的。例如，ICA已被应用于使计算机理解一组新闻列表存档中的讨论主题。
- en: See also
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Official documentation of the `sklearn.decomposition.FastICA` function: [https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.FastICA.html](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.FastICA.html)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sklearn.decomposition.FastICA`函数的官方文档：[https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.FastICA.html](https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.FastICA.html)'
- en: '*BLIND SOURCE SEPARATION: Principal and Independent Component Analysis* (from
    Massachusetts Institute of Technology): [http://www.mit.edu/~gari/teaching/6.555/LECTURE_NOTES/ch15_bss.pdf](http://www.mit.edu/~gari/teaching/6.555/LECTURE_NOTES/ch15_bss.pdf)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*盲源分离：主成分分析和独立成分分析原理*（来自麻省理工学院）：[http://www.mit.edu/~gari/teaching/6.555/LECTURE_NOTES/ch15_bss.pdf](http://www.mit.edu/~gari/teaching/6.555/LECTURE_NOTES/ch15_bss.pdf)'
- en: Building a face recognizer using a local binary patterns histogram
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用局部二值模式直方图构建人脸识别器
- en: We are now ready to build a face recognizer. We need a face dataset for training,
    so we've provided you with a folder called `faces_dataset` that contains a small
    number of images that are sufficient for training. This dataset is a subset of
    the dataset that is available at [http://www.vision.caltech.edu/Image_Datasets/faces/faces.tar](http://www.vision.caltech.edu/Image_Datasets/faces/faces.tar).
    This dataset contains a good number of images that we can use to train a face
    recognition system.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好构建人脸识别器了。我们需要一个用于训练的人脸数据集，所以我们提供了一个名为`faces_dataset`的文件夹，其中包含足够用于训练的一小部分图像。这个数据集是[http://www.vision.caltech.edu/Image_Datasets/faces/faces.tar](http://www.vision.caltech.edu/Image_Datasets/faces/faces.tar)中可用数据集的一个子集。这个数据集包含足够多的图像，我们可以用它们来训练一个人脸识别系统。
- en: We will use a **local binary patterns histogram** to build our face recognition
    system. In our dataset, you will see different people. Our job is to build a system
    that can learn to separate these people from one another. When we see an unknown
    image, our system will assign it to one of the existing classes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**局部二值模式直方图**来构建我们的人脸识别系统。在我们的数据集中，你会看到不同的人。我们的任务是构建一个能够学会将这些人区分开来的系统。当我们看到一张未知图像时，我们的系统会将其分配到现有的某个类别中。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will see how we can build a face recognizer using a **local
    binary patterns histogram** and use a face dataset to train the model.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用**局部二值模式直方图**构建人脸识别器，并使用人脸数据集来训练模型。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how we can build a face recognizer using a local binary patterns
    histogram:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用局部二值模式直方图构建人脸识别器：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `face_recognizer.py` file that is provided for you):'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`face_recognizer.py`文件中给出）：
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s define a class to handle all of the tasks that are related to label
    encoding for the classes:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个类来处理与标签编码相关的所有任务：
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define a method to encode the labels. In the input training data, labels are
    represented by words. However, we need numbers to train our system. This method
    will define a preprocessor object that can convert words into numbers in an organized
    fashion by maintaining forward and backward mapping:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法来编码标签。在输入训练数据中，标签由单词表示。然而，我们需要数字来训练我们的系统。此方法将定义一个预处理对象，该对象可以通过维护正向和反向映射以有组织的方式将单词转换为数字：
- en: '[PRE74]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Define a method to convert a word into a number:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法将单词转换为数字：
- en: '[PRE75]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Define a method to convert the number back into the original word:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法将数字转换回原始单词：
- en: '[PRE76]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Define a method to extract the images and labels from the input folder:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个方法从输入文件夹中提取图像和标签：
- en: '[PRE77]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Recursively iterate through the input folder and extract all of the image paths:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归遍历输入文件夹并提取所有图像路径：
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Initialize the variables:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化变量：
- en: '[PRE79]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Parse the input directory for training:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析输入目录以进行训练：
- en: '[PRE80]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Read the current image in grayscale format:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以灰度格式读取当前图像：
- en: '[PRE81]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Extract the label from the folder path:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件夹路径中提取标签：
- en: '[PRE82]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Perform face detection on this image:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此图像上执行人脸检测：
- en: '[PRE83]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Extract the ROIs and return them, along with the label encoder:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取ROI并返回它们，以及标签编码器：
- en: '[PRE84]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define the main function and the path to the face cascade file:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义主函数和面部级联文件的路径：
- en: '[PRE85]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Load the face cascade file:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载人脸级联文件：
- en: '[PRE86]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create local binary patterns histogram for face recognizer objects:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为人脸识别器对象创建局部二值模式直方图：
- en: '[PRE87]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Extract the images, labels, and label encoder for this input path:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取此输入路径的图像、标签和标签编码器：
- en: '[PRE88]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Train the face recognizer using the data that we extracted:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们提取的数据训练人脸识别器：
- en: '[PRE89]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Test the face recognizer on unknown data:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在未知数据上测试人脸识别器：
- en: '[PRE90]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Load the image:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载图像：
- en: '[PRE91]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Determine the location of the face using the face detector:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用人脸检测器确定人脸的位置：
- en: '[PRE92]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'For each face ROI, run the face recognizer:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个面部ROI，运行人脸识别器：
- en: '[PRE93]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Convert the label into a word:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签转换为单词：
- en: '[PRE94]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Overlay the text on the output image and display it:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出图像上叠加文本并显示：
- en: '[PRE95]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Check whether the user pressed the *Esc* key. If so, break out of the loop:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户是否按下了*Esc*键。如果是，则跳出循环：
- en: '[PRE96]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: If you run this code, you will get an output window that displays the predicted
    outputs for test images. You can press the *Space* button to keep looping. There
    are three different people in the test images.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你将得到一个输出窗口，显示测试图像的预测输出。你可以按*空格*按钮以保持循环。测试图像中有三个人。
- en: How it works...
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Local Binary Patterns Histogram algorithm is based on a non-parametric operator
    that synthesizes the local structure of an image. At a particular pixel, the LBP
    operator associates an ordered binary sequence of color intensity comparisons
    between that pixel and the pixels belonging to the considered neighborhood. In
    particular, if the intensity of the central pixel is greater than or equal to
    the intensity of the adjacent pixel, then a value of 1 is assigned. Otherwise,
    0 is assigned. Therefore, for a neighborhood of 8 pixels, for example, there will
    be 2⁸ possible combinations.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本地二值模式直方图算法基于一个非参数算子，该算子综合了图像的局部结构。在特定的像素点，LBP算子将该像素与属于考虑的邻域像素之间的颜色强度比较的有序二进制序列关联起来。特别是，如果中心像素的强度大于或等于相邻像素的强度，则分配一个值为1。否则，分配0。因此，对于8像素的邻域，例如，将有2⁸种可能的组合。
- en: There's more…
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To apply this operator to the face recognition problem, the idea is to divide
    the image into *m* local regions and extract a histogram from each of them. The
    vector of the features to be extracted consists of the concatenation of these
    local histograms.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此算子应用于面部识别问题，想法是将图像划分为*m*个局部区域，并从每个区域中提取直方图。要提取的特征向量由这些局部直方图的连接组成。
- en: See also
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Local Binary Patterns* *Histogram*: [http://docs.opencv.org/2.4/modules/contrib/doc/facerec/facerec_tutorial.html#local-binary-patterns-histograms](http://docs.opencv.org/2.4/modules/contrib/doc/facerec/facerec_tutorial.html#local-binary-patterns-histograms)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本地二值模式* *直方图*：[http://docs.opencv.org/2.4/modules/contrib/doc/facerec/facerec_tutorial.html#local-binary-patterns-histograms](http://docs.opencv.org/2.4/modules/contrib/doc/facerec/facerec_tutorial.html#local-binary-patterns-histograms)'
- en: Recognizing faces using the HOG-based model
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于HOG的模型进行面部识别
- en: By face recognition, we mean the process that returns the position of the faces
    that are present in an image. In the *Building a face detector using Haar cascades*
    recipe, we already addressed this topic. In this recipe, we will use the `face_recognition`
    library to perform a series of operations on these faces.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 通过面部识别，我们指的是返回图像中存在的人脸位置的过程。在*使用Haar级联构建面部检测器*的配方中，我们已经讨论了这个问题。在这个配方中，我们将使用`face_recognition`库对这些面部执行一系列操作。
- en: 'The focal objective of face recognition consists of detecting the characteristics
    of a face and ignoring everything else that surrounds it. This is a feature on
    multiple commercial devices, and it allows you to establish when and how to apply
    focus in an image so that you can capture it. In the world of computer vision,
    it is customary to divide the family of face detection algorithms into two major
    categories. What distinguishes these two categories is their different uses of
    information, derived from a priori knowledge of the structure and properties of
    the face:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 面部识别的主要目标是检测面部特征，忽略围绕它的所有其他内容。这是许多商业设备上的一个特性，它允许你确定何时以及如何在一个图像中应用焦点，以便你可以捕捉到它。在计算机视觉的世界里，通常将面部检测算法家族分为两大类。这两个类别之间的区别在于它们对信息的不同使用，这些信息来自对面部结构和特性的先验知识：
- en: The first category includes methods based on the extraction of specification
    features
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一类包括基于提取规格特征的算法
- en: The second category adopts a global approach to image analysis
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二类采用全局方法进行图像分析
- en: Getting ready
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: In this recipe, we will see how we can use the `face_recognition` library to
    perform face recognition from a complex image. Before proceeding, install the `face_recognition`
    library. This library is based on the `dlib` library, which must be installed
    before we can go any further. `dlib` is a modern C++ toolkit that contains machine
    learning algorithms and tools for creating complex software in C++ to solve real-world
    problems. You can find information on installing the package at [https://pypi.org/project/face_recognition/](https://pypi.org/project/face_recognition/).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何使用`face_recognition`库从复杂图像中执行面部识别。在继续之前，请安装`face_recognition`库。这个库基于`dlib`库，我们必须在继续之前安装它。`dlib`是一个现代的C++工具包，它包含机器学习算法和用于在C++中创建复杂软件以解决现实世界问题的工具。您可以在[https://pypi.org/project/face_recognition/](https://pypi.org/project/face_recognition/)找到有关安装该包的信息。
- en: How to do it...
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how we can recognize faces using a HOG-based model:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用基于HOG的模型来识别面部：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `FaceRecognition.py` file that is provided for you):'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`FaceRecognition.py`文件中给出）：
- en: '[PRE97]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The **Python Imaging Library** (**PIL**) is a free library for the Python programming
    language that adds support for opening, manipulating, and saving many different
    image file formats. `face_recognition` is a Python library that recognizes and
    manipulates faces from Python scripts or from the command line.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python图像库**（**PIL**）是Python编程语言的免费库，它增加了打开、操作和保存许多不同图像文件格式的支持。`face_recognition`是一个Python库，可以从Python脚本或命令行中识别和操作面部。'
- en: 'Let''s load the `family.jpg` file into a NumPy array:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`family.jpg`文件加载到NumPy数组中：
- en: '[PRE98]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We will now find all of the faces in the image using the default HOG-based
    model:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用默认的基于HOG的模型在图像中找到所有的面部：
- en: '[PRE99]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Define a method to convert words into numbers:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一种将单词转换为数字的方法：
- en: '[PRE100]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Print the location of each face in this image:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印图像中每个面部位置：
- en: '[PRE101]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, we need to access the actual face itself:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要访问实际的面部本身：
- en: '[PRE102]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: A thumbnail of each recognized face will be returned.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回每个识别出的面部的缩略图。
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**Histogram of Oriented Gradients** (**HOG**) is a feature descriptor that''s
    used for object recognition. The algorithm counts the occurrences of the orientation
    of the gradient in localized portions of an image. It differs from other techniques
    that are used for the same purpose (scale-invariant feature transforms, edge orientation
    histograms, shape contexts) because it uses a dense grid of uniformly spaced cells
    and uses localized superimposed normalization to improve accuracy.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**方向梯度直方图**（**HOG**）是一种用于物体识别的特征描述符。该算法计算图像局部区域中梯度方向的出现的次数。与其他用于相同目的的技术（尺度不变特征变换、边缘方向直方图、形状上下文）不同，因为它使用均匀分布的密集网格单元，并使用局部叠加归一化来提高准确性。'
- en: There's more…
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The first to introduce this technology were Navneet Dalal and Bill Triggs (2005),
    researchers of the **Institut national de recherche en informatique et en automatique** (**INRIA**),
    while they were studying the problem of pedestrian detection in static images.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 首次介绍这项技术的是Navneet Dalal和Bill Triggs（2005），他们是**国家信息与自动化研究所**（**INRIA**）的研究员，当时他们正在研究静态图像中行人检测的问题。
- en: See also
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Official documentation of the `face_recognition` library: [https://github.com/ageitgey/face_recognition](https://github.com/ageitgey/face_recognition)
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`face_recognition`库的官方文档：[https://github.com/ageitgey/face_recognition](https://github.com/ageitgey/face_recognition)'
- en: '*Histograms of Oriented Gradients for Human Detection* (by Navneet Dalal and
    Bill Triggs from INRIA): [https://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf](https://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf)'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向人类检测的定向梯度直方图*（由INRIA的Navneet Dalal和Bill Triggs编写）：[https://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf](https://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf)'
- en: Facial landmark recognition
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面部特征点识别
- en: Face recognition is also complicated because of its orientation. The same face,
    directed in different directions from that of the observer, can induce the algorithm
    to identify it as a different face. To solve this problem, we can use facial landmarks,
    which are specific points on the face such as eyes, eyebrows, lips, nose, and
    so on. By using this technique, you can identify as many as 68 points on any face.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其方向性，面部识别也很复杂。同一个面部，从观察者的不同方向看去，可能会让算法将其识别为不同的面部。为了解决这个问题，我们可以使用面部特征点，这些点位于面部上的特定位置，如眼睛、眉毛、嘴唇、鼻子等。通过使用这种技术，你可以在任何面部上识别多达68个点。
- en: Getting ready
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will see how we can extract facial features as facial landmarks.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何提取面部特征作为面部特征点。
- en: How to do it...
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see how we can perform facial landmark recognition:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何执行面部特征点识别：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `FaceLandmarks.py` file that is provided for you):'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`FaceLandmarks.py`文件中给出）：
- en: '[PRE103]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let''s load the `ciaburro.jpg` file into a NumPy array:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`ciaburro.jpg`文件加载到NumPy数组中：
- en: '[PRE104]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Let''s find all facial features in all of the faces in the image:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在图像中的所有面部中找到所有面部特征：
- en: '[PRE105]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Print the number of faces that were recognized in the image:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印图像中识别到的面部数量：
- en: '[PRE106]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The following result is returned:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE107]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a PIL imagedraw object so that we can draw on the picture:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个PIL imagedraw对象，以便我们可以在图片上绘制：
- en: '[PRE108]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'At this point, we will insert a cycle that returns the position of the points
    for each facial feature that''s included in the list and trace a line to the image:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们将插入一个循环，返回列表中每个面部特征的点位置，并在图像上绘制线条：
- en: '[PRE109]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'First, we print the location of each facial feature in this image:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们打印出此图像中每个面部特征的位置：
- en: '[PRE110]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Then we trace out each facial feature in the image with a line:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们用线条在图像中追踪每个面部特征：
- en: '[PRE111]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Finally, we draw the image with the highlighted landmarks:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们绘制带有突出显示特征点的图像：
- en: '[PRE112]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'In the following image, we can see the input image and the image with highlighted
    landmarks:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，我们可以看到输入图像和带有突出显示特征点的图像：
- en: '![](img/009c45a4-9604-4d87-88ed-674d94796546.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/009c45a4-9604-4d87-88ed-674d94796546.png)'
- en: 'In addition, the positions of the landmarks are printed as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，特征点的位置如下打印：
- en: '![](img/1aceb22e-4627-4676-ab75-4edfa0edce47.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1aceb22e-4627-4676-ab75-4edfa0edce47.png)'
- en: How it works...
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we learned how to extract facial landmarks from an image and
    how to draw these points on the same image. The following landmarks were detected:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何从图像中提取面部特征点，以及如何在同一图像上绘制这些点。以下特征点被检测到：
- en: '`chin`'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`下巴`'
- en: '`left_eyebrow`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`左眉毛`'
- en: '`right_eyebrow`'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`右眉毛`'
- en: '`nose_bridge`'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`鼻梁`'
- en: '`nose_tip`'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`鼻尖`'
- en: '`left_eye`'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`左眼`'
- en: '`right_eye`'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`右眼`'
- en: '`top_lip`'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`上嘴唇`'
- en: '`bottom_lip`'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`下嘴唇`'
- en: For each feature that was detected, connecting lines of the detection points
    were drawn to show the contours.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检测到的每个特征，连接检测点的线条被绘制出来以显示轮廓。
- en: There's more…
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'To extract facial landmarks, the `face_recognition` library was used. This
    library performed this task by using the method that was introduced by Vahid Kazemi
    and Josephine Sullivan in the following paper: *One Millisecond Face Alignment
    with an Ensemble of Regression Trees*. To estimate the face''s landmark positions,
    an ensemble of regression trees was used.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取面部特征点，使用了`face_recognition`库。这个库通过使用Vahid Kazemi和Josephine Sullivan在以下论文中介绍的方法来完成这项任务：*One
    Millisecond Face Alignment with an Ensemble of Regression Trees*。为了估计面部特征点的位置，使用了一个回归树集成。
- en: See also
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Official documentation of the `face_recognition` library: [https://github.com/ageitgey/face_recognition](https://github.com/ageitgey/face_recognition)
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`face_recognition`库的官方文档：[https://github.com/ageitgey/face_recognition](https://github.com/ageitgey/face_recognition)'
- en: '*One Millisecond Face Alignment with an Ensemble of Regression Trees* (by Vahid
    Kazemi and Josephine Sullivan): [http://www.csc.kth.se/~vahidk/papers/KazemiCVPR14.pdf](http://www.csc.kth.se/~vahidk/papers/KazemiCVPR14.pdf)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*One Millisecond Face Alignment with an Ensemble of Regression Trees*（由Vahid
    Kazemi和Josephine Sullivan）：[http://www.csc.kth.se/~vahidk/papers/KazemiCVPR14.pdf](http://www.csc.kth.se/~vahidk/papers/KazemiCVPR14.pdf)'
- en: User authentication by face recognition
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过面部识别进行用户身份验证
- en: Authentication technologies based on facial recognition have been a consolidated
    reality for several decades now. We no longer have to carry pocket cards, store
    it on the phone, or use mnemonics to remember a different one each time, if we
    are so considerate to change it often. What we need to do is authenticate that
    which we already had it with us. To do this, we just look at our webcam. An identification
    system based on facial recognition tries to identify a person by comparing the
    image of the face that was just acquired with those present in a database to find
    a possible correspondence. This leads to either allowing or prohibiting access.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 基于面部识别的认证技术已经是一个巩固的现实了几十年。如果我们如此体贴地经常更换它，我们不再需要携带口袋卡，存储在手机上，或使用记忆术来记住每次都不同的一个。我们需要做的是验证我们已有的东西。为此，我们只需看看我们的网络摄像头。基于面部识别的识别系统试图通过将刚刚获取的面部图像与数据库中现有的图像进行比较来识别一个人，以找到可能的对应关系。这会导致允许或禁止访问。
- en: Getting ready
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will see how we can build an identification system based
    on facial recognition using the `face_recognition`  library.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用`face_recognition`库构建基于面部识别的识别系统。
- en: How to do it...
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how we can perform user authentication by using face recognition:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过使用面部识别来执行用户认证：
- en: 'Create a new Python file and import the following packages (the full code is
    given in the `UserAuthentification.py` file that is provided for you):'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python文件并导入以下包（完整的代码在提供的`UserAuthentification.py`文件中给出）：
- en: '[PRE113]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Let''s load all of the image files into NumPy arrays:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将所有图像文件加载到NumPy数组中：
- en: '[PRE114]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Three images have been loaded: the first two images refer to the faces we''ve
    already seen, while the third is the image to be compared (`tiziana`).'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 已加载三张图像：前两张图像指的是我们之前看到的面孔，而第三张是要比较的图像（`tiziana`）。
- en: 'Get the face encodings for each face in each image file:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取每个图像文件中每个面孔的面部编码：
- en: '[PRE115]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Let''s define the known faces:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义已知的面孔：
- en: '[PRE116]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Let''s compare the known faces with the unknown face we just loaded:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们比较已知面孔与我们刚刚加载的未知面孔：
- en: '[PRE117]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Finally, we will print the results of the comparison:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将打印比较的结果：
- en: '[PRE118]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The following results are returned:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下结果：
- en: '[PRE119]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: As we can see, the authentication system recognized the user as Tiziana.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，认证系统识别用户为Tiziana。
- en: How it works...
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we learned how to build an identification system based on facial
    recognition. To do this, we extracted some basic measures from every face in the
    known database. In doing so, we were able to compare these basic measures with
    the basic measures of other faces that require authentication.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了如何构建基于面部识别的识别系统。为此，我们从已知数据库中的每个面孔中提取了一些基本度量。通过这样做，我们能够将这些基本度量与其他需要认证的面孔的基本度量进行比较。
- en: 'These measurements were made using a deep convolutional neural network. The
    learning process works by analyzing three images simultaneously:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这些度量是使用深度卷积神经网络进行的。学习过程通过同时分析三张图像来工作：
- en: An image that contains the face of a known person (anchor)
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含已知人员面孔的图像（锚点）
- en: Another image of the same known person (positive)
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一已知人员的另一张图像（正面）
- en: An image of a completely different person (negative)
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完全不同的人的图像（负面）
- en: At this point, the algorithm examines the measures it is generating for each
    of these three images. Then it adjusts the weights of the neural network to make
    sure that the measurements that were generated for faces 1 and 2 are slightly
    closer, while the measures for faces 2 and 3 are slightly more distant. This technique
    is called `Triplet Loss`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，算法会检查为这三张图像各自生成的度量。然后它调整神经网络的权重，以确保为面孔1和2生成的度量稍微接近一些，而面孔2和3的度量稍微远一些。这种技术被称为`Triplet
    Loss`。
- en: There's more…
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: So far, we have said that the secret to the success of an algorithm based on
    machine learning lies in the number of examples that are used in the learning
    phase. The greater the number, the greater the accuracy of the model. In the cases
    that we dealt with in this chapter, this cannot be considered valid. This is because,
    in the algorithms for facial recognition, the examples at our disposal were very
    limited.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们说过，基于机器学习的算法成功的关键在于学习阶段使用的示例数量。数量越多，模型的准确性就越高。在我们本章处理的情况中，这不能被认为是有效的。这是因为，在面部识别算法中，我们可用的示例非常有限。
- en: Therefore, the construction and formation of a typical convolutional neural
    network will not work because it cannot learn the required functionality with
    the amount of data that's available. In these cases, we use a **one-shot learning**
    approach in which we construct a similarity function that compares two images
    and tells you if there is a match.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，典型的卷积神经网络的结构和形成将不会工作，因为它无法使用现有数据量学习所需的功能。在这些情况下，我们采用**单次学习**方法，其中我们构建一个相似度函数，该函数比较两个图像并告诉你是否存在匹配。
- en: See also
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Official documentation of the `face_recognition` library: [https://github.com/ageitgey/face_recognition](https://github.com/ageitgey/face_recognition)
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`face_recognition` 库的官方文档：[https://github.com/ageitgey/face_recognition](https://github.com/ageitgey/face_recognition)'
- en: '*One-shot learning* (from Wikipedia): [https://en.wikipedia.org/wiki/One-shot_learning](https://en.wikipedia.org/wiki/One-shot_learning)'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单次学习**（来自维基百科）：[https://en.wikipedia.org/wiki/One-shot_learning](https://en.wikipedia.org/wiki/One-shot_learning)'
- en: '*One-shot learning of simple visual concepts* (from MIT): [https://web.mit.edu/jgross/Public/lake_etal_cogsci2011.pdf](https://web.mit.edu/jgross/Public/lake_etal_cogsci2011.pdf)'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单视觉概念的单次学习**（来自麻省理工学院）：[https://web.mit.edu/jgross/Public/lake_etal_cogsci2011.pdf](https://web.mit.edu/jgross/Public/lake_etal_cogsci2011.pdf)'
- en: '*Siamese/Triplet Networks* (from Virginia Tech University): [https://filebox.ece.vt.edu/~jbhuang/teaching/ece6554/sp17/lectures/Lecture_08_Siamese_Triplet_Networks.pdf](https://filebox.ece.vt.edu/~jbhuang/teaching/ece6554/sp17/lectures/Lecture_08_Siamese_Triplet_Networks.pdf)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Siamese/Triplet 网络**（来自弗吉尼亚理工大学）：[https://filebox.ece.vt.edu/~jbhuang/teaching/ece6554/sp17/lectures/Lecture_08_Siamese_Triplet_Networks.pdf](https://filebox.ece.vt.edu/~jbhuang/teaching/ece6554/sp17/lectures/Lecture_08_Siamese_Triplet_Networks.pdf)'
