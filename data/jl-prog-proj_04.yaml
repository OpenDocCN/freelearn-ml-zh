- en: Building the Wiki Game Web Crawler
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Wiki 游戏网络爬虫
- en: Wow, [Chapter 3](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml), *Setting Up the
    Wiki Game*, was quite a ride! Laying the foundation of our Wikipedia game took
    us on a real learning *tour-de-force*. After the quick refresher on how the web
    and web pages work, we dived deeper into the key parts of the language, studying
    the dictionary data structure and its corresponding data type, conditional expressions,
    functions, exception handling, and even the very handy piping operator (`|>`).
    In the process, we built a short script that uses a couple of powerful third-party
    packages, `HTTP` and `Gumbo`, to request a web page from Wikipedia, parse it as
    an HTML DOM, and extract all internal links from within the page. Our script is
    part of a proper Julia project, which employs `Pkg` to efficiently manage dependencies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，[第 3 章](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml)，*设置 Wiki 游戏*，真是一次刺激的旅程！为我们维基百科游戏打下基础带我们经历了一场真正的学习之旅。在快速回顾了网络和网页的工作原理之后，我们深入研究了语言的关键部分，研究了字典数据结构和相应的数据类型、条件表达式、函数、异常处理，甚至非常实用的管道操作符（`|>`）。在这个过程中，我们构建了一个简短的脚本，该脚本使用几个强大的第三方包
    `HTTP` 和 `Gumbo` 从维基百科请求网页，将其解析为 HTML DOM，并从页面中提取所有内部链接。我们的脚本是一个完整的 Julia 项目的一部分，该项目使用
    `Pkg` 来高效管理依赖项。
- en: 'In this chapter, we''ll continue the development of our game, implementing
    the complete workflow and the gameplay. Even if you are not a seasoned developer,
    it''s easy to imagine that even a simple game like this will end up with multiple
    logical parts. We could maybe have a module for the Wikipedia page crawler, one
    for the gameplay itself, and one for the UI (the web app that we''ll create in
    the next chapter). Breaking down a problem into smaller parts always makes for
    a simpler solution. And, that''s especially true when writing code—having small,
    specialized functions, grouped by responsibility, makes the software easier to
    reason about, develop, extend, and maintain. In this chapter, we''ll learn about
    Julia''s constructs for structuring the code, and we''ll discuss a few more key
    elements of the language: the type system, constructors, methods, and multiple
    dispatch.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续开发我们的游戏，实现完整的流程和游戏玩法。即使你不是经验丰富的开发者，也容易想象这样一个简单的游戏最终会有多个逻辑部分。我们可能有一个用于维基百科页面爬虫的模块，一个用于游戏本身，还有一个用于
    UI（我们将在下一章中创建的 Web 应用）。将问题分解成更小的部分总是会使解决方案更简单。而且，这在编写代码时尤其如此——拥有小型、专业的函数，按责任分组，使得软件更容易推理、开发、扩展和维护。在本章中，我们将学习
    Julia 的代码结构化构造，并讨论语言的一些更多关键元素：类型系统、构造函数、方法和多态。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '*Six Degrees of Wikipedia*, the gameplay'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*维基百科的六度分隔*，游戏玩法'
- en: Organizing our code using modules and loading code from multiple files (the
    so-called **mixin behavior**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块组织我们的代码和从多个文件加载代码（所谓的 **mixin 行为**）
- en: Types and the type system, which are key to Julia's flexibility and performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型以及类型系统，这是 Julia 灵活性和性能的关键
- en: Constructors, special functions which allow us to create new instances of our
    types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数，特殊函数，允许我们创建我们类型的实例
- en: Methods and multiple dispatch, some of the most important aspects of the language
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法和多态，这是语言最重要的方面之一
- en: Interacting with relational databases (specifically, MySQL)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与关系型数据库交互（特别是 MySQL）
- en: I hope you are ready to dive in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你已经准备好深入研究了。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Julia package ecosystem is under continuous development and new package
    versions are released on a daily basis. Most of the times this is great news,
    as new releases bring new features and bug fixes. However, since many of the packages
    are still in beta (version 0.x), any new release can introduce breaking changes.
    As a result, the code presented in the book can stop working. In order to ensure
    that your code will produce the same results as described in the book, it is recommended
    to use the same package versions. Here are the external packages used in this
    chapter and their specific versions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的包生态系统正在持续发展中，并且每天都有新的包版本发布。大多数时候，这是一个好消息，因为新版本带来了新功能和错误修复。然而，由于许多包仍然处于测试版（版本
    0.x），任何新版本都可能引入破坏性更改。因此，书中展示的代码可能会停止工作。为了确保你的代码能够产生与书中描述相同的结果，建议使用相同的包版本。以下是本章使用的外部包及其具体版本：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to install a specific version of a package you need to run:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装特定版本的包，你需要运行：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively you can install all the used packages by downloading the Project.toml
    file provided with the chapter and using `pkg>` instantiate as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过下载本章提供的Project.toml文件并使用`pkg>`实例化来安装所有使用的包：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Six Degrees of Wikipedia, the gameplay
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维基百科六度分隔游戏，游戏玩法
- en: As we've seen in the previous chapter, the **Six Degrees of Wikipedia game**
    is a play on the concept of the *six degrees of separation* theory—the idea that
    all living things (and pretty much everything in the world) are six or fewer steps
    away from each other. For example, a chain of *a friend of a friend* can be made
    to connect any two people in a maximum of six steps.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，**维基百科六度分隔游戏**是对六度分隔理论概念的戏仿——即所有生物（以及世界上几乎所有事物）彼此之间相隔六步或更少。例如，一个“朋友的朋友”的链条可以在最多六步内连接任何两个人。
- en: For our own game, the goal of the player is to link any two given Wikipedia
    articles, passing through six or fewer other Wikipedia pages. In order to make
    sure that the problem has a solution (the *six degrees of separation* theory has
    not been demonstrated) and that indeed there is a path from our starting article
    to the end article, we'll pre-crawl the full path. That is, we'll begin with a
    random Wikipedia page, which will be our starting point, and we'll link through
    a number of pages toward our destination, the end article. The algorithm for picking
    the next linked page will be the simplest—we'll just pick any random internal
    link.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们自己的游戏，玩家的目标是连接任意两个给定的维基百科文章，通过六个或更少的其他维基百科页面。为了确保问题有解决方案（六度分隔理论尚未得到证实）并且确实存在从起始文章到结束文章的路径，我们将预先爬取完整路径。也就是说，我们将从一个随机的维基百科页面开始，这将是我们的起点，然后通过多个页面链接到我们的目的地，即结束文章。选择下一个链接页面的算法将是最简单的——我们只需随机选择任何内部链接。
- en: To make things more interesting, we will also offer a difficulty setting—easy,
    medium, or hard. This will affect how far apart the start page and the end page
    will be. For an easy game, they will be two pages away, for medium, four, and
    for hard, six. Of course, this logic in not super rigorous. Yes, intuitively,
    we can say that two articles that are further apart will be less related and harder
    to link. But, it's also possible that the player will find a shorter path. We
    won't worry about that, though.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更有趣，我们还将提供难度设置——简单、中等或困难。这将影响起始页面和结束页面之间的距离。对于简单游戏，它们相隔两页，对于中等，四页，对于困难，六页。当然，这个逻辑并不非常严格。是的，直观上，我们可以这样说，相隔更远的文章之间关系较少，更难连接。但，玩家也可能找到更短的路径。尽管如此，我们不会担心这一点。
- en: The game will also allow the players to go back if they can't find the solution
    in the maximum number of steps.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏还将允许玩家在最多步数内找不到解决方案时返回。
- en: Finally, if the player gives up, we'll add an option to show the solution—the
    path we found from the start article to the destination.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果玩家放弃，我们将添加一个选项来显示解决方案——从起始文章到目标文章的路径。
- en: This sounds exciting—let's write some code!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很令人兴奋——让我们写一些代码吧！
- en: Some additional requirements
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些额外的要求
- en: 'In order to follow through this chapter, you will need the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章，你需要以下内容：
- en: A working Julia installation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的Julia安装
- en: An internet connection
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有互联网连接
- en: A text editor
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Organizing our code
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织我们的代码
- en: Up to this point, we've been mostly coding at the REPL. Recently, in the previous
    chapter, we've started to rely more on the IDE to whip up short Julia files.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要在REPL中进行编码。最近，在上一章中，我们开始更多地依赖IDE来快速创建简短的Julia文件。
- en: But, as our skillset grows and we develop more and more ambitious projects,
    so will grow the complexity of our programs. This, in turn, will lead to more
    lines of code, more logic, and more files—and more difficulties in maintaining
    and understanding all these down the line. As the famous coding axiom goes, the
    code is read many more times than it is written—so we need to plan accordingly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着我们的技能集的增长和越来越雄心勃勃的项目的发展，我们程序的复杂性也将增长。这反过来又会导致代码行数、逻辑和文件的增加——以及维护和理解所有这些的困难增加。正如著名的编码公理所说，代码被阅读的次数远多于被编写的次数——因此我们需要相应地规划。
- en: Each language comes with its own philosophy and toolset when it comes to code
    organization. In Julia, we have files, modules, and packages. We'll learn about
    all of these next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言在代码组织方面都有自己的哲学和工具集。在Julia中，我们有文件、模块和包。我们将在下一章中了解所有这些。
- en: Using modules to tame our code
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块来驯服我们的代码
- en: Modules group together related functions, variables, and other definitions.
    But, they are not just organizational units—they are language constructs that
    can be understood as variable workspaces. They allow us to define variables and
    functions without worrying about name conflicts. Julia's `Module` is one of the
    cornerstones of the language—a key structural and logical entity that helps make
    code easier to develop, understand, and maintain. We'll make good use of modules
    by architecting our game around them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模块将相关的函数、变量和其他定义组合在一起。但，它们不仅仅是组织单元——它们是语言结构，可以理解为变量工作空间。它们允许我们定义变量和函数，而不用担心名称冲突。Julia
    的 `Module` 是语言的基础之一——一个关键的架构和逻辑实体，有助于使代码更容易开发、理解和维护。我们将通过围绕模块构建我们的游戏来充分利用模块。
- en: 'A module is defined using the `module <<name>>...end` construct:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是通过使用 `module <<name>>...end` 结构定义的：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's start a new REPL session and look at a few examples.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个新的 REPL 会话，看看一些例子。
- en: Say we want to write a function that retrieves a random Wikipedia page—it's
    one of our game's features. We could call this function `rand`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个函数来检索一个随机的维基百科页面——这是我们的游戏功能之一。我们可以称这个函数为 `rand`。
- en: 'As you may suspect, creating random *things* is a pretty common task, so we''re
    not the first ones to think about it. You can see for yourself. Try this at the
    REPL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所怀疑的，创建随机的 *东西* 是一项相当常见的任务，所以我们不是第一个考虑它的人。您可以亲自查看。在 REPL 中尝试这个：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Turns out, 56 `rand` methods are already defined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，已经定义了 56 个 `rand` 方法。
- en: 'This will make it difficult to add our own variant:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使得添加我们自己的变体变得困难：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our attempt to define a new `rand` method raised an error because it was already
    defined and loaded.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试定义一个新的 `rand` 方法时引发了错误，因为它已经被定义并加载。
- en: It's easy to see how this can lead to a nightmare scenario when choosing the
    names of our functions. If all the defined names would live in the same workspace,
    we'd get into endless name conflicts as we'd run out of relevant names for our
    functions and variables.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，当我们选择函数名称时，这可能导致一个噩梦般的场景。如果所有定义的名称都生活在同一个工作空间中，我们就会陷入无休止的名称冲突，因为我们将耗尽为我们的函数和变量提供的相关名称。
- en: Julia's module allows us to define separate workspaces, providing a level of
    encapsulation that separates our variables and functions from everybody else's.
    By using modules, name conflicts are eliminated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的模块允许我们定义独立的工作空间，提供一种封装级别，将我们的变量和函数与其他人的变量和函数分开。通过使用模块，我们可以消除名称冲突。
- en: 'Modules are defined within `module...end` language constructs. Try this example
    (at the REPL), where we define our `rand` function within a module called `MyModule`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是在 `module...end` 语言结构中定义的。尝试这个例子（在 REPL 中），我们在名为 `MyModule` 的模块中定义我们的 `rand`
    函数：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see from its full name, `Main.MyModule`, our newly created module,
    is actually added within another existing module called `Main`. This module, `Main`,
    is the default module within which code executed at the REPL is evaluated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从其全名 `Main.MyModule` 中所见，我们新创建的模块实际上是在另一个名为 `Main` 的现有模块中添加的。这个模块 `Main` 是
    REPL 中执行代码的默认模块。
- en: 'In order to access our newly defined function, we need to reference it within
    `MyModule`, by *dotting in*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问我们新定义的函数，我们需要在 `MyModule` 中引用它，通过 *点号连接*：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Defining modules
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模块
- en: Since modules are designed to be used with larger code bases, they're not REPL-friendly.
    Because once they are defined, we cannot extend them with extra definitions and
    we're forced to retype and redefine the whole module, and it's best to use a full-fledged
    editor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块是为与较大的代码库一起使用而设计的，它们并不适合 REPL。因为一旦它们被定义，我们就不能通过额外的定义来扩展它们，我们必须重新输入并重新定义整个模块，因此最好使用一个完整的编辑器。
- en: Let's create a new folder to host our code. Within it, we'll want to create
    a new folder called `modules/`. Then, within the `modules/` folder, add three
    files—`Letters.jl`, `Numbers.jl`, and `module_name.jl`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件夹来存放我们的代码。在其中，我们希望创建一个名为 `modules/` 的新文件夹。然后，在 `modules/` 文件夹中，添加三个文件—`Letters.jl`、`Numbers.jl`
    和 `module_name.jl`。
- en: Files containing Julia code use, by convention, the `.jl` file extension.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 Julia 代码的文件按照惯例使用 `.jl` 文件扩展名。
- en: Productive REPL sessions with Julia
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Julia 的高效 REPL 会话
- en: Why not use Julia's file-wrangling powers to set up this file structure? Let's
    take a look at how to do this, as it will come in handy in our day-to-day work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用 Julia 的文件管理能力来设置这个文件结构？让我们看看如何做这件事，因为它在我们的日常工作中会很有用。
- en: Remember, you can type `;` into the REPL, at the beginning of the line, to trigger
    the shell mode. Your cursor will change from `julia>` to `shell>` to confirm the
    change of context. In IJulia/Jupyter, you have to prefix the code in the cell
    with `;` in order to be executed in shell mode.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以在 REPL 中输入 `;`，在行的开头，以触发 shell 模式。你的光标将从 `julia>` 变为 `shell>` 以确认上下文的变化。在
    IJulia/Jupyter 中，你必须使用 `;` 作为单元格中代码的前缀，以便在 shell 模式下执行。
- en: 'Now, we can perform the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行以下操作：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Don''t forget that Julia''s shell mode calls commands as if they run straight
    into the OS Terminal—so the invoked binaries must exist on that platform. Both
    `mkdir` and `cd` are supported on all major operating systems, so we''re safe
    here. But, when it comes to creating the files, we''re out of luck—the `touch`
    command is not available on Windows. No problem though—all we need to do in this
    case is to invoke the Julia function with the same name. This will create the
    files programmatically, in a platform-agnostic way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记 Julia 的 shell 模式会像它们直接在 OS 终端中运行一样调用命令——因此被调用的二进制文件必须存在于该平台上。`mkdir` 和
    `cd` 在所有主要操作系统上都受支持，所以我们很安全。但是，当涉及到创建文件时，我们就无能为力了——在 Windows 上不可用 `touch` 命令。不过，没问题——在这种情况下，我们只需要调用具有相同名称的
    Julia 函数。这将以平台无关的方式程序化地创建文件：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to make sure that the files were created, use `readdir`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要确保文件已被创建，请使用 `readdir`：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Please make sure that you name the files exactly as indicated, respecting the
    case.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保文件名与指示的完全一致，注意大小写。
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the default editor is not your favorite Julia IDE, you can change it by
    setting one of the `JULIA_EDITOR`, `VISUAL`, or `EDITOR` environment variables
    to point to the editor of your choice. For instance, on my Mac, I can ask for
    the path to the Atom editor with the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认编辑器不是你最喜欢的 Julia IDE，你可以通过设置 `JULIA_EDITOR`、`VISUAL` 或 `EDITOR` 环境变量之一来更改它，指向你选择的编辑器。例如，在我的
    Mac 上，我可以使用以下命令获取 Atom 编辑器的路径：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then, I can set `JULIA_EDITOR` as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以将 `JULIA_EDITOR` 设置如下：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The three variables have slightly different purposes, but in this case, setting
    any of them will have the same effect—changing the default editor for the current
    Julia session. Keep in mind, though, that they have different *weights*, with
    `JULIA_EDITOR` taking precedence over `VISUAL`, which takes precedence over `EDITOR`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个变量有略微不同的用途，但在这个情况下，设置任何一个都将产生相同的效果——更改当前 Julia 会话的默认编辑器。不过，请记住，它们有不同的 *权重*，其中
    `JULIA_EDITOR` 优先于 `VISUAL`，而 `VISUAL` 优先于 `EDITOR`。
- en: Setting up our modules
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的模块
- en: 'Let''s start by editing `Letters.jl` to make it look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先编辑 `Letters.jl`，使其看起来像这样：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we have defined a module called `Letters`. In it, we added a `rand` function
    that uses Julia's `Random.rand` to return a random letter between `A` and `Z`
    in the form of a `Char`. Next, we added a function called `Letters.randstring`,
    which returns a `String` of `10` random characters. This string is generated using
    a `Char[]` array comprehension (the `_` variable name is perfectly legal in Julia
    and, by convention, it designates a variable whose value is not used) which is
    piped into the `join` function to return the string result.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `Letters` 的模块。在其中，我们添加了一个 `rand` 函数，该函数使用 Julia 的 `Random.rand`
    来返回一个 `A` 到 `Z` 之间的随机字母，形式为一个 `Char`。接下来，我们添加了一个名为 `Letters.randstring` 的函数，该函数返回一个由
    `10` 个随机字符组成的 `String`。这个字符串是通过一个 `Char[]` 数组推导式（在 Julia 中 `_` 变量名是合法的，并且按照惯例，它表示一个值未使用的变量）生成的，然后通过管道输入到
    `join` 函数中，以返回字符串结果。
- en: Please note that this is an over complicated way to generate a random string
    as Julia provides the `Random.randstring` function. But, at this point, it's important
    to exploit every opportunity to practice writing code, and I just didn't want
    to waste the chance of using Julia's comprehension syntax and the pipe operator.
    Practice makes perfect!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是一个生成随机字符串的过于复杂的方法，因为 Julia 提供了 `Random.randstring` 函数。但是，在这个阶段，重要的是要抓住每一个机会来练习编写代码，而且我并不想浪费使用
    Julia 的推导语法和管道操作符的机会。熟能生巧！
- en: Switching our focus towards the first lines of code, we declared that we'll
    be `using Random`—and we instructed the compiler to make `randstring` public via
    `export randstring`. Finally, we have also declared a constant called `MY_NAME`,
    which points to the `Letters` string (which is the name of the module itself).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的注意力转向代码的第一行，我们声明我们将 `using Random`——并指示编译器通过 `export randstring` 使 `randstring`
    公开。最后，我们还声明了一个名为 `MY_NAME` 的常量，它指向 `Letters` 字符串（即模块本身的名称）。
- en: The last line of the module, `include("module_name.jl")`, loads the contents
    of `module_name.jl` into `Letters`. The `include` function is typically used to
    load source code interactively, or to combine files in packages that are split
    into multiple source files—and we'll see how this works soon.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的最后一行，`include("module_name.jl")`，将 `module_name.jl` 的内容加载到 `Letters` 中。`include`
    函数通常用于交互式加载源代码，或将分成多个源文件的包中的文件组合在一起——我们很快就会看到它是如何工作的。
- en: 'Next, let''s edit `Number.jl`. It will have a similar `rand` function that
    will return a random `Integer` between `1` and `1_000`. It exports `halfrand`,
    a function that gets a value from `rand` and divides it by `2`. We pass the result
    of the division to the `floor` function, which will convert it to the closest
    less than or equal value. And, just like `Letters`, it also includes `module_name.jl`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编辑 `Number.jl`。它将有一个类似的 `rand` 函数，该函数将返回一个介于 `1` 和 `1_000` 之间的随机 `Integer`。它导出
    `halfrand` 函数，该函数从 `rand` 获取一个值并将其除以 `2`。我们将除法的结果传递给 `floor` 函数，该函数将将其转换为最接近的小于或等于的值。而且，就像
    `Letters` 一样，它还包括 `module_name.jl`：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Thus, for both modules, we defined a `MY_NAME` constant. We''ll reference it
    by editing the `module_name.jl` file to make it look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这两个模块，我们定义了一个 `MY_NAME` 常量。我们将通过编辑 `module_name.jl` 文件来引用它，使其看起来像这样：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code returns the corresponding value of the constant, depending on the actual
    module where we include the `module_name.jl` file. This illustrates Julia's mixin
    behavior, where included code acts as if it was written directly into the including
    file. We'll see how this works next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码返回常量的对应值，这取决于我们包含 `module_name.jl` 文件的实际模块。这说明了 Julia 的 mixin 行为，其中包含的代码表现得就像它被直接写入包含文件中一样。我们将在下一节中看到它是如何工作的。
- en: Referencing modules
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块引用
- en: Despite the fact that we are only *now* formally discussing modules, we've been
    using them all along. The `using` statement which we employed so many times takes
    as its parameter a module name. It's a key language construct that tells the compiler
    to bring the module's definitions into the current scope. Referencing functions,
    variables, and types defined in other modules is a routine part of programming
    in Julia—accessing the functionality provided by a third-party package, for example,
    revolves around bringing its main module into scope via `using`. But, `using`
    is not the only tool in Julia's arsenal. We have a few more commands at our disposal,
    such as `import`, `include`, and `export`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在只是正式讨论模块，但我们一直在使用它们。我们多次使用的 `using` 语句将其参数作为模块名称。这是一个关键的语言结构，告诉编译器将模块的定义引入当前作用域。在
    Julia 中引用其他模块中定义的函数、变量和类型是编程的常规部分——例如，访问第三方包提供的功能，围绕通过 `using` 将其主模块引入作用域。但是，`using`
    并不是 Julia 武器库中的唯一工具。我们还有几个其他命令可供使用，例如 `import`、`include` 和 `export`。
- en: The `using` directive allows us to reference functions, variables, types, and
    so on exported by other modules. This tells Julia to make the module's exported
    definitions available in the current workspace. If the definitions were exported
    by the module's author, we can invoke them without having to prefix them with
    the module's name (prefixing the name of the function with the module name represents
    the fully qualified name). But, be careful though as this is a double-edged sword—if
    two used modules export functions with the same name, the functions will still
    have to be accessed using the fully qualified name—otherwise Julia will throw
    an exception as it won't know which of the functions we refer to.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 指令允许我们引用其他模块导出的函数、变量、类型等。这告诉 Julia 使模块的导出定义在当前工作区中可用。如果这些定义是由模块的作者导出的，我们可以调用它们而无需在它们前面加上模块的名称（在函数名称前加上模块名称表示完全限定名称）。但是，请注意，这是一把双刃剑——如果两个使用的模块导出了具有相同名称的函数，仍然必须使用完全限定名称来访问这些函数——否则
    Julia 将抛出异常，因为它不知道我们指的是哪个函数。'
- en: As for `import`, it is somewhat similar, in that it also brings definitions
    from another module into scope. But, it differs in two important aspects. First,
    calling `import MyModule` would still require prefixing the definitions with the
    module's name, thereby avoiding potential name clashes. Second, if we want to
    extend functions defined in other modules with new methods, we *have* to use `import`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 `import`，它在某种程度上是相似的，因为它也将另一个模块的定义引入作用域。但是，它在两个重要方面有所不同。首先，调用 `import MyModule`
    仍然需要在定义前加上模块的名称，从而避免潜在的名称冲突。其次，如果我们想用新方法扩展其他模块中定义的函数，*必须*使用 `import`。
- en: On the other hand, `include` is conceptually different. It is used to evaluate
    the contents of a file into the current context (that is, into the current module's
    *global* scope). It's a way to reuse code by providing mixin-like behavior, as
    we have already seen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`include` 在概念上是不同的。它用于将一个文件的内容评估到当前上下文中（即当前模块的 *全局* 作用域）。这是一种通过提供类似 mixin
    的行为来重用代码的方法，正如我们之前所看到的。
- en: 'The fact that the included file is evaluated in the module''s global scope
    is a very important point. It means that, even if we include a file within a function''s
    body, the contents of the file will not be evaluated within the function''s scope,
    but within the module''s scope. To see this in action, let''s create a file called
    `testinclude.jl` in our `modules/` folder. Edit `testinclude.jl` and append this
    line of code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 被包含的文件在模块的全局作用域中评估的事实是一个非常重要的点。这意味着，即使我们在函数体中包含一个文件，文件的内容也不会在函数的作用域内评估，而是在模块的作用域内评估。为了看到这一点，让我们在我们的
    `modules/` 文件夹中创建一个名为 `testinclude.jl` 的文件。编辑 `testinclude.jl` 并添加以下代码行：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, if you run the following code in the REPL or in IJulia, you''ll see what
    I mean:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在 REPL 或 IJulia 中运行以下代码，你就能明白我的意思：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Apparently, it all worked fine. The `testinclude.jl` file was included and
    the `somevar` variable was defined. However, `somevar` was not created within
    the `testinclude` function, but as a global variable in the `Main` module. We
    can see that easily, as we can access the `somevar` variable directly:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一切正常。`testinclude.jl` 文件被包含进来，`somevar` 变量被定义了。然而，`somevar` 并不是在 `testinclude`
    函数中创建的，而是在 `Main` 模块中的全局变量。我们可以很容易地看到这一点，因为我们可以直接访问 `somevar` 变量：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Keep this behavior in mind as it can lead to hard-to-understand bugs by exposing
    variables in the global scope.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这种行为，因为它可能导致在全局作用域中暴露变量时出现难以理解的错误。
- en: Finally, `export` is used by a module's author to expose definitions, much like
    a public interface. As we've seen, exported functions and variables are brought
    into scope by the module's users via `using`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模块的作者使用 `export` 来暴露定义，就像公共接口一样。正如我们所见，导出的函数和变量是通过模块的用户通过 `using` 引入作用域的。
- en: Setting up the LOAD_PATH
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 LOAD_PATH
- en: Let's look at some examples that illustrate scoping rules when working with
    modules. Please open a new Julia REPL.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例，这些示例说明了在处理模块时作用域规则。请打开一个新的 Julia REPL。
- en: 'We''ve seen the `using` statement many times throughout the previous chapters,
    and now we understand its role—to bring another module and its definitions (variables,
    functions, types) into scope. Let''s try it with our newly created modules:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中多次看到了 `using` 语句，现在我们理解了它的作用——就是将另一个模块及其定义（变量、函数、类型）引入作用域。让我们用我们新创建的模块来试一试：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ouch, an exception! Julia informs us that it doesn't know where to find the
    `Letters` module and advises us to use `Pkg.add("Letters")` to install it. But,
    since `Pkg.add` only works with registered packages and we haven't published our
    modules to Julia's registry, that won't help. Turns out we just need to tell Julia
    where to find our code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，出现了一个异常！Julia 告诉我们它不知道在哪里找到 `Letters` 模块，并建议我们使用 `Pkg.add("Letters")` 来安装它。但是，由于
    `Pkg.add` 只与已注册的包一起工作，而我们还没有将我们的模块发布到 Julia 的注册表中，这不会有所帮助。结果是我们只需要告诉 Julia 我们代码的位置。
- en: 'When asked to bring a module into scope via `using`, Julia checks a series
    of paths to look up the corresponding files. These lookup paths are stored in
    a `Vector` called the `LOAD_PATH`—and we can append our `modules/` folder to this
    collection by using the `push!` function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当被要求通过 `using` 将一个模块引入作用域时，Julia 会检查一系列路径以查找相应的文件。这些查找路径存储在一个名为 `LOAD_PATH`
    的 `Vector` 中——我们可以通过使用 `push!` 函数将我们的 `modules/` 文件夹添加到这个集合中：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Your output might be different, but what matters is that after calling `push!`,
    the `LOAD_PATH` collection now has an extra element indicating the path to the
    `modules/` folder.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出可能会有所不同，但重要的是在调用 `push!` 之后，`LOAD_PATH` 集合现在有一个额外的元素，表示 `modules/` 文件夹的路径。
- en: In order for Julia to match the name of a module with its corresponding file,
    *the file must have exactly the same name as the module*, plus the `.jl` extension.
    It's OK for a file to include more than one module, but Julia will not be able
    to automatically find the extra ones by filename.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Julia 能够将模块的名称与其对应的文件匹配，*文件必须与模块具有完全相同的名称，加上 `.jl` 扩展名*。一个文件可以包含多个模块，但 Julia
    将无法通过文件名自动找到额外的模块。
- en: In regard to naming the modules themselves, the convention is to use CamelCase.
    Thus, we'll end up with a module called `Letters` defined in a `Letters.jl` file,
    or with a `WebSockets` module in a file named `WebSockets.jl`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模块命名的命名约定是使用驼峰式命名法。因此，我们最终会在名为`Letters.jl`的文件中定义一个名为`Letters`的模块，或者在一个名为`WebSockets.jl`的文件中定义一个名为`WebSockets`的模块。
- en: Loading modules with using
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`using`加载模块
- en: 'Now that we''ve added our folder to the `LOAD_PATH`, we''re ready to use our
    modules:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的文件夹添加到`LOAD_PATH`中，我们就可以使用我们的模块了：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, two things have happened:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，发生了两件事：
- en: All the exported definitions are now directly callable in the REPL, in our case,
    `randstring`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有导出的定义现在都可以在REPL中直接调用，在我们的例子中，是`randstring`
- en: The definitions that were not exported are accessible by *dotting into* `Letters`—for
    example, `Letters.rand()`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未导出的定义可以通过`Letters`的`dotting into`来访问——例如，`Letters.rand()`
- en: 'Let''s try it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can see what a module exports with the `names` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`names`函数查看模块导出了什么：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we want to get all the definitions of a module, exported or not, `names`
    takes a second parameter, `all`, a `Boolean`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取一个模块的所有定义，无论是否导出，`names`函数接受一个名为`all`的第二个参数，一个`Boolean`：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can easily recognize the variables and functions we defined.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地识别我们定义的变量和函数。
- en: 'As we can see, for instance, `myname` was not brought directly into scope,
    since it wasn''t exported in `Letters`. But, it turns out that we can still get
    the exported-like behavior if we explicitly tell Julia to use the function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，例如，`myname`并没有直接引入作用域，因为它在`Letters`中没有导出。但结果是，如果我们明确告诉Julia使用该函数，我们仍然可以得到类似导出的行为：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we want to bring multiple definitions from the same module directly into
    scope, we can pass a comma-separated list of names:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想直接将同一模块中的多个定义引入作用域，我们可以传递一个以逗号分隔的名称列表：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Loading modules with import
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`import`加载模块
- en: 'Now, let''s look at the effects of the `import` function, using `Numbers`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`import`函数的效果，使用`Numbers`：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can see here that, unlike `using`, the `import` function *does not bring
    into scope* the exported definitions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，与`using`不同，`import`函数*不会将导出的定义引入作用域*。
- en: 'However, explicitly importing a definition itself will bring it directly into
    scope, disregarding whether it was exported or not:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，显式导入一个定义本身会将其直接引入作用域，不考虑它是否被导出：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This snippet is equivalent to the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等同于以下代码：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Loading modules with include
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`include`加载模块
- en: Manipulating the `LOAD_PATH` works great when developing standalone apps, like
    the one we're working on now. However, this approach is not available for a package
    developer. For such instances—and for all the cases when for one reason or another
    using the `LOAD_PATH` is not an option—a common way of loading modules is by including
    their files.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发独立的程序，如我们现在正在做的，操作`LOAD_PATH`效果很好。但是，对于包开发者来说，这种方法不可用。在这种情况下——以及所有由于某种原因使用`LOAD_PATH`不是选项的情况——加载模块的常见方式是通过包含它们的文件。
- en: 'For example, we can include our `Letters` module at the REPL, as follows (start
    a new REPL session):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将我们的`Letters`模块包含在REPL中，如下所示（启动一个新的REPL会话）：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will read and evaluate the contents of the `modules/Letters.jl` file in
    the current scope. And as a result, it will define the `Letters` module within
    our current module, `Main`. But, this is not enough—at this point, none of the
    definitions within `Letters` were exported:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将读取并评估当前作用域中`modules/Letters.jl`文件的内容。结果，它将在我们的当前模块`Main`中定义`Letters`模块。但是，这还不够——在这个阶段，`Letters`中的任何定义都没有被导出：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We need to bring them into scope:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将它们引入作用域：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Not again! What just happened? This is an important distinction when using
    `include` with modules. The `Letters` module, like we just said, is included in
    the current module, `Main`, so we need to reference it accordingly:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 别再了！刚才发生了什么？当使用`include`与模块时，这是一个重要的区别。正如我们刚才说的，`Letters`模块被包含在当前模块`Main`中，因此我们需要相应地引用它：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also reference this kind of nested module hierarchy by using relative
    *paths*. For example, a dot, `.`, stands for *current module*. So, the previous
    `Main.Letters` nesting can be expressed as `.Letters`— it''s exactly the same
    thing:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用相对路径来引用这种嵌套模块层次结构。例如，一个点`.`代表`current module`。因此，之前的`Main.Letters`嵌套可以表示为`.Letters`——这正是同一件事：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Similarly, we could use two dots, `..`, to reference the parent module, three
    dots for the parent of the parent, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用两个点`..`来引用父模块，三个点用于父模块的父模块，依此类推。
- en: Nesting modules
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块嵌套
- en: As we've just seen, sometimes, the logic of our program will dictate that a
    module has to be part of another module, effectively nesting them. This is used
    with predilection when developing our own packages. The best way to organize a
    package is to expose a top module and include all the other definitions (functions,
    variables, and other modules) within it (to encapsulate the functionality). An
    example should help clarify things.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有时我们程序的逻辑会要求一个模块必须成为另一个模块的一部分，从而有效地嵌套它们。我们在开发自己的包时特别喜欢使用这种方法。组织包的最佳方式是暴露一个顶层模块，并在其中包含所有其他定义（函数、变量和其他模块）（以封装功能）。一个例子应该有助于澄清这些内容。
- en: Let's make a change—in the `Letters.jl` file, under the line saying `include("module_name.jl")`,
    go ahead and add another line—`include("Numbers.jl")`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个改变——在`Letters.jl`文件中，在说`include("module_name.jl")`的行下面，继续添加另一行——`include("Numbers.jl")`。
- en: 'With this change, the `Numbers` module will effectively be defined within the
    `Letters` module. In order to access the functions of the nested module, we *dot
    into* as deep as necessary:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个变化，`Numbers`模块将实际上在`Letters`模块内部定义。为了访问嵌套模块的功能，我们需要点进到必要的深度：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Setting up our game's architecture
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们游戏的架构
- en: Let's create a home for our game—make a new folder called `sixdegrees/`. We'll
    use it to organize our game's files. Each file will contain a module and each
    module will package related functionality. We'll make use of Julia's auto-loading
    features, which means that the filename of each module will be the same as the
    module's name, plus the `.jl` extension.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的游戏找一个家——创建一个名为`sixdegrees/`的新文件夹。我们将用它来组织我们的游戏文件。每个文件将包含一个模块，每个模块将打包相关的功能。我们将利用Julia的自动加载功能，这意味着每个模块的文件名将与模块的名称相同，加上`.jl`扩展名。
- en: 'The first thing we need to do, though, once we go into the `sixdegrees/` folder,
    is to initialize our project through `Pkg`—so we can use Julia''s dependency management
    features:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们进入`sixdegrees/`文件夹，我们首先需要通过`Pkg`初始化我们的项目——这样我们就可以使用Julia的依赖项管理功能：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We''ll be using the `HTTP` and the `Gumbo` packages, so it''s a good idea to
    add them, now that we''re dealing with dependencies:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`HTTP`和`Gumbo`包，所以在处理依赖项时，现在添加它们是个好主意：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The next thing we need is a container for Wikipedia-related code—a module that
    encapsulates the functionality for requesting an article and extracting the internal
    URLs. We already have a first iteration of the code in the `webcrawler.jl` file
    we wrote in [Chapter 3](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml), *Setting
    Up the Wiki Game*. Now, all we need to do is create a `Wikipedia` module and fill
    it up with the contents of `webcrawler.jl`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要的是一个用于存放与维基百科相关代码的容器——一个封装了请求文章和提取内部URL功能的模块。我们已经在[第3章](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml)，“设置维基游戏”中编写的`webcrawler.jl`文件中完成了代码的第一个迭代。现在，我们只需要创建一个`Wikipedia`模块，并用`webcrawler.jl`的内容填充它。
- en: 'Within the `sixdegrees` folder, create a new file called `Wikipedia.jl`. Set
    it up with the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sixdegrees`文件夹内，创建一个名为`Wikipedia.jl`的新文件。用以下代码设置它：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code should look familiar as it shares much of its logic with
    `webcrawler.jl`. But, there are some important changes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码应该看起来很熟悉，因为它与`webcrawler.jl`共享了大部分逻辑。但是，有一些重要的变化。
- en: First of all, we wrapped everything into a `module` declaration.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将一切包裹在一个`module`声明中。
- en: 'Please note a very important convention: in Julia, we do not indent the code
    within modules as this would cause the whole file to be indented, which would
    affect readability.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意一个非常重要的约定：在Julia中，我们不会在模块内部缩进代码，因为这会导致整个文件缩进，从而影响可读性。
- en: On the third line, where we used to have the link to Julia's Wikipedia entry,
    we now define a `String` constant, `RANDOM_PAGE_URL`, which points to a special
    Wikipedia URL that returns a random article. Also, we switched to the mobile version
    of the Wikipedia website, as indicated by the `en.m.` subdomains. Using the mobile
    pages will make our lives easier as they are simpler and have less markup.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们原本有Julia维基百科条目的链接，现在我们定义了一个`String`常量`RANDOM_PAGE_URL`，它指向一个特殊的维基百科URL，该URL返回一个随机文章。我们还切换到了维基百科网站的移动版本，如`en.m.`子域名所示。使用移动页面会使我们的工作更简单，因为它们更简单，标记也更少。
- en: In the `fetchpage` function, we're no longer looking for the `Content-Length`
    header and we're instead checking the `length` of the `response.body` property.
    We're doing this because requesting the special random Wikipedia page performs
    a redirect and, in the process, the `Content-Length` header is dropped.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fetchpage` 函数中，我们不再寻找 `Content-Length` 标头，而是检查 `response.body` 属性的 `length`。我们这样做是因为请求特殊的随机维基百科页面会进行重定向，在这个过程中，`Content-Length`
    标头会被丢弃。
- en: 'We have also replaced some of the logic at the bottom of the file. Instead
    of automatically fetching Julia''s Wikipedia page and dumping the list of internal
    links onto the screen, we now define two more functions: `fetchrandom` and `articlelinks`.
    These functions will be the public interface of the `Wikipedia` module, and they
    are exposed using the `export` statement. The `fetchrandom` function does exactly
    what the name says—it calls the `fetchpage` function passing in the `RANDOM_PAGE_URL`
    const, effectively fetching a random Wikipedia page. `articlelinks` returns an
    array of strings representing the linked articles.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还替换了文件底部的部分逻辑。我们不再自动获取 Julia 的维基百科页面并将内部链接列表输出到屏幕上，我们现在定义了两个额外的函数：`fetchrandom`
    和 `articlelinks`。这些函数将是 `Wikipedia` 模块的公共接口，并且通过 `export` 语句公开。`fetchrandom` 函数确实如其名所示——它调用
    `fetchpage` 函数，传入 `RANDOM_PAGE_URL` 常量，实际上是从随机维基百科页面获取。`articlelinks` 返回一个表示链接文章的字符串数组。
- en: Finally, we removed the `LINKS` constant—global variables should be avoided.
    The `extractlinks` function has been refactored accordingly, now accepting a second
    parameter, `links`, a `Vector` of `String`, which is used to maintain state during
    recursion.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移除了 `LINKS` 常量——应该避免使用全局变量。`extractlinks` 函数已经相应地重构，现在接受第二个参数，`links`，一个
    `String` 的 `Vector`，它在递归过程中用于维护状态。
- en: Checking our code
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的代码
- en: Let's make sure that, after this refactoring, our code still works as expected.
    Julia comes out of the box with unit-testing capabilities, and we'll look at these
    in [Chapter 11](8391f749-e95c-4ff9-ba40-d71c91b1d7fd.xhtml), *Creating Julia Packages*.
    For now, we'll do it the old-fashioned way, by manually running the code and inspecting
    the output.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保在这次重构之后，我们的代码仍然按预期工作。Julia 默认带有单元测试功能，我们将在第 11 章 [创建 Julia 包](8391f749-e95c-4ff9-ba40-d71c91b1d7fd.xhtml)中探讨这些内容。现在，我们将按照老方法来做，手动运行代码并检查输出。
- en: 'We''ll add a new file inside the `sixdegrees/` folder, called `six_degrees.jl`.
    Looking at its name, you can guess that it will be a plain Julia file and not
    a module. We''ll use it to orchestrate the loading of our game:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `sixdegrees/` 文件夹内添加一个新文件，命名为 `six_degrees.jl`。从其名称来看，您可以猜测它将是一个纯 Julia
    文件，而不是一个模块。我们将使用它来编排游戏的加载：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The code is straightforward and minimalistic—we use `Pkg` to activate the current
    project. Then, we include the `Wikipedia.jl` file in the current module, and then
    we ask the compiler to bring the `Wikipedia` module into scope. Finally, we use
    the previously discussed `fetchrandom` and `articlelinks` to retrieve the list
    of articles URLs from a random Wikipedia page and display it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码简单且简洁——我们使用 `Pkg` 激活当前项目。然后，我们将 `Wikipedia.jl` 文件包含到当前模块中，然后要求编译器将 `Wikipedia`
    模块引入作用域。最后，我们使用之前讨论过的 `fetchrandom` 和 `articlelinks` 来从随机维基百科页面检索文章 URL 列表并显示。
- en: 'Time to run our code! In the REPL, make sure that you `cd` into the `sixdegrees`
    folder and execute:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行我们的代码了！在 REPL 中，确保您已经 `cd` 到 `sixdegrees` 文件夹并执行：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Alternatively, you can use the run code or run file option in Visual Studio
    Code and Atom. Here''s Atom running the `six_degrees.jl` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在 Visual Studio Code 和 Atom 中使用运行代码或运行文件选项。以下是 Atom 运行 `six_degrees.jl`
    文件的情况：
- en: '![](img/254968f3-69ff-4ecc-abec-45273a13f10c.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/254968f3-69ff-4ecc-abec-45273a13f10c.png)'
- en: Building our Wikipedia crawler - take two
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的维基百科爬虫 - 第二部分
- en: Our code runs as expected, refactored and neatly packed into a module. However,
    there's one more thing I'd like us to refactor before moving on. I'm not especially
    fond of our `extractlinks` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码按预期运行，重构并整洁地打包到一个模块中。然而，在继续之前，我还有一个东西想让我们重构。我对我们的 `extractlinks` 函数并不特别满意。
- en: First of all, it naively iterates over all the HTML elements. For example, say
    that we also want to extract the title of the page—every time we want to process
    something that's not a link, we'll have to iterate over the whole document again.
    That's going to be resource-hungry and slow to run.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它天真地遍历了所有的 HTML 元素。例如，假设我们还想提取页面的标题——每次我们想要处理不是链接的内容时，我们都需要再次遍历整个文档。这将非常消耗资源，并且运行速度会变慢。
- en: Secondly, we're reinventing the wheel. In [Chapter 3](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml),
    *Setting Up the Wiki Game*, we said that CSS selectors are the *lingua franca*
    of DOM parsing. We'd benefit massively from using the concise syntax of CSS selectors
    with the underlying optimizations provided by specialized libraries.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们正在重新发明轮子。在[第三章](3184f173-ae3d-47f9-b7e9-f677947499f2.xhtml) *设置Wiki游戏*
    中，我们说CSS选择器是DOM解析的*通用语言*。如果我们使用CSS选择器的简洁语法和由专用库提供的底层优化，我们将从中获得巨大的好处。
- en: Fortunately, we don't need to look too far for this kind of functionality. Julia's
    `Pkg` system provides access to `Cascadia`, a native CSS selector library. And,
    the great thing about it is that it works hand in hand with `Gumbo`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要寻找太远就能找到这种功能。Julia的`Pkg`系统提供了对`Cascadia`的访问，这是一个本地的CSS选择器库。而且，它的一大优点是它与`Gumbo`协同工作。
- en: 'In order to use Cascadia, we need to add it to our project''s list of dependencies:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Cascadia，我们需要将其添加到我们项目的依赖列表中：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, tell Julia we''ll be using it—modify `Wikipedia.jl` so that the third
    line reads as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，告诉Julia我们将使用它——修改`Wikipedia.jl`，使其第三行如下所示：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With the help of `Cascadia`, we can now refactor the `extractlinks` function,
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Cascadia`的帮助下，我们现在可以重构`extractlinks`函数，如下所示：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let's take a closer look at all that happens here. The first thing that stands
    out is the `Selector` function. This is provided by `Cascadia` and constructs
    a new CSS selector object. The string that is passed to it as its only parameter
    is a CSS selector that reads as—all `<a>` elements that have a `href` attribute
    whose value starts with `'/wiki/'` and does not contain a column (`:`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这里发生的一切。首先引起注意的是`Selector`函数。这是由`Cascadia`提供的，它构建一个新的CSS选择器对象。传递给它作为唯一参数的字符串是一个CSS选择器，其内容为——所有具有以`'/wiki/'`开头且不包含列（`:`）的`href`属性的`<a>`元素。
- en: '`Cascadia` also exports the `eachmatch` method. More accurately, it *extends*
    the existing `Base.eachmatch` method that we''ve seen previously with regular
    expressions. This provides a familiar interface—and we''ll see how to extend methods
    later in this chapter, in the *Methods* section. The `Cascadia.eachmatch` function
    returns a `Vector` of elements that match the selector.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cascadia`还导出了`eachmatch`方法。更准确地说，它是*扩展*了我们之前看到的带有正则表达式的现有`Base.eachmatch`方法。这提供了一个熟悉的接口——我们将在本章后面的*方法*部分看到如何扩展方法。`Cascadia.eachmatch`函数返回一个匹配选择器的`Vector`元素。'
- en: 'Once we retrieve the collection of matched elements, we pass it to the `map`
    function. The `map` function is one of the most used tools in the functional programming
    toolbox. It takes as its arguments a function, `f`, and a collection, `c`—and
    it transforms the collection, `c`, by applying `f` to each element, returning
    the modified collection as the result. Its definition is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们检索到匹配的元素集合，我们就将其传递给`map`函数。`map`函数是函数式编程工具箱中最常用的工具之一。它接受一个函数`f`和一个集合`c`作为其参数——并通过将`f`应用于每个元素来转换集合`c`，返回修改后的集合作为结果。其定义如下：
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using blocks
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用块
- en: Because, in Julia, functions are first-class language constructs, they can be
    referenced and manipulated like any other type of variable. They can be passed
    as arguments to other functions or can be returned as the result of other function
    calls. The functions that take another function as their argument or return another
    function as their result are called **higher-order functions**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在Julia中，函数是一等语言构造，它们可以被引用和操作，就像任何其他类型的变量一样。它们可以作为其他函数的参数传递，或者可以作为其他函数调用的结果返回。将另一个函数作为其参数或返回另一个函数作为其结果的函数称为**高阶函数**。
- en: 'Let''s look at a simple example using `map`. We''ll take a `Vector` of `Int`,
    and we''ll apply to each element of its collection a function that doubles the
    value. You can follow along in a new REPL session (or in the accompanying IJulia
    notebook):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的`map`示例来看看。我们将取一个`Int`的`Vector`，并将一个函数应用于其集合的每个元素，该函数将值加倍。你可以在新的REPL会话（或在配套的IJulia笔记本）中跟随：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's all good, but having to define a function just to use it as a one-off
    argument for another function is inconvenient and a bit wasteful. For this reason,
    the programming languages that support functional features, including Julia, usually
    support *anonymous functions*. An anonymous function, or a *lambda*, is a function
    definition that is not bound to an identifier.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 那都是好的，但是不得不定义一个函数只是为了将其作为另一个函数的一次性参数是不方便的，而且有点浪费。出于这个原因，支持函数式特性的编程语言，包括 Julia，通常支持
    *匿名函数*。匿名函数，或称为 *lambda*，是一个没有绑定到标识符的函数定义。
- en: 'We can rewrite the preceding `map` invocation to use an anonymous function,
    which is defined on the spot by using the arrow `->` syntax:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的 `map` 调用重写为使用匿名函数，该函数通过使用箭头 `->` 语法现场定义：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the definition, `x -> x*2`, the `x` at the left of the arrow represents the
    argument that is passed into the function, while `x*2` represents the body of
    the function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义中，`x -> x*2`，箭头左边的 `x` 代表传递给函数的参数，而 `x*2` 代表函数体。
- en: 'Great! We have achieved the same end result without having to separately define
    `double`. But, what if we need to use a more complex function? For instance, note
    the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们没有必要单独定义 `double` 就达到了相同的结果。但是，如果我们需要使用更复杂的函数呢？例如，注意以下内容：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: That's pretty hard to follow! Because Julia allows us to indent our code, we
    can enhance the readability of this example to make it more palatable, but the
    result is still far from great.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这很难理解！因为 Julia 允许我们缩进我们的代码，我们可以增强这个示例的可读性，使其更加易于接受，但结果仍然远远不够好。
- en: Because these situations occur often, Julia provides the block syntax for defining
    anonymous functions. All the functions that take another function as their *first*
    argument can be used with the block syntax. Support for this kind of invocation
    is baked into the language, so you don't need to do anything—your functions will
    support it as well, out of the box, as long as the function is the first positional
    argument. In order to use it, we skip passing in the first argument when invoking
    the higher-order function—and instead, at the end of the arguments list, outside
    of the arguments tuple, we add a `do...end` block. Within this block, we define
    our lambda.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些情况经常发生，Julia 提供了用于定义匿名函数的块语法。所有将另一个函数作为其 *第一个* 参数的函数都可以使用块语法。对这种调用的支持已经内置于语言中，因此你不需要做任何事情——只要函数是第一个位置参数，你的函数就会自动支持它。为了使用它，我们在调用高阶函数时跳过传递第一个参数——而是在参数列表的末尾，在参数元组之外，添加一个
    `do...end` 块。在这个块内部，我们定义我们的 lambda。
- en: 'So, we can rewrite the previous example as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将前面的示例重写如下：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Much more readable!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读起来更加清晰！
- en: Implementing the gameplay
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏玩法
- en: Our Wikipedia parser is pretty robust now, and the addition of `Cascadia` greatly
    simplifies the code. It's time to think about the actual gameplay.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对维基百科解析器相当有信心，添加 `Cascadia` 大大简化了代码。现在是时候考虑实际的游戏玩法了。
- en: The most important thing, the core of the game, is to create the riddle—asking
    the player to find a path from the initial article to the end article. We previously
    decided that in order to be sure that a path between two articles really exists,
    we will pre-crawl all the pages, from the first to the last. In order to navigate
    from one page to the next, we'll simply randomly pick one of the internal URLs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，游戏的精髓是创建谜题——要求玩家从初始文章找到通往结束文章的路径。我们之前决定，为了确保两篇文章之间确实存在路径，我们将预先爬取所有页面，从第一页到最后一页。为了从一个页面导航到下一个页面，我们将简单地随机选择一个内部
    URL。
- en: We also mentioned including difficulty settings. We will use the common-sense
    assumption that the more links there are between the start article and the end
    article, the less related their subjects will be; and thus, the more difficult
    to identify the path between them, resulting in a more challenging level.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了包括难度设置。我们将使用常识假设，即起始文章和结束文章之间的链接越多，它们的主题就越不相关；因此，识别它们之间路径的难度就越大，导致更具有挑战性的难度级别。
- en: 'All right, time to get coding! For starters, create a new file inside the `sixdegrees/`
    folder. Name it `Gameplay.jl` and copy and paste the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是时候开始编码了！首先，在 `sixdegrees/` 文件夹内创建一个新文件。命名为 `Gameplay.jl` 并复制粘贴以下内容：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`Gamplay.jl` defines a new `module` and brings `Wikipedia` into scope. Here,
    you can see how we reference the `Wikipedia` module in the parent scope by using
    `..`. It then defines three constants that map the difficulty settings to degrees
    of separation (named `DIFFICULTY_EASY`, `DIFFICULTY_MEDIUM`, and `DIFFICULTY_HARD`).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gamplay.jl` 定义了一个新的 `module` 并将 `Wikipedia` 带入作用域。在这里，你可以看到我们如何通过使用 `..` 在父作用域中引用
    `Wikipedia` 模块。然后它定义了三个常量，这些常量将难度设置映射到分离度（分别命名为 `DIFFICULTY_EASY`、`DIFFICULTY_MEDIUM`
    和 `DIFFICULTY_HARD`）。'
- en: It then defines a function, `newgame`, which accepts a difficulty argument,
    by default set to hard. In the body of the function, we loop for a number of times
    equal to the difficulty value. On each iteration, we check the current degree
    of separation—if it's the first article, we call `fetchrandom` to start off the
    crawling process. If it's not the first article, we pick a random link from the
    list of links of the previously crawled article (`rand(articles[i-1][:links])`).
    We then pass this URL to `fetchpage`. When discussing conditionals, we learned
    that in Julia `if/else` statements return the value of the last-evaluated expression.
    We can see it put to good use here, with the result of the evaluation being stored
    in the `article` variable.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它定义了一个名为 `newgame` 的函数，该函数接受一个难度参数，默认设置为困难。在函数的主体中，我们循环的次数等于难度值。在每次迭代中，我们检查当前的分离度——如果是第一篇文章，我们调用
    `fetchrandom` 来启动爬取过程。如果不是第一篇文章，我们从先前爬取的文章的链接列表中随机选择一个链接（`rand(articles[i-1][:links])`）。然后我们将此URL传递给
    `fetchpage`。在讨论条件语句时，我们了解到在 Julia 中 `if/else` 语句返回最后一个评估表达式的值。我们可以看到它在这里得到了很好的应用，评估的结果被存储在
    `article` 变量中。
- en: Once we've fetched the article, we store its content and its links within a
    `Dict` called `article_data`. And, `article_data` is in turn added to the `articles`
    array. On its last line, the `newgame` function returns the `articles` vector
    that now contains all the steps, from first to last. This function is also exported.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了文章，我们将其内容及其链接存储在一个名为 `article_data` 的 `Dict` 中。然后，`article_data` 被添加到
    `articles` 数组中。在其最后一行，`newgame` 函数返回包含所有步骤（从第一个到最后一个）的 `articles` 向量。此函数也被导出。
- en: 'That wasn''t too hard! But, there''s a small glitch. If you try to run the
    code now, it will fail. The reason is that the article links are *relative*. This
    means that they are not fully qualified URLs; they look like `/wiki/Some_Article_Title`.
    When `HTTP.jl` makes a request, it needs the full link, protocol, and domain name
    included. But don''t worry, that''s easy to fix in `Wikipedia.jl`. Please switch
    your editor to the `Wikipedia` module and replace the `const RANDOM_PAGE_URL`
    line with the following three lines:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太难！但是，有一个小问题。如果你现在尝试运行代码，它将会失败。原因是文章链接是 *relative* 的。这意味着它们不是完全限定的URL；它们看起来像
    `/wiki/Some_Article_Title`。当 `HTTP.jl` 发起请求时，它需要包含协议、链接和域名。但别担心，在 `Wikipedia.jl`
    中修复这个问题很容易。请切换你的编辑器到 `Wikipedia` 模块，并将 `const RANDOM_PAGE_URL` 行替换为以下三行：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We broke the random page URL into its components—the protocol, the domain name,
    and the rest of the relative path.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将随机页面URL分解为其组成部分——协议、域名和剩余的相对路径。
- en: 'We''ll use a similar approach to turn relative URLs into absolute URLs when
    fetching articles. For this, change the body of `fetchpage` and add this as its
    first line of code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似的方法在获取文章时将相对URL转换为绝对URL。为此，更改 `fetchpage` 的主体，并将其作为第一行代码添加以下内容：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we check the `url` argument—if it starts with `"/"`, it means it's a relative
    URL so we need to turn it into its absolute counterpart. We used the ternary operator,
    as you can tell.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查 `url` 参数——如果它以 `"/"` 开头，这意味着它是一个相对URL，因此我们需要将其转换为它的绝对形式。正如你可以看到的，我们使用了三元运算符。
- en: 'Our code should work just fine now, but spreading this `PROTOCOL * DOMAIN_NAME
    * url` throughout our game is a bit of a code smell. Let''s abstract this away
    into a function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码应该可以正常工作，但将这个 `PROTOCOL * DOMAIN_NAME * url` 散布到我们的游戏中有点像 *code smell*。让我们将其抽象成一个函数：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A *code smell* in programming parlance refers to a practice that violates fundamental
    design principles and negatively impacts quality. It is not a *bug* *per se*,
    but indicates weakness in design that may increase the risk of bugs or failures
    in the future.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，*code smell* 指的是违反基本设计原则并负面影响的实践。它本身不是一个 *bug*，但它表明设计中的弱点可能会增加未来出现错误或失败的风险。
- en: 'The `Wikipedia.jl` file should now look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wikipedia.jl` 文件现在应该看起来像这样：'
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Finishing touches
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成细节
- en: Our gameplay evolves nicely. Only a few pieces left. Thinking about our game's
    UI, we'll want to show the game's progression, indicating the articles the player
    has navigated through. For this, we'll need the titles of the articles. If we
    could also include an image, that would make our game much prettier.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏玩法发展得很好。只剩下几个部件了。在思考我们的游戏用户界面时，我们希望展示游戏的进度，指出玩家已经导航过的文章。为此，我们需要文章的标题。如果我们还能包括一张图片，那会让我们的游戏看起来更漂亮。
- en: 'Fortunately, we are now using CSS selectors, so extracting the missing data
    should be a piece of cake. All we need to do is add the following to the `Wikipedia`
    module:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们现在使用CSS选择器，因此提取缺失的数据应该轻而易举。我们只需要将以下内容添加到`Wikipedia`模块中：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `extracttitle` and `extractimage` functions will retrieve the corresponding
    content from our article pages. In both cases, since we only want to select a
    single element, the main page heading and the first image respectively, we use
    `Cascadia.matchFirst`. The `matchFirst` function is not publicly exposed by `Cascadia`—but
    since it's quite useful, we `import` it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`extracttitle`和`extractimage`函数将从我们的文章页面检索相应的内容。在两种情况下，因为我们只想选择一个元素，即主页标题和第一张图片，所以我们使用`Cascadia.matchFirst`。`matchFirst`函数不是由`Cascadia`公开暴露的——但因为它非常有用，所以我们`import`它。'
- en: The `#section_0` selector identifies the main page heading, a `<h1>` element.
    And, because we need to extract the text between its `<h1>...</h1>` tags, we invoke
    the `nodeText` method provided by `Cascadia`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`#section_0`选择器标识主页标题，一个`<h1>`元素。而且，因为我们需要提取其`<h1>...</h1>`标签之间的文本，我们调用`Cascadia`提供的`nodeText`方法。'
- en: 'You can see in the following screenshot, which shows the main heading of a
    Wikipedia page in Safari''s inspector, how to identify the desired HTML elements
    and how to pick their CSS selectors by inspecting the source of the page and the
    corresponding DOM element. The HTML property, `id="section_0"`, corresponds to
    the `#section_0` CSS selector:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下屏幕截图（显示Safari检查器中的Wikipedia页面的主要标题）中看到，如何识别所需的HTML元素以及如何通过检查页面源代码和相应的DOM元素来选择它们的CSS选择器。HTML属性`id="section_0"`对应于`#section_0`CSS选择器：
- en: '![](img/09501ef3-c816-45fb-9fdf-7210a0538eec.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09501ef3-c816-45fb-9fdf-7210a0538eec.png)'
- en: As for `extractimage`, we look for the main article image, represented by the
    `".content a.image img"` selector. Since not all the pages have it, we check if
    we do indeed get a valid element. If the page does not have an image, we'll get
    an instance of `Nothing,` called `nothing`. This is an important construct—`nothing`
    is the singleton instance of `Nothing`, indicating the absence of an object, corresponding
    to `NULL` in other languages. If we do get an `img` element, we extract the value
    of its `src` attribute, which is the URL of the image.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`extractimage`，我们寻找主要文章图片，表示为`".content a.image img"`选择器。由于并非所有页面都有它，我们检查是否确实得到了一个有效的元素。如果页面没有图片，我们将得到一个`Nothing`实例，称为`nothing`。这是一个重要的构造——`nothing`是`Nothing`的单例实例，表示没有对象，对应于其他语言中的`NULL`。如果我们确实得到了一个`img`元素，我们提取其`src`属性的值，即图片的URL。
- en: 'Here is another Wikipedia screenshot, in which I marked the image element that
    we''re targeting. The flag is the first image on Wikipedia''s **Australia** page—a
    perfect match:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个Wikipedia截图，其中我标记了我们要针对的图像元素。旗帜是Wikipedia的**澳大利亚**页面上的第一张图片——一个完美的匹配：
- en: '![](img/3db08f0a-dabc-4811-ab68-93785a2cea72.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3db08f0a-dabc-4811-ab68-93785a2cea72.png)'
- en: 'Next, we could extend the `Gameplay.newgame` function, to handle the new functions
    and values. But by now, this doesn''t feel right—too much of the logic of `Wikipedia`
    would leak into the `Gameplay` module, coupling them; a dangerous anti-pattern.
    Instead, let''s make the extraction of the data and setting up of the article,
    `Dict`, the full responsibility of `Wikipedia`, completely encapsulating the logic.
    Make the `Gameplay.newgame` function looks as shown in the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以扩展`Gameplay.newgame`函数，以处理新的功能和值。但到目前为止，这感觉并不合适——太多的`Wikipedia`逻辑会泄露到`Gameplay`模块中，使它们耦合；这是一个危险的反模式。相反，让我们让数据的提取和文章的设置，即`Dict`，成为`Wikipedia`的全权责任，完全封装逻辑。让`Gameplay.newgame`函数看起来如下所示：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, update the `Wikipedia` module to read as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新`Wikipedia`模块如下所示：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The file has a few important changes. We've removed the `articlelinks` function
    and instead added `articleinfo` and `articledom`. The new `articledom` function
    parses the HTML using `Gumbo` and generates the DOM, which, very importantly,
    is only parsed once. We don't want to parse the HTML into a DOM every time we
    extract a type of element, as would've been the case if we kept the previous `articlelinks`
    function. As for `articleinfo`, it is responsible for setting up an article, `Dict`,
    with all the relevant information—content, links, title, and image.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 文件有几处重要更改。我们移除了`articlelinks`函数，并添加了`articleinfo`和`articledom`。新的`articledom`函数使用`Gumbo`解析HTML并生成DOM，这非常重要，DOM只解析一次。我们不希望在每次提取元素类型时都解析HTML到DOM，就像如果我们保留之前的`articlelinks`函数那样。至于`articleinfo`，它负责设置一个包含所有相关信息的文章`Dict`——内容、链接、标题和图片。
- en: 'We can do a test run of our code, by modifying the `six_degrees.jl` file, as
    follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改`six_degrees.jl`文件来进行代码的测试运行，如下所示：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We start a new game, which goes through two articles (`Gameplay.DIFFICULTY_EASY`)
    and for each article we display its title. We can see it in action by either running
    it in a REPL session via `julia> include("six_degrees.jl")`, or by simply running
    the file in Visual Studio Code or Atom. Here it is in the REPL:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始一个新的游戏，它包含两篇文章（`Gameplay.DIFFICULTY_EASY`），并且对于每一篇文章，我们都会显示其标题。我们可以通过在REPL会话中运行它来看到它的实际效果，通过`julia>
    include("six_degrees.jl")`，或者简单地通过在Visual Studio Code或Atom中运行文件。下面是REPL中的样子：
- en: '[PRE61]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: One more thing
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有一件事
- en: 'Our test run shows that our difficulty settings have a small glitch. We should
    crawl a certain number of articles *after* the starting point. Our initial article
    should not count. This is super easy to fix. In `Gameplay.newgame`, we need to
    replace `for i in 1:difficulty` with `for i in 1:difficulty+1` (note the `+1`
    at the end). Now, if we try again, it works as intended:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试运行显示我们的难度设置有一个小故障。我们应该在起点之后爬取一定数量的文章。我们的初始文章不应计入。这个问题非常容易解决。在`Gameplay.newgame`中，我们需要将`for
    i in 1:difficulty`替换为`for i in 1:difficulty+1`（注意最后的`+1`）。现在，如果我们再次尝试，它将按预期工作：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Learning about Julia's type system
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Julia的类型系统
- en: Our game works like a charm, but there is one thing we can improve—storing our
    article info as a `Dict`. Julia's dictionaries are very flexible and powerful,
    but they are not a good fit in every case. The `Dict` is a generic data structure
    that is optimized for search, delete, and insert operations. None of these are
    needed here—our articles have a fixed structure and contain data that doesn't
    change once created. It's a perfect use case for objects and **object-oriented
    programming** (**OOP**). Looks like it's time to learn about types.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏运行得非常顺利，但有一件事我们可以改进——将我们的文章信息存储为`Dict`。Julia的字典非常灵活和强大，但它们并不适合所有情况。`Dict`是一个通用的数据结构，它针对搜索、删除和插入操作进行了优化。这里我们都不需要这些——我们的文章具有固定的结构，并且创建后数据不会改变。这是一个非常适合使用对象和**面向对象编程**（**OOP**）的用例。看来是时候学习类型了。
- en: Julia's type system is the bread and butter of the language—it is all-pervasive,
    defining the language's syntax and being the driving force behind Julia's performance
    and flexibility. Julia's type system is dynamic, meaning that nothing is known
    about types until runtime, when the actual values manipulated by the program are
    available. However, we can benefit from the advantages of static typing by using
    type annotations—indicating that certain values are of specific types. This can
    greatly improve the performance of the code and also enhance readability and simplify
    debugging.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的类型系统是语言的核心——它无处不在，定义了语言的语法，并且是Julia性能和灵活性的驱动力。Julia的类型系统是动态的，这意味着在程序可用的实际值之前，我们对类型一无所知。然而，我们可以通过使用类型注解来利用静态类型的好处——表明某些值具有特定的类型。这可以大大提高代码的性能，并增强可读性，简化调试。
- en: It's impossible to talk about Julia and not talk about types. And sure enough,
    we've seen many primitive types so far—`Integer`, `Float64`, `Boolean`, `Char`,
    and so on. We've also been exposed to types while learning about the various data
    structures, such as `Array`, `Dict,` or tuple. These are all built into the language,
    but it turns out that Julia makes it very easy to create our own.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论Julia语言而不提及类型是不可能的。确实，到目前为止，我们已经看到了许多原始类型——`Integer`、`Float64`、`Boolean`、`Char`等等。在学习各种数据结构，如`Array`、`Dict`或元组时，我们也接触到了类型。这些都是语言内置的，但结果是Julia使得创建我们自己的类型变得非常容易。
- en: Defining our own types
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们自己的类型
- en: Julia supports two categories of type—primitive and composite. A primitive type
    is a concrete type whose data consists of plain old bits. A composite type is
    a collection of named fields, an instance of which can be treated as a single
    value. In many languages, composite types are the only kind of user-definable
    type, but Julia lets us declare our own primitive types as well, rather than providing
    only a fixed set of built-in ones.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Julia支持两种类型的类别——原始类型和复合类型。原始类型是一个具体类型，其数据由普通的位组成。复合类型是一组命名字段，其实例可以被视为单个值。在许多语言中，复合类型是唯一一种用户可定义的类型，但Julia允许我们声明自己的原始类型，而不仅仅是提供一组固定的内置类型。
- en: We won't talk about defining primitive types here, but you can read more about
    them in the official documentation at [https://docs.julialang.org/en/v1/manual/types/](https://docs.julialang.org/en/v1/manual/types/).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会讨论定义原始类型，但你可以在官方文档中了解更多信息，网址为[https://docs.julialang.org/en/v1/manual/types/](https://docs.julialang.org/en/v1/manual/types/)。
- en: 'In order to represent our articles, we''re best served by an immutable composite
    type. Once our article object is created, its data won''t change. Immutable composite
    types are introduced by the `struct` keyword followed by a block of field names:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示我们的文章，我们最好使用一个不可变的复合类型。一旦我们的文章对象被创建，其数据就不会改变。不可变的复合类型是通过`struct`关键字后跟一个字段名称块来引入的：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Since we provide no type information for the fields—that is, we don''t tell
    Julia what type we want each field to be—they will default to any, allowing to
    hold any type of value. But, since we already know what data we want to store,
    we would greatly benefit from constraining the type of each field. The `::` operator
    can be used to attach type annotations to expressions and variables. It can be
    read as *is an instance of*. Thus, we define the `Article` type as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为字段提供类型信息——也就是说，我们没有告诉Julia我们希望每个字段是什么类型——它们将默认为任何类型，允许存储任何类型的值。但是，由于我们已经知道我们想要存储什么数据，我们将极大地从限制每个字段的类型中受益。`::`运算符可以用来将类型注解附加到表达式和变量上。它可以读作“是一个实例”。因此，我们定义`Article`类型如下：
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: All the fields are of `String` type, with the exception of `links`, which is
    a one-dimensional `Array` of `String`, also called a `Vector{String}`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字段都是`String`类型，除了`links`，它是一个一维的`Array`，也称为`Vector{String}`。
- en: Type annotations can provide important performance benefits—while also eliminating
    a whole class of type-related bugs.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解可以提供重要的性能优势——同时消除一类与类型相关的错误。
- en: Constructing types
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造类型
- en: 'New objects of `Article` type are created by applying the `Article` type name
    like a function. The arguments are the values for its fields:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Article`类型的新对象是通过将`Article`类型名称像函数一样应用来实现的。参数是该字段的值：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The fields of the newly created object can be accessed using the standard *dot
    notation*:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用标准的*点表示法*访问新创建对象的字段：
- en: '[PRE66]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Because we declared our type to be immutable, the values are read-only, so
    they can''t be changed:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们声明我们的类型为不可变的，所以值是只读的，因此它们不能被更改：
- en: '[PRE67]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Our `Article` type definition won''t allow us to change the `julia.title` property.
    But, immutability should not be dismissed as it does come with considerable advantages,
    per the official Julia documentation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Article`类型定义不会允许我们更改`julia.title`属性。但是，不可变性不应该被忽视，因为它确实带来了相当大的优势，如官方Julia文档所述：
- en: It can be more efficient. Some structs can be packed efficiently into arrays,
    and in some cases, the compiler is able to avoid allocating immutable objects
    entirely.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能更有效。某些结构可以有效地打包到数组中，在某些情况下，编译器能够避免分配不可变对象。
- en: It is not possible to violate the invariants provided by the type's constructors.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法违反类型构造函数提供的不变性。
- en: Code using immutable objects can be easier to reason about.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变对象的代码可能更容易推理。
- en: 'But, that''s not the whole story. An immutable object can have fields that
    reference mutable objects, such as, for instance, `links`, which points to an
    `Array{String, 1}`. This array is still mutable:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这并不是全部的故事。一个不可变对象可以拥有引用可变对象的字段，例如，比如`links`，它指向一个`Array{String, 1}`。这个数组仍然是可变的：
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can see that there is no error when trying to alter the `links` property,
    by pushing one more URL to the underlying collection. If a property points to
    a mutable type, that type can be mutated, as long as its type stays the same:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过尝试向底层集合推送一个额外的URL来改变`links`属性，看到没有错误发生。如果一个属性指向一个可变类型，那么这个类型可以被修改，只要它的类型保持不变：
- en: '[PRE69]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We are not allowed to change the type of the `links` field—Julia tries to accommodate
    and attempts to convert the values we provided from `Int` to `String`, but fails.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不允许更改`links`字段的类型——Julia试图适应并尝试将我们提供的值从`Int`转换为`String`，但失败了。
- en: Mutable composite types
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变复合类型
- en: 'It is also possible (and equally easy) to construct mutable composite types.
    The only thing we need to do is to use the `mutable struct` statement, instead
    of just `struct`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地（并且同样简单），我们也可以构造可变复合类型。我们唯一需要做的是使用`mutable struct`语句，而不是仅仅使用`struct`：
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Our `Player` object should be mutable, as we''ll need to update the `score`
    property after each game:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Player`对象应该是可变的，因为我们需要在每次游戏后更新`score`属性：
- en: '[PRE71]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Type hierarchy and inheritance
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型层次结构和继承
- en: 'Like all programming languages that implement OOP features, Julia allows developers
    to define rich and expressive type hierarchies. However, unlike most OOP languages,
    there is a very important difference—*only the final (upper) type in the hierarchy
    can be instantiated in Julia*. All its parents are just nodes in the type graph,
    and we can''t create instances of them. They are *abstract types* and are defined
    using the `abstract` type keywords:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有实现OOP特性的编程语言一样，Julia允许开发者定义丰富和表达性的类型层次结构。然而，与大多数OOP语言不同的是，有一个非常重要的区别——在Julia中，*只有层次结构中的最终（上层）类型可以被实例化*。所有它的父类型只是类型图中的节点，我们无法创建它们的实例。它们是*抽象类型*，使用`abstract`类型关键字定义：
- en: '[PRE72]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can use the `<:` operator to indicate that a type is a subtype of an existing
    *parent*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`<:`运算符来表示一个类型是现有*父类型*的子类型：
- en: '[PRE73]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Or, in another example, this is Julia''s numerical types hierarchy:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在另一个例子中，这是Julia的数值类型层次结构：
- en: '[PRE74]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The fact that super-types can''t be instantiated can seem limiting, but they
    have a very powerful role. We can define functions that take a super-type as their
    argument, in effect accepting all its subtypes:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 超类型不能实例化的事实可能看起来很有限，但它们有一个非常强大的作用。我们可以定义接受超类型作为参数的函数，实际上接受所有其子类型：
- en: '[PRE75]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, we can see how we defined a `getusername` function, which accepts an argument
    of (abstract) type, `Person`. As both `User` and `Player` are subtypes of `Person`,
    their instances are accepted as arguments.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们如何定义了一个`getusername`函数，它接受一个（抽象）类型参数，`Person`。由于`User`和`Player`都是`Person`的子类型，它们的实例被接受为参数。
- en: Type unions
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型联合
- en: Sometimes, we might want to allow a function to accept a set of types that are
    not necessarily part of the same type hierarchy. We could, of course, allow the
    function to accept any type, but depending on the use case, it could be desirable
    to strictly limit the arguments to a well-defined subset of types. For such cases,
    Julia provides *type unions*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望允许一个函数接受一组不一定属于同一类型层次结构的类型。当然，我们可以允许函数接受任何类型，但根据用例，可能希望严格限制参数到一个定义良好的类型子集。对于这种情况，Julia提供了*类型联合*。
- en: 'A type union is a special abstract type that includes as objects all instances
    of any of its argument types, constructed using the special `Union` function:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 类型联合是一种特殊的抽象类型，它包括使用特殊`Union`函数构造的所有其参数类型的实例：
- en: '[PRE76]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here, we have defined a new type union, `GameEntity`, which includes two types—`Person`
    and `Article`. Now, we can define functions that know how to handle `GameEntities`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个新的类型联合，`GameEntity`，它包括两种类型——`Person`和`Article`。现在，我们可以定义知道如何处理`GameEntities`的函数：
- en: '[PRE77]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Using article types
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文章类型
- en: We can refactor our code to eliminate the generic `Dict` data structure and
    represent our articles with specialized `Article` composite types.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的代码重构，以消除通用的`Dict`数据结构，并用专门的`Article`复合类型来表示我们的文章。
- en: 'Let''s create a new file in our `sixdegrees/` work folder, and name it `Articles.jl`.
    Edit the file by typing in the corresponding `module` declaration. Then, add the
    definition of our type and `export` it:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`sixdegrees/`工作文件夹中创建一个新的文件，命名为`Articles.jl`。通过输入相应的`module`声明来编辑文件。然后，添加我们类型的定义并将其`export`：
- en: '[PRE78]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We could've added the `Article` type definition to the `Wikipedia.jl` file,
    but chances are this will grow and it's better to keep them separated instead.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将`Article`类型定义添加到`Wikipedia.jl`文件中，但很可能会增长，因此最好将它们分开。
- en: Another thing to note is that both the `module` and the `type` are Julia entities
    that are loaded in the same scope. For this reason, we can't use the name `Article`
    for both the `module` and the `type`—we'd end up with a name clash. However, the
    pluralized name `Articles` is a good name for the module, since it will encapsulate
    the logic for dealing with *articles* in general, while the `Article` type represents
    an *article* entity—hence the singular form.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，`module` 和 `type` 都是 Julia 实体，它们在相同的作用域中被加载。因此，我们不能同时使用 `Article`
    这个名字来命名 `module` 和 `type`——否则会出现名称冲突。然而，复数形式的 `Articles` 是一个很好的模块名称，因为它将封装处理一般文章的逻辑，而
    `Article` 类型代表一个文章实体——因此使用单数形式。
- en: 'However, since conceptually an `Article` object references a Wikipedia page,
    it should be part of the `Wikipedia` namespace. That''s easy, we just need to
    include it into the `Wikipedia` module. Add this after the `import Cascadia: matchFirst`
    line:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，由于概念上 `Article` 对象引用了一个维基百科页面，它应该是 `Wikipedia` 命名空间的一部分。这很简单，我们只需要将其包含到
    `Wikipedia` 模块中。在 `import Cascadia: matchFirst` 行之后添加以下内容：'
- en: '[PRE79]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We're including the `Articles` module file and bringing it into scope.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了 `Articles` 模块文件并将其带入作用域。
- en: 'Next, in the same `Wikipedia.jl` file, we need to modify the `articleinfo`
    function. Please make sure it reads as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在同一个 `Wikipedia.jl` 文件中，我们需要修改 `articleinfo` 函数。请确保它如下所示：
- en: '[PRE80]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Instead of creating a generic `Dict` object, we're now instantiating an instance
    of `Article`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不是创建一个通用的 `Dict` 对象，而是实例化一个 `Article` 的实例。
- en: 'We also need to make a few changes to `Gameplay.jl` to use the `Article` types
    instead of `Dict`. It should now look like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对 `Gameplay.jl` 进行一些修改，以使用 `Article` 类型而不是 `Dict`。它现在应该看起来像这样：
- en: '[PRE81]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note that on the third line we bring `Wikipedia.Articles` into scope. Then,
    in the `newgame` function, we initiate the `articles` array to be of `Vector{Article}`
    type. And then, we update the code in the `for` loop to deal with `Article` objects—`rand(articles[i-1].links)`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第三行我们将 `Wikipedia.Articles` 带入作用域。然后，在 `newgame` 函数中，我们将 `articles` 数组初始化为
    `Vector{Article}` 类型。接着，我们更新 `for` 循环中的代码来处理 `Article` 对象——`rand(articles[i-1].links)`。
- en: 'The last change is in `six_degrees.jl`. Since `newgame` now returns a vector
    of `Article` objects instead of a `Dict`, we print the title by accessing the
    `title` field:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改在 `six_degrees.jl` 中。由于 `newgame` 现在返回一个 `Article` 对象的向量而不是 `Dict`，我们通过访问
    `title` 字段来打印标题：
- en: '[PRE82]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'A new test run should confirm that all works as expected (your output will
    be different since, remember, we''re pulling random articles):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 新的测试运行应该确认所有工作如预期（由于我们正在拉取随机文章，所以你的输出将不同）：
- en: '[PRE83]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Inner constructors
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部构造函数
- en: The external constructor (where we invoke the `type` as a function) is a default
    constructor where we provide the values for all the fields, in the right order—and
    get back an instance of the corresponding type. But, what if we want to provide
    additional constructors, that maybe impose certain constraints, perform validations,
    or are simply more user-friendly? For this purpose, Julia provides *internal constructors*.
    I've got a good use case for them.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 外部构造函数（我们作为函数调用 `type`）是一个默认构造函数，我们为所有字段提供值，并按正确的顺序返回相应类型的实例。但是，如果我们想提供额外的构造函数，可能施加某些约束、执行验证或者只是更用户友好呢？为此，Julia
    提供了 *内部构造函数*。我有一个很好的用例。
- en: I'm not especially fond of our `Article` constructor—it takes too many arguments
    that need to be passed in the exact right order. It's hard to remember how to
    instantiate it. We've learned earlier about keyword arguments—and it would be
    awesome to provide an alternative constructor that takes keyword arguments. Inner
    constructors are what we need.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不特别喜欢我们的 `Article` 构造函数——它需要太多的参数，并且必须按正确的顺序传递。很难记住如何实例化它。我们之前学过关键字参数——提供一个接受关键字参数的替代构造函数会非常棒。内部构造函数正是我们所需要的。
- en: 'Inner constructors are very much like the outer constructors, but with two
    major differences:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 内部构造函数与外部构造函数非常相似，但有两大主要区别：
- en: They are declared inside the block of a type declaration, rather than outside
    of it like normal methods.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是在类型声明块的内部声明的，而不是像正常方法那样在块外部声明。
- en: They have access to a special locally existent function called `new` that creates
    objects of the same type.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以访问一个特殊的本地存在函数 `new`，该函数创建相同类型的对象。
- en: On the other hand, external constructors have a clear limitation (by design)—we
    can create as many as we want, but they can only instantiate objects by invoking
    the existing internal constructors (they do not have access to the `new` function).
    This way, if we define internal constructors that implement some business logic
    constraints, *Julia guarantees that the external constructors cannot go around
    them*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，外部构造函数有一个明显的限制（按设计）——我们可以创建尽可能多的构造函数，但它们只能通过调用现有的内部构造函数来实例化对象（它们没有访问 `new`
    函数的权限）。这样，如果我们定义了实现某些业务逻辑约束的内部构造函数，*Julia 保证外部构造函数不能绕过这些约束*。
- en: 'Our inner constructor with keyword arguments will look like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用关键字参数的内部构造函数看起来是这样的：
- en: '[PRE84]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note the use of `;`, which separates the empty list of positional arguments
    from the list of keyword arguments.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `;` 的使用，它将空的位置参数列表与关键字参数列表分开。
- en: 'This constructor allows us to instantiate `Article` objects using keyword arguments,
    which we can provide in any order:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数允许我们使用关键字参数来实例化 `Article` 对象，我们可以按任何顺序提供这些参数：
- en: '[PRE85]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'However, there''s a small problem. When we don''t provide any internal constructor,
    Julia provides the default one. But, if any inner constructor is defined, no default
    constructor method is provided anymore—it is presumed that we have supplied ourselves
    all the necessary inner constructors. In this case, if we want to get back the
    default constructor with the positional arguments, we''ll have to also define
    it ourselves as an internal one:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个小问题。当我们没有提供任何内部构造函数时，Julia 提供默认的一个。但是，如果定义了任何内部构造函数，就不再提供默认构造函数方法——假设我们已经提供了所有必要的内部构造函数。在这种情况下，如果我们想获取带有位置参数的默认构造函数，我们必须自己定义它作为一个内部构造函数：
- en: '[PRE86]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The final version of the `Articles.jl` file should now be the following, with
    the two internal constructors:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Articles.jl` 文件的最终版本现在应该是以下内容，包含两个内部构造函数：'
- en: '[PRE87]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: It is worth pointing out that, in this case, our keyword constructor could've
    been equally added as an external constructor and defined outside the `struct...end`
    body. What kind of constructor you use is an architectural decision that has to
    be taken on a case-by-case basis, taking into account the differences between
    the internal and the external constructors.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，在这种情况下，我们的关键字构造函数也可以作为一个外部构造函数添加，并定义在 `struct...end` 主体之外。你使用哪种构造函数是一个架构决策，必须根据具体情况逐个案例进行考虑，考虑到内部构造函数和外部构造函数之间的差异。
- en: Methods
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: If you come from an OOP background, you may have noticed a very interesting
    aspect throughout our discussion of types. Unlike other languages, objects in
    Julia do not define behavior. That is, Julia's types only define fields (properties)
    but do not encapsulate functions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象编程的背景，你可能会注意到在我们的类型讨论中一个非常有趣的方面。与其他语言不同，Julia 中的对象不定义行为。也就是说，Julia
    的类型只定义字段（属性），但不封装函数。
- en: The reason is Julia's implementation of *multiple dispatch**, *a distinctive
    feature of the language.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于 Julia 对 *多重调度* 的实现，这是语言的一个独特特性。
- en: 'Multiple dispatch is explained in the official documentation as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 多重调度在官方文档中的解释如下：
- en: '"The choice of which method to execute when a function is applied is called
    dispatch. Julia allows the dispatch process to choose which of a function''s methods
    to call based on the number of arguments given, and on the types of all of the
    function''s arguments. This is different than traditional object-oriented languages,
    where dispatch occurs based only on the first argument [`...`]. Using all of a
    function''s arguments to choose which method should be invoked, rather than just
    the first, is known as multiple dispatch. Multiple dispatch is particularly useful
    for mathematical code, where it makes little sense to artificially deem the operations
    to *belong *to one argument more than any of the others."'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '"当对一个函数应用时，选择执行哪个方法的过程称为调度。Julia 允许调度过程根据提供的参数数量以及所有函数参数的类型来选择调用函数的哪个方法。这与传统的面向对象语言不同，在传统的面向对象语言中，调度仅基于第一个参数[...]。使用一个函数的所有参数来选择应该调用的方法，而不是仅使用第一个参数，这被称为多重调度。多重调度对于数学代码特别有用，因为它使得人为地将操作归因于一个参数比其他任何参数更有意义的情况变得没有意义。"'
- en: Julia allows us to define functions that provide specific behavior for certain
    combinations of argument types. A definition of one possible behavior for a function
    is called a **method**. The signatures of method definitions can be annotated
    to indicate the types of arguments, in addition to their number, and more than
    a single method definition may be provided. An example will help.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Julia允许我们定义函数，为某些参数类型的组合提供特定的行为。一个函数可能行为的定义被称为**方法**。方法定义的签名可以注解以指示参数的类型，而不仅仅是它们的数量，并且可以提供多个方法定义。一个例子将有所帮助。
- en: 'Let''s say we have our previously defined `Player` type, as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们之前定义了`Player`类型，如下所示：
- en: '[PRE88]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And here, we see a corresponding `getscore` function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到相应的`getscore`函数：
- en: '[PRE89]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'So far, so good. But, as our game grows incredibly successful, we could end
    up adding an app store to offer in-app purchases. This will lead us to also define
    a `Customer` type that could have a homonymous `credit_score` field, which stores
    their credit score:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但是，随着我们的游戏取得惊人的成功，我们可能会添加一个应用商店来提供应用内购买。这将使我们定义一个`Customer`类型，该类型可能有一个同名的`credit_score`字段，用于存储他们的信用评分：
- en: '[PRE90]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Of course, we''d need a corresponding `getscore` function:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要一个相应的`getscore`函数：
- en: '[PRE91]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, how would Julia know which function to use? It wouldn''t. As both functions
    are defined to accept any type of argument, the last-defined function overwrites
    the previous one. We need to specialize the two `getscore` declarations on the
    type of their arguments:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Julia将如何知道使用哪个函数呢？它不会。因为这两个函数都被定义为接受任何类型的参数，最后定义的函数覆盖了之前的函数。我们需要根据它们的参数类型对两个`getscore`声明进行特殊化：
- en: '[PRE92]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If you look closely at the output for each function declaration, you'll see
    something interesting. After the definition of `getscore(p::Player)`, it says
    `getscore (generic function with 1 method)`. But, after defining `getscore(c::Customer)`,
    it shows `getscore (generic function with 2 methods)`. So now, we have defined
    two methods for the `getscore` function, each specializing on its argument type.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看每个函数声明的输出，你会看到一些有趣的东西。在定义`getscore(p::Player)`之后，它说`getscore (generic
    function with 1 method)`。但是，在定义`getscore(c::Customer)`之后，它显示`getscore (generic
    function with 2 methods)`。所以现在，我们已经为`getscore`函数定义了两种方法，每种方法都针对其参数类型进行了特殊化。
- en: But, what if we add the following?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们添加以下内容呢？
- en: '[PRE93]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Or, alternatively, note the following that we might add:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以注意以下可能添加的内容：
- en: '[PRE94]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Can you guess which methods will be used when invoking `getscore` with a `Player`,
    a `Customer`, and an `Article` object? I''ll give you a hint: when a function
    is applied to a particular set of arguments, the most specific method applicable
    to those arguments is invoked.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到在调用`getscore`时，使用`Player`、`Customer`和`Article`对象将使用哪些方法吗？我会给你一个提示：当一个函数应用于一组特定的参数时，将调用适用于这些参数的最具体的方法。
- en: 'If we want to see which method is called for a given set of arguments, we can
    use `@which`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看给定参数集调用的方法，我们可以使用`@which`：
- en: '[PRE95]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The same goes for `Customer` types:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Customer`类型也是如此：
- en: '[PRE96]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We can see how the most specialized method is invoked— `getscore(t::Union{Player,Customer})`,
    which is more generic, is actually never used.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到最专业的方法是如何被调用的——`getscore(t::Union{Player,Customer})`，这是一个更通用的方法，实际上从未被使用。
- en: However, what about the following?
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下情况又如何呢？
- en: '[PRE97]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Passing an `Article` type will invoke the last definition of `getscore`, the
    one accepting `Any` type of argument:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`Article`类型将调用`getscore`的最后一个定义，即接受`Any`类型参数的定义：
- en: '[PRE98]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Since the `Article` type does not have a `score` or a `credit_score` property,
    the `ErrorException` we defined is being thrown.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Article`类型没有`score`或`credit_score`属性，我们定义的`ErrorException`正在被抛出。
- en: 'To find out what methods are defined for a function, use `methods()`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出为函数定义了哪些方法，请使用`methods()`：
- en: '[PRE99]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Working with relational databases
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与关系型数据库一起工作
- en: Our web crawler is quite performant—using CSS selectors is very efficient. But,
    as it is right now, if we end up with the same Wikipedia article in different
    game sessions, we'll have to fetch it, parse it, and extract its contents multiple
    times. This is a time-consuming and resource-expensive operation—and, more importantly,
    one we can easily eliminate if we just store the article information once we fetch
    it the first time.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网页爬虫性能相当出色——使用CSS选择器非常高效。但是，就目前而言，如果我们不同游戏会话中遇到相同的维基百科文章，我们不得不多次获取、解析和提取其内容。这是一个耗时且资源密集的操作——更重要的是，如果我们只存储第一次获取的文章信息，我们就可以轻松消除这一操作。
- en: We could use Julia's serialization features, which we've already seen, but since
    we're building a fairly complex game, we would benefit from adding a database
    backend. Besides storing articles' data, we could also persist information about
    players, scores, preferences, and whatnot.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Julia的序列化功能，我们之前已经看到过了，但由于我们正在构建一个相当复杂的游戏，添加数据库后端将对我们有所帮助。除了存储文章数据外，我们还可以持久化有关玩家、分数、偏好等信息。
- en: 'We have already seen how to interact with MongoDB. In this case, though, a
    relational database is the better choice, as we''ll work with a series of related
    entities: articles, games (referencing articles), players (referencing games),
    and more.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何与MongoDB交互。然而，在这种情况下，关系型数据库是更好的选择，因为我们将与一系列相关实体一起工作：文章、游戏（引用文章）、玩家（引用游戏）等等。
- en: Julia's package ecosystem provides a good range of options for interacting with
    relational databases, from generic ODBC and JDBC libraries to dedicated packages
    for the main backends—MySQL/MariaDB, SQLite, and Postgres, to name just a few.
    For our game, we'll use MySQL. If you don't already have MySQL installed on your
    system, please follow the instructions at [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/).
    Alternatively, if you're using Docker, you can get the official MySQL Docker image
    from [https://hub.docker.com/r/library/mysql/](https://hub.docker.com/r/library/mysql/).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的包生态系统为与关系数据库交互提供了广泛的选择，从通用的ODBC和JDBC库到针对主要后端（MySQL/MariaDB、SQLite和Postgres等）的专用包。对于我们的游戏，我们将使用MySQL。如果你系统上还没有安装MySQL，请按照[https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/)上的说明进行操作。或者，如果你使用Docker，你可以从[https://hub.docker.com/r/library/mysql/](https://hub.docker.com/r/library/mysql/)获取官方的MySQL
    Docker镜像。
- en: 'On Julia''s side, `(sixdegrees) pkg>add MySQL` is all we need in order to add
    support for MySQL. Make sure you''re within the `sixdegrees/` project before adding
    MySQL. You can confirm this by looking at the prefix of the `pkg>` cursor; it
    should look like this: `(sixdegrees) pkg>`. If that is not the case, just execute
    `pkg> activate .` while making sure that you''re within the `sixdegrees/` folder.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia这边，`(sixdegrees) pkg>add MySQL`就是我们需要添加MySQL支持的所有操作。确保你在`sixdegrees/`项目内添加MySQL。你可以通过查看`pkg>`光标的前缀来确认这一点；它应该看起来像这样：（sixdegrees）pkg>。如果不是这种情况，只需在确保你处于`sixdegrees/`文件夹内的情况下执行`pkg>
    activate .`。
- en: Adding MySQL support
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加MySQL支持
- en: When working with SQL databases, it's a good practice to abstract away the DB-related
    logic and to avoid littering all the codebase with SQL strings and database-specific
    commands. It will make our code more predictable and manageable and will provide
    a safe level of abstraction if we ever need to change or upgrade the database
    system. I'm a big fan of using ORM systems, but in this case, as a learning device,
    we'll be adding this functionality ourselves.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当与SQL数据库一起工作时，将DB相关逻辑抽象出来，避免在所有代码库中散布SQL字符串和数据库特定命令是一个好的做法。这将使我们的代码更具可预测性和可管理性，并在我们需要更改或升级数据库系统时提供一层安全的抽象。我是一个使用ORM系统的忠实粉丝，但在这个案例中，作为一个学习工具，我们将自己添加这个功能。
- en: Connecting to the database
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'For starters, let''s instruct our application to connect to and disconnect
    from our MySQL database. Let''s extend our game by adding a new `Database` module
    within its corresponding file:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们指导我们的应用程序连接到并断开与我们的MySQL数据库的连接。让我们通过在其对应的文件中添加一个新的`Database`模块来扩展我们的游戏：
- en: '[PRE100]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Calling `MySQL.connect` returns a connection object. We''ll need it in order
    to interact with the database, so we''ll reference it via the `CONN` constant:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`MySQL.connect`返回一个连接对象。我们需要它来与数据库交互，因此我们将通过`CONN`常量来引用它：
- en: '[PRE101]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Since various parts of our code will access this connection object in order
    to perform queries against the database, we `export` it. Equally importantly,
    we need to set up some cleanup mechanism, to automatically disconnect from the
    database when we're done. We've defined a `disconnect` function that can be manually
    called. But, it's safer if we make sure that the cleanup function is automatically
    invoked. Julia provides an `atexit` function, which registers a zero-argument
    function `f` to be called at process exit. The `atexit` hooks are called in **last-in-first-out**
    (**LIFO**) order.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码的各个部分都需要访问这个连接对象以对数据库进行查询，我们将其`export`。同样重要的是，我们需要设置一些清理机制，以便在完成操作后自动断开与数据库的连接。我们定义了一个可以手动调用的`disconnect`函数。但是，如果我们确保清理函数能够自动调用，那就更安全了。Julia提供了一个`atexit`函数，它可以将一个无参数函数`f`注册为在进程退出时调用。`atexit`钩子以**后进先出**（**LIFO**）的顺序调用。
- en: Setting up our Article module
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的文章模块
- en: The next step is to add a few more functions to the `Article` module to enable
    database persistence and retrieval functionality. Since it will need access to
    our DB connection object, let's give it access to the `Database` module. We'll
    also want to use `MySQL` functions. So, under the `export Article` line, add `using..Database,
    MySQL`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向`Article`模块添加几个更多函数，以启用数据库持久化和检索功能。由于它将需要访问我们的数据库连接对象，让我们给它访问`Database`模块的权限。我们还将想要使用`MySQL`函数。因此，在`export
    Article`行下，添加`using..Database, MySQL`。
- en: Next, we'll add a `createtable` method. This will be a one-off function that
    will create the corresponding database table. We use this instead of just typing
    `CREATE TABLE` queries in the MySQL client, in order to have a consistent and
    reproducible way of (re)creating the table. In general, I prefer the use of a
    fully fledged database migration library, but for now, better to keep things simple
    (you can read about schema migrations at [https://en.wikipedia.org/wiki/Schema_migration](https://en.wikipedia.org/wiki/Schema_migration)).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个`createtable`方法。这将是一个一次性函数，用于创建相应的数据库表。我们使用这个方法而不是直接在MySQL客户端中键入`CREATE
    TABLE`查询，以便有一个一致且可重复的创建（重新）创建表的方式。一般来说，我更喜欢使用完整的数据库迁移库，但现在，最好保持简单（你可以在[https://en.wikipedia.org/wiki/Schema_migration](https://en.wikipedia.org/wiki/Schema_migration)上阅读有关模式迁移的内容）。
- en: 'Without further ado, here''s our function:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，这是我们的函数：
- en: '[PRE102]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Here, we define an `sql` variable, which references the MySQL `CREATE TABLE`
    query, in the form of a `String`. The table will have four columns corresponding
    to the four fields of our `Article` type. Then, there's a fifth column, `url`,
    which will store the article's Wikipedia URL. We'll identify articles by URL—and
    for this reason, we add a unique index on the `url` column.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`sql`变量，它引用了一个`CREATE TABLE`查询，形式为一个`String`。该表将有四个列，对应于我们的`Article`类型的四个字段。然后还有一个第五列，`url`，它将存储文章的维基百科URL。我们将通过URL来识别文章——因此，我们在`url`列上添加了一个唯一索引。
- en: At the end of the function, we pass the query string to `MySQL.execute!` to
    be run against the DB connection. Please append the `createtable` definition to
    the end of the `Articles` module (within the module, above the closing `end`).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的末尾，我们将查询字符串传递给`MySQL.execute!`以在数据库连接上运行。请将`createtable`定义添加到`Articles`模块的末尾（在模块内，在关闭`end`之前）。
- en: 'Now, let''s see it in action. Open a new REPL session in the `sixdegrees/`
    folder and run the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它是如何工作的。在`sixdegrees/`文件夹中打开一个新的REPL会话，并运行以下命令：
- en: '[PRE103]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: That's it, our table is ready!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的表已经准备好了！
- en: The workflow should be pretty clear—we made sure we're loading our project's
    dependencies, we included the `Database.jl` and `Articles.jl` files, we brought
    `Articles` into scope, and then invoked its `createtable` method.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程应该是很清晰的——我们确保加载了我们的项目依赖项，包含了`Database.jl`和`Articles.jl`文件，将`Articles`引入作用域，然后调用了它的`createtable`方法。
- en: Adding the persistence and retrieval methods
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加持久化和检索方法
- en: We said that when an article is fetched and parsed, we want to store its data
    in the database. Thus, before fetching an article, we'll first want to check our
    database. If the article was previously persisted, we'll retrieve it. If not,
    we'll perform the original fetch-and-parse workflow. We use the `url` property
    to uniquely identify articles.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，当一篇文章被获取并解析后，我们希望将其数据存储到数据库中。因此，在获取文章之前，我们首先会检查我们的数据库。如果文章之前已经被持久化，我们将检索它。如果没有，我们将执行原始的获取和解析工作流程。我们使用`url`属性来唯一标识文章。
- en: 'Let''s start by adding the `Articles.save(a::Article)` method for persisting
    an article object:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加`Articles.save(a::Article)`方法来持久化文章对象：
- en: '[PRE104]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Here, we use `MySQL.Stmt` to create a MySQL prepared statement. The query itself
    is very simple, using MySQL's `INSERT IGNORE` statement, which makes sure that
    the `INSERT` operation is performed only if there is no article with the same
    `url`. If there is already an article with the same `url`, the query is ignored.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`MySQL.Stmt`来创建一个MySQL预编译语句。查询本身非常简单，使用了MySQL的`INSERT IGNORE`语句，确保只有当没有与相同`url`的文章时，才会执行`INSERT`操作。如果已经存在具有相同`url`的文章，则查询将被忽略。
- en: The prepared statement accepts a specially formatted query string, in which
    the actual values are replaced with placeholders, designated by question marks—`?`.
    We can then execute the prepared statement by passing it to `MySQL.execute!`,
    together with an array of corresponding values. The values are passed directly
    from the `article` object, with the exception of `links`. Since this represents
    a more complex data structure, a `Vector{String}`, we'll first serialize it using
    `JSON` and store it in MySQL as a string. To access functions from the `JSON`
    package, we'll have to add it to our project, so please execute `(sixdegrees)
    pkg> add JSON` in the REPL.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理语句接受一个特殊格式的查询字符串，其中实际值被占位符替换，占位符由问号`?`表示。然后我们可以通过将相应的值数组传递给`MySQL.execute!`来执行预处理语句。值直接从`article`对象传递，除了`links`。由于这代表一个更复杂的数据结构，一个`Vector{String}`，我们首先使用`JSON`序列化它，并将其作为字符串存储在MySQL中。为了访问`JSON`包中的函数，我们必须将其添加到我们的项目中，所以请在REPL中执行`(sixdegrees)
    pkg> add JSON`。
- en: Prepared statements provide a safe way to execute queries because the values
    are automatically escaped, eliminating a common source of MySQL injection attacks.
    In our case, MySQL injections are less of a worry since we're not accepting user-generated
    input. But, the approach is still valuable, avoiding insert errors caused by improper
    escaping.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理语句提供了一种安全地执行查询的方法，因为值会被自动转义，消除了MySQL注入攻击的常见来源。在我们的情况下，MySQL注入不太令人担忧，因为我们不接受用户生成的输入。但是，这种方法仍然很有价值，可以避免由于不当转义引起的插入错误。
- en: 'Next, we need a retrieval method. We''ll call it `find`. As its only attribute,
    it will take an article URL in the form of a `String`. It will return an `Array`
    of `Article` objects. By convention, if no corresponding article is found, the
    array will be empty:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个检索方法。我们将称之为`find`。作为它的唯一属性，它将接受一个形式为`String`的文章URL。它将返回一个`Article`对象的`Array`。按照惯例，如果没有找到相应的文章，数组将是空的：
- en: '[PRE105]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'In this function''s declaration, we can see another Julia feature: return value
    types. After the regular function declaration, `function find(url)`, we appended
    `:: Vector{Article}`. This constrains the return value of `find` to an array of
    `Article`. If our function won''t return that, an error will be thrown.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个函数的声明中，我们可以看到另一个Julia特性：返回值类型。在常规函数声明`function find(url)`之后，我们附加了`:: Vector{Article}`。这限制了`find`的返回值为一个`Article`数组。如果我们的函数不会返回那个值，将会抛出错误。'
- en: The rest of the code, although very compact, has quite a lot of functionality.
    First, we create `articles`, a vector of `Article` objects, which will be the
    return value of our function. Then, we execute a `SELECT` query against the MySQL
    database through the `MySQL.query` method, attempting to find rows that match
    the `url`. The result of the query is stored in the `result` variable, which is
    a `NamedTuple` (each field in the `result` `NamedTuple` references an array of
    values corresponding to the database column of the same name). Next, we peek into
    our query `result` to see if we got anything—we chose to sample the `result.url`
    field—if it's empty, it means our query didn't find anything and we can just exit
    the function, returning an empty `articles` vector.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分，虽然非常紧凑，但功能相当多。首先，我们创建了一个`articles`向量，其中包含`Article`对象，这将是我们函数的返回值。然后，我们通过`MySQL.query`方法对MySQL数据库执行一个`SELECT`查询，尝试找到匹配`url`的行。查询的结果存储在`result`变量中，它是一个`NamedTuple`（`result`
    `NamedTuple`中的每个字段都引用了一个与数据库列同名的值数组）。接下来，我们查看我们的查询结果`result`以查看是否得到了任何东西——我们选择采样`result.url`字段——如果它是空的，这意味着我们的查询没有找到任何东西，我们可以直接退出函数，返回一个空的`articles`向量。
- en: On the other hand, if `result.url` does contain entries, it means our query
    brought at least one row; so we iterate over the `result.url` array using `eachindex`,
    and for each iteration we construct an `Article` object with the corresponding
    values. Finally, we `push!` this new `Article` object into the `articles` vector
    which is returned, at the end of the loop.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果`result.url`确实包含条目，这意味着我们的查询至少返回了一行；因此，我们使用`eachindex`遍历`result.url`数组，并在每次迭代中用相应的值构建一个`Article`对象。最后，我们将这个新的`Article`对象`push!`到返回的`articles`向量中，循环结束后。
- en: Putting it all together
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: The last thing we need to do is update the rest of the code to work with the
    changes we've made so far.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新代码的其余部分，以适应我们迄今为止所做的更改。
- en: 'First of all, we need to update the `Article` type to add the extra `url` field.
    We need it in the list of fields and in the two constructors. Here is the final
    version of `Articles.jl`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更新 `Article` 类型以添加额外的 `url` 字段。我们需要在字段列表和两个构造函数中使用它。以下是 `Articles.jl`
    的最终版本：
- en: '[PRE106]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We also need to make a few important changes to `Wikipedia.jl`. First, we''ll
    remove `Article` instantiation from `Wikipedia.articleinfo` since creating `Article`
    objects should now also take into account database persistence and retrieval.
    Instead, we''ll return a tuple representing the article data:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对 `Wikipedia.jl` 进行一些重要的更改。首先，我们将从 `Wikipedia.articleinfo` 中删除 `Article`
    实例化，因为现在创建 `Article` 对象也应考虑数据库的持久化和检索。相反，我们将返回表示文章数据的元组：
- en: '[PRE107]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We can now add a new function, `persistedarticle`, which will accept as arguments
    the article content plus the article URL. It will instantiate a new `Article`
    object, save it to the database, and return it. In a way, `persistedarticle` can
    be considered a database-backed constructor, hence the name:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加一个新函数 `persistedarticle`，它将接受文章内容和文章 URL 作为参数。它将实例化一个新的 `Article` 对象，将其保存到数据库中，并返回它。从某种意义上说，`persistedarticle`
    可以被视为数据库支持的构造函数，因此得名：
- en: '[PRE108]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, you can see the *splat* operator `...` in action—it decomposes the `articleinfo`
    result `Tuple` into its corresponding elements so they can be passed into the
    `Article` constructor as individual arguments.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 *splat* 操作符 `...` 的实际应用——它将 `articleinfo` 结果 `Tuple` 分解为其对应的元素，以便它们可以作为单独的参数传递给
    `Article` 构造函数。
- en: Also, we have to deal with a minor complication. When we start a new game and
    call the `/wiki/Special:Random` URL, Wikipedia automatically performs a redirect
    to a random article. When we fetch the page, we get the redirected page content—but
    we don't have its URL.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须处理一个小的复杂问题。当我们开始新游戏并调用 `/wiki/Special:Random` URL 时，维基百科会自动将重定向到一个随机文章。当我们获取页面时，我们得到重定向页面的内容，但我们没有其
    URL。
- en: So, we need to do two things. Firstly, we need to check if our request has been
    redirected and, if so, get the redirection URL. In order to do this, we can check
    the `request.parent` field of the `response` object. In the case of a redirect,
    the `response.request.parent` object will be set and will present a `headers`
    collection. The collection will include a `"Location"` item—and that's what we're
    after.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要做两件事。首先，我们需要检查我们的请求是否已被重定向，如果是的话，获取重定向 URL。为了做到这一点，我们可以检查 `response.parent`
    字段。在重定向的情况下，`response.request.parent` 对象将被设置，并将呈现一个 `headers` 集合。该集合将包括一个 `"Location"`
    项——这正是我们所追求的。
- en: Secondly, we also need to return the URL together with the HTML content of the
    page. This is easy—we'll return a tuple.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们还需要返回页面的 HTML 内容以及 URL。这很简单——我们将返回一个元组。
- en: 'Here is the updated `fetchpage` function:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的 `fetchpage` 函数：
- en: '[PRE109]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Note that we also use `eachmatch` to extract the part corresponding to the relative
    URL out of the absolute URL.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还使用 `eachmatch` 从绝对 URL 中提取相应的相对 URL 部分。
- en: 'Here is the whole `Wikipedia.jl` file:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是整个 `Wikipedia.jl` 文件：
- en: '[PRE110]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, let''s focus on `Gameplay.jl`. We need to update the `newgame` function
    to take advantage of the newly available methods from the `Wikipedia` module:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于 `Gameplay.jl`。我们需要更新 `newgame` 函数以利用 `Wikipedia` 模块中新可用的方法：
- en: '[PRE111]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: If it's the first article, we fetch a random page and persist its data. Otherwise,
    we pick a random URL from the previously crawled page and check if a corresponding
    article already exists. If not, we fetch the page, making sure it's also persisted
    to the DB.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是第一篇文章，我们获取一个随机页面并持久化其数据。否则，我们从之前爬取的页面中随机选择一个 URL 并检查是否存在相应的文章。如果没有，我们获取该页面，确保它也被持久化到数据库中。
- en: 'Lastly, our point of entry into the app, the `six_degrees.jl` file, needs to
    look like this:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进入应用程序的入口点，即 `six_degrees.jl` 文件，需要看起来像这样：
- en: '[PRE112]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'A final test run should confirm that all is good:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试运行应该确认一切正常：
- en: '[PRE113]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Running the `six_degrees.jl` file with the `julia` binary in a terminal will
    output three Wikipedia article titles. And we can check the database to confirm
    that the data has been saved:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中使用 `julia` 二进制文件运行 `six_degrees.jl` 文件将输出三个维基百科文章标题。我们可以检查数据库以确认数据已被保存：
- en: '![](img/468c724e-157a-4188-a63d-d722a5197c3e.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](img/468c724e-157a-4188-a63d-d722a5197c3e.png)'
- en: The data for the three previously crawled pages has been safely persisted.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 之前爬取的三个页面的数据已安全持久化。
- en: Summary
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations, this was quite a journey! We've learned about three key Julia
    concepts—modules, types and their constructors, and methods. We've applied all
    this knowledge to develop the backend of our *Six Degrees of Wikipedia* game,
    and in the process we've seen how to interact with MySQL databases, persisting
    and retrieving our `Article` objects.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，这真是一次相当漫长的旅程！我们学习了三个关键的Julia概念——模块、类型及其构造函数，以及方法。我们将所有这些知识应用于开发我们的“维基百科六度分隔”游戏后端，在这个过程中，我们看到了如何与MySQL数据库交互，持久化和检索我们的`Article`对象。
- en: 'At the end of the next chapter, we''ll get the chance to enjoy the fruits of
    our hard work: after we add a web UI to our *Six degrees of Wikipedia* backend,
    we''ll relax by playing a few rounds. Let''s see if you can beat my best score!'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章的结尾，我们将有机会享受我们辛勤工作的果实：在我们为我们的“维基百科六度分隔”后端添加了Web UI之后，我们将通过玩几轮来放松。看看你是否能打败我的最佳成绩！
