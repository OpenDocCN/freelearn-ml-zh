- en: Chapter 5. Building Collaborative Filtering Recommendation Engines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：构建协同过滤推荐引擎
- en: In this chapter, we learn how to implement collaborative filtering recommendation
    systems using popular data analysis programming languages, R and Python. We will
    learn how to implement user-based collaborative filtering and item-based collaborative
    filtering in R and Python programming languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习如何使用流行的数据分析编程语言R和Python实现协同过滤推荐系统。我们将学习如何在R和Python编程语言中实现基于用户的协同过滤和基于物品的协同过滤。
- en: 'In this chapter, we learn about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The Jester5k dataset we will be using for this chapter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在本章中使用Jester5k数据集
- en: Exploring the dataset and understanding the data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索数据集和理解数据
- en: Recommendation engine packages/libraries available in R and Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R和Python中可用的推荐引擎包/库
- en: Building user-based collaborative filtering in R
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在R中构建基于用户的协同过滤
- en: Building item-based collaborative filtering in R
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在R环境中构建基于物品的协同过滤
- en: Building user-based collaborative filtering in Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中构建基于用户的协同过滤
- en: Item-based collaborative filtering in Python
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中构建基于物品的协同过滤
- en: Evaluating the model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估模型
- en: The **recommenderlab**, R package is a framework for developing and testing
    recommendation algorithms including user-based collaborative filtering, item-based
    collaborative filtering, SVD, and association rule-based algorithms, which are
    used to build recommendation engines. This package also provides basic infrastructure
    or mechanisms to develop our own recommendation engine methodology.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**recommenderlab**，R包是一个用于开发和使用包括基于用户的协同过滤、基于物品的协同过滤、SVD和基于关联规则的算法在内的推荐算法的框架，这些算法用于构建推荐引擎。此包还提供了基本的基础设施或机制来开发我们自己的推荐引擎方法。'
- en: Installing the recommenderlab package in RStudio
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在RStudio中安装recommenderlab包
- en: 'The following code snippet, will install the `recommenderlab` package into
    RStudio, if it is not available:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将安装`recommenderlab`包到RStudio中，如果尚未安装：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First the r-environment checks if there are any previous installations of the
    recommender lab package, if none are found then it installs as shown below:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，r环境检查是否有任何先前安装的recommender lab包，如果没有找到，则按以下方式安装：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following code snippet using `library()` loads the `recommenderlab` package
    into the r-environment:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用`library()`将`recommenderlab`包加载到r环境中：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To get help on the `recommenderlab` package using the help function, run the
    following command in Rstudio:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用帮助函数获取`recommenderlab`包的帮助，请在Rstudio中运行以下命令：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Check the help page for details on the usage of the package by clicking on
    the links provided:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击提供的链接检查帮助页面以获取有关包使用的详细信息：
- en: '![Installing the recommenderlab package in RStudio](img/image00320.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![在RStudio中安装recommenderlab包](img/image00320.jpeg)'
- en: Datasets available in the recommenderlab package
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: recommenderlab包中可用的数据集
- en: 'Like any other package available in R, `recommenderlab` also comes with default
    datasets. Run the following command to show the available packages:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与R中可用的任何其他包一样，`recommenderlab`也附带默认数据集。运行以下命令以显示可用的包：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Datasets available in the recommenderlab package](img/image00321.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![recommenderlab包中可用的数据集](img/image00321.jpeg)'
- en: Out of all the available datasets, we have chosen to use the `Jester5k` dataset
    for implementing user-based collaborative filtering and item-based collaborative
    filtering recommendation engines using R.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有可用的数据集中，我们选择使用`Jester5k`数据集来实现使用R的基于用户的协同过滤和基于物品的协同过滤推荐引擎。
- en: Exploring the Jester5K dataset
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Jester5K数据集
- en: 'In this section, we shall explore the `Jester5K` dataset as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将按以下方式探讨`Jester5K`数据集：
- en: Description
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: The dataset contains a sample of 5000 users from the Jester Online Joke Recommender
    System anonymous ratings data, collected between April 1999 and May 2003.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集包含来自Jester在线笑话推荐系统匿名评分数据的5000个用户样本，收集时间介于1999年4月到2003年5月之间。
- en: Usage
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Format
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式
- en: 'The format of `Jester5k` is: `Formal class ''realRatingMatrix'' [package "recommenderlab"]`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jester5k`的格式是：`Formal class ''realRatingMatrix'' [package "recommenderlab"]`。'
- en: The format of `JesterJokes` is a vector of character strings.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`JesterJokes`的格式是一个字符字符串向量。'
- en: Details
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详细信息
- en: '`Jester5k` contains a *5000 x 100* rating matrix (5000 users and 100 jokes)
    with ratings between -10.00 and +10.00\. All selected users have rated 36 or more
    jokes.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Jester5k`包含一个*5000 x 100*的评分矩阵（5000个用户和100个笑话），评分介于-10.00到+10.00之间。所有选定的用户都评分了36个或更多的笑话。'
- en: The data also contains the actual jokes in `JesterJokes`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据还包含 `JesterJokes` 中的实际笑话。
- en: 'The number of ratings present in the real-rating matrix is represented as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际评分矩阵中存在的评分数量表示如下：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can display the class of the rating matrices by running the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来显示评分矩阵的类别：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `recommenderlab` package efficiently stores the rating information in a
    compact way. Usually, rating matrices are sparse matrices. For this reason, the
    `realRatingMatrix` class supports a compact storage of sparse matrices.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommenderlab` 包以紧凑的方式高效地存储评分信息。通常，评分矩阵是稀疏矩阵。因此，`realRatingMatrix` 类支持稀疏矩阵的紧凑存储。'
- en: 'Let''s compare the size of `Jester5k` with the corresponding R matrix to understand
    the advantage of the real rating matrix, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 `Jester5k` 与相应的 R 矩阵的大小，以了解实际评分矩阵的优势，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We observe that the real-rating matrix stores `0.92` times less space than the
    R matrix. For collaborative filtering methods, which are memory-based models,
    where all the data is loaded into the memory while generating recommendations,
    storing data efficiently is very important. The `recommenderlab` package does
    this job efficiently.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到实际评分矩阵存储的空间比 R 矩阵少 `0.92` 倍。对于基于内存的协同过滤方法，这些方法是内存中的模型，在生成推荐时将所有数据加载到内存中，因此高效地存储数据非常重要。`recommenderlab`
    包有效地完成了这项工作。
- en: '`The recommenderlab` package exposes many functions which can be operated on
    using the rating matrix object. Run the following command to see the available
    methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`The recommenderlab` 包暴露了许多可以通过评分矩阵对象操作的功能。运行以下命令以查看可用方法：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Details](img/image00322.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![详细信息](img/image00322.jpeg)'
- en: 'Run the following commands to see the available recommendation algorithms in
    the `recommenderlab` package:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以查看 `recommenderlab` 包中可用的推荐算法：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Details](img/image00323.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![详细信息](img/image00323.jpeg)'
- en: 'The following code snippet displays the same result as in the previous image,
    `lapply()` function applies the function to all the elements of the list, in our
    case, for each of the items in the `recommender_models` object, `lapply` will
    extract the description and display the results as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示的结果与上一张图片相同，`lapply()` 函数将函数应用于列表的所有元素，在我们的案例中，对于 `recommender_models`
    对象中的每个项目，`lapply` 将提取描述并按以下方式显示结果：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exploring the dataset
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据集
- en: 'In this section let''s explore the data in more detail. To find the dimensions
    of the data and the type of data, run the following commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们更详细地探索数据。要查找数据的维度和数据类型，请运行以下命令：
- en: 'There are `5000` users and `100` items:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有 `5000` 个用户和 `100` 个项目：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The data is of R Matrix:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是 R 矩阵：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Exploring the rating values
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索评分值
- en: 'The following code snippet will help us understand the rating values distribution:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将帮助我们了解评分值的分布：
- en: 'Rating distribution is given as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 评分分布如下：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Exploring the rating values](img/image00324.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![探索评分值](img/image00324.jpeg)'
- en: The preceding image shows the frequency of the ratings available from the `Jester5K`
    dataset. We can observe that the negative ratings are more or less of uniform
    distribution or the same frequency, and the positive ratings are of a higher frequency
    and are declining towards the right of the plot. This may attribute to the bias
    induced by the ratings given by the users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片显示了 `Jester5K` 数据集中可用的评分的频率。我们可以观察到负评分大致呈均匀分布或相同的频率，而正评分频率较高，并向图表的右侧递减。这可能是用户给出的评分引入的偏差所致。
- en: Building user-based collaborative filtering with recommenderlab
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 recommenderlab 构建基于用户的协同过滤
- en: 'Run the following code in order to load the `recommenderlab` library and data
    into the R environment:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以将 `recommenderlab` 库和数据加载到 R 环境中：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s look at the sample rating data of the first six users on the first 10
    jokes. Run the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看前六个用户在第一个 10 个笑话上的样本评分数据。运行以下命令：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Building user-based collaborative filtering with recommenderlab](img/image00325.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![使用 recommenderlab 构建基于用户的协同过滤](img/image00325.jpeg)'
- en: We have looked at exploring the data in the previous section so we will get
    directly to building a user-based collaborative recommender system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中已经探讨了数据探索，因此我们将直接进入构建基于用户的协同推荐系统。
- en: 'This section is divided as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本节分为以下几部分：
- en: Building a base recommender model for benchmarking by splitting the data into
    80% training data and 20% test data.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将数据分为80%的训练数据和20%的测试数据来构建基准推荐模型。
- en: Evaluating the recommender model using a k-fold cross-validation approach model
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用k折交叉验证方法评估推荐模型
- en: Parameter tuning for the recommender model
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整推荐模型的参数
- en: Preparing training and test data
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备训练数据和测试数据
- en: 'For building and evaluating a recommender model, we need training data and
    test data. Run the following command to create it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建和评估推荐模型，我们需要训练数据和测试数据。运行以下命令来创建它们：
- en: 'We use the seed function for generating reproducible results:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用种子函数来生成可重复的结果：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The previous code creates a logical object with an equal length to the number
    of users. True indexes will be part of the train set and false indexes will be
    part of the test set.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个与用户数量相等的逻辑对象。真实的索引将是训练集的一部分，而假的索引将是测试集的一部分。
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a user-based collaborative model
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基于用户的协作模型
- en: 'Now, let''s create a recommendation model on the whole data of `Jester5k`.
    Before that, let''s explore the recommender models available and their parameters
    in the `recommenderlab` package as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`Jester5k`的全部数据上创建一个推荐模型。在此之前，让我们探索`recommenderlab`包中可用的推荐模型及其参数，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Creating a user-based collaborative model](img/image00326.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![创建基于用户的协作模型](img/image00326.jpeg)'
- en: Image we just saw displays the 6 different recommender models available and
    its parameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的图像显示了6种不同的推荐模型及其参数。
- en: 'Run the following code to build a user-based collaborative filtering model:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码来构建基于用户的协同过滤模型：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `recc_model@model$data` object contains the rating matrix. The reason for
    this is that UBCF is a lazy-learning technique, which means that it needs to access
    all the data to perform a prediction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`recc_model@model$data`对象包含评分矩阵。这是因为UBCF是一种懒学习技术，这意味着它需要访问所有数据来进行预测。'
- en: Predictions on the test set
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试集上的预测
- en: 'Now that we have built the model, let''s predict the recommendations on the
    test set. For this we will use the `predict()` function available in the library.
    We generate 10 recommendations per user. See the following code for the predictions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了模型，让我们在测试集上预测推荐。为此，我们将使用库中可用的`predict()`函数。我们为每个用户生成10个推荐。请参阅以下代码以获取预测结果：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resultant object is a list type given by the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码给出的结果是列表类型：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first two recommendations are given as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个推荐如下：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can observe that for user `u21505`, the top 10 recommendations are given
    as `j81, j73, j83, ... j96`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，对于用户`u21505`，前10个推荐是`j81, j73, j83, ... j96`。
- en: 'The following image shows the recommendations for four users:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了四个用户的推荐：
- en: '![Predictions on the test set](img/image00327.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![在测试集上的预测](img/image00327.jpeg)'
- en: 'Let''s see how many recommendations are generated for all the test users by
    running the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下代码来查看为所有测试用户生成了多少推荐：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From the above results, we see that for `286` users, zero recommendations were
    generated. The reason is that they have rated all the movies in the original dataset.
    For 691 users, 10 ratings for each of them has been generated, the reason is that
    in the original dataset, they have not rated for any movies. Other users who have
    received 2, 3, 4, and so on recommendations means that they have recommended very
    few movies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述结果中，我们看到对于`286`个用户，没有生成任何推荐。原因是他们已经对原始数据集中的所有电影进行了评分。对于`691`个用户，每个用户生成了10个评分，原因是他们在原始数据集中没有对任何电影进行评分。其他收到2、3、4等推荐的用户意味着他们推荐的电影非常少。
- en: Analyzing the dataset
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析数据集
- en: Before we evaluate the model, let's take one step back and analyze the data.
    By analyzing the number of ratings given by all the users for the jokes, we can
    observe that there are 1422 people who have rated all 100 jokes, which seems to
    be unusual as there are very few people who have rated 80 to 99 jokes. Further
    analyzing the jokes we find that, there are 221, 364, 312, and 131 users who have
    rated 71, 72, 73, and 74 jokes respectively which seems to be unusual compared
    to other joke ratings.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们评估模型之前，让我们退一步分析数据。通过分析所有用户对笑话给出的评分数量，我们可以观察到有`1422`个人对所有的`100`个笑话进行了评分，这似乎很不寻常，因为很少有人对80到99个笑话进行了评分。进一步分析笑话，我们发现，有`221`、`364`、`312`和`131`个用户分别对`71`、`72`、`73`和`74`个笑话进行了评分，这与其他笑话评分相比似乎很不寻常。
- en: 'Run the following code to extract the number of ratings given to each joke:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以提取每个笑话获得的评分数量：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Analyzing the dataset](img/image00328.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![分析数据集](img/image00328.jpeg)'
- en: 'For the next step, let''s remove the records of users who have rated 80 or
    more jokes as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，让我们删除评分了80个或更多笑话的用户的记录。
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The dimension has been reduced from `5000` to `3261` records.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 维度已从`5000`减少到`3261`条记录。
- en: Now let's analyze the average ratings given by each user. A boxplot shows us
    the average distribution of the joke ratings.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们分析每个用户给出的平均评分。箱线图显示了笑话评分的平均分布。
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Analyzing the dataset](img/image00329.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![分析数据集](img/image00329.jpeg)'
- en: 'The preceding image shows us that there are very few ratings that deviate from
    normal behavior. From the preceding image we see that the average ratings that
    are above 7 (approximately) and below -5 (approximately) are kind of outliers
    and are less in number. Let''s see the count by running the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示，很少有评分偏离正常行为。从前面的图像中我们可以看到，平均评分在7（大约）以上和-5（大约）以下的是一些异常值，数量较少。让我们通过运行以下代码来查看计数：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Analyzing the dataset](img/image00330.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![分析数据集](img/image00330.jpeg)'
- en: Dropping users who have given very low average ratings and very high average
    ratings.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 删除给出了非常低平均评分和非常高平均评分的用户。
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s examine the rating distribution of the first 100 users in the data as
    follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式检查数据中前100个用户的评分分布：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Analyzing the dataset](img/image00331.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![分析数据集](img/image00331.jpeg)'
- en: Evaluating the recommendation model using the k-cross validation
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用k交叉验证评估推荐模型
- en: The `recommenderlab` package provides an infrastructure for evaluating the models
    using the `evaluationScheme()` function. By definition, from the Cran website,
    evaluationScheme *creates an evaluationScheme object from a data set. The scheme
    can be a simple split into training and test data, k-fold cross-evaluation or
    using k independent bootstrap samples*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommenderlab`包提供了一个使用`evaluationScheme()`函数评估模型的框架。根据Cran网站的定义，evaluationScheme可以从数据集创建一个evaluationScheme对象。方案可以是简单的训练和测试数据分割，k折交叉验证或使用k个独立的自助样本。'
- en: 'The following are the arguments for the `evaluationScheme()` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`evaluationScheme()`函数的参数：
- en: '![Evaluating the recommendation model using the k-cross validation](img/image00332.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用k交叉验证评估推荐模型](img/image00332.jpeg)'
- en: 'We use cross-validation method to split the data, for example the 5-fold cross-validation
    approach divides the training data into five smaller sets where four sets will
    be used for training the model and the remaining one set is used for evaluating
    the model. Let''s define the parameters into minimum good ratings, number of folds
    for cross-validation method, and split method as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用交叉验证方法来分割数据，例如，5折交叉验证方法将训练数据分成五个更小的集合，其中四个集合用于训练模型，剩下的一个集合用于评估模型。让我们定义以下参数：最小良好评分、交叉验证方法的折数和分割方法：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s examine the size of the five sets formed by the cross-validation approach
    as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式检查由交叉验证方法形成的五个集合的大小：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to extract the sets, we need to use `getData()`. There are three sets:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取集合，我们需要使用`getData()`。有三个集合：
- en: '**train**: This is the training set'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**train**：这是训练集'
- en: '**known**: This is the test set, with the item used to build the recommendations'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**known**：这是测试集，用于构建推荐的项目'
- en: '**unknown**: This is the test set, with the item used to test the recommendations'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**unknown**：这是测试集，用于测试推荐的项目'
- en: 'Let''s take a look at the training set in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码中的训练集：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Evaluating user-based collaborative filtering
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估基于用户的协同过滤
- en: 'Now let''s evaluate the models, let''s set the parameters `model_to_evaluate`
    with user-based collaborative filtering and `model_parameters` with `NULL` for
    using default settings as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们评估模型，让我们将`model_to_evaluate`参数设置为基于用户的协同过滤，并将`model_parameters`设置为`NULL`以使用默认设置，如下所示：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next step is to build the recommender model using the recommender() function
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`recommender()`函数构建推荐模型，如下所示：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have seen that the user-based recommender model has been learned with a training
    data of `2528 users`. Now we can predict the known ratings in `eval_sets` and
    evaluate the results with unknown sets as described earlier.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，基于用户的推荐模型已经使用`2528`个用户的训练数据学习。现在我们可以预测`eval_sets`中的已知评分，并使用前面描述的未知集来评估结果。
- en: 'Before making the predictions for the known ratings, we have to set the number
    of items to be recommended. Next, we have to provide the test set to the `predict()`
    function for prediction. The prediction of ratings is done by running the following
    command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在对已知评分进行预测之前，我们必须设置要推荐的物品数量。接下来，我们必须将测试集提供给`predict()`函数进行预测。评分的预测是通过运行以下命令完成的：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Executing the `predict()` function will take time because the user-based collaborative
    filtering approach is memory-based and a lazy learning technique implemented at
    run time, to show that the whole dataset is loaded during the prediction.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`predict()`函数将花费时间，因为基于用户的协同过滤方法是基于内存的、在运行时实现的懒惰学习技术，以表明在预测过程中整个数据集被加载。
- en: 'Now we shall evaluate the predictions with the unknown sets and estimate the
    model accuracy with metrics such as precision, recall, and F1 measure. Run the
    following code to calculate the model accuracy metrics by calling the `calcPredicitonAccuracy()`
    method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用未知集评估预测，并使用精确率、召回率和F1度量等指标来估计模型精度。运行以下代码通过调用`calcPredictionAccuracy()`方法来计算模型精度指标：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'By setting `byUser = TRUE`, we are calculating the model accuracy for each
    user. Taking the average will give us the overall accuracy as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`byUser = TRUE`，我们正在计算每个用户的模型精度。取平均值将给出整体精度，如下所示：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'By setting `byUser=FALSE`, in the previous `calcPredictionAccuracy()` we can
    calculate the overall model accuracy given by the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`byUser=FALSE`，在先前的`calcPredictionAccuracy()`中，我们可以计算由以下给出的整体模型精度：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the previous approach, we evaluated the model accuracy using the **root
    mean squared error** (**RMSE**), and **mean absolute error** (**MAE**), but we
    can also evaluate the model accuracy using precision/recall For this, we use the
    `evaluate()` function and then the result of the `evaluate()` method is used to
    create a confusion matrix containing precision/recall/f1 measures as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的方法中，我们使用**均方根误差**（**RMSE**）和**平均绝对误差**（**MAE**）来评估模型精度，但我们也可以使用精确率/召回率来评估模型精度。为此，我们使用`evaluate()`函数，然后使用`evaluate()`方法的结果创建一个包含精确率/召回率/f1度量的混淆矩阵，如下所示：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Evaluating user-based collaborative filtering](img/image00333.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![评估基于用户的协同过滤](img/image00333.jpeg)'
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first four columns contain the true-false positives/negatives, and they
    are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前四列包含真实/假阳性/阴性，如下所示：
- en: '**True Positives** (**TP**): These are recommended items that have been rated
    correctly'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真阳性**（**TP**）：这些是被正确评分的推荐项目'
- en: '**False Positives** (**FP**): These are recommended items that haven''t been
    rated'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假阳性**（**FP**）：这些是没有被评分的推荐项目'
- en: '**False Negatives** (**FN**): These are not recommended items that have been
    rated'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假阴性**（**FN**）：这些是不推荐的、已经被评分的项目'
- en: '**True Negatives** (**TN**): These are not recommended items that haven''t
    been rated'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真阴性**（**TN**）：这些是没有被推荐的、没有被评分的项目'
- en: A perfect (or overfitted) model would have only `TP` and `TN`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美（或过度拟合）的模型将只有`TP`和`TN`。
- en: 'If we want to take account of all the splits at the same time, we can just
    sum up the indices as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想同时考虑所有分割，我们可以将索引相加，如下所示：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since summarizing the model is difficult by referring to the above table, we
    can use a `ROC curve` to evaluate the model. Use `plot()` to build the ROC plot
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通过上述表格很难总结模型，我们可以使用ROC曲线来评估模型。使用`plot()`来构建ROC图，如下所示：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Evaluating user-based collaborative filtering](img/image00334.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![评估基于用户的协同过滤](img/image00334.jpeg)'
- en: The preceding plot shows the relation between **True Positive Rate** (**TPR**)
    and **False Positive Rate** (**FPR**), but we have to choose the values in such
    a way that we give a trade-off between TPR and FPR. In our case, we observe that
    *nn=30* is a very good trade-off since when considering neighbors of 30 we have
    TPR closer to *0.7*, FPR is *0.4* and when moving to *nn=40* the TPR is still
    close to *0.7* but the FPR has been changed to *0.4.* This means that the False
    Positive Rate has been increased.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了**真阳性率**（**TPR**）和**假阳性率**（**FPR**）之间的关系，但我们必须选择这样的值，以便在TPR和FPR之间进行权衡。在我们的案例中，我们观察到*nn=30*是一个非常好的权衡点，因为当我们考虑30个邻居时，TPR接近*0.7*，FPR是*0.4*，当移动到*nn=40*时，TPR仍然接近*0.7*，但FPR已经变为*0.4*。这意味着假阳性率已经增加。
- en: Building an item-based recommender model
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基于物品的推荐模型
- en: 'As with UBCF, we use the same `Jester5k` dataset for the item-based recommender
    system. In this section, we do not explore the data as we have already done so
    in the previous section. We first remove the user data of those who have rated
    all the items and also those records who have rated more than `80` as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与 UBCF 一样，我们使用相同的 `Jester5k` 数据集作为基于物品的推荐系统。在本节中，我们不会探索数据，因为我们已经在上一节中这样做过了。我们首先移除那些对所有物品都进行了评分的用户数据，以及那些评分超过
    `80` 的记录，如下所示：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now let''s see how the average ratings are distributed for each user:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看每个用户的平均评分是如何分布的：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![Building an item-based recommender model](img/image00335.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![构建基于物品的推荐模型](img/image00335.jpeg)'
- en: 'The following code snippet calculates the average ratings given by each user
    and identifies users who have given extreme ratings - either very high ratings
    or very low ratings:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段计算了每个用户给出的平均评分，并识别了给出极端评分的用户——要么是极高的评分，要么是极低的评分：
- en: 'From the below results, we observe that there are 19 records with very high
    average ratings and 79 records with very low ratings, compared with the majority
    of users:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下结果中，我们可以观察到有 19 条记录的平均评分非常高，而与大多数用户相比，有 79 条记录的评分非常低：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Of the total `3261` records, only `98` records had much less than the average
    and much more than the average ratings, so we removed these from our dataset as
    follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在总共 `3261` 条记录中，只有 `98` 条记录的平均评分远低于平均值，远高于平均值，因此我们将这些记录从数据集中移除，如下所示：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'From here, we divide the sections as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们将章节划分为以下几部分：
- en: Building the IBCF recommender model using the training and test data.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用训练数据和测试数据构建 IBCF 推荐模型。
- en: Evaluating the model
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估模型
- en: Parameter tuning
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数调整
- en: Building an IBCF recommender model
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 IBCF 推荐模型
- en: 'The first step in building any recommender model is to prepare the training
    data. Previously, we have prepared the data required for building the model by
    removing outlying data. Now run the following code to divide the available data
    into two sets: 80% training set and 20% test set. We build the recommender model
    using the training data and generate the recommendations on the test set.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 构建任何推荐模型的第一个步骤是准备训练数据。之前，我们已经通过移除异常数据来准备了构建模型所需的数据。现在运行以下代码将可用数据分为两个集合：80% 的训练集和
    20% 的测试集。我们使用训练数据构建推荐模型并在测试集上生成推荐。
- en: 'The following code first creates a logical object of the same length as the
    original dataset containing 80% elements as TRUE and 20% as a test:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码首先创建了一个与原始数据集长度相同的逻辑对象，其中包含 80% 的元素为 TRUE，20% 为测试：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then we use the logical object in the `model_data` to generate the training
    set as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `model_data` 中的逻辑对象生成训练集，如下所示：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then we use the logical object in the `model_data` to generate the test set
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `model_data` 中的逻辑对象生成测试集，如下所示：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now that we have prepared the training set and the test set, let's train the
    model and generate the top recommendations on the test set.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了训练集和测试集，让我们训练模型并在测试集上生成顶级推荐。
- en: For model building, as mentioned in the UBCF section, we use the same `recommender()`
    function available in the `recommenderlab` package. Run the following code to
    train the model with training data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型构建，如 UBCF 部分所述，我们使用 `recommenderlab` 包中可用的相同的 `recommender()` 函数。运行以下代码使用训练数据训练模型。
- en: 'Set the parameters for the `recommender()` function. We set the model to evaluate
    as `"IBCF"` and `k=30`. `k` is the number of neighbors to be considered while
    calculating the similarity values as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `recommender()` 函数设置参数。我们将模型设置为评估 `"IBCF"` 并设置 `k=30`。`k` 是在计算相似度值时需要考虑的邻居数量，如下所示：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following code snippet shows building the recommendation engine model using
    the `recommender()` function and its input parameters such as input data, model
    to evaluate the parameters, and the k parameter:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用 `recommender()` 函数及其输入参数（如输入数据、评估参数的模型和 k 参数）构建推荐引擎模型：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The IBCF model object is created as a `model_recommender`. This model is trained
    and learned using the `2506` training set we created earlier as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: IBCF 模型对象被创建为 `model_recommender`。该模型使用我们之前创建的 `2506` 条训练集进行训练和学习，如下所示：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that we have created the model, let''s explore the model bit. We use `getModel()`
    available in the `recommenderlab` to extract the model details as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了模型，让我们来探索一下模型。我们使用 `recommenderlab` 中的 `getModel()` 函数提取模型细节，如下所示：
- en: '![Building an IBCF recommender model](img/image00336.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![构建 IBCF 推荐模型](img/image00336.jpeg)'
- en: From the above results, the important parameters to note are `k` value, the
    default similarity value, and method, `cosine similarity`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述结果中，需要注意的重要参数是`k`值、默认相似度值和方法，即`余弦相似度`。
- en: The final step is to generate the recommendations on the test set. Run the following
    code on the test set and generate the recommendations.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在测试集上生成推荐。在测试集上运行以下代码以生成推荐。
- en: '`items_to_recommend` is the parameter to set the number of recommendations
    to be generated for each user:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`items_to_recommend`是设置每个用户要生成的推荐数量的参数：'
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Call the `predict()` method available in the reocommenderlab package to predict
    the unknowns in the test set:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 调用reocommenderlab包中可用的`predict()`方法来预测测试集中的未知项：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can get the slot details of the prediction object using the `slotNames()`
    method:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`slotNames()`方法获取预测对象的槽位详情：
- en: '[PRE56]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s have a look of the predictions generated for the first user in the test
    set:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看测试集中第一个用户的预测结果：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s add the item labels to each of the predictions:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在每个预测中添加项目标签：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Model evaluation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型评估
- en: Let's take one step back to evaluate the recommender model before we generate
    the predictions. As we saw in UBCF, we can use the available `evaluationScheme()`
    method. We use the cross-validation setting to generate the training and test
    sets. Then we make predictions on each test set and evaluate the model accuracy.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们生成预测之前，让我们退一步来评估推荐器模型。正如我们在UBCF中看到的，我们可以使用可用的`evaluationScheme()`方法。我们使用交叉验证设置来生成训练集和测试集。然后我们在每个测试集上做出预测并评估模型准确性。
- en: Run the following code to generate the training and test sets.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以生成训练集和测试集。
- en: '`n_fold` defines the 4-fold cross-validation, that divides the data into 4
    sets; 3 training sets and 1 test set:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`n_fold`定义了4折交叉验证，将数据分为4个集合；3个训练集和1个测试集：'
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`items_to_keep` defines the minimum number of items to use to generate recommendations:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`items_to_keep`定义了用于生成推荐的最低项目数量：'
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`rating_threshold` defines the minimum rating which is considered as a good
    rating:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`rating_threshold`定义了被认为是良好评分的最小评分：'
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`evaluationScheme` method creates the test sets:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`evaluationScheme`方法创建测试集：'
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Set the `model_to_evaluate` to set the recommender method to be used. `model_parameters`
    defines the model parameters such as the number of neighbors to be considered
    while computing the similarity using cosine. For now we will set it as `NULL`
    in order to make the model choose the default values, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将`model_to_evaluate`设置为设置要使用的推荐器方法。`model_parameters`定义了模型参数，例如在计算余弦相似度时考虑的邻居数量。目前我们将它设置为`NULL`，以便模型选择默认值，如下所示：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Use the `recommender()` method to generate the model. Let''s understand each
    parameter of the `recommender()` method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`recommender()`方法生成模型。让我们了解`recommender()`方法的每个参数：
- en: '`getData` extracts the training data from `eval_sets` and passes it on to the
    `recommender()` method as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`getData`从`eval_sets`中提取训练数据，并将其按如下方式传递给`recommender()`方法：'
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Since we are using 4-folds cross-validation, the `recommender()` method uses
    the three sets from `eval_sets` for training and the remaining one set for testing/
    evaluating the model as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用4折交叉验证，`recommender()`方法使用`eval_sets`中的三个集合进行训练，剩余的一个集合用于测试/评估模型，如下所示：
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now we use the built model to make predictions on a `"known"` dataset from
    `eval_sets`. As seen before, we use the `predict()` method to generate the predictions
    as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用构建的模型在`eval_sets`的“已知”数据集上做出预测。如前所述，我们使用`predict()`方法生成预测，如下所示：
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Model accuracy using metrics
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指标评估模型准确性
- en: Until now, the procedure has been the same as for making the initial predictions,
    now we will see how to evaluate the model accuracy for the predictions made on
    the "known" set of test data from `eval_sets`. As we saw in the UBCF section,
    we use the `calcPredictionAccuracy()` method to calculate the prediction accuracy.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，该过程与制作初始预测的过程相同，现在我们将看到如何评估在`eval_sets`的“已知”测试数据集上做出的模型准确性。正如我们在UBCF部分所看到的，我们使用`calcPredictionAccuracy()`方法来计算预测准确性。
- en: 'We use the `calcPredictionAccuracy()` method and pass the `"unknown"` dataset
    available in the `eval_sets` as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`calcPredictionAccuracy()`方法，并将`eval_sets`中可用的`"unknown"`数据集作为如下所示：
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using `byUser = TRUE` in the previous method calculates the accuracy for each
    user. In the table above we can see that for user - `u238` the `RMSE` is `4.62`
    and `MAE` is `4.25`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中使用`byUser = TRUE`计算每个用户的准确度。在上面的表中，我们可以看到对于用户`u238`，`RMSE`为`4.62`，`MAE`为`4.25`
- en: 'If we want to see the accuracy of the whole model, just calculate the mean
    of each column, that is to say the average for all the users as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想看到整个模型的准确度，只需计算每列的平均值，即所有用户的平均值，如下所示：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'By setting `byUser=FALSE` we can calculate the model accuracy for the whole
    model:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`byUser=FALSE`，我们可以计算整个模型的模型准确度：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Model accuracy using plots
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用图表展示模型准确度
- en: Now we can see the model accuracy using Precision-Recall, ROC curves, and precision/recall
    curves. These curves help us to decide the trade-off between Precision-Recall
    while choosing the parameters we use for the recommender models, IBCF in our case.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到使用Precision-Recall、ROC曲线和精度/召回曲线来展示模型准确度。这些曲线帮助我们决定在为推荐模型选择参数时Precision-Recall之间的权衡，在我们的案例中是IBCF。
- en: 'We use the `evaluate()` method and then set the n value which defines the number
    of nearest neighbors while calculating the similarities between items as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`evaluate()`方法，然后设置n值，该值定义了在计算项目之间的相似度时最近邻的数量，如下所示：
- en: 'Running the following evaluate method makes the model run four times for each
    dataset:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下评估方法使模型对每个数据集运行四次：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s see the model accuracy at each fold:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个折的模型准确度：
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![Model accuracy using plots](img/image00337.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![使用图表展示模型准确度](img/image00337.jpeg)'
- en: 'Let''s sum up all the 4-fold results using the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码汇总所有4折结果：
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![Model accuracy using plots](img/image00338.jpeg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![使用图表展示模型准确度](img/image00338.jpeg)'
- en: 'From the previous table, we can observe that the model accuracy, Precision-Recall
    values are good for n values of 30 and 40\. The same results can be visually inferred
    using ROC curves and Precision-Recall plots as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个表中，我们可以观察到，当n值为30和40时，模型准确率和Precision-Recall值都很好。同样，可以使用ROC曲线和Precision-Recall图直观地得出相同的结果，如下所示：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '![Model accuracy using plots](img/image00339.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![使用图表展示模型准确度](img/image00339.jpeg)'
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![Model accuracy using plots](img/image00340.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![使用图表展示模型准确度](img/image00340.jpeg)'
- en: Parameter tuning for IBCF
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IBCF的参数调整
- en: 'While building the IBCF model there are a few places where we can choose the
    optimal values before we generate recommendations for building a final model:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建IBCF模型时，在生成最终模型推荐之前，我们可以选择一些最优值：
- en: We have to choose, optimal number of neighbors for calculating the similarities
    between items
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须选择计算项目之间相似度时最优的邻居数量
- en: Similarity method to be used, whether it is the cosine or Pearson method
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用的相似度方法，无论是余弦还是Pearson方法
- en: 'See the following steps:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤：
- en: 'First set the different k-values:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先设置不同的k值：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Use `lapply` to generate different models using the cosine method and different
    values of k:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lapply`生成使用余弦方法和不同k值的模型：
- en: '[PRE76]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![Parameter tuning for IBCF](img/image00341.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![IBCF的参数调整](img/image00341.jpeg)'
- en: 'Set the total number of recommendations to be generated:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要生成的推荐总数：
- en: '[PRE77]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Call the evaluate method to the build 4-fold methods:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 调用评估方法到构建4折方法：
- en: '[PRE78]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now that we have got the results, let''s plot and choose the optimal parameters
    as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了结果，让我们绘制并选择最优参数，如下所示：
- en: '[PRE79]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![Parameter tuning for IBCF](img/image00342.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![IBCF的参数调整](img/image00342.jpeg)'
- en: From the preceding plot, the best methods are IBCF with cosine similarity with
    *n = 30*, and the next best is the Pearson method with *n = 40*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，最佳方法是使用余弦相似度的IBCF，n值为30，其次是使用Pearson方法的n值为40。
- en: 'Let''s confirm this with the `Precision-Recall` curve as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下`Precision-Recall`曲线来确认这一点：
- en: '[PRE80]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '![Parameter tuning for IBCF](img/image00343.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![IBCF的参数调整](img/image00343.jpeg)'
- en: From the above plot we see that the best Precision-Recall ratio is achieved
    when the number of recommendations = 30 with cosine similarity and *n=40*. Another
    good model is achieved with the Pearson similarity method and *n=10*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图中我们可以看到，当推荐数量=30且使用余弦相似度和n=40时，实现了最佳的Precision-Recall比率。另一个好的模型是通过使用Pearson相似度方法和n=10实现的。
- en: Collaborative filtering using Python
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行协同过滤
- en: In the previous section we saw implementations of user-based recommender systems
    and item-based recommender systems using the R package, `recommenderlab`. In this
    section, we see UBCF and IBCF implementation using the Python programming language.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了使用 R 包 `recommenderlab` 实现基于用户的推荐系统和基于物品的推荐系统的实现。在本节中，我们将看到使用 Python
    编程语言实现的 UBCF 和 IBCF 实现。
- en: For this section, we use the MovieLens 100k dataset, which contains 943 user
    ratings on 1682 movies. Unlike in R, in Python we do not have a proper Python
    package dedicated to building recommender engines, at least the neighborhood-based
    recommenders such as user-based/item-based recommenders.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们使用 MovieLens 100k 数据集，其中包含 943 个用户对 1682 部电影的评分。与 R 不同，在 Python 中我们没有专门用于构建推荐引擎的
    Python 包，至少没有基于邻居的推荐器，如基于用户/基于物品的推荐器。
- en: We have the Crab Python package available but it is not actively supported.
    So I thought of building a recommender engine using scientific packages in Python
    such as NumPy, sklearn, and Pandas.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 Crab Python 包可用，但它没有得到积极支持。因此，我想使用 Python 中的科学包（如 NumPy、sklearn 和 Pandas）构建推荐引擎。
- en: Installing the required packages
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装所需的包
- en: 'For this section, please make sure you have the following system requirements:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，请确保您满足以下系统要求：
- en: Python 3.5
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.5
- en: Pandas 1.9.2 - Pandas is an open source, BSD-licensed library providing high-performance,
    easy-to-use data structures, and data analysis tools for the Python programming
    language.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas 1.9.2 - Pandas 是一个开源的、BSD 许可的库，为 Python 编程语言提供高性能、易于使用的数据结构和数据分析工具。
- en: NumPy 1.9.2 - NumPy is the fundamental package for scientific computing with
    Python.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 1.9.2 - NumPy 是 Python 科学计算的基础包。
- en: sklearn 0.16.1
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sklearn 0.16.1
- en: Tip
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The best way to install the preceding packages is to install, Anaconda distribution
    which will install all the required packages such as Python, Pandas, and Numpy.
    Anaconda can be found at:[https://www.continuum.io/downloads](https://www.continuum.io/downloads)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 安装前面提到的最佳方式是安装 Anaconda 发行版，这将安装所有所需的包，如 Python、Pandas 和 Numpy。Anaconda 可以在
    [https://www.continuum.io/downloads](https://www.continuum.io/downloads) 找到。
- en: Data source
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据来源
- en: 'The MovieLens 100k data can be downloaded from the following link:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: MovieLens 100k 数据可以从以下链接下载：
- en: '[http://files.grouplens.org/datasets/movielens/ml-100k.zip](http://files.grouplens.org/datasets/movielens/ml-100k.zip)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://files.grouplens.org/datasets/movielens/ml-100k.zip](http://files.grouplens.org/datasets/movielens/ml-100k.zip)'
- en: Let's get started with implementing user-based collaborative filtering. Assuming
    we have downloaded the data into our local system, let's load the data into a
    Python environment.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现基于用户的协同过滤开始。假设我们已经将数据下载到本地系统，让我们将数据加载到 Python 环境中。
- en: 'We load the data using the Pandas package and the `read_csv()` method by passing
    two parameters, path and separator as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Pandas 包和 `read_csv()` 方法通过传递两个参数，路径和分隔符来加载数据，如下所示：
- en: '[PRE81]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The data will be loaded as a DataFrame, a table-like data structure that can
    easily be used for data handling and manipulation tasks.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 数据将以 DataFrame 的形式加载，这是一种类似于表格的数据结构，可以轻松用于数据处理和操作任务。
- en: '[PRE82]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Let''s see the first six results of the data frame to have a look at how data
    seems to be using the `head()` method available in the Pandas DataFrame object:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用 Pandas DataFrame 对象中可用的 `head()` 方法查看数据框的前六个结果，以了解数据似乎是如何使用的：
- en: '[PRE83]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let''s see the column names of the data frame, `df` using the columns attributes.
    The result of the following code snippet shows that there are four columns: `UserID`,
    `ItemId`, `Rating`, `Timestamp`, and that it is of the object datatype:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `columns` 属性查看数据框 `df` 的列名。以下代码片段的结果显示有四个列：`UserID`、`ItemId`、`Rating`、`Timestamp`，并且它是对象数据类型：
- en: '[PRE84]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s see the size of the data frame by calling the shape attribute; we observe
    that we have 100k records with 4 columns:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用 shape 属性来查看数据框的大小；我们观察到我们有 100k 条记录，4 列：
- en: '[PRE85]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Data exploration
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据探索
- en: In this section, we will explore the MovieLens dataset and also prepare the
    data required for building collaborative filtering recommendation engines using
    python.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索 MovieLens 数据集，并准备使用 Python 构建协同过滤推荐引擎所需的数据。
- en: 'Let''s see the distribution of ratings using the following code snippet:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码片段查看评分的分布：
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'From the following image we see that we have more movies with 4 star ratings:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下图像中我们可以看到，有更多电影获得了 4 星评级：
- en: '![Data exploration](img/image00344.jpeg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![数据探索](img/image00344.jpeg)'
- en: 'Using the following code snippet, we shall see the counts of ratings by applying
    the `groupby()` function and the `count()` function on DataFrame:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段，我们将通过在 DataFrame 上应用 `groupby()` 函数和 `count()` 函数来查看评分的计数：
- en: '![Data exploration](img/image00345.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![数据探索](img/image00345.jpeg)'
- en: 'The following code snippet shows the distribution of movie views. In the following
    code we apply the `count()` function on DataFrame:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了电影观看的分布。在以下代码中，我们在 DataFrame 上应用 `count()` 函数：
- en: '[PRE87]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '![Data exploration](img/image00346.jpeg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![数据探索](img/image00346.jpeg)'
- en: From the previous image, we can observe that the starting ItemId has more ratings
    than later movies.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图像中，我们可以观察到起始 ItemId 的评分比后来的电影多。
- en: Rating matrix representation
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评分矩阵表示
- en: Now that we have explored the data, let's represent the data in a rating matrix
    form so that we can get started with our original task of building a recommender
    engine.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了数据，让我们以评分矩阵的形式表示数据，这样我们就可以开始我们的原始任务，即构建推荐引擎。
- en: 'For creating a rating matrix, we make use of NumPy package capabilities such
    as arrays and row iterations in a matrix. Run the following code to represent
    the data frame in a rating matrix:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建评分矩阵，我们利用 NumPy 包的功能，如数组和矩阵中的行迭代。运行以下代码以将数据框表示为评分矩阵：
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the following code, first we extract all the unique user IDs and then we
    check the length using the shape parameter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们首先提取所有唯一的用户 ID，然后使用形状参数检查长度。
- en: 'Create a variable of `n_users` to find the total number of unique users in
    the data:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `n_users` 的变量来查找数据中的总唯一用户数：
- en: '[PRE88]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Create a variable `n_items` to find the total number of unique movies in the
    data:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个变量 `n_items` 来查找数据中的总唯一电影数：
- en: '[PRE89]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Print the counts of unique users and movies:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 打印唯一用户和电影的计数：
- en: '[PRE90]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create a zero value matrix of size (*n_users x n_items*) to store the ratings
    in the cell of the matrix ratings:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个大小为 (*n_users x n_items*) 的零值矩阵来存储矩阵中的评分：
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For each tuple in the DataFrame, `df` extracts the information from each column
    of the row and stores it in the rating matrix cell value as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DataFrame 中的每个元组，`df` 从行的每一列中提取信息，并将其存储在评分矩阵的单元格值中，如下所示：
- en: '[PRE92]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Run the loop and the whole DataFrame movie ratings information will be stored
    in the matrix ratings of the `numpy.ndarray` type as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 运行循环，整个 DataFrame 电影评分信息将按如下方式存储在 `numpy.ndarray` 类型的矩阵 `ratings` 中：
- en: '[PRE93]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now let''s see the dimensions of the multidimensional array ''ratings'' using
    the shape attribute as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用形状属性查看多维数组 'ratings' 的尺寸：
- en: '[PRE94]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Let''s see the sample data for how a ratings multidimensional array looks by
    running the following code:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下代码来查看评分多维数组的样本数据：
- en: '[PRE95]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We observe that the rating matrix is sparse as we see a lot of zeros in the
    data. Let''s determine the `sparsity` in the data, by running the following code:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到评分矩阵是稀疏的，因为数据中有许多零。让我们通过运行以下代码来确定数据中的 `sparsity`：
- en: '[PRE96]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We observe that the sparsity is `6.3%` that is to say that we only have rating
    information for `6.3%` of the data and for the others it is just zeros. Also please
    note that, the `0` value we see in the rating matrix doesn't represent the rating
    given by the user, it just means that they are empty.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到稀疏度为 `6.3%`，也就是说，我们只有 `6.3%` 的数据有评分信息，其余的只是零。另外请注意，评分矩阵中我们看到的 `0` 值并不代表用户给出的评分，它只是表示它们是空的。
- en: Creating training and test sets
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建训练集和测试集
- en: Now that we have a ratings matrix, let's create a training set and test set
    to build the recommender model using a training set and evaluate the model using
    a test set.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了评分矩阵，让我们创建一个训练集和一个测试集，使用训练集构建推荐模型，并使用测试集评估模型。
- en: 'To divide the data into training and test sets, we use the `sklearn` package''s
    capabilities. Run the following code to create training and test sets:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据分为训练集和测试集，我们使用 `sklearn` 包的功能。运行以下代码以创建训练集和测试集：
- en: 'Load the `train_test_split` module into the python environment using the following
    import functionality:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下导入功能将 `train_test_split` 模块加载到 Python 环境中：
- en: '[PRE97]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Call the `train_test_split()` method with a test size of `0.33` and random
    seed of `42`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `train_test_split()` 方法，测试集大小为 `0.33`，随机种子为 `42`：
- en: '[PRE98]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Let''s see the dimensions of the train set:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看火车模型的尺寸：
- en: '[PRE99]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: For user-based collaborative filtering, we predict that a user's rating for
    an item is given by the weighted sum of all other users' ratings for that item,
    where the weighting is the cosine similarity between each user and the input user.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于用户的协同过滤，我们预测一个用户对项目的评分是所有其他用户对该项目的评分的加权平均，其中权重是每个用户与输入用户之间的余弦相似度。
- en: The steps for building a UBCF
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建UBCF的步骤
- en: 'The steps for building a UBCF are:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 构建UBCF的步骤如下：
- en: Creating a similarity matrix between the users
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户之间创建相似度矩阵。
- en: Predicting the unknown rating value of item *i* for an active user *u* by calculating
    the weighted sum of all the users' ratings for the item.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过计算所有用户对项目的评分的加权平均来预测活跃用户*u*对项目*i*的未知评分值。
- en: Tip
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Here the weighting is the cosine similarity calculated in the previous step
    between the user and neighboring users.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，权重是之前步骤中用户和邻近用户之间计算的余弦相似度。
- en: Recommending the new items to the users.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户推荐新项目。
- en: User-based similarity calculation
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于用户的相似度计算
- en: 'The next step is to create pairwise similarity calculations for each user in
    the rating matrix, that is to say we have to calculate the similarity of each
    user with all the other users in the matrix. The similarity calculation we choose
    here is cosine similarity. For this, we make use of pairwise distance capabilities
    to calculate the cosine similarity available in the `sklearn` package as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为评分矩阵中的每个用户创建成对相似度计算，也就是说，我们必须计算矩阵中每个用户与其他所有用户的相似度。我们在这里选择的相似度计算方法是余弦相似度。为此，我们利用成对距离能力来计算`sklearn`包中可用的余弦相似度，如下所示：
- en: '![User-based similarity calculation](img/image00347.jpeg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![基于用户的相似度计算](img/image00347.jpeg)'
- en: 'Let''s see a sample dataset of the distance matrix:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看距离矩阵的一个示例数据集：
- en: '[PRE100]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '![User-based similarity calculation](img/image00348.jpeg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![基于用户的相似度计算](img/image00348.jpeg)'
- en: Predicting the unknown ratings for an active user
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测活跃用户的未知评分。
- en: 'As previously mentioned, the unknown values can be calculated for all the users
    by taking the dot product between the distance matrix and the rating matrix and
    then normalizing the data with the number of ratings as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以通过将距离矩阵和评分矩阵之间的点积以及用评分数量对数据进行归一化来计算所有用户的未知值如下：
- en: '[PRE101]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now that we have predicted the unknown ratings for use in the training set,
    let''s define a function to check the error or performance of the model. The following
    code defines a function for calculating the root mean square error (RMSE) by taking
    the predicted values and original values. We use `sklearn` capabilities for calculating
    RMSE as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经预测了用于训练集的未知评分，让我们定义一个函数来检查模型的误差或性能。以下代码定义了一个函数，通过取预测值和原始值来计算均方根误差（RMSE）。我们使用`sklearn`的能力来计算RMSE，如下所示：
- en: '[PRE102]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We call the `get_mse()` method to check the model prediction error rate as
    follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`get_mse()`方法来检查模型预测误差率，如下所示：
- en: '[PRE103]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We see that the model accuracy or RMSE is `7.8`. Now let''s run the same `get_mse()`
    method on the test data and check the accuracy as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到模型的准确率或RMSE是`7.8`。现在让我们在测试数据上运行相同的`get_mse()`方法并检查准确率，如下所示：
- en: '[PRE104]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: User-based collaborative filtering with the k-nearest neighbors
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于用户的k近邻协同过滤
- en: If we observe the RMSE values in the above model, we can see that the error
    is a bit higher. The reason may be that we have chosen all the users' rating information
    while making the predictions. Instead of considering all the users, let's consider
    only the top-N similar users' ratings information and then make the predictions.
    This may result in improving the model accuracy by eliminating some biases in
    the data.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察上述模型中的RMSE值，我们可以看到误差略高。原因可能在于我们在进行预测时选择了所有用户的评分信息。而不是考虑所有用户，让我们只考虑相似度最高的N个用户的评分信息，然后进行预测。这可能会通过消除数据中的某些偏差来提高模型准确率。
- en: To explain in a more elaborate way; in the previous code we predicted the ratings
    of the users by taking the weighted sum of the ratings of all users, instead we
    first chose the top-N similar users for each user and then the ratings were calculated
    by considering the weighted sum of the ratings of these top-N users.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地解释；在之前的代码中，我们通过取所有用户的评分的加权平均来预测用户的评分，而我们现在首先为每个用户选择前N个相似用户，然后通过考虑这些前N个用户的评分的加权平均来计算评分。
- en: Finding the top-N nearest neighbors
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到前N个最近邻。
- en: Firstly, for computational easiness, we shall choose the top five similar users
    by setting a variable, *k*.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了计算上的简便，我们将通过设置变量*k*来选择前五个相似用户。
- en: '*k=5*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*k=5*'
- en: 'We use the k-nearest neighbors method to choose the top five nearest neighbors
    for an active user. We will see this in action shortly. We choose sklearn.knn
    capabilities for this task as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用k-最近邻方法为活跃用户选择前五个最近邻。我们很快就会看到这一点。我们选择sklearn.knn功能来完成这项任务，如下所示：
- en: '[PRE105]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Define the `NearestNeighbors` object by passing k and the similarity method
    as parameters:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递k和相似度方法作为参数定义`NearestNeighbors`对象：
- en: '[PRE106]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Fit the training data to the `nearestNeighbor` object:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 将训练数据拟合到`nearestNeighbor`对象：
- en: '[PRE107]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Calculate the top five similar users for each user and their similarity values,
    that is the distance values between each pair of users:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每个用户的前五个相似用户及其相似度值，即每对用户之间的距离值：
- en: '[PRE108]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We can observe below that the resultant `top_k_distances` ndarray contains
    similarity values and top five similar users for each users in the training set:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到以下结果，`top_k_distances` ndarray包含相似度值和训练集中每个用户的前五个相似用户：
- en: '[PRE109]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Let''s see the top five users that are similar to user 1 in the training set:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看训练集中与用户1相似的前五个用户：
- en: '[PRE110]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The next step would be to choose only the top five users for each user and use
    their rating information while predicting the ratings using the weighted sum of
    all of the ratings of these top five similar users.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是为每个用户选择前五个用户，并在预测评分时使用他们的评分信息，即使用这五个相似用户的所有评分的加权总和。
- en: 'Run the following code to predict the unknown ratings in the training data:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以预测训练数据中的未知评分：
- en: '[PRE111]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Let''s see the data predicted by the model as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模型预测的数据如下：
- en: '[PRE112]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The following image displays the results for `user_pred_k`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了`user_pred_k`的结果：
- en: '![Finding the top-N nearest neighbors](img/image00349.jpeg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![寻找前N个最近邻](img/image00349.jpeg)'
- en: 'Now let''s see if the model has improved or not. Run the get_mse() method defined
    earlier as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看模型是否有所改进。运行之前定义的get_mse()方法如下：
- en: '[PRE113]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Item-based recommendations
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物品的推荐
- en: IBCF is very similar to UBCF but with very minor changes in how we use the rating
    matrix.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: IBCF与UBCF非常相似，但在如何使用评分矩阵方面有非常小的变化。
- en: 'The first step is to calculate the similarities between movies, as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是计算电影之间的相似度，如下所示：
- en: 'Since we have to calculate the similarity between movies, we use movie count
    as `k` instead of user count:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须计算电影之间的相似度，所以我们使用电影计数作为`k`而不是用户计数：
- en: '[PRE114]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We fit the transpose of the rating matrix to the `NearestNeighbors` object:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将评分矩阵的转置拟合到`NearestNeighbors`对象：
- en: '[PRE115]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Calculate the cosine similarity distance between each movie pair:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 计算每对电影之间的余弦相似度距离：
- en: '[PRE116]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The next step is to predict the movie ratings using the following code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用以下代码预测电影评分：
- en: '[PRE117]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The following image shows the result for `item_pred`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了`item_pred`的结果：
- en: '![Item-based recommendations](img/image00350.jpeg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![基于物品的推荐](img/image00350.jpeg)'
- en: Evaluating the model
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估模型
- en: 'Now let''s evaluate the model using the `get_mse()` method we have defined
    by passing the prediction ratings and the training and test set as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们定义的`get_mse()`方法评估模型，通过传递预测评分以及训练和测试集如下：
- en: '[PRE118]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The training model for k-nearest neighbors
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: k-最近邻的训练模型
- en: 'Run the following code to calculate the distance matrix for the top 40 nearest
    neighbors and then calculate the weighted sum of ratings by the top 40 users for
    all the movies. If we closely observe the code, it is very similar to what we
    have done for UBCF. Instead of passing `ratings_train` as is, we transpose the
    data matrix and pass to the previous code as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以计算前40个最近邻的距离矩阵，然后计算所有电影的前40个用户的加权评分总和。如果我们仔细观察代码，它与我们之前为UBCF所做的工作非常相似。我们不是直接传递`ratings_train`，而是转置数据矩阵，并按如下方式传递给前面的代码：
- en: '[PRE119]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Evaluating the model
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估模型
- en: The follow code snippet calculates the mean squared error for the training and
    test set. We can observe that the training error is 11.12 whereas the test error
    is 12.12.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段计算训练和测试集的均方误差。我们可以观察到训练误差为11.12，而测试误差为12.12。
- en: '[PRE120]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored building collaborative filtering approaches
    such as user-based and item-based approaches in R and Python, the popular data
    mining programming languages. The recommendation engines are built on MovieLens,
    and Jester5K datasets available online.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在R和Python中构建协同过滤方法，如基于用户和基于物品的方法，这两种是流行的数据挖掘编程语言。推荐引擎建立在MovieLens和Jester5K数据集上，这些数据集可在网上找到。
- en: We have learnt about how to build the model, choose data, explore the data,
    create training and test sets, and evaluate the models using metrics such as RMSE,
    Precision-Recall, and ROC curves. Also, we have seen how to tune parameters for
    model improvements.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何构建模型、选择数据、探索数据、创建训练集和测试集，以及使用如RMSE、精确率-召回率和ROC曲线等指标来评估模型。此外，我们还了解了如何调整参数以改进模型。
- en: In the next chapter, we will be covering personalized recommendation engines
    such as content-based recommendation engines and context-aware recommendation
    engines using R and Python.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍使用R和Python实现的个性化推荐引擎，例如基于内容的推荐引擎和上下文感知的推荐引擎。
