- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Segmenting Customers with Machine Learning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器学习进行客户细分
- en: With the rising availability of data on customer characteristics and behaviors,
    it has become more accessible to approach customers with more informed insights.
    From analyzing the drivers behind customer engagements that we discussed in *Chapter
    3* to understanding which specific products that individual customers may like,
    which we touched on in *Chapter 7*, the assumptions behind these approaches were
    based on the fact that there are certain groups of similar customers that behave
    in similar fashions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着关于客户特征和行为数据的日益丰富，用更深入的见解来接近客户变得更加容易。从分析我们在*第3章*中讨论的客户参与背后的驱动因素，到理解个人客户可能喜欢哪些具体产品，这是我们*第7章*中提到的，这些方法的假设是基于存在某些行为方式相似的客户群体这一事实。
- en: Targeted marketing approaches are proven to work significantly better than mass
    marketing, due to which **customer segmentation** has been a frequently discussed
    topic in this domain. Also, with the upcoming cookieless world, first-party data
    is expected to play an even more critical role. Consequently, targeted strategies
    based on customer segments, such as geographic segments, demographic segments,
    or interest topic segments that will still be available without browser cookies,
    are going to be critical for success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于定向营销方法已被证明比大众营销更有效，因此**客户细分**一直是该领域经常讨论的话题。此外，随着无cookie世界的到来，第一方数据预计将发挥更加关键的作用。因此，基于客户细分（如地理细分、人口统计细分或兴趣主题细分）的策略，这些细分在浏览器cookie不可用的情况下仍然可用，对于成功至关重要。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: One-time versus repeat customers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性客户与回头客
- en: Customer segmentation with K-means clustering and purchase behaviors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用K-means聚类和购买行为进行客户细分
- en: Customer segmentation with **large language models** (**LLMs**) and product
    interests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**大型语言模型**（**LLMs**）和产品兴趣进行客户细分
- en: One-time versus repeat customers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次性客户与回头客
- en: According to *BIA Advisory Services*, which provides some very clear metrics,
    repeat customers spend 67% more than new customers on average. Also, a survey
    conducted by *BIA Advisory Services* says that over half of the surveyed businesses’
    revenue comes from repeat customers rather than new customers. This signifies
    the fact that retaining existing customers is as important as growing the customer
    base. However, businesses often sacrifice customer service to gain new customers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供了一些非常清晰的指标的*BIA顾问服务*，回头客平均比新客户多花费67%。此外，*BIA顾问服务*进行的一项调查表明，超过一半的调查企业收入来自回头客，而不是新客户。这表明保留现有客户与扩大客户基础同样重要。然而，企业往往为了获取新客户而牺牲客户服务。
- en: '**BIA Advisory Services report**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**BIA顾问服务报告**'
- en: '[https://www.bia.com/small-business-owners-shift-investment-from-customer-acquisition-to-customer-engagement-new-report-by-manta-and-biakelsey/](https://www.bia.com/small-business-owners-shift-investment-from-customer-acquisition-to-customer-engagement-new-report-by-manta-and-biakelsey/)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.bia.com/small-business-owners-shift-investment-from-customer-acquisition-to-customer-engagement-new-report-by-manta-and-biakelsey/](https://www.bia.com/small-business-owners-shift-investment-from-customer-acquisition-to-customer-engagement-new-report-by-manta-and-biakelsey/)'
- en: The need to retain customers
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留客户的需求
- en: 'There are several benefits that indicate why retaining customers is so important
    to businesses:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 保留客户对业务来说如此重要的几个好处表明了原因：
- en: '**Less investment**: The first obvious reason is that new customers cost more.
    If you recall a typical customer life cycle from *Chapter 2*, you need to spend
    capital and marketing resources to promote brand awareness among potential new
    customers, engage prospects with your business, and then finally convert them
    into paying customers.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投资减少**：第一个显而易见的原因是新客户成本更高。如果您还记得*第2章*中典型的客户生命周期，您需要投入资本和营销资源来提高潜在新客户的品牌知名度，与潜在客户建立业务联系，然后最终将他们转化为付费客户。'
- en: '![](img/B30999_08_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_01.png)'
- en: 'Figure 8.1: The customer life cycle'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：客户生命周期
- en: For existing customers, you can skip these steps and focus your efforts on retaining
    them as repeat customers by providing great customer service and introducing products
    that interest them enough. Obtaining new customers often costs multiple times
    more than keeping existing customers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现有客户，您可以跳过这些步骤，专注于通过提供优质的客户服务和介绍他们感兴趣的产品，将他们作为回头客保留下来。获取新客户通常比保留现有客户成本高出数倍。
- en: '**Greater reliability**: Repeat customers bring more reliable and recurring
    revenue to your business. As previously mentioned, repeat customers often contribute
    more than half of the revenue for businesses and spend more than new customers.
    As you provide products or services that existing customers like and as you provide
    better customer services, your customers may become loyal to your brand and continue
    to purchase products.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的可靠性**: 重复客户为你的业务带来了更可靠和可重复的收入。如前所述，重复客户通常贡献了超过一半的业务收入，并且比新客户花费更多。随着你提供现有客户喜欢的产品或服务，以及你提供更好的客户服务，你的客户可能会对你的品牌忠诚，并继续购买产品。'
- en: For example, if you are selling pet products, such as pet food or pet toys,
    and they like your products, they may come back next month to purchase more or
    even subscribe to get monthly pet foods delivered to them. This results in a reliable
    and recurring revenue stream that is going to strengthen the cash flow of your
    business, which you can use to invest more into your products, which will bring
    in more revenue. This starts the positive cycle for your business.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在销售宠物产品，比如宠物食品或宠物玩具，并且他们喜欢你的产品，他们下个月可能会回来购买更多，甚至订阅以每月获得宠物食品的配送。这导致了一个可靠且可重复的收入流，这将加强你业务的现金流，你可以用这些资金投资更多到你的产品上，这将带来更多的收入。这开始了你业务的积极循环。
- en: '**Building brand loyalty**: Repeat customers who are loyal to your business
    bring in more new customers. As you may recall from *Chapter 2*, loyal customers
    act as your brand ambassadors and marketing agents, where they spread the word
    about your business and bring in new customers. Without having to spend more marketing
    dollars, these loyal customers promote your business and attract new customers.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建立品牌忠诚度**: 对你的业务忠诚的重复客户会带来更多的新客户。如你可能在 *第二章* 中回忆的那样，忠诚的客户充当你的品牌大使和营销代理，他们传播关于你业务的信息并吸引新客户。无需花费更多的营销费用，这些忠诚的客户就会推广你的业务并吸引新客户。'
- en: There are many more subtle benefits to having a strong repeat customer base,
    but these are the three most obvious benefits of having repeat customers, and
    demonstrate how they help businesses significantly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个强大的重复客户基础还有许多其他微妙的好处，但这些都是拥有重复客户最明显的三个好处，并展示了它们如何显著帮助业务。
- en: Analyzing the impact of retaining customers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析保留客户的影响
- en: 'Let’s take a look at a practical example of the kinds of impacts these repeat
    customers have on the business compared to new customers:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际例子，看看这些重复客户与新客户相比对业务产生的影响：
- en: '**Source code and data**: [https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/tree/main/ch.8](https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/tree/main/ch.8
    )'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码和数据**: [https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/tree/main/ch.8](https://github.com/PacktPublishing/Machine-Learning-and-Generative-AI-for-Marketing/tree/main/ch.8)'
- en: '**Data source**: [https://archive.ics.uci.edu/dataset/352/online+retail](https://archive.ics.uci.edu/dataset/352/online+retail)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据来源**: [https://archive.ics.uci.edu/dataset/352/online+retail](https://archive.ics.uci.edu/dataset/352/online+retail)'
- en: 'As always, we will start by importing the data into a `pandas` DataFrame. Take
    a look at the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将首先将数据导入到一个 `pandas` DataFrame 中。看看下面的代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we load the data into a `pandas` DataFrame, `df`. As we are only interested
    in comparing new versus repeat customers, we are going to drop the rows with `NaN`
    values using the `dropna` function and only take the customers who have purchased
    at least one or more items by filtering with `df["Quantity"] > 0`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将数据加载到一个 `pandas` DataFrame，`df` 中。因为我们只对比较新客户和重复客户感兴趣，我们将使用 `dropna` 函数删除包含
    `NaN` 值的行，并通过 `df["Quantity"] > 0` 过滤只取至少购买了一件或更多商品的客户。
- en: 'Then, we are going to create the following additional variables:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建以下额外的变量：
- en: '**Sales amount**: By simply multiplying the quantity that the customers have
    purchased by the individual price of the items, we can get the total sales amount
    for each order. In the following code, we create a new column named `Sales`, which
    has the total sales amount for each order:'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销售额**: 通过简单地将客户购买的数量乘以单个商品的价格，我们可以得到每个订单的总销售额。在下面的代码中，我们创建了一个名为 `Sales` 的新列，它包含每个订单的总销售额：'
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Month variable**: In order to decide whether a given customer is a new customer
    or not, we need to consider the time horizon of the data. If a given customer
    has not purchased any items previously, then this customer will be considered
    new. On the other hand, if a given customer has purchased an item previously,
    then we will consider this customer a repeat customer. For this exercise, we are
    going to look at month-over-month data, which will require us to create a variable
    for what month the invoice was created. In the following code, we convert the
    column, `InvoiceDate`, into the `datetime` type and cast `InvoiceDate` into each
    month. For example, the date `2011-02-23` will be cast to `2011-02-01`:'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**月份变量**：为了确定一个客户是否是新客户，我们需要考虑数据的时间范围。如果一个客户之前没有购买任何商品，那么这个客户将被视为新客户。另一方面，如果一个客户之前购买过商品，那么我们将这个客户视为回头客。在这个练习中，我们将查看月度数据，这需要我们创建一个变量来表示发票是在哪个月创建的。在下面的代码中，我们将`InvoiceDate`列转换为`datetime`类型，并将`InvoiceDate`转换为每个月。例如，日期`2011-02-23`将被转换为`2011-02-01`：'
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With these two variables, we can now start dissecting whether the sales are
    from the new or repeat customers. Take a look at the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这两个变量，我们可以开始分析销售是否来自新客户或回头客。看看下面的代码：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s take a closer look at this code. We first iterate through each month
    in the `month` variable. For each iteration, we find the unique customers in the
    given month and store them as a set into a variable, named `curr_customers`. We
    do the same for the past customers by getting the unique customers up to the given
    month and storing them as a set in a variable named `prev_customers`. Based on
    these two variables, we can identify the new customers from the repeat customers
    by using some set operations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这段代码。我们首先遍历`month`变量中的每个月。对于每次迭代，我们找到给定月份的唯一客户，并将它们存储为一个集合，命名为`curr_customers`。我们同样为过去客户做同样的操作，通过获取到给定月份的唯一客户，并将它们存储为一个集合，命名为`prev_customers`。基于这两个变量，我们可以通过一些集合操作来识别新客户和回头客：
- en: First, we find the intersection between `curr_customers` and `prev_customers`,
    which represent the repeat customers as we have seen these customers in our sales
    data already.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们找到`curr_customers`和`prev_customers`的交集，这代表回头客，因为我们已经在销售数据中看到了这些客户。
- en: Next, we subtract the `prev_customers` set from the `curr_customers` set, which
    gives us the new customers as these are the customers that we have not seen before.
    From these operations, we have successfully identified new versus repeat customers.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从`curr_customers`集合中减去`prev_customers`集合，这给出了新客户，因为这些是我们之前没有见过的客户。通过这些操作，我们已经成功识别了新客户和回头客。
- en: Based on these `prev_customers` and `curr_customers` sets, we can find the revenue
    from the new and repeat customers. Using the `isin` function, we select the `CustomerIDs`
    that match the IDs in the set of `new_customers` and compute the total sales from
    the new customers by summing all the sales amounts from these customers and the
    average sales amount for the new customers by taking a mean of all the sales amounts
    from these customers. Similarly, using the `isin` function, we select the `CustomerIDs`
    that match the IDs in the set of `repeat_customers` and compute the total sales
    from the repeat customers. We do this by summing all the sales amounts from these
    customers and the average sales amount for the repeat customers by taking a mean
    of all the sales amounts from these customers. We save this data into a variable,
    `monthly_data`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些`prev_customers`和`curr_customers`集合，我们可以找到新客户和回头客带来的收入。使用`isin`函数，我们选择与`new_customers`集合中的ID匹配的`CustomerIDs`，通过将这些客户的全部销售额相加来计算新客户的总销售额，并通过取这些客户的全部销售额的平均值来计算新客户的平均销售额。同样，使用`isin`函数，我们选择与`repeat_customers`集合中的ID匹配的`CustomerIDs`，通过将这些客户的全部销售额相加来计算回头客的总销售额。我们通过取这些客户的全部销售额的平均值来计算回头客的平均销售额。我们将这些数据保存到一个变量中，名为`monthly_data`。
- en: 'We do one last set of computations as in the following and will be ready to
    look at the differences between the new and repeat customers:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行最后一组计算，如下所示，并将准备好查看新客户和回头客之间的差异：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code simply converts the data into a `pandas` DataFrame and computes what
    percentage of customers are actually repeat customers and what percentage of sales
    are from the repeat customers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是将数据转换成`pandas` DataFrame，并计算有多少比例的客户是回头客，以及有多少比例的销售来自回头客。
- en: 'Now that we’re done, let’s take a look at the monthly customer counts and the
    breakdowns between the new and repeat customers using the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了，让我们使用以下代码查看每月客户数量以及新客户和回头客之间的细分：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should produce the following chart:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成以下图表：
- en: '![](img/B30999_08_02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_02.png)'
- en: 'Figure 8.2: The number of new versus repeat customers'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：新客户与回头客的数量对比
- en: The bars on the left for each time period represent the number of new customers
    for each month and the bars on the right represent the number of repeat customers.
    As you can see, the composition of the repeat customers grows over time and there
    is some cycle in terms of the influx of the new customers. We see more new customers
    at the beginning and end of the year and dips during the summertime from June
    to August.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个时间段的左侧条形表示每个月的新客户数量，右侧条形表示回头客的数量。正如你所看到的，回头客的构成随着时间的推移而增长，新客户的流入量也存在某种周期性。我们在年初和年底看到更多的新客户，而在六月至八月夏季期间有所下降。
- en: The line chart shows what percentage of the customers in each month were repeat
    customers and as this chart suggests, it grew from around 40% in January 2011
    to around 80% in November 2011.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 线形图显示了每个月客户中回头客所占的百分比，正如这个图表所暗示的，它从2011年1月的大约40%增长到2011年11月的大约80%。
- en: This indicates a very healthy business. It shows continuous demand and purchases
    from the customers who have made previous purchases from this business. The number
    of repeat customers continuously grows, which suggests that the products and services
    this business provides continuously attract customers who have once interacted
    with this business. For a business that lacks attractive products and/or good
    customer service, the number of repeat customers will typically decrease. One
    thing to note here though is that the rate of new customer influx is relatively
    steady and not growing. This, of course, is better than a decreasing new customer
    count over time, but this shows that there is a growth potential to capture more
    new customers. Given that there is a healthy repeat and recurring customer base,
    the marketers can focus on new customer acquisition more for this business.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明这是一个非常健康的业务。它显示了来自已经从这个业务中进行过购买的客户持续的需求和购买。回头客的数量持续增长，这表明这个业务提供的产品和服务持续吸引那些曾经与这个业务互动过的客户。对于一个缺乏吸引人的产品以及/或者良好客户服务的业务，回头客的数量通常会减少。不过，这里需要注意的是，新客户的流入率相对稳定，并没有增长。当然，这比随着时间的推移新客户数量减少要好，但这表明有增长潜力来吸引更多的新客户。鉴于有一个健康的回头客和重复购买客户群，营销人员可以更多地关注这个业务的新客户获取。
- en: 'Similarly, let’s take a look at the sales amount from the new and repeat customers.
    Take a look at the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们看看新客户和回头客的销售金额。看看以下代码：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code produces the following chart:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成以下图表：
- en: '![](img/B30999_08_03.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_03.png)'
- en: 'Figure 8.3: Sales from new versus repeat customers'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：新客户与回头客的销售对比
- en: Similar to before, the bars on the left represent the sales amount from new
    customers and the bars on the right represent the sales amount from repeat customers.
    As was the case with a number of customer comparisons before, the sales amount
    from repeat customers outweighs the sales amount from new customers. This suggests
    that there is a strong continuous recurring revenue from repeat customers. The
    percentage of sales from the repeat customers reached above 80% in November 2011\.
    This is somewhat expected as we have discussed previously how repeat customers
    often take up more than half of the revenue for the businesses. Another point
    discussed previously and reported by *BIA Advisory Services* was that repeat customers
    typically spend 67% more than new customers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前类似，左侧的条形表示新客户的销售额，右侧的条形表示回头客的销售额。正如之前在许多客户比较中看到的那样，回头客的销售额超过了新客户的销售额。这表明回头客有很强的持续重复收入。回头客的销售额百分比在2011年11月达到了80%以上。这在我们之前讨论过回头客通常占企业收入一半以上时是预料之中的。之前讨论并报告的另一个观点是由*BIA
    Advisory Services*提出的，即回头客通常比新客户多花费67%。
- en: 'Now let’s see what our data says about this business by comparing average monthly
    sales from new customers against repeat customers. Take a look at the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过比较新客户和回头客的平均月销售额来查看我们的数据对这个业务说了什么。看看以下代码：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code should produce a chart like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该生成以下图表：
- en: '![](img/B30999_08_04.png)Figure 8.4: Average sales from new versus repeat customers'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B30999_08_04.png)图8.4：新客户与回头客的平均销售额'
- en: Similarly, the bars on the left are the average sales from the new customers
    and the bars on the right are the average sales from the repeat customers for
    each month. The line plot shows the ratios between the average sales of the new
    customers versus those of the repeat customers. For example, if the ratio is `1.5`,
    it means that the repeat customers spent `1.5` times more than the new customers
    on average during that month. Based on this example dataset, we see that, on average,
    repeat customers spent more than the average customers for all months reported.
    In November 2011, the ratio was `1:1.58`, which suggests that the repeat customers
    spent about 60% more than the new customers on average. This aligns with the *BIA
    Advisory Services* report that repeat customers spend significantly more than
    new customers on average.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，左侧的柱状图是新客户的平均销售额，右侧的柱状图是回头客的平均销售额，每个月都有。折线图显示了新客户平均销售额与回头客平均销售额之间的比率。例如，如果比率是`1.5`，这意味着回头客在那个月平均花费是新客户的`1.5`倍。根据这个示例数据集，我们看到，在所有报告的月份中，回头客的平均花费都高于平均客户。在2011年11月，比率是`1:1.58`，这意味着回头客平均比新客户多花费了大约60%。这与*BIA顾问服务*的报告相符，该报告指出回头客平均比新客户花费更多。
- en: 'In this exercise, we have dissected the customer base into two simple segments:
    new versus repeat. As you may have noticed, this is a simple analytical exercise
    to conduct, but this produces powerful insights into the dynamics and health of
    the business and also tells the marketers which group of customers to focus on.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将客户基础划分为两个简单的部分：新客户与回头客。正如你可能已经注意到的，这是一项简单的分析练习，但它能产生对业务动态和健康状况的深刻见解，同时也告诉营销人员应该关注哪一群客户。
- en: If there is a strong recurring customer base with continuous recurring revenue,
    but it shows steadiness or a decreasing new customer base, it suggests that marketers
    should focus more on new customer acquisition.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个强大的回头客基础，并且有持续的收入，但新客户基础显示出稳定或下降的趋势，这表明营销人员应该更加关注新客户的获取。
- en: On the other hand, if there is a decline in repeat customers, it suggests that
    the products and services may not be attractive for customers to come back or
    that the customer service does not meet the customer expectations. In this case,
    the marketers should focus on improving the product marketing strategies, customer
    satisfaction strategies, or other marketing strategies to attract customers to
    come back for repeated purchases.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果回头客的数量下降，这可能表明产品和服务可能对顾客没有吸引力，或者客户服务未能达到顾客的期望。在这种情况下，营销人员应该专注于改进产品营销策略、客户满意度策略或其他营销策略，以吸引顾客进行重复购买。
- en: Customer segmentation with purchase behaviors
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于购买行为的客户细分
- en: Segmenting customers based on new versus repeat customers is one of the basic
    and critical analyses to conduct. However, oftentimes, we would like to segment
    customers based on multiple factors, which can be demographic factors, such as
    age, geolocation, and occupation, or purchase history, such as how much they spent
    in the past year, how many items they have purchased, and how many returns they
    have requested. You can also segment based on customer web activities, such as
    number of logins in the past X number of days, how long they stay on your webpage,
    and what pages they look at.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据新客户与回头客对客户进行细分是进行的基本且关键的分析之一。然而，很多时候，我们希望根据多个因素对客户进行细分，这些因素可以是人口统计因素，如年龄、地理位置和职业，或者是购买历史，如他们在过去一年中花费了多少钱，他们购买了哪些商品，以及他们请求了多少次退货。你还可以根据客户的网络活动进行细分，例如过去X天内登录的次数，他们在你的网页上停留的时间，以及他们查看的页面。
- en: There are still challenges to segmenting customers based on these factors, as
    there are an infinite number of ways and values you can segment the customers
    by. For example, if you are segmenting your customers by age, some of the questions
    that may arise are “`how many buckets should I create?`" or “`what age cutoff
    thresholds should I choose?`". Similarly, if you want to segment your customers
    by past sales volume, you will still have to choose what thresholds to use to
    break down the customer base and how many segments you want to create.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些因素对客户进行细分仍然存在挑战，因为你可以以无数种方式和值来细分客户。例如，如果你根据年龄细分客户，可能会出现一些问题，比如“我应该创建多少个桶？”或者“我应该选择什么年龄截止阈值？”类似地，如果你想根据过去销售量细分客户，你仍然需要选择用于细分客户基础和希望创建多少个细分的阈值。
- en: 'Furthermore, when you combine these segments across multiple factors, the number
    of segments grows exponentially. For example, if you have 2 segments based on
    the sales volume and combine it with the other 2 segments from purchase quantity,
    you will end up with 4 segments. If you had 3 segments for both factors, then
    you would end up with 9 segments in total. In summary, there are mainly three
    key questions to be answered in conducting customer segmentation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你将多个因素结合这些细分时，细分数量会呈指数增长。例如，如果你基于销售量有2个细分，并将其与其他基于购买数量的2个细分相结合，你将最终得到4个细分。如果你对两个因素都有3个细分，那么总共将得到9个细分。总之，在执行客户细分时，主要有三个关键问题需要回答：
- en: What factor(s) should be used for customer segmentation?
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪些因素进行客户细分？
- en: How many segments should be created?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该创建多少个细分？
- en: What thresholds should be used to break down into segments?
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用什么阈值来细分到细分？
- en: We are going to use the online retail dataset that we have used previously as
    an example and discuss how to answer these key questions with the K-means clustering
    algorithm and silhouette score for measuring the effectiveness of clusters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前使用过的在线零售数据集作为示例，并讨论如何使用K-means聚类算法和轮廓分数来回答这些关键问题，以衡量聚类的有效性。
- en: K-means clustering
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: K-means聚类
- en: K-means clustering is one of the most frequently used machine learning algorithms
    for clustering and segmentation. It is a method to partition the data into *k*
    clusters. In short, the algorithm iteratively finds the centroids and groups the
    data points to the nearest centroids until the data points are closer to their
    centroids than to their neighboring centroids. As you can imagine, the data points
    in our case will be the factors of interest, such as sales amount, quantity, and
    refund, and the “*k*” in K-means clustering is how many clusters or customer segments
    we would like to create.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: K-means聚类是用于聚类和分割的最常用的机器学习算法之一。它是一种将数据划分为*k*个聚类的算法。简而言之，该算法迭代地找到质心并将数据点分组到最近的质心，直到数据点比其邻近的质心更接近其质心。正如你可以想象的那样，我们案例中的数据点将是感兴趣的因子，例如销售额、数量和退款，而在K-means聚类中的“*k*”是我们希望创建多少个聚类或客户细分。
- en: 'In order to create customer segments based on the total sales amount, order
    quantity, and refunds, we need to do some prep work. Take a look at the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据总销售额、订单数量和退款创建客户细分，我们需要做一些准备工作。看看以下代码：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we first get the net sales and quantity for each customer. This will
    subtract any refunds and returned items as there are some records with negative
    `Sales` and `Quantity` values. Next, we get the information about the refunds.
    We assume any quantity that is negative is a refund. Thus, we get the total refund
    amount by summing all the sales with the negative quantity values and the total
    refund quantity by summing all the order quantities with the negative quantity
    values. Lastly, we merge these two DataFrames by the index, which is the customer
    ID. The resulting DataFrame should look like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先获取每个客户的净销售额和数量。这将减去任何退款和退货项，因为有一些记录的销售额和数量值为负。接下来，我们获取关于退款的信息。我们假设任何负数数量都是退款。因此，我们通过求和所有负数量值的销售额来获取总退款金额，通过求和所有负数量值的订单数量来获取总退款数量。最后，我们通过索引（即客户ID）合并这两个DataFrame。生成的DataFrame应该看起来像以下这样：
- en: '![](img/B30999_08_05.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B30999_08_05.png)'
- en: 'Figure 8.5: The resulting net sales, net quantity, refund amount, and refund
    quantity'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：生成的净销售额、净数量、退款金额和退款数量
- en: 'One thing to note here is that the data is highly skewed. Take a look at the
    following code, which we will be using to generate histograms:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的一点是数据高度偏斜。看看以下代码，这是我们用来生成直方图的代码：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This gives us the following plots:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下图表：
- en: '![](img/B30999_08_06.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_06.png)'
- en: 'Figure 8.6: Data distribution'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：数据分布
- en: 'As you can see from these histograms, the data is highly skewed to the right.
    This occurs often, especially when the data has monetary or quantity values. Skewness
    in data causes disproportionate clusters with suboptimal segmentation of data.
    One simple approach to overcome this skewness is to log transform the data, using
    the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如从这些直方图中所见，数据高度右偏斜。这种情况经常发生，尤其是在数据具有货币或数量值时。数据的偏斜会导致不均衡的聚类，数据分割不理想。克服这种偏斜的一个简单方法是对数据进行对数变换，以下代码为证：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can generate the log-transformed data’s histograms using the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码生成对数变换数据的直方图：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following are the histograms that are generated:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由此生成的直方图：
- en: '![](img/B30999_08_07.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_07.png)'
- en: 'Figure 8.7: Log-transformed data distribution'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：对数变换后的数据分布
- en: As expected, the log-transformed data is more centered around the mean and closer
    to a bell curve. We are going to examine clustering both with and without log
    transformation and see how it affects the clustering results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，对数变换后的数据更集中在平均值周围，更接近钟形曲线。我们将检查带有和对数变换的聚类，并看看它如何影响聚类结果。
- en: Without log transformation
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无对数变换
- en: 'Training a K-means clustering algorithm in Python is straightforward. Take
    a look at the following code, where we import the `KMeans` module in the `scikit-learn`
    package to build a K-means clustering algorithm:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中训练K-means聚类算法很简单。看看以下代码，我们在`scikit-learn`包中导入`KMeans`模块来构建K-means聚类算法：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we are building customer segments based on the three columns,
    `NetSales`, `NetQuantity`, and `TotalRefundQuantity`. Then, we are building four
    clusters by using the parameter `n_clusters`. The `labels_` attribute of the trained
    `KMeans` model has the assigned labels (0 through 3) for each row or customer
    and the `cluster_centers_` attribute shows the centroids of each cluster.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们根据三个列，`NetSales`、`NetQuantity`和`TotalRefundQuantity`构建客户细分。然后，我们使用参数`n_clusters`构建四个聚类。训练好的`KMeans`模型的`labels_`属性为每一行或客户分配了标签（0到3），而`cluster_centers_`属性显示了每个聚类的中心。
- en: '**Randomness in K-means clustering**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**K-means聚类中的随机性**'
- en: As K-means clustering is an algorithm with iterative approaches to updating
    centroids from the original randomly selected centroids, there is a randomness
    in K-means clustering that results in slightly different results each time it
    is run. If you would like to get the same results each time, you would want to
    set the `random_state` variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于K-means聚类是一种迭代方法，用于从原始随机选择的中心更新中心，因此K-means聚类中存在随机性，导致每次运行时结果略有不同。如果您希望每次都得到相同的结果，您应该设置`random_state`变量。
- en: The examples in this chapter do not use the `random_state` variable, so your
    results may look slightly different from the charts you see here.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例没有使用`random_state`变量，所以您的结果可能看起来与您看到的图表略有不同。
- en: 'Now, let’s visualize the clusters so that we can visually inspect how the K-means
    clustering algorithm has segmented the customer base using the three factors we
    are interested in:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们可视化聚类，这样我们就可以直观地检查K-means聚类算法如何使用我们感兴趣的三个因素（`NetSales`、`NetQuantity`和`TotalRefundQuantity`）将客户群分割开来：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we first define a function, `plot_clusters`, to 2D plot each cluster,
    where it takes the DataFrame as an input with the two columns for x- and y-axes.
    Then, we create three plots: one to visualize the clusters based on `NetSales`
    and `NetQuantity`, another for `NetSales` and `TotalRefundQuantity`, and a third
    for `NetQuantity` and `TotalRefundQuantity`. The three resulting plots should
    look like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义一个函数，`plot_clusters`，用于绘制每个聚类的2D图，它接受DataFrame作为输入，其中包含用于x轴和y轴的两个列。然后，我们创建三个图表：一个用于根据`NetSales`和`NetQuantity`可视化聚类，另一个用于`NetSales`和`TotalRefundQuantity`，第三个用于`NetQuantity`和`TotalRefundQuantity`。这三个生成的图表应该看起来像以下这样：
- en: '![](img/B30999_08_08.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_08.png)'
- en: 'Figure 8.8: Clusters based on NetSales versus NetQuantity'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：基于NetSales与NetQuantity的聚类
- en: '![](img/B30999_08_09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_09.png)'
- en: 'Figure 8.9: Clusters based on NetSales versus TotalRefundQuantity'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：基于NetSales与TotalRefundQuantity的聚类
- en: '![](img/B30999_08_10.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_10.png)'
- en: 'Figure 8.10: Clusters based on NetQuantity versus TotalRefundQuantity'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：基于NetQuantity与TotalRefundQuantity的聚类
- en: 'In *Figures 8.8*, *8**.9*, and *8.10*, we can easily see how clusters are formed
    based on the pairs. For instance, cluster `0` seems to be the customers who have
    low net sales, low net quantity, and low refunds, and cluster `1` seems to be
    the customers who have low-mid net sales, low-mid net quantity, and low refunds.
    However, there are two things that stand out in this example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.8*、*8.9*和*8.10*中，我们可以很容易地看到聚类是如何基于成对形成的。例如，聚类`0`似乎代表的是那些净销售额、净数量和退款都较低的客户，而聚类`1`似乎代表的是那些净销售额、净数量和退款处于中低水平的客户。然而，在这个例子中有两点值得关注：
- en: Some clusters have a wide range of points. Cluster `0`, as an example, has a
    wide range of refund quantity that ranges from `0` to `80,000` if you look at
    *Figure 8.10*. This makes it difficult to describe what cluster `0` actually signifies
    and how it is different from other clusters.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些聚类具有广泛的点范围。以聚类`0`为例，如果查看*图8.10*，其退款数量范围从`0`到`80,000`，这使得描述聚类`0`实际上代表什么以及它与其他聚类有何不同变得困难。
- en: Another thing to note here is that most of the data points are in cluster `0`
    and very few are in other clusters. Cluster `3` seems to contain only two data
    points. These large imbalances in cluster sizes make generalizations from these
    clusters less reliable as insights based on a few data points are not so trustable.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里还有一个需要注意的事项，那就是大多数数据点都在聚类`0`中，而其他聚类中的数据点非常少。聚类`3`似乎只包含两个数据点。这些聚类大小的巨大不平衡使得从这些聚类中得出的概括不太可靠，因为基于少量数据点的见解并不可靠。
- en: 'You can take a look at the number of data points in each cluster using the
    following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码查看每个聚类中的数据点数量：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here are the details of each cluster:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个聚类的详细信息：
- en: '![](img/B30999_08_11.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_11.png)'
- en: 'Figure 8.11: The number of data points in each cluster'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：每个聚类中的数据点数量
- en: Data skewness often causes these problems as it makes the K-means clustering
    algorithm difficult to find or effectively cluster the data points. This is the
    reason why we need to normalize the data before applying clustering algorithms
    when there is a skewness in the data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数据偏斜经常导致这些问题，因为它使得K-means聚类算法难以找到或有效地聚类数据点。这就是为什么当数据存在偏斜时，我们需要在应用聚类算法之前对数据进行归一化的原因。
- en: With log transformation
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对数变换
- en: 'Let’s see how log transformation may help customer segmentation using K-means
    clustering. Take a look at the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看对数变换如何可能帮助使用K-means聚类进行客户细分。看一下以下代码：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we use the previously defined variable, `log_customer_df`, which is the
    log-transformed data, using the `np.log` function. We then fit a K-means clustering
    model with four clusters. We can see what the cluster sizes look like now:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用之前定义的变量`log_customer_df`，它是使用`np.log`函数进行对数变换的数据。然后我们拟合了一个包含四个聚类的K-means聚类模型。现在我们可以看到聚类的大小如下：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This gives us the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![](img/B30999_08_12.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_12.png)'
- en: 'Figure 8.12: The number of data points in each cluster after log transformation'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：对数变换后每个聚类中的数据点数量
- en: 'Compared to earlier in the chapter, when we fit the clustering model without
    the log transformation, the clusters are more balanced, with each cluster having
    a significant number of customers. This is going to give better insights into
    how customers are segmented based on the three factors of our interest: net sales,
    net quantity, and total refunds. Let’s visualize the clusters with the following
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章早期我们拟合聚类模型时没有进行对数变换相比，聚类现在更加均衡，每个聚类都有显著数量的客户。这将使我们能够更好地了解客户是如何基于我们感兴趣的三个因素（净销售额、净数量和总退款）进行细分的。让我们用以下代码可视化聚类：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code should create three charts similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该创建三个类似于以下图表：
- en: '![](img/B30999_08_13.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_13.png)'
- en: 'Figure 8.13: Clusters on NetSales versus NetQuantity after transformation'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：转换后的NetSales与NetQuantity的聚类
- en: '![](img/B30999_08_14.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_14.png)'
- en: 'Figure 8.14: Clusters on NetSales versus TotalRefundQuantityafter transformation'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：NetSales与转换后的TotalRefundQuantity的聚类
- en: '![](img/B30999_08_15.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_15.png)'
- en: 'Figure 8.15: Clusters on NetQuantity versus TotalRefundQuantity after transformation'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：转换后的NetQuantity与TotalRefundQuantity的聚类
- en: Let’s dive deeper into these cluster visualizations. There is no clear separation
    between clusters based on the net sales and net quantity if you look at *Figure
    8.13*. Cluster `3` seems more centered around the mean, while cluster `1` tends
    more toward higher net sales and higher net quantity, and the clusters `0` and
    `2` more toward lower net sales and lower net quantity. Despite these subtle differences,
    all clusters seem to cluster around the means of net sales and net quantity.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些集群的可视化。如果您查看 *图 8.13*，基于净销售额和净数量，集群之间没有明显的分离。集群 `3` 似乎更集中在平均值附近，而集群
    `1` 则更倾向于更高的净销售额和更高的净数量，集群 `0` 和 `2` 则更倾向于更低的净销售额和更低的净数量。尽管有这些细微的差异，所有集群似乎都聚集在净销售额和净数量的平均值周围。
- en: 'The distinctions between clusters are more clear in *Figures 8.14* and *8**.15*.
    Cluster `1` seems to be the customer segment with high total refunds, with the
    cutoff threshold around `4` in the log scale. You can convert this log-transformed
    value by reverting the transformation we have applied previously or by using the
    following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8.14* 和 *图 8.15* 中，集群之间的区别更为明显。集群 `1` 似乎是一个具有高总退款的客户群体，其截止阈值在对数尺度上约为 `4`。您可以通过撤销我们之前应用的转换或使用以下代码来转换这个对数转换的值：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `X` in this code is the value in the log scale and `COLUMN` in this code
    is the factor of interest. Let’s take a closer look at these clusters:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的 `X` 是对数尺度上的值，而 `COLUMN` 是感兴趣的因子。让我们更仔细地看看这些集群：
- en: '**Cluster 0**: This cluster seems to be the cluster with low total refunds
    and low net quantity. The thresholds for `TotalRefundQuantity` in the log scale
    are around `2` and `6.7` for `NetQuantity`. These numbers equate to `6.4` in total
    refunds and `811.4` in net quantity, using the preceding equation. This suggests
    that the customers in this cluster have less than `6.4` total refunds and have
    a net quantity less than `811.4`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群 0**：这个集群似乎是一个具有低总退款和低净数量的集群。`TotalRefundQuantity` 在对数尺度上的阈值约为 `2` 和 `6.7`
    对于 `NetQuantity`。这些数字相当于总退款中的 `6.4` 和净数量中的 `811.4`，使用前面的公式。这表明这个集群中的客户总退款少于 `6.4`，净数量少于
    `811.4`。'
- en: '**Cluster 1**: This cluster seems to be the group of customers who have got
    refunds the most frequently. The cutoff threshold for cluster `1` seems to be
    around `4` in the log scale of `TotalRefundQuantity` and using the code above,
    this equates to `54 (np.exp(4) + customer_df.min()["TotalRefundQuantity"] - 1)`.
    Thus, cluster `1` is the segment of customers with above 54 total refunds.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群 1**：这个集群似乎是一组退款频率最高的客户。集群 `1` 的截止阈值在对数尺度上 `TotalRefundQuantity` 中约为 `4`，使用上面的代码，这相当于
    `54 (np.exp(4) + customer_df.min()["TotalRefundQuantity"] - 1)`。因此，集群 `1` 是总退款超过
    `54` 的客户群体。'
- en: '**Cluster 2**: This cluster seems to be the customer segment with mid-total
    refunds with a threshold of around `2` in the log scale of `TotalRefundQuantity`,
    which equates to about `6` in actual total refunds. Thus, cluster `2` is the segment
    of customers with total refunds between `6` and `54`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群 2**：这个集群似乎是一个具有中等总退款且对数尺度上 `TotalRefundQuantity` 的阈值约为 `2` 的客户群体，这相当于实际总退款中的
    `6`。因此，集群 `2` 是总退款在 `6` 到 `54` 之间的客户群体。'
- en: '**Cluster 3**: The customers in cluster `3` seem to be the ones with low total
    refunds but high net quantity. This customer segment may be the sweet spot for
    the business as it suggests that they buy frequently from the business but do
    not get as many refunds as other customers in different segments. Given that their
    cutoff thresholds for total refunds in the log scale are around `2` and `6.7`
    for net quantity, this group of customers are the ones with less than 6 in total
    refunds and more than `811` in net quantity.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群 3**：集群 `3` 中的客户似乎具有低总退款但高净数量的特点。这个客户群体可能是业务的甜点，因为它表明他们经常从该业务购买，但退款数量并不像其他不同客户群体中的客户那么多。鉴于他们在对数尺度上总退款的下限约为
    `2` 和 `6.7` 对于净数量，这个客户群体在总退款中少于 `6`，而在净数量中多于 `811`。'
- en: As you can see in this exercise, the K-means clustering algorithm is helpful
    in segmenting the customers in an ML way without having to define the thresholds
    for each customer segment manually for yourselves. This programmatic approach
    helps you define customer segments more dynamically and in a more data-driven
    way. This way, you can better understand how different customer segments are grouped
    and what the separating factors are, which then can be used to strategize and
    prioritize for your future marketing efforts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这次练习中看到的，K-means 聚类算法有助于以机器学习的方式对客户进行分段，而无需你自己手动为每个客户分段定义阈值。这种程序化方法帮助你更动态、更数据驱动地定义客户分段。这样，你可以更好地理解不同的客户分段是如何组合的，以及分离因素是什么，这些因素随后可以用来为你的未来营销工作制定策略和优先级。
- en: Silhouette score
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮廓系数
- en: 'We have seen how to build customer segments with the K-means clustering algorithm.
    One of the key arguments to build the clusters was the number of clusters. However,
    you may wonder how to decide or how you would know the right number of clusters
    before you build such clusters. In a practical setting, you would want to build
    multiple clusters with different numbers of clusters and decide which one works
    the best. This is where the **silhouette score** comes in. Simply put, the silhouette
    score is a metric that quantifies how well a given data point fits into its cluster
    and how distinguishable it is from other clusters. The formula for the silhouette
    score looks as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 K-means 聚类算法构建客户分段。构建聚类的一个关键论点是聚类的数量。然而，你可能想知道在构建这样的聚类之前，你如何决定或如何知道正确的聚类数量。在实际环境中，你可能想要构建具有不同数量的聚类的多个聚类，并决定哪一个效果最好。这就是**轮廓系数**发挥作用的地方。简单来说，轮廓系数是一个度量，它量化了给定数据点与其聚类中其他点的匹配程度以及它与其他聚类的可区分性。轮廓系数的公式如下：
- en: '![](img/B30999_08_001.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_001.png)'
- en: Here, *a*[i] is the average distance of the *i*^(th) data point to all other
    points in the same cluster and *b*[i] is the minimum average distance of the *i*^(th)
    data point to all other points in the other clusters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*a*[i] 是第 *i* 个数据点到同一聚类中所有其他点的平均距离，而 *b*[i] 是第 *i* 个数据点到其他聚类中所有点的最小平均距离。
- en: In order to get the silhouette scores for a clustering algorithm, you need to
    get the average of all individual silhouette scores for each data point. Silhouette
    scores range between `-1` and `1`. The closer the score is to `1`, the better
    the data points are clustered together and the more distinct they are from adjacent
    clusters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得聚类算法的轮廓系数，你需要计算每个数据点的所有单个轮廓系数的平均值。轮廓系数的范围在 `-1` 和 `1` 之间。分数越接近 `1`，数据点聚在一起的程度就越好，它们与相邻聚类的区别就越明显。
- en: 'Silhouette scores can easily be computed in Python. The `scikit-learn` package
    in Python has a function, `silhouette_score`, which computes the average silhouette
    score for the clusters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 轮廓系数在 Python 中很容易计算。Python 的 `scikit-learn` 包中有一个名为 `silhouette_score` 的函数，它可以计算聚类的平均轮廓系数：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As a higher silhouette score value suggests better clusters, we can utilize
    this to decide what the ideal number of clusters is. Take a look at the following
    code, where we are experimenting with clusters of sizes from `4` to `8`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更高的轮廓系数值表明聚类更好，我们可以利用这一点来决定理想的聚类数量。看看以下代码，我们在 `4` 到 `8` 之间尝试不同的聚类大小：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For each cluster, we compute the silhouette scores and check what percentage
    of data points are in each cluster. Ideally, the best cluster is the one with
    the highest silhouette score and the highest number of data points evenly distributed
    among each cluster. This code should generate the output that follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个聚类，我们计算轮廓系数并检查每个聚类中有多少百分比的数据点。理想情况下，最佳的聚类是轮廓系数最高且每个聚类中数据点均匀分布的聚类。以下代码应该生成以下输出：
- en: '![](img/B30999_08_16.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_16.png)'
- en: 'Figure 8.16: The cluster size experimentation results'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16：聚类大小实验结果
- en: 'This chart shows a couple of important decision factors when you are figuring
    out what the best cluster size should be:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表显示了当你确定最佳聚类大小时应考虑的几个重要决策因素：
- en: '**Silhouette scores**: First, we can see the silhouette scores for each cluster
    size, where it is `0.4986` for the cluster of size `4`, `0.5391` for the cluster
    of size `5`, and so forth. Here, the silhouette score for the cluster of size
    `5` seems to be the highest with `0.5391`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮廓得分**：首先，我们可以看到每个簇大小的轮廓得分，其中大小为`4`的簇得分为`0.4986`，大小为`5`的簇得分为`0.5391`，依此类推。在这里，大小为`5`的簇的轮廓得分似乎是最高的，为`0.5391`。'
- en: '**Cluster sizes and compositions**: We should also evaluate if the data points
    in each cluster are somewhat evenly distributed, as large imbalances among the
    clusters may not be reliable enough to generate the best insights. The horizontal
    bar charts in *Figure 8.16* show the cluster compositions for each cluster size.
    The dotted vertical line shows where the bars should be if the composition is
    completely evenly distributed. As can be seen in these charts, clusters with high
    silhouette scores do not necessarily mean the best clusters. Cluster `5`, for
    example, has the highest overall silhouette score, but has a large imbalance where
    the *0*^(th) cluster has close to 70% of data points and the rest shares a small
    portion of the data. This is not an ideal cluster as too much of the data is in
    one cluster.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**簇大小和组成**：我们还应该评估每个簇中的数据点是否分布得相对均匀，因为簇之间的大规模不平衡可能不足以生成最佳的洞察。*图8.16*中的水平条形图显示了每个簇大小的簇组成。虚线垂直线显示了如果组成完全均匀分布，条形应该在哪里。从这些图表中可以看出，高轮廓得分的簇并不一定意味着最佳的簇。例如，簇`5`具有最高的整体轮廓得分，但存在很大的不平衡，其中第`0`个簇有接近70%的数据点，其余部分共享一小部分数据。这不是一个理想的簇，因为数据过于集中在单个簇中。'
- en: In this example, a cluster of size `4` may be the best choice as the data points
    are more evenly distributed across the clusters compared to others, even though
    the silhouette score is not the highest.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，大小为`4`的簇可能是最佳选择，因为与其它簇相比，数据点在簇之间分布得更均匀，尽管轮廓得分不是最高的。
- en: Customer segmentation with product interests
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于产品兴趣的客户细分
- en: We have discussed how we can build customer segments based on their purchase
    history in the previous section and how this can inform marketers on which segment
    to prioritize and strategize for the next marketing effort. Not only can we segment
    customers based on their purchase history, or more specifically with numerical
    values, but we can also find customer segments based on their product interests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中讨论了如何根据他们的购买历史构建客户细分，以及这如何帮助营销人员确定优先考虑和为下一次营销活动制定策略的细分。我们不仅可以根据购买历史或更具体地说，根据数值对客户进行细分，还可以根据他们的产品兴趣找到客户细分。
- en: The items that customers purchase have hidden insights into what types of items
    each customer is interested in and what they are likely to purchase more of. There
    are multiple approaches to segmenting customers based on the products that they
    have purchased in the past, such as simply grouping by the product categories
    that they have purchased from. However, in this exercise, we are going to expand
    on the topic of the embedding vectors that we touched on in *Chapter 5*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 客户购买的商品中隐藏着关于每个客户感兴趣的商品类型以及他们可能购买更多的商品的见解。根据客户过去购买的产品进行客户细分有多种方法，例如简单地根据他们购买的产品类别进行分组。然而，在这个练习中，我们将扩展到*第五章*中提到的嵌入向量这一主题。
- en: 'If you have not already, you may need to install Hugging Face’s `transformers`
    using `pip`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装，您可能需要使用`pip`安装Hugging Face的`transformers`：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As previously discussed in *Chapter 5*, modern LLMs like **BERT** and **GPT**
    introduced contextual embeddings, where the words and sentences are transformed
    into numerical values or vectors that represent the contextual meanings. We will
    be using the pre-trained LLM `all-MiniLM-L6-v2` from Hugging Face to encode past
    product purchases for each customer in our example dataset and build customer
    segments using these embedding vectors. Take a look at the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文在*第五章*中所述，现代LLM如**BERT**和**GPT**引入了上下文嵌入，将单词和句子转换成表示上下文意义的数值或向量。我们将使用Hugging
    Face的预训练LLM `all-MiniLM-L6-v2`对示例数据集中每个客户的过去产品购买进行编码，并使用这些嵌入向量构建客户细分。请看以下代码：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we first get all the product descriptions of products that the customers
    have bought and then create a comma-separated list for each of the customers,
    which gets stored in the variable `customer_item_df`. Then, we load the pre-trained
    LLM, `sentence-transformers/all-MiniLM-L6-v2`, and encode the list of product
    descriptions for each customer into numerical vectors by using the `encode` function
    of the pre-trained LLM. This will result in a vector of 384 values for each customer.
    We then save this array into `tmp.npy` for future usage.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先获取客户购买的所有产品描述，然后为每个客户创建一个以逗号分隔的列表，该列表存储在变量`customer_item_df`中。然后，我们加载预训练的LLM，`sentence-transformers/all-MiniLM-L6-v2`，并使用预训练LLM的`encode`函数将每个客户的商品描述列表编码成数值向量。这将导致每个客户有一个384值的向量。然后我们将这个数组保存到`tmp.npy`中，以供将来使用。
- en: 'In high-dimensional space, the distances between data points become less meaningful
    as the volume increases due to larger dimensions making data too sparse. As the
    K-means clustering algorithm uses distance metrics to cluster data points together,
    this becomes an issue. In order to overcome this, we need to apply some dimensionality
    reduction techniques. In this exercise, we will simply apply **principal component
    analysis** (**PCA**) to reduce the dimensions of the embedding vectors while retrieving
    most of the variance within the data:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在高维空间中，随着维度的增加，数据点之间的距离变得不那么有意义，因为更大的维度使得数据过于稀疏。由于K-means聚类算法使用距离度量来聚簇数据点，这成为一个问题。为了克服这个问题，我们需要应用一些降维技术。在这个练习中，我们将简单地应用**主成分分析**（**PCA**）来降低嵌入向量的维度，同时保留数据中的大部分方差：
- en: 'Take a look at the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请看以下代码：
- en: '[PRE23]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we import the `PCA` module in the `scikit-learn` package. We import the
    previously built embedding vectors from the temporary location, `tmp.npy`, and
    fit and transform the vector by using the `fit_transform` function. We have defined
    it to return 5 components, as you can see from the `n_components` parameter. The
    resulting vector, `transforemd_encoded`, should have a size of 5 vectors for each
    customer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入`scikit-learn`包中的`PCA`模块。我们从临时位置`tmp.npy`导入之前构建的嵌入向量，并使用`fit_transform`函数对向量进行拟合和转换。我们将其定义为返回5个成分，正如您可以从`n_components`参数中看到的那样。结果向量`transforemd_encoded`应该有5个向量，每个客户一个。
- en: '**Other dimensionality reduction approaches**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他降维方法**'
- en: There are numerous dimensionality reduction techniques other than PCA. In our
    exercise, we used PCA for its simplicity, but T-SNE and UMAP are two others that
    are frequently used when dealing with high-dimensional data. Be sure to check
    them out and see if they may be a better fit for this exercise!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了PCA之外，还有许多降维技术。在我们的练习中，我们使用PCA是因为它的简单性，但T-SNE和UMAP是处理高维数据时经常使用的另外两种技术。务必查看它们，看看它们是否可能更适合这个练习！
- en: '**T-SNE**: [https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**T-SNE**: [https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html](https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html)'
- en: '**UMAP**: [https://umap-learn.readthedocs.io/en/latest/](https://umap-learn.readthedocs.io/en/latest/)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**UMAP**: [https://umap-learn.readthedocs.io/en/latest/](https://umap-learn.readthedocs.io/en/latest/)'
- en: 'Now it’s finally the time to build customer segments or clusters based on these
    embedding vectors, which have contextual understandings of the products that each
    customer has bought. Take a look at the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候根据这些嵌入向量构建客户细分或聚类了，这些嵌入向量对每个客户购买的产品有上下文理解。请看以下代码：
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code should look familiar, as this is almost the exact same code as before
    when we built clusters using purchase history with the K-means clustering algorithm.
    The main difference here is instead of the sales metrics, we use the embedding
    vectors as the input to `KMeans` to build clusters. The output of this code should
    look something like the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来应该很熟悉，因为这与我们之前使用K-means聚类算法根据购买历史构建聚簇时几乎完全相同的代码。这里的主要区别是，我们不是使用销售指标，而是使用嵌入向量作为`KMeans`的输入来构建聚类。这段代码的输出应该看起来像以下这样：
- en: '![](img/B30999_08_17.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_17.png)'
- en: 'Figure 8.17: The silhouette scores for different cluster sizes'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：不同聚类大小的轮廓得分
- en: The actual values may differ as there is some randomness in fitting a K-means
    clustering algorithm, but the trend should be similar.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实际值可能会有所不同，因为拟合K-means聚类算法时存在一些随机性，但趋势应该是相似的。
- en: 'Based on this, we are going to build 7 clusters based on the embedding vectors,
    as in the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于此，我们打算基于嵌入向量构建7个集群，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this code, we build 7 clusters. Then, for each cluster, we get the top 5
    most common items that customers in each cluster have purchased by using the `collections`
    library in Python. We then store these top 5 most commonly bought items for each
    cluster in a DataFrame named `common_items_df`. This DataFrame should give us
    insights into what types of products interest each customer segment the most.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们构建了7个集群。然后，对于每个集群，我们使用Python中的`collections`库获取每个集群中客户购买的最常见的5个商品。然后，我们将每个集群中最常购买的5个商品存储在一个名为`common_items_df`的DataFrame中。这个DataFrame应该能让我们了解哪些类型的商品最吸引每个客户细分市场。
- en: 'Let’s take a closer look at this DataFrame:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个DataFrame：
- en: '![](img/B30999_08_18.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30999_08_18.png)'
- en: 'Figure 8.18: The top 5 common items for each cluster'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：每个集群前5个常见商品
- en: 'This gives us the following insights:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了以下见解：
- en: The customers in the first cluster or the cluster indexed at 0 seem to have
    the most interest in some decoration items, such as ornaments and wooden frames.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一集群或索引为0的集群的客户似乎对一些装饰品最感兴趣，例如饰品和木框。
- en: The customers in the second cluster or the cluster indexed at 1 seem to show
    interest in party-related items, such as baking sets, party bunting, and cards.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二集群或索引为1的集群的客户似乎对与派对相关的商品感兴趣，例如烘焙套装、派对彩旗和卡片。
- en: The customers in the third cluster or the cluster indexed at 2 seem to be into
    teas or tea ceremonies, as they bought teacups and saucers.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三集群或索引为2的集群的客户似乎对茶或茶道很感兴趣，因为他们购买了茶杯和茶托。
- en: The fourth cluster’s customers seem to like purchasing bags.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四集群的客户似乎喜欢购买包。
- en: The fifth cluster’s customers seem to like water bottles, and so forth.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五集群的客户似乎喜欢水壶等等。
- en: As you can see, these customer clusters show what they are mostly interested
    in and how different customers can be grouped together by their product interests.
    These are going to be powerful insights as you build your next marketing strategies
    and campaigns. You may not want to promote tea sets to those who are interested
    in purchasing water bottles and vice versa. This misaligned targeting will result
    in wasteful marketing campaigns with low success rates in engagements and conversions.
    You would want to take these findings about different customer segments based
    on their product interests and build more targeted marketing campaigns for each
    segment with the product categories they are most interested in.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些客户集群显示了他们最感兴趣的商品，以及如何根据他们的产品兴趣将不同的客户分组在一起。这些信息将在您构建下一轮营销策略和活动时非常有用。您可能不想向那些对购买水壶感兴趣的人推广茶具，反之亦然。这种不匹配的目标定位将导致浪费的营销活动，参与和转化的成功率低。您希望根据不同客户细分市场的产品兴趣，为每个细分市场构建更精准的营销活动，并针对他们最感兴趣的品类进行推广。
- en: This way, you are more likely to have successful marketing campaigns with more
    success in drawing customer engagements and conversions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，你更有可能进行成功的营销活动，在吸引客户参与和转化方面取得更多成功。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed different ways to segment the customer base. We
    first looked at how new versus repeat customers contribute to revenue, as well
    as how monthly progressions of new and repeat customer numbers can tell us which
    segment or group of customers to focus on during the next marketing campaigns.
    Then, we discussed how the K-means clustering algorithm can be used to programmatically
    build and identify different customer segments. Using the sales amount, order
    quantity, and refunds, we experimented with how these factors can be used to build
    different customer segments. In lieu of doing it, we touched on silhouette scores
    as a criterion for finding the best number of clusters and how log transformation
    can be beneficial when dealing with highly skewed datasets. Lastly, we used word
    and sentence embedding vectors to convert the product descriptions into numerical
    vectors with contextual understanding and further built customer segments based
    on their product interests.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了不同分割客户群的方法。我们首先探讨了新客户与回头客对收入的影响，以及新客户和回头客数量的月度进展如何告诉我们下一次营销活动应关注哪个细分市场或客户群体。然后，我们讨论了如何使用K-means聚类算法编程构建和识别不同的客户细分市场。通过销售金额、订单数量和退款，我们实验了如何使用这些因素构建不同的客户细分市场。在不进行实际操作的情况下，我们提到了轮廓分数作为寻找最佳聚类数量的标准，以及在对高度偏斜的数据集进行处理时，对数变换可能是有益的。最后，我们使用单词和句子嵌入向量将产品描述转换为具有上下文理解的数值向量，并基于他们的产品兴趣进一步构建客户细分市场。
- en: In the following chapters, we are going to explore LLMs even further. From creating
    compelling content using pre-trained zero-shot models to more advanced few-shot
    and RAG approaches, we will touch more on LLMs and generative AI in the next chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进一步探索LLMs。从使用预训练的零样本模型创建引人入胜的内容，到更高级的少样本和RAG方法，我们将在下一章更多地涉及LLMs和生成式AI。
- en: Join our book’s Discord space
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们书籍的Discord空间
- en: 'Join our Discord community to meet like-minded people and learn alongside more
    than 5000 members at:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区，与志同道合的人交流，并和超过5000名成员一起学习：
- en: '[https://packt.link/genai](https://packt.link/genai)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/genai](https://packt.link/genai)'
- en: '![](img/QR_Code12856128601808671.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code12856128601808671.png)'
