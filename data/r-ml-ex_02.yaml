- en: Vectors
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Indexing and naming vectors
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量的索引和命名
- en: 'One of the most important operations we can do on vectors involves subsetting
    and indexing vectors to access specific elements which are often useful when we
    want to run some code only on specific data points. The following examples show
    some ways in which we can index and subset vectors:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在向量上执行的最重要操作之一涉及子集和索引向量以访问特定元素，这在只想在特定数据点上运行代码时非常有用。以下示例展示了我们可以如何索引和子集向量：
- en: '[PRE2]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we look at how we can name vectors. This is basically a nifty feature in
    R where you can label each element in a vector to make it more readable or easy
    to interpret. There are two ways this can be done, which are shown in the following
    examples:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看如何命名向量。这基本上是R中的一个巧妙功能，您可以为向量中的每个元素添加标签，使其更易于阅读或解释。这可以通过两种方式完成，以下示例展示了这些方法：
- en: '[PRE3]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Output:**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Indexing and naming vectors](img/00003.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![索引和命名向量](img/00003.jpeg)'
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Output:**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Indexing and naming vectors](img/00003.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![索引和命名向量](img/00003.jpeg)'
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Output:**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Indexing and naming vectors](img/00004.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![索引和命名向量](img/00004.jpeg)'
- en: Thus, you can see, it becomes really useful to annotate and name vectors sometimes,
    and we can also subset and slice vectors using element names rather than values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到，有时注释和命名向量变得非常有用，我们也可以使用元素名称而不是值来子集和切片向量。
- en: Arrays and matrices
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组和矩阵
- en: Vectors are one dimensional data structures, which means that they just have
    one dimension and we can get the number of elements they have using the `length`
    property. Do remember that arrays may also have a similar meaning in other programming
    languages, but in R they have a slightly different meaning. Basically, arrays
    in R are data structures which hold the data having multiple dimensions. Matrices
    are just a special case of generic arrays having two dimensions, namely represented
    by properties `rows` and `columns`. Let us look at some examples in the following
    code snippets in the accompanying subsection.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一维数据结构，这意味着它们只有一个维度，我们可以使用`length`属性来获取它们的元素数量。请记住，在其它编程语言中，数组可能也有类似的意义，但在R中，它们的意义略有不同。基本上，R中的数组是包含多维数据的结构。矩阵是具有两个维度的通用数组的特例，由`rows`和`columns`属性表示。让我们在下面的代码片段中查看一些示例。
- en: Creating arrays and matrices
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数组和矩阵
- en: 'First we will create an array that has three dimensions. Now it is easy to
    represent two dimensions in your screen, but to go one dimension higher, there
    are special ways in which R transforms the data. The following example shows how
    R fills the data (column first) in each dimension and shows the final output for
    a 4x3x3 array:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个三维数组。现在在屏幕上表示两个维度很容易，但要增加一个维度，R有一些特殊的方法来转换数据。以下示例展示了R如何在每个维度中填充数据（列优先）以及一个4x3x3数组的最终输出：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Output:**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Creating arrays and matrices](img/00005.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![创建数组和矩阵](img/00005.jpeg)'
- en: Like I mentioned earlier, a matrix is just a special case of an array. We can
    create a matrix using the `matrix` function, shown in detail in the following
    example. Do note that we use the parameter `byrow` to fill the data row-wise in
    the matrix instead of R's default column-wise fill in any array or matrix. The
    `ncol` and `nrow` parameters stand for number of columns and rows respectively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我之前提到的，矩阵只是数组的特例。我们可以使用`matrix`函数创建矩阵，以下示例将详细介绍。请注意，我们使用`byrow`参数在矩阵中以行方式填充数据，而不是R中任何数组或矩阵的默认列方式填充。`ncol`和`nrow`参数分别代表列数和行数。
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Output:**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Creating arrays and matrices](img/00006.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建数组和矩阵](img/00006.jpeg)'
- en: Names and dimensions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称和维度
- en: 'Just like we named vectors and accessed element names, will perform similar
    operations in the following code snippets. You have already seen the use of the
    `dimnames` parameter in the preceding examples. Let us look at some more examples
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们命名向量和访问元素名称一样，在下面的代码片段中我们将执行类似的操作。您已经在前面的示例中看到了`dimnames`参数的使用。让我们看看以下更多的示例：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Output:**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Names and dimensions](img/00007.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![名称和维度](img/00007.jpeg)'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Output:**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Names and dimensions](img/00008.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![名称和维度](img/00008.jpeg)'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Output:**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Names and dimensions](img/00009.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![名称和维度](img/00009.jpeg)'
- en: 'To access details of dimensions related to arrays and matrices, there are special
    functions. The following examples show the same:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问与数组和矩阵相关的维度细节，有一些特殊函数。以下示例展示了相同的内容：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Matrix operations
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩阵运算
- en: A lot of machine learning and optimization algorithms deal with matrices as
    their input data. In the following section, we will look at some examples of the
    most common operations on matrices.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 许多机器学习和优化算法都处理矩阵作为它们的输入数据。在下一节中，我们将探讨矩阵上最常见的运算的一些例子。
- en: We start by initializing two matrices and then look at ways of combining the
    two matrices using functions such as `c` which returns a vector, `rbind` which
    combines the matrices by `rows,` and `cbind` which does the same by columns.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化两个矩阵，然后探讨使用诸如`c`函数（返回一个向量）、`rbind`函数（按行组合矩阵）和`cbind`函数（按列组合矩阵）等函数组合这两个矩阵的方法。
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Output:**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00010.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00010.jpeg)'
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Output:**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00011.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00011.jpeg)'
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Output:**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00012.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00012.jpeg)'
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Output:**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00013.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00013.jpeg)'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Output:**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00014.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00014.jpeg)'
- en: 'Now we look at some of the important arithmetic operations which can be performed
    on matrices. Most of them are quite self-explanatory from the following syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看在矩阵上可以执行的一些重要的算术运算。大多数运算从下面的语法中可以很容易地理解：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Output:**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00015.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00015.jpeg)'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Output:**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00016.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00016.jpeg)'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Output:**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00017.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00017.jpeg)'
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Output:**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00018.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00018.jpeg)'
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Output:**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00019.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00019.jpeg)'
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Output:**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00020.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00020.jpeg)'
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Output:**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Matrix operations](img/00021.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![矩阵运算](img/00021.jpeg)'
- en: The preceding arithmetic operations are just some of the most popular ones amongst
    the vast number of functions and operators which can be applied to matrices. This
    becomes useful, especially in areas such as linear optimization.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的算术运算只是众多可以应用于矩阵的函数和运算符中的一部分。这在诸如线性优化等领域非常有用。
- en: Lists
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are a special case of vectors where each element in the vector can be
    of a different type of data structure or even simple data types. It is similar
    to the lists in the Python programming language in some aspects, if you have used
    it before, where the lists indicate elements which can be of different types and
    each have a specific index in the list. In R, each element of a list can be as
    simple as a single element or as complex as a whole matrix, a function, or even
    a vector of strings.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是向量的特例，其中向量的每个元素可以是不同类型的数据结构，甚至可以是简单的数据类型。在某些方面，它与Python编程语言中的列表相似，如果您之前使用过它，那么列表表示可以具有不同类型的元素，并且每个元素在列表中都有一个特定的索引。在R中，列表的每个元素可以像单个元素一样简单，也可以像整个矩阵、函数或字符串向量一样复杂。
- en: Creating and indexing lists
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和索引列表
- en: We will get started with looking at some common methods to create and initialize
    lists in the following examples. Besides that, we will also look at how we can
    access some of these list elements for further computations. Do remember that
    each element in a list can be a simple primitive data type or even complex data
    structures or functions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将开始查看一些创建和初始化列表的常见方法。此外，我们还将探讨如何访问这些列表元素以进行进一步的计算。请记住，列表中的每个元素可以是一个简单的原始数据类型，甚至可以是复杂的数据结构或函数。
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Output:**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Creating and indexing lists](img/00022.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![创建和索引列表](img/00022.jpeg)'
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Output:**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Creating and indexing lists](img/00023.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![创建和索引列表](img/00023.jpeg)'
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see from the preceding examples how easy it is to access any element
    of the list and use it for further computations, such as the `cos` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的例子中看到，访问列表中的任何元素并用于进一步计算（如`cos`函数）是多么容易。
- en: Combining and converting lists
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并和转换列表
- en: 'Now we will take a look at how to combine several lists together into one single
    list in the following examples:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将看看如何将几个列表组合成一个单一的列表：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Output:**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Combining and converting lists](img/00024.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![合并和转换列表](img/00024.jpeg)'
- en: 'It is very easy to convert lists in to vectors and vice versa. The following
    examples show some common ways we can achieve this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表转换为向量以及相反的操作非常简单。以下例子展示了我们可以实现这一点的常见方法：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Output:**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Combining and converting lists](img/00025.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![合并和转换列表](img/00025.jpeg)'
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Data frames
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框
- en: Data frames are special data structures which are typically used for storing
    data tables or data in the form of spreadsheets, where each column indicates a
    specific attribute or field and the rows consist of specific values for those
    columns. This data structure is extremely useful in working with datasets which
    usually have a lot of fields and attributes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框是特殊的数据结构，通常用于存储数据表或以电子表格形式的数据，其中每一列表示一个特定的属性或字段，而每一行包含这些列的特定值。这种数据结构在处理通常具有许多字段和属性的集合时非常有用。
- en: Creating data frames
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据框
- en: 'We can create data frames easily using the `data.frame` function. We will look
    at some following examples to illustrate the same with some popular superheroes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `data.frame` 函数轻松地创建数据框。我们将通过一些流行的超级英雄的示例来展示这一点。
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Output:**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Creating data frames](img/00026.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据框](img/00026.jpeg)'
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Output:**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Creating data frames](img/00027.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据框](img/00027.jpeg)'
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Output:**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Creating data frames](img/00028.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据框](img/00028.jpeg)'
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `str` function talks in detail about the structure of the data frame where
    we see details about the data present in each column of the data frame. There
    are a lot of datasets readily available in R base which you can directly load
    and start using. One of them is shown next. The `mtcars` dataset has information
    about various automobiles, which was extracted from the *Motor Trend U.S. Magazine*
    of 1974.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 函数详细说明了数据框的结构，其中我们可以看到数据框中每个列中数据的详细信息。R 基础中有很多现成的数据集可以直接加载并开始使用。下面展示的是其中之一。`mtcars`
    数据集包含有关各种汽车的信息，这些信息是从 1974 年的《Motor Trend U.S. Magazine》中提取的。'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Output:**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Creating data frames](img/00029.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据框](img/00029.jpeg)'
- en: Operating on data frames
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作数据框
- en: There are a lot of operations we can do on data frames, such as merging, combining,
    slicing, and transposing data frames. We will look at some of the important data
    frame operations in the following examples.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在数据框上执行许多操作，例如合并、组合、切片和转置数据框。在接下来的示例中，我们将查看一些重要的数据框操作。
- en: It is really easy to index and subset specific data inside data frames using
    simplex indexes and functions such as `subset`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单索引和如 `subset` 函数之类的函数，在数据框中索引和子集特定数据非常容易。
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Output:**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Operating on data frames](img/00030.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据框](img/00030.jpeg)'
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Output:**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Operating on data frames](img/00031.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据框](img/00031.jpeg)'
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Output:**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Operating on data frames](img/00032.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据框](img/00032.jpeg)'
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Output:**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Operating on data frames](img/00033.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据框](img/00033.jpeg)'
- en: We will now look at some more complex operations, such as combining and merging
    data frames.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看一些更复杂的操作，例如合并和合并数据框。
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Output:**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Operating on data frames](img/00034.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据框](img/00034.jpeg)'
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Output:**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Operating on data frames](img/00035.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据框](img/00035.jpeg)'
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Output:**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Operating on data frames](img/00036.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据框](img/00036.jpeg)'
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Output:**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Operating on data frames](img/00037.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![操作数据框](img/00037.jpeg)'
- en: From the preceding operations it is evident that `rbind` and `cbind` work in
    the same way as we saw previously with arrays and matrices. However, merge lets
    you merge the data frames in the same way as you join various tables in relational
    databases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的操作中可以看出，`rbind` 和 `cbind` 的工作方式与我们之前看到的数组矩阵相同。然而，`merge` 允许你以与在关系数据库中连接各种表相同的方式合并数据框。
- en: Working with functions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数
- en: Next up, we will be looking at functions, which is a technique or methodology
    to easily structure and modularize your code, specifically lines of code which
    perform specific tasks, so that you can execute them whenever you need them without
    writing them again and again. In R, functions are basically treated as just another
    data type and you can assign functions, manipulate them as and when needed, and
    also pass them as arguments to other functions. We will be exploring all this
    in the following section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨函数，这是一种技术或方法，可以轻松地构建和模块化你的代码，特别是执行特定任务的代码行，这样你就可以在需要时执行它们，而无需再次编写。在
    R 中，函数基本上被视为另一种数据类型，你可以分配函数，根据需要操作它们，并将它们作为参数传递给其他函数。我们将在下一节中探讨所有这些内容。
- en: Built-in functions
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置函数
- en: 'R consists of several functions which are available in the R-base package and,
    as you install more packages, you get more functionality, which is made available
    in the form of functions. We will look at a few built-in functions in the following
    examples:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: R 包含了几个在 R-base 包中可用的函数，并且随着您安装更多的包，您将获得更多的功能，这些功能以函数的形式提供。在以下示例中，我们将查看一些内置函数：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can see from the preceding examples that functions such as `mean`, `median,`
    and `sqrt` are built-in and can be used anytime when you start R, without loading
    any other packages or defining the functions explicitly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的示例中看到，例如 `mean`、`median` 和 `sqrt` 这样的函数是内置的，并且可以在您启动 R 时随时使用，无需加载任何其他包或显式定义函数。
- en: User-defined functions
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的函数
- en: 'The real power lies in the ability to define your own functions based on different
    operations and computations you want to perform on the data and making R execute
    those functions just in the way you intend them to work. Some illustrations are
    shown as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的力量在于能够根据您想要在数据上执行的不同操作和计算来定义自己的函数，并让 R 以您期望的方式执行这些函数。以下是一些示例：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Passing functions as arguments
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数作为参数传递
- en: 'When you define any function, you can also pass other functions to it as arguments
    if you intend to use them inside your function to perform some complex computations.
    This reduces the complexity and redundancy of the code. The following example
    computes the Euclidean distance between two points using the `square` function
    defined earlier, which is passed as an argument:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义任何函数时，如果您打算在函数内部使用它们来执行一些复杂的计算，您也可以将其作为参数传递给函数。这减少了代码的复杂性和冗余。以下示例使用之前定义的
    `square` 函数计算两点之间的欧几里得距离，该函数作为参数传递：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Thus, you can see that with functions you can define a specific function once
    and execute it as many times as you need.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到，使用函数，您可以定义一个特定的函数一次，并且根据需要执行多次。
- en: Controlling code flow
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制代码流
- en: This section covers areas related to controlling the execution of your code.
    Using specific constructs such as `if-else` and `switch`, you can execute code
    conditionally. Constructs like `for`, `while`, and `repeat`, and `help` in executing
    the same code multiple times which is also known as looping. We will be exploring
    all these constructs in the following section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了与控制代码执行相关的领域。使用特定的构造，如 `if-else` 和 `switch`，您可以有条件地执行代码。例如，`for`、`while`
    和 `repeat` 以及 `help` 在执行相同代码多次时也称为循环。我们将在下一节中探讨所有这些构造。
- en: Working with if, if-else, and ifelse
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 if、if-else 和 ifelse
- en: 'There are several constructs which help us in executing code conditionally.
    This is especially useful when we don''t want to execute a bunch of statements
    one after the other sequentially but execute the code only when it meets or does
    not meet specific conditions. The following examples illustrate the same:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种构造可以帮助我们在代码执行时进行条件判断。这在我们不希望按顺序依次执行一系列语句，而只想在满足或未满足特定条件时执行代码时特别有用。以下示例说明了相同的内容：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Working with switch
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 switch
- en: 'The `switch` function is especially useful when you have to match an expression
    or argument to several conditions and execute only if there is a specific match.
    This becomes extremely messy when implemented with the `if-else` constructs but
    is much more elegant with the `switch` function, as we will see next:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 函数在您必须将表达式或参数与多个条件匹配并且只有在存在特定匹配时才执行时特别有用。当使用 `if-else` 构造时，这会变得非常混乱，但使用
    `switch` 函数则更加优雅，正如我们接下来将要看到的：'
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Loops
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Loops are an excellent way to execute code segments repeatedly when needed.
    Vectorization constructs are, however, more optimized than loops for working on
    larger data sets, but we will see that later in this chapter. For now, you should
    remember that there are three types of loops in R, namely, `for`, `while`, and
    `repeat`. We will look at all of them in the following examples:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是在需要时重复执行代码段的一种极好方式。然而，对于处理大型数据集，向量化构造比循环更优化，但我们将在本章的后面看到这一点。现在，您应该记住，R 中有三种类型的循环，即
    `for`、`while` 和 `repeat`。我们将在以下示例中查看所有这些：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Advanced constructs
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级构造
- en: 'We heard the term **vectorized** earlier when we talked about operating on
    vectors without using loops. While looping is a great way to iterate through vectors
    and perform computations, it is not very efficient when we deal with what is known
    as **Big Data**. In this case, R provides some advanced constructs which we will
    be looking at in this section. We will be covering the following functions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论在不使用循环的情况下对向量进行操作时，我们之前听到了 **向量化** 这个术语。虽然循环是遍历向量并执行计算的好方法，但当处理所谓的 **大数据**
    时，它并不非常高效。在这种情况下，R 提供了一些高级构造，我们将在本节中查看这些构造。我们将涵盖以下函数：
- en: '`lapply`: Loops over a list and evaluates a function on each element'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lapply`：遍历列表并对每个元素评估一个函数'
- en: '`sapply`: A simplified version of lapply'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sapply`：`lapply` 的简化版本'
- en: '`apply`: Evaluates a function on the boundaries or margins of an array'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`：在数组的边界或边缘上评估一个函数'
- en: '`tapply`: Evaluates a function over subsets of a vector'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tapply`：在向量的子集上评估一个函数'
- en: '`mapply`: A multivariate version of lapply'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapply`：`lapply` 的多元版本'
- en: lapply and sapply
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lapply 和 sapply
- en: 'Like we mentioned earlier, `lapply` takes a list and a function as input and
    evaluates that function over each element of the list. If the input list is not
    a list, it is converted into a list using the `as.list` function before the output
    is returned. It is much faster than a normal loop because the actual looping is
    done internally using C code. We look at its implementation and an example in
    the following code snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`lapply` 函数接受一个列表和一个函数作为输入，并在列表的每个元素上评估该函数。如果输入列表不是一个列表，则在返回输出之前，使用
    `as.list` 函数将其转换为列表。它比普通循环快得多，因为实际的循环是通过内部使用 C 语言代码来完成的。我们将在下面的代码片段中查看其实现和示例：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Output:**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![lapply and sapply](img/00038.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![lapply 和 sapply](img/00038.jpeg)'
- en: 'Coming to `sapply`, it is similar to `lapply` except that it tries to simplify
    the results wherever possible. For example, if the final result is such that every
    element is of length `1`, it returns a vector, if the length of every element
    in the result is the same but more than 1, a matrix is returned, and if it is
    not able to simplify the results, we get the same result as `lapply`. We illustrate
    the same with the following example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `sapply`，它与 `lapply` 类似，但它在可能的情况下尝试简化结果。例如，如果最终结果中每个元素长度都是 `1`，则返回一个向量；如果结果中每个元素的长度相同但超过
    `1`，则返回一个矩阵；如果它无法简化结果，则我们得到与 `lapply` 相同的结果。我们将在以下示例中展示同样的内容：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**Output:**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![lapply and sapply](img/00039.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![lapply 和 sapply](img/00039.jpeg)'
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '**Output:**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![lapply and sapply](img/00040.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![lapply 和 sapply](img/00040.jpeg)'
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Output:**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![lapply and sapply](img/00041.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![lapply 和 sapply](img/00041.jpeg)'
- en: apply
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: apply
- en: 'The `apply` function is used to evaluate a function over the margins or boundaries
    of an array; for instance, applying aggregate functions on the rows or columns
    of an array. The `rowSums`, `rowMeans`, `colSums,` and `colMeans` functions also
    use `apply` internally but are much more optimized and useful when operating on
    large arrays. We will see all the preceding constructs in the following example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 函数用于在数组的边缘或边界上评估一个函数；例如，在数组的行或列上应用聚合函数。`rowSums`、`rowMeans`、`colSums`
    和 `colMeans` 函数也内部使用 `apply`，但它们在操作大型数组时更加优化和有用。我们将在以下示例中看到所有这些先前的构造：'
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Output:**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![apply](img/00042.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![apply](img/00042.jpeg)'
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Output:**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![apply](img/00043.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![apply](img/00043.jpeg)'
- en: Thus you can see how easy it is to apply various statistical functions on matrices
    without using loops at all.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到如何在完全不使用循环的情况下轻松地应用各种统计函数。
- en: tapply
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tapply
- en: 'The function `tapply` is used to evaluate a function over the subsets of any
    vector. This is similar to applying the `GROUP BY` construct in SQL if you are
    familiar with using relational databases. We illustrate the same in the following
    examples:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `tapply` 用于在向量的子集上评估一个函数。如果您熟悉使用关系数据库，这类似于在 SQL 中应用 `GROUP BY` 构造。我们将在以下示例中展示同样的内容：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Output:**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![tapply](img/00044.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![tapply](img/00044.jpeg)'
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Output:**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![tapply](img/00045.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![tapply](img/00045.jpeg)'
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Output:**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![tapply](img/00046.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![tapply](img/00046.jpeg)'
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Output:**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![tapply](img/00047.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![tapply](img/00047.jpeg)'
- en: mapply
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mapply
- en: 'The `mapply` function is a multivariate version of `lapply` and is used to
    evaluate a function in parallel over sets of arguments. A simple example is if
    we have to build a list of vectors using the `rep` function, we have to write
    it multiple times. However, with `mapply` we can achieve the same in a more elegant
    way as illustrated next:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapply` 函数是 `lapply` 的多元版本，用于在参数集上并行评估函数。一个简单的例子是，如果我们必须使用 `rep` 函数构建一个向量列表，我们必须多次编写它。然而，使用
    `mapply` 我们可以以更优雅的方式实现相同的功能，如下所示：'
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Output:**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![mapply](img/00048.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![mapply](img/00048.jpeg)'
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Output:**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![mapply](img/00048.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![mapply](img/00048.jpeg)'
- en: Next steps with R
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 R 的下一步
- en: Before we dive into machine learning, it will be useful to pause for a moment,
    take a deep breath, and contemplate on what you have learnt so far. This quick
    yet detailed refresher of R will help you a lot in the upcoming chapters. However,
    there are two more things which we must go through quickly. They are how to get
    help in R and how to work with various packages in R.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入机器学习之前，暂停片刻，深呼吸，思考一下你迄今为止学到了什么，这将很有用。这个关于 R 的快速而详细的复习将有助于你在接下来的章节中。然而，还有两件事我们必须快速了解。它们是如何在
    R 中获取帮助以及如何在 R 中处理各种包。
- en: Getting help
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取帮助
- en: 'By now, you must have figured out that there are thousands of functions and
    constructs in R and it is impossible to remember what each of them actually does
    and you don''t have to either! R provides many intuitive ways to get help regarding
    any function, package, or data structure. To start with, you can run the `help.start()`
    function at the `R` command prompt, which will start a manual browser. Here you
    will get detailed information regarding R which includes manuals, references,
    and other material. The following command shows the contents of `help.start()`
    as shown in the screenshot following the command, which you can use to navigate
    further and get more help:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你必须已经意识到 R 中有成千上万的函数和结构，不可能记住每个函数实际上做什么，你也不必这么做！R 提供了许多直观的方式来获取有关任何函数、包或数据结构的帮助。首先，你可以在
    `R` 命令提示符中运行 `help.start()` 函数，这将启动一个手册浏览器。在这里，你可以获取有关 R 的详细信息，包括手册、参考和其他材料。以下命令显示了
    `help.start()` 的内容，如命令后面的截图所示，你可以使用它来进一步导航并获得更多帮助：
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If nothing happens, you should open `http://127.0.0.1:31850/doc/html/index.html`
    yourself.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生任何事情，你应该自己打开 `http://127.0.0.1:31850/doc/html/index.html`。
- en: '![Getting help](img/00049.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![获取帮助](img/00049.jpeg)'
- en: To get help on any particular function or construct in R, if you know the function's
    name, you can get help using the help function or the `?` operator in combination
    with the function name. For example, if you want help regarding the `apply` function,
    just type `help("apply")` or `?apply` to get detailed information regarding the
    `apply` function. This easy mechanism for getting help in R increases your productivity
    and makes working with R a pleasant experience. Often, you won't quite remember
    the exact name of the function you intend to use but you might have a vague idea
    of what its name might be. R has a help feature for this purpose too, where you
    can use the `help.search` function or the `??` operator, in combination with the
    function name. For example, you can use `??apply` to get more information on the
    apply function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 R 中任何特定函数或结构的帮助，如果你知道函数的名称，你可以使用帮助函数或与函数名称结合的 `?` 操作符来获取帮助。例如，如果你想获取有关 `apply`
    函数的帮助，只需键入 `help("apply")` 或 `?apply` 以获取有关 `apply` 函数的详细信息。这种在 R 中获取帮助的简单机制提高了你的生产力，并使使用
    R 变得愉快。通常，你可能不会完全记得你打算使用的函数的确切名称，但你可能对其名称有一个模糊的概念。R 也为此目的提供了一个帮助功能，你可以使用 `help.search`
    函数或与函数名称结合的 `??` 操作符。例如，你可以使用 `??apply` 来获取有关 `apply` 函数的更多信息。
- en: Handling packages
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理包
- en: There are thousands and thousands of packages containing a wide variety of capabilities
    available on **CRAN** (**Comprehensive R Archive Network**), which is a repository
    hosting all these packages. To download any package from CRAN, all you have to
    do is run the `install.packages` function passing the package name as a parameter,
    like `install.packages("caret")`. Once the package is downloaded and installed,
    you can load it into your current R session using the `library` function. To load
    the package `caret`, just type `library(caret)` and it should be readily available
    for use. The `require` function has similar functionality to load a specific package
    and is used specially inside functions in a similar way by typing `require(caret)`
    to load the `caret` package. The only difference between `require` and `library`
    is that, in case the specific package is not found, `library` will show an error
    but `require` will continue the execution of code without showing any error. However,
    if there is a dependency call to that package then your code will definitely throw
    an error.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在**CRAN（综合R存档网络**）上，有数千个包含各种功能的包可用，这是一个托管所有这些包的仓库。要从CRAN下载任何包，你只需要运行`install.packages`函数，将包名作为参数传递，例如`install.packages("caret")`。一旦包下载并安装，你可以使用`library`函数将其加载到当前的R会话中。要加载`caret`包，只需键入`library(caret)`，它应该可以立即用于使用。`require`函数具有类似的功能来加载特定的包，并且在类似的方式中特别用于函数内部，通过键入`require(caret)`来加载`caret`包。`require`和`library`之间的唯一区别是，如果找不到特定的包，`library`将显示错误，而`require`将不会显示任何错误继续执行代码。然而，如果代码中有对该包的依赖调用，则你的代码肯定会抛出错误。
- en: Machine learning basics
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习基础
- en: Now that you have refreshed your memory about R, we will be talking about the
    basics of what machine learning is, how it is used today, and what are the main
    areas inside machine learning. This section intends to provide an overview into
    machine learning which will help in paving the way to the next chapter where we
    will be exploring it in more depth.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经刷新了你对R的记忆，我们将讨论机器学习的基本概念，它是如何被使用的，以及机器学习内部的主要领域。本节旨在提供一个机器学习的概述，这将有助于为下一章的深入探讨铺平道路。
- en: Machine learning – what does it really mean?
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习——它究竟意味着什么？
- en: Machine learning does not have just one distinct textbook definition because
    it is a field which encompasses and borrows concepts and techniques from several
    other areas in computer science. It is also taught as an academic course in universities
    and has recently gained more prominence, with machine learning and data science
    being widely adopted online, in the form of educational videos, courses, and training.
    Machine learning is basically an intersection of elements from the fields of computer
    science, statistics, and mathematics, which uses concepts from artificial intelligence,
    pattern detection, optimization, and learning theory to develop algorithms and
    techniques which can learn from and make predictions on data without being explicitly
    programmed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习并没有一个明确的教科书定义，因为它是一个涵盖并借鉴了计算机科学中其他几个领域概念和技术的领域。它也被作为一门大学课程进行教授，并且最近获得了更多的关注，机器学习和数据科学以在线教育视频、课程和培训的形式被广泛采用。机器学习基本上是计算机科学、统计学和数学领域的元素交叉，它使用人工智能、模式检测、优化和学习理论的概念来开发算法和技术，这些算法和技术可以从数据中学习并做出预测，而无需进行明确的编程。
- en: The learning here refers to the ability to make computers or machines intelligent
    based on the data and algorithms which we provide to them so that they start detecting
    patterns and insights from the provided data. This learning ensures that machines
    can detect patterns on data fed to it without explicitly programming them every
    time. The initial data or observations are fed to the machine and the machine
    learning algorithm works on that data to generate some output which can be a prediction,
    a hypothesis, or even some numerical result. Based on this output, there can be
    feedback mechanisms to our machine learning algorithm to improve our results.
    This whole system forms a machine learning model which can be used directly on
    completely new data or observations to get results from it without needing to
    write any separate algorithm again to work on that data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的学习指的是根据我们提供给计算机或机器的数据和算法，使它们变得智能的能力，以便它们可以从提供的数据中开始检测模式和洞察力。这种学习确保机器可以在不每次都进行显式编程的情况下，从输入的数据中检测模式。最初的数据或观察结果被输入到机器中，机器学习算法处理这些数据以生成一些输出，这些输出可以是预测、假设，甚至是某些数值结果。基于这个输出，可以对我们机器学习算法进行反馈机制以改进我们的结果。整个系统形成一个机器学习模型，可以直接应用于全新的数据或观察结果，从中获取结果，而无需再次编写任何单独的算法来处理这些数据。
- en: Machine learning – how is it used in the world?
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习——它在世界上是如何被使用的？
- en: 'You might be wondering how on earth some algorithms or code can be used in
    the real world. It turns out they are used in a wide variety of use-cases in different
    verticals. Some examples are as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，究竟如何将某些算法或代码应用于现实世界。实际上，它们被广泛应用于不同领域的各种用例。以下是一些例子：
- en: '**Retail**: Machine learning is widely used in the retail and e-commerce vertical
    where each store wants to outperform its competitors.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零售**：机器学习在零售和电子商务领域被广泛使用，每个商店都希望超越其竞争对手。'
- en: '**Pricing analytics**: Machine learning algorithms are used to compare prices
    for items across various stores so that a store can sell the item at the most
    competitive price.'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价分析**：机器学习算法用于比较不同商店中商品的价格，以便商店以最具竞争力的价格销售商品。'
- en: '**Market basket analysis**: They are used for analysis of customer shopping
    trends and recommendation of products to buy, which we will be covering in [Chapter
    3](part0026_split_000.html#OPEK1-973e731d75c2419489ee73e3a0cf4be8 "Chapter 3. Predicting
    Customer Shopping Trends with Market Basket Analysis"), *Predicting Customer Shopping
    Trends with Market Basket Analysis*.'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场篮子分析**：用于分析客户购物趋势，并推荐购买的产品，我们将在[第3章](part0026_split_000.html#OPEK1-973e731d75c2419489ee73e3a0cf4be8
    "第3章。使用市场篮子分析预测客户购物趋势")，*使用市场篮子分析预测客户购物趋势*中详细讨论。'
- en: '**Recommendation engines**: They are used to analyze customer purchases, ratings,
    and satisfaction to recommend products to various users. We will be building some
    recommendation systems of our own in [Chapter 4](part0032_split_000.html#UGI01-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 4. Building a Product Recommendation System"), *Building a Product Recommendation
    System*.'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推荐引擎**：用于分析客户购买、评分和满意度，并向各种用户推荐产品。我们将在[第4章](part0032_split_000.html#UGI01-973e731d75c2419489ee73e3a0cf4be8
    "第4章。构建产品推荐系统")，*构建产品推荐系统*中构建一些我们自己的推荐系统。'
- en: '**Advertising**: The advertising industry heavily relies on machine learning
    to promote and show the right advertisements to consumers for maximum conversion.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广告**：广告行业高度依赖机器学习来推广并向消费者展示正确的广告，以实现最大化的转化率。'
- en: '**Web analytics**: Analyzes website traffic'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站分析**：分析网站流量'
- en: '**Churn analytics**: Predicts customer churn rate'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户流失分析**：预测客户流失率'
- en: '**Advertisement click-through prediction**: Used to predict how effective an
    advertisement would be to consumers such that they click on it to buy the relevant
    product'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广告点击率预测**：用于预测广告对消费者的影响效果，以便他们点击广告购买相关产品'
- en: '**Healthcare**: Machine learning algorithms are used widely in the healthcare
    vertical for more effective treatment of patients.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**医疗保健**：机器学习算法在医疗保健领域被广泛用于更有效地治疗患者。'
- en: '**Disease detection and prediction**: Used to detect and predict chances of
    a disease based on the patient''s medical history.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**疾病检测与预测**：用于根据患者的病历检测和预测疾病发生的可能性。'
- en: Studying complex structures such as the human brain and DNA to understand the
    human body's functionality better for more effective treatment.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究复杂结构，如人脑和DNA，以更好地理解人体功能，从而实现更有效的治疗。
- en: Detection and filtering of spam e-mails and messages.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和过滤垃圾邮件和消息。
- en: Predicting election results.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测选举结果。
- en: Fraud detection and prediction. We will be taking a stab at one of the most
    critical fraud detection problems in [Chapters 5](part0038_split_000.html#147LC1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 5. Credit Risk Detection and Prediction – Descriptive Analytics"), *Credit
    Risk Detection and Prediction – Descriptive Analytics* and [Chapter 6](part0046_split_000.html#1BRPS1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 6. Credit Risk Detection and Prediction – Predictive Analytics"), *Credit
    Risk Detection and Prediction – Predictive Analytics*.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欺诈检测和预测。我们将在[第5章](part0038_split_000.html#147LC1-973e731d75c2419489ee73e3a0cf4be8
    "第5章。信用风险检测和预测 – 描述性分析")和[第6章](part0046_split_000.html#1BRPS1-973e731d75c2419489ee73e3a0cf4be8
    "第6章。信用风险检测和预测 – 预测分析")中尝试解决最关键的欺诈检测问题之一，即*信用风险检测和预测 – 描述性分析*和*信用风险检测和预测 – 预测分析*。
- en: Text prediction in a messaging application.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在消息应用中的文本预测。
- en: Self-driving cars, planes, and other vehicles.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动驾驶汽车、飞机和其他车辆。
- en: Weather, traffic, and crime activity forecasting and prediction.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天气、交通和犯罪活动预测和预报。
- en: Sentiment and emotion analysis, which we will be covering in [Chapter 8](part0066_split_000.html#1UU542-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 8. Sentiment Analysis of Twitter Data"), *Sentiment Analysis of Twitter
    Data*.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情感和情绪分析，我们将在[第8章](part0066_split_000.html#1UU542-973e731d75c2419489ee73e3a0cf4be8
    "第8章。Twitter数据情感分析")中介绍，*Twitter数据情感分析*。
- en: The preceding examples just scratch the surface of what machine learning can
    really do and by now I am sure that you have got a good flavor of the various
    areas where machine learning is being used extensively.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子只是触及了机器学习真正能做什么的皮毛，到现在我相信你已经对机器学习被广泛应用的各个领域有了很好的了解。
- en: Types of machine learning algorithms
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习算法的类型
- en: As we talked about earlier, to make machines learn, you need machine learning
    algorithms. Machine learning algorithms are a special class of algorithms which
    work on data and gather insights from it. The idea is to build a model using a
    combination of data and algorithms which can then be used to work on new data
    and derive actionable insights.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所讨论的，要让机器学习，你需要机器学习算法。机器学习算法是一类特殊的算法，它们在数据上工作并从中获取洞察。其想法是结合数据和算法构建一个模型，然后可以使用这个模型来处理新数据并得出可操作的见解。
- en: Each machine learning algorithm depends on what type of data it can work on
    and what type of problem are we trying to solve. You might be tempted to learn
    a couple of algorithms and then try to apply them to every problem you face. Do
    remember that there is no universal machine learning algorithm which fits all
    problems. The main input to machine learning algorithms is data which consists
    of features, where each feature can be described as an attribute of the data set,
    such as your height, weight, and so on if we were dealing with data related to
    human beings. Machine learning algorithms can be divided into two main areas,
    namely supervised and unsupervised learning algorithms.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 每个机器学习算法都取决于它可以处理的数据类型和我们要解决的问题类型。你可能想学习几个算法，然后尝试将它们应用到你所面临的所有问题上。请记住，没有一种通用的机器学习算法可以适用于所有问题。机器学习算法的主要输入是数据，这些数据由特征组成，其中每个特征都可以描述为数据集的属性，例如如果我们处理的是与人类相关的数据，那么你的身高、体重等都可以是特征。机器学习算法可以分为两大类，即监督学习和无监督学习算法。
- en: Supervised machine learning algorithms
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监督式机器学习算法
- en: 'The supervised learning algorithms are a subset of the family of machine learning
    algorithms which are mainly used in predictive modeling. A predictive model is
    basically a model constructed from a machine learning algorithm and features or
    attributes from training data such that we can predict a value using the other
    values obtained from the input data. Supervised learning algorithms try to model
    relationships and dependencies between the target prediction output and the input
    features such that we can predict the output values for new data based on those
    relationships which it learned from the previous data sets. The main types of
    supervised learning algorithms include:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 监督学习算法是机器学习算法家族的一个子集，主要用于预测建模。预测模型基本上是由机器学习算法和训练数据中的特征或属性构建的模型，这样我们就可以使用从输入数据中获得的其它值来预测一个值。监督学习算法试图模拟目标预测输出和输入特征之间的关系和依赖性，以便我们可以根据从先前数据集中学习到的关系预测新数据的输出值。主要的监督学习算法类型包括：
- en: '**Classification algorithms**: These algorithms build predictive models from
    training data which have features and class labels. These predictive models in-turn
    use the features learnt from training data on new, previously unseen data to predict
    their class labels. The output classes are discrete. Types of classification algorithms
    include decision trees, random forests, support vector machines, and many more.
    We will be using several of these algorithms in [Chapter 2](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 2. Let''s Help Machines Learn"), *Let''s Help Machines Learn*, [Chapter
    6](part0046_split_000.html#1BRPS1-973e731d75c2419489ee73e3a0cf4be8 "Chapter 6. Credit
    Risk Detection and Prediction – Predictive Analytics"), *Credit Risk Detection
    and Prediction – Predictive Analytics*, and [Chapter 8](part0066_split_000.html#1UU542-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 8. Sentiment Analysis of Twitter Data"), *Sentiment Analysis of Twitter
    Data*.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分类算法**：这些算法从具有特征和类别标签的训练数据中构建预测模型。这些预测模型反过来使用从训练数据中学习到的特征对新数据（之前未见过的数据）进行预测，以预测其类别标签。输出类别是离散的。分类算法的类型包括决策树、随机森林、支持向量机等，还有很多。我们将在[第2章](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "第2章。让我们帮助机器学习")、*让我们帮助机器学习*、[第6章](part0046_split_000.html#1BRPS1-973e731d75c2419489ee73e3a0cf4be8
    "第6章。信用风险检测与预测 - 预测分析")、*信用风险检测与预测 - 预测分析*和[第8章](part0066_split_000.html#1UU542-973e731d75c2419489ee73e3a0cf4be8
    "第8章。推特数据情感分析")、*推特数据情感分析*中使用这些算法中的几个。'
- en: '**Regression algorithms**: These algorithms are used to predict output values
    based on some input features obtained from the data. To do this, the algorithm
    builds a model based on features and output values of the training data and this
    model is used to predict values for new data. The output values in this case are
    continuous and not discrete. Types of regression algorithms include linear regression,
    multivariate regression, regression trees, and lasso regression, among many others.
    We explore some of these in [Chapter 2](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 2. Let''s Help Machines Learn"), *Let''s Help Machines Learn*.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归算法**：这些算法用于根据从数据中获得的某些输入特征预测输出值。为此，算法基于训练数据的特征和输出值构建一个模型，并使用此模型来预测新数据的值。在这种情况下，输出值是连续的，而不是离散的。回归算法的类型包括线性回归、多元回归、回归树和lasso回归等，还有很多。我们在[第2章](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "第2章。让我们帮助机器学习")、*让我们帮助机器学习*中探讨了其中的一些。'
- en: Unsupervised machine learning algorithms
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无监督机器学习算法
- en: 'The unsupervised learning algorithms are the family of machine learning algorithms
    which are mainly used in pattern detection and descriptive modeling. A descriptive
    model is basically a model constructed from an unsupervised machine learning algorithm
    and features from input data similar to the supervised learning process. However,
    there are no output categories or labels here based on which the algorithm can
    try to model relationships. These algorithms try to use techniques on the input
    data to mine for rules, detect patterns, and summarize and group the data points
    which help in deriving meaningful insights and describe the data better to the
    users. There is no specific concept of training or testing data here since we
    do not have any specific relationship mapping and we are just trying to get useful
    insights and descriptions from the data we are trying to analyze. The main types
    of unsupervised learning algorithms include:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 无监督学习算法是主要用于模式检测和描述性建模的机器学习算法家族。描述性模型基本上是由无监督机器学习算法和与监督学习过程类似的输入数据特征构建的模型。然而，这里没有基于算法尝试建模关系的输出类别或标签。这些算法试图使用输入数据上的技术来挖掘规则、检测模式、总结和分组数据点，这些数据点有助于推导出有意义的见解并更好地向用户描述数据。由于我们没有特定的关系映射，我们只是试图从我们试图分析的数据中获得有用的见解和描述，因此这里没有特定的训练或测试数据概念。无监督学习算法的主要类型包括：
- en: '**Clustering algorithms**: The main objective of these algorithms is to cluster
    or group input data points into different classes or categories using just the
    features derived from the input data alone and no other external information.
    Unlike classification, the output labels are not known beforehand in clustering.
    There are different approaches to build clustering models, such as by using means,
    medoids, hierarchies, and many more. Some popular clustering algorithms include
    k-means, k-medoids, and hierarchical clustering. We will look at some clustering
    algorithms in [Chapter 2](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 2. Let''s Help Machines Learn"), *Let''s Help Machines Learn*, and [Chapter
    7](part0059_split_000.html#1O8H61-973e731d75c2419489ee73e3a0cf4be8 "Chapter 7. Social
    Media Analysis – Analyzing Twitter Data"), *Social Media Analysis – Analyzing
    Twitter Data*.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚类算法**：这些算法的主要目标是仅使用从输入数据中提取的特征，而不使用任何其他外部信息，将输入数据点聚类或分组到不同的类别或类别中。与分类不同，聚类中的输出标签事先是未知的。构建聚类模型有不同的方法，例如使用均值、类中心、层次结构等。一些流行的聚类算法包括k-means、k-medoids和层次聚类。我们将在[第2章](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "第2章。让我们帮助机器学习")、“让我们帮助机器学习”和[第7章](part0059_split_000.html#1O8H61-973e731d75c2419489ee73e3a0cf4be8
    "第7章。社交媒体分析 – 分析Twitter数据")、“社交媒体分析 – 分析Twitter数据”中探讨一些聚类算法。'
- en: '**Association rule learning algorithms**: These algorithms are used to mine
    and extract rules and patterns from data sets. These rules explain relationships
    between different variables and attributes, and also depict frequent item sets
    and patterns which occur in the data. These rules in turn help discover useful
    insights for any business or organization from their huge data repositories. Popular
    algorithms include Apriori and FP Growth. We will be using some of these in [Chapter
    2](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8 "Chapter 2. Let''s
    Help Machines Learn"), *Let''s Help Machines Learn*, and [Chapter 3](part0026_split_000.html#OPEK1-973e731d75c2419489ee73e3a0cf4be8
    "Chapter 3. Predicting Customer Shopping Trends with Market Basket Analysis"),
    *Predicting Customer Shopping Trends with Market Basket Analysis*.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联规则学习算法**：这些算法用于从数据集中挖掘和提取规则和模式。这些规则解释了不同变量和属性之间的关系，并描述了数据中出现的频繁项集和模式。这些规则反过来又帮助从任何企业或组织的庞大数据存储库中发现有用的见解。流行的算法包括Apriori和FP
    Growth。我们将在[第2章](part0022_split_000.html#KVCC1-973e731d75c2419489ee73e3a0cf4be8
    "第2章。让我们帮助机器学习")、“让我们帮助机器学习”和[第3章](part0026_split_000.html#OPEK1-973e731d75c2419489ee73e3a0cf4be8
    "第3章。使用市场篮子分析预测客户购物趋势")、“使用市场篮子分析预测客户购物趋势”中使用一些这些算法。'
- en: Popular machine learning packages in R
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: R中流行的机器学习包
- en: 'After getting a brief overview of machine learning basics and types of algorithms,
    you must be getting inquisitive as to how we apply some of these algorithms to
    solve real world problems using R. It turns out, there are a whole lot of packages
    in R which are dedicated to just solving machine learning problems. These packages
    consist of algorithms which are optimized and ready to be used to solve problems.
    We will list several popular machine learning packages in R, so that you are aware
    of what tools you might need later on and also feel more familiar with some of
    these packages when used in the later chapters. Based on usage and functionality,
    the following R packages are quite popular in solving machine learning problems:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要概述了机器学习基础和算法类型之后，你一定对如何使用R将这些算法应用于解决现实世界问题感到好奇。结果是，R中有许多专门用于解决机器学习问题的包。这些包包含经过优化的算法，可以直接用于解决问题。我们将列出几个R中流行的机器学习包，以便你了解你可能需要的工具，并在后续章节中使用这些包时更加熟悉。根据使用和功能，以下R包在解决机器学习问题方面相当受欢迎：
- en: '`caret`: This package (short for classification and regression training) consists
    of several machine learning algorithms for building predictive models'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`caret`: 这个包（简称分类和回归训练）包含用于构建预测模型的几个机器学习算法'
- en: '`randomForest`: This package deals with implementations of the random forest
    algorithm for classification and regression'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randomForest`: 这个包处理随机森林算法的分类和回归实现'
- en: '`rpart`: This package focuses on recursive partitioning and decision trees'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpart`: 这个包专注于递归分割和决策树'
- en: '`glmnet`: The main focus of this package is lasso and elastic-net regularized
    regression models'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glmnet`: 这个包的主要重点是lasso和弹性网络正则化回归模型'
- en: '`e1071`: This deals with fourier transforms, clustering, support vector machines,
    and many more supervised and unsupervised algorithms'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e1071`: 它涉及傅里叶变换、聚类、支持向量机以及许多其他监督和非监督算法'
- en: '`party`: This deals with recursive partitioning'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`party`: 它涉及递归分割'
- en: '`arules`: This package is used for association rule learning algorithms'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arules`: 这个包用于关联规则学习算法'
- en: '`recommenderlab`: This is a library to build recommendation engines'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommenderlab`: 这是一个用于构建推荐引擎的库'
- en: '`nnet`: This package enables predictive modeling using neural networks'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nnet`: 这个包使使用神经网络进行预测建模成为可能'
- en: '`h2o`: It is one of the most popular packages being used in data science these
    days and offers fast and scalable algorithms including gradient boosting and deep
    learning'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h2o`: 这是目前数据科学中最受欢迎的包之一，提供了包括梯度提升和深度学习在内的快速和可扩展的算法'
- en: Besides the preceding libraries, there are a ton of other packages out there
    related to machine learning in R. What matters is choosing the right algorithm
    and model based on the data and problem in hand.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述库之外，还有许多其他与R中的机器学习相关的包。重要的是根据手头的数据和问题选择正确的算法和模型。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked briefly about the journey we will take into the world
    of machine learning and R. We discussed the basics of R and built a strong foundation
    of the core constructs and data structures used in R. Then we dived into the world
    of machine learning by looking at some concepts and algorithms, and how it is
    used in the world to solve problems. Finally, we ended with a quick glance at
    some of the most popular machine learning packages in R to get us all familiarized
    with some handy tools for our machine learning toolbox!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要地讨论了我们将要进入的机器学习和R的世界之旅。我们讨论了R的基础知识，并建立了R中使用的核心构造和数据结构的基础。然后，我们通过查看一些概念和算法以及它们在解决现实世界问题中的应用，深入了解了机器学习的世界。最后，我们快速浏览了一些R中最受欢迎的机器学习包，以便我们熟悉一些机器学习工具箱中的实用工具！
- en: In the next chapter, we will be looking in depth about machine learning concepts
    and algorithms which will help us make the machines learn something!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨机器学习概念和算法，这将帮助我们让机器学习到一些东西！
