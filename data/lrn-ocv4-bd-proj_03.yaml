- en: Learning Graphical User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习图形用户界面
- en: In [Chapter 2](37cf2702-b8c6-41ff-a935-fd4030f8ce64.xhtml), *An Introduction
    to the Basics of OpenCV*, we learned the basic classes and structures of OpenCV
    and the most important class, called `Mat`. We learned how to read and save images
    and videos and the internal structure in the memory of images. We are now ready
    to work with OpenCV, but, in most cases, we need to show our image results and
    retrieve user interaction with our images using a number of user interfaces. OpenCV
    provides us with a few basic user interfaces to facilitate the creation of our
    applications and prototypes. To better understand how the user interface works,
    we are going to create a small application called **PhotoTool** at the end of
    this chapter. In this application, we will learn how to use filters and color
    conversions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](37cf2702-b8c6-41ff-a935-fd4030f8ce64.xhtml)，《OpenCV基础知识简介》中，我们学习了OpenCV的基本类和结构以及最重要的类，称为`Mat`。我们学习了如何读取和保存图像和视频以及图像在内存中的内部结构。我们现在准备好使用OpenCV，但在大多数情况下，我们需要通过多个用户界面来展示我们的图像结果和获取用户与图像的交互。OpenCV为我们提供了一些基本的用户界面，以方便我们创建应用程序和原型。为了更好地理解用户界面的工作原理，我们将在本章末尾创建一个小应用程序，称为**PhotoTool**。在这个应用程序中，我们将学习如何使用过滤器进行颜色转换。
- en: 'This chapter introduces the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下主题：
- en: The OpenCV basic user interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV 基本用户界面
- en: The OpenCV Qt interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV Qt界面
- en: Sliders and buttons
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块和按钮
- en: An advanced user interface – OpenGL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级用户界面 – OpenGL
- en: Color conversion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色转换
- en: Basic filters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本过滤器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires familiarity with the basic C++ programming language.
    All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_03](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_03). The
    code can be executed on any operating system, although it has only been tested
    on Ubuntu.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求熟悉基本的C++编程语言。本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_03](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_03)。代码可以在任何操作系统上执行，尽管它只在Ubuntu上进行了测试。
- en: 'Check out the following video to see the code in action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：
- en: '[http://bit.ly/2KH2QXD](http://bit.ly/2KH2QXD)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2KH2QXD](http://bit.ly/2KH2QXD)'
- en: Introducing the OpenCV user interface
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OpenCV用户界面
- en: OpenCV has its own cross-OS user interface that allows developers to create
    their own applications without the need to learn complex user interface libraries.
    The OpenCV user interface is basic, but it gives computer vision developers the
    basic functions to create and manage their software developments. All of them
    are native and optimized for real-time use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 拥有自己跨操作系统的用户界面，允许开发者创建自己的应用程序，无需学习复杂的用户界面库。OpenCV 的用户界面是基本的，但它为计算机视觉开发者提供了创建和管理软件开发的必要基本功能。所有这些功能都是本地的，并且针对实时使用进行了优化。
- en: 'OpenCV provides two user interface options:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了两种用户界面选项：
- en: A basic interface based on native user interfaces, cocoa or carbon for Mac OS
    X, and GTK for Linux or Windows user interfaces, selected by default when compiling
    OpenCV.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于本地用户界面、Mac OS X的cocoa或carbon以及Linux或Windows用户界面的GTK的基本界面，默认情况下在编译OpenCV时选择。
- en: A slightly more advanced interface based on Qt library that is a cross-platform
    interface. You have to enable the Qt option manually in CMake before compiling
    OpenCV.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Qt库的稍微高级一些的界面，这是一个跨平台界面。在编译OpenCV之前，您必须手动在CMake中启用Qt选项。
- en: 'In the following screenshot, you can see the basic user interface window on
    the left, and the Qt user interface on the right:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以在左侧看到基本用户界面窗口，在右侧看到Qt用户界面：
- en: '![](img/70ba76a2-6e26-440a-9a0c-9db64f284983.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70ba76a2-6e26-440a-9a0c-9db64f284983.png)'
- en: Basic graphical user interface with OpenCV
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV的基本图形用户界面
- en: We are going to create a basic user interface with OpenCV. The OpenCV user interface
    allows us to create windows, add images to it, and move, resize, and destroy it.
    The user interface is in OpenCV's `highui` module. In the following code, we are
    going to learn how to create and show two images by pressing a key to display
    multiple windows with the image moving in the window on our desktop.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用OpenCV创建一个基本的用户界面。OpenCV用户界面允许我们创建窗口，向其中添加图像，并移动、调整大小和销毁它。用户界面位于OpenCV的`highui`模块中。在下面的代码中，我们将学习如何通过按下一个键来显示多个窗口，并在我们的桌面上移动窗口中的图像。
- en: 'Don''t worry about reading the full code; we are going to explain it in small
    chunks:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心阅读完整的代码；我们将分块解释它：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s understand the code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下代码：
- en: 'The first task we have to do in order to facilitate a graphical user interface
    is to import OpenCV''s `highui` module:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了便于图形用户界面，我们必须做的第一件事是导入OpenCV的`highui`模块：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we are prepared to create our new windows, we have to load some images:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备创建新的窗口，我们必须加载一些图像：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create the windows, we use the `namedWindow` function. This function has
    two parameters; the first is a constant string with the window''s name, and the
    second is the flags that we require. This second parameter is optional:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建窗口，我们使用`namedWindow`函数。此函数有两个参数；第一个是一个常量字符串，包含窗口的名称，第二个是我们需要的标志。第二个参数是可选的：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our case, we create two windows: the first is called `Lena`, and the second
    is called `Photo`.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们创建了两个窗口：第一个称为`Lena`，第二个称为`Photo`。
- en: 'There are three flags by default for Qt and native:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Qt和原生默认有三个标志：
- en: '`WINDOW_NORMAL`: This flag allows the user to resize the window'
  id: totrans-33
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_NORMAL`: 此标志允许用户调整窗口大小'
- en: '`WINDOW_AUTOSIZE`: If this flag is set, the window size is automatically adjusted
    to fit the display image and it is not possible to resize the window'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_AUTOSIZE`: 如果设置此标志，则窗口大小将自动调整以适应显示图像，并且无法调整窗口大小'
- en: '`WINDOW_OPENGL`: This flag enables the OpenGL support'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_OPENGL`: 此标志启用OpenGL支持'
- en: 'Qt has a number of additional flags:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Qt有许多额外的标志：
- en: '`WINDOW_FREERATIO` or `WINDOW_KEEPRATIO`: If `WINDOW_FREERATIO` is set, the
    image is adjusted with no respect for its ratio. If `WINDOW_FREERATIO` is set,
    the image is adjusted with respect to its ratio.'
  id: totrans-37
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_FREERATIO` 或 `WINDOW_KEEPRATIO`: 如果设置`WINDOW_FREERATIO`，则图像调整时不考虑其比例。如果设置`WINDOW_FREERATIO`，则图像调整时考虑其比例。'
- en: '`WINDOW_GUI_NORMAL` or `WINDOW_GUI_EXPANDED`: The first flag facilitates a
    basic interface without the status bar and the toolbar. The second flag facilitates
    the most advanced graphical user interface, with the status bar and the toolbar.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOW_GUI_NORMAL` 或 `WINDOW_GUI_EXPANDED`: 第一个标志提供了一个没有状态栏和工具栏的基本界面。第二个标志提供了一个带有状态栏和工具栏的最先进图形用户界面。'
- en: If we compile OpenCV with Qt, all the windows that we create are, by default,
    in the expanded interface, but we can use native interfaces and more basic ones
    adding the `CV_GUI_NORMAL` flag. By default, the flags are `WINDOW_AUTOSIZE`, `WINDOW_KEEPRATIO`,
    and `WINDOW_GUI_EXPANDED`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Qt编译OpenCV，我们创建的所有窗口默认情况下都在扩展界面中，但我们可以使用原生界面和更基本的界面，通过添加`CV_GUI_NORMAL`标志。默认情况下，标志是`WINDOW_AUTOSIZE`、`WINDOW_KEEPRATIO`和`WINDOW_GUI_EXPANDED`。
- en: 'When we create multiple windows, they are superimposed, but we can move the
    windows to any area of our desktop using the `moveWindow` function, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建多个窗口时，它们是叠加的，但我们可以使用`moveWindow`函数将窗口移动到桌面上的任何区域，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In our code, we move the `Lena` window `10` pixels to the left, and `10` pixels
    up, and the `Photo` window `520` pixels to the left, and `10` pixels up:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将`Lena`窗口向左移动`10`像素，向上移动`10`像素，并将`Photo`窗口向左移动`520`像素，向上移动`10`像素：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After showing the images that we loaded previously using the `imshow` function,
    we resize the `Lena` window to `512` pixels, calling the `resizeWindow` function.
    This function has three parameters: the `window name`, `width`, and `height`.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`imshow`函数显示我们之前加载的图像之后，我们将`Lena`窗口的大小调整为`512`像素，调用`resizeWindow`函数。此函数有三个参数：`窗口名称`、`宽度`和`高度`。
- en: The specific window size is for the image area. Toolbars are not counted. Only
    windows without the `WINDOW_AUTOSIZE` flag enabled can be resized.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的窗口大小是针对图像区域的。工具栏不计入。只有没有启用`WINDOW_AUTOSIZE`标志的窗口才能调整大小。
- en: 'After waiting for a key press with the `waitKey` function, we are going to
    remove or delete our windows using the `destroyWindow` function, where the name
    of the window is the only parameter required:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`waitKey`函数等待按键后，我们将使用`destroyWindow`函数删除或删除我们的窗口，其中窗口名称是唯一需要的参数：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OpenCV has a function to remove all windows that we create in only one call.
    The function is called `destroyAllWindows`. To demonstrate how this works, we
    create 10 windows in our sample and await a key press. When the user presses any
    key, it destroys all the windows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenCV有一个函数可以在一个调用中删除我们创建的所有窗口。该函数名为`destroyAllWindows`。为了演示其工作原理，我们在我们的示例中创建了10个窗口并等待按键。当用户按下任何键时，它将销毁所有窗口：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In any event, OpenCV handles the destruction of all windows automatically when
    the application is terminated, and it is not necessary to call this function at
    the end of our application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何事件中，当应用程序终止时，OpenCV会自动处理所有窗口的销毁，因此我们不需要在应用程序结束时调用此函数。
- en: 'The result of all this code can be seen in the following images across two
    steps. First, it shows two windows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码的结果可以在以下两个步骤中看到的图像中看到。首先，它显示了两个窗口：
- en: '![](img/7b6c21b3-4b79-4f6d-93e1-784f372b2f4f.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b6c21b3-4b79-4f6d-93e1-784f372b2f4f.png)'
- en: 'After pressing any key, the application continues and draws several windows
    changing their positions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下任何键后，应用程序继续并绘制几个窗口，改变它们的位置：
- en: '![](img/d52ca1f9-d77c-4b18-9146-1a24d4d79bc0.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d52ca1f9-d77c-4b18-9146-1a24d4d79bc0.png)'
- en: With a few lines of code, we are able to create and manipulate windows and show
    images. We are now ready to facilitate user interaction with images and add user
    interface controls.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几行代码，我们能够创建和操作窗口以及显示图像。我们现在准备好促进用户与图像的交互并添加用户界面控件。
- en: Adding slider and mouse events to our interfaces
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将滑块和鼠标事件添加到我们的界面中
- en: 'Mouse events and slider control are very useful in computer vision and OpenCV.
    Using these control users, we can interact directly with the interface and change
    the properties of the input images or variables. In this section, we are going
    to introduce the mouse events and slider controls for basic interactions. To facilitate
    proper understanding, we have created the following code, by means of which we
    are going to paint green circles in an image, using mouse events, and blur the
    image with the slider:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件和滑块控制对计算机视觉和OpenCV非常有用。使用这些控件，用户可以直接与界面交互并更改输入图像或变量的属性。在本节中，我们将介绍用于基本交互的鼠标事件和滑块控制。为了便于理解，我们创建了以下代码，通过该代码我们将使用鼠标事件在图像上绘制绿色圆圈，并使用滑块模糊图像：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's understand the code!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解这段代码！
- en: 'First, we create a variable to save the slider position. We need to save the
    slider position for access from other functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个变量来保存滑块的位置。我们需要保存滑块的位置以便其他函数访问：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we define our callbacks for our slider and mouse event, required for the
    OpenCV functions `setMouseCallback` and `createTrackbar`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义我们的滑块和鼠标事件回调，这是`setMouseCallback`和`createTrackbar`OpenCV函数所需的：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the main function, we load an image and create a new window called `Lena`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们加载一个图像并创建一个名为`Lena`的新窗口：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now is the time to create the slider. OpenCV has the `createTrackbar` function to
    generate a slider with the following parameters in order:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建滑块的时候了。OpenCV有一个名为`createTrackbar`的函数，可以生成具有以下参数的滑块：
- en: Trackbar name.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滑块名称。
- en: Window name.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 窗口名称。
- en: Integer pointer to use as a value; this parameter is optional. If it is set,
    the slider attains this position when created.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整数指针用作值；此参数是可选的。如果设置了，则滑块在创建时达到此位置。
- en: Maximum position on slider.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滑块上的最大位置。
- en: Callback function when the position of the slider changes.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滑块位置改变时的回调函数。
- en: User data to send to callback. It can be used to send data to callbacks without
    using global variables.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送到回调的用户数据。它可以用来在不使用全局变量的情况下将数据发送到回调。
- en: 'To this code, we add `trackbar` for the `Lena` window and call the `Lena` trackbar too
    in order to blur the image. The value of the trackbar is stored in the `blurAmount`
    integer that we pass as a pointer and set the maximum value of the bar to `30`.
    We set up `onChange` as a callback function and send the lena mat image as user
    data:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们为`Lena`窗口添加`trackbar`，并调用`Lena`的`trackbar`以模糊图像。滑块的值存储在作为指针传递的`blurAmount`整数中，并将滑块的最大值设置为`30`。我们将`onChange`设置为回调函数，并发送`lena
    mat`图像作为用户数据：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After creating the slider, we add the mouse events to paint circles when a
    user clicks the left button on the mouse. OpenCV has the `setMouseCallback` function.
    This function has three parameters:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建滑块后，我们添加鼠标事件，当用户在鼠标上点击左键时绘制圆圈。OpenCV有`setMouseCallback`函数。此函数有三个参数：
- en: A window name where we get mouse events.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取鼠标事件的窗口名称。
- en: A callback function to call when there is any mouse interaction.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有任何鼠标交互时调用的回调函数。
- en: '**User data**: this is any data that will be sent to the callback function
    when it''s fired. In our example, we''ll send the entire `Lena` image.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户数据**：这是在触发回调函数时将被发送的任何数据。在我们的例子中，我们将发送整个`Lena`图像。'
- en: 'Using the following code, we can add a mouse callback to the `Lena` window and
    set up `onMouse` as a callback function, passing the lena mat image as user data:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，我们可以为`Lena`窗口添加鼠标回调，并将`onMouse`设置为回调函数，传递`lena mat`图像作为用户数据：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To finalize the main function only, we need to initialize the image with the
    same parameter as the slider. To carry out the initialization, we only need to
    call the `onChange` callback function and wait for events before closing the windows
    with `destroyWindow`*,* as can be seen in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅最终化主函数，我们需要使用与滑块相同的参数初始化图像。为了执行初始化，我们只需要调用`onChange`回调函数，并在使用`destroyWindow`关闭窗口之前等待事件，如下所示：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The slider callback applies a basic blur filter to the image using the slider
    value as a blur quantity:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块回调使用滑块值作为模糊量对图像应用基本模糊过滤器：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function checks whether the slider value is `0` using the variable `pos`.
    In this case, we do not apply the filter because it generates a bad execution.
    We cannot apply a `0` pixel blur either. After checking the slider value, we create
    an empty matrix called `imgBlur` to store the blur result. To retrieve the image
    sent through user data in the callback function, we have to cast `void* userData` to
    the correct image type pointer `Mat*`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用变量`pos`检查滑块值是否为`0`。在这种情况下，我们不应用过滤器，因为它会产生不良的执行效果。我们也不能应用`0`像素的模糊。在检查滑块值后，我们创建一个名为`imgBlur`的空矩阵来存储模糊结果。为了在回调函数中检索通过用户数据发送的图像，我们必须将`void*
    userData`转换为正确的图像类型指针`Mat*`。
- en: Now we have the correct variables to apply the blur filter. The blur function
    applies a basic median filter to an input image, `*img` in our case; to an output
    image, the last required parameter is the size of the blur kernel (a kernel is
    a small matrix used to calculate the means of convolution between the kernel and
    the image) that we want to apply. In our case, we are using a squared kernel of `pos` size.
    Finally, we only need to update the image interface using the `imshow` function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了正确的变量来应用模糊过滤器。模糊函数将基本中值滤波器应用于输入图像，在我们的例子中是`*img`；输出图像，最后一个必需的参数是我们想要应用的模糊核的大小（核是一个用于计算核与图像之间卷积平均的小矩阵）。在我们的例子中，我们使用了一个大小为`pos`的平方核。最后，我们只需要使用`imshow`函数更新图像界面。
- en: 'The mouse events callback has five input parameters: the first parameter defines
    the event type; the second and third define the mouse position; the fourth parameter
    defines the wheel movement; and the fifth parameter defines the user input data.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件回调有五个输入参数：第一个参数定义事件类型；第二个和第三个定义鼠标位置；第四个参数定义鼠标滚轮移动；第五个参数定义用户输入数据。
- en: 'The mouse event types are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件类型如下：
- en: '| Event type | Description |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 描述 |'
- en: '| `EVENT_MOUSEMOVE` | When the user moves the mouse. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MOUSEMOVE` | 当用户移动鼠标时。 |'
- en: '| `EVENT_LBUTTONDOWN` | When the user clicks the left mouse button. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_LBUTTONDOWN` | 当用户点击鼠标左键时。 |'
- en: '| `EVENT_RBUTTONDOWN` | When the user clicks the right mouse button. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_RBUTTONDOWN` | 当用户点击鼠标右键时。 |'
- en: '| `EVENT_MBUTTONDOWN` | When the user clicks the middle mouse button. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MBUTTONDOWN` | 当用户点击鼠标中键时。 |'
- en: '| `EVENT_LBUTTONUP` | When the user releases the left mouse button. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_LBUTTONUP` | 当用户释放鼠标左键时。 |'
- en: '| `EVENT_RBUTTONUP` | When the user releases the right mouse button. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_RBUTTONUP` | 当用户释放鼠标右键时。 |'
- en: '| `EVENT_MBUTTONUP` | When the user releases the middle mouse button. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MBUTTONUP` | 当用户释放鼠标中键时。 |'
- en: '| `EVENT_LBUTTONDBLCLK` | When the user double-clicks the left mouse button.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_LBUTTONDBLCLK` | 当用户双击鼠标左键时。 |'
- en: '| `EVENT_RBUTTONDBLCLK` | When the user double-clicks the right mouse button.
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_RBUTTONDBLCLK` | 当用户双击鼠标右键时。 |'
- en: '| `EVENT_MBUTTONDBLCLK` | When the user double-clicks the middle mouse button.
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MBUTTONDBLCLK` | 当用户双击鼠标中键时。 |'
- en: '| `EVENTMOUSEWHEEL` | When the user executes a vertical scroll with the mousewheel.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `EVENTMOUSEWHEEL` | 当用户使用鼠标滚轮执行垂直滚动时。 |'
- en: '| `EVENT_MOUSEHWHEEL` | When the user executes a horizontal scroll with the
    mousewheel. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `EVENT_MOUSEHWHEEL` | 当用户使用鼠标滚轮执行水平滚动时。 |'
- en: 'In our sample, we only manage events that result from a left-click of the mouse,
    and any event other than `EVENT_LBUTTONDOWN` is discarded. After discarding other
    events, we obtain the input image like that with the slider callback, and with
    a circle in the image using the circle OpenCV function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只管理由鼠标左键点击产生的事件，任何不是`EVENT_LBUTTONDOWN`的事件都将被丢弃。在丢弃其他事件后，我们获得像滑动条回调函数那样的输入图像，并在图像中使用`circle`
    OpenCV 函数添加一个圆圈：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Graphic user interface with Qt
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 Qt 的图形用户界面
- en: The Qt user interface gives us more control and options to work with our images.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 用户界面为我们提供了更多控制和选项来处理我们的图像。
- en: 'The interface is divided into the following three main areas:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 界面分为以下三个主要区域：
- en: Toolbar
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具栏
- en: Image area
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像区域
- en: Status bar
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态栏
- en: 'We can see these three areas in the following picture. At the top of the image
    is the toolbar, the image is the main area, and the status bar can be seen at
    the bottom of the image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图片中看到这三个区域。图像顶部是工具栏，图像是主要区域，状态栏位于图像底部：
- en: '![](img/61d3f74e-02a7-4f53-be89-ec396b28a42f.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61d3f74e-02a7-4f53-be89-ec396b28a42f.png)'
- en: 'The toolbar has the following buttons from left to right:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，工具栏有以下按钮：
- en: Four buttons for panning
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个用于平移的按钮
- en: Zoom x1
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放大 x1
- en: Zoom x30, show labels
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放大 x30，显示标签
- en: Zoom in
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 放大
- en: Zoom out
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩小
- en: Save current image
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存当前图像
- en: Show properties
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示属性
- en: 'These options can be seen clearly in the following image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项在以下图像中可以清楚地看到：
- en: '![](img/ffab5642-1bf2-44d6-8cfc-386776bed0b1.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffab5642-1bf2-44d6-8cfc-386776bed0b1.png)'
- en: 'The image area shows an image and a contextual menu when we push the right
    mouse button over the image. This area can show an overlay message at the top
    of the area using the `displayOverlay` function. This function accepts three parameters:
    the window name, the text that we want to show, and the period in milliseconds
    for which the overlay text is displayed. If this time is set to `0`, the text
    never disappears:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在图像上按下鼠标右键时，图像区域显示一个图像和一个上下文菜单。此区域可以使用`displayOverlay`函数在区域的顶部显示覆盖消息。此函数接受三个参数：窗口名称、我们想要显示的文本以及覆盖文本显示的毫秒数。如果此时间设置为`0`，则文本永远不会消失：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see the result of the preceding code in the following image. You can
    see a small black box at the top of the image with the sentence Overlay 5secs:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图像中看到前面代码的结果。您可以在图像顶部看到一个带有句子“Overlay 5secs”的小黑框：
- en: '![](img/9e96283c-36bf-42fb-8b99-2594c1145a0a.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e96283c-36bf-42fb-8b99-2594c1145a0a.png)'
- en: 'Finally, the status bar shows the bottom part of the window and shows the pixel
    value and position of the coordinates in the image:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，状态栏显示窗口的底部部分，并显示图像中坐标的像素值和位置：
- en: '![](img/73c772f0-ffb3-4b30-a8a2-e44f9b447069.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73c772f0-ffb3-4b30-a8a2-e44f9b447069.png)'
- en: 'We can use the status bar to show messages like an overlay. The function that
    can change the status bar message is `displayStatusBar`. This function has the
    same parameters as those of the overlay functions: the window name, the text to
    show, and the period of time for which to show it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用状态栏显示类似于覆盖的消息。可以更改状态栏消息的函数是`displayStatusBar`。此函数具有与覆盖函数相同的参数：窗口名称、要显示的文本以及显示它的持续时间：
- en: '![](img/812fe575-7b2a-4d1f-92f7-e5fb119638ff.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/812fe575-7b2a-4d1f-92f7-e5fb119638ff.png)'
- en: Adding buttons to the user interface
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向用户界面添加按钮
- en: In the previous sections, we learned how to create normal or Qt interfaces and
    interact with them using the mouse and sliders, but we can create different types
    of buttons too.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何创建普通或 Qt 界面，并使用鼠标和滑动条与之交互，但我们可以创建不同类型的按钮。
- en: Buttons are only supported in Qt windows.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮仅在 Qt 窗口中受支持。
- en: 'The types of buttons supported by OpenCV Qt are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV Qt 支持的按钮类型如下：
- en: Push button
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮推压
- en: Checkbox
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框
- en: RadioBox
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选框
- en: 'The buttons only appear in the control panel. The control panel is an independent
    window per program where we can attach buttons and trackbars. To show the control
    panel, we can push the last toolbar button, right-click in any part of the Qt
    window and select the Display properties window, or use the *Ctrl *+ *P* shortcut. Let''s
    create a basic sample with buttons. The code is extensive, and we are going to
    explain the main function first and later each callback separately so as to understand
    everything better. The following code shows us the main code function that generates
    the user interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮仅出现在控制面板中。控制面板是每个程序的一个独立窗口，我们可以在这里附加按钮和滑块。要显示控制面板，我们可以点击最后一个工具栏按钮，在Qt窗口的任何部分右键单击并选择显示属性窗口，或者使用`*Ctrl*
    + *P*`快捷键。让我们创建一个带有按钮的基本示例。代码量很大，我们将首先解释主函数，然后分别解释每个回调函数，以便更好地理解所有内容。以下代码显示了生成用户界面的主代码函数：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are going to apply thee types of filters: blur, a sobel filter, and a color
    conversion to gray. All these are optional and the user can choose each one using
    the buttons that we are going to create. Then, to get the status of each filter,
    we create three global Boolean variables:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用三种类型的过滤器：模糊、Sobel滤波器和颜色转换到灰度。所有这些都是可选的，用户可以通过我们即将创建的按钮选择每个选项。然后，为了获取每个过滤器的状态，我们创建了三个全局布尔变量：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the main function, after loading the image and creating the window, we have
    to use the `createButton` function to create each button.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，在加载图像并创建窗口之后，我们必须使用`createButton`函数创建每个按钮。
- en: 'There are three button types defined in OpenCV:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中定义了三种按钮类型：
- en: '`QT_CHECKBOX`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT_CHECKBOX`'
- en: '`QT_RADIOBOX`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT_RADIOBOX`'
- en: '`QT_PUSH_BUTTON`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QT_PUSH_BUTTON`'
- en: 'Each button has five parameters with the following order:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮有五个参数，顺序如下：
- en: The button name
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮名称
- en: A callback function
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个回调函数
- en: A pointer to user variable data passed to callback
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向传递给回调的用户变量数据的指针
- en: The button type
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮类型
- en: The default initialized state used for the checkbox and RadioBox button types
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于复选框和单选按钮类型的默认初始化状态
- en: 'Then, we create a blur checkbox button, two radio buttons for color conversion,
    and a push button for a sobel filter, as you can see in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个模糊复选框按钮，两个用于颜色转换的单选按钮，以及一个用于Sobel滤波器的推送按钮，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These are the most important parts of the main function. We are going to explore
    the `Callback` functions. Each `Callback` changes its status variable to call
    another function called `applyFilters` in order to add the filters activated to
    the input image:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主函数最重要的部分。我们将探讨`Callback`函数。每个`Callback`都会更改其状态变量，以调用另一个名为`applyFilters`的函数，以便将激活的过滤器添加到输入图像中：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `applyFilters` function checks the status variable for each filter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyFilters`函数检查每个过滤器的状态变量：'
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To change the color to gray, we use the `cvtColor` function which accepts three
    parameters: input image, output image, and the color conversion type.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将颜色转换为灰度，我们使用`cvtColor`函数，该函数接受三个参数：输入图像、输出图像和颜色转换类型。
- en: 'The most useful color space conversions are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的颜色空间转换如下：
- en: RGB or BGR to gray (`COLOR_RGB2GRAY`, `COLOR_BGR2GRAY`)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB或BGR到灰度（`COLOR_RGB2GRAY`，`COLOR_BGR2GRAY`）
- en: RGB or BGR to YcrCb (or YCC) (`COLOR_RGB2YCrCb`, `COLOR_BGR2YCrCb`)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB或BGR到YcrCb（或YCC）（`COLOR_RGB2YCrCb`，`COLOR_BGR2YCrCb`）
- en: RGB or BGR to HSV (`COLOR_RGB2HSV`, `COLOR_BGR2HSV`)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB或BGR到HSV（`COLOR_RGB2HSV`，`COLOR_BGR2HSV`）
- en: RGB or BGR to Luv (`COLOR_RGB2Luv`, `COLOR_BGR2Luv`)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB或BGR到Luv（`COLOR_RGB2Luv`，`COLOR_BGR2Luv`）
- en: Gray to RGB or BGR (`COLOR_GRAY2RGB`, `COLOR_GRAY2BGR`)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰度到RGB或BGR（`COLOR_GRAY2RGB`，`COLOR_GRAY2BGR`）
- en: We can see that the codes are easy to memorize.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，代码很容易记住。
- en: OpenCV works by default with the BGR format, and the color conversion is different
    for RGB and BGR, even when converted to gray. Some developers think that *R*+*G*+*B*/*3*
    is true for gray, but the optimal gray value is called **luminosity** and has
    the formula *0*,*21***R* + *0*,*72***G* + *0*,*07***B.*
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV默认使用BGR格式，RGB和BGR的颜色转换不同，即使转换为灰度也是如此。一些开发者认为`R+G+B/3`对灰度是正确的，但最佳灰度值被称为**亮度**，其公式为*0*，*21*`R`
    + *0*，*72*`G` + *0*，*07*`B`。
- en: The blur filter was described in the previous section, and finally, if the `applySobel`
    variable is true, we apply the sobel filter. The sobel filter is an image derivate
    obtained using the sobel operator, commonly used to detect edges. OpenCV allows
    us to generate different derivates with kernel size, but the most common is a
    3x3 kernel to calculate the *x* derivates or *y* derivate.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊滤镜在上一节中已描述，最后，如果 `applySobel` 变量为真，我们应用 Sobel 滤镜。Sobel 滤镜是通过 Sobel 运算符获得的图像导数，通常用于检测边缘。OpenCV
    允许我们使用核大小生成不同的导数，但最常见的是 3x3 核来计算 *x* 导数或 *y* 导数。
- en: 'The most important sobel parameters are the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的 Sobel 参数如下：
- en: Input image
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入图像
- en: Output image
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出图像
- en: Output image depth (`CV_8U`, `CV_16U`, `CV_32F`, `CV_64F`)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出图像深度 (`CV_8U`, `CV_16U`, `CV_32F`, `CV_64F`)
- en: Order of the derivate *x*
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导数 *x* 的顺序
- en: Order of the derivate *y*
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导数 *y* 的顺序
- en: Kernel size (a value of 3 by default)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核大小（默认值为 3）
- en: 'To generate a 3 x 3 kernel and a first *x* order derivate, we have to use the
    following parameters:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 3x3 核和第一个 *x* 顺序导数，我们必须使用以下参数：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following parameters are used for *y* order derivates:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数用于 *y* 顺序导数：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our example, we use the *x* and *y* derivate simultaneously, overwriting
    the input. The following snippet shows how to generate the *x* and *y* derivates
    simultaneously, adding `1` in the fourth and fifth parameters:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们同时使用 *x* 和 *y* 导数，覆盖输入。以下代码片段展示了如何同时生成 *x* 和 *y* 导数，在第四和第五个参数中添加 `1`：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result of applying *x* and *y* derivatives simultaneously looks like following
    image applied to the Lena picture:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同时应用 *x* 和 *y* 导数的结果看起来像以下图像，应用于 Lena 图片：
- en: '![](img/d97827fe-df6a-4482-904c-d438ae87db5a.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d97827fe-df6a-4482-904c-d438ae87db5a.png)'
- en: OpenGL support
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL 支持
- en: OpenCV includes OpenGL support. OpenGL is a graphical library integrated in
    almost all graphical cards as a standard. OpenGL allows us to draw 2D up to complex
    3D scenes. OpenCV includes OpenGL support due to the importance of representing
    3D spaces in a number of tasks. To allow window support in OpenGL, we have to
    set up the `WINDOW_OPENGL` flag when we create the window using the `namedWindow`
    call.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 包含 OpenGL 支持。OpenGL 是集成在几乎所有图形卡中的标准图形库。OpenGL 允许我们绘制 2D 到复杂的 3D 场景。OpenCV
    包含 OpenGL 支持是因为在许多任务中，表示 3D 空间非常重要。为了允许 OpenGL 窗口支持，我们必须在创建窗口时使用 `namedWindow`
    调用设置 `WINDOW_OPENGL` 标志。
- en: 'The following code creates a window with OpenGL support and draws a rotate
    plane where we are going to show the web camera frames:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个具有 OpenGL 支持的窗口，并绘制了一个旋转平面，我们将在此平面上显示网络摄像头帧：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's understand the code!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下代码！
- en: 'The first task is to create the required global variables, where we store the
    video capture, save the frames, and control the animation angle plane and the
    OpenGL texture:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是创建所需的全局变量，其中我们存储视频捕获，保存帧，并控制动画角度平面和 OpenGL 纹理：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In our main function, we have to create the video camera capture to retrieve
    the camera frames:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们必须创建视频摄像头捕获以检索摄像头帧：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the camera is opened correctly, we can create our window with OpenGL support
    using the `WINDOW_OPENGL` flag:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相机正确打开，我们可以使用 `WINDOW_OPENGL` 标志创建具有 OpenGL 支持的窗口：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our example, we want to draw the images that come from the web camera in
    a plane; then, we need to enable the OpenGL textures:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们想在平面上绘制来自网络摄像头的图像；然后，我们需要启用 OpenGL 纹理：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we are ready to draw with OpenGL in our window, but we need to set up a
    draw OpenGL callback like a typical OpenGL application. OpenCV gives us the `setOpenGLDrawCallback`
    function which has two parameters – the window name and the callback function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在窗口中使用 OpenGL 绘制，但我们需要设置一个类似于典型 OpenGL 应用程序的绘制 OpenGL 回调。OpenCV 给我们
    `setOpenGLDrawCallback` 函数，它有两个参数——窗口名称和回调函数：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the OpenCV window and callback function defined, we need to create a loop
    to load the texture, update the window content calling the OpenGL draw callback,
    and finally update the angle position. To update the window content, we use the
    OpenCV function update window with the window name as a parameter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 OpenCV 窗口和回调函数后，我们需要创建一个循环来加载纹理，通过调用 OpenGL 绘制回调更新窗口内容，并最终更新角度位置。为了更新窗口内容，我们使用
    OpenCV 函数 `updateWindow` 并将窗口名称作为参数：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are in the loop when the user presses the *Q* key. Before compiling our
    application sample, we need to define the `loadTexture` function and our `on_opengl`
    callback draw function. The `loadTexture` function converts our `Mat` frame to
    an OpenGL texture image ready to load and use in each callback drawing. Before
    loading the image as a texture, we have to ensure that we have data in our frame
    matrix, checking that the data variable object is not empty:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Q*键时，我们处于循环中。在我们编译应用程序示例之前，我们需要定义`loadTexture`函数和我们的`on_opengl`回调绘制函数。`loadTexture`函数将我们的`Mat`帧转换为OpenGL纹理图像，以便在每次回调绘制中使用。在将图像作为纹理加载之前，我们必须确保我们的帧矩阵中有数据，检查数据变量对象是否为空：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we have data in our matrix frame, then we can create the OpenGL texture
    binding and set the OpenGL texture parameter as a linear interpolation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的矩阵帧中有数据，那么我们可以创建OpenGL纹理绑定，并将OpenGL纹理参数设置为线性插值：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we have to define how the pixels are stored in our matrix and generate
    the pixels with the OpenGL `glTexImage2D` function. It''s very important to note
    that OpenGL uses the RGB format, and OpenCV the BGR format, by default, and we
    have to set up the correct format in this function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须定义像素在我们矩阵中的存储方式，并使用OpenGL的`glTexImage2D`函数生成像素。非常重要的一点是，OpenGL默认使用RGB格式，而OpenCV使用BGR格式，我们必须在这个函数中设置正确的格式：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we only need to finish drawing our plane on every callback when we call `updateWindow`
    in the main loop. We use the common OpenGL functions, and then we load the identity
    OpenGL matrix to reset all our previous changes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在主循环中调用`updateWindow`时，在每次回调中完成我们的平面的绘制。我们使用常见的OpenGL函数，然后加载单位OpenGL矩阵以重置我们之前的所有更改：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also have to bring the frame texture to memory:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须将帧纹理带到内存中：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before drawing our plane, we apply all transformations to our scene. In our
    case, we are going to rotate our plane in the `1,1,1` axis:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制我们的平面之前，我们将应用所有变换到我们的场景中。在我们的例子中，我们将围绕`1,1,1`轴旋转我们的平面：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have the scene correctly set to draw our plane, we are going to
    draw quads faces (faces with four vertices) and use `glBegin (GL_QUADS)` for this
    purpose:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确设置了场景来绘制我们的平面，我们将绘制四边形面（具有四个顶点的面），并使用`glBegin (GL_QUADS)`来完成这个目的：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will draw a plane centered in the `0,0` position, which is 2 units
    in size. Then, we have to define the texture coordinate to use and the vertex
    position using the `glTextCoord2D` and `glVertex2D` functions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制一个以`0,0`位置为中心的平面，大小为2个单位。然后，我们必须定义要使用的纹理坐标和顶点位置，使用`glTextCoord2D`和`glVertex2D`函数：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This OpenGL code becomes obsolete, but it is appropriated to understand better
    the OpenCV and OpenGL integration without complex OpenGL code. By way of an introduction
    to modern OpenGL, read *Introduction to Modern OpenGL*, from *Packt Publishing*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这段OpenGL代码已经过时，但它适合更好地理解OpenCV和OpenGL的集成，而不需要复杂的OpenGL代码。通过现代OpenGL的介绍，阅读*《现代OpenGL入门》*，由*Packt
    Publishing*出版。
- en: 'We can see the result in the following image:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图像中看到结果：
- en: '![](img/07b18665-27b6-4cdc-b90a-5eb71ea48db6.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07b18665-27b6-4cdc-b90a-5eb71ea48db6.png)'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create different types of user interfaces
    to show images or 3D interfaces using OpenGL. We learned how to create sliders
    and buttons or draw in 3D. We learned some basic image processing filters too
    with native OpenCV, but there are new open source alternatives that allow us to
    add more functionalities, such as cvui ([https://dovyski.github.io/cvui/](https://dovyski.github.io/cvui/))
    or OpenCVGUI ([https://damiles.github.io/OpenCVGUI/](https://damiles.github.io/OpenCVGUI/)).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用OpenGL创建不同类型的用户界面来显示图像或3D界面。我们学习了如何创建滑块和按钮或在3D中绘制。我们还使用原生OpenCV学习了一些基本的图像处理过滤器，但有一些新的开源替代品允许我们添加更多功能，例如cvui
    ([https://dovyski.github.io/cvui/](https://dovyski.github.io/cvui/)) 或 OpenCVGUI
    ([https://damiles.github.io/OpenCVGUI/](https://damiles.github.io/OpenCVGUI/))。
- en: In the next chapter, we are going to construct a complete photo tool application
    where we will be applying all the knowledge that we have learned thus far. With
    the graphical user interface, we are going to learn how to apply multiple filters
    to an input image.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个完整的照片工具应用程序，我们将应用迄今为止所学的所有知识。通过图形用户界面，我们将学习如何将多个过滤器应用到输入图像上。
