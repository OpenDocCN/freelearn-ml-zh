- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Sensing Distances to Detect Objects with Pico
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pico 感测距离以检测物体
- en: Our robot is starting to move around independently. We spent the last chapter
    preparing mount points to add sensors, including distance sensors. We can use
    these sensors to detect how far objects are from the robot, and by adding more
    than one, we can see which direction is closest. This sense will allow the robot
    to respond to the real world and drive around a room without much manual control.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人开始独立移动。我们在上一章中准备了安装点以添加传感器，包括距离传感器。我们可以使用这些传感器来检测物体与机器人之间的距离，通过添加多个传感器，我们可以看到哪个方向最近。这种感知能力将使机器人能够对现实世界做出反应，并在没有太多手动控制的情况下在房间内行驶。
- en: In this chapter, we will learn more about these sensors and their limitations.
    Then, we will attach the sensors to the robot and learn more about the communication
    protocol used to talk to them. Next, we will wire the sensors into Raspberry Pi
    Pico and get data. Finally, we will tie multiple sensors together with motor control
    to make the robot avoid obstacles while driving.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更多地了解这些传感器及其局限性。然后，我们将传感器连接到机器人上，并了解用于与它们通信的通信协议。接下来，我们将传感器连接到 Raspberry
    Pi Pico 并获取数据。最后，我们将多个传感器与电机控制结合在一起，使机器人在行驶时能够避开障碍物。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: How distance sensing works
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离传感的工作原理
- en: Soldering headers and attaching them to the robot
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焊接引脚并将其连接到机器人上
- en: An introduction to I2C communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C 通信简介
- en: Communicating with a single distance sensor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单个距离传感器通信
- en: Connecting two distance sensors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接两个距离传感器
- en: Building a wall avoider with Raspberry Pi Pico
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Raspberry Pi Pico 构建避障器
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: The robot build from previous chapters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从前几章构建的机器人
- en: 2 x Pimoroni VL53L1X distance sensor modules
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个 Pimoroni VL53L1X 距离传感器模块
- en: 2 x five-way single row 2.54-mm (included with the modules)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个五向单排 2.54 毫米（包含在模块中）
- en: 8 x male-to-female jump wires with a 2.54-mm DuPont connector
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 根带有 2.54 毫米 DuPont 连接器的公对母跳线
- en: 2 x M2 nuts and M2 x 6-mm bolts
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个 M2 螺母和 M2 x 6 毫米螺栓
- en: A suitable screwdriver for driving the bolts, and a spanner for holding the
    nuts
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合拧紧螺栓的螺丝刀，以及用于夹紧螺母的扳手
- en: A soldering station with a soldering iron, solder, tip-cleaning brass, and soldering
    stand
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有烙铁、焊料、烙铁头清洁黄铜和烙铁支架的焊接站
- en: A flat work area with good lighting, free of interruptions or being nudged
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个平坦的工作区域，光线充足，无干扰或被推挤
- en: The code from previous chapters
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前几章的代码
- en: A Raspberry Pi Pico code editor such as Mu or Thonny
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Raspberry Pi Pico 代码编辑器，如 Mu 或 Thonny
- en: A USB micro cable
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条 USB 微型线
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-08](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-08).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-08](https://github.com/PacktPublishing/Robotics-at-Home-with-Raspberry-Pi-Pico/tree/main/ch-08)找到本章的代码。
- en: How distance sensing works
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离传感的工作原理
- en: Before diving into connecting and programming distance sensors, we should examine
    how they operate. [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139), *Planning and
    Shopping for More Devices*, evaluated options and chose optical (light-based)
    distance sensors. We will be focusing on this type for the remainder of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入连接和编程距离传感器之前，我们应该检查它们的工作原理。[*第 7 章*](B18001_07.xhtml#_idTextAnchor139)，*为更多设备规划和购物*，评估了选项并选择了基于光学的距离传感器。在本章的剩余部分，我们将专注于这种类型。
- en: 'Many distance sensors operate using a principle known as **time of flight**.
    The following diagram demonstrates this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 许多距离传感器使用称为**飞行时间**的原理进行操作。以下图表展示了这一点：
- en: '![Figure 8.1 – Optical distance sensor operation ](img/Figure_8.01_B18001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 光学距离传感器工作原理](img/Figure_8.01_B18001.jpg)'
- en: Figure 8.1 – Optical distance sensor operation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 光学距离传感器工作原理
- en: The preceding diagram shows pictures of robots with sensors and the returned
    light. On the top left, a single beam is emitted (shown as a cone), hits an object,
    and its reflection (shown as a dashed line) hits the sensor (the blue box), which
    detects it. The time between emitting the beam and receiving the response is the
    time of flight used to calculate the distance. At the top right of the diagram,
    both sensors are active. However, the left sensor detects a closer object in its
    beam, returning a lower value than the right sensor, which only detects the wall
    behind the object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了带有传感器和返回光线的机器人的图片。在左上角，发射了一束光（显示为圆锥形），击中了一个物体，其反射（显示为虚线）击中了传感器（蓝色方块），并检测到了它。发射光线和接收响应之间的时间是飞行时间，用于计算距离。在图表的右上角，两个传感器都处于活动状态。然而，左边的传感器在其光束中检测到一个更近的物体，返回的值低于右边的传感器，后者只检测到物体后面的墙壁。
- en: For most materials, the light beams make a diffuse reflection in all directions,
    as the bottom-left part of the diagram shows, and these time-of-flight sensors
    will detect their return. However, like the mirror shown in the bottom right of
    the diagram, some materials do not diffuse their reflected light and reflect away
    at the incident angle. Therefore, these objects may not be detected or will confuse
    the system. It may even detect objects reflected in a mirror as behind the mirror.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数材料，光线以向所有方向扩散的方式反射，如图表的左下角所示，这些飞行时间传感器将检测它们的返回。然而，就像图表右下角所示的镜子一样，有些材料不会扩散它们的反射光线，而是以入射角反射出去。因此，这些物体可能不会被检测到，或者会混淆系统。它甚至可能检测到在镜子中反射的物体，就像在镜子后面一样。
- en: Note that these sensors have a slight instability in their readings, so they
    will take several readings and combine them to produce a more accurate reading.
    The sensors use a timing budget to take several readings. The VL53L1X device does
    this sampling and averaging.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些传感器的读数略有不稳定，因此它们会进行多次读数并将它们结合起来以产生更准确的读数。传感器使用时间预算进行多次读数。VL53L1X设备进行这种采样和平均。
- en: Ambient light conditions can affect these sensors, with very bright light potentially
    washing out the beam. However, these work in most conditions, losing accuracy
    and a little distance but not becoming unusable. In our context, a robot mainly
    needs to detect an oncoming obstacle, so a loss of accuracy is acceptable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光线条件可能会影响这些传感器，非常明亮的光线可能会使光线变淡。然而，在大多数条件下它们都能正常工作，虽然精度会降低，距离也会略微减少，但并不会变得无法使用。在我们的情境中，机器人主要需要检测迎面而来的障碍物，因此精度的降低是可以接受的。
- en: We now understand how the sensors operate. In the next section, let’s attach
    them to the robot.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了传感器的运作方式。在下一节中，我们将把它们连接到机器人上。
- en: Soldering headers and attaching them to the robot
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 焊接引脚并将其连接到机器人上
- en: Before we can start to use or wire the sensors, we will need to solder headers
    onto them and then bolt them so they face forward on the robot.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用或布线传感器之前，我们需要将引脚焊接在它们上面，然后将它们螺栓固定，使它们面向机器人的前方。
- en: Soldering headers
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 焊接引脚
- en: 'I recommend using a spare breadboard for soldering these, as you did with Raspberry
    Pi Pico and the motor controller earlier in [*Chapter 4*](B18001_04.xhtml#_idTextAnchor080),
    *Building a Robot around Pico*. The following photo shows me soldering them:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用一个备用的面包板来焊接这些引脚，就像你在[*第4章*](B18001_04.xhtml#_idTextAnchor080)“围绕Pico构建机器人”中使用的Raspberry
    Pi Pico和电机控制器一样。以下照片显示了我正在焊接它们：
- en: '![Figure 8.2 – Soldering the distance sensor headers ](img/Figure_8.02_B18001.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 焊接距离传感器引脚](img/Figure_8.02_B18001.jpg)'
- en: Figure 8.2 – Soldering the distance sensor headers
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 焊接距离传感器引脚
- en: The photo on the left of the preceding figure shows the sensors, the headers,
    and a breadboard to aid soldering. Place the headers long pins in the breadboard
    holes and the sensors on top. Pimoroni designed these sensor modules to hold the
    board on the header for easy soldering.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表左边的照片显示了传感器、引脚和面包板，以帮助焊接。将引脚的长针插入面包板的孔中，将传感器放在上面。Pimoroni设计了这些传感器模块，以便在引脚上固定板子，以便于焊接。
- en: In the right photo, one sensor has had the header soldered in, and I am soldering
    the other. The headers should be facing back from the sensor so that the wiring
    will not be in the sensor beam.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在右边的照片中，一个传感器已经焊接了引脚，我正在焊接另一个。引脚应该朝向传感器后方，这样布线就不会在传感器光束中。
- en: With the headers soldered, you are ready to fit the sensors onto the robot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚焊接完成后，你就可以将传感器安装到机器人上了。
- en: Mounting the sensors
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装传感器
- en: 'We put a lot of groundwork into mounting the sensors in previous chapters and
    created brackets to mount them onto. The following photo shows these sensors bolted
    on:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们为安装传感器做了大量的准备工作，并创建了支架来安装它们。以下照片显示了这些传感器已经固定到位：
- en: '![Figure 8.3 – Optical distance sensors mounted ](img/Figure_8.03_B18001.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 安装的光学距离传感器](img/Figure_8.03_B18001.jpg)'
- en: Figure 8.3 – Optical distance sensors mounted
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 安装的光学距离传感器
- en: On the left of the preceding photo are the robot’s front, the sensors, and the
    M2 nuts and bolts. We push the sensor’s headers through the slot and bolt them
    in place. Note that there might be a slight tightness around the slot. If so,
    file the header space up and out a little to accommodate this. Wipe or blow away
    any dust after filing. The right shows the sensors bolted onto the front of the
    robot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一张照片的左侧是机器人的前方、传感器以及M2螺母和螺栓。我们将传感器的引脚穿过插槽并固定到位。注意，插槽周围可能会有轻微的紧绷。如果是这样，可以稍微修整引脚空间以适应。修整后，擦拭或吹走任何灰尘。右侧显示了传感器已经固定在机器人的前方。
- en: We will wire these sensors in via I2C. But, first, let’s take a closer look
    at how I2C is used to talk to sensors like this.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过I2C连接这些传感器。但首先，让我们更仔细地看看I2C是如何用来与这类传感器通信的。
- en: Introduction to I2C communication
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C通信简介
- en: You encountered I2C communication in earlier chapters. [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015),
    discussed how I2C is a data bus that carries address information, allowing a primary
    device such as Raspberry Pi Pico to reach multiple devices on a single bus. We
    learned then that Raspberry Pi Pico has two hardware I2C buses. **I2C** (or **I**2**C**)
    is an acronym for **Inter-Integrated Circuit**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你在早期章节中遇到了I2C通信。[*第1章*](B18001_01.xhtml#_idTextAnchor015)讨论了I2C是一个数据总线，它携带地址信息，允许主设备如Raspberry
    Pi Pico在单个总线上访问多个设备。我们当时了解到Raspberry Pi Pico有两个硬件I2C总线。**I2C**（或**I**2**C**）是**Inter-Integrated
    Circuit**的缩写。
- en: In [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139), *Planning and Shopping for
    More Devices*, we saw how we would be using I2C devices both for VL53L1X distance
    sensors along with an IMU.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18001_07.xhtml#_idTextAnchor139)中，*规划和采购更多设备*，我们看到了我们将如何使用I2C设备，包括VL53L1X距离传感器和IMU。
- en: 'How exactly does this bus work? [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015),
    also mentioned that I2C has two wires – a **Serial Clock** line (**SCL**) and
    a **Serial Data** line (**SDA**). The following picture shows how devices send
    signals through them:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个总线究竟是如何工作的？[*第1章*](B18001_01.xhtml#_idTextAnchor015)也提到了I2C有两条线 – 一条**串行时钟**线（**SCL**）和一条**串行数据**线（**SDA**）。以下图片显示了设备如何通过它们发送信号：
- en: '![Figure 8.4 – I2C signals on the wire ](img/Figure_8.04_B18001.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 线上的I2C信号](img/Figure_8.04_B18001.jpg)'
- en: Figure 8.4 – I2C signals on the wire
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 线上的I2C信号
- en: The preceding diagram shows two graphs representing I2C signals. The horizontal
    axis is time, and the vertical axis when high is logic one, with low being logic
    zero. As shown in the top diagram, the clock produces a stream of pulses, a square
    wave. The accompanying data line sends data synchronized with the clock pulses.
    This clock means that devices on the bus are synchronized.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了代表I2C信号的两个图表。水平轴是时间，垂直轴上高电平代表逻辑1，低电平代表逻辑0。如图表顶部所示，时钟产生一系列脉冲，一个方波。伴随的数据线发送与时钟脉冲同步的数据。这个时钟意味着总线上的设备是同步的。
- en: The lines are usually held high (logic high) and pulled down when a device wishes
    to communicate. Devices leave the line high when they have stopped communicating
    so another can control the bus. In most cases, the central controller will send
    a request to a device, and the device will respond.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 线路通常保持高电平（逻辑高），当设备希望通信时被拉低。设备在停止通信后保持线路高电平，以便其他设备可以控制总线。在大多数情况下，中央控制器会向设备发送请求，设备将做出响应。
- en: As mentioned in [*Chapter 1*](B18001_01.xhtml#_idTextAnchor015), devices on
    an I2C bus have an address. However, these VL53L1X devices both have the same
    addresses. Luckily, there are two I2C buses we can use on Raspberry Pi Pico.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第1章*](B18001_01.xhtml#_idTextAnchor015)所述，I2C总线上的设备有一个地址。然而，这些VL53L1X设备都拥有相同的地址。幸运的是，在Raspberry
    Pi Pico上我们可以使用两个I2C总线。
- en: The good thing is that we don’t need to control much of this manually. CircuitPython
    has a `busio` (bus input-output) library for handling I/O operations on a data
    bus, which we’ll use to control these devices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们不需要手动控制太多。CircuitPython有一个`busio`（总线输入输出）库，用于处理数据总线上的I/O操作，我们将使用它来控制这些设备。
- en: We need to wire both SDA and SCL for each sensor and then write code connecting
    them. In the next section, we will discuss how to wire and talk to a single sensor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个传感器连接SDA和SCL，然后编写代码将它们连接起来。在下一节中，我们将讨论如何连接和与单个传感器通信。
- en: Communicating with a single distance sensor
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与单个距离传感器通信
- en: Each distance sensor requires only four wires; however, we will also improve
    the power system. We will then get into the code needed to read data from a system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个距离传感器只需要四根线；然而，我们还将改进电源系统。然后我们将进入读取系统数据的代码。
- en: Wiring the distance sensors
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接距离传感器
- en: 'We start our wiring by looking at a block diagram of our robot, as we saw previously
    in [*Chapter 7*](B18001_07.xhtml#_idTextAnchor139). Look at the following diagram:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从查看我们机器人的框图开始我们的接线，就像我们在[*第7章*](B18001_07.xhtml#_idTextAnchor139)中看到的那样。看看以下图表：
- en: '![Figure 8.5 – The robot block diagram with distance sensors ](img/Figure_8.05_B18001.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 带距离传感器的机器人框图](img/Figure_8.05_B18001.jpg)'
- en: Figure 8.5 – The robot block diagram with distance sensors
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 带距离传感器的机器人框图
- en: The preceding diagram shows the robot block diagram with the additional VL53L1x
    distance sensors connected via I2C to Raspberry Pi Pico. The new parts have a
    thick double outline.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了通过I2C连接到Raspberry Pi Pico的带有额外VL53L1x距离传感器的机器人框图。新部件有一个粗的双轮廓。
- en: 'We need the schematic to get into the details of the connections, as shown
    in the following figure:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要电路图来了解连接的细节，如下面的图所示：
- en: '![Figure 8.6 – The schematic with distance sensors ](img/Figure_8.06_B18001.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 带距离传感器的电路图](img/Figure_8.06_B18001.jpg)'
- en: Figure 8.6 – The schematic with distance sensors
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 带距离传感器的电路图
- en: In the preceding figure, I’ve shown a close-up schematic of the distance sensors
    connected to Raspberry Pi Pico. We connect a sensor to each I2C bus, along with
    3v3 power and ground connections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一张图中，我展示了连接到Raspberry Pi Pico的距离传感器的近距离电路图。我们为每个I2C总线连接一个传感器，以及3v3电源和地线连接。
- en: The right sensor has its SDA connected to `GPIO0` and its SCL connected to `GPIO1`.
    The left sensor connects SDA to `GPIO2` and SCL to `GPIO3`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的传感器将SDA连接到`GPIO0`，将SCL连接到`GPIO1`。左侧的传感器将SDA连接到`GPIO2`，将SCL连接到`GPIO3`。
- en: 'The following photo shows the sensor wiring:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下照片显示了传感器接线：
- en: '![Figure 8.7 – Distance sensors wired into the robot ](img/Figure_8.07_B18001.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 将距离传感器连接到机器人](img/Figure_8.07_B18001.jpg)'
- en: Figure 8.7 – Distance sensors wired into the robot
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 将距离传感器连接到机器人
- en: The preceding photo shows the robot with the sensors wired in using male-to-female
    jumper wires. Remember that you are not connecting the `INT` pin from the sensor
    to anything, so expect a gap here. Also, double-check power and ground connections,
    as reversing these may damage the device. It is also a common troubleshooting
    problem with I2C to have accidentally swapped SDA and SCL lines.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前一张照片显示了使用公对母跳线连接传感器的机器人。请记住，您并没有将传感器的`INT`引脚连接到任何东西，所以这里可能会有一个空隙。此外，请务必检查电源和地线的连接，因为反转这些连接可能会损坏设备。I2C中意外交换SDA和SCL线也是常见的故障排除问题。
- en: 'Once the wiring is complete, please carefully remove the protective cover from
    the sensor, as shown next:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成接线，请按照以下步骤小心地移除传感器的保护盖：
- en: '![Figure 8.8 – Removing the protective tape ](img/Figure_8.08_B18001.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 移除保护胶带](img/Figure_8.08_B18001.jpg)'
- en: Figure 8.8 – Removing the protective tape
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 移除保护胶带
- en: As the preceding photo shows, if your sensors still have protective cover tape,
    carefully use a fingernail or tweezers to remove this cover before use. After
    removing this, take care not to touch the optical parts of the sensor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张照片所示，如果您的传感器仍然有保护性覆盖胶带，请在使用前小心地使用指甲或镊子去除此胶带。去除后，请小心不要触摸传感器的光学部件。
- en: With this wired in, let’s look at how the sensor operates in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 连接好这些线路后，让我们在下一节中看看传感器是如何工作的。
- en: VL53LX theory of operation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VL53LX工作原理
- en: 'These sensors have a particular operation cycle. We can use this as a guide
    for writing our code. The following diagram shows the states of the VL53L1X:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些传感器有一个特定的操作周期。我们可以将其用作编写代码的指南。以下图表显示了VL53L1X的状态：
- en: '![Figure 8.9 – VL53L1X operating states ](img/Figure_8.09_B18001.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – VL53L1X工作状态](img/Figure_8.09_B18001.jpg)'
- en: Figure 8.9 – VL53L1X operating states
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – VL53L1X工作状态
- en: The preceding state diagram is a simplified view of the states of this device.
    The nodes are the states, and the lines between them are events/signals that cause
    the state to change. First, the sensor starts on the left in an idle mode. This
    mode saves power until we want to measure distances. Then, the host (Pico) sends
    a start-ranging signal, and the device enters ranging mode, where it takes active
    measurements. Next, the device enters a data-ready state when it has taken enough
    measurements, as set by the timing budget. In this state, the host can read the
    distance measured.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述状态图是此设备状态的简化视图。节点是状态，它们之间的线条是导致状态变化的事件/信号。首先，传感器从左侧以空闲模式开始。这种模式在我们要测量距离之前节省电量。然后，主机（Pico）发送开始测距信号，设备进入测距模式，进行主动测量。接下来，当设备根据时间预算进行了足够的测量后，它会进入数据就绪状态。在此状态下，主机可以读取测量的距离。
- en: However, the device will not make fresh measurements until the host sends a
    clear interrupt signal, putting it back in the ranging state.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，设备不会进行新的测量，直到主机发送清除中断信号，将其放回测距状态。
- en: Finally, when we no longer need ranging, the host should send the stop-ranging
    signal, which puts the device back into an idle state and uses less power.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们不再需要测距时，主机应该发送停止测距信号，这将设备放回空闲状态并减少功耗。
- en: We will need to account for these state changes in our code, which we will cover
    in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的代码中考虑这些状态变化，我们将在下一节中介绍。
- en: Reading a single distance sensor in CircuitPython
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在CircuitPython中读取单个距离传感器
- en: When reading a sensor, we will use the Adafruit VL53L1X library. Copy `adafruit_vl53l1x.mpy`
    from the Adafruit CircuitPython library into the `lib` folder on the `CIRCUITPY`
    volume. We can also write code inspired by their documentation examples. When
    communicating with any new device, using the example code for the related library
    is always a good start. We will adapt it a little for Raspberry Pi Pico.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取传感器时，我们将使用Adafruit VL53L1X库。将`adafruit_vl53l1x.mpy`从Adafruit CircuitPython库复制到`CIRCUITPY`卷上的`lib`文件夹。我们也可以根据他们的文档示例编写代码。与任何新设备通信时，使用相关库的示例代码始终是一个好开始。我们将对其进行一些调整以适应Raspberry
    Pi Pico。
- en: 'We start the code in the `read_1_sensor.py` file with imports:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`read_1_sensor.py`文件中开始代码的导入：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ve two new imports here. Alongside the vl53l1x library, the `busio` library
    uses Pico pins to form data buses such as `I2C`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们有两个新的导入。除了vl53l1x库之外，`busio`库使用Pico引脚形成数据总线，如`I2C`。
- en: 'Next, we need to set up the `I2C` bus and device:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置`I2C`总线和设备：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This first line forms the `I2C` bus using GP0 and GP1 pins, corresponding with
    the left sensor. Pico is a little fussy about which pins you can use for the SDA
    and SCL lines of an `I2C` bus. We then create the VL53L1X device with this `I2C`
    bus. In the next section of code, we send some settings to the device:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一行使用GP0和GP1引脚形成`I2C`总线，对应左边的传感器。Pico对可用于`I2C`总线SDA和SCL线的引脚有些挑剔。然后我们使用这个`I2C`总线创建VL53L1X设备。在下一节代码中，我们向设备发送一些设置：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The device has multiple distance modes; distance mode 1 is short-range – for
    close objects. We set a timing budget of 100 milliseconds, controlling how long
    the sensor is allowed to take for measuring. It limits the maximum distance and
    the number of measurements used to smooth data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设备有多个距离模式；距离模式1是短距离模式——用于近距离物体。我们设置了一个100毫秒的时间预算，控制传感器允许测量多长时间。它限制了最大距离和用于平滑数据的测量次数。
- en: 'Let’s start the device:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设备：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have now moved the device from the idle state into the ranging state. We
    can now wait for the measurements to be ready. We can now write the code for the
    `main` loop:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将设备从空闲状态移动到测距状态。我们现在可以等待测量准备就绪。我们现在可以编写`main`循环的代码：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This loop starts by checking whether the device has data ready to read. When
    it has `data_ready`, we can read data with `vl53.distance` and print it. This
    distance is in centimeters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环首先检查设备是否有准备好的数据读取。当它有`data_ready`时，我们可以使用`vl53.distance`读取数据并打印出来。这个距离是以厘米为单位的。
- en: After reading the data, we need to send a `clear_interrupt` signal, so the sensor
    goes back into its ranging mode for a new reading.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据后，我们需要发送一个`clear_interrupt`信号，这样传感器就会回到其测距模式进行新的读取。
- en: Regardless of whether there is data, the system will wait 50 milliseconds before
    looping around and checking again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否有数据，系统都会等待50毫秒后循环并再次检查。
- en: 'Upload this file to Pico and update `code.py` to import `read_1_sensor.py`.
    Then, when you run it and connect the REPL, you should see output like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件上传到Pico，并更新`code.py`以导入`read_1_sensor.py`。然后，当你运行它并连接REPL时，你应该看到如下输出：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s check a few things to ensure everything’s all working before we carry
    on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们检查一些事情以确保一切正常工作。
- en: Troubleshooting
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'If this example code doesn’t work, the following troubleshooting steps will
    help:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个示例代码不起作用，以下故障排除步骤将有所帮助：
- en: If you receive the `No pull up found on SDA or SCL; check your wiring` warning,
    this indicates the wiring may be incorrect or that wires may be loose. Power down
    and check the wiring.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你收到“在SDA或SCL上未找到上拉；检查你的布线”警告，这表明布线可能不正确或线可能松动。关闭电源并检查布线。
- en: 'The `No I2C device at address: 29` warning likely means you have reversed SDA
    and SCL. Swap them and try again.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在地址29上没有I2C设备”警告可能意味着你反接了SDA和SCL。交换它们并再次尝试。
- en: There must be no heat in any part of the circuit including the wires, the batteries,
    the sensor, or Pico – this will cause damage, and should be powered down then
    the wiring checked carefully.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路的任何部分，包括电线、电池、传感器或Pico，都不能有热量——这将造成损坏，应该关闭电源并仔细检查布线。
- en: Sometimes, sensors can get stuck between test runs, resulting in slow or erratic
    results or sensors showing no errors but never having data ready. I advise powering
    the whole robot down.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，传感器可能在测试运行之间卡住，导致结果缓慢或不规律，或者传感器显示没有错误但数据始终未准备好。我建议关闭整个机器人的电源。
- en: Try adding lines such `print("i2c set up")` between stages to see where the
    problem is.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在各个阶段之间添加如`print("i2c set up")`之类的行，以查看问题所在。
- en: If you see `unsupported operation` or `unknown distance mode`, check the power
    wiring to ensure each sensor is well connected.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你看到`不支持的操作`或`未知距离模式`，请检查电源布线，确保每个传感器都连接良好。
- en: Note that powering down means turning off battery power (if you’ve turned that
    on) and unplugging the computer. Never leave the computer plugged in during rewiring.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，关闭电源意味着关闭电池电源（如果你已经打开了它）并拔掉电脑。在重新布线时，永远不要让电脑插上电源。
- en: We should have data being read reliably from a single sensor. Our robot has
    two sensors, though, so let’s read data from both in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够从单个传感器可靠地读取数据。然而，我们的机器人有两个传感器，所以让我们在下一节中读取两个传感器的数据。
- en: Connecting two distance sensors
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接两个距离传感器
- en: 'We have wired in two sensors, each on a separate set of pins. Create the `read_2_sensors.py`
    file. The imports look identical:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经布线了两个传感器，每个传感器都连接到一组不同的引脚。创建`read_2_sensors.py`文件。导入看起来相同：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we come to set up the sensors, we first need to set up two `I2C` buses
    on the different pins and then use them:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置传感器时，我们首先需要在不同的引脚上设置两个`I2C`总线，然后使用它们：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can also apply the same configuration settings for both sensors:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为两个传感器应用相同的配置设置：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main loop starts in the same way, with both sensors going into ranging
    mode:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环以相同的方式开始，两个传感器进入测距模式：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And in this case, we will check for ready data from both sensors before printing:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在打印之前将检查两个传感器的就绪数据：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When uploaded and run on Pico, this code will now output both sensors’ data,
    as shown next:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当上传并运行在Pico上时，此代码现在将输出两个传感器的数据，如下所示：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll troubleshoot any problems here before we use two sensors for smarter behavior.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用两个传感器实现更智能的行为之前，我们将先解决这里的问题。
- en: Troubleshooting
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'Adding a second sensor can still cause odd behavior:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 添加第二个传感器仍然可能导致奇怪的行为：
- en: First, the wiring considerations in the single sensor apply.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，单传感器布线注意事项适用。
- en: If you have used the same I2C bus twice in code, you will get some odd behavior
    or the same reading from both sensors. Check the code for this.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你已经在代码中两次使用了相同的I2C总线，你可能会得到一些奇怪的行为或两个传感器的相同读数。检查代码以确认这一点。
- en: We now have data from two sensors, and in the next section, we’ll use this data
    to make the robot avoid objects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个传感器的数据，在下一节中，我们将使用这些数据使机器人避开物体。
- en: Building a wall avoider with Raspberry Pi Pico
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Raspberry Pi Pico构建避障器
- en: Two distance sensors and independent motor control with some code are the ingredients
    needed to avoid obstacles. Let’s start by putting the distance sensors in the
    shared robot library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 两个距离传感器和一些代码中的独立电机控制是避免障碍物的必要成分。让我们首先将距离传感器放入共享的机器人库中。
- en: Preparing the robot library
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备机器人库
- en: 'Like we have with other aspects of the robot, we’ll start by building the distance
    sensors set up in the `robot.py` file. At the top of this file, the imports now
    include `busio` and `adafruit_vl53l1x` libraries:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在机器人的其他方面所做的那样，我们将从在 `robot.py` 文件中设置距离传感器开始。在此文件的顶部，导入现在包括 `busio` 和 `adafruit_vl53l1x`
    库：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can then set up our left and right distance sensors. Insert the following
    below the encoder setup and above the `stop` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置我们的左右距离传感器。在编码器设置下方和 `stop` 函数上方插入以下内容：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save this file and be sure to upload it to the `CIRCUITPY` volume.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件，并确保将其上传到 `CIRCUITPY` 卷。
- en: We will use `robot.py` in the avoider code. We must next consider how avoiding
    behaviors operate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在避障器代码中使用 `robot.py`。接下来，我们必须考虑避障行为如何操作。
- en: Wall-avoiding theory of operation
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避障器操作理论
- en: 'We need to consider data from both sensors to avoid walls. The following diagram
    shows how we will do this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑两个传感器的数据来避免墙壁。以下图表显示了我们将如何做到这一点：
- en: '![Figure 8.10 – Avoiding walls with two sensors ](img/Figure_8.10_B18001.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 使用两个传感器避免墙壁](img/Figure_8.10_B18001.jpg)'
- en: Figure 8.10 – Avoiding walls with two sensors
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 使用两个传感器避免墙壁
- en: In the preceding diagram, a sketched robot is facing a wall. It has sensed the
    wall, but the object is closer to the left sensor than the right; dashed arrows
    show reflections coming from the object. That means the robot should turn right
    to avoid this object, shown by the curved arrow to the robot’s left. We will make
    the turn by reversing the right motor until it is clear of the obstacle.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，一个草图机器人面对墙壁。它已经检测到墙壁，但物体比右侧传感器更靠近左侧；虚线箭头显示来自物体的反射。这意味着机器人应该向右转以避开这个物体，由机器人左侧的弯曲箭头表示。我们将通过反转右侧电机直到它清除障碍物来完成转弯。
- en: There is a special edge case where the two sensors detect the wall as equally
    close. To ensure the robot decides to avoid the flat obstacle, we will slightly
    bias (weight one side) by checking one sensor first and making a turn based on
    that.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊情况，两个传感器检测到墙壁距离相等。为了确保机器人决定避开平坦的障碍物，我们将稍微偏置（加权一侧）通过首先检查一个传感器并根据它进行转弯。
- en: We have all the parts we need. So, let’s start writing this code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所有需要的部分。所以，让我们开始编写这段代码。
- en: Distance sensor wall avoider code
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 距离传感器墙壁避障器代码
- en: 'The code for this uses the distance sensors from the robot library. Put this
    in `avoid_walls.py`. Let’s start with familiar imports and by setting the sensor
    config:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用机器人库中的距离传感器。将其放入 `avoid_walls.py`。让我们从熟悉的导入和设置传感器配置开始：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We’ll leave sensors on the default timing budget. We then have some configurations
    for our avoider:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持传感器的默认时间预算。然后我们有我们避障器的配置：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `too_close_cm` variable has a threshold for when the robot should turn
    to avoid a wall. We can set the overall robot speed for this behavior in the `speed`
    variable. We can tune these two variables to ensure the robot avoids a wall in
    time. Let’s start the sensors ranging:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`too_close_cm` 变量设置了当机器人应该转弯以避开墙壁时的阈值。我们可以在 `speed` 变量中设置此行为的整体机器人速度。我们可以调整这两个变量以确保机器人在时间上避开墙壁。让我们开始传感器测距：'
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We are going to start the robot moving; however, we want to ensure that the
    robot stops moving and stops the sensors ranging if there are any problems, so
    we wrap the main loop in `try`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始让机器人移动；然而，我们想确保如果出现任何问题，机器人停止移动并停止传感器测距，所以我们用 `try` 将主循环包裹起来：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A `finally` statement to accompany that `try` will come below the main loop.
    Next, we check whether there is sensor data ready:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环下方将伴随 `try` 的 `finally` 语句。接下来，我们检查是否有传感器数据准备好：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We store the read distances so that we can use them throughout the handling.
    Note that while `robot.left_distance.distance` looks like a variable, it is a
    property that actively reads the sensor when we use it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储读取的距离，以便在整个处理过程中使用。请注意，虽然 `robot.left_distance.distance` 看起来像是一个变量，但它是一个属性，在我们使用它时主动读取传感器。
- en: 'Since we have two values, we should check if one side is too close. Note that
    a timeout will result in a `0` value, so we should check values are above this
    too. By favoring a side, we slightly bias the robot to that side, and this should
    stop the robot from being *indecisive* if both sensors detect a close obstacle:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有两个值，我们应该检查是否有一侧太近。请注意，超时将导致 `0` 值，因此我们也应该检查值是否高于这个值。通过偏向一侧，我们稍微偏置机器人到那一侧，这应该阻止机器人如果两个传感器都检测到近处的障碍物时犹豫不决：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We check whether the distance on the right sensor is closer than the threshold.
    If so, we print a line of debug, showing that we’ve detected an obstacle and the
    two sensor readings. We then set the left motor to go backward, which will cause
    the robot to swerve left, away from the obstacle.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查右边的距离传感器是否比阈值更近。如果是这样，我们打印一行调试信息，显示我们已经检测到障碍物和两个传感器的读数。然后我们将左电机设置为向后行驶，这将导致机器人向左偏离障碍物。
- en: 'We can now handle what happens otherwise:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以处理其他情况：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we’ve not turned left, we ensure the left motor is going forward. We then
    check the left distance sensor, and if this is too close, we turn right. Finally,
    we set the right motor forward, so both motors will be going forward if it detects
    nothing too close.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有向左转，我们确保左电机向前行驶。然后我们检查左边的距离传感器，如果太近，我们就向右转。最后，我们设置右电机向前，这样如果它检测到没有太近的物体，两个电机都会向前行驶。
- en: Putting the left distance check in the `else` means that the robot will not
    set both motors backward and will favor turning left in front of an obstacle directly
    in front.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将左距离检查放在`else`中意味着机器人不会同时设置两个电机向后行驶，并且会优先在直接面对障碍物时向左转。
- en: 'We then need to finish the loop by clearing the interrupts (so that the sensors
    are ranging again), and we leave a little time for them to sense again:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过清除中断（这样传感器就可以再次进行测量）来完成循环，并留出一点时间让它们再次感应：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we need to handle any errors that happened. If you recall, we wrapped
    this code in a `try` block. The `finally` block stops and cleans everything up:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理发生的任何错误。如果你还记得，我们把这个代码包裹在一个`try`块中。`finally`块停止并清理一切：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first thing we do here is to stop the motors. If anything goes wrong, such
    as errors from sensors or the code, we don’t want the robot to drive into a wall.
    We then clear the sensor interrupts and stop the sensors, putting them back into
    idle mode.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第一件事是停止电机。如果发生任何错误，比如传感器或代码的错误，我们不希望机器人撞到墙壁。然后我们清除传感器中断并停止传感器，将它们放回空闲模式。
- en: 'This example is complete, and you can send it to the robot along with the updated
    `robot.py`. Keep the battery power turned off initially and test that it detects
    obstacles. You should see output like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已经完整，你可以将它连同更新的`robot.py`一起发送给机器人。最初请保持电池电源关闭，并测试它是否能检测到障碍物。你应该会看到以下输出：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you’ve seen it working and detecting, you can turn the battery power on,
    which will enable the motors and let drive along – either using a long USB cable
    or independently if it’s working well. Let’s check whether we have any problems
    with some troubleshooting.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你看到它工作并检测到障碍物，你就可以打开电池电源，这将启用电机并允许机器人行驶——无论是使用长USB线还是如果它运行良好，可以独立运行。让我们检查是否有任何问题，并进行一些故障排除。
- en: Troubleshooting
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'These steps should get you up and running if you have any problems:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何问题，以下步骤应该能帮助你启动：
- en: If the robot complains about importing modules, ensure you have uploaded the
    code and libraries for this chapter and previous ones.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人抱怨导入模块，请确保你已经上传了本章及之前章节的代码和库。
- en: If the robot is getting too close before turning, try increasing the `too_close`
    variable.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器人在转弯前太靠近，尝试增加`too_close`变量。
- en: With any behavior using motors, ensure the batteries are fresh. Low power can
    cause stalling motors and malfunctioning sensors.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用任何涉及电机的行为时，确保电池电量充足。低电量可能导致电机停滞和传感器故障。
- en: The sensors will not detect obstacles that are above or below them. This limitation
    means the robot will drive into and get stuck on low obstacles or under high ones.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器无法检测到在它们上方或下方的障碍物。这种限制意味着机器人可能会驶入并卡在低障碍物上或在高障碍物下。
- en: Your robot now avoids walls and objects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人现在可以避开墙壁和物体。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about distance sensors. We looked at how the sensors
    operate and how to attach them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了距离传感器。我们了解了传感器的运作方式以及如何将它们连接起来。
- en: We learned more about the `I2C` bus and then saw how to electrically connect
    these VL53L1X distance sensors.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更多地了解了`I2C`总线，然后了解了如何将这些VL53L1X距离传感器进行电气连接。
- en: We then looked at the operating modes of the VL53L1X sensor and wrote code to
    get readings from one. Finally, we finished with a behavior to avoid walls using
    this sensor.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着研究了VL53L1X传感器的操作模式，并编写了从其中一个传感器获取读数的代码。最后，我们完成了使用该传感器避开墙壁的行为。
- en: In the next chapter, we will gain remote control of our robot by adding Bluetooth.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加蓝牙来获得对机器人的远程控制。
- en: Exercises
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'You can use these exercises to practice more of the concepts learned in this
    chapter:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些练习来练习本章学到的更多概念：
- en: Could you write code to follow an object at a fixed distance? If it’s further
    away, could you drive it forward, and if it’s too close, back it up a little?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能编写代码来保持一个物体在固定距离吗？如果它离得远，你能让它向前行驶，如果它太近，就稍微后退一点吗？
- en: Try different materials in front of the robot, such as glass, black fabric,
    thin paper, and thick paper. Observe which are detected and how they affect the
    distance detected. For example, what happens if you aim the robot at a mirror?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器人前方尝试不同的材料，例如玻璃、黑色布料、薄纸和厚纸。观察哪些被检测到以及它们如何影响检测到的距离。例如，如果你将机器人对准镜子会发生什么？
- en: Try observing the distance measurements in different light conditions, such
    as room light, darkness, and full sunlight.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在不同光照条件下观察距离测量，例如室内灯光、黑暗和全阳光。
- en: Additional reading
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外阅读
- en: 'The following sources of additional reading can deepen your understanding of
    these sensors:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下额外阅读资源可以加深你对这些传感器的理解：
- en: '[https://github.com/adafruit/Adafruit_CircuitPython_VL53L1X](https://github.com/adafruit/Adafruit_CircuitPython_VL53L1X)
    has the library and sample code for driving a device.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/adafruit/Adafruit_CircuitPython_VL53L1X](https://github.com/adafruit/Adafruit_CircuitPython_VL53L1X)
    包含了驱动设备的库和示例代码。'
- en: '[https://www.ti.com/lit/an/sbau305b/sbau305b.pdf](https://www.ti.com/lit/an/sbau305b/sbau305b.pdf)
    is a datasheet for a different brand of optical sensors. However, it has excellent
    information on reflectance and how materials affect distance sensing.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.ti.com/lit/an/sbau305b/sbau305b.pdf](https://www.ti.com/lit/an/sbau305b/sbau305b.pdf)
    是一款不同品牌的光学传感器的数据表。然而，它提供了关于反射率和材料如何影响距离传感的极好信息。'
- en: '[https://www.st.com/en/imaging-and-photonics-solutions/vl53l1x.html#documentation](https://www.st.com/en/imaging-and-photonics-solutions/vl53l1x.html#documentation)
    contains the complete product documentation. Of particular interest are the product
    specifications and API user manual.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.st.com/en/imaging-and-photonics-solutions/vl53l1x.html#documentation](https://www.st.com/en/imaging-and-photonics-solutions/vl53l1x.html#documentation)
    包含了完整的产品文档。特别感兴趣的是产品规格和API用户手册。'
- en: For an alternative technique using ultrasonic distance sensors, refer to *Learn
    Robotics Programming – Second Edition* by *Danny Staple*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用超声波距离传感器的替代技术，请参阅**丹尼·斯特普尔**所著的《学习机器人编程——第二版》。
