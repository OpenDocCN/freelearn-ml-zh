- en: Chapter 2. An Introduction to the Basics of OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。OpenCV 基础知识简介
- en: After covering the installation of OpenCV on different operating systems in
    [Chapter 1](ch01.html "Chapter 1. Getting Started with OpenCV"), *Getting Started
    with OpenCV*, we are going to introduce the basics of OpenCV development in this
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第1章](ch01.html "第1章。OpenCV 入门") 中介绍了在不同操作系统上安装 OpenCV 后，我们将介绍本章的 OpenCV 开发基础知识。
- en: In this chapter, you will learn how to create your project using CMake.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 CMake 创建你的项目。
- en: We will also introduce the image basic data structures, matrices, and other
    structures that are required in our projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍图像基本数据结构、矩阵和其他在我们项目中需要的结构。
- en: We will learn how to save our variables and data in files using the XML/YAML
    persistence OpenCV functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用 OpenCV 的 XML/YAML 持久性函数将我们的变量和数据保存到文件中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Configuring projects with CMake
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 配置项目
- en: Reading/writing images from/to disk
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从/到磁盘读取/写入图像
- en: Reading videos and accessing camera devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读视频和访问相机设备
- en: The main image structures (matrices)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要图像结构（矩阵）
- en: Other important and basic structures (vectors, scalars, and so on)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他重要和基本的结构（向量、标量等）
- en: An introduction to basic matrix operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本矩阵操作简介
- en: File storage operations with the XML/YAML persistence OpenCV API
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XML/YAML 持久性 OpenCV API 进行文件存储操作
- en: Basic CMake configuration files
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本CMake配置文件
- en: To configure and check all the required dependencies of our project, we are
    going to use CMake; but it is not mandatory, so we can configure our project in
    any other tool or IDE such as Makefiles or Visual Studio. However, CMake is the
    most portable way to configure multiplatform C++ projects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置和检查我们项目的所有必需依赖项，我们将使用 CMake；但这不是强制性的，因此我们可以使用任何其他工具或 IDE（如 Makefiles 或 Visual
    Studio）来配置我们的项目。然而，CMake 是配置多平台 C++ 项目的最便携方式。
- en: 'CMake uses configuration files called `CMakeLists.txt`, where the compilation
    and dependency processes are defined. For a basic project, based on an executable
    build from one source code file, a two-line `CMakeLists.txt` file is all that
    is needed. The file looks like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 使用名为 `CMakeLists.txt` 的配置文件，其中定义了编译和依赖过程。对于一个基于单个源代码文件的可执行文件的基本项目，所需的
    `CMakeLists.txt` 文件只有两行。文件看起来像这样：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line defines the minimum version of CMake required. This line is mandatory
    in our `CMakeLists.txt` file and allows you to use the `cmake` functionality defined
    from a given version defined in the second line; it defines the project name.
    This name is saved in a variable called `PROJECT_NAME`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了所需的 CMake 的最低版本。这一行在我们的 `CMakeLists.txt` 文件中是强制性的，并允许您使用第二行中定义的给定版本的 `cmake`
    功能；它定义了项目名称。此名称保存在一个名为 `PROJECT_NAME` 的变量中。
- en: The last line creates an executable command (`add_executable()`) in the `main.cpp`
    file, gives it the same name as our project (`${PROJECT_NAME}`), and compiles
    our source code into an executable called `CMakeTest`, which we set as the project
    name.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行在 `main.cpp` 文件中创建一个可执行命令（`add_executable()`），给它与我们的项目相同的名称（`${PROJECT_NAME}`），并将我们的源代码编译成一个名为
    `CMakeTest` 的可执行文件，我们将它设置为项目名称。
- en: The `${}` expression allows access to any variable defined in our environment.
    Then, we can use the `${PROJECT_NAME}` variable as an executable output name.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`${}` 表达式允许访问我们环境中定义的任何变量。然后，我们可以使用 `${PROJECT_NAME}` 变量作为可执行文件的输出名称。'
- en: Creating a library
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建库
- en: CMake allows you to create libraries, which are indeed used by the OpenCV build
    system. Factorizing the shared code among multiple applications is a common and
    useful practice in software development. In big applications or when the common
    code is shared in multiple applications, this practice is very useful.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 允许你创建库，这确实是 OpenCV 构建系统所使用的。在软件开发中，将共享代码分解为多个应用程序是一种常见且有用的做法。在大型应用程序或当共享代码在多个应用程序中共享时，这种做法非常有用。
- en: In this case, we do not create a binary executable; instead, we create a compiled
    file that includes all the functions, classes, and so on, developed. We can then
    share this library file with the other applications without sharing our source
    code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不创建二进制可执行文件；相反，我们创建一个包含所有开发的功能、类等的编译文件。然后，我们可以将这个库文件与其他应用程序共享，而无需共享我们的源代码。
- en: 'CMake includes the `add_library` function for this purpose:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 包含 `add_library` 函数用于此目的：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The lines starting with `#` add comments and are ignored by CMake.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `#` 开头的行添加注释，并被 CMake 忽略。
- en: The `add_library(Hello hello.cpp hello.h)` command defines our new library called,
    where `Hello` is the library name and `hello.cpp`, `hello.h` are the source files.
    We add the header file to allow IDEs such as Visual Studio to link to the header
    files.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_library(Hello hello.cpp hello.h)`命令定义了我们新的库，名为“Hello”，其中“Hello”是库名，“hello.cpp”和“hello.h”是源文件。我们添加头文件是为了允许IDE（如Visual
    Studio）链接到头文件。'
- en: This line will generate a shared file (So for OS X and Unix or `.dll` for Windows)
    or a static library (A for OS X and Unix or `.dll` for Windows), depending on
    our operating system or if it is a dynamic or static library.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这行将根据我们的操作系统或是否是动态库或静态库生成共享文件（对于OS X和Unix是So，对于Windows是.dll）或静态库（对于OS X和Unix是A，对于Windows是.dll）。
- en: '`target_link_libraries( executable Hello)` is the function that links our executable
    to the desired library; in our case, it''s the `Hello` library.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_link_libraries(executable Hello)`是链接我们的可执行文件到所需库的函数；在我们的例子中，它是`Hello`库。'
- en: Managing dependencies
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: CMake has the ability to search our dependencies and external libraries, giving
    us the facility to build complex projects depending on external components in
    our projects and by adding some requirements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CMake具有搜索我们的依赖项和外部库的能力，这为我们提供了在项目中构建依赖于外部组件的复杂项目的便利性，并且通过添加一些要求。
- en: 'In this book, the most important dependency is, of course, OpenCV, and we will
    add it to all our projects:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，最重要的依赖当然是OpenCV，我们将将其添加到所有我们的项目中：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s understand the working of the script:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解脚本的运行机制：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first line defines the minimum CMake version; the second line tells CMake
    to use the new behavior of CMake so that it can correctly recognize numbers and
    Booleans constants without dereferencing variables with such names. This policy
    was introduced in CMake 2.8.0, and CMake warns when the policy is not set to version
    3.0.2\. Finally, the last line defines the project title:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了最低的CMake版本；第二行告诉CMake使用CMake的新行为，以便它可以正确识别不需要解引用变量的数字和布尔常量。这项策略是在CMake
    2.8.0中引入的，CMake在策略未设置为3.0.2时发出警告。最后，最后一行定义了项目标题：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is where we search for our OpenCV dependency. `FIND_PACKAGE` is the function
    that allows us to find our dependencies and the minimum version required if this
    dependency is required or optional. In this sample script, we look for OpenCV
    in version 3.0.0 or greater and it is a required package.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们搜索OpenCV依赖项的地方。`FIND_PACKAGE`是允许我们找到依赖项以及如果该依赖项是必需的或可选的，所需的最低版本的函数。在这个示例脚本中，我们寻找版本3.0.0或更高版本的OpenCV，并且它是一个必需的包。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `FIND_PACKAGE` command includes all OpenCV submodules, but you can specify
    the submodules that you want to include in the project by making your application
    smaller and faster. For example, if we are going to work only with the basic OpenCV
    types and core functionalities, we can use the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIND_PACKAGE`命令包含所有OpenCV子模块，但你可以通过指定你想要包含在项目中的子模块来使你的应用程序更小、更快。例如，如果我们只打算使用基本的OpenCV类型和核心功能，我们可以使用以下命令：'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If CMake does not find it, it returns an error and does not prevent us from
    compiling our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CMake找不到它，它将返回一个错误，但不会阻止我们编译我们的应用程序。
- en: 'The MESSAGE function shows a message on the terminal or CMake GUI. In our case,
    we will show the OpenCV version, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MESSAGE函数在终端或CMake GUI上显示消息。在我们的例子中，我们将显示OpenCV版本，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`${OpenCV_VERSION}` is a variable where CMake stores the OpenCV package version.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`${OpenCV_VERSION}`是一个变量，CMake在其中存储OpenCV包的版本。'
- en: 'The `include_directories()` and `link_directories()` add the header and the
    directory of the specified library to our environment. OpenCV''s CMake module
    saves this data in the `${OpenCV_INCLUDE_DIRS}` and `${OpenCV_LIB_DIR}` variables.
    These lines are not required in all platforms, such as Linux, because these paths
    are normally in the environment, but it''s recommended that you have more than
    one OpenCV version to choose from the correct link and include directories:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`include_directories()`和`link_directories()`将指定的库的头文件和目录添加到我们的环境中。OpenCV的CMake模块将这些数据保存在`${OpenCV_INCLUDE_DIRS}`和`${OpenCV_LIB_DIR}`变量中。这些行在所有平台（如Linux）中不是必需的，因为这些路径通常在环境中，但建议你拥有多个OpenCV版本，以便从正确的链接和包含目录中进行选择：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This last line creates the executable and links it to the OpenCV library, as
    we saw in the previous section, *Creating a library*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一行创建了可执行文件并将其链接到OpenCV库，正如我们在上一节“创建库”中看到的。
- en: 'There is a new function in this piece of code called `SET`. This function creates
    a new variable and adds any value that we need to it. In our case, we set the
    SRC variable to the `main.cpp` value. However, we can add more and more values
    to the same variable, as shown in this script:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有一个新函数叫做 `SET`。此函数创建一个新变量并将任何需要的值添加到其中。在我们的例子中，我们将 SRC 变量设置为 `main.cpp`
    的值。然而，我们可以向同一个变量添加更多和更多的值，如本脚本所示：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Making the script more complex
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使脚本更加复杂
- en: In this section, we will show you a more complex script that includes subfolders,
    libraries, and executables, all in only two files and a few lines, as shown in
    this script.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示一个更复杂的脚本，该脚本包含子文件夹、库和可执行文件，所有这些都在两个文件和几行中，如本脚本所示。
- en: It's not mandatory to create multiple `CMakeLists.txt` files because we can
    specify everything in the main `CMakeLists.txt` file. It is more common to use
    different `CMakeLists.txt` files for each project subfolder, making it more flexible
    and portable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不必创建多个 `CMakeLists.txt` 文件，因为我们可以在主 `CMakeLists.txt` 文件中指定所有内容。更常见的是为每个项目子文件夹使用不同的
    `CMakeLists.txt` 文件，这使得它更加灵活和可移植。
- en: 'This example has a code structure folder that contains one folder for the `utils`
    library and the other for the `root` folder, which contains the main executable:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例有一个代码结构文件夹，包含一个用于 `utils` 库的文件夹，另一个用于包含主可执行文件的 `root` 文件夹：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we need to define two `CMakeLists.txt` files: one in the `root` folder
    and the other in the `utils` folder. The `CMakeLists.txt` root folder file has
    the following contents:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要定义两个 `CMakeLists.txt` 文件：一个在 `root` 文件夹中，另一个在 `utils` 文件夹中。`CMakeLists.txt`
    根文件夹文件的内容如下：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Almost all the lines are described in the previous sections except for some
    functions that we will explain in later sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有行都在前面的章节中描述过，除了我们将在后面的章节中解释的一些函数。
- en: The `add_subdirectory()` tells CMake to analyze the `CMakeLists.txt` of a desired
    subfolder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_subdirectory()` 告诉 CMake 分析所需子文件夹的 `CMakeLists.txt` 文件。'
- en: Before we continue with an explanation of the main `CMakeLists.txt` file, we
    will explain the `utils CMakeLists.txt` file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续解释主 `CMakeLists.txt` 文件之前，我们将解释 `utils CMakeLists.txt` 文件。
- en: 'In the `CMakeLists.txt` file in the `utils` folder, we will write a new library
    to include it in our main project folder:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `utils` 文件夹中的 `CMakeLists.txt` 文件中，我们将编写一个新的库并将其包含在我们的主项目文件夹中：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This CMake script file defines an `UTILS_LIB_SRC` variable where we add all
    the source files included in our library, generate the library with the `add_library`
    function, and use the `target_include_directories` function to allow our main
    project to detect all header files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此 CMake 脚本文件定义了一个 `UTILS_LIB_SRC` 变量，我们将所有包含在我们的库中的源文件添加到其中，使用 `add_library`
    函数生成库，并使用 `target_include_directories` 函数允许我们的主项目检测所有头文件。
- en: Leaving out the `utils` subfolder and continuing with the root `cmake` script,
    the Option function creates a new variable—in our case, `WITH_LOG`, with a small
    description attached. This variable can be changed via the `ccmake` command line
    or CMake GUI interface, where the description and a checkbox appears that allow
    users to enable or disable this option.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过 `utils` 子文件夹，继续使用根 `cmake` 脚本，`Option` 函数创建了一个新变量——在我们的例子中是 `WITH_LOG`，并附有简短描述。此变量可以通过
    `ccmake` 命令行或 CMake GUI 界面进行更改，其中描述和一个复选框出现，允许用户启用或禁用此选项。
- en: This function is very useful and allows the user to decide about compile-time
    features such as enabling or disabling logs, compiling with Java or Python support
    as with OpenCV, and so on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数非常有用，允许用户决定编译时特性，如启用或禁用日志、编译带有 Java 或 Python 支持（如 OpenCV）等。
- en: 'In our case, we use this option to enable a logger in our application. To enable
    the logger, we use a precompiler definition in our code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用此选项在应用程序中启用日志记录器。要启用日志记录器，我们在代码中使用预编译定义：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To tell our compiler that we require the `LOG` compile time definition, we
    use the `add_definitions(-DLOG)` function in our `CMakeLists.txt`. To allow the
    user to decide whether they want to enable it or not, we only have to verify whether
    the `WITH_LOG` CMake variable is checked or not with a simple condition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉我们的编译器我们需要 `LOG` 编译时定义，我们在 `CMakeLists.txt` 中使用 `add_definitions(-DLOG)`
    函数。为了允许用户决定是否启用它，我们只需通过一个简单条件验证 `WITH_LOG` CMake 变量是否被选中：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we are ready to create our CMake script files to be compiled in any operating
    system our Computer Vision projects. Then, we will continue with the OpenCV basics
    before we start with a sample project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建我们的CMake脚本文件，以便在任何操作系统上编译我们的计算机视觉项目。然后，在开始一个示例项目之前，我们将继续介绍OpenCV的基础知识。
- en: Images and matrices
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像和矩阵
- en: The most important structure in a Computer Vision is without any doubt the images.
    The image in Computer Vision is a representation of the physical world captured
    with a digital device. This picture is only a sequence of numbers stored in a
    matrix format, as shown in the following image. Each number is a measurement of
    the light intensity for the considered wavelength (for example, red, green, or
    blue in color images) or for a wavelength range (for panchromatic devices). Each
    point in an image is called a pixel (for a picture element), and each pixel can
    store one or more values depending on whether it is a gray, black, or white image
    (called a binary image as well) that stores only one value, such as 0 or 1, a
    gray-scale-level image that can store only one value, or a color image that can
    store three values. These values are usually integer numbers between 0 and 255,
    but you can use the other range. For example, 0 to 1 in a floating point numbers
    such as **HDRI** (**High Dynamic Range Imaging**) or thermal images.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉中，最重要的结构无疑是图像。计算机视觉中的图像是使用数字设备捕获的物理世界的表示。这幅图只是存储在矩阵格式中的数字序列，如下所示。每个数字是考虑的波长的光强度测量（例如，在彩色图像中的红色、绿色或蓝色）或波长范围（对于全色设备）。图像中的每个点称为像素（对于图像元素），每个像素可以存储一个或多个值，具体取决于它是一个灰度、黑色还是白色图像（也称为二值图像，只存储一个值，如0或1），一个只能存储一个值的灰度级图像，或者一个可以存储三个值的彩色图像。这些值通常是介于0到255之间的整数，但您也可以使用其他范围。例如，**HDRI**（**高动态范围成像**）或热图像中使用的浮点数0到1。
- en: '![Images and matrices](img/B04283_02_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图像和矩阵](img/B04283_02_01.jpg)'
- en: 'The image is stored in a matrix format, where each pixel has a position in
    it and can be referenced by the number of the column and row. OpenCV uses the
    `Mat` class for this purpose. In the case of a grayscale image, a single matrix
    is used, as shown in the following figure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图像以矩阵格式存储，其中每个像素都有一个位置，可以通过列和行的编号来引用。OpenCV使用`Mat`类来完成这个目的。对于灰度图像，使用单个矩阵，如下图所示：
- en: '![Images and matrices](img/B04283_02_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图像和矩阵](img/B04283_02_02.jpg)'
- en: 'In the case of a color image, as shown in the following image, we use a matrix
    of size width x height x number of colors:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在彩色图像的情况下，如下图中所示，我们使用一个大小为宽度 x 高度 x 颜色数量的矩阵：
- en: '![Images and matrices](img/B04283_02_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图像和矩阵](img/B04283_02_03.jpg)'
- en: The `Mat` class is not only used to store images, but also to store different
    types of arbitrarily sized matrices. You can use is it as an algebraic matrix
    and perform operations with it. In the next section, we are going to describe
    the most important matrix operations such as add, matrix multiplication, create
    a diagonal matrix, and so on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat`类不仅用于存储图像，还用于存储不同类型的不定大小矩阵。您可以用它作为代数矩阵并对其进行操作。在下一节中，我们将描述最重要的矩阵操作，如加法、矩阵乘法、创建对角矩阵等。'
- en: However, before that, it's important to know how the matrix is stored internally
    in the computer memory because it is always better to have efficient access to
    the memory slots instead of access to each pixel with the OpenCV functions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这样做之前，了解矩阵在计算机内存中的内部存储方式是很重要的，因为始终更有效地访问内存槽而不是使用OpenCV函数访问每个像素会更好。
- en: 'In memory, the matrix is saved as an array or sequence of values ordered by
    columns and rows. The following table shows the sequence of pixels in the BGR
    image format:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，矩阵以列和行的顺序保存为一个数组或值序列。以下表格显示了BGR图像格式中像素的顺序：
- en: '| Row 0 | Row 1 | Row 2 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 行 0 | 行 1 | 行 2 |'
- en: '| --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Col 0 | Col 1 | Col 2 | Col 0 | Col 1 | Col 2 | Col 0 | Col 1 | Col 2 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 列 0 | 列 1 | 列 2 | 列 0 | 列 1 | 列 2 | 列 0 | 列 1 | 列 2 |'
- en: '| Pixel 1 | Pixel 2 | Pixel 3 | Pixel 4 | Pixel 5 | Pixel 6 | Pixel 7 | Pixel
    8 | Pixel 9 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 像素 1 | 像素 2 | 像素 3 | 像素 4 | 像素 5 | 像素 6 | 像素 7 | 像素 8 | 像素 9 |'
- en: '| B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B
    | G | R | B | G | R | B | G | R |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B | G | R | B
    | G | R | B | G | R | B | G | R |'
- en: 'With this order, we can access any pixel, as shown in the following formula:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个顺序，我们可以访问任何像素，如下面的公式所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OpenCV functions are quite optimized for random access, but sometimes direct
    access to the memory (working with pointer arithmetic) is more efficient—for example,
    when we have access to all the pixels in a loop.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV函数在随机访问方面进行了相当优化，但有时直接访问内存（使用指针算术）更有效率——例如，当我们在一个循环中访问所有像素时。
- en: Reading/writing images
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取/写入图像
- en: 'After the introduction of this matrix, we are going to start with the basics
    of the OpenCV code. Firstly, we need to learn how to read and write images:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍这个矩阵之后，我们将开始介绍OpenCV代码的基础。首先，我们需要学习如何读取和写入图像：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s try to understand this code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解这段代码：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we have to include the declarations of the functions that we need in
    our sample. These functions come from core (basic image data handling) and high-gui
    (the cross-platform I/O functions provided by OpenCV are `core` and `highui`.
    The first includes the basic classes, such as matrices, and the second includes
    the functions to read, write, and show images with graphical interfaces).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在我们的示例中包含所需函数的声明。这些函数来自核心（基本图像数据处理）和高GUI（OpenCV提供的跨平台I/O函数是`core`和`highui`。第一个包括基本类，如矩阵，第二个包括读取、写入和通过图形界面显示图像的函数）。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The **imread** is the main function used to read images. This function opens
    an image and stores the image in a matrix format. The `imread` function accepts
    two parameters: the first parameter is a string that contains the image''s path,
    and the second parameter is optional and, by default, loads the image as a color
    image. The second parameter allows the following options:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**imread**是用于读取图像的主要函数。此函数打开图像并将图像存储在矩阵格式中。`imread`函数接受两个参数：第一个参数是一个包含图像路径的字符串，第二个参数是可选的，默认情况下以彩色图像加载图像。第二个参数允许以下选项：'
- en: '`CV_LOAD_IMAGE_ANYDEPTH`: If set to this constant, returns a 16-bit/32-bit
    image when the input has the corresponding depth; otherwise, the `imread` function
    converts it to an 8-bit image'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_LOAD_IMAGE_ANYDEPTH`：如果设置为这个常量，当输入具有相应的深度时返回16位/32位图像；否则，`imread`函数将其转换为8位图像'
- en: '`CV_LOAD_IMAGE_COLOR`: If set to this constant, always converts the image to
    color'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_LOAD_IMAGE_COLOR`：如果设置为这个常量，总是将图像转换为彩色'
- en: '`CV_LOAD_IMAGE_GRAYSCALE`: If set to this constant, always converts the image
    to grayscale'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_LOAD_IMAGE_GRAYSCALE`：如果设置为这个常量，总是将图像转换为灰度'
- en: 'To save images, we can use the `imwrite` function, which stores a matrix image
    in our computer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存图像，我们可以使用`imwrite`函数，该函数将矩阵图像存储在我们的计算机中：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first parameter is the path where we want to save the image with the extension
    format that we desire. The second parameter is the matrix image that we want to
    save. In our code sample, we create and store a gray version of the image and
    then save it as a jpg file the gray image that we loaded and store in `gray` variable:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们想要保存图像的路径，其中包含我们想要的扩展格式。第二个参数是我们想要保存的矩阵图像。在我们的代码示例中，我们创建并存储图像的灰度版本，然后将其保存为jpg文件，该灰度图像是我们加载并存储在`gray`变量中的图像：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the `.cols` and `.rows` attributes of a matrix, we can access the number
    of columns and rows of an image—or in other words, the width and height:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵的`.cols`和`.rows`属性，我们可以访问图像的列数和行数——换句话说，宽度和高度：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To access one pixel of an image, we use the `cv::Mat::at<typename t>(row,col)`
    template function from the `Mat` OpenCV class. The template parameter is the desired
    return type. A `typename` in an 8-bit color image is a `Vec3b` class that stores
    three unsigned char data (Vec=vector, 3=number of components, and b = 1 byte).
    In the case of the gray image, we can directly use the unsigned char or any other
    number format used in the image, such as `uchar pixel= color.at<uchar>(myRow,
    myCol)`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问图像中的一个像素，我们使用`cv::Mat::at<typename t>(row,col)`模板函数，该函数来自`Mat` OpenCV类。模板参数是期望的返回类型。在8位彩色图像中，`typename`是一个存储三个无符号字符数据的`Vec3b`类（Vec=vector，3=组件数量，b
    = 1字节）。对于灰度图像，我们可以直接使用无符号字符或任何其他在图像中使用的数字格式，例如`uchar pixel= color.at<uchar>(myRow,
    myCol)`：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, to show the images, we can use the `imshow` function that creates a
    window with a title as the first parameter and the image matrix as the second
    parameter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了显示图像，我们可以使用`imshow`函数，该函数创建一个窗口，第一个参数是标题，第二个参数是图像矩阵。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we want to stop our application by waiting for the user to press a key, we
    can use the OpenCV `waitKey` function with a parameter set to the number of milliseconds
    we want to wait. If we set the parameter to `0`, then the function will wait forever.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过等待用户按键来停止我们的应用程序，我们可以使用OpenCV的`waitKey`函数，并将参数设置为我们要等待的毫秒数。如果我们设置参数为`0`，那么函数将永远等待。
- en: 'The result of this code is shown in the following picture; the left-hand image
    is a color image and right-hand image is a gray scale:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了此代码的结果；左侧图像是彩色图像，右侧图像是灰度图像：
- en: '![Reading/writing images](img/B04283_02_04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![读取/写入图像](img/B04283_02_04.jpg)'
- en: Finally, as an example for the following samples, we are going to create the
    `CMakeLists.txt` to allow you to compile our project and also see how to compile
    it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为以下示例的例子，我们将创建`CMakeLists.txt`以允许您编译我们的项目，并了解如何编译它。
- en: 'The following code describes the `CMakeLists.txt` file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了`CMakeLists.txt`文件：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To compile our code, using the `CMakeLists.txt` file we have to perform the
    following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译我们的代码，使用`CMakeLists.txt`文件，我们必须执行以下步骤：
- en: Create a `build` folder.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`build`文件夹。
- en: Inside the `build` folder, execute `cmake` or open the `CMake gui` app in Windows,
    choose the source folder and build folder, and click on the Configure and Generate
    buttons.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build`文件夹内，执行`cmake`或在Windows中打开`CMake gui`应用程序，选择源文件夹和构建文件夹，然后点击配置和生成按钮。
- en: After step 2, if we are in Linux or OS, generate a `makefile`; then we have
    to compile the project using the make command. If we are in Windows, we have to
    open the project with the editor that we selected in step 2 and compile it.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤2之后，如果我们处于Linux或OS，生成一个`makefile`；然后我们必须使用make命令编译项目。如果我们处于Windows，我们必须使用步骤2中选择的编辑器打开项目并编译它。
- en: After step 3, we have an executable called `app`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤3之后，我们有一个名为`app`的可执行文件。
- en: Reading videos and cameras
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取视频和摄像头
- en: 'This section introduces you to reading a video and camera with this simple
    example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过这个简单的示例向您介绍如何读取视频和摄像头：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we explain how to read video or camera inputs, we need to introduce
    a useful new class that will help us manage the input command line parameters;
    this new class was introduced in OpenCV version 3.0 and is called the `CommandLineParser`
    class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释如何读取视频或摄像头输入之前，我们需要介绍一个有用的新类，它将帮助我们管理输入命令行参数；这个新类是在OpenCV 3.0版本中引入的，称为`CommandLineParser`类：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first thing that we have to do for a command-line parser is define the
    parameters that we need or allow in a constant char vector; each line has this
    pattern:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令行解析器，我们必须首先在常量字符向量中定义我们需要的或允许的参数；每一行都有这种模式：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `name_param` can be preceded with `@`, which defines this parameter as
    a default input. We can use more than one `name_param`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_param`可以前面加上`@`，这定义了这个参数为默认输入。我们可以使用多个`name_param`：'
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The constructor will get the inputs of the main function and the key constants
    defined previously:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将获取主函数的输入和之前定义的关键常量：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `.has` class method checks the parameter''s existence. In this sample,
    we check whether the user has added the `–help` or ? `parameter`, and then, use
    the `printMessage` class function to show all the description parameters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`.has`类方法检查参数是否存在。在这个示例中，我们检查用户是否添加了`–help`或? `参数`，然后，使用`printMessage`类函数显示所有描述参数：'
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With the `.get<typename>(parameterName)` function, we can access and read any
    of the input parameters:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.get<typename>(parameterName)`函数，我们可以访问和读取任何输入参数：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After getting all the required parameters, we can check whether these parameters
    are parsed correctly and show an error message if one of the parameters is not
    parsed. For example, add a string instead of a number:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取所有必需的参数后，我们可以检查这些参数是否正确解析，如果其中一个参数没有解析，则显示错误消息。例如，添加一个字符串而不是一个数字：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The class to read a video and camera is the same. The `VideoCapture` class belongs
    to the `videoio` submodel instead of the `highgui` submodule, as in the former
    version of OpenCV. After creating the object, we check whether the input command
    line `videoFile` parameter has a path filename. If it's empty, then we try to
    open a web camera and, if it has a filename, then we open the video file. To do
    this, we use the open function, giving the video filename or the index camera
    that we want to open as a parameter. If we have a single camera, we can use `0`
    as a parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 读取视频和摄像头的类是相同的。`VideoCapture` 类属于 `videoio` 子模型，而不是 `highgui` 子模块，如 OpenCV 的早期版本。创建对象后，我们检查输入命令行
    `videoFile` 参数是否有路径文件名。如果为空，则尝试打开网络摄像头；如果有文件名，则打开视频文件。为此，我们使用 open 函数，将视频文件名或要打开的摄像头索引作为参数。如果我们只有一个摄像头，我们可以使用
    `0` 作为参数。
- en: 'To check whether we can read the video filename or the camera, we use the `isOpened`
    function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们是否可以读取视频文件名或摄像头，我们使用 `isOpened` 函数：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we create a window to show the frames with the `namedWindow` function
    and, with a non-finish loop, we grab each frame with the `>>` operation and show
    the image with the `imshow` function, if we correctly retrieve the frame. In this
    case, we don't want to stop the application, but we want to wait for 30 milliseconds
    to check whether users want to stop the application execution with any key using
    `waitKey(30)`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `namedWindow` 函数创建一个窗口来显示帧，并通过非结束循环，使用 `>>` 操作符抓取每一帧，如果正确检索到帧，则使用 `imshow`
    函数显示图像。在这种情况下，我们不想停止应用程序，但想等待 30 毫秒，以检查用户是否想通过按任意键停止应用程序执行，使用 `waitKey(30)`。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To choose a good value to wait for the next frame, using a camera access is
    calculated from the speed of the camera. For example, if a camera works at 20
    FPS, a great wait value is *40 = 1000/20*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择一个合适的值等待下一帧，使用摄像头访问速度计算。例如，如果摄像头以 20 FPS 的工作，一个很好的等待值是 *40 = 1000/20*。
- en: When the user wants to finish the app, he has to only press a key, and then
    we have to release all the video resources using the `release` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要结束应用程序时，他只需要按下一个键，然后我们必须使用 `release` 函数释放所有视频资源。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is very important to release all the resources that we use in a Computer
    Vision application; if we do not do it, we can consume all the RAM memory. We
    can release the matrices with the `release` function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机视觉应用程序中释放我们使用的所有资源非常重要；如果我们不这样做，我们可能会消耗所有 RAM 内存。我们可以使用 `release` 函数释放矩阵。
- en: 'The result of the code is a new window that shows a video or web camera in
    the BGR format, as shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结果是一个新窗口，显示 BGR 格式的视频或网络摄像头，如下截图所示：
- en: '![Reading videos and cameras](img/B04283_02_05.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![读取视频和摄像头](img/B04283_02_05.jpg)'
- en: Other basic object types
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他基本对象类型
- en: We have learned about the Mat and Vec3b classes, but we need to learn about
    other classes as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了 `Mat` 和 `Vec3b` 类，但我们需要学习其他类。
- en: 'In this section, we will learn about the most basic object types required in
    most of the projects:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在大多数项目中都需要的最基本的对象类型：
- en: '`Vec`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vec`'
- en: '`Scalar`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scalar`'
- en: '`Point`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Point`'
- en: '`Size`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size`'
- en: '`Rect`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rect`'
- en: '`RotatedRect`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RotatedRect`'
- en: The vec object type
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`vec` 对象类型'
- en: '`vec` is a template class that is used mainly for numerical vectors. We can
    define any type of vectors and a number of components:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec` 是一个模板类，主要用于数值向量。我们可以定义任何类型的向量以及组件数量：'
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or we can use any of the predefined types:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用任何预定义的类型：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'All the expected vector operations are also implemented, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有预期的向量操作也都已实现，如下所示：
- en: '`v1 = v2 + v3`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = v2 + v3`'
- en: '`v1 = v2 - v3`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = v2 - v3`'
- en: '`v1 = v2 * scale`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = v2 * scale`'
- en: '`v1 = scale * v2`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = scale * v2`'
- en: '`v1 = -v2`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 = -v2`'
- en: '`v1 += v2` and other augmenting operations'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 += v2` 和其他增加操作'
- en: '`v1 == v2, v1 != v2`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1 == v2, v1 != v2`'
- en: '`norm(v1) (euclidean norm)`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`norm(v1) (欧几里得范数)`'
- en: The Scalar object type
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标量对象类型
- en: The `Scalar` object type is a template class derived from Vec with four elements.
    The `Scalar` type is widely used in OpenCV to pass and read pixel values.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scalar` 对象类型是从 `Vec` 派生出的模板类，具有四个元素。`Scalar` 类型在 OpenCV 中广泛用于传递和读取像素值。'
- en: To access the values of `Vec` and `Scalar`, we use the [] operator.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `Vec` 和 `Scalar` 的值，我们使用 [] 操作符。
- en: The Point object type
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点对象类型
- en: Another very common class template is `Point`. This class defines a 2D point
    specified by its `x` and `y` coordinates.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的类模板是 `Point`。这个类定义了一个由其 `x` 和 `y` 坐标指定的 2D 点。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like the Point object type, there is a Point3 template class for 3D point support.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Point 对象类型类似，还有一个 Point3 模板类用于支持 3D 点。
- en: 'Like the `Vec` class, OpenCV defines the following `Point` aliases for our
    convenience:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Vec` 类类似，OpenCV 定义了以下 `Point` 别名以方便我们使用：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following operators are defined for points:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为点定义了以下运算符：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Size object type
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Size 对象类型
- en: 'Another `template` class that is very important and used in OpenCV is the `template`
    class used to specify the size of an image or rectangle, Size. This class adds
    two members: the width and height and a useful `area()`function.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在 OpenCV 中非常重要且常用的 `template` 类是用于指定图像或矩形大小的 `Size` 类。该类添加了两个成员：宽度和高度以及有用的
    `area()` 函数。
- en: The Rect object type
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rect 对象类型
- en: '`Rect` is another important template class used to define 2D rectangles by
    the following parameters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect` 是另一个重要的模板类，用于通过以下参数定义 2D 矩形：'
- en: The coordinates of the top-left corner
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶左角坐标
- en: The width and height of a rectangle
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形的宽度和高度
- en: The `Rect` template class can be used to define a **ROI** (**region of interest**)
    of an image.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rect` 模板类可用于定义图像的 **ROI**（**感兴趣区域**）。'
- en: RotatedRect object type
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RotatedRect 对象类型
- en: 'The last useful class is a particular rectangle called `RotatedRect`. This
    class represents a rotated rectangle specified by a center point, the width and
    height of a rectangle, and the rotation angle in degrees:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有用的类是特定矩形 `RotatedRect`。该类表示一个由中心点、矩形的宽度和高度以及旋转角度（以度为单位）指定的旋转矩形：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An interesting function of this class is `boundingBox`; this function returns
    a `Rect` that contains the rotated rectangle:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的一个有趣功能是 `boundingBox`；此函数返回一个包含旋转矩形的 `Rect`：
- en: '![RotatedRect object type](img/B04283_02_06.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![RotatedRect 对象类型](img/B04283_02_06.jpg)'
- en: Basic matrix operations
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本矩阵运算
- en: In this section, we will learn some basic and important matrix operations that
    we can apply to images or any matrix data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一些基本且重要的矩阵运算，这些运算可以应用于图像或任何矩阵数据。
- en: 'We learned how to load an image and store it in a `Mat` variable, but we can
    manually create a Mat variable. The most common constructor that provides the
    matrix size and type is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何加载图像并将其存储在 `Mat` 变量中，但我们可以手动创建一个 `Mat` 变量。最常见的构造函数是提供矩阵大小和类型的如下：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can create a new `Matrix link` with a stored buffer from third-party libraries,
    without copying the data, using the following constructor:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下构造函数从第三方库的存储缓冲区创建一个新的 `Matrix link`，而不复制数据：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The supported types depend on the type of the number you want to store and
    the number of channels. The most common types are as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的类型取决于您想要存储的数字类型和通道数。最常见的类型如下：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can create any type of a matrix using `CV_number_typeC(n)`, where `number_type`
    is 8U (8 bits unsigned) to 64F (64 float) and (n) is the number of channels. The
    number of channels allowed is from `1` to `CV_CN_MAX`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `CV_number_typeC(n)` 创建任何类型的矩阵，其中 `number_type` 是 8U（8 位无符号）到 64F（64 位浮点）之间，而
    (n) 是通道数。允许的通道数从 `1` 到 `CV_CN_MAX`。
- en: 'This initialization does not set up the data values and you can get undesirable
    values. To avoid undesirable values, you can initialize the matrix with `zeros`
    or `ones` values with the `zeros` or `ones` function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此初始化没有设置数据值，您可能会得到不希望的结果。为了避免不希望的结果，您可以使用 `zeros` 或 `ones` 函数用 `zeros` 或 `ones`
    值初始化矩阵：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of the preceding matrix is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前矩阵的输出如下：
- en: '![Basic matrix operations](img/B04283_02_07.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![基本矩阵运算](img/B04283_02_07.jpg)'
- en: 'A special matrix initialization is the **eye** function that creates an `identity`
    matrix with the specified type (`CV_8UC1, CV_8UC3…`) and size:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的矩阵初始化是 **eye** 函数，该函数创建一个指定类型（`CV_8UC1, CV_8UC3...`）和大小的 `identity` 矩阵：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Basic matrix operations](img/B04283_02_08.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![基本矩阵运算](img/B04283_02_08.jpg)'
- en: 'All matrix operations are allowed in the OpenCV Mat class. We can add or subtract
    two matrices with `+` and `-` operators:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV Mat 类允许所有矩阵运算。我们可以使用 `+` 和 `-` 运算符添加或减去两个矩阵：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The results of the previous operations are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之前操作的结果如下：
- en: '![Basic matrix operations](img/B04283_02_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![基本矩阵运算](img/B04283_02_09.jpg)'
- en: 'We can multiply a matrix by a scalar with the `*` operator, a matrix per element
    matrix with the `mul` function, or a matrix by matrix multiplication with `*`
    operator:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `*` 运算符将矩阵乘以一个标量，使用 `mul` 函数将矩阵乘以每个元素，或者使用 `*` 运算符进行矩阵与矩阵的乘法：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The results of the previous operations are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 之前操作的结果如下：
- en: '![Basic matrix operations](img/B04283_02_10.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![基本矩阵运算](img/B04283_02_10.jpg)'
- en: The other common mathematical matrix operations are transposition and matrix
    inversion, defined by the `t()` and `inv()` functions, respectively.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另外常见的数学矩阵运算包括转置和矩阵求逆，分别由`t()`和`inv()`函数定义。
- en: 'Other interesting functions that OpenCV provides us with are array operations
    in a matrix; for example, count the non-zero elements. This is useful to count
    the pixels or area of an object:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV为我们提供的其他有趣的功能是矩阵中的数组操作；例如，计算非零元素的数量。这有助于计算对象的像素或面积：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'OpenCV provides some statistical functions. The mean and standard deviation
    by channel can be calculated using the `meanStdDev` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一些统计函数。可以使用`meanStdDev`函数计算每个通道的平均值和标准差：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The other useful statistical function is `minMaxLoc`. This function finds the
    minimum and the maximum of a matrix or array and returns its location and value:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的统计函数是`minMaxLoc`。此函数查找矩阵或数组的最小值和最大值，并返回其位置和值：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `src` is the input matrix, `minVal` and `maxVal` are double values detected,
    and `minLoc` and `maxLoc` are point values detected.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`src`是输入矩阵，`minVal`和`maxVal`是检测到的双精度值，而`minLoc`和`maxLoc`是检测到的点值。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other core and useful functions are described in detail at [http://docs.opencv.org/modules/core/doc/core.html](http://docs.opencv.org/modules/core/doc/core.html).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 其他核心和有用的函数在[http://docs.opencv.org/modules/core/doc/core.html](http://docs.opencv.org/modules/core/doc/core.html)中详细描述。
- en: Basic data persistence and storage
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据持久化和存储
- en: Before we finish this chapter, we will explore the OpenCV functions to store
    and read our data. In many applications, such as calibration or machine learning,
    when we are done with the calculations, we need to save the results in order to
    retrieve them in the next executions. For this purpose, OpenCV provides an XML/YAML
    persistence layer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，我们将探索OpenCV的存储和读取数据的功能。在许多应用程序中，例如校准或机器学习，当我们完成计算后，我们需要保存结果以便在下次执行中检索。为此，OpenCV提供了一个XML/YAML持久化层。
- en: Writing to a file storage
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入文件存储
- en: 'To write a file with some OpenCV data or other numeric data, we can use the
    `FileStorage` class using the streaming c operator such as STL streaming:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一些OpenCV数据或其他数值数据写入文件，我们可以使用`FileStorage`类，并使用如STL流之类的流操作符：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To create a file storage where we save the data, we only need to call the constructor
    by giving a path filename with the desired extension format (XML or YAML) with
    the second parameter set to `write`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个用于保存数据的文件存储，我们只需要通过提供一个带有所需扩展格式（XML或YAML）的路径文件名并设置第二个参数为`write`来调用构造函数：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we want to save the data, we only need to use the stream operator by giving
    an identifier in the first stage and the matrix or value that we want to save
    in the later stage. For example, to save an `int`, we need to write the following
    code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要保存数据，我们只需要使用流操作符，在第一阶段提供一个标识符，在后续阶段提供我们想要保存的矩阵或值。例如，要保存一个`int`，我们需要编写以下代码：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A `mat` is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`mat`如下：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result of the preceding code is in YAML format, which is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果是YAML格式，如下所示：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Reading from a saved file previously is very similar to save functions:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前保存的文件中读取与保存函数非常相似：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, we have to open a saved file with the `FileStorage` constructor using
    the appropriate path and `FileStorage::READ` parameters:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用`FileStorage`构造函数和适当的路径以及`FileStorage::READ`参数来打开一个已保存的文件：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To read any stored variable, we only need to use the common `>>` stream operator
    using our `FileStorage` object and the identifier with the `[]` operator:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取任何已存储的变量，我们只需要使用我们的`FileStorage`对象和带有`[]`操作符的标识符的常见`>>`流操作符：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basics of how to access images and videos and
    how they are stored in matrices.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何访问图像和视频以及它们如何在矩阵中存储的基础知识。
- en: We learned the basic matrix operations and other basic OpenCV classes to store
    pixels, vectors, and so on.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了基本的矩阵运算和其他基本的OpenCV类，用于存储像素、向量等。
- en: Finally, we learned how to save our data in files to allow them to be read in
    other applications or executions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何将数据保存到文件中，以便在其他应用程序或执行中读取。
- en: In the next chapter, we will learn how to create our first application by learning
    the basics of a Graphical User Interface that OpenCV gives us. We will create
    buttons and sliders and introduce some image processing basics.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过学习OpenCV提供的图形用户界面的基础知识来创建我们的第一个应用程序。我们将创建按钮和滑块，并介绍一些图像处理的基本知识。
