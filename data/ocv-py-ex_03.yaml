- en: Chapter 3. Cartoonizing an Image
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：图像卡通化
- en: In this chapter, we are going to learn how to convert an image into a cartoon-like
    image. We will learn how to access the webcam and take keyboard/mouse inputs during
    a live video stream. We will also learn about some advanced image filters and
    see how we can use them to cartoonize an image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将图像转换为卡通风格的图像。我们将学习如何在实时视频流中访问网络摄像头和获取键盘/鼠标输入。我们还将了解一些高级图像过滤器，并了解我们如何使用它们来卡通化图像。
- en: 'By the end of this chapter, you will know:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将知道：
- en: How to access the webcam
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问网络摄像头
- en: How to take keyboard and mouse inputs during a live video stream
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在实时视频流中获取键盘和鼠标输入
- en: How to create an interactive application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建交互式应用程序
- en: How to use advanced image filters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用高级图像过滤器
- en: How to cartoonize an image
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何卡通化图像
- en: Accessing the webcam
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问网络摄像头
- en: We can build very interesting applications using the live video stream from
    the webcam. OpenCV provides a video capture object which handles everything related
    to opening and closing of the webcam. All we need to do is create that object
    and keep reading frames from it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用网络摄像头的实时视频流构建非常有趣的应用程序。OpenCV 提供了一个视频捕获对象，它处理与打开和关闭网络摄像头相关的所有事情。我们所需做的只是创建该对象，并从中读取帧。
- en: The following code will open the webcam, capture the frames, scale them down
    by a factor of 2, and then display them in a window. You can press the *Esc* key
    to exit.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打开网络摄像头，捕获帧，将它们按 2 倍因子缩小，然后在窗口中显示。您可以按 *Esc* 键退出。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Under the hood
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部机制
- en: 'As we can see in the preceding code, we use OpenCV''s `VideoCapture` function
    to create the video capture object cap. Once it''s created, we start an infinite
    loop and keep reading frames from the webcam until we encounter a keyboard interrupt.
    In the first line within the while loop, we have the following line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们使用 OpenCV 的 `VideoCapture` 函数创建视频捕获对象 cap。一旦创建，我们就启动一个无限循环，并从网络摄像头读取帧，直到遇到键盘中断。在
    while 循环内的第一行，我们有以下行：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, `ret` is a Boolean value returned by the `read` function, and it indicates
    whether or not the frame was captured successfully. If the frame is captured correctly,
    it''s stored in the variable `frame`. This loop will keep running until we press
    the *Esc* key. So we keep checking for a keyboard interrupt in the following line:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ret` 是由 `read` 函数返回的布尔值，它表示帧是否成功捕获。如果帧被正确捕获，它将存储在变量 `frame` 中。这个循环将一直运行，直到我们按下
    *Esc* 键。因此，我们在以下行中持续检查键盘中断：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we know, the ASCII value of *Esc* is 27\. Once we encounter it, we break
    the loop and release the video capture object. The line `cap.release()` is important
    because it gracefully closes the webcam.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，*Esc* 的 ASCII 值为 27。一旦遇到它，我们就中断循环并释放视频捕获对象。`cap.release()` 这一行很重要，因为它优雅地关闭了网络摄像头。
- en: Keyboard inputs
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键盘输入
- en: Now that we know how to capture a live video stream from the webcam, let's see
    how to use the keyboard to interact with the window displaying the video stream.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从网络摄像头捕获实时视频流，让我们看看如何使用键盘与显示视频流的窗口进行交互。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Interacting with the application
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与应用程序交互
- en: This program will display the input video stream and wait for the keyboard input
    to change the color space. If you run the previous program, you will see the window
    displaying the input video stream from the webcam. If you press *G*, you will
    see that the color space of the input stream gets converted to grayscale. If you
    press *Y*, the input stream will be converted to YUV color space. Similarly, if
    you press *H*, you will see the image being converted to HSV color space.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将显示输入的视频流并等待键盘输入以更改颜色空间。如果您运行上一个程序，您将看到显示来自网络摄像头的输入视频流的窗口。如果您按下 *G*，您将看到输入流的颜色空间被转换为灰度。如果您按下
    *Y*，输入流将被转换为 YUV 颜色空间。同样，如果您按下 *H*，您将看到图像被转换为 HSV 颜色空间。
- en: As we know, we use the function `waitKey()` to listen to the keyboard events.
    As and when we encounter different keystrokes, we take appropriate actions. The
    reason we are using the function `ord()` is because `waitKey()` returns the ASCII
    value of the keyboard input; thus, we need to convert the characters into their
    ASCII form before checking their values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们使用 `waitKey()` 函数来监听键盘事件。每当遇到不同的按键时，我们采取适当的行动。我们使用 `ord()` 函数的原因是 `waitKey()`
    返回键盘输入的 ASCII 值；因此，在检查它们的值之前，我们需要将字符转换为它们的 ASCII 形式。
- en: Mouse inputs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标输入
- en: In this section, we will see how to use the mouse to interact with the display
    window. Let's start with something simple. We will write a program that will detect
    the quadrant in which the mouse click was detected. Once we detect it, we will
    highlight that quadrant.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用鼠标与显示窗口进行交互。让我们从简单的事情开始。我们将编写一个程序，该程序将检测鼠标点击发生的位置象限。一旦检测到，我们将突出显示该象限。
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will look something like the following image:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下图像：
- en: '![Mouse inputs](img/B04554_03_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![鼠标输入](img/B04554_03_01.jpg)'
- en: What's happening underneath?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'Let''s start with the main function in this program. We create a white image
    on which we are going to click using the mouse. We then create a named window
    and bind the mouse callback function to this window. Mouse callback function is
    basically the function that will be called when a mouse event is detected. There
    are many kinds of mouse events such as clicking, double-clicking, dragging, and
    so on. In our case, we just want to detect a mouse click. In the function `detect_quadrant`,
    we check the first input argument event to see what action was performed. OpenCV
    provides a set of predefined events, and we can call them using specific keywords.
    If you want to see a list of all the mouse events, you can go to the Python shell
    and type the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从程序中的主函数开始。我们创建一个白色图像，我们将使用鼠标点击该图像。然后我们创建一个命名窗口，并将鼠标回调函数绑定到该窗口。鼠标回调函数基本上是在检测到鼠标事件时将被调用的函数。有许多种鼠标事件，如点击、双击、拖动等。在我们的情况下，我们只想检测鼠标点击。在函数`detect_quadrant`中，我们检查第一个输入参数`event`以查看执行了什么操作。OpenCV提供了一套预定义的事件，我们可以使用特定的关键字来调用它们。如果您想查看所有鼠标事件的列表，您可以在Python
    shell中输入以下内容：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second and third arguments in the function `detect_quadrant` provide the
    X and Y coordinates of the mouse click event. Once we know these coordinates,
    it's pretty straightforward to determine what quadrant it's in. With this information,
    we just go ahead and draw a rectangle with the specified color, using `cv2.rectangle()`.
    This is a very handy function that takes the top left point and the bottom right
    point to draw a rectangle on an image with the specified color.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`detect_quadrant`中的第二个和第三个参数提供了鼠标点击事件的X和Y坐标。一旦我们知道这些坐标，确定它所在的象限就非常直接了。有了这些信息，我们只需使用`cv2.rectangle()`函数绘制一个指定颜色的矩形。这是一个非常方便的函数，它接受左上角点和右下角点，在图像上绘制一个指定颜色的矩形。
- en: Interacting with a live video stream
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与实时视频流交互
- en: 'Let''s see how we can use the mouse to interact with live video stream from
    the webcam. We can use the mouse to select a region and then apply the "negative
    film" effect on that region, as shown next:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用鼠标与来自摄像头的实时视频流进行交互。我们可以使用鼠标选择一个区域，然后在该区域应用“负片”效果，如下所示：
- en: '![Interacting with a live video stream](img/B04554_03_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![与实时视频流交互](img/B04554_03_02.jpg)'
- en: 'In the following program, we will capture the video stream from the webcam,
    select a region of interest with the mouse, and then apply the effect:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下程序中，我们将从摄像头捕获视频流，使用鼠标选择感兴趣的区域，然后应用效果：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you run the preceding program, you will see a window displaying the video
    stream. You can just draw a rectangle on the window using your mouse and you will
    see that region being converted to its "negative".
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的程序，您将看到一个显示视频流的窗口。您只需使用鼠标在窗口上画一个矩形，您将看到该区域被转换为它的“负值”。
- en: How did we do it?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们是如何做到的？
- en: 'As we can see in the main function of the program, we initialize a video capture
    object. We then bind the function `draw_rectangle` with the mouse callback in
    the following line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在程序的主函数中看到的，我们初始化了一个视频捕获对象。然后我们在以下行中将函数`draw_rectangle`与鼠标回调绑定：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then start an infinite loop and start capturing the video stream. Let''s
    see what is happening in the function `draw_rectangle`. Whenever we draw a rectangle
    using the mouse, we basically have to detect three types of mouse events: mouse
    click, mouse movement, and mouse button release. This is exactly what we do in
    this function. Whenever we detect a mouse click event, we initialize the top left
    point of the rectangle. As we move the mouse, we select the region of interest
    by keeping the current position as the bottom right point of the rectangle.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后启动一个无限循环并开始捕获视频流。让我们看看函数`draw_rectangle`中发生了什么。每次我们使用鼠标绘制矩形时，我们基本上必须检测三种类型的鼠标事件：鼠标点击、鼠标移动和鼠标按钮释放。这正是我们在该函数中做的。每次我们检测到鼠标点击事件时，我们就初始化矩形的左上角点。当我们移动鼠标时，我们通过保持当前位置作为矩形的右下角点来选择感兴趣的区域。
- en: Once we have the region of interest, we just invert the pixels to apply the
    "negative film" effect. We subtract the current pixel value from 255 and this
    gives us the desired effect. When the mouse movement stops and button-up event
    is detected, we stop updating the bottom right position of the rectangle. We just
    keep displaying this image until another mouse click event is detected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了感兴趣的区域，我们只需反转像素以应用“负片”效果。我们从255中减去当前像素值，这样就得到了期望的效果。当鼠标移动停止并且检测到按钮抬起事件时，我们停止更新矩形的右下角位置。我们只需继续显示此图像，直到检测到另一个鼠标点击事件。
- en: Cartoonizing an image
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡通化图像
- en: Now that we know how to handle the webcam and keyboard/mouse inputs, let's go
    ahead and see how to convert a picture into a cartoon-like image. We can either
    convert an image into a sketch or a colored cartoon image.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何处理网络摄像头和键盘/鼠标输入，让我们继续看看如何将图片转换为类似卡通的图像。我们可以将图像转换为草图或彩色卡通图像。
- en: 'Following is an example of what a sketch will look like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个草图将看起来怎样的例子：
- en: '![Cartoonizing an image](img/B04554_03_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![卡通化图像](img/B04554_03_03.jpg)'
- en: 'If you apply the cartoonizing effect to the color image, it will look something
    like this next image:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将卡通化效果应用于彩色图像，它看起来可能就像下面这张图像：
- en: '![Cartoonizing an image](img/B04554_03_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![卡通化图像](img/B04554_03_04.jpg)'
- en: 'Let''s see how to achieve this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现这一点：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Deconstructing the code
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码解构
- en: When you run the preceding program, you will see a window with a video stream
    from the webcam. If you press *S*, the video stream will change to sketch mode
    and you will see its pencil-like outline. If you press *C*, you will see the color-cartoonized
    version of the input stream. If you press any other key, it will return to the
    normal mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的程序时，你会看到一个包含来自网络摄像头的视频流的窗口。如果你按*S*，视频流将切换到草图模式，你会看到它的铅笔轮廓。如果你按*C*，你会看到输入流的彩色卡通版本。如果你按任何其他键，它将返回到正常模式。
- en: 'Let''s look at the function `cartoonize_image` and see how we did it. We first
    convert the image to a grayscale image and run it through a median filter. Median
    filters are very good at removing salt and pepper noise. This is the kind of noise
    where you see isolated black or white pixels in the image. It is common in webcams
    and mobile cameras, so we need to filter it out before we proceed further. To
    give an example, look at the following images:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看函数`cartoonize_image`，看看我们是如何做到的。我们首先将图像转换为灰度图像，并通过中值滤波器进行处理。中值滤波器非常擅长去除椒盐噪声。这种噪声在图像中表现为孤立的黑色或白色像素。这在网络摄像头和手机摄像头中很常见，因此在我们进一步处理之前需要过滤掉它。为了举例说明，请看以下图像：
- en: '![Deconstructing the code](img/B04554_03_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![代码解构](img/B04554_03_05.jpg)'
- en: 'As we see in the input image, there are a lot of isolated green pixels. They
    are lowering the quality of the image and we need to get rid of them. This is
    where the median filter comes in handy. We just look at the NxN neighborhood around
    each pixel and pick the median value of those numbers. Since the isolated pixels
    in this case have high values, taking the median value will get rid of these values
    and also smoothen the image. As you can see in the output image, the median filter
    got rid of all those isolated pixels and the image looks clean. Following is the
    code to do it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在输入图像中看到的，有很多孤立的绿色像素。它们降低了图像质量，我们需要去除它们。这就是中值滤波器发挥作用的地方。我们只需查看每个像素周围的NxN邻域，并选择这些数字的中值。由于在这种情况下孤立的像素具有高值，取中值将去除这些值，并使图像平滑。正如您在输出图像中看到的，中值滤波器去除了所有这些孤立的像素，图像看起来很干净。以下是实现此功能的代码：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code is pretty straightforward. We just use the function `medianBlur` to
    apply the median filter to the input image. The second argument in this function
    specifies the size of the kernel we are using. The size of the kernel is related
    to the neighborhood size that we need to consider. You can play around with this
    parameter and see how it affects the output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当直接。我们只是使用`medianBlur`函数将中值滤波器应用于输入图像。这个函数的第二个参数指定了我们使用的核的大小。核的大小与我们需要考虑的邻域大小有关。您可以尝试调整这个参数，看看它如何影响输出。
- en: Coming back to `cartoonize_image`, we proceed to detect the edges on the grayscale
    image. We need to know where the edges are so that we can create the pencil-line
    effect. Once we detect the edges, we threshold them so that things become black
    and white, both literally and metaphorically!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`cartoonize_image`，我们继续在灰度图像上检测边缘。我们需要知道边缘在哪里，这样我们才能创建铅笔线效果。一旦我们检测到边缘，我们就对它们进行阈值处理，使事物变成黑白，字面和比喻意义上的！
- en: 'In the next step, we check if the sketch mode is enabled. If it is, then we
    just convert it into a color image and return it. What if we want the lines to
    be thicker? Let''s say we want to see something like the following image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们检查草图模式是否启用。如果是，我们就将其转换为彩色图像并返回。如果我们想使线条更粗呢？比如说，我们想看到以下这样的图像：
- en: '![Deconstructing the code](img/B04554_03_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![代码解构](img/B04554_03_06.jpg)'
- en: 'As you can see, the lines are thicker than before. To achieve this, replace
    the `if` code block with the following piece of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，线条比之前更粗。为了实现这一点，将`if`代码块替换为以下代码片段：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are using the erode function with a 3x3 kernel here. The reason we have this
    in place is because it gives us a chance to play with the thickness of the line
    drawing. Now you might ask that if we want to increase the thickness of something,
    shouldn't we be using dilation? Well, the reasoning is right, but there is a small
    twist here. Note that the foreground is black and the background is white. Erosion
    and dilation treat white pixels as foreground and black pixels as background.
    So if we want to increase the thickness of the black foreground, we need to use
    erosion. After we apply erosion, we just use the median filter to clear out the
    noise and get the final output.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的是3x3核的erode函数。我们之所以这样做，是因为它给了我们调整线条绘制厚度的机会。现在您可能会问，如果我们想增加某物的厚度，难道不应该使用膨胀吗？嗯，推理是正确的，但这里有一个小转折。请注意，前景是黑色，背景是白色。腐蚀和膨胀将白色像素视为前景，将黑色像素视为背景。因此，如果我们想增加黑色前景的厚度，我们需要使用腐蚀。在我们应用腐蚀之后，我们只需使用中值滤波器来清除噪声并得到最终输出。
- en: 'In the next step, we use bilateral filtering to smoothen the image. Bilateral
    filtering is an interesting concept and its performance is much better than a
    Gaussian filter. The good thing about bilateral filtering is that it preserves
    the edges, whereas the Gaussian filter smoothens everything out equally. To compare
    and contrast, let''s look at the following input image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们使用双边滤波来平滑图像。双边滤波是一个有趣的概念，其性能远优于高斯滤波。双边滤波的优点在于它保留了边缘，而高斯滤波则将一切均匀地平滑。为了比较和对比，让我们看看以下输入图像：
- en: '![Deconstructing the code](img/B04554_03_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![代码解构](img/B04554_03_07.jpg)'
- en: 'Let''s apply the Gaussian filter to the previous image:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将高斯滤波应用于之前的图像：
- en: '![Deconstructing the code](img/B04554_03_08.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![代码解构](img/B04554_03_08.jpg)'
- en: 'Now, let''s apply the bilateral filter to the input image:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将双边滤波应用于输入图像：
- en: '![Deconstructing the code](img/B04554_03_09.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![代码解构](img/B04554_03_09.jpg)'
- en: 'As you can see, the quality is better if we use the bilateral filter. The image
    looks smooth and the edges look nice and sharp! The code to achieve this is given
    next:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果我们使用双边滤波，质量会更好。图像看起来很平滑，边缘看起来也很清晰！实现这一点的代码如下：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you closely observe the two outputs, you can see that the edges in the Gaussian
    filtered image look blurred. Usually, we just want to smoothen the rough areas
    in the image and keep the edges intact. This is where the bilateral filter comes
    in handy. The Gaussian filter just looks at the immediate neighborhood and averages
    the pixel values using a Gaussian kernel. The bilateral filter takes this concept
    to the next level by averaging only those pixels that are similar to each other
    in intensity. It also takes a color neighborhood metric to see if it can replace
    the current pixel that is similar in intensity as well. If you look the function
    call:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察两个输出，你可以看到高斯滤波图像中的边缘看起来是模糊的。通常，我们只想平滑图像中的粗糙区域，并保持边缘完整。这就是双边滤波器派上用场的地方。高斯滤波器只查看直接邻域，并使用高斯核平均像素值。双边滤波器通过只平均那些在强度上相似的像素将这个概念提升到下一个层次。它还使用颜色邻域度量来查看是否可以替换当前像素，该像素在强度上与当前像素相似。如果你查看函数调用：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last two arguments here specify the color and space neighborhood. This is
    the reason the edges look crisp in the output of the bilateral filter. We run
    this filter multiple times on the image to smoothen it out, to make it look like
    a cartoon. We then superimpose the pencil-like mask on top of this color image
    to create a cartoon-like effect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里最后两个参数指定了颜色和空间邻域。这就是双边滤波器输出边缘看起来清晰的原因。我们在图像上多次运行这个滤波器以平滑它，使其看起来像卡通。然后我们在这个彩色图像上叠加铅笔状的遮罩以创建类似卡通的效果。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt how to access the webcam. We discussed how to take
    the keyboard and mouse inputs during live video stream. We used this knowledge
    to create an interactive application. We discussed the median and bilateral filters,
    and talked about the advantages of the bilateral filter over the Gaussian filter.
    We used all these principles to convert the input image into a sketch-like image,
    and then cartoonized it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何访问摄像头。我们讨论了如何在实时视频流中获取键盘和鼠标输入。我们利用这些知识创建了一个交互式应用程序。我们讨论了中值滤波器和双边滤波器，并谈到了双边滤波器相对于高斯滤波器的优势。我们使用所有这些原理将输入图像转换为类似草图的效果，然后将其卡通化。
- en: In the next chapter, we will learn how to detect different body parts in static
    images as well as in live videos.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在静态图像和实时视频中检测不同的身体部位。
