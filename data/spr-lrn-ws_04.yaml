- en: 4\. Autoregression
  id: totrans-0
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4. 自回归
- en: Overview
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will teach you how to implement autoregression as a method for
    forecasting values depending on past values. By the end of this chapter, you will
    be able to create an autoregression model and construct time series regression
    models using autoregression. You will be fully equipped to use autoregressors
    to model datasets and predict future values.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何实现自回归模型，作为一种基于过去值预测未来值的方法。在本章结束时，你将能够创建一个自回归模型，并使用自回归构建时间序列回归模型。你将完全掌握如何使用自回归模型对数据集进行建模，并预测未来的值。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引言
- en: In the previous chapter, we studied the different methods used to construct
    linear regression models. We learned how to use the least squares method to develop
    linear models. We made use of dummy variables to improve the performance of these
    linear models. We also performed linear regression analysis with a polynomial
    model to improve the model's performance. Next, we implemented the gradient descent
    algorithm, which handles large datasets and large numbers of variables with ease.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们研究了用于构建线性回归模型的不同方法。我们学习了如何使用最小二乘法开发线性模型。我们利用虚拟变量来提高这些线性模型的性能。我们还通过多项式模型进行线性回归分析，以提升模型的表现。接下来，我们实现了梯度下降算法，能够轻松处理大数据集和大量变量。
- en: In this chapter, we will be developing autoregression models. Autoregression
    is a special type of regression that can be used to predict future values based
    on the experience of previous data in the set.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发自回归模型。自回归是一种特殊类型的回归，可以根据数据集中的前期数据经验预测未来的值。
- en: Autoregression Models
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自回归模型
- en: Autoregression models are classical or "standard" modeling methods used on time
    series data (that is, any dataset that changes with time) and can complement the
    linear regression techniques covered previously. Autoregression models are often
    used for forecasting in the economics and finance industry as they are useful
    with univariate time series (where there are no x variables other than time) and
    with very large datasets (such as streaming data or high-frequency sensor data)
    where the linear algebra operations might run into memory or performance issues
    on very large datasets. The "auto" part of autoregression refers to the fact that
    these models leverage correlation of a time series to itself in the past, hence
    autoregression. In addition, many systems do not have an associated causal model—the
    time series data is said to be stochastic. An example is stock price data over
    time. Although many attempts have been made, and continue to be made, to develop
    predictive causal models of stock market behavior, very few have been successful.
    Thus, we can treat a given stock symbol price over time as a stochastic series
    and use autoregression to attempt to model it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归模型是经典的或“标准”的建模方法，适用于时间序列数据（即任何随时间变化的数据），并且可以补充之前讨论的线性回归技术。自回归模型常用于经济学和金融行业的预测，因为它们在单变量时间序列（即除了时间之外没有其他x变量）以及非常大的数据集（如流数据或高频传感器数据）中非常有效，后者在处理时可能会遇到内存或性能问题。“自”（auto）部分指的是这些模型利用时间序列与自身过去的相关性，因此称为自回归。此外，许多系统没有相关的因果模型——时间序列数据被认为是随机的。例如，股票价格随时间的变化。尽管已经进行并且仍在进行许多尝试，旨在开发股票市场行为的预测性因果模型，但成功的案例寥寥无几。因此，我们可以将某一股票符号的价格随时间变化视为随机序列，并使用自回归方法进行建模尝试。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To illustrate autoregression, we will use the S&P daily closing prices from
    1986 to 2018, which are available in the repository associated with this book
    (https://packt.live/2w3ZkDw).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明自回归模型，我们将使用1986年至2018年间的标准普尔500日收盘价，这些数据可以在与本书相关的仓库中找到（[https://packt.live/2w3ZkDw](https://packt.live/2w3ZkDw)）。
- en: 'The original dataset can be found here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据集可以在这里找到：
- en: '[https://www.kaggle.com/pdquant/sp500-daily-19862018](https://www.kaggle.com/pdquant/sp500-daily-19862018
    )'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/pdquant/sp500-daily-19862018](https://www.kaggle.com/pdquant/sp500-daily-19862018
    )'
- en: 'A graphical view of this data is shown in the following figure:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据的图形表示如下图所示：
- en: '![Figure 4.1: S&P 500 Daily Closing Price'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：标准普尔500日收盘价'
- en: '](img/image-VQ8F7304.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-VQ8F7304.jpg)'
- en: 'Figure 4.1: S&P 500 Daily Closing Price'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：标准普尔500日收盘价
- en: The main principle behind autoregression models is that, given enough previous
    observations, a reasonable prediction for the future can be made; that is, we
    are essentially constructing a model using the dataset as a regression against
    itself, using past values as the predictors. A key factor in choosing an autoregression
    model is that there is enough correlation of the future values to past values
    at specific lag times. Lag time refers to how far into the past the model uses
    data to predict the future.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自回归模型背后的主要原理是，给定足够的历史观察数据，可以对未来做出合理的预测；也就是说，我们本质上是在构建一个模型，将数据集作为自我回归，使用过去的值作为预测因子。选择自回归模型的一个关键因素是未来值与过去值在特定滞后时间点之间有足够的相关性。滞后时间指的是模型使用的数据回溯多长时间来预测未来。
- en: 'Exercise 4.01: Creating an Autoregression Model'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 4.01：创建自回归模型
- en: 'In this exercise, we will use autoregression and attempt to predict the S&P
    500 closing price 1 year into the future:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用自回归方法，尝试预测未来一年内标准普尔500指数的收盘价：
- en: Note
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'This exercise will work on an earlier version of pandas, ensure that you downgrade
    the version of pandas using the command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习适用于较早版本的 pandas，请确保使用以下命令将 pandas 降级：
- en: pip install pandas==0.24.2
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: pip install pandas==0.24.2
- en: 'Import the necessary packages and classes. In this exercise, we introduce the
    statsmodels package, which includes a wide range of statistical and modeling functions,
    including autoregression. If you have not previously installed statsmodels from
    a terminal prompt, use the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 导入必要的包和类。在这个练习中，我们介绍了 statsmodels 包，它包括广泛的统计和建模函数，包括自回归。如果你之前没有从终端提示符安装 statsmodels，请使用以下命令：
- en: conda install -c anaconda statsmodels
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: conda install -c anaconda statsmodels
- en: 'If you are not using Anaconda (or Miniconda) and instead install via pip, use
    the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用 Anaconda（或 Miniconda），而是通过 pip 安装，请使用以下命令：
- en: pip install -U statsmodels
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: pip install -U statsmodels
- en: 'Once statsmodels is installed on your system, load the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在系统上安装了 statsmodels，加载以下内容：
- en: import pandas as pd
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: import pandas as pd
- en: import numpy as np
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: from statsmodels.tsa.ar_model import AR
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: from statsmodels.tsa.ar_model import AR
- en: from statsmodels.graphics.tsaplots import plot_acf
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: from statsmodels.graphics.tsaplots import plot_acf
- en: import matplotlib.pyplot as plt
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: 'Load the S&P 500 data (spx.csv) and convert the date column into a datetime
    data type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 加载标准普尔500数据（spx.csv），并将日期列转换为 datetime 数据类型：
- en: df = pd.read_csv('../Datasets/spx.csv')
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: df = pd.read_csv('../Datasets/spx.csv')
- en: df['date'] = pd.to_datetime(df['date'])
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: df['date'] = pd.to_datetime(df['date'])
- en: print(df.head())
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: print(df.head())
- en: print(df.tail())
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: print(df.tail())
- en: 'We''ll get the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![Figure 4.2: S&P 500 historical data'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2：标准普尔500历史数据'
- en: '](img/image-DZT8WT05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-DZT8WT05.jpg)'
- en: 'Figure 4.2: S&P 500 historical data'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：标准普尔500历史数据
- en: If you look carefully at the data in Figure 4.2, you might see that some data
    is missing—for example, there is no data on 1/4/1986 and 1/5/1986\. These are
    weekend dates during which the market is closed. An autoregression model, especially
    one containing a lot of data, will not be sensitive to the missing values for
    at least two reasons. First, since the model moves forward one period at a time
    and, in higher-order models, uses multiple past values, the prediction will be
    less sensitive to missing values compared to a model that was, say, based on a
    single lag value. Second, in the case such as here, where most missing values
    are periodic (Saturdays repeat every 7 days, Sundays repeat every 7 days, and
    so on), then, if we have a lot of data, the model will automatically account for
    those days. However, as we will see, the uncertainty of predicting far beyond
    the end of existing data can become large for autoregression models.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看图 4.2 中的数据，你可能会发现一些数据缺失——例如，1986年1月4日和1986年1月5日没有数据。这些是市场关闭的周末日期。自回归模型，特别是包含大量数据的模型，对于缺失值通常不敏感，原因有至少两个。首先，由于模型一次前进一个时间段，并且在高阶模型中使用多个过去的值，预测对于缺失值的敏感度比基于单一滞后值的模型要低。其次，像这里的情况一样，大部分缺失值是周期性的（星期六每7天重复一次，星期天每7天重复一次，依此类推），如果我们有大量数据，模型会自动考虑这些缺失的日期。然而，正如我们将看到的，预测超出现有数据的时间范围时，自回归模型的预测不确定性会变得很大。
- en: 'Plot the raw dataset versus the date data type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始数据集与日期数据类型进行比较绘制：
- en: fig, ax = plt.subplots(figsize = (10, 7))
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(figsize = (10, 7))
- en: ax.plot(df.date, df.close)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ax.plot(df.date, df.close)
- en: ax.set_title('S&P 500 Daily Closing Price', fontsize = 16)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_title('标准普尔500每日收盘价', fontsize = 16)
- en: ax.set_ylabel('Price ($)', fontsize = 14)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylabel('价格 ($)', fontsize = 14)
- en: ax.tick_params(axis = 'both', labelsize = 12)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ax.tick_params(axis = 'both', labelsize = 12)
- en: plt.show()
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'The output will be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 4.3: Plot of the S&P 500 closing prices'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3：标准普尔500指数收盘价的图'
- en: '](img/image-8X8EV214.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-8X8EV214.jpg)'
- en: 'Figure 4.3: Plot of the S&P 500 closing prices'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：标准普尔500指数收盘价的图
- en: 'Before constructing an autoregression model, we should first check to see whether
    the model is able to be used as a regression against itself. As we noted earlier,
    the success of an autoregression model depends on the ability to use past values
    in a linear model to predict future values. That means the future values should
    be strongly correlated to past values. We can investigate this using the statsmodelsplot_acf
    function (plotting the autocorrelation function). We mentioned before that how
    far back we look into the past is called the lag; we will override the default
    maximum value of plot_acf and plot lags from 0 days to 4,000 days:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自回归模型之前，我们应该首先检查模型是否能够用于自回归。正如我们之前提到的，自回归模型的成功依赖于能否利用过去的值通过线性模型预测未来的值。这意味着未来的值应该与过去的值有很强的相关性。我们可以通过使用statsmodelsplot_acf函数（绘制自相关函数）来进行检查。我们之前提到过，回顾过去多长时间被称为滞后；我们将覆盖plot_acf的默认最大值，并绘制从0天到4,000天的滞后：
- en: max_lag = 4000
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: max_lag = 4000
- en: fig, ax = plt.subplots(figsize = (10, 7))
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(figsize = (10, 7))
- en: acf_plot = plot_acf(x = df.close, ax = ax, lags = max_lag, \
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: acf_plot = plot_acf(x = df.close, ax = ax, lags = max_lag, \
- en: use_vlines = False, alpha = 0.9, \
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: use_vlines = False, alpha = 0.9, \
- en: title = 'Autocorrelation of SPX vs. lag')
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: title = '标准普尔500指数的自相关与滞后关系')
- en: ax.grid(True)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ax.grid(True)
- en: ax.text(1000, 0.01, '90% confidence interval')
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ax.text(1000, 0.01, '90% 置信区间')
- en: ax.set_xlabel('Lag', fontsize = 14)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlabel('滞后', fontsize = 14)
- en: ax.tick_params(axis = 'both', labelsize = 12)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ax.tick_params(axis = 'both', labelsize = 12)
- en: plt.show()
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'The result should appear as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该如下所示：
- en: '![Figure 4.4: Autocorrelation plot of the S&P 500 closing price versus lag
    (days)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4：标准普尔500指数收盘价与滞后（天数）的自相关图'
- en: '](img/image-UL343SKQ.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-UL343SKQ.jpg)'
- en: 'Figure 4.4: Autocorrelation plot of the S&P 500 closing price versus lag (days)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：标准普尔500指数收盘价与滞后（天数）的自相关图
- en: We can understand this chart as follows. First, by definition at 0 lag, a series
    is perfectly correlated to itself so the autocorrelationfunction (ACF) value is
    1.0\. Then, we see that as we increase the lag, the series is less and less correlated,
    meaning each data point farther back in time has less information about the value
    we are predicting. This is very typical of stochastic or random series (note that
    periodic series will have peaks and valleys in the ACF plot—we will see this later).
    Also, by choosing the value in the function call, we plotted a 90% confidence
    interval shaded in blue. The meaning of this interval is that any lag outside
    the interval is considered statistically significant—in other words, the correlation
    is statistically valid. To build an autocorrelation model, we must have ACF values
    outside the confidence interval to be successful. In this case, we have a fairly
    high correlation from 0 to some number of days, which we can use in the model
    (more on that shortly). Finally, we can see that at lags above about 2,750 days,
    the correlation is negative—that is, the past values predict the opposite to the
    future. However, in this case, those long-term negative lags are not very significant.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样理解这张图。首先，根据定义，在滞后为0时，序列与自身完全相关，因此自相关函数（ACF）值为1.0。然后，我们可以看到，随着滞后的增加，序列的相关性逐渐减弱，这意味着越往后的数据点与我们预测的值相关性越小。这是典型的随机或斯托卡斯蒂克序列（注意周期性序列在ACF图中会有峰值和谷值—我们稍后会看到这一点）。此外，通过在函数调用中选择该值，我们绘制了一个90%的置信区间，并用蓝色阴影标示。这个区间的意义是，任何超出该区间的滞后都被认为在统计上显著—换句话说，相关性在统计上是有效的。为了构建自回归模型，我们必须有超出置信区间的ACF值才能成功。在这种情况下，从0到若干天，我们有相当高的相关性，这可以在模型中使用（稍后会详细讨论）。最后，我们可以看到，在大约2,750天以上的滞后下，相关性为负—也就是说，过去的值预测了与未来相反的结果。然而，在这种情况下，那些长期的负滞后并不非常显著。
- en: 'To get some intuition for the ACF results, let''s choose a fairly short lag
    of 100 days and plot both the original data and the lagged data on one chart.
    We can do that using the pandas.shift() function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对ACF结果有一些直观的理解，我们选择了一个相对较短的滞后期100天，并将原始数据和滞后数据绘制在同一张图上。我们可以通过使用pandas.shift()函数来做到这一点：
- en: spx_shift_100 = df.copy()
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: spx_shift_100 = df.copy()
- en: spx_shift_100['close'] = df.close.shift(100)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: spx_shift_100['close'] = df.close.shift(100)
- en: fix, ax = plt.subplots(figsize = (10, 7))
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: fix, ax = plt.subplots(figsize = (10, 7))
- en: ax.plot(df.date, df.close, c = "blue")
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ax.plot(df.date, df.close, c = "blue")
- en: ax.plot(spx_shift_100.date, spx_shift_100.close, c = "red")
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ax.plot(spx_shift_100.date, spx_shift_100.close, c = "red")
- en: plt.show()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'The output will be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 4.5: S&P 500 closing price (blue) and with a lag of 100 days (red)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5：标准普尔500指数收盘价（蓝色）和滞后100天的收盘价（红色）](img/image-C5NFMM99.jpg)'
- en: '](img/image-C5NFMM99.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-C5NFMM99.jpg)'
- en: 'Figure 4.5: S&P 500 closing price (blue) and with a lag of 100 days (red)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：标准普尔500指数收盘价（蓝色）和滞后100天的收盘价（红色）
- en: In Figure 4.5, the red line indicates the values from 100 days ago, as compared
    to the blue line, which indicates actual (present) values for a given date. We
    see that during periods when the value is increasing, the past values are below
    the actual, and when the value is decreasing, the opposite is true. This makes
    intuitive sense. Importantly, during large portions of the time period covered,
    the vertical space between the two curves looks about constant. That means, intuitively,
    that the relationship of the past to the present is roughly similar. If you think
    about these curves for some time, you will also see the limitation of autoregression—the
    predictions will always look like the recent history, so when things change, the
    predictions will be less accurate until the model "catches up" with the new behavior.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 4.5 中，红色线条表示100天前的值，与蓝色线条（表示给定日期的实际值）进行对比。我们看到，在值增加的阶段，过去的值低于实际值，而在值减少的阶段，情况则相反。这是直观上合理的。重要的是，在大部分时间段内，两条曲线之间的垂直间距看起来大致恒定。这意味着，直观上，过去与现在的关系大致相似。如果你仔细思考这些曲线，你还会看到自回归模型的局限性——预测值总是看起来像最近的历史，因此当情况发生变化时，预测会变得不准确，直到模型“追赶上”新的行为。
- en: 'There is one more way in which we can visualize the correlation we are analyzing.
    In the multiple linear regression case, we introduced a chart where we plotted
    the predicted values against the actual values; perfect prediction was along the
    diagonal. Similarly, if, instead of plotting the lagged values and the actual
    values, both versus time, we could plot the lagged values against the actual values.
    Let''s see what this would look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方式可以帮助我们可视化正在分析的相关性。在多元线性回归的案例中，我们引入了一个图表，绘制了预测值与实际值的对比；完美的预测沿对角线分布。同样，如果我们不再绘制滞后值和实际值相对于时间的图，而是将滞后值与实际值作图，我们会看到什么样的效果呢？
- en: print(spx_shift_100.head(), '\n', spx_shift_100.tail())
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: print(spx_shift_100.head(), '\n', spx_shift_100.tail())
- en: fig, ax = plt.subplots(figsize = (7, 7))
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(figsize = (7, 7))
- en: ax.scatter(df.loc[100:, 'close'], spx_shift_100.loc[100:, 'close'])
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ax.scatter(df.loc[100:, 'close'], spx_shift_100.loc[100:, 'close'])
- en: ax.set_xlim(0, 3000)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlim(0, 3000)
- en: ax.set_ylim(0, 3000)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylim(0, 3000)
- en: plt.show()
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'The output will be as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: date close
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 日期 收盘价
- en: 0 1986-01-02 NaN
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 0 1986-01-02 NaN
- en: 1 1986-01-03 NaN
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1 1986-01-03 NaN
- en: 2 1986-01-06 NaN
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 2 1986-01-06 NaN
- en: 3 1986-01-07 NaN
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 3 1986-01-07 NaN
- en: 4 1986-01-08 NaN
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 4 1986-01-08 NaN
- en: date close
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 日期 收盘价
- en: 8187 2018-06-25 2823.81
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 8187 2018-06-25 2823.81
- en: 8188 2018-06-26 2821.98
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 8188 2018-06-26 2821.98
- en: 8189 2018-06-27 2762.13
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 8189 2018-06-27 2762.13
- en: 8190 2018-06-28 2648.94
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 8190 2018-06-28 2648.94
- en: 8191 2018-06-29 2695.14
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 8191 2018-06-29 2695.14
- en: 'The plot will be as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图表将如下所示：
- en: '![Figure 4.6: S&P closing value with a lag of 100 days versus actual values'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6：滞后100天的标准普尔收盘值与实际值的比较](img/image-C5NFMM99.jpg)'
- en: '](img/image-RLYG1WTV.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-RLYG1WTV.jpg)'
- en: 'Figure 4.6: S&P closing value with a lag of 100 days versus actual values'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：滞后100天的标准普尔收盘价与实际值的比较
- en: Figure 4.6 shows that most of the values with a lag of 100 days are along a
    diagonal line, meaning that the relationship between the lagged values and the
    present values is similar across all actual values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6显示，大多数滞后100天的值沿着对角线分布，这意味着滞后值与实际值之间的关系在所有实际值中都是相似的。
- en: 'We could create plots like Figure 4.6 across a range of lag times to try to
    understand which lags would be useful in a model and which would not be useful.
    Before we do that, it would be useful to have the values of the ACF from Figure
    4.6, so we could relate what we see in the lag plots to the correlation function
    value. The plot_acf function of statsmodels is based upon an underlying numpy
    function, correlate. We can use that to get the values shown in Figure 4.6:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不同的滞后时间范围内创建类似图 4.6 的图表，尝试理解哪些滞后时间对模型有用，哪些没有用。在此之前，了解图 4.6 中的自相关函数（ACF）值将是有用的，这样我们可以将滞后图中的内容与相关函数值关联起来。statsmodels的plot_acf函数基于一个底层的numpy函数——correlate。我们可以使用它来获取图
    4.6 中显示的值：
- en: '"""'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: the statsmodels plot_acf is based upon the numpy correlate
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: statsmodels的plot_acf基于numpy的correlate函数
- en: function, so we can generate the actual values for
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，因此我们可以生成实际的值来
- en: illustration and so we can label some later plots
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 插图，因此我们可以稍后为一些图表加标签
- en: the standard presentation of an acf plot has the value at
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: acf图的标准表示中，值位于
- en: lag 0 == 1; the correlate function returns unscaled
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: lag 0 == 1；correlate函数返回未缩放的
- en: values so we get the first value for scaling to 1
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值使我们得到第一个值，用于缩放到1
- en: the values to be tested in the function must have
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中要测试的值必须具有
- en: the mean of the un-shifted series subtracted from
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从未移动序列中减去的均值
- en: both series
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 两个序列
- en: '"""'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'corr0 = np.correlate(df.close[0: ] - df.close.mean(), \'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'corr0 = np.correlate(df.close[0: ] - df.close.mean(), \'
- en: 'df.close[0: ] - df.close.mean(), \'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'df.close[0: ] - df.close.mean(), \'
- en: mode = 'valid')
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: mode = 'valid')
- en: corrs = [np.correlate(df.close[:(df.close.shape[0] - i)] \
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: corrs = [np.correlate(df.close[:(df.close.shape[0] - i)] \
- en: '- df.close.mean(), df.close[i: ] \'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '- df.close.mean(), df.close[i: ]'
- en: '- df.close.mean(), mode = ''valid'')'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '- df.close.mean(), mode = ''valid'')'
- en: for i in range(max_lag)] / corr0
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: for i in range(max_lag)] / corr0
- en: Note that we subtract the mean of the underlying series (df.close) from every
    value used in the correlate function. This is a mathematical subtlety to be consistent
    with the output of the plot_act function output.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从相关函数中使用的每个值中减去了基础序列（df.close）的均值。这是一个数学上的微妙之处，目的是与plot_act函数的输出保持一致。
- en: 'Now, rather than creating many charts by hand at different lag values, let''s
    create a function to generate a grid of plots that we can use with various lag
    ranges, numbers of plots, and so on. We will pass the df.close series to the function,
    along with the preceding corrs values, and with parameters to control the plots:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与其在不同滞后值下手动创建许多图表，不如创建一个函数来生成一个图表网格，我们可以用不同的滞后范围、图表数量等来使用它。我们将传递df.close序列给函数，同时传递前面的corrs值，并设置控制图表的参数：
- en: '"""'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: utility function to plot out a range of
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一定范围的实用函数
- en: plots depicting self-correlation
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 描述自相关的图
- en: '"""'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: def plot_lag_grid(series, corrs, axis_min, axis_max, \
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: def plot_lag_grid(series, corrs, axis_min, axis_max, \
- en: 'num_plots, total_lag, n_rows, n_cols):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'num_plots, total_lag, n_rows, n_cols):'
- en: lag_step = int(total_lag / num_plots)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: lag_step = int(total_lag / num_plots)
- en: fig = plt.figure(figsize = (18, 16))
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.figure(figsize = (18, 16))
- en: 'for i in range(num_plots):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(num_plots):'
- en: corr = corrs[lag_step * i]
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: corr = corrs[lag_step * i]
- en: ax = fig.add_subplot(n_rows, n_cols, i + 1)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ax = fig.add_subplot(n_rows, n_cols, i + 1)
- en: ax.scatter(series, series.shift(lag_step * i))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ax.scatter(series, series.shift(lag_step * i))
- en: ax.set_xlim(axis_min, axis_max)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlim(axis_min, axis_max)
- en: ax.set_ylim(axis_min, axis_max)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylim(axis_min, axis_max)
- en: ax.set_title('lag = ' + str(lag_step * i))
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_title('lag = ' + str(lag_step * i))
- en: ax.text(axis_min + 0.05 * (axis_max - axis_min), \
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ax.text(axis_min + 0.05 * (axis_max - axis_min), \
- en: axis_max - 0.05 * (axis_max - axis_min), \
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: axis_max - 0.05 * (axis_max - axis_min), \
- en: '''correlation = '' + str(round(corr[0], 3)))'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '''correlation = '' + str(round(corr[0], 3)))'
- en: fig.tight_layout()
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: fig.tight_layout()
- en: plt.show()
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'We are now prepared to get a deeper understanding of how the correlation relates
    to the lag plots. We''ll call the function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好深入理解相关性与滞后图之间的关系。我们将调用这个函数：
- en: '"""'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: create a grid to see how well the data at increasing
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个网格，查看数据在增大的滞后期下的相关性
- en: lags correlates to the original data
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 滞后与原始数据的相关性
- en: '''perfect'' correlation will appear as a diagonal line'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: “完美”的相关性将表现为对角线
- en: the farther from the line, the poorer the correlation
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 离直线越远，相关性越差
- en: '"""'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: plot_lag_grid(df.close, corrs, df.close.min(), df.close.max(), \
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: plot_lag_grid(df.close, corrs, df.close.min(), df.close.max(), \
- en: num_plots = 16, total_lag = 480, \
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: num_plots = 16, total_lag = 480, \
- en: n_rows = 4, n_cols = 4)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: n_rows = 4, n_cols = 4)
- en: 'This will produce the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生如下结果：
- en: '![Figure 4.7: Lag plots at various values'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7：在不同值下的滞后图'
- en: '](img/image-72CNT49S.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-72CNT49S.jpg)'
- en: 'Figure 4.7: Lag plots at various values'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：在不同值下的滞后图
- en: In Figure 4.7, we can see a gradual degradation in lag chart appearance in direct
    relation to the ACF function value shown on each plot. This gives us the idea
    that trying to use longer lags will add noise to the model, which looks like it
    would be fairly large by lag 60, and not too large at lag 30\. Now, we can use
    another statsmodels function to develop a model and see how that fits in with
    our idea.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 4.7 中，我们可以看到滞后图的外观逐渐恶化，这与每个图中显示的ACF函数值直接相关。这让我们得出一个结论：尝试使用更长的滞后期将会给模型增加噪声，到滞后60时噪声较大，而滞后30时噪声较小。现在，我们可以使用另一个statsmodels函数来开发模型，并查看它与我们想法的契合程度。
- en: 'The statsmodels function, AR, along with the associated fit method, builds
    an autoregression model. Used with the defaults, it will determine the max lag,
    return all the parameters from lag 1 to the max lag, and allow us to predict both
    in the range of the existing data and into the future:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: statsmodels 的 AR 函数与相关的 fit 方法一起，构建了一个自回归模型。使用默认设置时，它将确定最大滞后期，返回从滞后期 1 到最大滞后期的所有参数，并允许我们对现有数据范围内和未来进行预测：
- en: '"""'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: statsmodels AR function builds an autoregression model
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: statsmodels AR 函数构建了一个自回归模型
- en: using all the defaults, it will determine the max lag
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有默认设置时，它将确定最大滞后期
- en: and provide all the model coefficients
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 并提供所有模型系数
- en: '"""'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: model = AR(df.close)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: model = AR(df.close)
- en: model_fit = model.fit()
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: model_fit = model.fit()
- en: model fit now contains all the model information
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在，模型拟合包含了所有模型信息
- en: max_lag = model_fit.k_ar
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: max_lag = model_fit.k_ar
- en: '"""'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: note that by using defaults, the maximum lag is
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用默认设置时，最大滞后期为
- en: computed as round(12*(nobs/100.)**(1/4.))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 计算公式为 round(12*(nobs/100.)**(1/4.))
- en: see https://www.statsmodels.org/devel/generated/statsmodels.tsa.ar_model.AR.fit.html#statsmodels.tsa.ar_model.AR.fit
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问 https://www.statsmodels.org/devel/generated/statsmodels.tsa.ar_model.AR.fit.html#statsmodels.tsa.ar_model.AR.fit
- en: '"""'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: 'print(''Max Lag: '' + str(max_lag))'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: print('最大滞后期：' + str(max_lag))
- en: 'print(''Coefficients: \n'' + str(model_fit.params))'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: print('系数：\n' + str(model_fit.params))
- en: 'The output will be as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 4.8: Lag coefficients from the statsmodels AR function'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8：来自 statsmodels AR 函数的滞后系数'
- en: '](img/image-9MV9NO6B.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-9MV9NO6B.jpg)'
- en: 'Figure 4.8: Lag coefficients from the statsmodels AR function'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：来自 statsmodels AR 函数的滞后系数
- en: 'Note that there are 36 coefficients for each of the weights and one constant—the
    function determined that the maximum lag to use in the model is 36 days. It is
    easy to make predictions and visualize the result:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于每个权重和一个常数，模型有 36 个系数——该函数确定了在模型中使用的最大滞后期为 36 天。预测值生成和结果可视化非常简单：
- en: how far into the future we want to predict
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们想预测的未来时长
- en: max_forecast = 365
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: max_forecast = 365
- en: generate predictions from the model
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从模型中生成预测值
- en: 'pred_close = pd.DataFrame({''pred_close'': \'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'pred_close = pd.DataFrame({''pred_close'': \'
- en: model_fit.predict(start = max_lag, \
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: model_fit.predict(start = max_lag, \
- en: end = df.shape[0] \
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: end = df.shape[0] \
- en: + max_forecast - 1)})
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: + max_forecast - 1)})
- en: attach the dates for visualization
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加日期以便可视化
- en: pred_close['date'] = df.loc[pred_close.index, 'date'].reindex()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: pred_close['date'] = df.loc[pred_close.index, 'date'].reindex()
- en: pred_close.loc[(max(df.index) + 1):, 'date'] = \
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: pred_close.loc[(max(df.index) + 1):, 'date'] = \
- en: pd.to_datetime([max(df.date) \
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: pd.to_datetime([max(df.date) \
- en: + pd.Timedelta(days = i) \
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: + pd.Timedelta(days = i) \
- en: for i in range(1, max_forecast + 1)])
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: for i in range(1, max_forecast + 1)])
- en: '"""'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: visualize the predictions overlaid on the real data
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将预测结果与真实数据叠加进行可视化
- en: as well as the extrapolation to the future
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以及对未来的外推
- en: '"""'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: fig, ax = plt.subplots(figsize = (10, 7))
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(figsize = (10, 7))
- en: ax.plot(df.date, df.close, c = "blue", linewidth = 4, \
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ax.plot(df.date, df.close, c = "blue", linewidth = 4, \
- en: label = 'actual SPX close')
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: label = '实际 SPX 收盘'
- en: 'ax.plot(pred_close.loc[0 : len(df.close), ''date''], \'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'ax.plot(pred_close.loc[0 : len(df.close), ''date''], \'
- en: 'pred_close.loc[0 : len(df.close), ''pred_close''], \'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'pred_close.loc[0 : len(df.close), ''pred_close''], \'
- en: c = "yellow", linewidth = 0.5, \
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: c = "yellow", linewidth = 0.5, \
- en: label = 'predicted SPX close')
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: label = '预测 SPX 收盘'
- en: ax.plot(pred_close.loc[len(df.close):, 'date'], \
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ax.plot(pred_close.loc[len(df.close):, 'date'], \
- en: pred_close.loc[len(df.close):, 'pred_close'], \
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: pred_close.loc[len(df.close):, 'pred_close'], \
- en: c = "red", linewidth = 2, label = 'forecast SPX close')
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: c = "red", linewidth = 2, label = '预测 SPX 收盘')
- en: ax.set_xlabel('Date', fontsize = 14)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlabel('日期', fontsize = 14)
- en: ax.tick_params(axis = 'both', labelsize = 12)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ax.tick_params(axis = 'both', labelsize = 12)
- en: ax.legend()
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ax.legend()
- en: plt.show()
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'The result will look as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![Figure 4.9: S&P 500 closing vales, predicted values, and forecasted (future)
    values'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9：S&P 500 收盘值、预测值和预测（未来）值'
- en: from the autoregression model with order 36
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 来自自回归模型，滞后期为 36
- en: '](img/image-LUKCBOXA.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-LUKCBOXA.jpg)'
- en: 'Figure 4.9: S&P 500 closing vales, predicted values, and forecasted (future)
    values from the autoregression model with order 36'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：来自自回归模型（滞后期为 36）的 S&P 500 收盘值、预测值和预测（未来）值
- en: Note that the predictions do an excellent job of following the dataset, and
    that after the dataset has ended, the predictions are relatively linear. Given
    that the model is constructed from a linear model of the previous samples, and
    that, after yt+1, the predictions are less and less certain as they become based
    on past predictions, each of which has some error.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，预测值在跟随数据集方面表现非常好，并且在数据集结束后，预测值相对线性。由于模型是从前一个样本的线性模型构建的，而且在 yt+1 之后，随着基于过去预测的预测值增多，每个预测都带有一定误差，因此预测的确定性会逐渐降低。
- en: 'The fit is quite good. We can use the same approach as for linear regression
    to compare the predictions versus the actual values. We have to do a little work
    to deal with the fact that the predicted values don''t start until the maximum
    lag beyond the start date of the original data—we need at least the maximum lag
    number of past values to predict the next one—in this case, 36 values. The result
    is that we need to offset the index of the datasets we want to compare, which
    we did not have to do in the linear regression case:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合效果相当好。我们可以像线性回归一样比较预测值与实际值之间的差异。由于预测值直到超过原始数据的最大滞后期才开始，因此我们需要处理这个问题——我们至少需要最大滞后期数量的历史值才能预测下一个值——在本例中是
    36 个值。结果是我们需要对比数据集的索引进行偏移，这在进行线性回归时并不需要：
- en: compare predicted vs. actual
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较预测值与实际值
- en: fig, ax = plt.subplots(figsize = (10, 7))
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(figsize = (10, 7))
- en: ax.scatter(df.loc[max_lag:(df.shape[0] - 1), 'close'], \
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ax.scatter(df.loc[max_lag:(df.shape[0] - 1), 'close'], \
- en: pred_close.loc[max_lag:(df.shape[0] - 1), 'pred_close'])
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: pred_close.loc[max_lag:(df.shape[0] - 1), 'pred_close'])
- en: ax.tick_params(axis = 'both', labelsize = 12)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ax.tick_params(axis = 'both', labelsize = 12)
- en: ax.set_xlabel('SPX actual value', fontsize = 14)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlabel('SPX 实际值', fontsize = 14)
- en: ax.set_ylabel('SPX predicted value', fontsize = 14)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylabel('SPX 预测值', fontsize = 14)
- en: plt.show()
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'This provides the following plot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了如下图表：
- en: '![Figure 4.10: Predicted S&P 500 closing values versus the actual values'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10：预测的 S&P 500 收盘值与实际值的对比'
- en: '](img/image-8OL3AZBK.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-8OL3AZBK.jpg)'
- en: 'Figure 4.10: Predicted S&P 500 closing values versus the actual values'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：预测的 S&P 500 收盘值与实际值的对比
- en: 'In Figure 4.10, it appears as if the predictions are good across all values.
    We can, however, dig a little deeper by looking at the residuals, which are the
    differences between the actual and predicted values:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 4.10 中，似乎所有值的预测都很好。然而，我们可以通过查看残差来深入分析，残差是实际值与预测值之间的差异：
- en: 'Calculate the residuals using the same approach as used previously, to account
    for the date offsets:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的方法计算残差，以考虑日期偏移：
- en: fig, ax = plt.subplots(figsize = (10, 7))
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(figsize = (10, 7))
- en: 'residuals = pd.DataFrame({''date'' : (df.loc[max_lag:\'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'residuals = pd.DataFrame({''date'' : (df.loc[max_lag:\'
- en: (df.shape[0] - 1), 'date']),
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (df.shape[0] - 1), 'date']),
- en: '''residual'' : df.loc[max_lag:\'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '''residual'' : df.loc[max_lag:\'
- en: (df.shape[0] - 1), 'close'] \
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: (df.shape[0] - 1), 'close'] \
- en: '- pred_close.loc\'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '- pred_close.loc\'
- en: '[max_lag:(df.shape[0] - 1), \'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[max_lag:(df.shape[0] - 1), \'
- en: '''pred_close'']})'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '''pred_close'']})'
- en: ax.scatter(residuals.date, residuals.residual)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ax.scatter(residuals.date, residuals.residual)
- en: ax.tick_params(axis = 'both', labelsize = 12)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ax.tick_params(axis = 'both', labelsize = 12)
- en: ax.set_xlabel('Date', fontsize = 14)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlabel('日期', fontsize = 14)
- en: ax.set_ylabel('residual (' + r'$SPX_{act} - SPX_{pred}$' \
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylabel('残差 (' + r'$SPX_{act} - SPX_{pred}$' \
- en: + ')', fontsize = 14)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: + ')', fontsize = 14)
- en: plt.show()
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'This produces the following plot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下图表：
- en: '![Figure 4.11: Residual values versus time for the autoregression'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11：自回归模型的残差值与时间的关系'
- en: model of the S&P 500 closing price
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: S&P 500 收盘价的模型
- en: '](img/image-1YKW9W6F.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-1YKW9W6F.jpg)'
- en: 'Figure 4.11: Residual values versus time for the autoregression model of the
    S&P 500 closing price'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：S&P 500 收盘价的自回归模型残差值与时间的关系
- en: Figure 4.11 shows that the residuals are uniformly spread around 0, meaning
    that there appears to be minimal bias in the model, and they seem to increase
    somewhat over time. This latter characteristic isn't automatically an indication
    of an issue—it is better to view this data as a percentage of the actual value—intuitively,
    the residual for an equally accurate model would be larger as the value gets larger.
    We can convert the data into a percent and look at that.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 显示，残差均匀地分布在 0 附近，这意味着模型的偏差最小，而且它们似乎随时间有所增加。然而，这种特性不一定意味着存在问题——最好将数据视为实际值的百分比——直观地说，对于一个同样准确的模型，随着值变大，残差会更大。我们可以将数据转换为百分比，并查看这一点。
- en: 'Calculate the percentage of residuals simply by dividing by the actual value
    (and multiplying by 100). Note that percent values have issues if the actual values
    are near zero, but, in this case, that is not an issue:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将残差除以实际值并乘以100来计算残差的百分比。请注意，如果实际值接近零，百分比值可能存在问题，但在这种情况下这不是问题：
- en: fig, ax = plt.subplots(figsize = (10, 7))
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(figsize = (10, 7))
- en: 'pct_residuals = pd.DataFrame({''date'' : residuals.date, \'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'pct_residuals = pd.DataFrame({''date'' : residuals.date, \'
- en: '''pct_residual'' : 100 \'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '''pct_residual'' : 100 \'
- en: '* residuals.residual \'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '* residuals.residual \'
- en: / df.loc[max_lag:(df.shape[0] - 1), \
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: / df.loc[max_lag:(df.shape[0] - 1), \
- en: '''close'']})'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '''close'']})'
- en: ax.scatter(pct_residuals.date, pct_residuals.pct_residual)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ax.scatter(pct_residuals.date, pct_residuals.pct_residual)
- en: ax.tick_params(axis = 'both', labelsize = 12)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ax.tick_params(axis = 'both', labelsize = 12)
- en: ax.set_xlabel('Date', fontsize = 14)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlabel('日期', fontsize = 14)
- en: ax.set_ylabel('% residual 100 *(' \
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylabel('%残差 100 *(' \
- en: + r'$SPX_{act} - SPX_{pred}$' + ') / ' \
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: + r'$SPX_{act} - SPX_{pred}$' + ') / ' \
- en: + r'$SPX_{act}$', fontsize = 14)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: + r'$SPX_{act}$', fontsize = 14)
- en: plt.show()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: 'The output will be as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 4.12: Residual values as a percent of actual value versus time'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12：实际值与时间的残差百分比关系'
- en: '](img/image-QVB4H6MT.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-QVB4H6MT.jpg)'
- en: 'Figure 4.12: Residual values as a percent of actual value versus time'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：实际值与时间的残差百分比关系
- en: Note
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to https://packt.live/3eAi6DG.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 若要访问此特定部分的源代码，请参阅 https://packt.live/3eAi6DG。
- en: You can also run this example online at https://packt.live/2Z0uEh4\. You must
    execute the entire Notebook in order to get the desired result.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在线运行这个示例，网址为 https://packt.live/2Z0uEh4。你必须执行整个Notebook才能得到预期的结果。
- en: 'Now that the exercise is successfully completed, upgrade the version of pandas
    to continue to smoothly run the exercises and activities present in the rest of
    the book. To upgrade pandas, run:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然练习已经顺利完成，升级pandas的版本以继续顺利运行本书剩余部分的练习和活动。要升级pandas，请运行：
- en: pip install pandas==1.0.3
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: pip install pandas==1.0.3
- en: We now see that the percent error is very similar across the entire period,
    with a few periods where it gets larger. Excluding one outlier in 1987, most of
    the values are within 10 percent, and the vast majority are within 5 percent.
    We would conclude that this seems to be a fairly good model. However, we should
    reserve judgment until we see future results—predictions beyond the data we used
    in the model. We saw in Figure 4.12 that the future prediction was a fairly linear
    upward trend after the end of the data.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到，整个期间的百分比误差非常相似，只有少数几个期间误差增大。除去1987年的一个异常值，大多数值都在10%以内，绝大多数值都在5%以内。我们可以得出结论，这似乎是一个相当不错的模型。然而，在看到未来结果之前，我们应该保留判断——即超出我们用于模型的数据的预测结果。我们在图4.12中看到，数据结束后的未来预测呈现出相当线性的上升趋势。
- en: We'll leave it as an exercise for you to go and get more recent S&P 500 closing
    data and compare this data with the one year prediction from this model. Also,
    we must stress that fully qualifying such a model requires separating out training,
    validation, and test data and performing tests such as cross-validation, which
    will be covered in Chapter 6, Ensemble Modeling. As a teaser, the worst error
    over the year after the data was about 20%, the average error 1.4%, and the error
    at the very end of the forecast period was 0.8%. We must stress that it is very
    challenging to predict stock markets and it might be fortuitous that the forecast
    period was somewhat uniformly positive.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把获取最新的标准普尔500指数收盘数据并将其与此模型的1年预测数据进行比较的任务留给你。我们还必须强调，完全验证这样的模型需要将训练数据、验证数据和测试数据分开，并执行如交叉验证等测试，这将在第6章“集成建模”中详细讲解。作为一个提示，数据后的全年最差误差约为20%，平均误差为1.4%，而预测期结束时的误差为0.8%。我们必须强调，预测股市是非常具有挑战性的，预测期能够保持相对均匀的正增长可能是偶然的。
- en: From this exercise using an autoregression model, we can see that there is significant
    predictive power in using these models even when there is missing data. The autoregression
    model shown for the S&P 500 dataset was able to effectively provide predictions
    within the range of observed samples. However, outside of this range, when predicting
    future values for which no measurements have been taken, the predictive power
    may be somewhat limited. In this particular case, the future predictions seem
    reasonable. Let's now do an exercise that may be more challenging for this type
    of model.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用自回归模型进行此练习，我们可以看到，即使在缺失数据的情况下，使用这些模型也具有显著的预测能力。对S&P 500数据集使用的自回归模型能够有效地在观察样本范围内提供预测。然而，在此范围之外，当预测没有采样数据的未来值时，预测能力可能会有所限制。在这种特定情况下，未来的预测似乎是合理的。接下来，我们将进行一个可能对这种模型类型更具挑战性的练习。
- en: 'Activity 4.01: Autoregression Model Based on Periodic Data'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '活动4.01: 基于周期数据的自回归模型'
- en: In this activity, we will now use an autoregression model to fit the Austin
    weather dataset and predict future values. This data has different characteristics
    to the stock market data and will illustrate some of the challenges associated
    with applying autoregression.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们将使用自回归模型来拟合奥斯汀天气数据集并预测未来值。该数据与股票市场数据具有不同的特征，将展示应用自回归模型时面临的一些挑战。
- en: 'The steps to be performed are as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行的步骤如下：
- en: Import the packages and classes needed. As in the stock market exercise, we
    need pandas, numpy, the AR function from statsmodels.tsa.ar_model, the plot_acf
    function from statsmodels.graphics.tsaplots, and, of course, matplotlib.pyplot.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 导入所需的包和类。与股票市场练习一样，我们需要pandas、numpy、来自statsmodels.tsa.ar_model的AR函数、来自statsmodels.graphics.tsaplots的plot_acf函数，以及当然的matplotlib.pyplot。
- en: Load the Austin weather data (austin_weather.csv) and convert the Date column
    to datetime as before.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 加载奥斯汀天气数据（austin_weather.csv），并将日期列转换为datetime格式，如之前所示。
- en: Plot the complete set of average temperature values (df.TempAvgF) with Date
    on the x axis.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制完整的平均温度值集（df.TempAvgF），横坐标为日期。
- en: 'The output should be as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 4.13: Plot of Austin temperature data over several years'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13: 奥斯汀温度数据的多年绘图'
- en: '](img/image-SKT3FCRF.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-SKT3FCRF.jpg)'
- en: 'Figure 4.13: Plot of Austin temperature data over several years'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.13: 奥斯汀温度数据的多年绘图'
- en: Construct an autocorrelation plot to see whether the average temperature can
    be used with an autoregression model. Consider how this plot is different from
    Exercise 4.01, Creating an Autoregression Model and why.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自相关图，以查看平均温度是否可以与自回归模型一起使用。考虑此图与练习4.01“创建自回归模型”之间的差异，并思考其原因。
- en: 'The plot should be as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图应如下所示：
- en: '![Figure 4.14: Autocorrelation versus lag (days)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14: 自相关与滞后（天数）'
- en: '](img/image-T3T8I21O.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-T3T8I21O.jpg)'
- en: 'Figure 4.14: Autocorrelation versus lag (days)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.14: 自相关与滞后（天数）'
- en: Extract the actual ACF values using the numpy.correlate() function as in Exercise
    4.01, Creating an Autoregression Model.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用numpy.correlate()函数提取实际的ACF值，如练习4.01“创建自回归模型”中所示。
- en: Use the same plot_lag_grid function to investigate the correlation versus the
    lag plots at various correlation values. Consider the fact that the raw data obviously
    repeats on a period of around 365 days, but also that an autocorrelation model
    might not be effective at such long lags. Look at both short and long lags and
    understand the data.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的plot_lag_grid函数来研究不同相关值下的相关性与滞后图。考虑到原始数据显然在大约365天的周期上重复，并且自相关模型在如此长的滞后期下可能不太有效。查看短期和长期滞后，并理解数据。
- en: 'The output for short lags will be as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 短滞后期的输出将如下所示：
- en: '![Figure 4.15: Lag plots with short lags'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15: 短滞后期的滞后图'
- en: '](img/image-LHD2ZM0J.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-LHD2ZM0J.jpg)'
- en: 'Figure 4.15: Lag plots with short lags'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.15: 短滞后期的滞后图'
- en: 'The output for longer lags will be as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 较长滞后期的输出将如下所示：
- en: '![Figure 4.16: Lag plots with longer lags'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16: 较长滞后期的滞后图'
- en: '](img/image-J453E1BA.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-J453E1BA.jpg)'
- en: 'Figure 4.16: Lag plots with longer lags'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.16: 较长滞后期的滞后图'
- en: Use the statsmodelsAR function and the model.fit() method to model the data.
    Get the maximum model lag from the model.fit() method. Print the coefficients.
    How many terms are used (by default) in this case?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用statsmodelsAR函数和model.fit()方法对数据进行建模。从model.fit()方法中获取最大模型滞后期。打印系数。默认情况下使用了多少项？
- en: Use a maximum forecast period of 365 days (ask—why is this reasonable?) and
    generate predictions from the model. Using the same methods as before, match the
    correct dates to the predictions so that we can visualize them on the same plot
    as the raw data.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用365天的最大预测期（问：为什么这是合理的？）并生成模型预测结果。使用之前相同的方法，将正确的日期与预测结果匹配，这样我们就能将它们与原始数据一起可视化。
- en: Plot the predictions (including the 365-day forecast), as well as the original dataset.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制预测结果（包括365天的预测），以及原始数据集。
- en: 'The results should look as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应如下所示：
- en: '![Figure 4.17: Austin temperature data, in-data predictions, and out-of-data
    forecast'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17：奥斯汀温度数据、内数据预测与外数据预测'
- en: '](img/image-438S91VR.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-438S91VR.jpg)'
- en: 'Figure 4.17: Austin temperature data, in-data predictions, and out-of-data
    forecast'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：奥斯汀温度数据、内数据预测与外数据预测
- en: '![Figure 4.18: Detail of predictions near the end of the data'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18：数据末尾附近预测的详细信息'
- en: '](img/image-2IE532XU.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/image-2IE532XU.jpg)'
- en: 'Figure 4.18: Detail of predictions near the end of the data'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18：数据末尾附近预测的详细信息
- en: We can see from Figure 4.18 that, as in the stock market case, the predictions
    in the range of the data used to fit the model are good. However, the future predictions
    don't seem nearly as good. They start on a reasonable trend, but then level off
    to a value that clearly isn't correct for some of the forecast period. This is
    a great example of the limits of autoregression models; they may be very effective
    for hard-to-predict series over short time periods, but the long term may be significantly
    in error. The only way to rigorously evaluate such a model before trusting it
    in production is to use the methods in Chapter 6, Ensemble Modeling.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从图 4.18 看出，正如股市案例中所示，用于拟合模型的数据范围内的预测效果良好。然而，未来的预测似乎并不那么理想。它们在合理的趋势上起步，但随后趋于一个明显不准确的值，持续到部分预测期。这是自回归模型局限性的一个很好的例子；它们可能在短期内对难以预测的序列非常有效，但长期预测可能会出现显著误差。要在信任此类模型之前严格评估它们，唯一的方法是使用第六章中的集成建模方法。
- en: Note
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意事项
- en: The solution for this activity can be found via this link.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解答可以通过以下链接找到。
- en: In this section, we've used a variety of tools such as autocorrelation, lag
    plots, and autoregression to build a predictive model for a time series. Such
    models are fast to build, can work well on univariate data (where we have no x
    values other than time), and can provide good short-range predictions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们使用了自相关、滞后图和自回归等多种工具，构建了一个时间序列的预测模型。这些模型构建速度快，对于单变量数据（只有时间作为x变量时）效果良好，且能提供较好的短期预测。
- en: We have explored autoregression models as an alternative to linear regression
    models for time series data. Autoregression models can be very useful for univariate
    time series where we don't have any underlying model, or obvious predictors we
    can use for the x variables. Autoregression is most widely used in time series,
    and particularly in economic or financial modeling where we consider the series
    to be stochastic or a random variable. We have seen that, in certain cases, autoregression
    models can be extremely powerful, but that these models can be limited in cases
    where there is periodic or other non-constant behaviors versus time. Fundamentally,
    this limitation is due to autoregression being a linear combination of past values,
    so the future predictions are always reflective of the recent past. In general,
    autoregression models are most useful for relatively short-term predictions, although the
    definition of short term can be quite relative.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了自回归模型，作为时间序列数据中线性回归模型的替代方案。自回归模型对于没有底层模型或明显预测变量的单变量时间序列非常有用。在经济或金融建模中，自回归广泛应用，尤其是当我们认为序列是随机的或是随机变量时。我们已经看到，在某些情况下，自回归模型可以非常强大，但在存在周期性或其他非恒定时间行为的情况下，这些模型可能受到限制。根本原因是，自回归模型是过去值的线性组合，因此未来的预测总是反映了近期的过去。通常，自回归模型最适合用于相对短期的预测，尽管“短期”的定义是相对的。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have investigated the use of autoregression models, which
    predict future values based on the temporal behavior of prior data in the series.
    Using autoregression modeling, we were able to accurately model the closing price
    of the S&P 500 over the years 1986 to 2018 and a year into the future. On the
    other hand, the performance of autoregression modeling to predict annually periodic
    temperature data for Austin, Texas, seemed more limited.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了自回归模型的使用，该模型根据序列中先前数据的时间行为预测未来值。通过使用自回归建模，我们能够准确地建模1986年到2018年期间以及未来一年的标准普尔500指数收盘价。另一方面，自回归模型在预测德克萨斯州奥斯汀的年度周期性温度数据时，表现似乎更为有限。
- en: Now that we have experience with regression problems, we will turn our attention
    to classification problems in the next chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了回归问题的经验，我们将在下一章转向分类问题。
