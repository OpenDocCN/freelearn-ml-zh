- en: High-Performance Machine Learning – NumPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高性能机器学习——NumPy
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: NumPy basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy基础
- en: Loading the iris dataset
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载鸢尾花数据集
- en: Viewing the iris dataset
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看鸢尾花数据集
- en: Viewing the iris dataset with pandas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pandas查看鸢尾花数据集
- en: Plotting with NumPy and matplotlib
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NumPy和matplotlib绘图
- en: A minimal machine learning recipe – SVM classification
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小机器学习示例——SVM分类
- en: Introducing cross-validation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入交叉验证
- en: Putting it all together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: Machine learning overview – classification versus regression
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习概述——分类与回归
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we'll learn how to make predictions with scikit-learn. Machine
    learning emphasizes on measuring the ability to predict, and with scikit-learn
    we will predict accurately and quickly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用scikit-learn进行预测。机器学习强调衡量预测能力，而使用scikit-learn我们可以准确快速地进行预测。
- en: 'We will examine the `iris` dataset, which consists of measurements of three
    types of Iris flowers: *Iris S**etosa*, *Iris V**ersicolor*, and *Iris Virginica*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查`iris`数据集，它包含三种鸢尾花类型的测量数据：*Iris Setosa*、*Iris Versicolor* 和 *Iris Virginica*。
- en: 'To measure the strength of the predictions, we will:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了衡量预测的强度，我们将：
- en: Save some data for testing
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存一些数据以供测试
- en: Build a model using only training data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用训练数据构建模型
- en: Measure the predictive power on the test set
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量在测试集上的预测能力
- en: The prediction—one of three flower types is categorical. This type of problem
    is called a **classification problem**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 预测——三种花卉类型中的一种是分类的。这类问题称为**分类问题**。
- en: Informally, classification asks, *Is it an apple or an orange?* Contrast this
    with machine learning regression, which asks, *How many apples?* By the way, the
    answer can be *4.5 apples* for regression.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地说，分类问的是，*它是苹果还是橙子？*与此对比，机器学习回归问题问的是，*有多少个苹果？*顺便说一下，回归问题的答案可以是*4.5个苹果*。
- en: 'By the evolution of its design, scikit-learn addresses machine learning mainly
    via four categories:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其设计的演变，scikit-learn主要通过四个类别来解决机器学习问题：
- en: 'Classification:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类：
- en: Non-text classification, like the Iris flowers example
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非文本分类，例如鸢尾花的例子
- en: Text classification
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本分类
- en: Regression
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归
- en: Clustering
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类
- en: Dimensionality reduction
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降维
- en: NumPy basics
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy基础
- en: Data science deals in part with structured tables of data. The `scikit-learn`
    library requires input tables of two-dimensional NumPy arrays. In this section,
    you will learn about the `numpy` library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学部分处理结构化数据表。`scikit-learn`库要求输入表格是二维NumPy数组。在本节中，你将了解`numpy`库。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will try a few operations on NumPy arrays. NumPy arrays have a single type
    for all of their elements and a predefined shape. Let us look first at their shape.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对NumPy数组进行一些操作。NumPy数组的所有元素具有相同的数据类型，并且具有预定义的形状。让我们首先查看它们的形状。
- en: The shape and dimension of NumPy arrays
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy数组的形状和维度
- en: 'Start by importing NumPy:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先导入NumPy：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Produce a NumPy array of 10 digits, similar to Python''s `range(10)` method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个包含10个数字的NumPy数组，类似于Python的`range(10)`方法：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The array looks like a Python list with only one pair of brackets. This means
    it is of one dimension. Store the array and find out the shape:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组看起来像一个只有一对括号的Python列表。这意味着它是单维的。存储数组并找出它的形状：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The array has a data attribute, `shape`. The type of `array_1.shape` is a tuple `(10L,)`,
    which has length `1`, in this case. The number of dimensions is the same as the
    length of the tuple—a dimension of `1`, in this case:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组具有一个数据属性，`shape`。`array_1.shape`的类型是元组`(10L,)`，它的长度为`1`，在本例中是这样。维度的数量与元组的长度相同——在本例中是`1`维：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The array has 10 elements. Reshape the array by calling the `reshape` method:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组有10个元素。通过调用`reshape`方法重塑数组：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This reshapes the array into 5 x 2 data object that resembles a list of lists
    (a three dimensional NumPy array looks like a list of lists of lists). You did
    not save the changes. Save the reshaped array as follows::'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将把数组重塑为5 x 2的数据对象，类似于列表的列表（三维NumPy数组看起来像是列表的列表的列表）。你没有保存更改。请按以下方式保存重塑后的数组：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that `array_1` is now two-dimensional. This is expected, as its shape
    has two numbers and it looks like a Python list of lists:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`array_1`现在是二维的。这是预期的，因为它的形状有两个数字，看起来像是一个Python的列表的列表：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: NumPy broadcasting
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy广播
- en: 'Add `1` to every element of the array by broadcasting. Note that changes to
    the array are not saved:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过广播将`1`添加到数组的每个元素中。请注意，数组的更改没有保存：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The term **broadcasting** refers to the smaller array being stretched or broadcast
    across the larger array. In the first example, the scalar `1` was stretched to
    a 5 x 2 shape and then added to `array_1`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播**这个术语指的是将较小的数组扩展或广播到较大的数组上。在第一个示例中，标量 `1` 被扩展为一个 5 x 2 的形状，并与 `array_1`
    相加。'
- en: 'Create a new `array_2` array. Observe what occurs when you multiply the array
    by itself (this is not matrix multiplication; it is element-wise multiplication
    of arrays):'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `array_2` 数组。观察当你将数组与自身相乘时会发生什么（这不是矩阵乘法；而是数组的逐元素乘法）：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Every element has been squared. Here, element-wise multiplication has occurred.
    Here is a more complicated example:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个元素都已被平方。这里发生了逐元素乘法。下面是一个更复杂的例子：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Change `array_1` as well:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也修改 `array_1`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now add `array_1` and `array_2` element-wise by simply placing a plus sign
    between the arrays:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过简单地将数组之间加上加号来逐元素地将 `array_1` 和 `array_2` 相加：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The formal broadcasting rules require that whenever you are comparing the shapes
    of both arrays from right to left, all the numbers have to either match or be
    one. The shapes **5 X 2** and **5 X 2** match for both entries from right to left.
    However, the shape **5 X 2 X 1** does not match **5 X 2**, as the second values
    from the right, **2** and **5** respectively, are mismatched:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正式的广播规则要求，当你比较两个数组的形状时，从右到左，所有的数字必须匹配或为 1。形状为**5 X 2**和**5 X 2**的两个数组从右到左都匹配。然而，形状为**5
    X 2 X 1**与**5 X 2**不匹配，因为从右到左的第二个值，分别是**2**和**5**，不匹配：
- en: '![](img/862cc6cc-1c37-433c-870d-70f656a4da57.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/862cc6cc-1c37-433c-870d-70f656a4da57.jpg)'
- en: Initializing NumPy arrays and dtypes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 NumPy 数组和数据类型
- en: 'There are several ways to initialize NumPy arrays besides `np.arange`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `np.arange`，还有多种方法可以初始化 NumPy 数组：
- en: 'Initialize an array of zeros with `np.zeros`. The `np.zeros((5,2))` command creates
    a 5 x 2 array of zeros:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.zeros` 初始化一个全为零的数组。`np.zeros((5,2))` 命令创建一个 5 x 2 的零数组：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Initialize an array of ones using `np.ones`. Introduce a `dtype` argument, set
    to `np.int`, to ensure that the ones are of NumPy integer type. Note that scikit-learn
    expects `np.float` arguments in arrays. The `dtype` refers to the type of every
    element in a NumPy array. It remains the same throughout the array. Every single
    element of the array below has a np.int integer type.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.ones` 初始化一个全为 1 的数组。引入 `dtype` 参数，设置为 `np.int`，以确保这些 1 为 NumPy 整型。注意，scikit-learn
    期望数组中的 `dtype` 为 `np.float` 类型。`dtype` 指的是 NumPy 数组中每个元素的类型，它在整个数组中保持一致。下面数组的每个元素都是
    `np.int` 类型。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use `np.empty` to allocate memory for an array of a specific size and `dtype`,
    but no particular initialized values:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.empty` 为特定大小和 `dtype` 的数组分配内存，但不初始化特定值：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Use `np.zeros`, `np.ones`, and `np.empty` to allocate memory for NumPy arrays
    with different initial values.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`np.zeros`、`np.ones`和`np.empty`为 NumPy 数组分配不同初始值的内存。
- en: Indexing
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: 'Look up the values of the two-dimensional arrays with indexing:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用索引查找二维数组的值：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'View the first row:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看第一行：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then view the first column:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后查看第一列：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'View specific values along both axes. Also view the second to the fourth rows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看沿两个轴的特定值。同时查看第二行到第四行：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'View the second to the fourth rows only along the first column:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅查看第一列的第二行到第四行：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Boolean arrays
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔数组
- en: 'Additionally, NumPy handles indexing with Boolean logic:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，NumPy 还使用布尔逻辑来处理索引：
- en: 'First produce a Boolean array:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先生成一个布尔数组：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Place brackets around the Boolean array to filter by the Boolean array:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布尔数组加上括号，以便通过布尔数组进行过滤：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Arithmetic operations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算
- en: 'Add all the elements of the array with the `sum` method. Go back to `array_1`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sum` 方法将数组的所有元素相加。回到 `array_1`：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Find all the sums by row:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按行求和：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Find all the sums by column:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按列求和：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Find the mean of each column in a similar way. Note that the `dtype` of the
    array of averages is `np.float`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式求每一列的均值。注意，均值数组的`dtype`为`np.float`：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: NaN values
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NaN 值
- en: 'Scikit-learn will not accept `np.nan` values. Take `array_3` as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Scikit-learn 不接受 `np.nan` 值。假设有如下的 `array_3`：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Find the NaN values with a special Boolean array created by the `np.isnan`
    function:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `np.isnan` 函数创建一个特殊的布尔数组来查找 NaN 值：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Filter the NaN values by negating the Boolean array with the symbol ~ and placing
    brackets around the expression:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过否定布尔数组并在表达式周围加上括号来过滤 NaN 值：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, set the NaN values to zero:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法是将 NaN 值设置为零：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Data, in the present and minimal sense, is about 2D tables of numbers, which
    NumPy handles very well. Keep this in mind in case you forget the NumPy syntax
    specifics. Scikit-learn accepts only 2D NumPy arrays of real numbers with no missing `np.nan` values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 数据，在目前的最简意义上，是指由数字组成的二维表格，NumPy 对此处理得非常好。记住这一点，以防你忘记了 NumPy 的语法细节。Scikit-learn
    仅接受没有缺失值（`np.nan`）的二维 NumPy 数组。
- en: From experience, it tends to be best to change `np.nan` to some value instead
    of throwing away data. Personally, I like to keep track of Boolean masks and keep
    the data shape roughly the same, as this leads to fewer coding errors and more
    coding flexibility.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验，最好是将 `np.nan` 更改为某个值，而不是丢弃数据。就个人而言，我喜欢追踪布尔掩码，并保持数据形状大致不变，因为这样可以减少编码错误并提高编码灵活性。
- en: Loading the iris dataset
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载 iris 数据集
- en: To perform machine learning with scikit-learn, we need some data to start with.
    We will load the `iris` dataset, one of the several datasets available in scikit-learn.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 scikit-learn 进行机器学习，我们需要一些数据作为起点。我们将加载 `iris` 数据集，它是 scikit-learn 中几个数据集之一。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A scikit-learn program begins with several imports. Within Python, preferably
    in Jupyter Notebook, load the `numpy`, `pandas`, and `pyplot` libraries:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 scikit-learn 程序开始时会有多个导入。在 Python 中，最好在 Jupyter Notebook 中加载 `numpy`、`pandas`
    和 `pyplot` 库：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you are within a Jupyter Notebook, type the following to see a graphical
    output instantly:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Jupyter Notebook 中，输入以下内容即可立即查看图形输出：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'From the scikit-learn `datasets` module, access the `iris` dataset:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 scikit-learn 的 `datasets` 模块中，访问 `iris` 数据集：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Similarly, you could have imported the `diabetes` dataset as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以通过以下方式导入 `diabetes` 数据集：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There! You''ve loaded `diabetes` using the `load_diabetes()` function of the
    `datasets` module. To check which datasets are available, type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 看！你已经使用 `datasets` 模块中的 `load_diabetes()` 函数加载了 `diabetes` 数据集。要查看可用的数据集，输入：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once you try that, you might observe that there is a dataset named `datasets.load_digits`.
    To access it, type the `load_digits()` function, analogous to the other loading
    functions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你尝试这个，你可能会发现有一个名为 `datasets.load_digits` 的数据集。要访问它，输入 `load_digits()` 函数，类似于其他加载函数：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To view information about the dataset, type `digits.DESCR`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看数据集的信息，输入 `digits.DESCR`。
- en: Viewing the iris dataset
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看 iris 数据集
- en: Now that we've loaded the dataset, let's examine what is in it. The `iris` dataset
    pertains to a supervised classification problem.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了数据集，来看看里面有什么内容。`iris` 数据集涉及一个监督分类问题。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To access the observation variables, type:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问观测变量，输入：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This outputs a NumPy array:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出一个 NumPy 数组：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s examine the NumPy array:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查一下 NumPy 数组：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This returns:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This means that the data is 150 rows by 4 columns. Let''s look at the first
    row:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着数据是 150 行 4 列。让我们看看第一行：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The NumPy array for the first row has four numbers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的 NumPy 数组包含四个数字。
- en: 'To determine what they mean, type:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确定它们的含义，输入：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The feature or column names name the data. They are strings, and in this case,
    they correspond to dimensions in different types of flowers. Putting it all together,
    we have 150 examples of flowers with four measurements per flower in centimeters.
    For example, the first flower has measurements of 5.1 cm for sepal length, 3.5
    cm for sepal width, 1.4 cm for petal length, and 0.2 cm for petal width. Now,
    let''s look at the output variable in a similar manner:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 特征或列名表示数据。它们是字符串，在这个例子中，它们对应于不同种类花的不同维度。综合来看，我们有 150 个花的样本，每个花有四个以厘米为单位的测量值。例如，第一个花的测量值为：萼片长度
    5.1 cm，萼片宽度 3.5 cm，花瓣长度 1.4 cm，花瓣宽度 0.2 cm。现在，让我们以类似的方式查看输出变量：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This yields an array of outputs: `0`, `1`, and `2`. There are only three outputs.
    Type this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回一个输出数组：`0`、`1` 和 `2`。只有这三种输出。输入：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You get a shape of:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的形状是：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This refers to an array of length 150 (150 x 1). Let''s look at what the numbers
    refer to:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是长度为 150 的数组（150 x 1）。我们来看看这些数字代表什么：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the `iris.target_names` variable gives the English names for
    the numbers in the `iris.target` variable. The number zero corresponds to the
    `setosa` flower, number one corresponds to the `versicolor` flower, and number
    two corresponds to the `virginica` flower. Look at the first row of `iris.target`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`iris.target_names` 变量的输出给出了 `iris.target` 变量中数字的英文名称。数字零对应于 `setosa` 花，数字一对应于
    `versicolor` 花，数字二对应于 `virginica` 花。看看 `iris.target` 的第一行：'
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This produces zero, and thus the first row of observations we examined before
    correspond to the `setosa` flower.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了零，因此我们之前检查的第一行观测结果对应于`setosa`花。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In machine learning, we often deal with data tables and two-dimensional arrays
    corresponding to examples. In the `iris` set, we have 150 observations of flowers
    of three types. With new observations, we would like to predict which type of
    flower those observations correspond to. The observations in this case are measurements
    in centimeters. It is important to look at the data pertaining to real objects.
    Quoting my high school physics teacher, <q>"*Do not forget the units!*"</q>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中，我们经常处理数据表和二维数组，这些数组对应于样本。在`iris`数据集中，我们有150个观测值，包含三种类型的花。对于新的观测值，我们希望预测这些观测值对应的花种类。这里的观测值是厘米为单位的测量数据。观察与真实物体相关的数据非常重要。引用我高中的物理老师的话，<q>"*不要忘记单位！*</q>"
- en: The `iris` dataset is intended to be for a supervised machine learning task
    because it has a target array, which is the variable we desire to predict from
    the observation variables. Additionally, it is a classification problem, as there
    are three numbers we can predict from the observations, one for each type of flower.
    In a classification problem, we are trying to distinguish between categories.
    The simplest case is binary classification. The `iris` dataset, with three flower
    categories, is a multi-class classification problem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`iris`数据集旨在用于监督式机器学习任务，因为它有一个目标数组，即我们希望从观测变量中预测的变量。此外，它是一个分类问题，因为我们可以从观测值中预测三个数字，每个花的类型对应一个数字。在分类问题中，我们试图区分不同的类别。最简单的情况是二分类。`iris`数据集有三种花类，因此它是一个多类分类问题。'
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With the same data, we can rephrase the problem in many ways, or formulate new
    problems. What if we want to determine relationships between the observations?
    We can define the petal width as the target variable. We can rephrase the problem
    as a regression problem and try to predict the target variable as a real number,
    not just three categories. Fundamentally, it comes down to what we intend to predict.
    Here, we desire to predict a type of flower.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的数据，我们可以用多种方式重新表述问题，或者提出新的问题。如果我们想要确定观测值之间的关系怎么办？我们可以将花瓣宽度定义为目标变量。我们可以将问题重新表述为回归问题，试图将目标变量预测为一个实数，而不仅仅是三个类别。从根本上说，这取决于我们想要预测什么。在这里，我们希望预测一种花的类型。
- en: Viewing the iris dataset with Pandas
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pandas查看`iris`数据集
- en: In this recipe we will use the handy `pandas` data analysis library to view
    and visualize the `iris` dataset. It contains the notion o, a dataframe which
    might be familiar to you if you use the language R's dataframe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用方便的`pandas`数据分析库来查看和可视化`iris`数据集。它包含了概念o，一个数据框（dataframe），如果你使用R语言的数据框，可能会对它有所熟悉。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can view the `iris` dataset with Pandas, a library built on top of NumPy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Pandas查看`iris`数据集，Pandas是一个基于NumPy构建的库：
- en: 'Create a dataframe with the observation variables `iris.data`, and column names `columns`,
    as arguments:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含观测变量`iris.data`的数据框，并以`columns`作为列名：
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The dataframe is more user-friendly than the NumPy array.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框比NumPy数组更易于使用。
- en: 'Look at a quick histogram of the values in the dataframe for `sepal length`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看数据框中`sepal length`值的快速直方图：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![](img/bc06d071-510d-464e-8d01-1b6917d17b23.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc06d071-510d-464e-8d01-1b6917d17b23.jpg)'
- en: 'You can also color the histogram by the `target` variable:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以通过`target`变量为直方图上色：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, iterate through the target numbers for each flower and draw a color histogram
    for each. Consider this line:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，迭代每种花的目标数字，并为每个花绘制一个彩色直方图。考虑这一行：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It finds the NumPy index location for each class of flower:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它找到了每种花类别的NumPy索引位置：
- en: '![](img/fc479efd-c396-4ea0-8faa-2d699d0f84c5.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc479efd-c396-4ea0-8faa-2d699d0f84c5.jpg)'
- en: Observe that the histograms overlap. This encourages us to model the three histograms
    as three normal distributions. This is possible in a machine learning manner if
    we model the training data only as three normal distributions, not the whole set.
    Then we use the test set to test the three normal distribution models we just
    made up. Finally, we test the accuracy of our predictions on the test set.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到直方图有重叠。这鼓励我们将三个直方图建模为三个正态分布。如果我们仅将训练数据建模为三个正态分布而不是整个数据集，这在机器学习中是可行的。然后，我们使用测试集来测试我们刚刚构建的三个正态分布模型。最后，我们在测试集上测试我们预测的准确性。
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The dataframe data object is a 2D NumPy array with column names and row names.
    In data science, the fundamental data object looks like a 2D table, possibly because
    of SQL's long history. NumPy allows for 3D arrays, cubes, 4D arrays, and so on.
    These also come up often.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框架数据对象是一个二维的 NumPy 数组，包含列名和行名。在数据科学中，基本的数据对象看起来像一个二维表格，这可能与 SQL 的悠久历史有关。NumPy
    还支持三维数组、立方体、四维数组等，这些也经常出现。
- en: Plotting with NumPy and matplotlib
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NumPy 和 matplotlib 绘图
- en: A simple way to make visualizations with NumPy is by using the library `matplotlib`.
    Let's make some visualizations quickly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 进行可视化的一个简单方法是使用 `matplotlib` 库。让我们快速创建一些可视化图形。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by importing `numpy` and `matplotlib`. You can view visualizations within
    an IPython Notebook using the `%matplotlib inline` command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 `numpy` 和 `matplotlib`。你可以使用 `%matplotlib inline` 命令在 IPython Notebook
    中查看可视化图形：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The main command in matplotlib, in pseudo code, is as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: matplotlib 中的主要命令，伪代码如下：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Plot a straight line by placing two NumPy arrays of the same length:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过放置两个相同长度的 NumPy 数组来绘制一条直线：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](img/287e1a2e-a723-403f-912a-dc2ab10cfd2c.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/287e1a2e-a723-403f-912a-dc2ab10cfd2c.png)'
- en: 'Plot an exponential:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制指数图：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![](img/df166a79-ba13-48c5-adfa-765233d0aec8.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df166a79-ba13-48c5-adfa-765233d0aec8.png)'
- en: 'Place the two graphs side by side:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个图表并排放置：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or top to bottom:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从上到下：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![](img/490c815b-e265-454c-967b-e7dc4e617bfd.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/490c815b-e265-454c-967b-e7dc4e617bfd.png)'
- en: 'The first two numbers in the subplot command refer to the grid size in the
    figure instantiated by `plt.figure()`. The grid size referred to in `plt.subplot(221)`
    is 2 x 2, the first two digits. The last digit refers to traversing the grid in
    reading order: left to right and then up to down.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 子图命令中的前两个数字表示由 `plt.figure()` 实例化的图形中的网格大小。`plt.subplot(221)` 中提到的网格大小是 2 x
    2，前两个数字表示网格的行列数。最后一个数字表示按阅读顺序遍历网格：从左到右，再从上到下。
- en: 'Plot in a 2 x 2 grid traversing in reading order from one to four:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 2 x 2 网格中绘图，按照从一到四的阅读顺序排列：
- en: '[PRE57]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![](img/b6546b85-8074-4d63-9b2f-66bdadc52305.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6546b85-8074-4d63-9b2f-66bdadc52305.png)'
- en: 'Finally, with real data:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用真实数据：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `c` parameter takes an array of colors—in this case, the colors `0`, `1`,
    and `2` in the `iris` target:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`c` 参数接受一个颜色数组——在此例中为 `iris` 目标中的颜色 `0`、`1` 和 `2`：'
- en: '![](img/975ccab7-6564-4a71-82cd-daee92065546.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/975ccab7-6564-4a71-82cd-daee92065546.png)'
- en: A minimal machine learning recipe – SVM classification
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简化的机器学习配方 – SVM 分类
- en: 'Machine learning is all about making predictions. To make predictions, we will:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习的核心是进行预测。为了进行预测，我们需要：
- en: State the problem to be solved
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陈述要解决的问题
- en: Choose a model to solve the problem
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个模型来解决问题
- en: Train the model
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练模型
- en: Make predictions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行预测
- en: Measure how well the model performed
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量模型的表现
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Back to the iris example, we now store the first two features (columns) of
    the observations as `X` and the target as `y`, a convention in the machine learning
    community:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 回到鸢尾花示例，现在我们将观察数据的前两个特征（列）存储为 `X`，目标存储为 `y`，这是机器学习社区中的惯例：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First, we state the problem. We are trying to determine the flower-type category
    from a set of new observations. This is a classification task. The data available
    includes a target variable, which we have named `y`. This is a supervised classification
    problem.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们陈述问题。我们试图从一组新的观察数据中确定花卉类型类别。这是一个分类任务。可用的数据包括一个目标变量，我们将其命名为 `y`。这属于监督分类问题。
- en: The task of supervised learning involves predicting values of an output variable
    with a model that trains using input variables and an output variable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 监督学习的任务涉及使用输入变量和输出变量训练模型，从而预测输出变量的值。
- en: Next, we choose a model to solve the supervised classification. For now, we
    will use a support vector classifier. Because of its simplicity and interpretability,
    it is a commonly used algorithm (*interpretable* means easy to read into and understand).
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们选择一个模型来解决监督分类问题。目前我们将使用支持向量分类器。由于其简单性和可解释性，它是一个常用的算法（*可解释性*意味着容易阅读和理解）。
- en: 'To measure the performance of prediction, we will split the dataset into training
    and test sets. The training set refers to data we will learn from. The test set
    is the data we hold out and pretend not to know as we would like to measure the
    performance of our learning procedure. So, import a function that will split the
    dataset:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了衡量预测性能，我们将数据集分为训练集和测试集。训练集是我们将从中学习的数据。测试集是我们保留的数据，并假装不知道它，以便衡量我们学习过程的性能。因此，导入一个将数据集拆分的函数：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Apply the function to both the observation and target data:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该函数应用于观察数据和目标数据：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The test size is 0.25 or 25% of the whole dataset. A random state of one fixes
    the random seed of the function so that you get the same results every time you
    call the function, which is important for now to reproduce the same results consistently.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集大小为0.25，即整个数据集的25%。一个随机状态值1固定了函数的随机种子，使得每次调用该函数时都能得到相同的结果，这对现在保持结果一致性非常重要。
- en: 'Now load a regularly used estimator, a support vector machine:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在加载一个常用的估算器——支持向量机：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You have imported a support vector classifier from the `svm` module. Now create
    an instance of a linear SVC:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经从`svm`模块导入了支持向量分类器。现在创建一个线性SVC的实例：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The random state is fixed to reproduce the same results with the same code later.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 随机状态被固定，以便以后使用相同的代码重现相同的结果。
- en: 'The supervised models in scikit-learn implement a `fit(X, y)` method, which
    trains the model and returns the trained model. `X` is a subset of the observations,
    and each element of `y` corresponds to the target of each observation in `X`.
    Here, we fit a model on the training data:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn中的监督学习模型实现了一个`fit(X, y)`方法，用于训练模型并返回训练好的模型。`X`是观察数据的子集，`y`的每个元素对应于`X`中每个观察数据的目标。在这里，我们在训练数据上拟合了一个模型：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, the `clf` variable is the fitted, or trained, model.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`clf`变量是已经拟合或训练好的模型。
- en: 'The estimator also has a `predict(X)` method that returns predictions for several
    unlabeled observations, `X_test`, and returns the predicted values, `y_pred`.
    Note that the function does not return the estimator. It returns a set of predictions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 估算器还有一个`predict(X)`方法，该方法会对多个未标记的观察数据`X_test`进行预测，并返回预测值`y_pred`。请注意，该函数不会返回估算器本身，而是返回一组预测值：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'So far, you have done all but the last step. To examine the model performance,
    load a scorer from the metrics module:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经完成了除最后一步以外的所有步骤。为了检查模型的表现，加载一个来自指标模块的评分器：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With the scorer, compare the predictions with the held-out test targets:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用评分器，将预测结果与保留的测试目标进行比较：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Without knowing very much about the details of support vector machines, we have
    implemented a predictive model. To perform machine learning, we held out one-fourth
    of the data and examined how the SVC performed on that data. In the end, we obtained
    a number that measures accuracy, or how the model performed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对支持向量机的细节了解不多，我们也已经实现了一个预测模型。为了进行机器学习，我们保留了四分之一的数据，并检查了SVC在这些数据上的表现。最终，我们得到了一个衡量准确度的数值，或者说衡量模型表现的数值。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容……
- en: 'To summarize, we will do all the steps with a different algorithm, logistic
    regression:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们将用不同的算法——逻辑回归——来执行所有步骤：
- en: 'First, import `LogisticRegression`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`LogisticRegression`：
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then write a program with the modeling steps:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后编写一个包含建模步骤的程序：
- en: Split the data into training and testing sets.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据分为训练集和测试集。
- en: Fit the logistic regression model.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拟合逻辑回归模型。
- en: Predict using the test observations.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用测试观察数据进行预测。
- en: 'Measure the accuracy of the predictions with `y_test` versus `y_pred`:'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`y_test`与`y_pred`来衡量预测的准确性：
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This number is lower; yet we cannot make any conclusions comparing the two models,
    SVC and logistic regression classification. We cannot compare them, because we
    were not supposed to look at the test set for our model. If we made a choice between
    SVC and logistic regression, the choice would be part of our model as well, so
    the test set cannot be involved in the choice. Cross-validation, which we will
    look at next, is a way to choose between models.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数值较低；然而，我们无法在支持向量分类（SVC）与逻辑回归分类模型之间做出结论。我们无法比较它们，因为我们不应该查看模型的测试集。如果我们在SVC和逻辑回归之间做出选择，那么该选择也将成为我们模型的一部分，因此测试集不能参与选择。交叉验证，我们接下来将要介绍的，是一种选择模型的方法。
- en: Introducing cross-validation
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入交叉验证
- en: We are thankful for the `iris` dataset, but as you might recall, it has only
    150 observations. To make the most out of the set, we will employ cross-validation.
    Additionally, in the last section, we wanted to compare the performance of two
    different classifiers, support vector classifier and logistic regression. Cross-validation
    will help us with this comparison issue as well.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感谢`iris`数据集，但正如你所记得的，它只有150个观测值。为了最大限度地利用这个数据集，我们将使用交叉验证。此外，在上一部分中，我们想比较两种不同分类器的性能——支持向量分类器和逻辑回归。交叉验证将帮助我们解决这个比较问题。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Suppose we wanted to choose between the support vector classifier and the logistic
    regression classifier. We cannot measure their performance on the unavailable
    test set.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在支持向量分类器和逻辑回归分类器之间做选择。我们不能在不可用的测试集上衡量它们的表现。
- en: 'What if, instead, we:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们改为：
- en: Forgot about the test set for now?
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在忘记测试集了吗？
- en: Split the training set into two parts, one to train on and one to test the training?
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将训练集拆分成两部分，一部分用于训练，另一部分用于测试训练结果？
- en: 'Split the training set into two parts using the train_test_split function used
    in previous sections:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前部分中提到的`train_test_split`函数将训练集拆分为两部分：
- en: '[PRE70]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`X_train_2` consists of 75% of the `X_train` data, while `X_test_2` is the
    remaining 25%. `y_train_2` is 75% of the target data, and matches the observations
    of `X_train_2`. `y_test_2` is 25% of the target data present in `y_train`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`X_train_2`包含`X_train`数据的75%，而`X_test_2`是剩下的25%。`y_train_2`是目标数据的75%，并与`X_train_2`的观测值相匹配。`y_test_2`是`y_train`中25%的目标数据。'
- en: 'As you might have expected, you have to use these new splits to choose between
    the two models: SVC and logistic regression. Do so by writing a predictive program.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预料的，你必须使用这些新的拆分来在两个模型之间做选择：SVC和逻辑回归。通过编写一个预测程序来实现这一点。
- en: How to do it...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Start with all the imports and load the `iris` dataset:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从导入所有库并加载`iris`数据集开始：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create an instance of an SVC classifier and fit it:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个SVC分类器实例并进行拟合：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Do the same for logistic regression (both lines for logistic regression are
    compressed into one):'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对逻辑回归做相同操作（逻辑回归的两行代码压缩成一行）：
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now predict and examine the SVC and logistic regression''s performance on `X_test_2`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在预测并检查SVC和逻辑回归在`X_test_2`上的表现：
- en: '[PRE74]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The SVC performs better, but we have not yet seen the original test data. Choose
    SVC over logistic regression and try it on the original test set:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SVC的表现更好，但我们还没有看到原始的测试数据。选择SVC而非逻辑回归，并尝试在原始测试集上进行测试：
- en: '[PRE75]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In comparing the SVC and logistic regression classifier, you might wonder (and
    be a little suspicious) about a lot of scores being very different. The final
    test on SVC scored lower than logistic regression. To help with this situation,
    we can do cross-validation in scikit-learn.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较SVC和逻辑回归分类器时，你可能会感到疑惑（甚至有些怀疑），因为它们的得分差异很大。最终SVC的测试得分低于逻辑回归。为了解决这个问题，我们可以在scikit-learn中进行交叉验证。
- en: 'Cross-validation involves splitting the training set into parts, as we did
    before. To match the preceding example, we split the training set into four parts,
    or folds. We are going to design a cross-validation iteration by taking turns
    with one of the four folds for testing and the other three for training. It is
    the same split as done before four times over with the same set, thereby rotating,
    in a sense, the test set:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉验证涉及将训练集拆分为多个部分，就像我们之前做的一样。为了与前面的示例相匹配，我们将训练集拆分为四个部分或折叠。我们将通过轮流选取其中一个折叠作为测试集，其他三个折叠作为训练集，来设计一个交叉验证迭代。这与之前的拆分相同，只不过进行了四次轮换，从某种意义上来说，测试集在四个折叠中轮换：
- en: '![](img/f1e7c4be-773e-49cb-9291-1b06a0b75050.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1e7c4be-773e-49cb-9291-1b06a0b75050.jpg)'
- en: 'With scikit-learn, this is relatively easy to accomplish:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用scikit-learn，这个操作相对容易实现：
- en: 'We start with an import:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个导入开始：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then we produce an accuracy score on four folds:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在四个折叠上生成准确度评分：
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can find the mean for average performance and standard deviation for a measure
    of spread of all scores relative to the mean:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以找到平均表现的均值和所有得分相对于均值的标准差来衡量得分的分布情况：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Similarly, with the logistic regression instance, we compute four scores:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，对于逻辑回归实例，我们计算出四个得分：
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now we have many scores, which confirms our selection of SVC over logistic regression.
    Thanks to cross-validation, we used the training multiple times and had four small
    test sets within it to score our model.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了多个得分，这证实了我们选择SVC而非逻辑回归。由于交叉验证，我们多次使用训练集，并且在其中有四个小的测试集来评分我们的模型。
- en: 'Note that our model is a bigger model that consists of:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的模型是一个更大的模型，包含以下内容：
- en: Training an SVM through cross-validation
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交叉验证训练SVM
- en: Training a logistic regression through cross-validation
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交叉验证训练逻辑回归
- en: Choosing between SVM and logistic regression
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SVM和逻辑回归之间做选择
- en: The choice at the end is part of the model.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的选择是模型的一部分。
- en: There's more...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Despite our hard work and the elegance of the scikit-learn syntax, the score
    on the test set at the very end remains suspicious. The reason for this is that
    the test and train split are not necessarily balanced; the train and test sets
    do not necessarily have similar proportions of all the classes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们付出了很多努力，并且scikit-learn语法非常优雅，但最终测试集上的得分仍然令人怀疑。原因在于测试集和训练集的划分未必平衡；训练集和测试集中的各个类别的比例可能不同。
- en: 'This is easily remedied by using a stratified test-train split:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用分层的测试-训练划分，可以轻松解决这个问题：
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: By selecting the target set as the stratified argument, the target classes are
    balanced. This brings the SVC scores closer together.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将目标集选择为分层参数，目标类别会被平衡。这样可以使SVC的得分更接近。
- en: '[PRE81]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Additionally, note that in the preceding example, the cross-validation procedure
    produces stratified folds by default:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在前面的示例中，交叉验证过程默认会生成分层折叠：
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The preceding code is equivalent to:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码等价于：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Putting it all together
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切结合起来
- en: 'Now, we are going to perform the same procedure as before, except that we will
    reset, regroup, and try a new algorithm: **K-Nearest Neighbors** (**KNN**).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将执行与之前相同的步骤，只不过这次我们将重置、重新分组，并尝试一种新的算法：**K最近邻**（**KNN**）。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Start by importing the model from `sklearn`, followed by a balanced split:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`sklearn`导入模型，然后进行平衡划分：
- en: '[PRE84]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `random_state` parameter fixes the `random_seed` in the function `train_test_split`.
    In the preceding example, the `random_state` is set to zero and can be set to
    any integer.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_state`参数在`train_test_split`函数中固定了`random_seed`。在前面的示例中，`random_state`被设置为零，可以设置为任何整数。'
- en: 'Construct two different KNN models by varying the `n_neighbors` parameter.
    Observe that the number of folds is now 10\. Tenfold cross-validation is common
    in the machine learning community, particularly in data science competitions:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过改变`n_neighbors`参数构建两个不同的KNN模型。请注意，折叠次数现在为10。十折交叉验证在机器学习领域中非常常见，尤其是在数据科学竞赛中：
- en: '[PRE85]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Score and print out the scores for selection:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评分并打印出选择的得分：
- en: '[PRE86]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Both nearest neighbor types score similarly, yet the KNN with parameter `n_neighbors
    = 5` is a bit more stable. This is an example of *hyperparameter optimization* which
    we will examine closely throughout the book.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 两种最近邻类型的得分相似，但参数为`n_neighbors = 5`的KNN略微更稳定。这是一个*超参数优化*的例子，我们将在本书中仔细研究这一点。
- en: There's more...
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You could have just as easily run a simple loop to score the function more
    quickly:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你本来也可以简单地运行一个循环，更快地对函数进行评分：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Its output suggests that `n_neighbors = 4` is a good choice:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出表明，`n_neighbors = 4`是一个不错的选择：
- en: '[PRE88]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Machine learning overview – classification versus regression
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器学习概述 – 分类与回归
- en: In this recipe we will examine how regression can be viewed as being very similar
    to classification. This is done by reconsidering the categorical labels of regression
    as real numbers. In this section we will also look at at several aspects of machine
    learning from a very broad perspective including the purpose of scikit-learn.
    scikit-learn allows us to find models that work well incredibly quickly. We do
    not have to work out all the details of the model, or optimize, until we found
    one that works well. Consequently, your company saves precious development time
    and computational resources thanks to scikit-learn giving us the ability to develop
    models relatively quickly.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇中，我们将探讨如何将回归视为与分类非常相似。这是通过将回归的类别标签重新考虑为实数来实现的。在本节中，我们还将从非常广泛的角度来看待机器学习的多个方面，包括scikit-learn的目的。scikit-learn使我们能够非常快速地找到有效的模型。我们不需要一开始就详细地推导出所有模型的细节，也不需要优化，直到找到一个表现良好的模型。因此，得益于scikit-learn的高效性，你的公司可以节省宝贵的开发时间和计算资源。
- en: The purpose of scikit-learn
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: scikit-learn的目的
- en: As we have seen before, scikit-learn allowed us to find a model that works fairly
    quickly. We tried SVC, logistic regression, and a few KNN classifiers. Through
    cross-validation, we selected models that performed better than others. In industry,
    after trying SVMs and logistic regression, we might focus on SVMs and optimize
    them further. Thanks to scikit-learn, we saved a lot of time and resources, including
    mental energy. After optimizing the SVM at work on a realistic dataset, we might
    re-implement it for speed in Java or C and gather more data.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，scikit-learn允许我们相对快速地找到有效的模型。我们尝试了SVC、逻辑回归和一些KNN分类器。通过交叉验证，我们选择了表现更好的模型。在实际应用中，经过尝试SVM和逻辑回归后，我们可能会专注于SVM并进一步优化它们。多亏了scikit-learn，我们节省了大量时间和资源，包括精力。在工作中对现实数据集优化了SVM后，我们可能会为提高速度而在Java或C中重新实现它，并收集更多的数据。
- en: Supervised versus unsupervised
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监督学习与无监督学习
- en: Classification and regression are supervised, as we know the target variables
    for the observations. Clustering—creating regions in space for each category without
    being given any labels is unsupervised learning.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 分类和回归是监督学习，因为我们知道观测数据的目标变量。聚类——在空间中为每个类别创建区域而不给予标签，是无监督学习。
- en: Getting ready
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好
- en: In classification, the target variable is one of several categories, and there
    must be more than one instance of every category. In regression, there can be
    only one instance of every target variable, as the only requirement is that the
    target is a real number.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在分类中，目标变量是多个类别之一，并且每个类别必须有多个实例。在回归中，每个目标变量只能有一个实例，因为唯一的要求是目标是一个实数。
- en: In the case of logistic regression, we saw previously that the algorithm first
    performs a regression and estimates a real number for the target. Then the target
    class is estimated by using thresholds. In scikit-learn, there are `predict_proba`
    methods that yield probabilistic estimates, which relate regression-like real
    number estimates with classification classes in the style of logistic regression.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑回归的情况下，我们之前看到，算法首先执行回归并为目标估算一个实数。然后，通过使用阈值来估计目标类别。在scikit-learn中，有`predict_proba`方法，它提供概率估算，将类似回归的实数估算与逻辑回归风格的分类类别关联起来。
- en: Any regression can be turned into classification by using thresholds. A binary
    classification can be viewed as a regression problem by using a regressor. The
    target variables produced will be real numbers, not the original class variables.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 任何回归都可以通过使用阈值转化为分类。二分类问题可以通过使用回归器看作回归问题。产生的目标变量将是实数，而不是原始的类别变量。
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Quick SVC – a classifier and regressor
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速SVC——一个分类器和回归器
- en: 'Load `iris` from the `datasets` module:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`datasets`模块加载`iris`：
- en: '[PRE89]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'For simplicity, consider only targets `0` and `1`, corresponding to Setosa
    and Versicolor. Use the Boolean array `iris.target < 2` to filter out target `2`.
    Place it within brackets to use it as a filter in defining the observation set
    `X` and the target set `y`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为简便起见，只考虑目标`0`和`1`，分别对应Setosa和Versicolor。使用布尔数组`iris.target < 2`来过滤目标`2`。将其放入括号中，作为筛选器在定义观测集`X`和目标集`y`时使用：
- en: '[PRE90]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now import `train_test_split` and apply it:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在导入`train_test_split`并应用它：
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Prepare and run an SVC by importing it and scoring it with cross-validation:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导入SVC并使用交叉验证评分来准备并运行SVC：
- en: '[PRE92]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'As done in previous sections, view the average of the scores:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和之前的部分一样，查看评分的平均值：
- en: '[PRE93]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Perform the same with support vector regression by importing `SVR` from `sklearn.svm`,
    the same module that contains SVC:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从`sklearn.svm`导入`SVR`，对支持向量回归执行相同操作，该模块也包含SVC：
- en: '[PRE94]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then write the necessary syntax to fit the model. It is almost identical to
    the syntax for SVC, just replacing some `c` keywords with `r`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后编写必要的语法来拟合模型。它与SVC的语法几乎相同，只需将一些`c`关键字替换为`r`：
- en: '[PRE95]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Making a scorer
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建评分器
- en: 'To make a scorer, you need:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建评分器，你需要：
- en: A scoring function that compares `y_test`, the ground truth, with `y_pred`,
    the predictions
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个评分函数，它将`y_test`（真实值）与`y_pred`（预测值）进行比较
- en: To determine whether a high score is good or bad
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定高分是好是坏
- en: 'Before passing the SVR regressor to the cross-validation, make a scorer by
    supplying two elements:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在将SVR回归器传递给交叉验证之前，先通过提供两个元素来创建评分器：
- en: 'In practice, begin by importing the `make_scorer` function:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实际操作中，首先导入`make_scorer`函数：
- en: '[PRE96]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Use this sample scoring function:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个样本评分函数：
- en: '[PRE97]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `np.rint` function rounds off the prediction to the nearest integer, hopefully
    one of the targets, `0` or `1`. The `astype` method changes the type of the prediction
    to integer type, as the original target is in integer type and consistency is
    preferred with regard to types. After the rounding occurs, the scoring function
    uses the old `accuracy_score` function, which you are familiar with.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.rint` 函数将预测值四舍五入到最接近的整数，希望它是目标值之一，即 `0` 或 `1`。`astype` 方法将预测值的类型更改为整数类型，因为原始目标是整数类型，并且在类型上保持一致性是更优的选择。四舍五入之后，评分函数使用你熟悉的旧版
    `accuracy_score` 函数。'
- en: 'Now, determine whether a higher score is better. Higher accuracy is better,
    so for this situation, a higher score is better. In scikit code:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，确定较高的分数是否更好。更高的准确度更好，因此在这种情况下，较高的分数更好。在 scikit 代码中：
- en: '[PRE98]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Finally, run the cross-validation with a new parameter, the scoring parameter:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用一个新的参数——评分参数，运行交叉验证：
- en: '[PRE99]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Find the mean:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算均值：
- en: '[PRE100]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The accuracy scores are similar for the SVR regressor-based classifier and the
    traditional SVC classifier.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: SVR 回归器基础的分类器与传统的 SVC 分类器在准确率评分上相似。
- en: How it works...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You might ask, why did we take out class `2` out of the target set?
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么我们从目标集合中去掉了类 `2`？
- en: 'The reason is that, to use a regressor, our intent has to be to predict a real
    number. The categories had to have real number properties: that they are ordered
    (informally, if we have three ordered categories *x*, *y*, *z* and *x* < *y* and
    *y* < *z* then *x* < *z*). By eliminating the third category, the remaining flowers
    (Setosa and Versicolor) became ordered by a property we invented: Setosaness or
    Versicolorness.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 其原因在于，为了使用回归模型，我们的目标必须是预测一个实数。类别必须具备实数性质：即它们是有序的（非正式地说，如果我们有三个有序的类别 *x*、*y*、*z*，并且
    *x* < *y* 且 *y* < *z*，那么 *x* < *z*）。通过去掉第三个类别，剩下的花类（Setosa 和 Versicolor）根据我们发明的属性变得有序：Setosaness
    或 Versicolorness。
- en: The next time you encounter categories, you can consider whether they can be
    ordered. For example, if the dataset consists of shoe sizes, they can be ordered
    and a regressor can be applied, even though no one has a shoe size of 12.125.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 下次遇到类别时，你可以考虑它们是否可以排序。例如，如果数据集包含鞋码，那么它们可以排序，且可以应用回归模型，尽管没有人会有 12.125 号鞋。
- en: There's more...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Linear versus nonlinear
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性与非线性
- en: Linear algorithms involve lines or hyperplanes. Hyperplanes are flat surfaces
    in any *n*-dimensional space. They tend to be easy to understand and explain,
    as they involve ratios (with an offset). Some functions that consistently and
    monotonically increase or decrease can be mapped to a linear function with a transformation.
    For example, exponential growth can be mapped to a line with the log transformation.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 线性算法涉及直线或超平面。超平面是任何 *n* 维空间中的平面，它们往往易于理解和解释，因为它们涉及比率（带有偏移量）。一些始终单调增加或减少的函数可以通过变换映射到线性函数。例如，指数增长可以通过对数变换映射为一条直线。
- en: Nonlinear algorithms tend to be tougher to explain to colleagues and investors,
    yet ensembles of decision trees that are nonlinear tend to perform very well.
    KNN, which we examined earlier, is nonlinear. In some cases, functions not increasing
    or decreasing in a familiar manner are acceptable for the sake of accuracy.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性算法往往更难向同事和投资者解释，但非线性决策树集成通常表现得很好。我们之前探讨过的 KNN 就是一个非线性算法。在某些情况下，为了提高准确性，某些函数的增减方式不符合直观也可以被接受。
- en: 'Try a simple SVC with a polynomial kernel, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一个简单的 SVC 并使用多项式核，如下所示：
- en: '[PRE101]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The polynomial kernel of degree 3 looks like a cubic curve in two dimensions.
    It leads to a slightly better fit, but note that it can be harder to explain to
    others than a linear kernel with consistent behavior throughout all of the Euclidean
    space:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 三次多项式核在二维空间中看起来像一条立方曲线。它能带来稍微更好的拟合效果，但请注意，它可能比在整个欧几里得空间中行为一致的线性核更难向他人解释：
- en: '[PRE102]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Black box versus not
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑箱与非黑箱
- en: For the sake of efficiency, we did not examine the classification algorithms
    used very closely. When we compared SVC and logistic regression, we chose SVMs.
    At that point, both algorithms were black boxes, as we did not know any internal
    details. Once we decided to focus on SVMs, we could proceed to compute coefficients
    of the separating hyperplanes involved, optimize the hyperparameters of the SVM,
    use the SVM for big data, and do other processes. The SVMs have earned our time
    investment because of their superior performance.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率，我们并没有非常详细地检查所使用的分类算法。当我们比较支持向量分类器（SVC）和逻辑回归时，我们选择了SVM。那时，这两种算法都是黑箱，因为我们并不了解任何内部细节。一旦我们决定专注于SVM，就可以继续计算分离超平面的系数，优化SVM的超参数，使用SVM处理大数据，并进行其他处理。由于其卓越的性能，SVM值得我们投入时间。
- en: Interpretability
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可解释性
- en: Some machine learning algorithms are easier to understand than others. These
    are usually easier to explain to others as well. For example, linear regression
    is well known and easy to understand and explain to potential investors of your
    company. SVMs are more difficult to entirely understand.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一些机器学习算法比其他算法更容易理解。这些算法通常也更容易向他人解释。例如，线性回归是众所周知的，容易理解，并能向潜在的投资者解释。SVM则更加难以完全理解。
- en: 'My general advice: if SVMs are highly effective for a particular dataset, try
    to increase your personal interpretability of SVMs in the particular problem context.
    Also, consider merging algorithms somehow, using linear regression as an input
    to SVMs, for example. This way, you have the best of both worlds.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我的总体建议是：如果SVM在某个特定数据集上非常有效，尝试提高你在该特定问题情境中的SVM可解释性。同时，考虑某种方式将算法合并，比如使用线性回归作为SVM的输入。这样，你可以兼得两者的优点。
- en: This is really context-specific, however. Linear SVMs are relatively simple
    to visualize and understand. Merging linear regression with SVM could complicate
    things. You can start by comparing them side by side.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这真的取决于具体情况。线性SVM相对简单，容易可视化和理解。将线性回归与SVM合并可能会使事情变得复杂。你可以通过并排比较它们来开始。
- en: However, if you cannot understand every detail of the math and practice of SVMs,
    be kind to yourself, as machine learning is focused more on prediction performance
    rather than traditional statistics.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你无法理解支持向量机（SVM）的数学细节和实践过程，请对自己宽容些，因为机器学习更关注预测性能，而非传统统计学。
- en: A pipeline
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个管道
- en: 'In programming, a pipeline is a set of procedures connected in series, one
    after the other, where the output of one process is the input to the next:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，管道是一个按顺序连接的过程集，其中一个过程的输出作为下一个过程的输入：
- en: '![](img/dc22816a-cefb-4269-9c4d-04900308b55e.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc22816a-cefb-4269-9c4d-04900308b55e.png)'
- en: 'You can replace any procedure in the process with a different one, perhaps
    better in some way, without compromising the whole system. For the model in the
    middle step, you can use an SVC or logistic regression:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用不同的过程替换流程中的任何一个步骤，也许这个替代的步骤在某些方面更好，而不会破坏整个系统。对于中间步骤的模型，你可以使用SVC或逻辑回归：
- en: '![](img/d2a52812-d38e-45ae-b047-3c96e13f0d62.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2a52812-d38e-45ae-b047-3c96e13f0d62.png)'
- en: 'One can also keep track of the classifier itself and build a flow diagram from
    the classifier. Here is a pipeline keeping track of the SVC classifier:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以跟踪分类器本身，并从分类器构建一个流程图。以下是一个跟踪SVC分类器的管道：
- en: '![](img/8267f221-917f-41ea-b55a-d9185d3fbb01.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8267f221-917f-41ea-b55a-d9185d3fbb01.png)'
- en: 'In the upcoming chapters, we will see how scikit-learn uses the intuitive notion
    of a pipeline. So far, we have used a simple one: train, predict, test.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到scikit-learn是如何使用管道这一直观概念的。到目前为止，我们使用了一个简单的管道：训练、预测、测试。
