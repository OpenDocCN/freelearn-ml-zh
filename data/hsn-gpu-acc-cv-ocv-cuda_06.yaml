- en: Basic Computer Vision Operations Using OpenCV and CUDA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 和 CUDA 的基本计算机视觉操作
- en: The last chapter described the process of working with images and videos using
    OpenCV and CUDA. We looked at the code for some basic image and video processing
    applications and compared the performance of OpenCV code with and without CUDA
    acceleration. In this chapter, we will build on this knowledge and try to develop
    some more computer vision and image processing applications using OpenCV and CUDA.
    This chapter describes the method for accessing individual pixel intensities in
    color and grayscale images. A histogram is a very useful concept for image processing.
    This chapter describes the method for calculating histograms and how histogram
    equalization can improve the visual quality of images. This chapter will also
    describe how different geometric transformations can be performed using OpenCV
    and CUDA. Image filtering is a very important concept, which is useful in image
    preprocessing and feature extraction. This is described in detail in this chapter.
    The last part of this chapter describes different morphological operations, such
    as erosion, dilation, and opening and closing images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章描述了使用 OpenCV 和 CUDA 处理图像和视频的过程。我们查看了一些基本的图像和视频处理应用的代码，并比较了带有和没有 CUDA 加速的
    OpenCV 代码的性能。在这一章中，我们将在此基础上构建知识，并尝试使用 OpenCV 和 CUDA 开发一些更多的计算机视觉和图像处理应用。这一章描述了在彩色和灰度图像中访问单个像素强度的方法。直方图是图像处理中的一个非常有用的概念。这一章描述了计算直方图的方法以及直方图均衡化如何提高图像的视觉效果。这一章还将描述如何使用
    OpenCV 和 CUDA 执行不同的几何变换。图像滤波是一个非常重要的概念，它在图像预处理和特征提取中非常有用。这一章将详细描述这一点。本章的最后部分将描述不同的形态学操作，如腐蚀、膨胀、开运算和闭运算。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Accessing individual pixel intensities in OpenCV
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenCV 中访问单个像素强度
- en: Histogram calculation and histogram equalization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图计算和直方图均衡化
- en: Image transformation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像变换
- en: Filtering operations on images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的滤波操作
- en: Morphological operations on images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的形态学操作
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires a basic understanding of image processing and computer
    vision. It needs familiarity with basic C or C++ programming language, CUDA, and
    all of the codes sample explained in previous chapters. All of the code used in
    this chapter can be downloaded from the following GitHub link: [https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA).
    The code can be executed on any operating system, though it has only been tested
    on Ubuntu 16.04\.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要具备图像处理和计算机视觉的基本理解。它需要熟悉基本的 C 或 C++ 编程语言、CUDA 以及前几章中解释的所有示例代码。本章中使用的所有代码都可以从以下
    GitHub 链接下载：[https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Accelerated-Computer-Vision-with-OpenCV-and-CUDA)。代码可以在任何操作系统上执行，尽管它只在
    Ubuntu 16.04 上进行了测试。
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：
- en: '[http://bit.ly/2xERUDL](http://bit.ly/2xERUDL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2xERUDL](http://bit.ly/2xERUDL)'
- en: Accessing the individual pixel intensities of an image
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问图像的单个像素强度
- en: Sometimes there is a need to access pixel intensity value at a particular location
    when we are working with images. This is very useful when we want to change the
    brightness or contrast of a group of pixels or we want to perform some other pixel-level
    operations. For an 8-bit grayscale image, this intensity value at a point will
    be in a range of 0 to 255, while for a color image there will be three different
    intensity values for the blue, green, and red channels with all having values
    between 0 to 255\.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理图像时，有时需要访问特定位置的像素强度值。当我们想要改变一组像素的亮度或对比度，或者想要执行其他像素级操作时，这非常有用。对于一个 8 位灰度图像，该点的强度值将在
    0 到 255 的范围内，而对于彩色图像，将会有三个不同的强度值，分别对应蓝色、绿色和红色通道，所有这些通道的值都在 0 到 255 之间。
- en: 'OpenCV provides a `cv::Mat::at<>` method for accessing intensity values at
    a particular location for any channel images. It needs one argument, which is
    the location of the point at which the intensity is to be accessed. The point
    is passed using the `Point` class with row and column values as arguments. For
    a grayscale image, the method will return a scalar object while, for a color image,
    it will return a vector of three intensities. The code for accessing pixel intensities
    at a particular location for a grayscale as well as a color image is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个`cv::Mat::at<>`方法来访问任何通道图像在特定位置的强度值。它需要一个参数，即要访问强度值的位置。该点通过`Point`类传递，行和列值作为参数。对于灰度图像，该方法将返回一个标量对象，而对于彩色图像，它将返回一个包含三个强度的向量。访问灰度图像以及彩色图像在特定位置的像素强度的代码如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The grayscale image is read first and the `at` method is called on this image
    object. The intensity value is measured at the `(100,50)` point, which indicates
    the pixel at the 100^(th) row and 50^(th) column. It returns a scalar, which is
    stored in the intensity variable. The value is printed on the console. The same
    procedure is followed for a color image but the return value for it will be a
    vector of three intensities, which is stored in the `Vec3b` object. The intensity
    values are printed on the console. The output of the above program is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度图像首先被读取，然后在这个图像对象上调用`at`方法。强度值在`(100,50)`点被测量，这表示第100行和第50列的像素。它返回一个标量，存储在强度变量中。该值被打印在控制台上。对于彩色图像，遵循相同的程序，但返回值将是一个包含三个强度的向量，存储在`Vec3b`对象中。强度值被打印在控制台上。上述程序的输出如下：
- en: '![](img/e89e363b-0180-4b19-8817-08d900820e44.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e89e363b-0180-4b19-8817-08d900820e44.png)'
- en: 'As can be seen, pixel intensity for a grayscale image at `(100,50)` is `9`
    while for a color image it is `[175,179,177]`, which indicates the blue intensity
    is `175`, the green intensity is `179`, and red intensity is `177`. The same method
    is used to modify pixel intensity at a particular location. Suppose, you want
    to change the pixel intensity at the `(100,50)` location to `128`, then you can
    write:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，灰度图像在`(100,50)`处的像素强度为`9`，而对于彩色图像则是`[175,179,177]`，这表示蓝色强度为`175`，绿色强度为`179`，红色强度为`177`。同样的方法用于修改特定位置的像素强度。假设你想将`(100,50)`位置的像素强度改为`128`，则可以编写如下代码：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To summarize, in this section we have seen a method to access and change intensity
    values at a particular location. In the next section, we will see the method to
    calculate the histogram in OpenCV.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中我们看到了一种访问和改变特定位置强度值的方法。在下一节中，我们将看到在OpenCV中计算直方图的方法。
- en: Histogram calculation and equalization in OpenCV
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV中的直方图计算和平滑
- en: A histogram is a very important property of an image as it provides a global
    description of the appearance of that image. An enormous amount of information
    can be obtained from the histogram. It represents the relative frequency of occurrence
    of gray levels in an image. It is basically a plot of gray levels on the *X*-axis
    and the number of pixels in each gray level on the *Y*-axis. If the histogram
    is concentrated on the left side then the image will be very dark and if it is
    concentrated on the right side, then the image will be very bright. It should
    be evenly distributed for good visual quality of an image.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是图像的一个重要属性，因为它提供了该图像外观的全局描述。可以从直方图中获得大量信息。它代表了图像中灰度级别的相对出现频率。它基本上是在X轴上灰度级别和Y轴上每个灰度级别的像素数的图表。如果直方图集中在左侧，则图像会非常暗；如果集中在右侧，则图像会非常亮。为了获得良好的图像视觉质量，它应该均匀分布。
- en: 'The following image demonstrates histograms for dark, bright, and normal images:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了暗、亮和正常图像的直方图：
- en: '![](img/57923152-d000-474c-85e8-2fc0c884e9cc.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57923152-d000-474c-85e8-2fc0c884e9cc.png)'
- en: 'OpenCV provides a function to calculate the histogram of an Image. The syntax
    of the function is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个函数来计算图像的直方图。该函数的语法如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function needs two arrays as an argument. The first array is the input image
    for which the histogram needs to be calculated. The second argument is an output
    array in which the histogram will be stored. The output can be plotted to get
    a histogram like what is shown in the preceding screenshot. As described earlier,
    a flat histogram improves the visual quality of an Image. OpenCV and CUDA provide
    a function to flatten the histogram, which is described in the following section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数需要两个数组作为参数。第一个数组是需要计算直方图的输入图像。第二个参数是输出数组，其中将存储直方图。输出可以绘制成直方图，如图像前面的截图所示。如前所述，平坦的直方图可以提高图像的视觉质量。OpenCV和CUDA提供了一个函数来平坦直方图，这在下一节中将有描述。
- en: Histogram equalization
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直方图均衡化
- en: A perfect image has an equal number of pixels in all its gray levels. So a histogram
    should have a large dynamic range and an equal number of pixels in the entire
    range. This can be accomplished by a technique called histogram equalization.
    It is a very important preprocessing step in any computer vision application.
    In this section, we will see how histogram equalization can be performed for grayscale
    and color images using OpenCV and CUDA.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的图像在其所有灰度级别中像素数量相等。因此，直方图应该具有大的动态范围和整个范围内的像素数量相等。这可以通过一种称为直方图均衡化的技术来实现。它是任何计算机视觉应用中非常重要的预处理步骤。在本节中，我们将看到如何使用OpenCV和CUDA对灰度图像和彩色图像进行直方图均衡化。
- en: Grayscale images
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灰度图像
- en: 'Grayscale images are normally 8-bit single channel images that have 256 different
    gray levels. If the histogram is not evenly distributed, the image is too dark
    or the image is too light, and histogram equalization should be performed to improve
    the visual quality of the image. The following code describes the process for
    histogram equalization on a grayscale image:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度图像通常是8位单通道图像，具有256个不同的灰度级别。如果直方图分布不均匀，图像可能太暗或太亮，此时应进行直方图均衡化以改善图像的视觉质量。以下代码描述了在灰度图像上进行直方图均衡化的过程：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The image read is uploaded to the device memory for histogram equalization.
    It is a mathematically intensive step so CUDA acceleration will help in improving
    the performance of the program. OpenCV provides the `equalizeHist` function for
    histogram equalization. It needs two arguments. The first argument is the source
    image and the second argument is the destination image. The destination image
    is downloaded back to the host and displayed on the console. The output after
    histogram equalization is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 读取的图像被上传到设备内存以进行直方图均衡化。这是一个计算密集型的步骤，因此CUDA加速将有助于提高程序的性能。OpenCV提供了`equalizeHist`函数用于直方图均衡化。它需要两个参数。第一个参数是源图像，第二个参数是目标图像。目标图像被下载回主机并在控制台上显示。直方图均衡化后的输出如下：
- en: '![](img/33934253-36ec-4673-9d4e-33569c4d1aa6.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33934253-36ec-4673-9d4e-33569c4d1aa6.png)'
- en: As can be seen, the image after histogram equalization has a better visual quality
    than the original image. The same operation for color images is described next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，直方图均衡化后的图像在视觉质量上优于原始图像。接下来将描述对彩色图像进行相同操作的过程。
- en: Color image
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 彩色图像
- en: 'Histogram equalization can also be done on color images. It has to be performed
    on separate channels. So the color image has to be split into three channels.
    The histogram of each channel is equalized independently and then channels are
    merged to reconstruct the image. The code for histogram equalization on a color
    image is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图均衡化也可以应用于彩色图像。它必须在单独的通道上执行。因此，彩色图像必须分成三个通道。每个通道的直方图独立均衡，然后合并通道以重建图像。以下是对彩色图像进行直方图均衡化的代码：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A histogram is not normally equalized in the BGR color space; HSV and YCrCb
    color spaces are used for it. So, in the code, the BGR color space is converted
    in to the HSV color space. Then, it is split into three separate channels using
    the `split` function. Now, hue and saturation channels contain the color information
    so there is no point in equalizing those channels. Histogram equalization is performed
    only on the value channel. Three channels are merged back to reconstruct the color
    image using the `merge` function. The HSV color image is converted back into the
    BGR color space for display using `imshow`. The output of the program is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在BGR颜色空间中，直方图通常不进行均衡化；使用HSV和YCrCb颜色空间进行均衡化。因此，在代码中，将BGR颜色空间转换为HSV颜色空间。然后，使用`split`函数将其拆分为三个独立的通道。现在，色调和饱和度通道包含颜色信息，因此没有必要均衡这些通道。直方图均衡化仅在值通道上执行。使用`merge`函数将三个通道合并回重建彩色图像。使用`imshow`将HSV彩色图像转换回BGR颜色空间进行显示。程序的输出如下：
- en: '![](img/caded0d4-03be-471c-ae00-ea7b724a6b5d.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/caded0d4-03be-471c-ae00-ea7b724a6b5d.png)'
- en: To summarize, histogram equalization improves the visual quality of an image
    so it is a very important preprocessing step for any computer vision application.
    The next section describes the geometric transformation of images.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，直方图均衡化可以提升图像的视觉效果，因此它是任何计算机视觉应用中非常重要的预处理步骤。下一节将描述图像的几何变换。
- en: Geometric transformation on images
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像的几何变换
- en: Sometimes, there is a need for resizing an image, the translation of images,
    and the rotation of images for larger computer vision applications. These kinds
    of geometric transformation is explained in this section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在更大的计算机视觉应用中，需要缩放图像、平移图像和旋转图像。本节将解释这类几何变换。
- en: Image resizing
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像缩放
- en: 'images need to be of specific sizes in some computer vision applications. So
    there is a need to convert the image of arbitrary size into the specific size.
    OpenCV provides a function to resize an image. The code for image resizing is
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些计算机视觉应用中，图像需要具有特定的尺寸。因此，需要将任意大小的图像转换为特定尺寸。OpenCV提供了一个用于缩放图像的函数。图像缩放的代码如下：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The height and width of an image can be obtained using two different functions,
    as shown in the code. The `rows` and `cols` properties of the `Mat` object describes
    the `height` and `width` of an image respectively. The `Mat` object also has the
    `size()` method, which has `height` and `width` properties which are used to find
    the size of an image. The image is resized in two ways. In the first way, the
    image is resized to a specific size of `(200,200)` and, in the second, it is resized
    to half of its original dimensions. OpenCV provides the `resize` function for
    this operation. It has four arguments.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两个不同的函数获取图像的高度和宽度，如代码所示。`Mat`对象的`rows`和`cols`属性分别描述图像的`height`和`width`。`Mat`对象还有一个`size()`方法，它具有`height`和`width`属性，用于查找图像的大小。图像以两种方式缩放。在第一种方式中，图像被缩放为特定的`(200,200)`大小，在第二种方式中，它被缩放为其原始尺寸的一半。OpenCV提供了`resize`函数来执行此操作。它有四个参数。
- en: 'The first two arguments are the source and destination images respectively.
    The third argument is the size of the destination image. It is defined using the
    `Size` object. When images are resized, then pixel values have to be interpolated
    on the destination image from the source image. There are various interpolation
    methods such as, bilinear interpolation, bicubic interpolation, area interpolation
    which are available for interpolating pixel values. This interpolation method
    is provided as the fourth argument to the `resize` function. It can be `cv::INTER_LINEAR
    (bilinear)`, `cv::INTER_CUBIC (bicubic)`, or `cv::INTER_AREA (Area)`. The output
    of the image resizing code is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数分别是源图像和目标图像。第三个参数是目标图像的大小。它使用`Size`对象定义。当图像缩放时，必须从源图像对目标图像上的像素值进行插值。有各种插值方法可供使用，例如双线性插值、双三次插值和面积插值。这些插值方法作为`resize`函数的第四个参数提供。它可以设置为`cv::INTER_LINEAR
    (双线性)`、`cv::INTER_CUBIC (双三次)`或`cv::INTER_AREA (面积)`。图像缩放的代码输出如下：
- en: '![](img/a7179ed4-cbc3-4d76-b0e2-345089955041.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7179ed4-cbc3-4d76-b0e2-345089955041.png)'
- en: Image translation and rotation
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像平移和旋转
- en: 'Image translation and rotation are important geometric transformations that
    are needed in some computer vision applications. OpenCV provides an easy API to
    perform these transformations on images. The code to perform translation and rotation
    is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图像平移和旋转是某些计算机视觉应用中需要的重要几何变换。OpenCV 提供了一个简单的 API 来在图像上执行这些变换。执行平移和旋转的代码如下：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A translation matrix needs to be created, which specifies the image translation
    in horizontal and vertical directions. It is a 2 x 3 matrix as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个平移矩阵，该矩阵指定了图像在水平和垂直方向上的平移。它是一个 2 x 3 的矩阵，如下所示：
- en: '![](img/e728715d-0b8d-44f4-85e8-8da1dbdefd1a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e728715d-0b8d-44f4-85e8-8da1dbdefd1a.png)'
- en: '`tx` and `ty` are translation offset in the *x* and *y* directions. In the
    code, this matrix is created using the `Mat` object with 70 as an offsets in the
    *X*-direction and 50 as an offset in the *Y*-direction. This matrix is passed
    as an argument to the `warpAffine` function for Image translation. The other arguments
    for the `warpAffine` function are the source image, destination image, and size
    of the output image respectively.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`tx` 和 `ty` 是沿 *x* 和 *y* 方向的平移偏移。在代码中，这个矩阵使用 `Mat` 对象创建，其中 *X*-方向的偏移量为 70，*Y*-方向的偏移量为
    50。这个矩阵作为参数传递给 `warpAffine` 函数以实现图像平移。`warpAffine` 函数的其他参数分别是源图像、目标图像和输出图像的大小。'
- en: A rotation matrix should be created for Image rotation at a particular degree
    centered at a particular point. OpenCV provides the `cv::getRotationMatrix2D`
    function to construct this rotation matrix. It needs three arguments. The first
    argument is the point for rotation; the center of the image is used for this.
    The second argument is the angle of rotation in degrees, which is specified as
    45 degrees. The last argument is the scale, which is specified as 1\. The constructed
    rotation matrix is again passed as an argument to the `warpAffine` function for
    Image rotation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应该创建一个旋转矩阵，用于在特定点以特定角度旋转图像。OpenCV 提供了 `cv::getRotationMatrix2D` 函数来构建这个旋转矩阵。它需要三个参数。第一个参数是旋转点；在这种情况下使用图像的中心。第二个参数是旋转角度，指定为
    45 度。最后一个参数是缩放比例，指定为 1。构建的旋转矩阵再次作为参数传递给 `warpAffine` 函数以实现图像旋转。
- en: 'The output of the Image translation and Image rotation code is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图像平移和图像旋转代码的输出如下：
- en: '![](img/00396820-7bf0-4da4-84cb-7c198c24b00c.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00396820-7bf0-4da4-84cb-7c198c24b00c.png)'
- en: To summarize, this section described various geometric transformations such
    as Image resizing, image translation, and Image rotation using OpenCV and CUDA.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本节描述了使用 OpenCV 和 CUDA 实现的各种几何变换，如图像缩放、图像平移和图像旋转。
- en: Filtering operations on images
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像上的滤波操作
- en: The methods described till this point worked on a single pixel intensity, and
    are called point processing methods. Sometimes it is helpful to look at the neighborhood
    of a pixel rather than only single pixel intensity. This are called neighborhood
    processing techniques. The neighborhood can be 3 x 3, 5 x 5, 7 x 7, and so on
    and are matrix-centered at a particular pixel. Image filtering is an important
    neighborhood processing technique.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的方法都是针对单个像素强度进行的，被称为点处理方法。有时查看像素的邻域而不是仅查看单个像素强度是有帮助的。这些被称为邻域处理技术。邻域可以是
    3 x 3、5 x 5、7 x 7 等等，并且以特定像素为中心。图像滤波是邻域处理中的一个重要技术。
- en: Filtering is an important concept in signal processing where we reject a certain
    band of frequencies and allow a certain band of frequency to pass. How is frequency
    measured in images? If gray levels change slowly over a region, then it is a low-frequency
    region. If gray levels changes drastically, then it is a high-frequency region.
    Normally the background of an image is considered a low-frequency region and the
    edges are high-frequency regions. Convolution is a very important mathematical
    concept for neighborhood processing and Image filtering in particular. It is explained
    in the following section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是信号处理中的一个重要概念，其中我们拒绝一定频率范围的信号，并允许一定频率范围的信号通过。图像中是如何测量频率的？如果一个区域的灰度值变化缓慢，那么它是一个低频区域。如果灰度值变化剧烈，那么它是一个高频区域。通常，图像的背景被认为是低频区域，而边缘是高频区域。卷积是邻域处理和图像滤波中的一个非常重要的数学概念。它将在下一节中解释。
- en: Convolution operations on an image
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像上的卷积操作
- en: 'The basic idea of convolutions evolved from a similar idea in biology called
    receptive fields, where it is sensitive to some parts in an image and insensitive
    to other parts. It can be mathematically represented as the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积的基本思想源于生物学中类似的概念，称为感受野，其中对图像中的某些部分敏感，而对其他部分不敏感。它可以用以下方式数学表示：
- en: '*g(x,y)=f(x,y)*h(x,y)= ∑∑f(n,m)h(x-n,y-m)*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*g(x,y)=f(x,y)*h(x,y)= ∑∑f(n,m)h(x-n,y-m)*'
- en: 'In simplified form, this equation is a dot product between a filter, *h,* and
    a sub-image of the image, *f,* centered around the *(x,y)* point. The answer to
    this product is equal to the *(x,y)* point in the image, *g*. To illustrate the
    working of the convolution operation on an image, an example of a 3 x 3 filter
    applied to an image of a size of 6 x 6 is shown in the following diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简化形式下，此方程是滤波器*h*与图像的子图像*f*（以*(x,y)*点为中心）的点积。此乘积的答案是图像中的*(x,y)*点*g*。为了说明卷积操作在图像上的工作原理，以下图显示了将3
    x 3滤波器应用于6 x 6大小图像的示例：
- en: '![](img/a9321074-4028-4de5-a4bd-9ad4aa78c0b8.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9321074-4028-4de5-a4bd-9ad4aa78c0b8.png)'
- en: A dot product is taken between the leftmost window shown in red with the filter
    to find a point in the destination image. The answer of the dot product will be
    *2 ((1*1 + 1*1 + 1*0 + 1*5 + 1*1 +1*7 +1*0 +1*1 + 1*1)/9)*. The same operation
    is repeated after moving this window by 1 pixel to the right and answer the will
    be *3*. This is repeated for all windows in an image to construct the destination
    image. Different low pass and high-pass filters can be constructed by changing
    the values of the 3 x 3 filter matrix. This is explained in the next two sections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将最左侧的红色窗口与滤波器进行点积，以找到目标图像中的一个点。点积的答案将是 *2 ((1*1 + 1*1 + 1*0 + 1*5 + 1*1 +1*7
    +1*0 +1*1 + 1*1)/9)*。将此窗口向右移动1个像素后，重复相同的操作，答案将是 *3*。这将对图像中的所有窗口重复进行，以构建目标图像。通过改变3
    x 3滤波器矩阵的值，可以构建不同的低通和高通滤波器。这将在下一两节中解释。
- en: Low pass filtering on an image
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像上的低通滤波
- en: 'A low pass filter removes high-frequency content from an Image. Generally,
    noise is considered high-frequency content so a low pass filter removes noise
    from an image. There are many types of noise, such as Gaussian noise, uniform
    noise, exponential noise, and salt-and-pepper noise, which can effect an image.
    Low pass filters are used to eliminate this kind of noise. There are many types
    of low pass filters available:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 低通滤波器从图像中移除高频内容。通常，噪声被认为是高频内容，因此低通滤波器从图像中移除噪声。有许多类型的噪声，如高斯噪声、均匀噪声、指数噪声和盐和胡椒噪声，这些都会影响图像。低通滤波器用于消除这类噪声。有许多类型的低通滤波器可用：
- en: Averaging or box filters
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均或箱式滤波器
- en: Gaussian filters
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高斯滤波器
- en: Median filters
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中值滤波器
- en: These filters and implementation of them using OpenCV is explained in this section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了这些滤波器及其使用OpenCV的实现。
- en: Averaging filters
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平均滤波器
- en: 'An averaging filters as the name suggests, performs averaging operations on
    neighborhood pixels. If a Gaussian noise is present in an image then the low pass
    averaging filter can be used to remove the noise. It will also blur the edges
    of an Image, because of the averaging operation. The neighborhood can be 3 x 3,
    5 x 5, 7 x 7, and so on. The bigger the size of the filter window, the more blurring
    of the image will take place. The 3 x 3 and 5 x 5 averaging mask is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 平均滤波器，正如其名所示，对邻域像素执行平均操作。如果图像中存在高斯噪声，则可以使用低通平均滤波器来去除噪声。由于平均操作，它还会模糊图像的边缘。邻域可以是3
    x 3、5 x 5、7 x 7等。滤波器窗口的尺寸越大，图像的模糊程度就越高。3 x 3和5 x 5平均掩模如下：
- en: '![](img/394559ad-38f0-4218-bd97-5273f0a1bc4e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/394559ad-38f0-4218-bd97-5273f0a1bc4e.png)'
- en: 'OpenCV provides a simple interface to apply many kinds of filters on an image.
    The code to apply an averaging filter with a different mask is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个简单的接口，可以在图像上应用许多类型的滤波器。以下代码演示了如何使用不同掩模应用平均滤波器：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`cv::Ptr`, which is a template class for smart pointers, is used to store a
    filter of the `cv::cuda::Filter` type. Then, the `createBoxFilter` function is
    used to create an averaging filter of different window sizes. It requires three
    mandatory and three optional arguments. The first and second arguments are datatypes
    for the source and destination images. They are taken as `CV_8UC1`, which indicates
    an 8-bit unsigned grayscale image. The third argument defines the size of the
    filter window. It can be 3 x 3, 5 x 5, 7 x 7, and so on. The fourth argument is
    the anchor point, which has a default value of (-1,-1) which indicates the anchor
    is at the center point of the kernel. The final two optional arguments are related
    to the pixel interpolation method and border value, which are omitted here.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv::Ptr`是一个用于智能指针的模板类，用于存储`cv::cuda::Filter`类型的过滤器。然后，使用`createBoxFilter`函数创建不同窗口大小的平均滤波器。它需要三个必选参数和三个可选参数。第一个和第二个参数是源图像和目标图像的数据类型。它们被假定为`CV_8UC1`，表示8位无符号灰度图像。第三个参数定义了滤波器窗口的大小。它可以是一个3
    x 3、5 x 5、7 x 7等。第四个参数是锚点，其默认值为(-1,-1)，表示锚点位于核的中心点。最后两个可选参数与像素插值方法和边界值相关，这里省略。'
- en: 'The created filter pointer has an apply method, which is used to apply the
    created filter on any image. It has three arguments. The first argument is the
    source image, the second argument is the destination image, and the third optional
    argument is, CUDA stream, which is used for multitasking, as explained earlier
    in this book. In the code, three averaging filters of different sizes are applied
    on an Image. The result is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的过滤器指针有一个应用方法，该方法用于将创建的过滤器应用于任何图像。它有三个参数。第一个参数是源图像，第二个参数是目标图像，第三个可选参数是CUDA流，它用于多任务处理，如本书前面所述。在代码中，对图像应用了不同大小的三个平均滤波器。结果如下：
- en: '![](img/0d5c6cf0-9d19-4774-be37-edbcc634877a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d5c6cf0-9d19-4774-be37-edbcc634877a.png)'
- en: As can be seen from the output, as the size of the filter increases, more pixels
    are used for averaging, which introduces more blurring on an image. Though a large
    filter will eliminate more noise.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，随着滤波器大小的增加，用于平均的像素更多，这会在图像上引入更多的模糊。尽管大滤波器可以消除更多的噪声。
- en: Gaussian filters
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高斯滤波器
- en: 'A Gaussian filter uses a mask that has a Gaussian distribution to filter an
    Image instead of a simple averaging mask. This filter also introduces smooth blurring
    on an Image and is widely used to eliminate noise from an image. A 5 x 5 Gaussian
    filter with an approximate standard deviation of 1 is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯滤波器使用具有高斯分布的掩码来过滤图像，而不是简单的平均掩码。此滤波器还引入了图像上的平滑模糊，并且广泛用于从图像中消除噪声。一个5 x 5的高斯滤波器，其标准差约为1，如下所示：
- en: '![](img/111f7e02-3cb6-4702-919d-3f170e573560.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/111f7e02-3cb6-4702-919d-3f170e573560.png)'
- en: 'OpenCV provides a function to implement the Gaussian filter. The code for it
    is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一个实现高斯滤波器的函数。其代码如下：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `createGaussianFilter` function is used to create a mask for the Gaussian
    filter. The datatype of the source and destination images, size of the filter,
    and standard deviation in the horizontal direction are provided as arguments to
    the function. We can also provide a standard deviation in the vertical direction
    as an argument; if it is not provided, then its default value is equal to standard
    deviation in the horizontal direction. The created Gaussian mask of a different
    size is applied to the image using an `apply` method. The output of the program
    is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`createGaussianFilter`函数用于创建高斯滤波器的掩码。源图像和目标图像的数据类型、滤波器大小以及水平方向的标准差作为参数提供给函数。我们还可以提供一个垂直方向的标准差作为参数；如果没有提供，则其默认值等于水平方向的标准差。使用`apply`方法将不同大小的创建的高斯掩码应用于图像。程序输出如下：'
- en: '![](img/3dcba18f-b470-4ce8-8cdc-a4e555c4a06c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dcba18f-b470-4ce8-8cdc-a4e555c4a06c.png)'
- en: Again as the size of the Gaussian filter increases, more blurring is introduced
    in the image. The Gaussian filter is used to eliminate noise and introduce smooth
    blurring on an image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，随着高斯滤波器大小的增加，图像中引入了更多的模糊。高斯滤波器用于消除噪声并在图像上引入平滑的模糊。
- en: Median filtering
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中值滤波
- en: 'When an image is affected by salt and pepper noise, it will not be eliminated
    by the averaging or Gaussian filter. It needs a nonlinear filter. Median operations
    on a neighborhood instead of averaging can help in eliminating salt and pepper
    noise. In this filter, the median of 9-pixel values in the neighborhood is placed
    at the center pixel. It will eliminate extreme high or low values introduced by
    salt and pepper noise. Though OpenCV and CUDA provide a function for median filtering,
    it is slower than regular functions in OpenCV, so this function is used to implement
    median filter as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像受到椒盐噪声的影响时，它不会被平均或高斯滤波器消除。它需要一个非线性滤波器。在邻域中进行中值运算而不是平均可以帮助消除椒盐噪声。在这个滤波器中，邻域中9个像素值的中值放置在中心像素上。它将消除由椒盐噪声引入的极端高或低值。尽管OpenCV和CUDA提供了一个中值滤波函数，但它的速度比OpenCV中的常规函数慢，因此使用以下代码实现中值滤波：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `medianBlur` function in OpenCV is used to implement a median filter. It
    needs three arguments. The first argument is the source image, the second argument
    is the destination image, and the third argument is the window size for the median
    operation. The output of the median filtering is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中的`medianBlur`函数用于实现中值滤波。它需要三个参数。第一个参数是源图像，第二个参数是目标图像，第三个参数是中值操作的窗口大小。中值滤波的输出如下：
- en: '![](img/f692e545-d0a8-457b-8ade-e6b45c278b16.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f692e545-d0a8-457b-8ade-e6b45c278b16.png)'
- en: The source image is affected by salt and pepper noise, as can be seen in the
    screenshot. This noise is eliminated completely by the median filter of a size
    of 3x3 without introducing extreme blurring. So median filtering is a very important
    preprocessing step when images applications are affected by salt and pepper noise.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 源图像受到椒盐噪声的影响，如图中的截图所示。这种噪声通过3x3大小的中值滤波器完全消除，而没有引入极端的模糊。因此，中值滤波是图像应用受到椒盐噪声影响时的一个非常重要的预处理步骤。
- en: To summarize, we have seen three types of low pass filter, which are widely
    used in various computer vision applications. Averaging and Gaussian filters are
    used to eliminate Gaussian noise, but they will also blur the edges of an Image.
    A median filter is used to remove salt-and-pepper noise.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们看到了三种类型的低通滤波器，它们在各种计算机视觉应用中得到了广泛使用。平均滤波器和高斯滤波器用于消除高斯噪声，但它们也会模糊图像的边缘。中值滤波器用于去除椒盐噪声。
- en: High-pass filtering on an image
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像的高通滤波
- en: 'High-pass filters remove low-frequency components from images and enhance high-frequency
    components. So, when a high-pass filter is applied to an Image, it will remove
    the background, as it is a low-frequency region, and enhances the edges, which
    are high-frequency components. So, high-pass filters can also be called edge detectors.
    The coefficients of the filter will change, otherwise it is similar to the filters
    seen in the last section. There are many high-pass filters available such as following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 高通滤波器从图像中移除低频分量并增强高频分量。因此，当高通滤波器应用于图像时，它会移除背景，因为它是低频区域，并增强边缘，这些是高频分量。因此，高通滤波器也可以称为边缘检测器。滤波器的系数将改变，否则它与上一节中看到的滤波器相似。有许多高通滤波器可用，如下所示：
- en: Sobel filters
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sobel滤波器
- en: Scharr filters
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scharr滤波器
- en: Laplacian filters
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉普拉斯滤波器
- en: We will see each one of them separately in this section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分别看到它们中的每一个。
- en: Sobel filters
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sobel滤波器
- en: 'The Sobel operator or Sobel filter is a widely used image processing and computer
    vision algorithm for edge detection applications. It is a 3 x 3 filter that approximates
    the gradient of the image intensity function. It provides a separate filter to
    compute the gradient in a horizontal and vertical direction. The filter is convolved
    with the image in a similar way as described earlier in this chapter. The horizontal
    and vertical 3 x 3 Sobel filter is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel算子或Sobel滤波器是一种广泛用于边缘检测应用的图像处理和计算机视觉算法。它是一个3 x 3的滤波器，用于近似图像强度函数的梯度。它提供了一个单独的滤波器来计算水平和垂直方向的梯度。该滤波器以与本章前面所述类似的方式与图像卷积。水平和垂直的3
    x 3 Sobel滤波器如下：
- en: '![](img/08b07763-8193-4132-9968-3c8b55ffa033.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08b07763-8193-4132-9968-3c8b55ffa033.png)'
- en: 'The code for implementing this Sobel filter is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此Sobel滤波器的代码如下：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: OpenCV provides the `createSobelFilter` function for implementing a Sobel filter.
    It requires many arguments. The first two arguments are data types of the source
    and destination images. The third and fourth arguments are the order of the `x`
    and `y` derivatives respectively. For computing the `x` derivative or vertical
    edges, 1 and 0 are provided, and for computing the `y` derivative or horizontal
    edges, 0 and 1 are provided. The fifth argument which indicates the size of the
    kernel, is optional. The default value is 3\. The scale for derivatives can also
    be provided.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了`createSobelFilter`函数来实现Sobel滤波器。它需要许多参数。前两个参数是源图像和目标图像的数据类型。第三个和第四个参数分别是`x`和`y`导数的阶数。对于计算`x`导数或垂直边缘，提供1和0，而对于计算`y`导数或水平边缘，提供0和1。第五个参数表示核的大小，是可选的。默认值是3。也可以提供导数的比例。
- en: 'To see both horizontal and vertical edges simultaneously, the result of the
    `x`-derivative and the `y`-derivative are summed. The result is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时看到水平和垂直边缘，需要将`x`导数和`y`导数的结果相加。结果如下：
- en: '![](img/6a632427-fd9a-4d72-a303-501284f8c1ba.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a632427-fd9a-4d72-a303-501284f8c1ba.png)'
- en: The Sobel operator provides a very inaccurate approximation of derivative but
    still, it is quite useful in computer vision applications for edge detection.
    It does not have rotation symmetry; to overcome that, the Scharr operator is used.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel算子提供了非常不精确的导数近似，但仍然在计算机视觉应用中的边缘检测方面非常有用。它没有旋转对称性；为了克服这一点，使用了Scharr算子。
- en: Scharr filters
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scharr滤波器
- en: 'As Sobel does not provide rotation symmetry, a Scharr operator is used to overcome
    that by using different filter masks as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Sobel没有提供旋转对称性，因此使用不同的滤波器掩码来克服这一点，如下所示：
- en: '![](img/6ebcaa19-69d1-49fb-94fa-40e6cf520ee8.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ebcaa19-69d1-49fb-94fa-40e6cf520ee8.png)'
- en: 'As can be seen from the mask, the Scharr operator gives more weight to central
    rows or central columns to find edges. The program to implement a Scharr filter
    is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从掩码中可以看出，Scharr算子更重视中间行或中间列以找到边缘。实现Scharr滤波器的程序如下：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: OpenCV provides the `createScharrFilter` function for implementing the Scharr
    filter. It requires many arguments. The first two arguments are datatypes of the
    source and destination images. The third and fourth arguments are the order of
    the `x` and `y` derivatives respectively. For computing the `x` derivative or
    vertical edges, 1 and 0 are provided, and for computing the `y` derivative or
    horizontal edges, 0 and 1 are provided. The fifth argument, which indicate the
    size of the kernel, is optional. The default value is 3\.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了`createScharrFilter`函数来实现Scharr滤波器。它需要许多参数。前两个参数是源图像和目标图像的数据类型。第三个和第四个参数分别是`x`和`y`导数的阶数。对于计算`x`导数或垂直边缘，提供1和0，而对于计算`y`导数或水平边缘，提供0和1。第五个参数，表示核的大小，是可选的。默认值是3。
- en: 'To see both horizontal and vertical edges simultaneously, the result of the
    `x`-derivative and the `y`-derivative are summed. The result is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时看到水平和垂直边缘，需要将`x`导数和`y`导数的结果相加。结果如下：
- en: '![](img/681f64de-2f79-41eb-9d92-01acbfc9d973.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/681f64de-2f79-41eb-9d92-01acbfc9d973.png)'
- en: Laplacian filters
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laplacian滤波器
- en: 'The Laplacian filters is also a derivative operator to find out edges in an
    Image. The difference is that Sobel and Scharr are first-order derivative operators,
    while Laplacian is a second-order derivative operator. It also finds out edges
    in both horizontal and vertical directions simultaneously, which is different
    than Sobel and Scharr operators. The Laplacian filter is computes the second derivative,
    so it is very sensitive to noise in an image, it is desirable to blur the image
    and remove noise before applying the Laplacian filter. The code for implementing
    a Laplacian filter is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Laplacian滤波器也是一种导数算子，用于在图像中找到边缘。不同之处在于Sobel和Scharr是一阶导数算子，而Laplacian是二阶导数算子。它也同时找到水平和垂直方向的边缘，这与Sobel和Scharr算子不同。Laplacian滤波器计算二阶导数，因此对图像中的噪声非常敏感，在应用Laplacian滤波器之前最好对图像进行模糊处理以去除噪声。实现Laplacian滤波器的代码如下：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Two Laplacian filters with kernel sizes of 1 and 3 are applied on an image
    using the `createLaplacianFilter` function. Along with the size of the kernel,
    the function also requires datatypes of the source and destination images as arguments.
    The created Laplacian filter is applied to an image using the `apply` method.
    The output of the Laplacian filter is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`createLaplacianFilter`函数在图像上应用了两个核大小为1和3的Laplacian滤波器。除了核的大小外，该函数还需要作为参数提供源图像和目标图像的数据类型。创建的Laplacian滤波器通过`apply`方法应用于图像。Laplacian滤波器的输出如下：
- en: '![](img/c9f8842c-0a03-4a11-9c52-2b3fd23a180d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9f8842c-0a03-4a11-9c52-2b3fd23a180d.png)'
- en: To summarize, in this section, we have described different high-pass filters
    such as Sobel, Scharr, and Laplacian filters. Sobel and Scharr are first-order
    derivative operators used to compute edges and they are less sensitive to noise.
    Laplacian is a second-order derivative operator used to compute edges and it is
    very sensitive to noise.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们描述了不同的高通滤波器，如Sobel、Scharr和Laplacian滤波器。Sobel和Scharr是一阶导数算子，用于计算边缘，它们对噪声的敏感性较低。Laplacian是一个二阶导数算子，用于计算边缘，它对噪声非常敏感。
- en: Morphological operations on images
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像的形态学操作
- en: 'Image morphology deals with the regions and shapes of an image. It is used
    to extract image components that are useful to represent shapes and regions. Image
    morphology treats the image as an ensemble of sets unlike, other Image processing
    operations seen earlier. The image interacts with a small template, which is called
    a structuring element, and which defines the region of interest or neighborhood
    in the image morphology. There are various morphological operations that can be
    performed on images, which are explained one by one in this section:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图像形态学处理图像的区域和形状。它用于提取对表示形状和区域有用的图像成分。图像形态学将图像视为集合的总和，这与之前看到的其他图像处理操作不同。图像与一个小模板相互作用，该模板称为结构元素，它定义了图像形态学中的感兴趣区域或邻域。本节中解释了可以在图像上执行的各种形态学操作，将逐一进行说明。
- en: '**Erosion**: Erosion sets a center pixel to the minimum over all pixels in
    the neighborhood. The neighborhood is defined by the structuring element, which
    is a matrix of 1s and 0s. Erosion is used to enlarge holes in the object, shrink
    the boundary, eliminate the island, and get rid of narrow peninsulas that might
    exist on the image boundary.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**腐蚀**：腐蚀将中心像素设置为邻域内所有像素的最小值。邻域由结构元素定义，它是一个由1s和0s组成的矩阵。腐蚀用于扩大物体中的孔洞，缩小边界，消除岛屿，并去除可能存在于图像边界上的狭窄半岛。'
- en: '**Dilation**: Dilation sets a center pixel to the maximum over all pixels in
    the neighborhood. The dilation increases the size of a white block and reduces
    the size of the black region. It is used to fill holes in the object and expand
    the boundary of the object.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**膨胀**：膨胀将中心像素设置为邻域内所有像素的最大值。膨胀增加了白色块的大小，减少了黑色区域的大小。它用于填充物体中的孔洞并扩展物体的边界。'
- en: '**Opening**: Image opening is basically a combination of erosion and dilation.
    Image opening is defined as erosion followed by dilation. Both operations are
    performed using the same structuring elements. It is used to smooth the contours
    of the image, break down narrow bridges and isolate objects that are touching
    one another. It is used in the analysis of wear particles in engine oils, ink
    particles in recycled paper, and so on.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开运算**：图像开运算基本上是腐蚀和膨胀的组合。图像开运算定义为腐蚀后跟膨胀。这两个操作都使用相同的结构元素执行。它用于平滑图像的轮廓，破坏狭窄的桥梁并隔离相互接触的物体。它在分析发动机油中的磨损颗粒、回收纸中的墨水颗粒等方面得到应用。'
- en: '**Closing**: Image closing is defined as dilation followed by erosion. Both
    operations are performed using the same structuring elements. It is used to fuse
    narrow breaks and eliminate small holes.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闭运算**：图像闭运算定义为膨胀后跟腐蚀。这两个操作都使用相同的结构元素执行。它用于融合狭窄的裂缝并消除小孔。'
- en: 'The morphological operators can be easily understood by applying them on binary
    images that only contain black and white. OpenCV and CUDA provide an easy API
    to apply a morphological transformation on images. The code for it is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 形态学算子可以通过将它们应用于仅包含黑白两色的二值图像来轻松理解。OpenCV和CUDA提供了一个简单的API来在图像上应用形态学变换。相应的代码如下：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A structuring element that defines the neighborhood for the morphological operation
    needs to be created first. This can be done by using the `getStructuringElement`
    function in OpenCV. The shape and size of the structuring element need to be provided
    as an argument to this function. In the code, a rectangular structuring element
    of a size of 5 x 5 is defined.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要创建一个定义形态学操作邻域的结构元素。这可以通过使用OpenCV中的`getStructuringElement`函数来完成。需要将结构元素的形状和尺寸作为参数传递给此函数。在代码中，定义了一个5
    x 5大小的矩形结构元素。
- en: The filter for morphological operations is created using the `createMorphologyFilter`
    function. It needs three mandatory arguments. The first argument defines the operation
    to be performed. `cv::MORPH_ERODE` is used for erosion, `cv::MORPH_DILATE` for
    dilation, `cv::MORPH_OPEN` for opening, and `cv::MORPH_CLOSE` for closing. The
    second argument is the datatype of an image, and the third argument is the structuring
    element created earlier. The `apply` method is used to apply these filters on
    an image.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 形态学操作的过滤器是通过使用`createMorphologyFilter`函数创建的。它需要三个必填参数。第一个参数定义要执行的操作。`cv::MORPH_ERODE`用于腐蚀，`cv::MORPH_DILATE`用于膨胀，`cv::MORPH_OPEN`用于开运算，`cv::MORPH_CLOSE`用于闭运算。第二个参数是图像的数据类型，第三个参数是之前创建的结构元素。使用`apply`方法将这些过滤器应用于图像。
- en: 'The output of morphological operations on an image is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图像上形态学操作的输出如下：
- en: '![](img/e5158d17-32b8-4f56-9c57-29242cedfb1a.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e5158d17-32b8-4f56-9c57-29242cedfb1a.png)'
- en: As can be seen from the output, erosion reduces the boundary of an object while
    dilation thickens it. We consider the white part an object and the black part
    is the background. Opening smooths the contours of the image. Closing eliminates
    small holes in an image. If the size of the structuring element is increased to
    7 x 7 from 5 x 5, then the erosion of the boundary will be more pronounced in
    an erosion operation and the boundary will get thicker in a dilation operation.
    The small circles on the left side, which were visible in an eroded image of 5
    x 5, are removed when it is eroded with a size of 7 x 7.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出结果可以看出，腐蚀操作会减小物体的边界，而膨胀操作则会使其变厚。我们将白色部分视为物体，黑色部分则是背景。开运算可以平滑图像的轮廓。闭运算可以消除图像中的小孔。如果将结构元素的尺寸从5
    x 5增加到7 x 7，那么在腐蚀操作中边界腐蚀会更加明显，而在膨胀操作中边界会变得更厚。在5 x 5腐蚀图像中可见的左侧的小圆圈，在用7 x 7尺寸腐蚀时会被移除。
- en: 'The output of morphological operations using a 7 x 7 structuring element is
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用7 x 7结构元素的形态学操作的输出如下：
- en: '![](img/4e8edd25-34ff-4742-8aaf-1ca95014aaa1.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e8edd25-34ff-4742-8aaf-1ca95014aaa1.png)'
- en: To summarize, morphological operations are important to find out components
    used to define the shape and regions of an image. It can be used to fill holes
    in an image and smoothen the contours of an image.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，形态学操作对于找出定义图像形状和区域的组件非常重要。它可以用来填充图像中的孔洞并平滑图像的轮廓。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter described the method to access pixel intensities at a particular
    location in an image. It is very useful when we are performing a pointwise operation
    on an image. A histogram is a very important global feature used to describe an
    image. This chapter described the method to compute a histogram and the process
    of histogram equalization, which improves the visual quality of an image. Various
    geometric transformations such as image resizing, rotation, and translation were
    explained in detail. Image filtering is a useful neighborhood processing technique
    used to eliminate noise and extract edge features of an image and was described
    in detail. A low pass filter is used to remove noise but it will also blur out
    the edges of an image. A high-pass filter removes the background, which is a low-frequency
    region while enhancing edges, which are high-frequency regions. The last part
    of this chapter described different morphological operations such as erosion,
    dilation, opening, and closing, which can be used to describe the shape of an
    image and fill holes in an image. In the next chapter, we will use these concepts
    to build some useful computer vision applications using OpenCV and CUDA.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在图像中特定位置访问像素强度的方法。当我们对图像进行逐点操作时，这非常有用。直方图是描述图像的一个非常重要的全局特征。本章介绍了计算直方图和直方图均衡化的方法，这可以提高图像的视觉效果。详细解释了各种几何变换，如图像缩放、旋转和平移。图像滤波是一种有用的邻域处理技术，用于消除噪声和提取图像的边缘特征，并进行了详细描述。低通滤波器用于去除噪声，但它也会模糊图像的边缘。高通滤波器去除背景，这是一个低频区域，同时增强边缘，这些是高频区域。本章的最后部分介绍了不同的形态学操作，如腐蚀、膨胀、开运算和闭运算，这些可以用来描述图像的形状并填充图像中的空洞。在下一章中，我们将使用这些概念，结合OpenCV和CUDA构建一些有用的计算机视觉应用。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Write an OpenCV function to print pixel intensity at the location (200,200)
    of any color image on the console.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个OpenCV函数，在控制台打印任何彩色图像在位置（200,200）的像素强度。
- en: Write an OpenCV function to resize an image to (300,200) pixels. Use the bilinear
    interpolation method.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个OpenCV函数，将图像调整到（300,200）像素大小。使用双线性插值方法。
- en: Write an OpenCV function to upsample an Image by 2\. Use the area interpolation
    method.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个OpenCV函数，通过2倍上采样图像。使用面积插值方法。
- en: 'State true or false: blurring decreases as we increase the size of the averaging
    filter.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：随着平均滤波器大小的增加，模糊程度降低。
- en: 'State true or false: median filters can remove gaussian noise.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：中值滤波器可以去除高斯噪声。
- en: What steps can be taken to reduce noise sensitivity of Laplacian operator?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以采取哪些步骤来降低拉普拉斯算子的噪声敏感性？
- en: Write an OpenCV function to implement top hat and black hat morphological operation.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个OpenCV函数来实现顶帽和黑帽形态学操作。
