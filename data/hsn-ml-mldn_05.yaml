- en: Regression Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归模型
- en: With our development environment configured and our first ML.NET application
    completed, it is now time to dive into regression models. In this chapter, we
    will dive into the math behind regression models, as well as the various applications
    of regression models. We will also build two additional ML.NET applications, one
    utilizing a linear regression model and the other a logistic regression model.
    The linear regression application will predict employee attrition based on various
    employee attributes. The logistic regression application will perform basic static
    file analysis on a file to determine whether it is malicious or benign. Finally,
    we will explore how to evaluate a regression model with the properties ML.NET
    exposes in regression models.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的开发环境配置完成并且我们的第一个ML.NET应用完成后，现在是时候深入研究回归模型了。在本章中，我们将深入研究回归模型背后的数学原理，以及回归模型的各种应用。我们还将构建两个额外的ML.NET应用，一个使用线性回归模型，另一个使用逻辑回归模型。线性回归应用将根据各种员工属性预测员工流失。逻辑回归应用将对文件进行基本静态文件分析，以确定其是恶意还是良性。最后，我们将探讨如何使用ML.NET在回归模型中公开的特性来评估回归模型。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Breaking down various regression models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解各种回归模型
- en: Creating the linear regression application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建线性回归应用
- en: Creating the logistic regression application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建逻辑回归应用
- en: Evaluating a regression model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估回归模型
- en: Breaking down regression models
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解回归模型
- en: 'While there are several regression model types available in the machine learning
    eco-system, there are two primary regression models groups: linear and logistic,
    both of which have rich implementations in ML.NET.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管机器学习生态系统中提供了多种回归模型类型，但主要有两种主要的回归模型组：线性回归和逻辑回归，它们在ML.NET中都有丰富的实现。
- en: 'ML.NET provides the following linear regression trainers:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ML.NET提供了以下线性回归训练器：
- en: '`FastTreeRegressionTrainer`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FastTreeRegressionTrainer`'
- en: '`FastTreeTweedieTrainer`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FastTreeTweedieTrainer`'
- en: '`FastForestRegressionTrainer`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FastForestRegressionTrainer`'
- en: '`GamRegressionTrainer`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GamRegressionTrainer`'
- en: '`LbfgsPoissonRegressionTrainer`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LbfgsPoissonRegressionTrainer`'
- en: '`LightGbmRegressionTrainer`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LightGbmRegressionTrainer`'
- en: '`OlsTrainer`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OlsTrainer`'
- en: '`OnlineGradientDescentTrainer`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnlineGradientDescentTrainer`'
- en: '`SdcaRegressionTrainer`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SdcaRegressionTrainer`'
- en: The employee attrition application we will be creating later in this chapter
    utilizes the linear regression SDCA trainer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面创建的员工流失应用将使用线性回归SDCA训练器。
- en: 'In addition, ML.NET provides the following binary logistic regression trainers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ML.NET还提供了以下二元逻辑回归训练器：
- en: '`LbfgsLogisticRegressionBinaryTrainer`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LbfgsLogisticRegressionBinaryTrainer`'
- en: '`SdcaLogisticRegressionBinaryTrainer`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SdcaLogisticRegressionBinaryTrainer`'
- en: '`SdcaNonCalibratedBinaryTrainer`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SdcaNonCalibratedBinaryTrainer`'
- en: '`SymbolicSgdLogisticRegressionBinaryTrainer`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SymbolicSgdLogisticRegressionBinaryTrainer`'
- en: For the file classification application, we will be utilizing the `SDCALogisticRegressionBinaryTrainer`
    model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件分类应用，我们将使用`SDCALogisticRegressionBinaryTrainer`模型。
- en: Choosing the type of regression model
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择回归模型类型
- en: With all of these options, how do you choose the right type of regression model?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些选项中，你如何选择正确的回归模型类型？
- en: The type of regression model you choose depends on what your expected output
    is. If you are looking for just a Boolean (that is, 0 or 1) value, logistic regression
    models should be used like in the file classification application we will be writing
    later in this chapter. In addition, if you are looking to return a specific pre-defined
    range of values, perhaps a car type such as coupe, convertible, or hatchback,
    a logistic regression model is the correct model to choose from.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的回归模型类型取决于你期望的输出。如果你只希望得到一个布尔值（即，0或1），那么应该使用逻辑回归模型，就像我们在本章后面将要编写的文件分类应用中那样。此外，如果你希望返回一个特定的预定义值范围，比如汽车类型，如敞篷车、敞篷车或掀背车，那么逻辑回归模型是正确的选择。
- en: Conversely, linear regression models return a numeric value, such as the employment
    duration example we will explore later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，线性回归模型返回一个数值，例如我们在本章后面将要探讨的就业时长示例。
- en: 'So, to summarize, we have the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结如下：
- en: If your output is a Boolean value, use a logistic regression model.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的输出是布尔值，请使用逻辑回归模型。
- en: If your output is comprised of a preset range type of values (akin to an enumeration),
    use a logistic regression model.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的输出由预设的范围类型值组成（类似于枚举），请使用逻辑回归模型。
- en: If your output is a numeric unknown value, use a linear regression model.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的输出是一个数值未知值，请使用线性回归模型。
- en: Choosing a linear regression trainer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择线性回归训练器
- en: When looking at the list of nine linear regression trainers ML.NET, it can be
    a bit daunting to ask which is the best.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看 ML.NET 中九个线性回归训练器的列表时，可能会感到有些令人畏惧，不知道哪一个才是最好的。
- en: For ML.NET linear regression trainers, by and large, the most popular are FastTree
    and LightGBM. The three FastTree algorithms utilize neighbor-joining and use heuristics
    to quickly identify candidate joins to build out a decision tree. LightGBM is
    a very popular linear regression algorithm that utilizes a **Gradient-based One
    Side Sampling** (**GOSS**) to filter out the data instances for finding a split
    value. Both trainers provide both quick training and predict times while also
    providing very accurate model performance. Also, more documentation, papers, and
    research are available with both of these algorithms.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ML.NET 线性回归训练器来说，总体而言，最受欢迎的是 FastTree 和 LightGBM。三个 FastTree 算法利用邻接和启发式方法快速识别候选连接来构建决策树。LightGBM
    是一个非常流行的线性回归算法，它利用 **基于梯度的单边采样**（**GOSS**）来过滤数据实例以找到分割值。这两个训练器都提供了快速的训练和预测时间，同时提供了非常准确的模式性能。此外，这两个算法都有更多的文档、论文和研究资料。
- en: The remaining five trainers are useful and worth a deep dive for experimentation,
    but overall you will likely find equal or greater success with LightGBM and FastTree.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的五个训练器很有用，值得深入实验，但总体来说，你可能会发现 LightGBM 和 FastTree 的效果同样好或更好。
- en: Choosing a logistic regression trainer
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择逻辑回归训练器
- en: Given the four logistic regression trainers available in ML.NET, which is the
    best for your problem? Whilst all four regression trainers return a binary classification,
    they are optimized for different datasets and workloads.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ML.NET 中提供的四个逻辑回归训练器中，哪一个最适合你的问题？虽然所有四个回归训练器都返回二元分类，但它们针对不同的数据集和工作负载进行了优化。
- en: Are you looking to train and predict in a low memory environment? If so, the
    L-BFGS logistic regression trainer (`LbfgsLogisticRegressionBinaryTrainer`) is
    a logical choice given that it was created to handle memory-restricted environments.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否在寻找一个低内存环境下的训练和预测？如果是这样，考虑到它是为了处理内存受限环境而创建的，L-BFGS 逻辑回归训练器（`LbfgsLogisticRegressionBinaryTrainer`）是一个合理的选择。
- en: Both of the SDCA-based trainers—`SdcaLogisticRegressionBinaryTrainer` and `SdcaNonCalibratedBinaryTrainer`—have
    been optimized for scalability in training. If your training set is large and
    you are looking for binary classification, either of the SDCA trainers would be
    a good choice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 SDCA 的两个训练器——`SdcaLogisticRegressionBinaryTrainer` 和 `SdcaNonCalibratedBinaryTrainer`——已经针对训练的可扩展性进行了优化。如果你的训练集很大，并且你在寻找二元分类，那么任一
    SDCA 训练器都是一个不错的选择。
- en: The `SymbolicSgdLogisticRegressionBinaryTrainer` model is different from the
    other three in that it is based on a stochastic gradient descent algorithm. This
    means rather than looking to maximize the error function, the algorithm looks
    to minimize the error function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymbolicSgdLogisticRegressionBinaryTrainer` 模型与其他三个不同，因为它基于随机梯度下降算法。这意味着该算法不是试图最大化误差函数，而是试图最小化误差函数。'
- en: If you are curious to expand your knowledge of SCDAs and in particular how Microsoft
    Research experimented with scaling SCDAs, give this white paper a read: [https://www.microsoft.com/en-us/research/wp-content/uploads/2016/06/main-3.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/06/main-3.pdf).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇想扩展你对 SCDAs 的知识，特别是微软研究如何扩展 SCDAs 的实验，请阅读这篇白皮书：[https://www.microsoft.com/en-us/research/wp-content/uploads/2016/06/main-3.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/06/main-3.pdf)。
- en: Creating the linear regression application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建线性回归应用程序
- en: As mentioned earlier, the application we will be creating is an employee attrition
    predictor. Given a set of attributes tied to an employee, we can predict how long
    they will remain at their current job. The attributes included in this example
    aren't a definitive list of attributes, nor should be used as-is in a production
    environment; however, we can use this as a starting point for predicting a singular
    numeric output based on several attributes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将要创建的应用程序是一个员工流失预测器。给定一组与员工相关的属性，我们可以预测他们将在当前工作中停留多久。本例中包含的属性并不是属性的确切列表，也不应直接在生产环境中使用；然而，我们可以将其作为基于多个属性预测单个数值输出的起点。
- en: As with [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml), *Getting Started
    with Machine Learning and ML.NET*, the completed project code, sample dataset,
    and project files can be downloaded here: [https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_linear_regression](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_linear_regression).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [第 1 章](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml)，“使用 ML.NET 开始机器学习”，完成的项目代码、样本数据集和项目文件可以在此处下载：[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_linear_regression](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_linear_regression)。
- en: Diving into the trainer
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解训练器
- en: As previously mentioned, for this linear regression application, we will be
    using the SDCA trainer. **SDCA** stands for **Stochastic Dual Coordinate Ascent**
    and if you may recall, we used the logistic regression version of this trainer
    in the example in [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting
    Up the ML.NET Environment*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于这个线性回归应用，我们将使用 SDCA 训练器。**SDCA** 代表 **Stochastic Dual Coordinate Ascent**，如果你还记得，我们在
    [第 2 章](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml)，“设置 ML.NET 环境”的例子中使用了这个训练器的逻辑回归版本。
- en: To the average reader, all four words that comprise SDCA might be unknown, so
    let's break down what each means to give better clarity to what happens when you
    utilize an SDCA trainer. Starting with *Stochastic*, which, in other words, means
    unpredictability. And in the case of machine learning, it means attempting to
    probabilistically predict the error function and feed random samples from your
    training set into the optimizer. The use of *Dual Coordinate* means two variables
    are coupled when training the model. As you have probably guessed, this makes
    the model much more complex but doesn't require any extra work to be utilized.
    Lastly, *Ascent* refers to maximizing the value of the error function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通读者来说，构成 SDCA 的四个单词可能都是未知的，所以让我们逐一解释每个单词的含义，以便更好地理解当您使用 SDCA 训练器时会发生什么。首先，*Stochastic*，换句话说，就是不可预测性。在机器学习的情况下，这意味着尝试以概率预测误差函数，并将训练集中的随机样本输入到优化器中。使用
    *Dual Coordinate* 意味着在训练模型时两个变量是耦合的。正如你可能猜到的，这使得模型变得更加复杂，但不需要任何额外的工作就可以使用。最后，*Ascent*
    指的是最大化误差函数的值。
- en: Exploring the project architecture
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目架构
- en: Building on the project architecture and code we created in [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml),
    *Setting Up the ML.NET Environment*, the major change architecturally in this
    example is the mechanism for input. [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting
    Up the ML.NET Environment*,used a simple string to provide sentiment analysis
    via a command-line argument. In this application, there are several properties
    to pass into the model; therefore, for this application, we are now using a JSON
    file to contain our input data. With this addition, we are now including the popular
    `Newtonsoft.Json` NuGet package (version 12.0.2 is the latest at the time of this
    writing and what is used in the included sample). If you are building this project
    from scratch and do not remember how to add a NuGet reference, please refer back
    to [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting Up the ML.NET
    Environment*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml)，“设置 ML.NET 环境”中创建的项目架构和代码的基础上，这个例子在架构上的主要变化是输入机制。在
    [第 2 章](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml)，“设置 ML.NET 环境”中，使用简单的字符串通过命令行参数提供情感分析。在这个应用中，有几个属性需要传递给模型；因此，对于这个应用，我们现在使用
    JSON 文件来包含我们的输入数据。随着这个添加，我们现在包括流行的 `Newtonsoft.Json` NuGet 包（在撰写本文时，最新版本是 12.0.2，并在包含的示例中使用）。如果您是从头开始构建此项目并且不记得如何添加
    NuGet 引用，请参阅 [第 2 章](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml)，“设置 ML.NET 环境”。
- en: 'The following screenshot shows the Visual Studio Solution Explorer view of
    the project. The new addition to the solution is the `ExtensionMethods` class
    file, which we will review in the next section:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了项目的 Visual Studio Solution Explorer 视图。解决方案的新增内容是 `ExtensionMethods`
    类文件，我们将在下一节中对其进行回顾：
- en: '![](img/9759fb4f-f8f5-4bb0-93db-cd76f0ff7971.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9759fb4f-f8f5-4bb0-93db-cd76f0ff7971.png)'
- en: 'The `sampledata.csv` file contains 40 rows of random data; feel free to adjust
    the data to fit your own observations or to adjust the trained model. Here is
    a snippet of the data:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledata.csv` 文件包含 40 行随机数据；您可以随意调整数据以适应自己的观察或调整训练模型。以下是数据的片段：'
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each of these rows contains the value for the properties in the newly created
    `EmploymentHistory` class that we will review later on in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些每一行都包含新创建的 `EmploymentHistory` 类中属性的值，我们将在本章后面进行回顾。
- en: If you want to use a larger dataset to train and expand this example, the website
    Kaggle offers a dataset created by IBM data scientists. This dataset is available
    here: [https://www.kaggle.com/pavansubhasht/ibm-hr-analytics-attrition-dataset](https://www.kaggle.com/pavansubhasht/ibm-hr-analytics-attrition-dataset).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用更大的数据集来训练并扩展此示例，Kaggle 网站提供了由 IBM 数据科学家创建的数据集。此数据集在此处可用：[https://www.kaggle.com/pavansubhasht/ibm-hr-analytics-attrition-dataset](https://www.kaggle.com/pavansubhasht/ibm-hr-analytics-attrition-dataset)。
- en: Diving into the code
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入代码
- en: For this application as noted, we are building on top of the work completed
    in [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting Up the ML.NET
    Environment*. For this deep dive, we are going to focus solely on the code that
    was changed for this application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，对于此应用程序，我们是在完成[第2章](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml)，*设置 ML.NET
    环境*的工作基础上构建的。对于这次深入研究，我们将专注于此应用程序更改的代码。
- en: 'The classes that were changed or added are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 被更改或添加的课程如下：
- en: '`ExtensionMethods`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExtensionMethods`'
- en: '`EmploymentHistory`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmploymentHistory`'
- en: '`EmploymentHistoryPrediction`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmploymentHistoryPrediction`'
- en: '`Predictor`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Predictor`'
- en: '`Trainer`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trainer`'
- en: '`Program`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program`'
- en: The ExtensionMethods class
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ExtensionMethods` 类'
- en: 'This newly added class provides an easy to use an extension method to return
    all of the properties in a class except the label.If you are unfamiliar with extension
    methods, these methods provide a very simple syntax to potentially provide complex
    actions on a single object, like in this case, where we take an arbitrary type
    and return all of the properties it contains (except for `labelName`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新添加的类提供了一个易于使用的扩展方法，可以返回类中除标签外的所有属性。如果你不熟悉扩展方法，这些方法提供了一种非常简单的语法，可以潜在地对单个对象执行复杂操作，就像在这个例子中，我们取一个任意类型并返回它包含的所有属性（除了
    `labelName`）：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The EmploymentHistory class
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`EmploymentHistory` 类'
- en: 'The `EmploymentHistory` class is the container class that contains the data
    to both predict and train our model. These columns map in order for the sample
    data reviewed previously. If you begin experimenting with new features and add
    to this list, ensure you increment the array index appropriately:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmploymentHistory` 类是包含预测和训练模型所需数据的容器类。这些列按照先前审查的样本数据顺序映射。如果你开始尝试新的功能并向此列表添加内容，请确保适当地增加数组索引：'
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The EmploymentHistoryPrediction class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`EmploymentHistoryPrediction` 类'
- en: 'The `EmploymentHistoryPrediction` class contains only the prediction value
    of how many months the employee is projected to be at his or her job in the `DurationInMonths`
    property:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmploymentHistoryPrediction` 类仅包含在 `DurationInMonths` 属性中预测的员工预计在其职位上工作多少个月的预测值：'
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Predictor class
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Predictor` 类'
- en: 'There are a couple of changes in this class to handle the employment prediction
    scenario:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类中有一两个更改，用于处理就业预测场景：
- en: 'First, validate that the input file exists before making a prediction on it:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在对此文件进行预测之前，验证输入文件是否存在：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The other change is in the prediction call itself. As you probably guessed,
    the TSrc and TDst arguments need to be adjusted to utilize both of the new classes
    we created, `EmploymentHistory` and `EmploymentHistoryPrediction`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个更改是在预测调用本身。正如你可能猜到的，TSrc 和 TDst 参数需要调整以利用我们创建的两个新类，`EmploymentHistory` 和
    `EmploymentHistoryPrediction`：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Given that we are no longer simply passing in the string and building an object
    on the fly, we need to first read in the file as text. We then deserialize the
    JSON into our `EmploymentHistory` object:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不再只是传递字符串并在飞行中构建对象，我们需要首先以文本形式读取文件。然后，将 JSON 反序列化为我们的 `EmploymentHistory`
    对象：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, we need to adjust the output of our prediction to match our new `EmploymentHistoryPrediction`
    properties:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要调整预测的输出以匹配我们新的 `EmploymentHistoryPrediction` 属性：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Trainer class
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Trainer` 类'
- en: Inside the `Trainer` class, a large portion was rewritten to handle the expanded
    features used and to provide regression algorithm evaluation as opposed to the
    binary classification we looked at in [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting
    Up the ML.NET Environment*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Trainer` 类中，大部分代码被重写，以处理使用的扩展功能，并提供回归算法评估，而不是我们在[第2章](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml)，*设置
    ML.NET 环境*中查看的二分类。
- en: 'The first change is the use of a comma to separate the data as opposed to the
    default tab like we used in [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting
    Up the ML.NET Environment*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个更改是使用逗号分隔数据，而不是我们像在第2章[设置 ML.NET 环境](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml)中使用的默认制表符：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next change is in the pipeline creation itself. In our first application,
    we had a label and fed that straight into the pipeline. With this application,
    we have nine features to predict the duration of a person's employment in the
    `DurationInMonths` property and append each one of them to the pipeline using
    the C# 6.0 feature, `nameof`. You might have noticed the use of magic strings
    to map class properties to features in various code samples on GitHub and MSDN;
    personally, I find this error-prone compared to the strongly typed approach.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个更改是在管道创建本身。在我们的第一个应用程序中，我们有一个标签并将其直接输入到管道中。在这个应用程序中，我们有九个特征用于预测 `DurationInMonths`
    属性中一个人的就业时长，并使用 C# 6.0 特性 `nameof` 将每个特征附加到管道中。你可能已经注意到在 GitHub 和 MSDN 上的各种代码示例中使用了魔法字符串来将类属性映射到特征；我个人认为，与强类型方法相比，这种方法更容易出错。
- en: For every property, we call the `NormalizeMeanVariance` transform method, which
    as the name implies normalizes the input data both on the mean and the variance.
    ML.NET computes this by subtracting the mean of the input data and dividing that
    value by the variance of the inputted data. The purpose behind this is to nullify
    outliers in the input data so the model isn't skewed to handle an edge case compared
    to the normal range. For example, suppose the sample dataset of employment history
    had 20 rows and all but one of those rows had a person with 50 years experience.
    The one row that didn't fit would be normalized to better fit within the ranges
    of values entered into the model.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个属性，我们调用 `NormalizeMeanVariance` 转换方法，正如其名称所暗示的，该方法在均值和方差上对输入数据进行归一化。ML.NET通过从输入数据的均值中减去并除以输入数据的方差来计算这一点。这样做背后的目的是消除输入数据中的异常值，以便模型不会偏向处理边缘情况，而不是正常范围。例如，假设就业历史样本数据集有20行，其中除了有一行外，其他所有行都有一个有50年经验的人。那个不符合的行将被归一化，以便更好地适应模型中输入的值范围。
- en: 'In addition, note the use of the extension method referred to earlier to help
    to simplify the following code, when we concatenate all of the feature columns:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意使用前面提到的扩展方法来帮助简化以下代码，当我们连接所有特征列时：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then create the `Sdca` trainer using the default parameters (`"Label"`
    and `"Features"`):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用默认参数（`"Label"` 和 `"Features"`）创建 `Sdca` 训练器：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, we call the `Regression.Evaluate` method to provide regression specific
    metrics, followed by a `Console.WriteLine` call to provide these metrics to your
    console output. We will go into detail about what each of these means in the last
    section of this chapter:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `Regression.Evaluate` 方法来提供回归特定的度量，然后通过 `Console.WriteLine` 调用来将这些度量输出到控制台。我们将在本章的最后部分详细介绍这些度量分别代表什么：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Program class
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序类
- en: 'The only change in the `Program` class was the help text to indicate usage
    for predict requires a filename, not a string:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program` 类的唯一更改是帮助文本，用于指示预测时需要一个文件名而不是字符串：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the application
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'To run the application the process is nearly identical to Chapter 2''s sample
    application. To iterate more quickly, the debug configuration automatically passes
    in the included `sampledata.csv` file as a command-line parameter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序的过程几乎与第2章的示例应用程序相同。为了更快地迭代，调试配置自动将包含的 `sampledata.csv` 文件作为命令行参数传入：
- en: '![](img/f4d37e52-1dcc-4cca-8fd1-b899579f0d6a.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4d37e52-1dcc-4cca-8fd1-b899579f0d6a.png)'
- en: 'Going forward, due to the increasing complexity of the applications, all sample
    applications will have this preset:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序的复杂性不断增加，未来的所有示例应用程序都将具有以下预设：
- en: 'To run the training on the command line as we did in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml),
    *Getting Started with Machine Learning and ML.NET,* simply pass in the following
    command (assuming you are using the included sample dataset):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要像在第1章[开始使用机器学习和 ML.NET](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml)中那样在命令行上运行训练，只需传递以下命令（假设您正在使用包含的样本数据集）：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the expanded output to include several metric data points—we will go through
    what each one of these means at the end of this chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意扩展的输出包括几个度量数据点——我们将在本章的末尾解释这些数据点各自代表什么。
- en: 'After training the model, build a sample JSON file and save it as `input.json`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 训练模型后，构建一个示例 JSON 文件并将其保存为 `input.json`：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To run the model with this file, simply pass in the filename to the built application
    and the predicted output will show:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用此文件运行模型，只需将文件名传递给构建的应用程序，预测输出将显示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Feel free to modify the values and see how the prediction changes based on
    the dataset that the model was trained on.  A few areas of experimentation from
    this point might be to do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随意修改值，看看基于模型训练的数据集，预测如何变化。从这个点开始，一些实验性的区域可能包括以下内容：
- en: Add some additional features based on your own experience.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你自己的经验添加一些额外的功能。
- en: Modify `sampledata.csv` to include your team's experience.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`sampledata.csv`以包含你团队的经验。
- en: Modify the sample application to have a GUI to make running predicts easier.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改示例应用程序以具有GUI，使运行预测更容易。
- en: Creating the logistic regression application
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建逻辑回归应用程序
- en: As mentioned earlier, the application we will be creating to demonstrate logistic
    regressions is a file classifier. Given a file (of any type), we extract the strings
    from the file. This is a very common approach to performing file classification
    although, like the previous example, this is often just an element of file classification,
    not the only component. Therefore, don't expect this to find the next zero-day
    piece of malware!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将创建的应用程序来展示逻辑回归是一个文件分类器。给定一个文件（任何类型），我们从文件中提取字符串。这是一种非常常见的文件分类方法，尽管，就像前面的例子一样，这通常只是文件分类的一个元素，而不是唯一的组成部分。因此，不要期望它能找到下一个零日恶意软件！
- en: The completed project code, sample dataset, and project files can be downloaded
    here:[ ](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_logistic_regression)[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_logistic_regression](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_logistic_regression)[.](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_logistic_regression)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目代码、样本数据集和项目文件可以在此处下载：[ ](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_logistic_regression)[https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_logistic_regression](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_logistic_regression)[.](https://github.com/PacktPublishing/Hands-On-Machine-Learning-With-ML.NET/tree/master/chapter03_logistic_regression)
- en: The trainer used in this application also uses SDCA but using the logistic regression
    variation that was discussed earlier in this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序中使用的训练器也使用SDCA，但使用本章前面讨论的逻辑回归变体。
- en: As in the previous example, we will begin by exploring the project architecture,
    diving into the code, and then show how you can run the example to both train
    and predict.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们将首先探索项目架构，深入代码，然后展示如何运行示例以进行训练和预测。
- en: Exploring the project architecture
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目架构
- en: Building on the project architecture and code we created in the previous example,
    the major change architecturally in this example is feature extraction. With this
    example, we will add in the `FeatureExtractor` class in addition to creating new
    input and prediction classes. The reason for this is going back to the idea of
    keeping things separate and well defined as discussed in [Chapter 2](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml), *Setting
    Up the ML.NET Environment*. For this example application and future applications
    you may write, they, more than likely, will have input files to convert into rows
    of data. By having a separate class handle this part of the pipeline, you can
    encapsulate this functionality cleanly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面例子中创建的项目架构和代码的基础上，本例在架构上的主要变化是特征提取。在本例中，我们将在`FeatureExtractor`类中添加新输入和预测类。这样做的原因是回到将事物保持分离和明确定义的想法，如[第2章](b8decd34-4bcb-4b1b-80d2-b2bfd0fa31c1.xhtml)中讨论的，*设置ML.NET环境*。对于这个示例应用程序和未来你可能编写的应用程序，它们很可能会有输入文件需要转换为数据行。通过有一个单独的类来处理这个管道的部分，你可以干净地封装这个功能。
- en: 'The following screenshot shows the Visual Studio Solution Explorer view of
    the project. The new addition to the solution is the `FeatureExtractor` class
    file that we will review in the next section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了项目的Visual Studio解决方案资源管理器视图。解决方案的新增内容是`FeatureExtractor`类文件，我们将在下一节中对其进行审查：
- en: '![](img/c49ce931-dac3-4c89-a977-ada86e7ab1a7.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c49ce931-dac3-4c89-a977-ada86e7ab1a7.png)'
- en: 'The `sampledata.csv` file contains eight rows of random data. Feel free to
    adjust the data to fit your own observations or adjust the trained model. Here
    is the included sample data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampledata.csv` 文件包含八行随机数据。请随意调整数据以适应您的观察或调整训练模型。以下是包含的样本数据：'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each of these rows contains two columns worth of data. The first is the classification,
    with true being malicious and false being benign. These properties are mapped
    in the newly created `FileInput` class that we will review later on in this chapter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行包含两列数据。第一列是分类，其中 true 表示恶意，false 表示良性。这些属性映射到我们稍后在本章中将要审查的新创建的 `FileInput`
    类中。
- en: Diving into the code
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入代码
- en: For this application as noted, we are building on top of the work completed
    earlier within this chapter. Again, for this deep dive, we are going to focus
    solely on the code that was changed for this application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于这个应用程序，我们正在构建本章中之前完成的工作。同样，对于这次深入分析，我们将仅关注为这个应用程序更改的代码。
- en: 'Classes that were changed or added are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 被更改或添加的类如下：
- en: '`FeatureExtractor`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FeatureExtractor`'
- en: '`FileInput`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileInput`'
- en: '`FilePrediction`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FilePrediction`'
- en: '`BaseML`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseML`'
- en: '`Predictor`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Predictor`'
- en: '`Trainer`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trainer`'
- en: '`Program`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program`'
- en: The FeatureExtractor class
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FeatureExtractor 类
- en: 'This newly added class provides our feature extraction for the given folder
    of files**. **Once extraction is complete, the classification and strings data
    is written out to the `sampledata` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新添加的类为我们提供了给定文件夹中文件的特性提取**。**提取完成后，分类和字符串数据将被写入到 `sampledata` 文件中：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The FileInput class
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FileInput 类
- en: 'The `FileInput` class provides the container for the trained classification
    and the strings data we extract:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileInput` 类提供了我们提取的训练分类和字符串数据的容器：'
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The FilePrediction class
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FilePrediction 类
- en: 'The `FilePrediction` class provides the container for the classification, probability,
    and score:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilePrediction` 类提供了分类、概率和得分的容器：'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The BaseML class
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BaseML 类
- en: 'For the `BaseML` class, we have made several enhancements, starting with the
    constructor. In the constructor, we initialize the `stringRex` variable to the
    regular expression we will use to extract strings. `Encoding.RegisterProvider`
    is critical to utilize the Windows-1252 encoding. This encoding is the encoding
    Windows Executables utilize:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `BaseML` 类，我们对它进行了几项增强，从构造函数开始。在构造函数中，我们将 `stringRex` 变量初始化为我们将用于提取字符串的正则表达式。`Encoding.RegisterProvider`
    对于使用 Windows-1252 编码至关重要。这种编码是 Windows 可执行文件使用的编码：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next major addition is the `GetStrings` method. This method takes the bytes,
    runs the previously created compiled regular expression, and extracts the string
    matches:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主要新增功能是 `GetStrings` 方法。该方法接收字节，运行之前创建的编译后的正则表达式，并提取字符串匹配项：
- en: 'To begin, we define the method definition and initialize the `stringLines`
    variable to hold the strings:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义方法定义并初始化 `stringLines` 变量以保存字符串：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will sanity check the input data is not null or empty:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将对输入数据进行合理性检查，确保它不是 null 或空的：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next block of code we open a `MemoryStream` object and then a `StreamReader`
    object:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的代码块中，我们打开一个 `MemoryStream` 对象和一个 `StreamReader` 对象：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will then loop through the `streamReader` object until an `EndOfStream`
    condition is reached, reading line by line:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将遍历 `streamReader` 对象，直到达到 `EndOfStream` 条件，逐行读取：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then will apply some string clean up of the data and handle whether the
    line is empty or not gracefully:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将对数据进行一些字符串清理，并优雅地处理行是否为空的情况：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we will append the regular expression matches and append those matches
    to the previously defined `stringLines` variable:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将正则表达式匹配项追加到之前定义的 `stringLines` 变量中：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, we will return the `stringLines` variable converted into a single string
    using the `string.Join` method:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用 `string.Join` 方法将 `stringLines` 变量转换为单个字符串：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Predictor class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Predictor 类
- en: 'The `Predictor` class, much like what was changed in the linear regression
    example, is simply modified to support the new model and return the classification:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predictor` 类，就像在线性回归示例中更改的那样，只是进行了修改以支持新模型并返回分类：'
- en: 'We begin by passing in the two new classes, `FileInput` and `FilePrediction`,to
    the `CreatePredictionEngine` method:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将两个新类 `FileInput` 和 `FilePrediction` 传递给 `CreatePredictionEngine` 方法：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we create the `FileInput` object, setting the `Strings` property with
    the return value of the `GetStrings` method we wrote earlier:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建 `FileInput` 对象，将 `Strings` 属性设置为之前编写的 `GetStrings` 方法的返回值：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we update the output call to the `Console` object with our file classification
    and probability:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将输出调用更新到 `Console` 对象，包括我们的文件分类和概率：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Trainer class
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Trainer` 类'
- en: 'In the `Trainer` class, we will build a new pipeline to train our model. The
    `FeaturizeText` transform builds NGrams from the strings data we previously extracted
    from the files. **NGrams** are a popular method to create vectors from a string
    to, in turn, feed the model. You can think of NGrams as breaking a longer string
    into ranges of characters based on the value of the NGram parameter. A bi-gram,
    for instance, would take the following sentence, *ML.NET is great* and convert
    it into *ML-.N-ET-is-gr-ea-t*. Lastly, we build the `SdcaLogisticRegression` trainer
    object:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Trainer` 类中，我们将构建一个新的管道来训练我们的模型。`FeaturizeText` 转换从我们之前从文件中提取的字符串数据构建 NGrams。**NGrams**
    是一种从字符串创建向量的流行方法，进而将数据输入模型。你可以将 NGrams 视为根据 NGram 参数值将较长的字符串分解为字符范围。例如，一个二元组会将以下句子
    *ML.NET is great* 转换为 *ML-.N-ET-is-gr-ea-t*。最后，我们构建了 `SdcaLogisticRegression`
    训练器对象：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For those looking to deep dive further into the `Transforms` Catalog API, check
    out the documentation from Microsoft here: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.transformscatalog?view=ml-dotnet](https://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.transformscatalog?view=ml-dotnet).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于想要深入了解 `Transforms` 目录 API 的人来说，请查看微软的以下文档：[https://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.transformscatalog?view=ml-dotnet](https://docs.microsoft.com/en-us/dotnet/api/microsoft.ml.transformscatalog?view=ml-dotnet)。
- en: The Program class
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Program` 类'
- en: 'In the `Program` class, we added a third option to extract features and create
    the sample data `.tsv` file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program` 类中，我们添加了第三个选项来提取特征并创建样本数据 `.tsv` 文件：
- en: 'To begin, we modify the help text to indicate the new extract option that takes
    a path to the training folder:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们修改帮助文本以指示新的提取选项，该选项接受训练文件夹的路径：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In addition, we also need to modify the main switch/case to support the `extract`
    argument:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要修改主开关/情况以支持 `extract` 参数：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Running the application
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'With the addition of feature extraction in our pipeline, we first need to perform
    feature extraction on the files:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管道中添加了特征提取后，我们首先需要对文件执行特征提取：
- en: 'Assuming the folder of files called `temp_data` exists, execute the following
    command:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设名为 `temp_data` 的文件文件夹存在，请执行以下命令：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output shows the count of extracted files and the output sample file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了提取的文件数量和输出样本文件。
- en: 'To train the model using either the included `sampledata.csv` or one you trained
    yourself, execute the following command:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用包含的 `sampledata.csv` 或你自己训练的数据训练模型，请执行以下命令：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `chapter3.mdl` model file should exist in the folder executed in once complete.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`chapter3.mdl` 模型文件应存在于执行文件夹中。
- en: 'To run the newly trained model against an existing file such as the compiled
    `chapter3` executable, run the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行针对现有文件（如编译的 `chapter3` 可执行文件）的新训练模型，请运行以下命令：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you are looking for sample files, the `c:\Windows` and `c:\Windows\System32`
    folders contain numerous Windows Executables and DLLs. In addition, if you are
    looking to create malicious-looking files that are actually clean, you can create
    files on the fly on [http://cwg.io](http://cwg.io) in various file formats. This
    is a helpful tool in the cyber-security space where testing new functionality
    on a development machine is much safer than detonating real zero-day threats on!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在寻找示例文件，`c:\Windows` 和 `c:\Windows\System32` 文件夹包含大量的 Windows 可执行文件和 DLL。此外，如果你想要创建看起来恶意但实际上是干净的文件，你可以在
    [http://cwg.io](http://cwg.io) 上动态创建各种格式的文件。这是网络安全领域的一个有用工具，在开发机器上测试新功能比在真实环境中引爆零日威胁要安全得多！
- en: Evaluating a regression model
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估回归模型
- en: As discussed in previous chapters, evaluating a model is a critical part of
    the overall model building process. A poorly trained model will only provide inaccurate
    predictions. Fortunately, ML.NET provides many popular attributes to calculate
    model accuracy based on a test set at the time of training to give you an idea
    of how well your model will perform in a production environment.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，评估模型是整个模型构建过程中的关键部分。一个训练不良的模型只会提供不准确的预测。幸运的是，ML.NET 提供了许多流行的属性，可以根据训练时的测试集计算模型精度，从而让你了解你的模型在生产环境中将如何表现。
- en: 'In ML.NET, as noted earlier in the linear regression sample application, there
    are five properties that comprise the `RegressionMetrics` class object. These
    include the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在ML.NET中，如前所述，线性回归示例应用中有五个属性构成了`RegressionMetrics`类对象。这些包括以下内容：
- en: Loss function
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 损失函数
- en: Mean absolute error
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均方绝对误差
- en: Mean squared error
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均方误差
- en: R-squared
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R平方
- en: Root mean squared error
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根号均方误差
- en: In the next sections, we will break down how these values are calculated and
    ideal values to look for.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分解这些值的计算方法和理想值。
- en: Loss function
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 损失函数
- en: This property uses the loss function set when the regression trainer was initialized.
    In the case of our linear regression example application, we used the default
    constructor, which for SDCA is defaulted to the `SquaredLoss` class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性使用在回归训练器初始化时设置的损失函数。在我们的线性回归示例应用中，我们使用了默认构造函数，对于SDCA而言，默认为`SquaredLoss`类。
- en: 'Other regression loss functions offered by ML.NET are the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ML.NET提供的其他回归损失函数如下：
- en: '`TweedieLoss` (used for Tweedie regression models)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TweedieLoss`（用于Tweedie回归模型）'
- en: '`PoissonLoss` (used for Poisson regression models)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PoissonLoss`（用于泊松回归模型）'
- en: The idea behind this property is to allow some flexibility when it comes to
    evaluating your model compared to the other four properties that use fixed algorithms
    for evaluation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性背后的想法是在评估模型时提供一些灵活性，与其他四个使用固定算法进行评估的属性相比。
- en: Mean squared error
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 均方误差
- en: '**Mean Squared Error**, also known as **MSE**, is defined as the measure of
    the average of the squares of the errors. To put it simply, please refer to the
    following plot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**均方误差**，也称为**MSE**，定义为误差平方的平均值。简单来说，请参考以下图表：'
- en: '![](img/fb4d71a8-e7cc-4b33-bb07-776c6e17aa3b.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb4d71a8-e7cc-4b33-bb07-776c6e17aa3b.png)'
- en: The dots correlate to data points for our model, while the blue line is the
    prediction line. The distance between the red dots and the prediction line is
    the error. For MSE, the value is calculated based on these points and their distances
    to the line. From that value, the mean is calculated. For MSE, the smaller the
    value, the better fitting and more accurate predictions you will have with your
    model.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 点代表我们模型中的数据点，而蓝色线是预测线。红色点与预测线之间的距离是误差。对于MSE，值是基于这些点和它们到线的距离计算的。从这个值中，计算平均值。对于MSE，值越小，你的模型拟合得越好，预测越准确。
- en: MSE is best used to evaluate models when outliers are critical to the prediction
    output.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: MSE最好用于评估模型，当异常值对预测输出至关重要时。
- en: Mean absolute error
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 均方绝对误差
- en: '**Mean Absolute Error**, also known as **MAE**, is similar to MSE, with the
    critical difference that it sums the distances between the points and the prediction
    lines as opposed to computing the mean. It should be noted, MAE does not take
    into account directions in calculating the sum. For instance, if you had two data
    points, equidistant from the line, one being above and the other below, in effect,
    this would be balanced out with a positive and negative value. In machine learning,
    this is referred to as mean bias error, however, ML.NET does not provide this
    as part of the `RegressionMetrics` class at the time of this writing.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**均方绝对误差**，也称为**MAE**，与MSE相似，关键区别在于它将点与预测线之间的距离求和，而不是计算平均值。需要注意的是，MAE在计算总和时不考虑方向。例如，如果你有两个等距离于线的点，一个在上面，一个在下面，实际上，这将通过正负值相互抵消。在机器学习中，这被称为平均偏差误差，然而，ML.NET在撰写本文时并未将其作为`RegressionMetrics`类的一部分提供。'
- en: MAE is best used to evaluate models when outliers are considered simply anomalies
    and shouldn't be counted in evaluating a model's performance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: MAE（均方绝对误差）最好用于评估模型，当异常值被视为简单的异常，不应计入评估模型性能时。
- en: R-squared
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: R平方
- en: R-squared, also called the coefficient of determination, is another method of
    representing how accurate the prediction is compared to the test set. R-squared
    is calculated by taking the sum of the distance between every data point and the
    mean squared, subtracting them and then squaring it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: R平方，也称为确定系数，是另一种表示预测相对于测试集准确性的方法。R平方是通过计算每个数据点到均方距离的总和，然后减去这些距离并平方来计算的。
- en: R-squared values generally range between 0 and 1, represented as a floating-point
    value. A negative value can occur when the fitted model is evaluated to be worse
    than an average fit. However, a low number does not always reflect that the model
    is bad. Predictions such as the one we looked at in this chapter that is based
    on predicting human actions are often found to be under 50%.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: R-平方值通常在 0 到 1 之间，表示为浮点值。当拟合模型被评估为比平均拟合更差时，可能会出现负值。然而，低数值并不总是反映模型不好。本章中我们查看的基于预测人类行为的预测，通常发现低于
    50%。
- en: Conversely, higher values aren't necessarily a sure sign of the model's performance,
    as this could be considered an overfitting of the model. This happens in cases
    when there are a lot of features fed to the model, thereby making the model more
    complex than, for instance, the model we built in [Chapter 1](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml),
    *Getting Started with Machine Learning and ML.NET*, or there is simply not enough
    diversity in the training and test sets. For example, if all of the employees
    were roughly the same values, and the test set holdout was comprised of the same
    ranges of values, this would be considered overfitting.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，较高的值并不一定是模型性能的可靠标志，因为这可能是模型过拟合的迹象。这种情况发生在向模型提供大量特征时，使得模型比例如我们在[第1章](b8d873e1-9234-4f11-ad94-76df5ffbb228.xhtml)“使用机器学习和
    ML.NET 入门”中构建的模型更复杂，或者训练集和测试集的多样性不足。例如，如果所有员工的价值大致相同，并且测试集保留集由相同范围的价值组成，这将被认为是过拟合。
- en: Root mean squared error
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 均方根误差
- en: '**Root mean squared** **error**, also known as **RMSE**, is arguably the easiest
    to understand given the previous methods. Take the following plot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**均方根** **误差**，也称为 **RMSE**，鉴于之前的方法，可以说是最容易理解的。以下是一个示例图：'
- en: '![](img/a9168326-ca8b-49d0-b37b-614cfaf918c1.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9168326-ca8b-49d0-b37b-614cfaf918c1.png)'
- en: In the case of testing the model as we did previously with the holdout set,
    the red dots are the actual values from the test set, while the blue dots are
    the predicted values. The *X*depicted is the distance between the predicted and
    actual values. RMSE simply takes a mean of all of those distances, squares that
    value, and then takes the square root.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试模型的情况下，正如我们之前使用保留集所做的，红色点代表测试集的实际值，而蓝色点代表预测值。图中描绘的 *X* 是预测值和实际值之间的距离。RMSE
    简单地取所有这些距离的平均值，然后平方该值，最后取平方根。
- en: A value under 180 is generally considered a good model.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 低于180的值通常被认为是良好的模型。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we looked into the differences between linear and logistic
    regression models. In addition, we reviewed when to choose linear or logistic
    models along with the trainers ML.NET provides. We also created and trained our
    first linear regression application using SDCA and ML.NET to predict employee
    attrition. We also created a logistic regression application using SDCA and ML.NET
    to provide file classification. Lastly, we also dove into how to evaluate a regression
    model and the various properties that ML.NET exposes to achieve a proper evaluation
    of your regression models.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了线性回归模型和逻辑回归模型之间的差异。此外，我们还回顾了何时选择线性或逻辑模型以及 ML.NET 提供的培训器。我们还使用 SDCA
    和 ML.NET 创建并训练了我们的第一个线性回归应用程序，以预测员工流失。我们还创建了一个逻辑回归应用程序，使用 SDCA 和 ML.NET 提供文件分类。最后，我们还深入探讨了如何评估回归模型以及
    ML.NET 提供的各种属性，以正确评估您的回归模型。
- en: In the next chapter, we will deep dive into binary classification algorithms.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨二元分类算法。
