- en: <st c="0">8</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">8</st>
- en: <st c="2">Creating New Features</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">创建新特征</st>
- en: <st c="23">Adding new features to a dataset can help machine learning models
    learn patterns and important details in the data.</st> <st c="140">For example,
    in finance, the</st> **<st c="169">disposable income</st>**<st c="186">, which
    is the</st> *<st c="201">total income</st>* <st c="213">minus the</st> *<st c="224">acquired
    debt</st>* <st c="237">for any</st> <st c="245">one month, might be more relevant
    for credit risk than just the income or the acquired debt.</st> <st c="339">Similarly,
    the</st> *<st c="354">total acquired debt</st>* <st c="373">of a person across
    financial products, such as a car loan, a mortgage, and credit cards, might be
    more important to estimate the credit risk than any debt considered individually.</st>
    <st c="554">In these examples, we use domain knowledge to craft new variables,
    and these variables are created by adding or subtracting</st> <st c="678">existing
    features.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23">向数据集中添加新特征可以帮助机器学习模型学习数据中的模式和重要细节。</st> <st c="140">例如，在金融领域，**<st
    c="169">可支配收入</st>**<st c="186">，即</st> *<st c="201">总收入</st>** <st c="213">减去</st>
    *<st c="224">已获债务</st>** <st c="237">的任何</st> <st c="245">一个月，可能比仅仅的收入或已获债务更能反映信用风险。</st>
    <st c="339">同样，一个人在金融产品（如汽车贷款、抵押贷款和信用卡）中的**<st c="354">总已获债务</st>** <st c="373">可能比单独考虑的任何债务更能重要地估计信用风险。</st>
    <st c="554">在这些例子中，我们使用领域知识来创建新变量，这些变量是通过添加或减去</st> <st c="678">现有特征</st>来创建的。
- en: <st c="696">In some cases, a variable may not have a linear or monotonic relationship
    with the target, but a polynomial combination might.</st> <st c="824">For example,
    if our variable has a quadratic relationship with the target,</st> ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mrow></math>](img/36.png)<st
    c="899"><st c="900">, we can convert that into a linear relationship by squaring
    the original variable.</st> <st c="984">We can also help linear models better
    understand the relationships between variables and targets by transforming the
    predictors through splines, or by using</st> <st c="1141">decision trees.</st></st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="696">在某些情况下，一个变量可能与目标没有线性或单调关系，但多项式组合可能会有。</st> <st c="824">例如，如果我们的变量与目标有二次关系，</st>
    ![<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup></mrow></mrow></math>](img/36.png)<st
    c="899"><st c="900">，我们可以通过平方原始变量将其转换为线性关系。</st> <st c="984">我们还可以通过使用样条函数或决策树来转换预测变量，从而帮助线性模型更好地理解变量和目标之间的关系。</st>
- en: <st c="1156">The advantage of crafting additional features to train simpler
    models, such as linear or logistic regression, is that both the features and the
    models remain interpretable.</st> <st c="1330">We can explain the reasons driving
    a model’s output to management, clients, and regulators, adding a layer of transparency
    to our machine learning pipelines.</st> <st c="1488">In addition, simpler models
    tend to be faster to train and easier to deploy</st> <st c="1564">and maintain.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1156">为训练简单的模型（如线性或逻辑回归）创建额外特征的优势在于，特征和模型都保持可解释性。</st> <st c="1330">我们可以向管理层、客户和监管机构解释驱动模型输出的原因，为我们的机器学习管道增加一层透明度。</st>
    <st c="1488">此外，简单的模型通常训练速度更快，部署和维护也更容易。</st>
- en: <st c="1577">In this chapter, we will create new features by transforming or
    combining variables with mathematical functions, splines, and</st> <st c="1704">decision
    trees.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1577">在本章中，我们将通过变换或结合变量与数学函数、样条和决策树来创建新特征。</st>
- en: <st c="1719">This chapter will cover the</st> <st c="1748">following recipes:</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1719">本章将涵盖以下配方：</st> <st c="1748">以下内容：</st>
- en: <st c="1766">Combining features with</st> <st c="1791">mathematical functions</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1766">将特征与</st> <st c="1791">数学函数</st>结合
- en: <st c="1813">Comparing features to</st> <st c="1836">reference variables</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1813">比较特征与</st> <st c="1836">参考变量</st>
- en: <st c="1855">Performing</st> <st c="1867">polynomial expansion</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1855">执行</st> <st c="1867">多项式展开</st>
- en: <st c="1887">Combining features with</st> <st c="1912">decision trees</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1887">将特征与</st> <st c="1912">决策树</st>结合
- en: <st c="1926">Creating periodic features from</st> <st c="1959">cyclical variables</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从<st c="1926">周期性变量</st>创建周期性特征
- en: <st c="1977">Creating</st> <st c="1987">spline features</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1977">创建</st> <st c="1987">样条特征</st>
- en: <st c="2002">Technical requirements</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2002">技术要求</st>
- en: <st c="2025">In this chapter, we will use the</st> `<st c="2059">pandas</st>`<st
    c="2065">,</st> `<st c="2067">numpy</st>`<st c="2072">,</st> `<st c="2074">matplotlib</st>`<st
    c="2084">,</st> `<st c="2086">scikit-learn</st>`<st c="2098">, and</st> `<st c="2104">feature-engine</st>`
    <st c="2118">Python libraries.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2025">在本章中，我们将使用</st> `<st c="2059">pandas</st>`<st c="2065">,</st> `<st
    c="2067">numpy</st>`<st c="2072">,</st> `<st c="2074">matplotlib</st>`<st c="2084">,</st>
    `<st c="2086">scikit-learn</st>`<st c="2098">, 和</st> `<st c="2104">feature-engine</st>`
    <st c="2118">Python 库。</st>
- en: <st c="2136">Combining features with mathematical functions</st>
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2136">使用数学函数组合特征</st>
- en: <st c="2183">New features</st> <st c="2196">can be created by combining existing
    variables with mathematical and statistical functions.</st> <st c="2289">Taking
    an example from</st> <st c="2311">the finance industry, we can calcula</st><st
    c="2348">te the total debt of a person by summing up their debt across individual
    financial products, such as car loan, mortgage, or credit</st> <st c="2480">card
    debt:</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2183">新特征</st> <st c="2196">可以通过将现有变量与数学和统计函数相结合来创建。</st> <st c="2289">以金融行业为例，我们可以通过将个人金融产品（如汽车贷款、抵押贷款或信用卡债务）的债务总额加起来来计算一个人的总债务：</st>
    <st c="2348">例如，通过将个人金融产品（如汽车贷款、抵押贷款或信用卡债务）的债务总额加起来来计算一个人的总债务：</st> <st c="2480">总债务
    = 汽车贷款债务 + 信用卡债务 + 抵押贷款债务</st>
- en: '*<st c="2490">Total debt = car loan debt + credit card debt +</st>* *<st c="2539">mortgage
    debt</st>*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="2490">总债务 = 汽车贷款债务 + 信用卡债务 +</st>* *<st c="2539">抵押贷款债务</st>*'
- en: <st c="2552">We can also derive other insightful features using alternative
    statistical operations.</st> <st c="2640">For example, we can determine the maximum
    debt of a customer across financial products or the average time a user spends
    on</st> <st c="2764">a website:</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2552">我们还可以使用其他统计运算推导出其他有洞察力的特征。</st> <st c="2640">例如，我们可以确定客户在金融产品中的最大债务或用户在网站上的平均停留时间：</st>
- en: '*<st c="2774">maximum debt = max(car loan balance, credit card balance,</st>*
    *<st c="2833">mortgage balance)</st>*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="2774">最大债务 = max(汽车贷款余额, 信用卡余额,</st>* *<st c="2833">抵押贷款余额)</st>*'
- en: '*<st c="2850">average time on website = mean(time spent on homepage, time spent
    on about page, time spent on</st>* *<st c="2946">FAQ page)</st>*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="2850">网站平均停留时间 = mean(在主页上花费的时间, 在关于页面上花费的时间, 在</st>* *<st c="2946">常见问题解答页面上花费的时间)</st>*'
- en: <st c="2955">We can, in principle, use any mathematical or statistical operation
    to create new features, such as the product, mean, standard deviation, or maximum
    or minimum values.</st> <st c="3125">In this recipe, we will implement these mathematical
    operations using</st> `<st c="3195">pandas</st>` <st c="3201">and</st> `<st c="3206">feature-engine</st>`<st
    c="3220">.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2955">原则上，我们可以使用任何数学或统计运算来创建新特征，例如乘积、平均值、标准差，或最大或最小值。</st> <st c="3125">在本配方中，我们将使用</st>
    `<st c="3195">pandas</st>` <st c="3201">和</st> `<st c="3206">feature-engine</st>`<st
    c="3220">来实现这些数学运算。</st>
- en: <st c="3221">Note</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3221">注意</st>
- en: <st c="3226">While, in the recipe, we can show you how to combine features with
    mathematical functions, we can’t do justice to the use of domain knowledge in
    deciding which function to apply, as that varies with every domain.</st> <st c="3440">So,
    we will leave that</st> <st c="3463">with yo</st><st c="3470">u.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3226">虽然，在配方中，我们可以向您展示如何使用数学函数组合特征，但我们无法公正地展示在决定应用哪个函数时使用领域知识的用法，因为那会随着每个领域而变化。</st>
    <st c="3440">因此，我们将把这个</st> <st c="3463">留给您。</st>
- en: <st c="3473">Getting ready</st>
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3473">准备中</st>
- en: <st c="3487">In this recipe, we</st> <st c="3507">will use the breast cancer
    dataset from</st> `<st c="3547">scikit-learn</st>`<st c="3559">. The features
    are computed from digitized images of</st> <st c="3612">breast cells and describe
    the characteristics of their cell nuclei, in terms of smoothness, concavity, symmetry,
    and compactness, among others.</st> <st c="3756">Each row contains information
    about the morphology of cell nuclei in a tissue sample.</st> <st c="3842">The
    target variable indicates whether the tissue sample corresponds to cancerous cells.</st>
    <st c="3930">The idea is to predict whether the tissue samples belong to benign
    or malignant breast cells, based on their cell</st> <st c="4044">nuclei morphology.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3487">在本配方中，我们将使用来自</st> `<st c="3547">scikit-learn</st>`<st c="3559">的乳腺癌数据集。这些特征是从乳腺细胞的数字化图像中计算得出的，并描述了它们的细胞核特征，包括平滑度、凹凸度、对称性和紧凑性等。</st>
    <st c="3612">每一行都包含有关组织样本中细胞核形态的信息。</st> <st c="3756">目标变量表示组织样本是否对应于癌细胞。</st>
    <st c="3842">目标是根据细胞核形态预测组织样本是否属于良性或恶性的乳腺细胞。</st>
- en: <st c="4062">To become familiar with the dataset, run the following commands
    in a Jupyter notebook or</st> <st c="4152">Python console:</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4062">为了熟悉数据集，请在 Jupyter 笔记本或</st> <st c="4152">Python 控制台中运行以下命令：</st>
    <st c="4062">为了熟悉数据集，请在 Jupyter 笔记本或Python 控制台中运行以下命令：</st>
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="4261">The preceding code block should print out a description of the
    dataset and an interpretation of</st> <st c="4358">its variab</st><st c="4368">les.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4261">前面的代码块应该会打印出数据集的描述以及其</st> <st c="4358">变量的</st><st c="4368">解释。</st>
    <st c="4261">前面的代码块应该会打印出数据集的描述以及其变量的解释。</st>
- en: <st c="4373">How to do it...</st>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="4373">如何操作...</st>
- en: <st c="4389">In</st> <st c="4393">this recipe, we will create new features by
    combining variables using multiple</st> <st c="4472">mathematical operations:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过使用多种数学运算来组合变量来创建新的特征：<st c="4389">In</st> <st c="4393">这个菜谱中，我们将通过使用多种数学运算来组合变量来创建新的特征：</st>
    <st c="4472">使用以下多种数学运算来组合变量：</st>
- en: <st c="4496">Let’s begin by loading the necessary libraries, classes,</st> <st
    c="4554">and data:</st>
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="4496">让我们首先加载必要的库、类和</st> <st c="4554">数据：</st> <st c="4496">让我们首先加载必要的库、类和数据：</st>
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="4680">Next, load the breast cancer dataset into a</st> `<st c="4725">pandas</st>`
    <st c="4731">DataFrame:</st>
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="4680">接下来，将乳腺癌数据集加载到一个</st> `<st c="4725">pandas</st>` <st c="4731">DataFrame：</st>
    <st c="4680">接下来，将乳腺癌数据集加载到一个pandas DataFrame：</st>
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="4827">In the following code lines, we will create new features by combining
    variables using multiple</st> <st c="4923">mathematical operations.</st>
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="4827">在以下代码行中，我们将通过使用多种数学运算来组合变量来创建新的特征：</st> <st c="4827">在以下代码行中，我们将通过使用多种数学运算来组合变量来创建新的特征：</st>
- en: <st c="4947">Let’s</st> <st c="4953">begin</st> <st c="4959">by creating a list
    with the subset of the features that we want</st> <st c="5024">to combine:</st>
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="4947">Let’s</st> <st c="4953">begin</st> <st c="4959">by creating a list
    with the subset of the features that we want</st> <st c="5024">to combine:</st>
    <st c="4947">让我们首先创建一个列表，包含我们想要组合的特征子集：</st>
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="5147">The features in</st> *<st c="5164">step 3</st>* <st c="5170">represent
    the mean characteristics of cell nuclei in the images.</st> <st c="5236">It might
    be useful to obtain the mean across all</st> <st c="5285">examined characteristics.</st>
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="5147">*步骤 3*中的特征代表了图像中细胞核的平均特征。</st> <st c="5164">可能需要获取所有</st> <st c="5170">检查特征的平均值。</st>
    <st c="5147">*步骤 3*中的特征代表了图像中细胞核的平均特征。</st> <st c="5164">可能需要获取所有检查特征的平均值。</st>
    <st c="5170">It might be useful to obtain the mean across all</st> <st c="5285">examined
    characteristics.</st>
- en: <st c="5310">Let</st><st c="5314">’s get the mean value of the features and
    then display the</st> <st c="5374">resulting feature:</st>
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5310">让我们计算特征的均值，然后显示</st> <st c="5314">结果特征：</st> <st c="5374">然后显示计算得到的特征均值：</st>
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="5467">The following output shows the mean value of the features from</st>
    *<st c="5531">step 3</st>*<st c="5537">:</st>
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="5467">以下输出显示了从</st> *<st c="5531">步骤 3</st>*<st c="5537">中得到的特征的均值：</st>
    <st c="5467">以下输出显示了从*步骤 3*中得到的特征的均值：</st>
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="5624">Similarly, to</st> <st c="5638">capture the general</st> <st c="5659">variability
    of the cell nuclei, let’s determine the standard deviation of the mean characteristics,
    and then display the</st> <st c="5780">resulting feature:</st>
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="5624">同样，为了捕捉细胞核的一般</st> <st c="5638">可变性，让我们确定平均特征的标准差，然后显示</st> <st
    c="5780">结果特征：</st> <st c="5624">同样，为了捕捉细胞核的一般可变性，让我们确定平均特征的标准差，然后显示结果特征：</st>
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="5870">The following output shows the standard deviation of the features
    from</st> <st c="5942">step 3:</st>
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="5870">以下输出显示了从</st> <st c="5942">步骤 3</st>中得到的特征的标准差：</st>
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="6039">Note</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6039">注意</st>
- en: <st c="6044">When we craft new features based on domain knowledge, we know exactly
    how we want to combine the variables.</st> <st c="6153">We could also combine
    features with multiple operations and then evaluate whether they are predictive,
    using, for example, a feature selection algorithm or deriving feature importance
    from the machine</st> <st c="6354">learning model.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6044">当我们根据领域知识构建新的特征时，我们确切地知道我们想要如何组合变量。</st> <st c="6153">我们也可以通过多个操作组合特征，然后使用，例如，特征选择算法或从机器</st>
    <st c="6354">学习模型中推导特征重要性来评估它们是否具有预测性。</st> <st c="6044">当我们根据领域知识构建新的特征时，我们确切地知道我们想要如何组合变量。</st>
    <st c="6153">我们也可以通过多个操作组合特征，然后使用，例如，特征选择算法或从机器学习模型中推导特征重要性来评估它们是否具有预测性。</st>
- en: <st c="6369">Le</st><st c="6372">t’s make a list containing mathematical functions
    that we want to use to combine</st> <st c="6454">the features:</st>
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6369">Le</st><st c="6372">t’s make a list containing mathematical functions
    that we want to use to combine</st> <st c="6454">the features:</st> <st c="6369">让我们创建一个包含我们想要用于组合特征的数学函数的列表：</st>
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="6525">Now, let’s apply the functions from</st> *<st c="6562">step 6</st>*
    <st c="6568">to combine the features from</st> *<st c="6598">step 3</st>*<st c="6604">,
    capturing the</st> <st c="6619">resulting variables in a</st> <st c="6645">new
    DataFrame:</st>
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="6525">现在，让我们应用</st> *<st c="6562">步骤 6</st>* <st c="6568">中的函数来组合</st>
    *<st c="6598">步骤 3</st>*<st c="6604">中的特征，并将结果变量存储在一个新的 DataFrame 中：</st> <st
    c="6525">现在，让我们应用*步骤 6*中的函数来组合*步骤 3*中的特征，并将结果变量存储在一个新的 DataFrame 中：</st>
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="6710">If we</st> <st c="6716">execute</st> `<st c="6725">df_t.head()</st>`<st
    c="6736">, we will see the DataFrame with the newly</st> <st c="6779">created</st>
    <st c="6787">features:</st>
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="6710">如果我们</st> <st c="6716">执行</st> `<st c="6725">df_t.head()</st>`<st
    c="6736">`，我们将看到包含新</st> <st c="6779">创建的特征的 DataFrame：</st> <st c="6710">如果我们执行`df_t.head()`，我们将看到包含新创建的特征的
    DataFrame：</st>
- en: '![Figure 8.1 – A DataFrame with the newly created features](img/B22396_08_1.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 包含新创建特性的 DataFrame](img/B22396_08_1.jpg)'
- en: <st c="7074">Figure 8.1 – A DataFrame with the newly created features</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7074">图 8.1 – 包含新创建特性的 DataFrame</st>
- en: <st c="7130">Note</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7130">注意</st>
- en: '`<st c="7135">pandas</st>` `<st c="7142">agg</st>` <st c="7146">can apply multiple
    functions to combine features.</st> <st c="7197">It can take a list of strings
    with the function names, as we did in</st> *<st c="7265">step 7</st>*<st c="7271">;
    a list of NumPy functions, such as</st> `<st c="7309">np.log</st>`<st c="7315">;
    and Python functions that</st> <st c="7344">you creat</st><st c="7353">e.</st>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="7135">pandas</st>` `<st c="7142">agg</st>` <st c="7146">可以应用多个函数来组合特性。</st>
    <st c="7197">它可以接受一个包含函数名称的字符串列表，就像我们在第</st> *<st c="7265">7</st>* <st c="7271">步</st>中做的那样；一个包含
    NumPy 函数的列表，例如</st> `<st c="7309">np.log</st>`<st c="7315">；以及你创建的 Python 函数。</st>'
- en: <st c="7356">We can create the same features that we created with</st> `<st
    c="7410">pandas</st>` <st c="7416">automatically by</st> <st c="7434">using</st>
    `<st c="7440">feature-engine</st>`<st c="7454">.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7356">我们可以通过使用</st> `<st c="7440">feature-engine</st>`<st c="7454">来创建与使用</st>
    `<st c="7410">pandas</st>` <st c="7416">自动创建的相同特性。</st>
- en: <st c="7455">Let’s create a list by using the name of the</st> <st c="7501">output
    features:</st>
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7455">让我们使用输出特性的名称创建一个列表：</st>
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="7595">Let’s set up</st> `<st c="7609">MathFeatures()</st>` <st c="7623">to
    apply the functions in</st> *<st c="7650">step 6</st>* <st c="7656">to the features
    from</st> *<st c="7678">step 3</st>*<st c="7684">, naming the new features with
    the strings from</st> *<st c="7732">step 8</st>*<st c="7738">:</st>
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7595">让我们设置</st> `<st c="7609">MathFeatures()</st>` <st c="7623">以将第</st>
    *<st c="7650">6</st>* <st c="7656">步</st> *<st c="7678">中的</st>* <st c="7684">特性</st>
    *<st c="7732">应用于第</st>* <st c="7738">8</st>* <st c="7738">步</st>中的字符串，并将新特性命名为第</st>
    *<st c="7732">8</st>* <st c="7738">步</st>中的字符串：</st>
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="7840">Let’s add</st> <st c="7851">the new features</st> <st c="7867">to
    the original DataFrame, capturing the result in a</st> <st c="7921">new variable:</st>
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7840">让我们将</st> <st c="7851">新特性</st> <st c="7867">添加到原始 DataFrame 中，并将结果保存在一个</st>
    <st c="7921">新变量</st>中：</st>
- en: '[PRE12]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="7966">We can display the input and output features by executing</st>
    `<st c="8025">df_t[features +</st>` `<st c="8041">new_feature_name</st><st c="8057">s].head()</st>`<st
    c="8067">:</st>
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="7966">我们可以通过执行</st> `<st c="8025">df_t[features +</st>` `<st c="8041">new_feature_name</st><st
    c="8057">s].head()</st>`<st c="8067">来显示输入和输出特性</st>：
- en: '![Figure 8.2 – DataFrame with the input features and the newly created variables](img/B22396_08_2.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 包含输入特性和新创建变量的 DataFrame](img/B22396_08_2.jpg)'
- en: <st c="8621">Figure 8.2 – DataFrame with the input features and the newly created
    variables</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8621">图 8.2 – 包含输入特性和新创建变量的 DataFrame</st>
- en: <st c="8699">While</st> `<st c="8706">pandas</st>` `<st c="8712">agg</st>` <st
    c="8716">returns a DataFrame with the features resulting from the operation,</st>
    `<st c="8785">feature-engine</st>` <st c="8799">goes one step further, by concatenating
    the new features to the</st> <st c="8864">original</st> <st c="8873">DataFrame.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8699">当</st> `<st c="8706">pandas</st>` `<st c="8712">agg</st>` <st c="8716">返回一个包含操作结果的特性
    DataFrame 时，</st> `<st c="8785">feature-engine</st>` <st c="8799">会进一步操作，通过将新特性连接到</st>
    <st c="8864">原始</st> <st c="8873">DataFrame</st>上。</st>
- en: <st c="8883">How it works...</st>
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8883">它是如何工作的...</st>
- en: '`<st c="8899">pandas</st>` <st c="8906">has many built-in operations to apply
    mathematical and statistical computations to a group of variables.</st> <st c="9012">To
    combine features mathematically, we first made a list containing the names of
    the features we wanted to combine.</st> <st c="9128">Then, we determined the mean
    and standard deviation of those features by using</st> `<st c="9207">pandas</st>`
    `<st c="9213">mean()</st>` <st c="9220">and</st> `<st c="9225">std()</st>`<st
    c="9230">. We could also apply any of the</st> `<st c="9263">sum()</st>`<st c="9268">,</st>
    `<st c="9270">prod()</st>`<st c="9276">,</st> `<st c="9278">max()</st>`<st c="9283">,
    and</st> `<st c="9289">min()</st>` <st c="9294">methods, which return the sum,
    product, maximum, and minimum values of those features, respectively.</st> <st
    c="9396">To perform these operations across the columns, we added the</st> `<st
    c="9457">axis=1</st>` <st c="9463">argument within</st> <st c="9480">the methods.</st>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="8899">pandas</st>` <st c="8906">有许多内置操作，可以将数学和统计计算应用于一组变量。</st> <st
    c="9012">为了在数学上组合特征，我们首先创建了一个包含我们想要组合的特征名称的列表。</st> <st c="9128">然后，我们使用 <st c="9207">pandas</st>
    `<st c="9213">mean()</st>` <st c="9220">和 <st c="9225">std()</st> <st c="9230">来确定这些特征的均值和标准差。</st>
    我们还可以应用任何 <st c="9263">sum()</st> <st c="9268">、<st c="9270">prod()</st> <st c="9276">、<st
    c="9278">max()</st> <st c="9283">和 <st c="9289">min()</st> <st c="9294">方法，分别返回这些特征的求和、乘积、最大值和最小值。</st>
    <st c="9396">为了在列上执行这些操作，我们在方法中添加了 <st c="9457">axis=1</st> <st c="9463">参数。</st>'
- en: <st c="9492">With pandas</st> `<st c="9505">agg()</st>`<st c="9510">, we</st>
    <st c="9515">applied several mathematical functions simultaneously.</st> <st c="9570">It
    takes as arguments a list of strings, corresponding to the functions to apply
    and the</st> `<st c="9659">axis</st>` <st c="9663">that the functions should be
    applied to, which can be either</st> `<st c="9725">1</st>` <st c="9726">for columns
    or</st> `<st c="9742">0</st>` <st c="9743">for rows.</st> <st c="9754">As a result,
    pandas</st> `<st c="9774">agg()</st>` <st c="9779">returned a</st> `<st c="9791">pandas</st>`
    <st c="9797">DataFrame, resulting from applying the mathematical functions to
    the groups</st> <st c="9874">of features.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9492">使用 pandas `<st c="9505">agg()</st>` <st c="9510">，我们同时应用了几个数学函数。</st>
    它接受一个字符串列表作为参数，对应要应用的功能和应该应用功能的 <st c="9659">axis</st> <st c="9663">，可以是 <st c="9725">1</st>
    <st c="9726">（列）或 <st c="9742">0</st> <st c="9743">（行）。</st> <st c="9754">因此，pandas
    `<st c="9774">agg()</st>` <st c="9779">返回了一个 <st c="9791">pandas</st> <st c="9797">DataFrame，它是通过将数学函数应用于特征组
    <st c="9874">而得到的。</st>
- en: <st c="9886">Finally,</st> <st c="9895">we</st> <st c="9899">created the same
    features by combining variables with</st> `<st c="9953">feature-engine</st>`<st
    c="9967">. We used the</st> `<st c="9981">MathFeatures()</st>` <st c="9995">transformer,
    which takes the features to combine and the functions to apply as input; it also
    has the option to indicate the names of the resulting features.</st> <st c="10154">When
    we used</st> `<st c="10167">fit()</st>`<st c="10172">, the transformer did not
    learn parameters but checked that the variables were indeed numerical.</st> <st
    c="10269">The</st> `<st c="10273">transform()</st>` <st c="10284">method triggered
    the use of</st> `<st c="10313">pandas.agg</st>` <st c="10323">under the hood,
    applying the mathematical functions to create the</st> <st c="10390">ne</st><st
    c="10392">w variables.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9886">最后，</st> <st c="9895">我们</st> <st c="9899">通过将变量与</st> `<st c="9953">特征工程</st>`<st
    c="9967">结合</st> <st c="9981">创建了相同的特征。</st> 我们使用了 <st c="9981">MathFeatures()</st>
    <st c="9995">转换器，它接受要组合的特征和要应用的功能作为输入；它还可以选择指示结果的特征的名称。</st> <st c="10154">当我们使用
    <st c="10167">fit()</st> <st c="10172">时，转换器没有学习参数，而是检查变量确实是数值的。</st> <st c="10269">`<st
    c="10273">transform()</st>` <st c="10284">方法触发了在底层使用 `<st c="10313">pandas.agg</st>`
    <st c="10323">，应用数学函数来创建新的变量。</st>
- en: <st c="10405">See also</st>
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10405">另请参阅</st>
- en: <st c="10414">To find out more about the mathematical operations supported by</st>
    `<st c="10479">pandas</st>`<st c="10485">,</st> <st c="10487">visit</st> [<st
    c="10493">https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#computations-descriptive-stats</st>](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#computations-descriptive-stats)<st
    c="10589">.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10414">要了解更多关于 `<st c="10479">pandas</st>` <st c="10485">支持的数学运算，请访问</st>
    [<st c="10493">https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#computations-descriptive-stats</st>](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#computations-descriptive-stats)<st
    c="10589">。</st>
- en: <st c="10590">To learn more about</st> `<st c="10611">pandas</st>` `<st c="10617">aggregate</st>`<st
    c="10627">, check</st> <st c="10635">out</st> [<st c="10639">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.agg</st><st
    c="10718">regate.html</st>](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html)<st
    c="10730">.</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[了解更多关于](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.agg<st
    c="10718">regate.html</st>) `<st c="10611">pandas</st>` `<st c="10617">聚合</st>`
    的信息。'
- en: <st c="10731">Comparing features to reference vari</st><st c="10768">ables</st>
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="10731">比较特征与参考变量</st>
- en: <st c="10774">In the</st> <st c="10782">previous recipe,</st> *<st c="10799">Combining
    features with mathematical functions</st>*<st c="10845">, we created new features
    by applying mathematical</st> <st c="10895">or statistical functions, such as
    the sum or the mean, to a group of variables.</st> <st c="10976">Some mathematical
    operations, however, such as subtraction or division, are performed</st> *<st
    c="11062">between</st>* <st c="11069">features.</st> <st c="11080">Th</st><st
    c="11082">ese operations are useful to derive ratios, such as the</st> *<st c="11139">debt-to-income
    ratio</st>*<st c="11159">:</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10774">在</st> <st c="10782">之前的配方中</st>，*<st c="10799">通过数学函数组合特征</st>*<st
    c="10845">，我们通过应用数学</st> <st c="10895">或统计函数，如总和或平均值，到一组变量上，创建了新的特征。</st> <st
    c="10976">然而，一些数学运算，例如减法或除法，是在</st> *<st c="11062">特征之间</st>* <st c="11069">执行的。</st>
    <st c="11080">这些操作对于推导比率，如</st> *<st c="11139">债务收入比</st>*<st c="11159">，很有用：</st>
- en: '*<st c="11161">debt-to-income ratio = total debt /</st>* *<st c="11197">total
    income</st>*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="11161">债务收入比 = 总债务 /</st>* *<st c="11197">总收入</st>*'
- en: <st c="11209">These operations</st> <st c="11227">are also useful to compute
    differences, such as the</st> *<st c="11279">disposable income</st>*<st c="11296">:</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11209">这些操作</st> <st c="11227">也很有用，可以计算差异，例如</st> *<st c="11279">可支配收入</st>*<st
    c="11296">：</st>
- en: '*<st c="11298">disposable income = income -</st>* *<st c="11327">total debt</st>*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="11298">可支配收入 = 收入 -</st>* *<st c="11327">总债务</st>*'
- en: <st c="11337">In this recipe, we</st> <st c="11356">will learn how to create
    new features by subtracting or dividing variables with</st> `<st c="11437">pandas</st>`
    <st c="11443">and</st> `<st c="11448">feature-engine</st>`<st c="11462">.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11337">在本配方中，我们将学习如何通过使用</st> `<st c="11437">pandas</st>` <st c="11443">和</st>
    `<st c="11448">feature-engine</st>`<st c="11462">来减法或除法变量创建新的特征。</st>
- en: <st c="11463">Note</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11463">注意</st>
- en: <st c="11468">In the recipe, we will show you how to create features with subtraction
    and division.</st> <st c="11555">We hope that the examples, relating to the financial
    sector, shed some light on how to use domain knowledge to decide which features
    to</st> <st c="11691">combine</st> <st c="11699">and how.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11468">在配方中，我们将向您展示如何通过减法和除法创建特征。</st> <st c="11555">我们希望这些与金融部门相关的示例能阐明如何使用领域知识来决定哪些特征需要</st>
    <st c="11691">组合</st> <st c="11699">以及如何组合。</st>
- en: <st c="11707">How to do</st> <st c="11717">it…</st>
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="11707">如何做</st> <st c="11717">它…</st>
- en: <st c="11721">Let’s begin by loading the necessary Python libraries and the
    breast cancer dataset</st> <st c="11806">from scikit-learn:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11721">让我们首先加载必要的Python库和来自scikit-learn的乳腺癌数据集</st> <st c="11806">：</st>
- en: <st c="11824">Load the necessary libraries, classes,</st> <st c="11864">and
    data:</st>
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11824">加载必要的库、类和数据：</st>
- en: '[PRE13]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="11994">Load the breast cancer dataset into a</st> `<st c="12033">pandas</st>`
    <st c="12039">DataFrame:</st>
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11994">将乳腺癌数据集加载到一个</st> `<st c="12033">pandas</st>` <st c="12039">DataFrame：</st>
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="12135">In the breast cancer dataset, some features capture the worst
    and the mean characteristics of the cell nuclei of breast cells.</st> <st c="12263">For
    example, for each image (that is, for each row), we have the worst compactness
    observed in all nuclei and the mean compactness of all nuclei.</st> <st c="12409">A</st>
    <st c="12411">feature that captures the difference between the worst and the mean
    value</st> <st c="12484">could</st> <st c="12491">predict malignancy.</st>
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12135">在乳腺癌数据集中，一些特征捕捉了乳腺细胞细胞核的最坏和平均特征。</st> <st c="12263">例如，对于每个图像（即每行），我们都有所有核中最差的紧密度和所有核的平均紧密度。</st>
    <st c="12409">一个捕捉最坏值和平均值之间差异的特征</st> <st c="12484">可以预测恶性。</st>
- en: <st c="12510">Let’s capture the difference between two features, the</st> `<st
    c="12566">worst compactness</st>` <st c="12583">and</st> `<st c="12588">mean compactness</st>`
    <st c="12604">of cel</st><st c="12611">l nuclei, in a new variable and display</st>
    <st c="12652">its values:</st>
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12510">让我们捕捉两个特征之间的差异，即</st> `<st c="12566">最差紧密度</st>` <st c="12583">和</st>
    `<st c="12588">平均紧密度</st>` <st c="12604">的细胞核，在一个新的变量中，并显示其值：</st> <st c="12652">其值：</st>
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="12760">In the following output, we can see the difference between these</st>
    <st c="12826">feature values:</st>
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12760">在以下输出中，我们可以看到这些特征值之间的差异：</st>
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="12924">Note</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12924">注意</st>
- en: <st c="12929">We can perform the same calculation by executing</st> `<st c="12979">df["difference"]
    = df["worst compactness"] - (</st>``<st c="13025">df["mean compactness"])</st>`<st
    c="13049">.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12929">我们可以通过执行</st> `<st c="12979">df["difference"] = df["worst compactness"]
    - (</st>```<st c="13025">df["mean compactness"])</st>`<st c="13049">来执行相同的计算。</st>
- en: <st c="13050">Similarly, the ratio between the worst and the average characteristic
    of the cell nuclei might be indicative</st> <st c="13160">of malignancy.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13050">同样，细胞核最差特征与平均特征之间的比率可能表明恶性。</st> <st c="13160">恶性。</st>
- en: <st c="13174">Let’s create a new feature with the ratio between the worst and
    mean radius of the nuclei, and then display</st> <st c="13283">its values:</st>
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13174">让我们创建一个新特征，该特征包含核最差半径与平均半径之间的比率，然后显示其值：</st> <st c="13283">其值：</st>
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="13376">In the</st> <st c="13384">following output, we can see the</st>
    <st c="13417">values corresponding to the ratio between</st> <st c="13459">the
    features:</st>
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="13376">在以下输出中，我们可以看到与特征之间的比率对应的值：</st> <st c="13417">以下输出中，我们可以看到这些特征值之间的差异：</st>
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="13558">Note</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13558">注意</st>
- en: <st c="13563">We can calculate the ratio by executing an alternative command,</st>
    `<st c="13628">df["quotient"] = df["worst radius"] / (</st>``<st c="13667">df["me</st><st
    c="13674">an radius"])</st>`<st c="13687">.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13563">我们可以通过执行一个替代命令来计算比率，</st> `<st c="13628">df["quotient"] = df["worst
    radius"] / (</st>```<st c="13667">df["me</st><st c="13674">an radius"])</st>`<st
    c="13687">。</st>
- en: <st c="13688">We can also capture the ratio and difference between every nuclei
    morphology characteristic and the mean radius or mean area of the nuclei.</st>
    <st c="13829">Let’s begin by capturing these subsets of variables</st> <st c="13881">into
    lists.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13688">我们还可以捕捉每个核形态特征与核的平均半径或平均面积之间的比率和差异。</st> <st c="13829">让我们首先将这些变量的子集</st>
    <st c="13881">捕获到列表中。</st>
- en: <st c="13892">Let’s make a list of the features in</st> <st c="13930">the numerator:</st>
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13892">让我们列出分子中的特征：</st> <st c="13930">分子：</st>
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="14032">Let’s make a list of the features in</st> <st c="14070">the denominator:</st>
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14032">让我们列出分母中的特征：</st> <st c="14070">分母：</st>
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="14127">Note</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14127">注意</st>
- en: <st c="14132">We can create features by dividing the features in</st> *<st c="14184">step
    5</st>* <st c="14190">by one of the features in</st> *<st c="14217">step 6</st>*
    <st c="14223">with</st> `<st c="14229">pandas</st>`<st c="14235">, by executing</st>
    `<st c="14250">df[features].div(df["mean radius"])</st>`<st c="14285">. For subtraction,
    we’d execute</st> `<st c="14317">df[features].sub(df["mean radius"])</st>`<st
    c="14352">.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14132">我们可以通过将步骤5中的特征除以步骤6中的特征之一来创建特征，通过执行</st> `<st c="14250">df[features].div(df["mean
    radius"])</st>`<st c="14285">。对于减法，我们将执行</st> `<st c="14317">df[features].sub(df["mean
    radius"])</st>`<st c="14352">。</st>
- en: <st c="14353">Let’s set</st> <st c="14364">up the</st> `<st c="14371">feature-engine</st>`
    <st c="14385">library’s</st> `<st c="14396">RelativeFeatures()</st>` <st c="14414">so
    that it subtracts or divides every feature</st> <st c="14461">from</st> *<st c="14466">step
    5</st>* <st c="14472">with respect to the features from</st> *<st c="14507">step
    6</st>*<st c="14513">:</st>
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14353">让我们设置</st> <st c="14364">`feature-engine`</st> <st c="14371">库的</st>
    `<st c="14396">RelativeFeatures()</st>` <st c="14414">，以便它从步骤5中的每个特征中减去或除以步骤6中的特征：</st>
    <st c="14513">：</st>
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="14607">Note</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14607">注意</st>
- en: <st c="14612">Subtracting the features from</st> *<st c="14643">step 5</st>*
    <st c="14649">and</st> *<st c="14654">step 6</st>* <st c="14660">does not make
    biological sense, but we will do it anyway to demonstrate the use of the</st>
    `<st c="14748">RelativeFeatures()</st>` <st c="14766">transformer.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14612">从步骤5和步骤6中减去特征没有生物学意义，但我们将这样做以演示使用</st> `<st c="14748">RelativeFeatures()</st>`
    <st c="14766">转换器。</st>
- en: <st c="14779">Let’s add the new features to the DataFrame and capture the result
    in a</st> <st c="14852">new variable:</st>
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14779">让我们将新特征添加到DataFrame中，并将结果保存在一个</st> <st c="14852">新变量</st>中：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="14898">Let’s capture the names of the new features in</st> <st c="14946">a
    list:</st>
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14898">让我们将新特征的名称保存在</st> <st c="14946">一个列表</st>中：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="15053">Note</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15053">注意</st>
- en: '`<st c="15058">feature_names_in_</st>` <st c="15076">is a</st> <st c="15082">common
    attribute in</st> `<st c="15102">scikit-learn</st>` <st c="15114">and</st> `<st
    c="15119">feature-engine</st>` <st c="15133">transformers and stores the name
    of the variables from the DataFrame used to fit the transformer.</st> <st c="15232">In
    other words, it stores the names of the input features.</st> <st c="15291">When
    using</st> `<st c="15302">transform()</st>`<st c="15313">, the transformers check
    that the features from the new input dataset match those used during training.</st>
    <st c="15417">In</st> *<st c="15420">step 9</st>*<st c="15426">, we leverage this
    attribute to find the additional variables added to the data after</st> <st c="15512">the
    transformation.</st>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="15058">feature_names_in_</st>` <st c="15076">是</st> <st c="15082">scikit-learn</st>
    <st c="15102">和</st> `<st c="15119">feature-engine</st>` <st c="15133">转换器中的一个常见属性，它存储了用于拟合转换器的DataFrame中的变量名称。</st>
    <st c="15232">换句话说，它存储了输入特征的名称。</st> <st c="15291">当使用</st> `<st c="15302">transform()</st>`<st
    c="15313">时，转换器会检查新输入数据集中的特征是否与训练期间使用的特征匹配。</st> <st c="15417">在</st> *<st c="15420">步骤9</st>*<st
    c="15426">中，我们利用这个属性来查找在转换后添加到数据中的额外变量。</st>'
- en: <st c="15531">If we</st> <st c="15537">execute</st> `<st c="15546">print(new_features)</st>`<st
    c="15565">, we</st> <st c="15569">will see a list with the names of the features
    created by</st> `<st c="15628">ReferenceFeatures()</st>`<st c="15647">. Note</st>
    <st c="15654">that the features contain the variables on the left- and right-hand
    sides of the mathematical equation, plus the function that was applied to them
    to create the</st> <st c="15815">new feature:</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15531">如果我们</st> <st c="15537">执行</st> `<st c="15546">print(new_features)</st>`<st
    c="15565">，我们将看到一个包含由</st> `<st c="15628">ReferenceFeatures()</st>`<st c="15647">创建的特征名称的列表。</st>
    <st c="15654">注意</st> <st c="15654">，这些特征包含数学方程式左侧和右侧的变量，以及应用于它们的函数以创建</st> <st
    c="15815">新特征：</st>
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="16364">Finally, we can display the first five rows of the resulting variables
    by</st> <st c="16439">executing</st> `<st c="16449">df</st><st c="16451">_t[new_features].head()</st>`<st
    c="16475">:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16364">最后，我们可以通过</st> <st c="16439">执行</st> `<st c="16449">df</st><st
    c="16451">_t[new_features].head()</st>`<st c="16475">:</st>
- en: '![Figure 8.3 – A DataFrame with the newly created features](img/B22396_08_3.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 包含新创建特征的DataFrame](img/B22396_08_3.jpg)'
- en: <st c="16983">Figure 8.3 – A DataFrame with the newly created features</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16983">图8.3 – 包含新创建特征的DataFrame</st>
- en: '`<st c="17039">feature-engine</st>` <st c="17054">adds</st> <st c="17060">new
    features as columns</st> <st c="17083">at the right of the original DataFrame
    and automatically adds variable names to those features.</st> <st c="17180">By
    doing so,</st> `<st c="17193">feature-engine</st>` <st c="17207">automates much
    of the manual work tha</st><st c="17245">t we would do</st> <st c="17260">with</st>
    `<st c="17265">pandas</st>`<st c="17271">.</st>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="17039">feature-engine</st>` <st c="17054">将</st> <st c="17060">新特征作为列</st>
    <st c="17083">添加到原始DataFrame的右侧，并自动将这些特征的变量名添加到其中。</st> <st c="17180">通过这样做，</st>
    `<st c="17193">feature-engine</st>` <st c="17207">自动化了我们本应使用</st><st c="17245">pandas</st>
    <st c="17271">完成的许多手动工作。</st>'
- en: <st c="17272">How it works...</st>
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17272">它是如何工作的...</st>
- en: '`<st c="17288">pandas</st>` <st c="17295">has many built-in operations to compare
    a feature or a group of features to a reference variable.</st> <st c="17394">In
    this recipe, we used pandas</st> `<st c="17425">sub()</st>` <st c="17430">and</st>
    `<st c="17435">div()</st>` <st c="17440">to determine the difference or the ratio
    between two variables, or a subset of variables and one</st> <st c="17538">refe</st><st
    c="17542">rence feature.</st>'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="17288">pandas</st>` <st c="17295">有许多内置操作可以比较一个特征或一组特征与一个参考变量。</st>
    <st c="17394">在这个配方中，我们使用了pandas</st> `<st c="17425">sub()</st>` <st c="17430">和</st>
    `<st c="17435">div()</st>` <st c="17440">来确定两个变量或一组变量与一个</st> <st c="17538">参考特征</st><st
    c="17542">之间的差异或比率。</st>'
- en: <st c="17557">To subtract one variable from another, we applied</st> `<st c="17608">sub()</st>`
    <st c="17613">to a</st> `<st c="17619">pandas</st>` <st c="17625">series with
    the first variable, passing the</st> `<st c="17670">pandas</st>` <st c="17676">series
    with the second variable as an argument to</st> `<st c="17727">sub()</st>`<st
    c="17732">. This operation returned a third</st> `<st c="17766">pandas</st>` <st
    c="17772">series with the difference between the first and second variables.</st>
    <st c="17840">To divide one variable from another, we used</st> `<st c="17885">div()</st>`<st
    c="17890">, which works identically to</st> `<st c="17919">sub()</st>` <st c="17924">–
    that is, it divides the variable on the left by the variable passed as an argument</st>
    <st c="18010">of</st> `<st c="18013">div()</st>`<st c="18018">.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从一个变量中减去另一个变量，我们对第一个变量应用了`<st c="17608">sub()</st>` `<st c="17613">`到`<st
    c="17619">pandas</st>` `<st c="17625">`系列，并将第二个变量的`<st c="17670">pandas</st>`
    `<st c="17676">`系列作为参数传递给`<st c="17727">sub()</st>` `<st c="17732">`。这个操作返回了一个第三个`<st
    c="17766">pandas</st>` `<st c="17772">`系列，其中包含第一个和第二个变量之间的差值。《st c="17840">要除以另一个变量，我们使用了</st>
    `<st c="17885">div()</st>` `<st c="17890">`，它的工作方式与`<st c="17919">sub()</st>`
    `<st c="17924">`相同——也就是说，它将左侧的变量除以作为`<st c="18013">div()</st>` `<st c="18018">`参数传递的变量。
- en: <st c="18019">Then, we combined several variables with two reference variables
    automatically via subtraction or division, by utilizing</st> `<st c="18141">ReferenceFeatures()</st>`
    <st c="18160">from</st> `<st c="18166">Feature-engine</st>`<st c="18180">. The</st>
    `<st c="18186">ReferenceFeatures()</st>` <st c="18205">transformer takes the variables
    to be combined, the reference variables, and the functions to use to combine them.</st>
    <st c="18321">When using</st> `<st c="18332">fit()</st>`<st c="18337">, the transformer
    did not learn about parameters but checked that the variables were numerical.</st>
    <st c="18433">Executing</st> `<st c="18443">transform()</st>` <st c="18454">added
    the new features to</st> <st c="18481">the DataFrame.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过利用`<st c="18141">ReferenceFeatures()</st>` `<st c="18160">from</st> `<st
    c="18166">Feature-engine</st>`<st c="18180">`自动将几个变量与两个参考变量通过减法或除法组合起来。`<st c="18186">ReferenceFeatures()</st>`
    `<st c="18205">transformer`接受要组合的变量、参考变量以及用于组合它们的函数。`<st c="18321">当使用</st> `<st
    c="18332">fit()</st>`<st c="18337">`时，转换器没有学习参数，而是检查了变量是否为数值型。《st c="18433">执行</st>
    `<st c="18443">transform()</st>` `<st c="18454">`将新特征添加到`<st c="18481">DataFrame</st>`中。
- en: <st c="18495">Note</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: '`<st c="18500">ReferenceFeatures()</st>` <st c="18520">can also add, multiply,
    get the modulo, or get the power of a group of variables relating to a second
    group of reference variables.</st> <st c="18653">You can find out more in its</st>
    <st c="18682">documentation:</st> [<st c="18697">https://feature-engine.readthedocs.io/en/latest/api_doc/creation/RelativeFeatures.html</st>](https://feature-engine.readthedocs.io/en/latest/api_doc/creation/RelativeFeatures.html)<st
    c="18783">.</st>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18500">ReferenceFeatures()</st>` `<st c="18520">`还可以对与第二组参考变量相关的一组变量进行加法、乘法、取模或求幂操作。《st
    c="18653">您可以在其</st> `<st c="18682">文档</st>` `<st c="18697">[https://feature-engine.readthedocs.io/en/latest/api_doc/creation/RelativeFeatures.html](https://feature-engine.readthedocs.io/en/latest/api_doc/creation/RelativeFeatures.html)`
    `<st c="18783">`中了解更多信息。'
- en: <st c="18784">See also</st>
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: <st c="18793">To learn more about the binary operations supported by</st> `<st
    c="18849">pandas</st>`<st c="18855">,</st> <st c="18857">visit</st> [<st c="18863">https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#binary-operator-functions</st>](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#binary-operator-functions)<st
    c="18954">.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`<st c="18849">pandas</st>` `<st c="18855">`支持的二进制操作，请访问[https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#binary-operator-functions](https://pandas.pydata.org/pandas-docs/stable/reference/frame.html#binary-operator-functions)。
- en: <st c="18955">Performing polynomial expansion</st>
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行多项式展开
- en: <st c="18987">Simple</st> <st c="18995">models, such as linear and logistic
    regression, can capture complex patterns if we feed them the right features.</st>
    <st c="19108">Sometimes, we can create powerful features by combining the variables
    in our datasets with themselves or with other variables.</st> <st c="19235">For
    example, in the following figure, we can see that the target,</st> *<st c="19301">y</st>*<st
    c="19302">, has a quadratic relation with the variable,</st> *<st c="19348">x</st>*<st
    c="19349">, and as shown in the left panel, a linear model is not able to capture
    that</st> <st c="19426">relationship accurately:</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18987">简单的</st> <st c="18995">模型，例如线性回归和逻辑回归，如果我们向它们提供正确的特征，可以捕捉到复杂的模式。</st>
    <st c="19108">有时，我们可以通过将数据集中的变量与自身或其他变量组合来创建强大的特征。</st> <st c="19235">例如，在下面的图中，我们可以看到目标，</st>
    *<st c="19301">y</st>*<st c="19302">，与变量，</st> *<st c="19348">x</st>*<st c="19349">，具有二次关系，并且如图左侧面板所示，线性模型无法准确捕捉这种</st>
    <st c="19426">关系：</st>
- en: "![Figure 8.4 – A linear model fit to predict a target, y, from a feature, x,\
    \ which has a quadratic relationship to the target, before and after squaring\
    \ x. In the left panel: the model offers a poor fit by using the original variable;\
    \ in the right panel, the model offers a better fit, based on the squar\uFEFF\
    e of the original variable](img/B22396_08_4.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 一个线性模型拟合预测目标y，其中特征x与目标具有二次关系，在平方x之前和之后。在左侧面板：模型使用原始变量提供较差的拟合；在右侧面板，模型基于原始变量的平方提供更好的拟合](img/B22396_08_4.jpg)'
- en: '<st c="19506">Figure 8.4 – A linear model fit to predict a target, y, from
    a feature, x, which has a quadratic relationship to the target, before and after
    squaring x.</st> <st c="19660">In the left panel: the model offers a poor fit
    by using the original variable; in the right panel, the model offers a better
    fit, based on the squar</st><st c="19808">e of the original variable</st>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19506">图8.4 – 一个线性模型拟合预测目标y，其中特征x与目标具有二次关系，在平方x之前和之后。</st> <st c="19660">在左侧面板：模型使用原始变量提供较差的拟合；在右侧面板，模型基于原始变量的平方提供更好的拟合</st><st
    c="19808">的平方</st>
- en: <st c="19835">This linear</st> <st c="19848">model has a quadratic relationship
    to the target, before and after squaring</st> *<st c="19924">x</st>*<st c="19925">.
    However, if we square</st> *<st c="19949">x</st>*<st c="19950">, or, in other
    words, if we create a second-degree polynomial of the feature, the linear model
    can accurately predict the target,</st> *<st c="20080">y</st>*<st c="20081">,
    from the square of</st> *<st c="20102">x</st>*<st c="20103">, as we see in the</st>
    <st c="20122">right panel.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19835">这个线性</st> <st c="19848">模型在平方</st> *<st c="19924">x</st>*<st c="19925">之前和之后都与目标具有二次关系。然而，如果我们平方</st>
    *<st c="19949">x</st>*<st c="19950">，换句话说，如果我们创建特征的二次多项式，线性模型可以准确地从</st> *<st
    c="20102">x</st>*<st c="20103">的平方预测目标，</st> *<st c="20080">y</st>*<st c="20081">，正如我们在</st>
    <st c="20122">右侧面板中看到的那样。</st>
- en: <st c="20134">Another classical example in which a simple feature can make a
    simple model, such as logistic regression, understand the underlying relationship
    in the data is the</st> **<st c="20299">XOR</st>** <st c="20302">situation.</st>
    <st c="20314">In</st> <st c="20316">the left panel of the following diagram, we
    see how the target class is distributed across the values of</st> *<st c="20422">x1</st>*
    <st c="20424">and</st> *<st c="20429">x2</st>* <st c="20431">(the class is highlighted
    with different</st> <st c="20473">color shades):</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20134">另一个简单的特征可以使简单模型，如逻辑回归，理解数据中潜在关系的经典例子是**<st c="20299">XOR</st>**
    <st c="20302">情况。</st> <st c="20314">在以下图的左侧面板中，我们看到目标类别是如何分布在</st> *<st c="20422">x1</st>*
    <st c="20424">和</st> *<st c="20429">x2</st>* <st c="20431">（类别用不同的</st> <st c="20473">颜色阴影突出显示）的值上的：</st>
- en: '![Figure 8.5 – An illustration of the XOR relationship and how combining features
    allows a full class separation](img/B22396_08_5.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – XOR关系示意图以及如何通过组合特征实现完整的类别分离](img/B22396_08_5.jpg)'
- en: <st c="20592">Figure 8.5 – An illustration of the XOR relationship and how combining
    features allows a full class separation</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20592">图8.5 – XOR关系示意图以及如何通过组合特征实现完整的类别分离</st>
- en: <st c="20702">If both features are positive, or both features are negative,
    then the class is 1, but if the features take different signs, then the class
    is 0 (left panel).</st> <st c="20862">Logistic regression will not be able to
    pick this pattern from each individual feature because, as we can see in the middle
    panel, there</st> <st c="20998">is significant class overlap across the values
    of the feature – in this case, x1\.</st> <st c="21081">However, multiplying x1
    by x2 creates a feature that allows a logistic regression to predict the classes
    accurately because x3, as can we see in the right panel, allows the classes to
    be</st> <st c="21268">clearly separated.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20702">如果两个特征都是正的，或者两个特征都是负的，那么类别是1，但如果特征具有不同的符号，那么类别是0（左侧面板）。</st> <st
    c="20862">逻辑回归无法从每个单独的特征中识别出这种模式，因为，如中间面板所示，特征值之间存在显著的类别重叠 – 在这种情况下，x1。</st> <st
    c="20998">然而，将x1乘以x2创建了一个特征，这使得逻辑回归能够准确预测类别，因为x3，如右面板所示，允许类别被</st> <st c="21268">清楚地分离。</st>
- en: <st c="21286">With similar logic, polynomial combinations of the same or different
    variables can return new variables that convey additional information and capture
    feature interaction thereby resulting in useful inputs for linear models.</st>
    <st c="21512">With huge datasets, analyzing every possible variable combination
    is not always possible.</st> <st c="21602">But we can create several polynomial
    variables automatically, using, for example,</st> `<st c="21684">scikit-learn</st>`<st
    c="21696">, and we can let the model decide which variables are useful.</st> <st
    c="21758">In this recipe, we will learn how to create multiple features through
    polynomial comb</st><st c="21843">inations</st> <st c="21853">using scikit-learn.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21286">使用类似的逻辑，相同或不同变量的多项式组合可以返回包含额外信息的新变量，并捕获特征交互，从而为线性模型提供有用的输入。</st>
    <st c="21512">在大型数据集中，分析每个可能的变量组合并不总是可能的。</st> <st c="21602">但我们可以使用例如</st> `<st
    c="21684">scikit-learn</st>`<st c="21696">自动创建几个多项式变量，并让模型决定哪些变量是有用的。</st> <st
    c="21758">在这个菜谱中，我们将学习如何使用scikit-learn通过多项式组合创建多个特征。</st>
- en: <st c="21872">Getting ready</st>
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="21872">准备就绪</st>
- en: <st c="21886">Polynomial expansion serves to automate the creation of new features,
    capture feature interaction, and potential non-linear relationships between the
    original variables and the target.</st> <st c="22072">To create polynomial features,
    we need to determine which features to combine and which polynomial degree</st>
    <st c="22178">to use.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21886">多项式展开用于自动化新特征的创建，捕获特征交互，以及原始变量和目标之间的潜在非线性关系。</st> <st c="22072">要创建多项式特征，我们需要确定要组合哪些特征以及使用哪个多项式度数</st>
    <st c="22178">。</st>
- en: <st c="22185">Note</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22185">注意</st>
- en: <st c="22190">While determining the features to combine or the degree of the
    polynomial combination is not an easy task, keep in mind that high polynomial
    degrees will result in a lot of new features and may lead to overfitting.</st>
    <st c="22406">In general, we keep the degree low, to a maximum of 2</st> <st c="22460">or
    3.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22190">虽然确定要组合的特征或多项式组合的度数不是一项容易的任务，但请记住，高多项式度数将导致大量新特征的生成，并可能导致过拟合。</st>
    <st c="22406">一般来说，我们保持度数较低，最多为2</st> <st c="22460">或3。</st>
- en: <st c="22465">The</st> `<st c="22470">PolynomialFeatures()</st>` <st c="22490">transformer
    from</st> `<st c="22508">scikit-learn</st>` <st c="22520">creates polynomial combinations
    of the features with a degree less than or equal to a user-specified</st> <st
    c="22622">degree, automatically.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22465">The</st> `<st c="22470">PolynomialFeatures()</st>` <st c="22490">转换器来自</st>
    `<st c="22508">scikit-learn</st>` <st c="22520">，它自动创建小于或等于用户指定</st> <st c="22622">度数的特征的多项式组合。</st>
- en: <st c="22644">To follow up easily with this recipe, let’s first understand the
    output of</st> `<st c="22720">PolynomialFeatures()</st>` <st c="22740">when used
    to create second- and third-degree polynomial combinations of</st> <st c="22813">th</st><st
    c="22815">ree variables.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22644">为了轻松跟进这个菜谱，让我们首先了解当使用</st> `<st c="22720">PolynomialFeatures()</st>`
    <st c="22740">创建三个变量的二次和三次多项式组合时的输出。</st>
- en: <st c="22830">Second-degree polynomial combinations of three variables –</st>
    *<st c="22890">a</st>*<st c="22891">,</st> *<st c="22893">b</st>*<st c="22894">,
    and</st> *<st c="22900">c</st>* <st c="22901">– will return the following</st>
    <st c="22930">new features:</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22830">三个变量的二次多项式组合 –</st> *<st c="22890">a</st>*<st c="22891">,</st>
    *<st c="22893">b</st>*<st c="22894">, 和</st> *<st c="22900">c</st>* <st c="22901">–
    将返回以下</st> <st c="22930">新特征：</st>
- en: '*<st c="22943">1, a, b, c, ab, ac, bc, a2,</st>* *<st c="22972">b2, c2</st>*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="22943">1, a, b, c, ab, ac, bc, a2,</st>* *<st c="22972">b2, c2</st>*'
- en: <st c="22978">From</st> <st c="22983">the previous features,</st> *<st c="23007">a</st>*<st
    c="23008">,</st> *<st c="23010">b</st>*<st c="23011">, and</st> *<st c="23017">c</st>*
    <st c="23018">are the original variables;</st> *<st c="23047">ab</st>*<st c="23049">,</st>
    *<st c="23051">ac</st>*<st c="23053">, and</st> *<st c="23059">bc</st>* <st c="23061">are
    the products of those features; and</st> *<st c="23102">a2</st>*<st c="23104">,</st>
    *<st c="23106">b2</st>*<st c="23108">, and</st> *<st c="23114">c2</st>* <st c="23116">are
    the squared values of the original features.</st> `<st c="23166">PolynomialFeatures()</st>`
    <st c="23186">also returns the bias term</st> *<st c="23214">1</st>*<st c="23215">,
    which we would probably exclude when</st> <st c="23254">creating features.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22978">从前面的特征中，</st> *<st c="22983">a</st>*<st c="22984">,</st> *<st
    c="22986">b</st>*<st c="22987">, 和</st> *<st c="22993">c</st>* <st c="22994">是原始变量；</st>
    *<st c="23023">ab</st>*<st c="23025">,</st> *<st c="23027">ac</st>*<st c="23029">,
    和</st> *<st c="23035">bc</st>* <st c="23037">是这些特征的乘积；并且</st> *<st c="23128">a2</st>*<st
    c="23130">,</st> *<st c="23132">b2</st>*<st c="23134">, 和</st> *<st c="23140">c2</st>*
    <st c="23142">是原始特征的平方值。</st> `<st c="23166">PolynomialFeatures()</st>` <st c="23186">还返回偏置项</st>
    *<st c="23214">1</st>*<st c="23215">，在创建特征时我们可能会排除它。</st>
- en: <st c="23272">Note</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23272">注意</st>
- en: <st c="23277">The resulting features –</st> *<st c="23303">ab</st>*<st c="23305">,</st>
    *<st c="23307">ac</st>*<st c="23309">, and</st> *<st c="23315">bc</st>* <st c="23317">–
    are</st> <st c="23324">called</st> **<st c="23331">interactions</st>** <st c="23343">or
    feature interactions of</st> **<st c="23371">degree 2</st>**<st c="23379">. The
    degree</st> <st c="23392">reflects the number of variables combined.</st> <st
    c="23435">The result combines a maximum of two variables because we indicated
    a second-degree polynomial as the maximum</st> <st c="23545">allowed combination.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23277">结果特征 –</st> *<st c="23303">ab</st>*<st c="23305">,</st> *<st c="23307">ac</st>*<st
    c="23309">, 和</st> *<st c="23315">bc</st>* <st c="23317">– 被称为</st> <st c="23324">**交互**</st>
    <st c="23344">或</st> **<st c="23372">二阶</st>**<st c="23380">的特征交互。度数</st> <st
    c="23392">反映了组合的变量数量。</st> <st c="23435">结果最多组合两个变量，因为我们指定了二次多项式为允许的最大组合。</st>
- en: <st c="23565">Third-degree polynomial combinations of the three variables –</st>
    *<st c="23628">a</st>*<st c="23629">,</st> *<st c="23631">b</st>*<st c="23632">,
    and</st> *<st c="23638">c</st>* <st c="23639">– will return the following</st>
    <st c="23668">new features:</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23565">三个变量的三次多项式组合 –</st> *<st c="23628">a</st>*<st c="23629">,</st>
    *<st c="23631">b</st>*<st c="23632">, 和</st> *<st c="23638">c</st>* <st c="23639">–
    将返回以下</st> <st c="23668">新特征：</st>
- en: '*<st c="23681">1, a, b, c, ab, ac, bc, abc, a2b, a2c, b2a, b2c, c2a, c2b, a3,</st>*
    *<st c="23745">b3, c3</st>*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="23681">1, a, b, c, ab, ac, bc, abc, a2b, a2c, b2a, b2c, c2a, c2b, a3,</st>*
    *<st c="23745">b3, c3</st>*'
- en: <st c="23751">Among the returned features, in addition to those returned by
    the second-degree polynomial combination, we now have the third-degree combinations
    of the features with themselves (</st>*<st c="23931">a3</st>*<st c="23934">,</st>
    *<st c="23936">b3</st>*<st c="23938">, and</st> *<st c="23944">c3</st>*<st c="23946">),
    the squared values of every feature combined linearly with a second feature (</st>*<st
    c="24027">a2b</st>*<st c="24031">,</st> *<st c="24033">a2c</st>*<st c="24036">,</st>
    *<st c="24038">b2a</st>*<st c="24041">,</st> *<st c="24043">b2c</st>*<st c="24046">,</st>
    *<st c="24048">c2a</st>*<st c="24051">, and</st> *<st c="24057">c2b</st>*<st c="24060">),
    and the product of the three features (</st>*<st c="24103">abc</st>*<st c="24107">).</st>
    <st c="24111">Note how we have all possible interactions of degrees 1, 2, and
    3 and the bias</st> <st c="24190">term</st> *<st c="24194">1</st>*<st c="24196">.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的特征中，除了由二次多项式组合返回的特征外，我们现在还有特征与自身进行的三次组合（<st c="23751">a3</st>、<st c="23931">b3</st>、<st
    c="23934">、<st c="23936">c3</st>），每个特征与第二个特征进行线性组合的平方值（<st c="24027">a2b</st>、<st
    c="24031">a2c</st>、<st c="24033">b2a</st>、<st c="24043">b2c</st>、<st c="24048">c2a</st>、<st
    c="24057">c2b</st>），以及三个特征的乘积（<st c="24103">abc</st>）。</st> <st c="24111">注意我们如何包含了所有可能的一、二、三次度的交互以及偏差</st>
    <st c="24190">项</st> *<st c="24194">1</st>。</st>
- en: <st c="24197">Now that we understand the output of the polynomial expansion
    implemented by</st> `<st c="24275">scikit-lea</st><st c="24285">rn</st>`<st c="24288">,
    let’s jump into</st> <st c="24306">the recipe.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24197">现在我们理解了由`<st c="24275">scikit-lea</st><st c="24285">rn</st>`<st
    c="24288">`实现的`多项式展开的输出，让我们直接进入</st> <st c="24306">步骤。</st>
- en: <st c="24317">How to do it...</st>
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24317">如何操作...</st>
- en: <st c="24333">In this</st> <st c="24342">recipe, we will create features with
    polynomial expansion using a toy dataset to become familiar with the resulting
    variables.</st> <st c="24469">Creating features with the polynomial expansion
    of a real dataset is identical to what we will discuss in</st> <st c="24575">this
    recipe:</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24333">在这个</st> <st c="24342">步骤中，我们将使用一个玩具数据集创建具有多项式展开的特征，以便熟悉生成的变量。</st>
    <st c="24469">创建具有真实数据集多项式展开的特征与我们在</st> <st c="24575">本步骤中讨论的内容相同：</st>
- en: <st c="24587">Let’s import the required libraries, classes,</st> <st c="24634">and
    data:</st>
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24587">让我们导入所需的库、类</st> <st c="24634">和数据：</st>
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="24798">Let’s set</st> `<st c="24809">scikit-learn</st>` <st c="24821">library’s</st>
    `<st c="24832">set_output</st>` <st c="24842">API globally so that all transformers
    return a DataFrame as a result of the</st> `<st c="24919">transform()</st>` <st
    c="24930">method:</st>
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24798">让我们设置`<st c="24809">scikit-learn</st>` <st c="24821">库的`<st c="24832">set_output</st>`
    <st c="24842">API全局，以便所有转换器在`<st c="24919">transform()</st>` <st c="24930">方法的结果返回一个DataFrame：</st>
- en: '[PRE26]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="24976">Let’s</st> <st c="24983">create a DataFrame containing one variable,
    with values from 1</st> <st c="25046">to 10:</st>
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="24976">让我们</st> <st c="24983">创建一个包含一个变量的DataFrame，其值从1</st> <st c="25046">到10：</st>
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="25112">Let’s set up</st> `<st c="25126">PolynomialFeatures()</st>` <st
    c="25146">to create all possible combinations up to a third-degree polynomial
    of the single variable and exclude the bias term from the result – that is, we
    will exclude the</st> <st c="25311">value</st> *<st c="25317">1</st>*<st c="25318">:</st>
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25112">让我们设置</st> `<st c="25126">PolynomialFeatures()</st>` <st c="25146">以创建单变量的所有可能的三次多项式组合，并从结果中排除偏差项
    – 即，我们将排除</st> <st c="25311">值</st> *<st c="25317">1</st>。</st>
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="25400">Now, let’s create the</st> <st c="25423">polynomial combinations:</st>
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="25400">现在，让我们创建</st> <st c="25423">多项式组合：</st>
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="25476">If we execute</st> `<st c="25491">dft</st>`<st c="25494">, we’ll</st>
    <st c="25502">see a DataFrame with the original feature, followed by its values
    squared, and then its values to the power</st> <st c="25610">of three:</st>
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25476">如果我们执行</st> `<st c="25491">dft</st>`<st c="25494">`，我们将</st> <st
    c="25502">看到一个包含原始特征、其值的平方以及其值的三次幂的DataFrame：</st>
- en: '![Figure 8.6 – A DataFrame with the polynomial expansion of the third degree
    of a single variable](img/B22396_08_6.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 一个包含单变量三次多项式展开的DataFrame](img/B22396_08_6.jpg)'
- en: <st c="25812">Figure 8.6 – A DataFrame with the polynomial expansion of the
    third degree of a single variable</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25812">图8.6 – 一个包含单变量三次多项式展开的DataFrame</st>
- en: <st c="25907">If, instead</st> <st c="25920">of returning a DataFrame,</st>
    `<st c="25946">PolynomialFeatures()</st>` <st c="25966">returns a NumPy array
    and you want to obtain the names of the features in the array, you can do so by
    executing</st> `<st c="26079">poly.get_feature_names_out()</st>`<st c="26107">,
    which returns</st> `<st c="26123">array(['var', 'var^2', '</st>``<st c="26147">var^3'],
    dtype=object)</st>`<st c="26170">.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25907">如果我们</st> <st c="25920">不返回一个DataFrame，</st> `<st c="25946">PolynomialFeatures()</st>`
    <st c="25966">返回一个NumPy数组，并且你想获取数组中特征的名称，你可以通过执行</st> `<st c="26079">poly.get_feature_names_out()</st>`<st
    c="26107">来实现，它返回</st> `<st c="26123">array(['var', 'var^2', '</st>``<st c="26147">var^3'],
    dtype=object)</st>`<st c="26170">。</st>
- en: <st c="26171">Now, let’s plot the new feature values against the</st> <st c="26223">original
    variable:</st>
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26171">现在，让我们将新的特征值与原始变量进行绘图：</st>
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="26424">In the following diagram, we can see the relationship between
    the polynomial fea</st><st c="26505">tures and the</st> <st c="26520">original
    variable:</st>
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26424">在下面的图中，我们可以看到多项式特征与原始变量之间的关系：</st>
- en: '![Figure 8.7 – The relationship between the features resulting from polynomial
    expansion and the original variable](img/B22396_08_7.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 多项式展开得到的特征与原始变量的关系](img/B22396_08_7.jpg)'
- en: <st c="26645">Figure 8.7 – The relationship between the features resulting from
    polynomial expansion and the original variable</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26645">图8.7 – 多项式展开得到的特征与原始变量的关系</st>
- en: <st c="26757">Let’s add</st> <st c="26768">two additional variables to our toy
    dataset, with values from 1</st> <st c="26832">to 10:</st>
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26757">让我们向我们的玩具数据集添加</st> <st c="26768">两个额外的变量，其值从1</st> <st c="26832">到10：</st>
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="26907">Next, let’s combine the three features in the</st> <st c="26954">dataset
    with polynomial expansion up to the second degree, but this time, we will only
    return features produced by combining at least two different variables – that
    is, the</st> <st c="27127">interaction features:</st>
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="26907">接下来，让我们将数据集中的三个特征与多项式展开到二次度相结合，但这次，我们只返回由至少两个不同变量组合产生的特征——即，交互特征：</st>
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="27257">If we execute</st> `<st c="27272">dft</st>`<st c="27275">, we
    will see the features resulting from the polynomial expansion, which contain the
    original features, plus all possible combinations of the three variables but without
    the quadratic terms, as we set the transformer to return only</st> <st c="27508">the
    interaction</st> <st c="27524">between features:</st>
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27257">如果我们执行</st> `<st c="27272">dft</st>`<st c="27275">，我们将看到多项式展开得到的所有特征，这些特征包含原始特征，以及三个变量的所有可能的组合，但没有二次项，因为我们设置了转换器只返回</st>
    <st c="27508">特征的交互</st> <st c="27524">作用：</st>
- en: "![Figure 8.8 – A DataFrame with the result of creating features with polynomial\
    \ expansion but retaining only the interactio\uFEFFn between variables](img/B22396_08_8.jpg)"
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 使用多项式展开创建特征但仅保留变量之间交互作用的DataFrame](img/B22396_08_8.jpg)'
- en: <st c="27849">Figure 8.8 – A DataFrame with the result of creating features
    with polynomial expansion but retaining only the interactio</st><st c="27970">n
    between variables</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27849">图8.8 – 使用多项式展开创建特征但仅保留变量之间交互作用的DataFrame</st><st c="27970">。</st>
- en: <st c="27990">Note</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27990">注意</st>
- en: <st c="27995">Go ahead and create third-degree polynomial combinations of the
    features, returning only the interactions or all possible features to get a better
    sense of the output</st> <st c="28163">of</st> `<st c="28166">PolynomialFeatures()</st>`<st
    c="28186">.</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27995">继续创建特征的立方度多项式组合，只返回交互作用或所有可能的特征，以更好地理解</st> <st c="28163">PolynomialFeatures()</st>`<st
    c="28186">的输出。</st>
- en: <st c="28187">With that, we’ve</st> <st c="28205">learned how to create new
    features by combining existing variables with themselves or other features in
    data.</st> <st c="28315">Creating features via polynomial expansion using a real
    dataset is, in</st> <st c="28386">essence, identical.</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28187">有了这些，我们就</st> <st c="28205">学会了如何通过将现有变量与其自身或其他特征相结合来创建新的特征。</st>
    <st c="28315">使用真实数据集通过多项式展开创建特征，在本质上，是相同的。</st>
- en: <st c="28405">If you want to combine only a subset of features, you can select
    the features to combine by utilizing</st> `<st c="28508">ColumnTransformer()</st>`<st
    c="28527">, as we will demonstrate in the</st> *<st c="28559">There’s more…</st>*
    <st c="28572">section ahead in this recipe, or by using</st> `<st c="28615">SklearnTransformerWrapper()</st>`
    <st c="28642">from</st> `<st c="28648">feature-engine</st>`<st c="28662">, as
    you can see in the accompanying GitHub</st> <st c="28706">repository:</st> [<st
    c="28718">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch08-creation/</st><st
    c="28827">Recipe3-PolynomialExpansion.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch08-creation/Recipe3-PolynomialExpansion.ipynb)<st
    c="28861">.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想组合特征的一个子集，您可以通过使用</st> `<st c="28508">ColumnTransformer()</st>`<st c="28527">来选择要组合的特征，正如我们将在本食谱中的*<st
    c="28559">更多内容…</st>* <st c="28572">部分中展示的那样，或者使用</st> `<st c="28615">SklearnTransformerWrapper()</st>`
    <st c="28642">来自</st> `<st c="28648">feature-engine</st>`<st c="28662">，正如您可以在随附的GitHub</st>
    <st c="28706">存储库中看到的那样：</st> [<st c="28718">https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch08-creation/</st><st
    c="28827">Recipe3-PolynomialExpansion.ipynb</st>](https://github.com/PacktPublishing/Python-Feature-Engineering-Cookbook-Third-Edition/blob/main/ch08-creation/Recipe3-PolynomialExpansion.ipynb)<st
    c="28861">。</st>
- en: <st c="28862">How it works...</st>
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="28862">它是如何工作的...</st>
- en: <st c="28878">In this recipe, we</st> <st c="28898">created features by using
    polynomial combinations of a feature with itself or among three variables.</st>
    <st c="28999">To create these polynomial features, we used</st> `<st c="29044">PolynomialFeatures()</st>`
    <st c="29064">from</st> `<st c="29070">scikit-learn</st>`<st c="29082">. By default,</st>
    `<st c="29096">Polynomia</st><st c="29105">lFeatures()</st>` <st c="29117">generates
    a new feature matrix consisting of all polynomial combinations of the features
    in the data, with a degree less than or equal to the user-specified</st> `<st
    c="29275">degree</st>`<st c="29281">. By setting</st> `<st c="29294">degree</st>`
    <st c="29300">to</st> `<st c="29304">3</st>`<st c="29305">, we created all possible
    polynomial combinations of a degree of 3 or smaller.</st> <st c="29384">To retain
    the combination of a feature with itself, we set the</st> `<st c="29447">interaction_only</st>`
    <st c="29463">parameter to</st> `<st c="29477">False</st>`<st c="29482">. To avoid
    returning the bias term, we set the</st> `<st c="29529">include_bias</st>` <st
    c="29541">parameter</st> <st c="29552">to</st> `<st c="29555">False</st>`<st c="29560">.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们通过使用特征与其自身或三个变量之间的多项式组合来创建特征。<st c="28898">为了创建这些多项式特征，我们使用了</st> `<st
    c="29044">PolynomialFeatures()</st>` <st c="29064">来自</st> `<st c="29070">scikit-learn</st>`<st
    c="29082">。默认情况下，</st> `<st c="29096">Polynomia</st><st c="29105">lFeatures()</st>`
    <st c="29117">生成一个新的特征矩阵，其中包含数据中所有特征的所有多项式组合，其次数小于或等于用户指定的</st> `<st c="29275">degree</st>`<st
    c="29281">。将</st> `<st c="29294">degree</st>` <st c="29300">设置为</st> `<st c="29304">3</st>`<st
    c="29305">，我们创建了所有可能的三次或更低次数的多项式组合。</st> <st c="29384">为了保留特征与其自身的组合，我们将</st>
    `<st c="29447">interaction_only</st>` <st c="29463">参数设置为</st> `<st c="29477">False</st>`<st
    c="29482">。为了避免返回偏差项，我们将</st> `<st c="29529">include_bias</st>` <st c="29541">参数设置为</st>
    `<st c="29555">False</st>`<st c="29560">。</st>
- en: <st c="29561">Note</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29561">注意</st>
- en: <st c="29566">Setting the</st> `<st c="29579">interaction_only</st>` <st c="29595">parameter
    to</st> `<st c="29609">True</st>` <st c="29613">returns the interaction terms
    only – that is, the variables resulting from combinations of two or</st> <st c="29712">more
    variables.</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29566">将</st> `<st c="29579">interaction_only</st>` <st c="29595">参数设置为</st>
    `<st c="29609">True</st>` <st c="29613">仅返回交互项——即由两个或更多变量组合而成的变量。</st>
- en: <st c="29727">The</st> `<st c="29732">fit()</st>` <st c="29737">method determined
    all of the possible feature combinations based on the parameters specified.</st>
    <st c="29832">At this stage, the transformer did not perform actual mathematical
    computations.</st> <st c="29913">The</st> `<st c="29917">transform()</st>` <st
    c="29928">method performed the mathematical computations with the features to
    create the new variables.</st> <st c="30023">With the</st> `<st c="30032">get_feature_names()</st>`
    <st c="30051">method, we could identify the terms of the expansion – that is,
    how each new feature</st> <st c="30137">was calculated.</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="29727">fit()</st>` `<st c="29732">method</st>`根据指定的参数确定了所有可能的特征组合。在这个阶段，转换器没有执行实际的数学计算。`<st
    c="29917">transform()</st>` `<st c="29928">method</st>`使用特征执行数学计算以创建新的变量。通过`<st
    c="30032">get_feature_names()</st>` `<st c="30051">method</st>`，我们可以识别展开的项 - 即每个新特征是如何计算的。'
- en: <st c="30152">In</st> *<st c="30156">step 2</st>*<st c="30162">, we set</st>
    `<st c="30171">scikit-learn</st>` <st c="30183">library’s</st> `<st c="30194">set_output</st>`
    <st c="30204">API</st> `<st c="30228">pandas</st>` <st c="30234">DataFrames as
    a result of the</st> `<st c="30265">transform()</st>` <st c="30276">method.</st>
    <st c="30285">scikit-learn transformers return</st> `<st c="30318">NumPy</st>`
    <st c="30323">arrays by default.</st> <st c="30343">The new</st> `<st c="30351">set_output</st>`
    <st c="30361">API allows us to change the container of the result to a</st> `<st
    c="30419">pandas</st>` <st c="30425">or a</st> `<st c="30431">polars</st>` <st
    c="30437">DataFrame.</st> <st c="30449">We can set the output individually every
    time we set up a transformer – for example, by using</st> `<st c="30543">poly
    = PolynomialFeatures().set_output(transform="pandas")</st>`<st c="30601">. Alternatively,
    as we did in this recipe, we can set the global configuration, and then every
    time we set up a new transformer,</st> <st c="30729">it will return a</st> `<st
    c="30747">pandas</st>` <st c="30753">DataFrame.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们设置`<st c="30171">scikit-learn</st>`库的`<st c="30183">library’s</st>`
    `<st c="30194">set_output</st>` `<st c="30204">API</st>` `<st c="30228">pandas</st>`
    `<st c="30234">DataFrames</st>`作为`<st c="30265">transform()</st>` `<st c="30276">method</st>`的结果。`<st
    c="30285">scikit-learn transformers</st>`默认返回`<st c="30318">NumPy</st>` `<st c="30323">arrays</st>`。新的`<st
    c="30351">set_output</st>` `<st c="30361">API</st>`允许我们将结果的容器更改为`<st c="30419">pandas</st>`
    `<st c="30425">或</st>` `<st c="30431">polars</st>` `<st c="30437">DataFrame</st>`。每次设置转换器时，我们都可以单独设置输出
    - 例如，通过使用`<st c="30543">poly = PolynomialFeatures().set_output(transform="pandas")</st>`
    `<st c="30601">`。或者，就像在这个食谱中做的那样，我们可以设置全局配置，然后每次设置新的转换器时，`<st c="30729">它将返回一个</st>`
    `<st c="30747">pandas</st>` `<st c="30753">DataFrame</st>`。
- en: <st c="30764">There’s more...</st>
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: <st c="30780">Let’s create features by</st> <st c="30805">performing polynomial
    expansion on a subset of variables in the breast</st> <st c="30877">cancer dataset:</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对乳腺癌数据集中变量的子集进行多项式展开来创建特征：
- en: <st c="30892">First, import the necessary libraries, classes,</st> <st c="30941">and
    data:</st>
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入必要的库、类和数据：
- en: '[PRE33]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: <st c="31170">Then, load the data and separate it into train and</st> <st c="31222">test
    sets:</st>
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，加载数据并将其分为训练集和测试集：
- en: '[PRE34]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <st c="31419">Make a list with the features</st> <st c="31450">to combine:</st>
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含要组合的特征的列表：
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <st c="31531">Set up</st> `<st c="31539">PolynomialFeatures()</st>` <st c="31559">to
    create all possible combinations up to the</st> <st c="31606">third degree:</st>
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`<st c="31539">PolynomialFeatures()</st>` `<st c="31559">`设置为创建所有可能的三次方组合：
- en: '[PRE36]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="31700">Set up the column transformer to create features only from those
    specified in</st> *<st c="31779">step 3</st>*<st c="31785">:</st>
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置列转换器以仅从**步骤 3**中指定的特征创建特征：
- en: '[PRE37]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <st c="31838">Create the</st> <st c="31850">polynomial features:</st>
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建多项式特征：
- en: '[PRE38]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: <st c="31936">And that’s it.</st> <st c="31952">By</st> <st c="31955">executing</st>
    `<st c="31965">ct.get_featur</st><st c="31978">e_names_out()</st>`<st c="31992">,
    we obtain the names of the</st> <st c="32021">new features.</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。
- en: <st c="32034">Note</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`<st c="32039">ColumnTransformer()</st>` <st c="32059">will append the word</st>
    `<st c="32081">poly</st>` <st c="32085">to the resulting variables, which is the
    name we gave to the step within</st> `<st c="32159">ColumnTransformer()</st>`
    <st c="32178">in</st> *<st c="32182">step 5</st>*<st c="32188">. I am not a huge
    fan of this behavior because it makes data analysis harder, as you need to keep
    track of the variable name changes.</st> <st c="32322">To avoid variable name
    changes, you can use</st> `<st c="32366">feature-engine</st>`<st c="32380">’s</st>
    `<st c="32383">SklearnTransformerWrapper()</st>` <st c="32411">instead.</st>'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="32039">ColumnTransformer()</st>` <st c="32059">将向结果变量追加单词</st> `<st
    c="32081">poly</st>` <st c="32085">，这是我们为</st> `<st c="32159">ColumnTransformer()</st>`
    <st c="32178">中的步骤</st> *<st c="32182">步骤 5</st>*<st c="32188">所赋予的名称。我不是特别喜欢这种行为，因为它使得数据分析变得更加困难，因为你需要跟踪变量名称的变化。</st>
    <st c="32322">为了避免变量名称的变化，你可以使用</st> `<st c="32366">feature-engine</st>`<st c="32380">的</st>
    `<st c="32383">SklearnTransformerWrapper()</st>` <st c="32411">代替。</st>'
- en: <st c="32420">Combining features with decision trees</st>
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="32420">将特征与决策树结合</st>
- en: <st c="32459">In the</st> <st c="32466">winning solution of the</st> **<st c="32491">Knowledge
    Discovery and Data</st>** <st c="32519">Mining (</st>**<st c="32528">KDD</st>**<st
    c="32532">) competition in 200</st><st c="32553">9, the authors created new features
    by combining two or more variables using decision trees.</st> <st c="32647">When
    examining the</st> <st c="32665">variables, they noticed that some features had
    a high level of mutual information with the target yet low correlation, indicating
    that the relationship with the target was not linear.</st> <st c="32850">While
    these features</st> <st c="32871">were predictive when used in tree-based algorithms,
    linear models could not take advantage of them.</st> <st c="32971">Hence, to use
    these features in linear models, they replaced the features with the outputs of
    decision trees trained on the individual features, or combinations of two or three
    variables, to return new features with a monotonic relationship with</st> <st
    c="33217">the target.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32459">在2009年</st> <st c="32466">知识发现与数据挖掘（</st>**<st c="32491">知识发现和数据挖掘（KDD）**</st>**<st
    c="32528">KDD</st>**<st c="32532">）竞赛的获奖方案中，作者通过使用决策树结合两个或多个变量来创建新的特征。</st> <st
    c="32553">在检查变量时，他们注意到一些特征与目标变量具有高度的互信息，但相关性较低，这表明与目标变量的关系不是线性的。</st> <st c="32647">当使用基于树的算法时，这些特征是可预测的，但线性模型无法利用它们。</st>
    <st c="32850">因此，为了在线性模型中使用这些特征，他们用训练在单个特征或两个或三个变量组合上的决策树输出的特征替换了这些特征，从而得到与目标变量呈单调关系的新的特征。</st>
    <st c="33217">。</st>
- en: <st c="33228">In short, combining features with decision trees is useful for
    creating features that show a monotonic relationship with the target, which is
    useful for making accurate predictions</st> <st c="33409">using linear models.</st>
    <st c="33431">The procedure consists of training a decision tree using a subset
    of the</st> <st c="33504">features – typically, one, two, or three at a time –
    and then using the prediction of the tree as a</st> <st c="33604">new feature.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33228">简而言之，将特征与决策树结合使用对于创建与目标变量呈单调关系的特征是有用的，这对于使用线性模型进行准确预测很有帮助</st>
    <st c="33409">来说。</st> <st c="33431">该过程包括使用特征子集训练决策树——通常是一次一个、两个或三个——然后使用树的预测作为</st>
    <st c="33604">新的特征。</st>
- en: <st c="33616">Note</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33616">注意</st>
- en: <st c="33621">You can find more details about this procedure and the overall
    winning solution of the 2009 KDD data competition in this</st> <st c="33743">article:</st>
    [<st c="33752">http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf</st>](http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf)<st
    c="33811">.</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33621">您可以在本文中找到有关此过程和2009年KDD数据竞赛整体获奖方案的更多详细信息：</st> <st c="33743">[</st>
    <st c="33752">http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf</st>](http://proceedings.mlr.press/v7/niculescu09/niculescu09.pdf)<st
    c="33811">。</st>
- en: <st c="33812">The good news is that we can automate the creation of features
    using trees, using</st> `<st c="33895">feature-engine</st>`<st c="33909">, and
    i</st><st c="33916">n this recipe, we will learn how to</st> <st c="33953">do
    so.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33812">好消息是，我们可以使用`feature-engine`自动化使用树创建特征，在这个菜谱中，我们将学习如何</st> <st
    c="33953">做到这一点。</st>
- en: <st c="33959">How to do it...</st>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="33959">如何做到...</st>
- en: <st c="33975">In this recipe, we’ll combine features with decision trees, using
    the California</st> <st c="34057">housing dataset:</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33975">在这个菜谱中，我们将使用加利福尼亚</st> <st c="34057">住房数据集</st>来结合特征与决策树：</st>
- en: <st c="34073">Let’s begin by importing</st> `<st c="34099">pandas</st>` <st
    c="34105">and the required functions, classes,</st> <st c="34143">and dataset:</st>
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34073">让我们首先导入</st> `<st c="34099">pandas</st>` <st c="34105">和所需的函数、类、</st>
    <st c="34143">以及数据集：</st>
- en: '[PRE39]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: <st c="34391">Let’s load the California housing dataset into a</st> `<st c="34441">pandas</st>`
    <st c="34447">DataFrame and remove the</st> `<st c="34473">Latitude</st>` <st
    c="34481">and</st> `<st c="34486">Longitude</st>` <st c="34495">variables:</st>
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34391">让我们将加利福尼亚住房数据集加载到一个</st> `<st c="34441">pandas</st>` <st c="34447">DataFrame中，并删除</st>
    `<st c="34473">纬度</st>` <st c="34481">和</st> `<st c="34486">经度</st>` <st c="34495">变量：</st>
- en: '[PRE40]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <st c="34635">Separate the dataset into train and</st> <st c="34672">test sets:</st>
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34635">将数据集分为训练集和</st> <st c="34672">测试集：</st>
- en: '[PRE41]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: <st c="34772">Check out</st> <st c="34783">Pearson’s correlation coefficient</st>
    <st c="34817">between the features and the target, which is a measure of a</st>
    <st c="34878">linear relationship:</st>
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34772">查看</st> <st c="34783">皮尔逊相关系数</st> <st c="34817">特征与目标之间的相关性，这是一个线性关系的度量：</st>
- en: '[PRE42]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <st c="35051">In the following output, we can see that, apart from</st> `<st
    c="35105">MedInc</st>`<st c="35111">, most variables do not show a strong linear
    relationship with the target; the correlation coefficient is smaller</st> <st
    c="35225">than 0.5:</st>
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35051">在以下输出中，我们可以看到，除了</st> `<st c="35105">MedInc</st>`<st c="35111">之外，大多数变量与目标之间没有显示出强烈的线性关系；相关系数小于0.5：</st>
- en: '[PRE43]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: <st c="35518">Create a grid of hyperparameters to optimize each</st> <st c="35569">decision
    tree:</st>
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35518">创建一个超参数网格以优化每个</st> <st c="35569">决策树：</st>
- en: '[PRE44]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: <st c="35627">The</st> `<st c="35632">feature-engine</st>` <st c="35646">library’s</st>
    `<st c="35657">DecisionTreeFeatures()</st>` <st c="35679">allows us to add features
    resulting from the predictions of a decision tree, trained on one or more features.</st>
    <st c="35790">There</st> <st c="35795">are many ways in which we can instruct
    the transformer to combine the features.</st> <st c="35876">We’ll start by creating
    all possible combinations between</st> <st c="35934">two variables.</st>
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35627">`<st c="35632">feature-engine</st>` <st c="35646">库的</st> `<st
    c="35657">DecisionTreeFeatures()</st>` <st c="35679">允许我们添加由一个或多个特征训练的决策树预测产生的特征。</st>
    <st c="35790">我们可以以多种方式指导转换器组合特征。</st> <st c="35876">我们将从创建两个变量之间所有可能的组合开始。</st>
- en: <st c="35948">Make a list</st> <st c="35960">with the two features that we want
    to use</st> <st c="36003">as inputs:</st>
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35948">制作一个包含我们想要用作输入的</st> <st c="35960">两个特征的列表：</st>
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <st c="36051">Set up</st> `<st c="36059">DecisionTreeFeatures()</st>` <st c="36081">to
    create all possible combinations between the features from</st> *<st c="36144">step
    6</st>*<st c="36150">:</st>
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36051">将</st> `<st c="36059">DecisionTreeFeatures()</st>` <st c="36081">设置为创建来自</st>
    *<st c="36144">步骤 6</st>*<st c="36150">的所有可能的特征组合：</st>
- en: '[PRE46]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="36309">Note</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34878">注意</st>
- en: <st c="36314">We set</st> `<st c="36322">regression</st>` <st c="36332">to</st>
    `<st c="36336">True</st>` <st c="36340">because the target in this dataset is
    continuous.</st> <st c="36391">If you have a binary target or are performing classification,
    set it to</st> `<st c="36463">False</st>`<st c="36468">. Make sure to select an
    evaluation metric (</st>`<st c="36512">scoring</st>`<st c="36520">) that is suitable
    for</st> <st c="36544">your model.</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36314">我们将</st> `<st c="36322">回归</st>` <st c="36332">设置为</st> `<st c="36336">True</st>`
    <st c="36340">，因为在这个数据集中目标值是连续的。</st> <st c="36391">如果你有一个二元目标或正在进行分类，请将其设置为</st>
    `<st c="36463">False</st>`<st c="36468">。请确保选择一个适合你模型的评估指标（</st>`<st c="36512">scoring</st>`<st
    c="36520">）。</st>
- en: <st c="36555">Fit the transformer so that it trains the decision trees on the</st>
    <st c="36620">input features:</st>
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36555">调整转换器，使其在输入特征上训练决策树：</st>
- en: '[PRE47]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: <st c="36661">If you wonder</st> <st c="36676">which features have been used
    to train decision trees, you can inspect them</st> <st c="36752">like this:</st>
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36620">如果你想知道</st> <st c="36676">哪些特征被用于训练决策树，你可以这样检查它们</st> <st c="36752">：</st>
- en: '[PRE48]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <st c="36782">In the</st> <st c="36789">following output, we can see that</st>
    `<st c="36824">DecisionTreeFeatures()</st>` <st c="36846">has trained three decision
    trees – two by using the single features,</st> `<st c="36916">AveRooms</st>` <st
    c="36924">and</st> `<st c="36929">AveBedrms</st>`<st c="36938">, and one by using</st>
    <st c="36957">both features:</st>
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36782">在</st> <st c="36789">以下输出中，我们可以看到</st> `<st c="36824">DecisionTreeFeatures()</st>`
    <st c="36846">已训练了三个决策树 – 两个使用单个特征</st> `<st c="36916">AveRooms</st>` <st c="36924">和</st>
    `<st c="36929">AveBedrms</st>`<st c="36938">，另一个使用</st> <st c="36957">这两个特征：</st>
- en: '[PRE49]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <st c="37024">Note</st>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37024">注意</st>
- en: '`<st c="37029">DecisionTreeFeatures()</st>` <st c="37052">also stores the decision
    trees.</st> <st c="37085">You can check them out by executing</st> `<st c="37121">dtf.estimators_</st>`<st
    c="37136">.</st>'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="37029">DecisionTreeFeatures()</st>` <st c="37052">也存储决策树。</st> <st
    c="37085">您可以通过执行</st> `<st c="37121">dtf.estimators_</st>`<st c="37136">来查看它们。</st>'
- en: <st c="37137">Now, add the features to the training and</st> <st c="37180">testing
    sets:</st>
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37137">现在，将特征添加到训练集和</st> <st c="37180">测试集中：</st>
- en: '[PRE50]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: <st c="37257">Make a list with the name of the new features (the transformer
    appends the word</st> `<st c="37338">tree</st>` <st c="37342">to the</st> <st
    c="37350">feature names):</st>
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37257">创建一个包含新特征名称的列表（转换器将单词</st> `<st c="37338">tree</st>` <st c="37342">添加到</st>
    `<st c="37350">特征名称</st>）：</st>
- en: '[PRE51]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <st c="37432">Finally, display the features that were added to the</st> <st
    c="37486">test set:</st>
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37432">最后，显示添加到</st> <st c="37486">测试集</st>中的特征：</st>
- en: '[PRE52]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <st c="37524">In the following output, we can see the first five rows of the
    new features, resulting from the decision trees trained in</st> *<st c="37647">step
    8</st>*<st c="37653">:</st>
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37524">在以下输出中，我们可以看到由第 8 步中训练的决策树产生的新的前五个特征，*<st c="37647">步骤 8</st>*<st
    c="37653">：</st>
- en: '![    Figure 8.9 – A portion of the testing set containing the features derived
    from the decision trees](img/B22396_08_9.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 包含从决策树中提取的特征的测试集的一部分](img/B22396_08_9.jpg)'
- en: <st c="37883">Figure 8.9 – A portion of the testing set containing the features
    derived from the decision trees</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37883">图 8.9 – 包含从决策树中提取的特征的测试集的一部分</st>
- en: <st c="37980">To check the</st> <st c="37994">power of this transformation,
    calculate</st> <st c="38034">Pearson’s correlation coefficient between the new
    features and</st> <st c="38097">the target:</st>
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37980">为了检查</st> <st c="37994">这种转换的</st> <st c="38034">能力，计算</st> <st
    c="38097">新特征与</st> <st c="38097">目标之间的</st> <st c="38097">皮尔逊相关系数：</st>
- en: '[PRE53]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <st c="38257">In the following output, we can see that the correlation between
    the new variables and the target is greater than the correlation shown by the
    original features (compare these values with those of</st> *<st c="38455">step
    4</st>*<st c="38461">):</st>
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38257">在以下输出中，我们可以看到新变量与目标之间的相关性大于原始特征显示的相关性（将这些值与*<st c="38455">步骤 4</st>*<st
    c="38461">中的值进行比较）：</st>
- en: '[PRE54]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: <st c="38590">If you want to combine specific features instead of getting all
    possible combinations between variables, you can do so by specifying the input
    features</st> <st c="38743">in tuples.</st>
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38590">如果您想结合特定的特征而不是获取变量之间所有可能的组合，您可以通过指定</st> <st c="38743">输入特征</st>
    <st c="38743">为元组来实现。</st>
- en: <st c="38753">Create a tuple of tuples with the different features that we want
    to use as input for</st> <st c="38840">decision trees:</st>
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38753">创建一个包含我们想要用作决策树输入的不同特征的元组元组：</st>
- en: '[PRE55]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <st c="38950">Now, we</st> <st c="38959">need</st> <st c="38964">to pass these
    tuples to the</st> `<st c="38992">features_to_combine</st>` <st c="39011">parameter</st>
    <st c="39022">of</st> `<st c="39025">DecisionTreeFeatures()</st>`<st c="39047">:</st>
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38950">现在，我们需要</st> <st c="38959">将这些元组传递给</st> `<st c="38992">features_to_combine</st>`
    <st c="39011">参数</st> <st c="39022">的</st> `<st c="39025">DecisionTreeFeatures()</st>`<st
    c="39047">：</st>
- en: '[PRE56]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <st c="39213">We fitted the transformer in the previous step, so we can go ahead
    and add the features to training and</st> <st c="39318">test sets:</st>
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39213">我们在上一步中拟合了转换器，因此我们可以继续将特征添加到训练集和</st> <st c="39318">测试集中：</st>
- en: '[PRE57]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <st c="39392">Display the</st> <st c="39405">new features:</st>
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39392">显示</st> <st c="39405">新特征：</st>
- en: '[PRE58]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <st c="39513">In the following output, we can see the new features derived from
    predictions of decision trees in the</st> <st c="39617">test set:</st>
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="39513">在以下输出中，我们可以看到测试集中决策树的预测结果产生的新特征：</st>
- en: '![    Figure 8.10 – A portion of the testing set containing the features derived
    from the decision trees](img/B22396_08_10.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 包含从决策树中提取的特征的测试集的一部分](img/B22396_08_10.jpg)'
- en: <st c="39886">Figure 8.10 – A portion of the testing set containing the features
    derived from the decision trees</st>
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39886">图8.10 – 包含从决策树派生出的特征的测试集的一部分</st>
- en: <st c="39984">To wrap up</st> <st c="39995">the recipe, we’ll compare</st> <st
    c="40022">the performance of a Lasso linear regression model trained using the
    original features with one using the features derived from the</st> <st c="40154">decision
    trees.</st>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39984">总结配方</st> <st c="39995">，我们将比较</st> <st c="40022">使用原始特征训练的Lasso线性回归模型与使用从</st>
    <st c="40154">决策树</st>派生出的特征训练的模型的性能。</st>
- en: <st c="40169">Import</st> `<st c="40177">Lasso</st>` <st c="40182">and the</st>
    `<st c="40191">cross_validate</st>` <st c="40205">function</st> <st c="40215">from</st>
    `<st c="40220">scikit-learn</st>`<st c="40232">:</st>
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40169">导入</st> `<st c="40177">Lasso</st>` <st c="40182">和</st> `<st c="40191">cross_validate</st>`
    <st c="40205">函数</st> <st c="40215">从</st> `<st c="40220">scikit-learn</st>`<st
    c="40232">：</st>
- en: '[PRE59]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <st c="40324">Set up a Lasso</st> <st c="40340">regression model:</st>
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40324">设置一个Lasso</st> <st c="40340">回归模型：</st>
- en: '[PRE60]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <st c="40401">Train and evaluate the model using the original data with cross-validation,
    and then print out the</st> <st c="40501">resulting</st> *<st c="40511">r</st>*<st
    c="40512">-squared:</st>
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40401">使用原始数据通过交叉验证训练和评估模型，然后打印出</st> <st c="40501">结果</st> *<st c="40511">r</st>*<st
    c="40512">-squared：</st>
- en: '[PRE61]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: <st c="40692">In the following output, we can see the</st> *<st c="40733">r</st>*<st
    c="40734">-squared of the Lasso regression model trained using the</st> <st c="40791">original
    features:</st>
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="40692">在以下输出中，我们可以看到使用原始特征训练的Lasso回归模型的</st> *<st c="40733">r</st>*<st
    c="40734">-squared：</st>
- en: '[PRE62]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <st c="40862">Finally, train a Lasso regression model with the features derived
    from the decision trees</st> <st c="40952">and evaluate it</st> <st c="40969">with
    cross-validation:</st>
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40862">最后，使用从决策树派生的特征训练Lasso回归模型，并使用交叉验证进行评估：</st>
- en: '[PRE63]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: <st c="41256">In the</st> <st c="41263">following output, we can see that the
    performance of the Lasso regression model trained based of the tree-derived features
    is b</st><st c="41391">etter; the</st> *<st c="41403">r</st>*<st c="41404">-square
    is greater than that from</st> *<st c="41438">step 20</st>*<st c="41445">:</st>
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41256">在</st> <st c="41263">以下输出中，我们可以看到基于树派生特征训练的Lasso回归模型的性能更好；</st>
    *<st c="41403">r</st>*<st c="41404">-square 大于</st> *<st c="41438">步骤20</st>*<st
    c="41445">的结果：</st>
- en: '[PRE64]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: <st c="41499">I hope I’ve given you a flavor of the power of combining features
    wit</st><st c="41569">h decision trees and how to do so</st> <st c="41604">with</st>
    `<st c="41609">feature-engine</st>`<st c="41623">.</st>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41499">我希望我已经向您展示了结合特征与决策树的力量以及如何使用</st> `<st c="41609">feature-engine</st>`<st
    c="41623">来做到这一点。</st>
- en: <st c="41624">How it works...</st>
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="41624">它是如何工作的...</st>
- en: <st c="41640">In this recipe, we created new features based on the predictions
    of decision trees trained on one or more variables.</st> <st c="41758">We used</st>
    `<st c="41766">DecisionTreeFeatures()</st>` <st c="41788">from</st> `<st c="41793">Feature-engine</st>`
    <st c="41808">to automate the process of training the decision trees with cross-validation
    and</st> <st c="41890">hyperparameter optimization.</st>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41640">在这个配方中，我们基于在一个或多个变量上训练的决策树的预测创建了新的特征。</st> <st c="41758">我们使用了</st>
    `<st c="41766">DecisionTreeFeatures()</st>` <st c="41788">从</st> `<st c="41793">Feature-engine</st>`
    <st c="41808">中</st> <st c="41890">自动化训练决策树的过程，包括交叉验证和</st> <st c="41890">超参数优化。</st>
- en: '`<st c="41918">DecisionTreeFeatures()</st>` <st c="41941">trains decision trees
    using grid-search under the hood.</st> <st c="41998">Hence, you can pass a grid
    of hyperparameters to optimize the tree, or the transformer will optimize just
    the depth, which, in any case, is the most important parameter in a decision tree.</st>
    <st c="42187">You can also change the metric you want to optimize through the</st>
    `<st c="42251">scoring</st>` <st c="42258">parameter and the cross-validation
    scheme you want to use through the</st> `<st c="42329">cv</st>` <st c="42331">parameter.</st>'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="41918">DecisionTreeFeatures()</st>` <st c="41941">在底层使用网格搜索训练决策树。</st>
    <st c="41998">因此，您可以传递一个超参数网格以优化树，或者转换器将仅优化深度，这在任何情况下都是决策树中最重要的参数。</st> <st c="42187">您还可以通过</st>
    `<st c="42251">scoring</st>` <st c="42258">参数更改您想要优化的度量标准，并通过</st> `<st c="42329">cv</st>`
    <st c="42331">参数更改您想要使用的交叉验证方案。</st>'
- en: <st c="42342">The most exciting feature of</st> `<st c="42372">DecisionTreeFeatures()</st>`
    <st c="42394">is its ability to infer the feature combinations to create tree-derived
    features, which is regulated through the</st> `<st c="42508">features_to_combine</st>`
    <st c="42527">parameter.</st> <st c="42539">If you pass an integer to this parameter
    – say, for example,</st> `<st c="42600">3</st>`<st c="42601">,</st> `<st c="42603">DecisionTreeFeatures()</st>`
    <st c="42625">will create all possible combinations of 1, 2, and 3 features and
    use these to train the decision trees.</st> <st c="42731">Instead of an integer,
    you can pass a list of integers – say,</st> `<st c="42793">[2,3]</st>` <st c="42798">–
    in which case,</st> `<st c="42816">DecisionTreeFeatures()</st>` <st c="42838">will
    create all</st> <st c="42854">possible combinations of 2 and 3 features.</st>
    <st c="42898">You</st> <st c="42901">can also specify which features you want
    to combine and how by passing the feature combinations in tuples, as we did in</st>
    *<st c="43022">step 14</st>*<st c="43029">.</st>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42342">DecisionTreeFeatures()</st> 的最激动人心的特性是其推断特征组合以创建树派生特征的能力，这一能力通过
    <st c="42508">features_to_combine</st> <st c="42527">参数进行调节。</st> <st c="42539">如果你向这个参数传递一个整数——比如说，例如，<st
    c="42600">3</st>，<st c="42601">，<st c="42603">DecisionTreeFeatures()</st> 将会创建所有可能的1、2和3个特征的组合，并使用这些组合来训练决策树。</st>
    <st c="42731">除了整数之外，你也可以传递一个整数的列表——比如说，<st c="42793">[2,3]</st>，<st c="42798">——在这种情况下，<st
    c="42816">DecisionTreeFeatures()</st> 将会创建所有2和3个特征的组合。</st> <st c="42898">你也可以通过传递特征组合的元组来指定你想要组合的特征以及如何组合，就像我们在
    *<st c="43022">步骤14</st>*<st c="43029"> 中所做的那样。</st>
- en: <st c="43030">With</st> `<st c="43036">fit()</st>`<st c="43041">,</st> `<st
    c="43043">DecisionTreeFeatures()</st>` <st c="43065">finds the feature combinations
    and trains the decision trees.</st> <st c="43128">With</st> `<st c="43133">transform()</st>`<st
    c="43144">,</st> `<st c="43146">DecisionTreeFeatures()</st>` <st c="43168">adds
    the features resulting from the decision trees to</st> <st c="43224">the DataFrame.</st>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43030">使用 <st c="43036">fit()</st>，<st c="43041">，<st c="43043">DecisionTreeFeatures()</st>
    会找到特征组合并训练决策树。</st> <st c="43128">使用 <st c="43133">transform()</st>，<st c="43144">，<st
    c="43146">DecisionTreeFeatures()</st> 将决策树产生的特征添加到 <st c="43224">DataFrame</st>
    中。</st>
- en: <st c="43238">Note</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43238">注意</st>
- en: <st c="43243">If you are training regression or multi-class classification,
    the new features will be either the prediction of the continuous target or the
    class.</st> <st c="43392">If you are training a binary classification model, the
    new features will result from the probability of</st> <st c="43496">class 1.</st>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43243">如果你正在训练回归或多类分类，新特征将是连续目标的预测或类别。</st> <st c="43392">如果你正在训练二元分类模型，新特征将来自类别1的概率。</st>
- en: <st c="43504">After adding the new features, we compared their relationship
    to the target by analyzing Pearson’s correlation coefficient, which returned a
    measure of linear association.</st> <st c="43677">We saw that the features derived
    from trees had a greater</st> <st c="43735">correlation coefficient.</st>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43504">在添加新特征后，我们通过分析皮尔逊相关系数来比较它们与目标之间的关系，该系数返回线性关联的度量。</st> <st c="43677">我们发现从树中派生的特征具有更大的
    <st c="43735">相关系数。</st>
- en: <st c="43759">See also</st>
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="43759">另请参阅</st>
- en: <st c="43768">If you want to know more about what mutual information is and
    how to calculate it, check out this</st> <st c="43867">article:</st> [<st c="43876">https://www.blog.trainindata.com/mutual-information-with-python/</st>](https://www.blog.trainindata.com/mutual-information-with-python/)<st
    c="43940">.</st>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43768">如果你想知道更多信息关于互信息是什么以及如何计算它，请查看这篇 <st c="43867">文章：</st> [<st c="43876">https://www.blog.trainindata.com/mutual-information-with-python/</st>](https://www.blog.trainindata.com/mutual-information-with-python/)<st
    c="43940">。</st>
- en: <st c="43941">Creating periodic features from cyclical variables</st>
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="43941">从周期性变量创建周期性特征</st>
- en: <st c="43992">Some features</st> <st c="44006">are periodic – for e</st><st
    c="44027">xample, the</st> <st c="44039">hours in</st> <st c="44048">a day, the
    months in a year, and the days in a week.</st> <st c="44102">They all start at
    a certain value (say, January), go up to a certain other value (say, December),
    and then start over from the beginning.</st> <st c="44240">Some features are numeric,
    such as the hours, and some can be represented with numbers, such as the months,
    with values of 1 to 12\.</st> <st c="44372">Yet, this numeric representation does
    not capture the periodicity or cyclical nature of the variable.</st> <st c="44474">For
    example, December (12) is closer to January (1) than June (6); however, this relationship
    is not captured by the numerical representation of the feature.</st> <st c="44632">But
    we could change it if we transformed these variables with the sine and cosine,
    two naturally</st> <st c="44729">periodic functions.</st>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43992">一些特征</st> <st c="44006">是周期性的</st> – 例如，<st c="44027">一天中的</st>
    <st c="44039">小时数</st>，<st c="44048">一年中的</st> <st c="44039">月份</st>，以及<st c="44048">一周中的</st>
    <st c="44039">天数</st>。</st> <st c="44102">它们都从一个特定的值开始（比如说，一月），上升到另一个特定的值（比如说，十二月），然后从头开始。</st>
    <st c="44240">一些特征是数值型的，例如小时数，而一些可以用数字表示，例如月份，其值为1到12。</st> <st c="44372">然而，这种数值表示并没有捕捉到变量的周期性或循环性质。</st>
    <st c="44474">例如，十二月（12）比六月（6）更接近一月（1）；然而，这种关系并没有被特征的数值表示所捕捉。</st> <st c="44632">但如果我们用正弦和余弦这两个自然周期函数对这些变量进行变换，我们就可以改变它。</st>
- en: <st c="44748">Encoding</st> <st c="44758">cyclical features</st> <st c="44776">with
    the sine and cosine functions allows linear models to leverage the cyclical nature
    of features and reduce their modeling error.</st> <st c="44909">In this recipe,
    we will create new features from</st> <st c="44958">periodic variables that capture
    the cyclical nature</st> <st c="45010">of time.</st>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44748">使用正弦和余弦函数对周期性特征进行编码允许线性模型利用特征的周期性并减少其建模误差。</st> <st c="44758">在本配方中，我们将从</st>
    <st c="44958">捕捉时间周期性的周期性变量中创建新的特征。</st>
- en: <st c="45018">Getting ready</st>
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="45018">准备</st>
- en: <st c="45032">Trigonometric functions</st><st c="45056">, such as sine and cosine,
    are periodic, with valu</st><st c="45106">es cycling between -1 and 1 every 2π
    cycles, as</st> <st c="45155">s</st><st c="45156">hown here:</st>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45032">三角函数</st><st c="45056">，例如正弦和余弦函数，是周期性的，其值在每个2π周期内循环于-1和1之间，如下所示：</st><st
    c="45106"></st><st c="45155">s</st><st c="45156">hown here:</st>
- en: '![Figure 8.11 – Sine and cosine functions](img/B22396_08_11.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 正弦和余弦函数](img/B22396_08_11.jpg)'
- en: <st c="45336">Figure 8.11 – Sine and cosine functions</st>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45336">图8.11 – 正弦和余弦函数</st>
- en: <st c="45375">We can capture the periodicity of a cyclical variable by applying
    a trigonometric transformation after normalizing the variable values between 0</st>
    <st c="45521">and 2π:</st>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45375">通过在将变量值归一化到0和2π之间后应用三角变换，我们可以捕捉到周期性变量的周期性：</st><st c="45521">:</st>
- en: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>sin</mi><mfenced
    open="(" close=")"><mi>x</mi></mfenced><mo>=</mo><mi>sin</mi><mrow><mrow><mo>(</mo><mn>2</mn><mi>π</mi><mfrac><mi>X</mi><msub><mi>X</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac><mo>)</mo></mrow></mrow></mrow></mrow></math>](img/37.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![<math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mrow><mi>sin</mi><mfenced
    open="(" close=")"><mi>x</mi></mfenced><mo>=</mo><mi>sin</mi><mrow><mrow><mo>(</mo><mn>2</mn><mi>π</mi><mfrac><mi>X</mi><msub><mi>X</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mfrac><mo>)</mo></mrow></mrow></mrow></mrow></math>](img/37.png)'
- en: <st c="45554">Dividing the variable’s values by its maximum will normalize it
    between 0 and 1 (assuming that the minimum value is 0), and multiplying it by
    2π will rescale the variable between 0</st> <st c="45735">and 2π.</st>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45554">将变量的值除以其最大值将使其归一化到0和1之间（假设最小值为0），然后乘以2π将变量重新缩放到0和2π之间。</st>
- en: <st c="45742">Should we</st> <st c="45753">use sine?</st> <st c="45763">Or should
    we use cosine?</st> <st c="45788">The thing is, we need to use both to encode
    all the values of the variables unequivocally.</st> <st c="45879">Since sine and
    cosine circle between 0 and 1, they will take a value of 0 for more than one value
    of</st> *<st c="45980">x</st>*<st c="45981">. For example, the sine of 0 returns
    0, and so does the sine of π.</st> <st c="46048">So, if we encode a variable with
    just the sine, we wouldn’t be able to distinguish between the values 0 and π anymore.</st>
    <st c="46167">However, because the sine and the cosine are out of phase, the cosine
    of 0 returns 1, whereas the</st> <st c="46265">cosine of π returns -1\.</st> <st
    c="46289">Hence, by encoding the variable with the two functions, we are now able
    to distinguish between 0 and 1, which would take (0,1) and (0,-</st><st c="46424">1)
    as values for the sine and cosine</st> <st c="46462">functions, respectively.</st>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用正弦函数吗？还是应该使用余弦函数？实际上，我们需要两者都使用来无歧义地编码变量的所有值。因为正弦和余弦函数在0和1之间循环，它们会在多个x值上取值为0。例如，0的正弦值为0，π的正弦值也是0。因此，如果我们只使用正弦函数来编码变量，我们就无法再区分0和π的值了。然而，由于正弦和余弦函数的相位差，0的余弦值为1，而π的余弦值为-1。因此，通过使用两个函数来编码变量，我们现在能够区分0和1，对于正弦函数，它们将取(0,1)和(0,-1)作为值，而对于余弦函数，则分别取(0,1)和(0,-1)。
- en: <st c="46486">How to do it…</st>
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: <st c="46500">In this recipe, we will first</st> <st c="46530">transform the</st>
    `<st c="46545">hour</st>` <st c="46549">variable in a toy DataFrame with the sine
    and the cosine to get a sense of the new variable representation.</st> <st c="46658">Then,
    we will automate feature creation from multiple cyclical variables</st> <st c="46731">using</st>
    `<st c="46737">feature-engine</st>`<st c="46751">:</st>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先将玩具DataFrame中的`小时`变量通过正弦和余弦变换来转换，以了解新的变量表示形式。然后，我们将使用`feature-engine`来自动化从多个周期性变量中创建特征：
- en: <st c="46753">Begin by importing the</st> <st c="46776">necessary libraries:</st>
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始导入必要的库：
- en: '[PRE65]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: <st c="46867">Create a toy DataFrame with one variable –</st> `<st c="46911">hour</st>`
    <st c="46915">– with values between 0</st> <st c="46940">and 23:</st>
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含一个变量 – `<小时>` – 的玩具DataFrame，其值在0和23之间：
- en: '[PRE66]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: <st c="47007">Next, create two features using the sine and cosine transformations,
    after normalizing the variable values between 0</st> <st c="47125">and 2π:</st>
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建两个特征，使用正弦和余弦变换，在将变量值归一化到0和2π之间后：
- en: '[PRE67]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: <st c="47268">If we e</st><st c="47276">xecute</st> `<st c="47284">df.head()</st>`<st
    c="47293">, we will see the original and</st> <st c="47324">new features:</st>
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们执行`df.head()`，我们将看到原始特征和新特征：
- en: "![Figure 8.12 – A DataFrame with the hour variable and the new features obtaine\uFEFF\
    d through the sine and cosine transformations](img/B22396_08_12.jpg)"
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 包含小时变量和通过正弦和余弦变换获得的新特征的DataFrame](img/B22396_08_12.jpg)'
- en: <st c="47462">Figure 8.12 – A DataFrame with the hour variable and the new features
    obtaine</st><st c="47539">d through the sine and cosine transformations</st>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 包含小时变量和通过正弦和余弦变换获得的新特征的DataFrame
- en: <st c="47585">Make</st> <st c="47590">a scatter plot between the</st> <st c="47618">hour
    and its</st> <st c="47631">sine-transformed values:</st>
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作小时与其正弦变换值之间的散点图：
- en: '[PRE68]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <st c="47774">In the following plot, we can see how the values of the hour circle
    between -1</st> <st c="47853">and 1, just like the sine function after</st> <st
    c="47895">the transformation:</st>
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，我们可以看到在-1和1之间的小时圆的值，就像变换后的正弦函数：
- en: "![Figure 8.13 – A sca\uFEFFtter plot of th\uFEFFe hour versus its sine transformed\
    \ values](img/B22396_08_13.jpg)"
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 小时与其正弦变换值的散点图](img/B22396_08_13.jpg)'
- en: <st c="48018">Figure 8.13 – A sca</st><st c="48037">tter plot of th</st><st
    c="48053">e hour versus its sine transformed values</st>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 小时与其正弦变换值的散点图
- en: <st c="48095">Now, make</st> <st c="48105">a scatter plot between</st> <st c="48129">the
    hour and its</st> <st c="48146">cosine transformation:</st>
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48095">现在，在</st> <st c="48129">小时和其</st> <st c="48146">余弦变换之间</st> <st
    c="48129">制作一个散点图：</st>
- en: '[PRE69]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: <st c="48291">In the following plot, we can see how the values of the hour circle
    between -1</st> <st c="48371">and 1, just like the cosine function after</st>
    <st c="48414">the transformation:</st>
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48291">在下面的图中，我们可以看到小时的值在-1</st> <st c="48371">和1之间循环，就像变换后的余弦函数一样：</st>
- en: '![Figure 8.14 – A scatter plot of the hour versus its cosine-transformed values](img/B22396_08_14.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 小时与其余弦变换值的散点图](img/B22396_08_14.jpg)'
- en: <st c="48541">Figure 8.14 – A scatter plot of the hour versus its cosine-transformed
    values</st>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48541">图8.14 – 小时与其余弦变换值的散点图</st>
- en: <st c="48618">Finally, we</st> <st c="48630">can reconstitute the cyclical nature
    o</st><st c="48669">f the hour,</st> <st c="48681">which is now captured by the
    two</st> <st c="48715">new features.</st>
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48618">最后，我们可以重建小时</st> <st c="48630">的循环性质，现在它被两个</st> <st c="48715">新特征所捕捉：</st>
- en: <st c="48728">Plot the</st> <st c="48738">values of the sine versus the cosine
    of the hour, and overlay the original values of the hour using a</st> <st c="48840">color
    map:</st>
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48728">绘制正弦值与小时余弦值的</st> <st c="48738">关系图，并使用</st> <st c="48840">颜色图叠加小时的原值：</st>
- en: '[PRE70]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: <st c="49025">In the following plot, we can see how the two trigonometric transformations
    of the hour reflect</st> <st c="49121">the cy</st><st c="49128">clical</st> <st
    c="49136">nature of the hour, in a plot that reminds us of</st> <st c="49185">a
    clock:</st>
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49025">在下面的图中，我们可以看到小时的两个三角变换如何反映</st> <st c="49121">其循环性质，在一张让我们想起</st>
    <st c="49185">钟表的图表中：</st>
- en: '![Figure 8.15 – A scatter plot of the trigonometric transformation of the hour](img/B22396_08_15.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 小时三角变换的散点图](img/B22396_08_15.jpg)'
- en: <st c="49357">Figure 8.15 – A scatter plot of the trigonometric transformation
    of the hour</st>
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49357">图8.15 – 小时三角变换的散点图</st>
- en: <st c="49433">Note</st>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49433">注意</st>
- en: <st c="49438">The code implementation and idea for this plot were taken from
    scikit-learn’s</st> <st c="49517">documentation:</st> [<st c="49532">https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#trigonometric-features</st>](https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#trigonometric-features)<st
    c="49652">.</st>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49438">此图的代码实现和思路来自scikit-learn的</st> <st c="49517">文档：</st> [<st c="49532">https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#trigonometric-features</st>](https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#trigonometric-features)<st
    c="49652">。</st>
- en: <st c="49653">Now that we understand the n</st><st c="49682">ature and effect
    of the transformation, let’s create new features using the sine and cosine transformations
    from multiple variables automatically.</st> <st c="49830">We will use the</st>
    `<st c="49846">feature-engine</st>` <st c="49860">library’s</st> `<st c="49871">CyclicalFeatures()</st>`<st
    c="49889">.</st>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49653">现在我们了解了变换的性质和效果，让我们使用来自多个变量的正弦和余弦变换自动创建新特征。</st> <st c="49830">我们将使用</st>
    `<st c="49846">feature-engine</st>` <st c="49860">库的</st> `<st c="49871">CyclicalFeatures()</st>`<st
    c="49889">。</st>
- en: <st c="49890">Import</st> `<st c="49898">CyclicalFeatures()</st>`<st c="49916">:</st>
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49890">导入</st> `<st c="49898">CyclicalFeatures()</st>`<st c="49916">:</st>
- en: '[PRE71]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: <st c="49971">Let’s create</st> <st c="49984">a toy DataFrame that contains
    the</st> `<st c="50019">hour</st>`<st c="50023">,</st> `<st c="50025">month</st>`<st
    c="50030">, and</st> `<st c="50036">week</st>` <st c="50040">variables, whose</st>
    <st c="50057">values vary between 0 and 23, 1 and 12, and 0 and</st> <st c="50108">6,
    respectively:</st>
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49971">让我们创建</st> <st c="49984">一个包含</st> `<st c="50019">小时</st>`<st
    c="50023">,</st> `<st c="50025">月份</st>`<st c="50030">, 和</st> `<st c="50036">星期</st>`
    <st c="50040">变量的玩具数据集，这些变量的</st> <st c="50057">值分别在0到23，1到12，和0到</st> <st c="50108">6之间变化：</st>
- en: '[PRE72]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <st c="50292">If we execut</st><st c="50305">e</st> `<st c="50308">df.head()</st>`<st
    c="50317">, we will see the first five rows of the</st> <st c="50358">toy DataFra</st><st
    c="50369">me:</st>
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50292">如果我们执行</st><st c="50305">e</st> `<st c="50308">df.head()</st>`<st
    c="50317">，我们将看到</st> <st c="50358">玩具数据集</st><st c="50369">的前五行：</st>
- en: "![Figure 8.16 – The\uFEFF toy DataFrame with three cyclical features](img/B22396_08_16.jpg)"
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图8.16 – 包含三个循环特征的玩具数据集](img/B22396_08_16.jpg)'
- en: <st c="50390">Figure 8.16 – The</st> <st c="50407">toy DataFrame with three
    cyclical features</st>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50390">图8.16 – 具有三个周期特征的</st> <st c="50407">玩具DataFrame</st>
- en: <st c="50450">Set up the transformer to create the sine and cosine features
    from</st> <st c="50518">these variables:</st>
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="50450">设置转换器以从</st> <st c="50518">以下变量创建正弦和余弦特征：</st>
- en: '[PRE73]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: <st c="50600">Note</st>
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50600">注意</st>
- en: <st c="50605">By setting</st> `<st c="50617">variables</st>` <st c="50626">to</st>
    `<st c="50630">None</st>`<st c="50634">,</st> `<st c="50636">CyclicalFeatures()</st>`
    <st c="50654">will create trigonometric features from all numerical variables.</st>
    <st c="50720">To create trigonometric features from a subset of variables, we
    can pass the variables’ names in a list to the</st> `<st c="50831">variables</st>`
    <st c="50840">parameter.</st> <st c="50852">We can retain or drop the original
    variables after creating the cyclical features using the</st> `<st c="50944">drop_original</st>`
    <st c="50957">parameter.</st>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50605">通过将</st> `<st c="50617">变量</st>` <st c="50626">设置为</st> `<st c="50630">None</st>`<st
    c="50634">，</st> `<st c="50636">CyclicalFeatures()</st>` <st c="50654">将从所有数值变量创建三角函数特征。</st>
    <st c="50720">要从变量的子集创建三角函数特征，我们可以将变量的名称列表传递给</st> `<st c="50831">变量</st>` <st
    c="50840">参数。</st> <st c="50852">使用</st> `<st c="50944">drop_original</st>` <st
    c="50957">参数，在创建周期特征后，我们可以保留或删除原始变量。</st>
- en: <st c="50968">To finish, add the</st> <st c="50988">features to the DataFrame
    and capture the result in a</st> <st c="51042">new variable:</st>
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="50968">最后，将</st> <st c="50988">特征添加到DataFrame中，并将结果捕获在一个</st> <st c="51042">新变量中：</st>
- en: '[PRE74]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: <st c="51086">If</st> <st c="51089">we execute</st> `<st c="51101">dft.head()</st>`<st
    c="51111">, we will see the original and</st> <st c="51142">new features:</st>
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="51086">如果我们执行</st> <st c="51089">dft.head()</st><st c="51111">，我们将看到原始和</st>
    <st c="51142">新特征：</st>
- en: '![Figure 8.17 – DataFrame with cyclical features plus the features created
    through the sine and cosine functions](img/B22396_08_17.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图8.17 – 带有周期特征以及通过正弦和余弦函数创建的特征的DataFrame](img/B22396_08_17.jpg)'
- en: <st c="51559">Figure 8.17 – DataFrame with cyclical features plus the features
    created through the sine and cosine functions</st>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51559">图8.17 – 带有周期特征的DataFrame以及通过正弦和余弦函数创建的特征</st>
- en: <st c="51669">And that’s it – we’ve</st> <st c="51692">created features by using
    the sine and cosine transformation automatically from mu</st><st c="51774">ltiple
    variables and added them directly to the</st> <st c="51823">original DataFrame.</st>
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51669">就这样 – 我们已经</st> <st c="51692">通过使用从多个变量自动生成的正弦和余弦变换来创建特征</st><st
    c="51774">，并将其直接添加到</st> <st c="51823">原始DataFrame中。</st>
- en: <st c="51842">How it works…</st>
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="51842">工作原理...</st>
- en: <st c="51856">In this recipe, we enco</st><st c="51880">ded cyclical features
    with</st> <st c="51907">values obtained from the sine and cosine functions, applied
    to the normalized values of the variable.</st> <st c="52010">First, we normalized
    the variable values between 0 and 2 π.</st> <st c="52070">To do this, we divided
    the variable values by the variable maximum value, which we obtained with</st>
    `<st c="52167">pandas.max()</st>`<st c="52179">, to scale the variables between
    0 and 1\.</st> <st c="52221">Then, we multiplied those values by 2π, using</st>
    `<st c="52267">numpy.pi</st>`<st c="52275">. Finally, we used</st> `<st c="52294">np.sin</st>`
    <st c="52300">and</st> `<st c="52305">np.cos</st>` <st c="52311">to apply the
    sine and cosine</st> <st c="52341">transformations, respectively.</st>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51856">在这个菜谱中，我们使用正弦和余弦函数从变量的归一化值中获取的值来编码周期特征。</st> <st c="51880">首先，我们将变量值归一化到0和2π之间。</st>
    <st c="52010">为此，我们用</st> `<st c="52167">pandas.max()</st>`<st c="52179">获取的变量最大值除以变量值，将变量缩放到0和1之间。</st>
    <st c="52221">然后，我们使用</st> `<st c="52267">numpy.pi</st>`<st c="52275">将这些值乘以2π。</st>
    <st c="52294">最后，我们使用</st> `<st c="52294">np.sin</st>` <st c="52300">和</st> `<st
    c="52305">np.cos</st>` <st c="52311">分别应用正弦和余弦变换。</st>
- en: <st c="52371">To automate this procedure for multiple variables, we used the</st>
    `<st c="52435">Feature-engine</st>` <st c="52449">library’s</st> `<st c="52460">CyclicalFeatures()</st>`<st
    c="52478">. With</st> `<st c="52485">fit()</st>`<st c="52490">, the transformer
    learned the maximum values of each variable, and with</st> `<st c="52562">transform()</st>`<st
    c="52573">, it added the features resulting from the sine</st> <st c="52621">and
    cosine transformations to</st> <st c="52651">the DataFrame.</st>
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52371">为了自动化多个变量的此过程，我们使用了`<st c="52435">Feature-engine</st>` <st c="52449">库的`<st
    c="52460">CyclicalFeatures()</st>`<st c="52478">。使用`<st c="52485">fit()</st>`<st
    c="52490">，转换器学习了每个变量的最大值，而使用`<st c="52562">transform()</st>`<st c="52573">，它将正弦和余弦变换产生的特征添加到`<st
    c="52621">DataFrame</st>`中。</st>
- en: <st c="52665">Note</st>
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52665">注意</st>
- en: <st c="52670">In theory, to apply the sine and cosine transformation, we need
    to scale the original variable between 0 and 1\.</st> <st c="52783">Dividing by
    the maximum of the variable will only result in this scaling if the minimum value
    is 0\.</st> <st c="52883">scikit-learn’s documentation and</st> `<st c="52916">Feature-engine</st>`<st
    c="52930">’s current implementation divide the variable by its maximum value (or
    an arbitrary period), without paying too much attention to whether the variable
    starts at 0\.</st> <st c="53095">In practice, you won’t see a big difference in
    the resulting variables if you divide the hour feature by 23 or 24, or the month
    feature by 12 or 11\.</st> <st c="53244">Discussions are underway on whether Feature-engine’s
    implementation should be updated, so the default behavior might change by the
    time t</st><st c="53381">his book is published.</st> <st c="53405">Check out the
    documentation for</st> <st c="53437">more details.</st>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52670">理论上，要应用正弦和余弦变换，我们需要将原始变量缩放到0到1之间。</st> <st c="52783">除以变量的最大值只会在这种缩放情况下发生，如果最小值是0。</st>
    <st c="52883">scikit-learn的文档和`<st c="52916">Feature-engine</st>`<st c="52930">的当前实现将变量除以其最大值（或任意周期），并没有过多关注变量是否从0开始。</st>
    <st c="53095">在实践中，如果你将小时特征除以23或24，或将月份特征除以12或11，你不会在结果变量中看到很大的差异。</st> <st c="53244">目前正在讨论是否应该更新Feature-engine的实现，因此，到这本书出版时，默认行为可能会改变。</st>
    <st c="53405">查看文档以获取更多详细信息。</st>
- en: <st c="53450">Creating spline features</st>
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="53450">创建样条特征</st>
- en: <st c="53475">Linear models</st> <st c="53489">expect a linear relationship
    between the predictor variables and the target.</st> <st c="53567">However, we
    can use linear models to model non-linear effects if we first transform the f</st><st
    c="53656">eatures.</st> <st c="53666">In the</st> *<st c="53673">Performing polynomial
    expansion</st>* <st c="53704">recipe, we saw how we can unmask linear patterns
    by creating features with polynomial functions.</st> <st c="53802">In this recipe,
    we will discuss the use</st> <st c="53842">of splines.</st>
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53475">线性模型</st> <st c="53489">期望预测变量和目标之间存在线性关系。</st> <st c="53567">然而，如果我们首先转换特征，我们可以使用线性模型来模拟非线性效应。</st>
    <st c="53656">在*<st c="53673">执行多项式展开</st>* <st c="53704">食谱中，我们看到了如何通过创建多项式函数的特征来揭示线性模式。</st>
    <st c="53802">在本食谱中，我们将讨论样条的使用。</st>
- en: <st c="53853">Splines are used to mathematically reproduce flexible shapes.</st>
    <st c="53916">They consist of piecewise low-degree polynomial functions.</st>
    <st c="53975">To create splines, we must place knots at several values of</st>
    *<st c="54035">x</st>*<st c="54036">. These knots indicate where the pieces of
    the function join.</st> <st c="54098">Then, we fit low-degree polynomials to the
    data between two</st> <st c="54158">consecutive knots.</st>
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53853">样条用于在数学上再现灵活的形状。</st> <st c="53916">它们由分段低次多项式函数组成。</st> <st c="53975">要创建样条，我们必须在几个值上放置节点。</st>
    *<st c="54035">x</st>*<st c="54036">。这些节点表示函数各部分连接的位置。</st> <st c="54098">然后，我们在两个连续节点之间拟合低次多项式。</st>
- en: <st c="54176">There are several types of splines, such as smoothing splines,
    regression splines, and B-splines.</st> <st c="54275">scikit-learn supports the
    use of B-splines to create features.</st> <st c="54338">The procedure to fit and,
    therefore, return the spline values for a certain variable, based on a polynomial
    degree and the number of knots, exceeds the scope of this recipe.</st> <st c="54512">For
    more details, check out the resources in the</st> *<st c="54561">See also</st>*
    <st c="54569">section of this recipe.</st> <st c="54594">In this recipe, we’ll
    get a sense of what splines are</st> <st c="54647">and how we can use them to
    improve the performance of</st> <st c="54702">linear models.</st>
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54176">样条曲线有几种类型，例如平滑样条、回归样条和B样条。</st> <st c="54275">scikit-learn支持使用B样条来创建特征。</st>
    <st c="54338">拟合样条并因此返回基于多项式度数和节点数的样条值的过程超出了本菜谱的范围。</st> <st c="54512">更多详情，请参阅本菜谱的</st>
    *<st c="54561">参见</st>* <st c="54569">部分。</st> <st c="54594">在这个菜谱中，我们将了解样条曲线是什么</st>
    <st c="54647">以及我们如何使用它们来提高线性模型的性能。</st>
- en: <st c="54716">Getting ready</st>
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="54716">准备工作</st>
- en: <st c="54730">Let’s get a sense of what splines are.</st> <st c="54770">In the
    following figure, on the left, we can see a spline with a degree of 1\.</st> <st
    c="54848">It consists of two linear pieces – one from 2.5 to 5 and the other from
    5 to 7.5\.</st> <st c="54930">There are three knots – 2.5, 5, and 7.5\.</st> <st
    c="54971">Outside the interval between 2.5 and 7.5, the spline takes a value of
    0\.</st> <st c="55044">The latter is characteristic of splines; they are only
    non-negative between certain values.</st> <st c="55136">On the right panel of
    the figure, we can see three</st> <st c="55186">splines of degree 1\.</st> <st
    c="55208">W</st><st c="55209">e can construct as many splines as we want by introducing</st>
    <st c="55267">more knots:</st>
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54730">让我们了解样条曲线是什么。</st> <st c="54770">在下面的图中，左侧我们可以看到一个一阶样条曲线。</st>
    <st c="54848">它由两段线性部分组成 – 一段从2.5到5，另一段从5到7.5。</st> <st c="54930">有三个节点 – 2.5、5和7.5。</st>
    <st c="54971">在2.5和7.5之间的区间外，样条曲线的值为0。</st> <st c="55044">这是样条曲线的特点；它们只在某些值之间为非负。</st>
    <st c="55136">在图的右侧面板中，我们可以看到三个一阶样条曲线。</st> <st c="55186">我们可以通过引入更多的节点来构建我们想要的任意数量的样条曲线：</st>
- en: '![Figure 8.18 – The splines with a degree of 1](img/B22396_08_18.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图8.18 – 一阶样条曲线](img/B22396_08_18.jpg)'
- en: <st c="55401">Figure 8.18 – The splines with a degree of 1</st>
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55401">图8.18 – 一阶样条曲线</st>
- en: <st c="55445">In the following figure, on the left, we can see</st> <st c="55494">a
    quadratic spline, also known as a spline with a degree of 2\.</st> <st c="55558">It
    is based on four adjacent knots – 0, 2.5, 5, and 7.5\.</st> <st c="55615">On the
    ri</st><st c="55624">ght-hand side of the figure, we can see several splines of</st>
    <st c="55684">degree 2:</st>
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55445">在下面的图中，左侧我们可以看到一个二次样条曲线，也称为二阶样条曲线。</st> <st c="55494">它基于四个相邻的节点
    – 0、2.5、5和7.5。</st> <st c="55558">在图的右侧，我们可以看到几个二阶样条曲线：</st>
- en: '![Figure 8.19 – The splines with a degree of 2](img/B22396_08_19.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19 – 二阶样条曲线](img/B22396_08_19.jpg)'
- en: <st c="55793">Figure 8.19 – The splines with a degree of 2</st>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55793">图8.19 – 二阶样条曲线</st>
- en: <st c="55837">We can use splines to model non-lin</st><st c="55873">ear functions,
    and we will learn how to do this in the</st> <st c="55929">next section.</st>
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55837">我们可以使用样条曲线来模拟非线性函数，我们将在下一节中学习如何做。</st>
- en: <st c="55942">How to do it…</st>
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="55942">如何做…</st>
- en: <st c="55956">In this recipe, we</st> <st c="55975">will use splines to model
    the sine function.</st> <st c="56021">Once we get a sense of what splines are
    and how we can use them to fit non-linear relationships through a linear model,
    we will use splines for regression in a</st> <st c="56181">real dataset:</st>
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用样条曲线来模拟正弦函数。<st c="55956">我们将了解样条曲线是什么，以及我们如何通过线性模型使用它们来拟合非线性关系。</st>
    <st c="56021">一旦我们有了这些概念，我们将在一个真实的数据集中使用样条曲线进行回归：</st> <st c="56181">真实数据集：</st>
- en: <st c="56194">Note</st>
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56194">注意</st>
- en: <st c="56199">The idea to model the sine function with splines was taken from
    scikit-learn’s</st> <st c="56279">documentation:</st> [<st c="56294">https://scikit-learn.org/stable/auto_</st><st
    c="56331">examples/linear_model/plot_polynomial_interpolation.html</st>](https://scikit-learn.org/stable/auto_examples/linear_model/plot_polynomial_interpolation.html)<st
    c="56388">.</st>
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56199">将正弦函数用样条建模的想法来自scikit-learn的</st> <st c="56279">文档：</st> [<st
    c="56294">https://scikit-learn.org/stable/auto_</st><st c="56331">examples/linear_model/plot_polynomial_interpolation.html</st>](https://scikit-learn.org/stable/auto_examples/linear_model/plot_polynomial_interpolation.html)<st
    c="56388">。</st>
- en: <st c="56389">Let’s begin by importing the necessary libraries</st> <st c="56439">and
    classes:</st>
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56389">让我们首先导入必要的库和类：</st>
- en: '[PRE75]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: <st c="56613">Create a training set,</st> `<st c="56637">X</st>`<st c="56638">,
    with 20 values between -1 and 11, and the target variable,</st> `<st c="56699">y</st>`<st
    c="56700">, which is the sine</st> <st c="56720">of</st> `<st c="56723">X</st>`<st
    c="56724">:</st>
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56613">创建一个包含20个介于-1和11之间的值的训练集</st> `<st c="56637">X</st>`<st c="56638">，以及目标变量</st>
    `<st c="56699">y</st>`<st c="56700">，它是</st> `<st c="56720">X</st>`<st c="56723">的</st>
    `<st c="56724">正弦</st>`<st c="56725">：</st>
- en: '[PRE76]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: <st c="56767">Plot the relationship between</st> `<st c="56798">X</st>` <st
    c="56799">and</st> `<st c="56803">y</st>`<st c="56804">:</st>
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56767">绘制</st> `<st c="56798">X</st>` <st c="56799">和</st> `<st c="56803">y</st>`<st
    c="56804">之间的关系图：</st>
- en: '[PRE77]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: <st c="56853">In the following plot, we can see the sine function</st> <st c="56906">of</st>
    `<st c="56909">X</st>`<st c="56910">:</st>
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="56853">在下面的图中，我们可以看到</st> `<st c="56909">X</st>`<st c="56910">的</st>
    `<st c="56906">正弦</st>`<st c="56907">函数：</st>
- en: "![Figure 8.20 – The relationship \uFEFFbetween the predictor and the target\
    \ variable, where y = sine(x)](img/B22396_08_20.jpg)"
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![图8.20 – 预测变量与目标变量之间的关系，其中y = sine(x)](img/B22396_08_20.jpg)'
- en: <st c="56980">Figure 8.20 – The relationship</st> <st c="57011">between the
    predictor and the target variable, where y = sine(x)</st>
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56980">图8.20 – 预测变量与目标变量之间的关系，其中y = sine(x)</st>
- en: <st c="57075">Fit a linear</st> <st c="57088">model to predict</st> `<st c="57106">y</st>`
    <st c="57107">from</st> `<st c="57113">X</st>` <st c="57114">by utilizing a Ridge
    regression, and then obtain the predictions of</st> <st c="57183">the model:</st>
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57075">使用Ridge回归将线性模型拟合到预测</st> `<st c="57106">y</st>` <st c="57107">来自</st>
    `<st c="57113">X</st>` <st c="57114">，然后获得模型的预测结果：</st>
- en: '[PRE78]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: <st c="57297">Now, plot the relationship between</st> `<st c="57333">X</st>`
    <st c="57334">and</st> `<st c="57339">y</st>`<st c="57340">, and overlay</st>
    <st c="57354">the predictions:</st>
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57297">现在，绘制</st> `<st c="57333">X</st>` <st c="57334">和</st> `<st c="57339">y</st>`<st
    c="57340">之间的关系图，并叠加</st> <st c="57354">预测结果：</st>
- en: '[PRE79]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: <st c="57505">In the following figure, we can see that the linear model m</st><st
    c="57565">akes a very poor fit of the non-linear relationship between</st> `<st
    c="57626">X</st>` <st c="57627">and</st> `<st c="57631">y</st>`<st c="57632">:</st>
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="57505">在下面的图中，我们可以看到线性模型m对</st><st c="57565">X</st><st c="57566">和</st><st
    c="57567">y</st><st c="57568">之间的非线性关系拟合得非常差：</st>
- en: '![Figure 8.21 – The linear fit between X and y](img/B22396_08_21.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图8.21 – X和y之间的线性拟合](img/B22396_08_21.jpg)'
- en: <st c="57716">Figure 8.21 – The linear fit between X and y</st>
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57716">图8.21 – X和y之间的线性拟合</st>
- en: <st c="57760">Now, set</st> <st c="57769">up</st> `<st c="57773">SplineTransformer()</st>`
    <st c="57792">to obtain spline features from</st> `<st c="57824">X</st>`<st c="57825">,
    by utilizing third-degree polynomials and five knots at equidistant places within
    the values</st> <st c="57920">of</st> `<st c="57923">X</st>`<st c="57924">:</st>
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57760">现在，设置</st> `<st c="57769">SplineTransformer()</st>` <st c="57792">以从</st>
    `<st c="57824">X</st>`<st c="57825">中获取样条特征，通过使用三次多项式和五个等距节点：</st>
- en: '[PRE80]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: <st c="57970">Obtain the spline features and convert the NumPy array into a</st>
    `<st c="58033">pandas</st>` <st c="58039">DataFrame, adding the names of the spline</st>
    <st c="58082">basis functions:</st>
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57970">获取样条特征并将NumPy数组转换为</st> `<st c="58033">pandas</st>` <st c="58039">DataFrame，添加样条</st>
    `<st c="58082">基函数</st>`<st c="58083">的名称：</st>
- en: '[PRE81]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: <st c="58212">By executing</st> `<st c="58226">X_df.head()</st>`<st c="58237">,
    we can see the</st> <st c="58254">spline features:</st>
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="58212">通过执行</st> `<st c="58226">X_df.head()</st>`<st c="58237">，我们可以看到</st>
    `<st c="58254">样条</st>`<st c="58255">特征：</st>
- en: '![Figure 8.22 – A DataFrame with the splines](img/B22396_08_22.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22 – 包含样条的DataFrame](img/B22396_08_22.jpg)'
- en: <st c="58585">Figure 8.22 – A DataFrame with the splines</st>
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58585">图8.22 – 包含样条的DataFrame</st>
- en: <st c="58627">Note</st>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58627">注意</st>
- en: '`<st c="58632">SplineTransformer()</st>` <st c="58652">returns a</st> <st c="58662">feature
    matrix consisting of</st> `<st c="58692">n_splines = n_knots + degree –</st>`
    `<st c="58723">1</st>`<st c="58724">.</st>'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="58632">SplineTransformer()</st>` <st c="58652">返回一个由</st> `<st c="58692">n_splines
    = n_knots + degree –</st>` `<st c="58723">1</st>`<st c="58724">.</st>'
- en: <st c="58725">Now, plot</st> <st c="58736">the splines against the values</st>
    <st c="58767">of</st> `<st c="58770">X</st>`<st c="58771">:</st>
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="58725">现在，将样条曲线与</st><st c="58736">的值</st><st c="58767">绘制出来</st><st
    c="58770">X</st><st c="58771">：</st>
- en: '[PRE82]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: <st c="58955">In the following figure, we can see the relationship betwee</st><st
    c="59015">n the different splines and the values of the predictor</st> <st c="59072">variable,</st>
    `<st c="59082">X</st>`<st c="59083">:</st>
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="58955">在下面的图中，我们可以看到不同样条与预测变量</st><st c="59015">的值</st><st c="59072">之间</st><st
    c="59082">X</st><st c="59083">的关系：</st>
- en: "![Figure 8.23 – Spli\uFEFFnes plotted against the values of the predictor variable,\
    \ X](img/B22396_08_23.jpg)"
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图8.23 – 样条曲线与预测变量X的值的关系](img/B22396_08_23.jpg)'
- en: <st c="59216">Figure 8.23 – Spli</st><st c="59234">nes plotted against the values
    of the predictor variable, X</st>
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59216">图8.23 – 样条曲线与预测变量X的值的关系</st>
- en: <st c="59294">Now, fit a</st> <st c="59306">linear model to predict</st> `<st
    c="59330">y</st>` <st c="59331">from the spline features obtained from</st> `<st
    c="59371">X</st>`<st c="59372">, by utilizing a Ridge regression, and then obtain
    the predictions of</st> <st c="59442">the model:</st>
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="59294">现在，拟合一个线性模型来预测</st><st c="59330">y</st><st c="59331">，从</st><st
    c="59371">X</st><st c="59372">获得的样条特征，通过利用岭回归，然后获得模型的预测：</st>
- en: '[PRE83]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: <st c="59530">Now, plot the relationship between</st> `<st c="59566">X</st>`
    <st c="59567">and</st> `<st c="59572">y</st>`<st c="59573">, and overlay</st>
    <st c="59587">the predictions:</st>
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="59530">现在，绘制X和y之间的关系图，并叠加预测：</st>
- en: '[PRE84]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: <st c="59739">In the following figure, we can see that by utilizing spline featur</st><st
    c="59807">es as input, the Ridge regression can better predict the shape</st>
    <st c="59871">of</st> `<st c="59874">y</st>`<st c="59875">:</st>
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="59739">在下面的图中，我们可以看到通过利用样条特征作为输入，岭回归可以更好地预测y的形状</st><st c="59807">：</st>
- en: '![Figure 8.24 – The predictions of a linear model, based on splines overlaid
    over the true relationship between X and y](img/B22396_08_24.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24 – 基于X和y之间真实关系的样条曲线的线性模型预测](img/B22396_08_24.jpg)'
- en: <st c="59961">Figure 8.24 – The predictions of a linear model, based on splines
    overlaid over the true relationship between X and y</st>
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59961">图8.24 – 基于X和y之间真实关系的样条曲线的线性模型预测</st>
- en: <st c="60078">Note</st>
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60078">注意</st>
- en: <st c="60083">Increasing the number of knots or the degree of the polynomial
    increases the flexibility of the spline curves.</st> <st c="60195">Try creating
    splines from higher polynomial degrees and see how the Ridge regression</st> <st
    c="60280">predictions change.</st>
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60083">增加节点数或多项式的次数会增加样条曲线的灵活性。</st> <st c="60195">尝试从更高次的多项式创建样条，看看岭回归预测会如何变化。</st>
    <st c="60280">预测。</st>
- en: <st c="60299">Now that we</st> <st c="60312">understand what the spline features
    are and how we can use them to predict non-linear effects, let’s try them out
    on a</st> <st c="60431">real dataset.</st>
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60299">现在我们</st><st c="60312">了解了样条特征是什么以及我们如何使用它们来预测非线性效应，让我们在一个</st><st
    c="60431">真实数据集上尝试一下。</st>
- en: <st c="60444">Import some additional classes and functions</st> <st c="60490">from</st>
    `<st c="60495">scikit-learn</st>`<st c="60507">:</st>
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60444">从`<st c="60495">scikit-learn</st>`<st c="60507">导入一些额外的类和函数：</st>
- en: '[PRE85]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: <st c="60661">Load the California housing dataset and drop two of the variables,
    which we won’t use</st> <st c="60748">for modeling:</st>
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60661">加载加利福尼亚住房数据集，并删除两个我们不会用于建模的变量：</st>
- en: '[PRE86]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: <st c="60882">First, we</st> <st c="60893">wil</st><st c="60896">l fit a Ridge
    regression to predict house prices based on the existing variables, by utilizing
    cross-validation, and then obtain the performance of the model to set up</st>
    <st c="61065">the benchmark:</st>
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60882">首先，我们</st><st c="60893">将</st><st c="60896">拟合岭回归来预测房价，基于现有变量，通过利用交叉验证，然后获得模型的性能以设置</st><st
    c="61065">基准：</st>
- en: '[PRE87]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: <st c="61253">In the following output, we can see the model performance, where
    the values are</st> <st c="61334">the</st> *<st c="61338">R</st>*<st c="61339">-squared:</st>
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="61253">在以下输出中，我们可以看到模型性能，其中值是</st> `<st c="61334">R</st>`<st c="61338">-squared：</st>
- en: '[PRE88]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: spl = SplineTransformer(degree=3, n_knots=50)
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: spl = SplineTransformer(degree=3, n_knots=50)
- en: ct = ColumnTransformer(
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ct = ColumnTransformer(
- en: '[("splines", spl, ['
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[("splines", spl, ['
- en: '"AveRooms", "AveBedrms", "Population",'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"平均房间数", "平均卧室数", "人口"'
- en: '"AveOccup"]'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"平均居住人数"]'
- en: )],
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )],
- en: remainder="passthrough",
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: remainder="passthrough",
- en: )
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: ct.fit(X, y)
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ct.fit(X, y)
- en: '[PRE89]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: <st c="61756">Note</st>
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61756">注意</st>
- en: <st c="61761">Remember that we need to use</st> `<st c="61791">ColumnTransformer()</st>`
    <st c="61810">to obtain features from a subset of variables in the data.</st>
    <st c="61870">With</st> `<st c="61875">remainder=passthrough</st>`<st c="61896">,
    we ensure that the variables that are not used as templates for the splines –
    that is,</st> `<st c="61985">MedInc</st>` <st c="61991">and</st> `<st c="61996">HouseAge</st>`
    <st c="62004">– are also returned in the resulting DataFrame.</st> <st c="62053">To
    check out the features resulting from this step,</st> <st c="62105">execute</st>
    `<st c="62113">ct.get_feature_names_out()</st>`<st c="62139">.</st>
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61761">记住，我们需要使用</st> `<st c="61791">ColumnTransformer()</st>` <st c="61810">从数据的一组变量中获取特征。</st>
    <st c="61870">使用</st> `<st c="61875">remainder=passthrough</st>`<st c="61896">，我们确保那些不作为样条模板的变量
    – 即</st> `<st c="61985">MedInc</st>` <st c="61991">和</st> `<st c="61996">HouseAge</st>`
    <st c="62004"> – 也会在结果 DataFrame 中返回。</st> <st c="62053">要检查此步骤产生的特征，请执行</st>
    `<st c="62105">ct.get_feature_names_out()</st>`<st c="62139">。</st>
- en: <st c="62140">Now, fit a Ridge</st> <st c="62158">regression to predict house
    prices based on</st> `<st c="62202">MedInc</st>`<st c="62208">,</st> `<st c="62210">HouseAge</st>`<st
    c="62218">, and the spline features, using cross-validation, and then obtain the
    performance of</st> <st c="62304">the model:</st>
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="62140">现在，使用交叉验证将岭回归拟合到基于</st> `<st c="62202">MedInc</st>`<st c="62208">、</st>
    `<st c="62210">HouseAge</st>`<st c="62218">和样条特征来预测房价，然后获得模型的性能：</st>
- en: '[PRE90]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: <st c="62470">In the following output, we can see the model performance, where
    the values are</st> <st c="62551">the</st> *<st c="62555">R</st>*<st c="62556">-squared:</st>
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="62470">在以下输出中，我们可以看到模型性能，其中值是</st> `<st c="62551">R</st>`<st c="62555">-squared：</st>
- en: '[PRE91]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: <st c="62620">As we can see, by using splines in place of some of the original
    va</st><st c="62688">riables, we can improve the performance of the linear</st>
    <st c="62743">regression model.</st>
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62620">正如我们所见，通过使用样条函数代替一些原始变量，我们可以提高线性回归模型的性能。</st>
- en: <st c="62760">How it works…</st>
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="62760">它是如何工作的…</st>
- en: <st c="62774">In this recipe, we created new features based on splines.</st>
    <st c="62833">First, we used a toy variable, with values from -1 to 11, and then
    we obtained splines from a real dataset.</st> <st c="62941">The procedure in both
    cases was identical – we used</st> `<st c="62993">SplineTransformer()</st>` <st
    c="63012">from</st> `<st c="63018">scikit-learn</st>`<st c="63030">. The</st>
    `<st c="63036">SplineTransformer()</st>` <st c="63055">transformer takes the</st>
    `<st c="63078">degree</st>` <st c="63084">property of the polynomial and the number
    of knots (</st>`<st c="63137">n_knots</st>`<st c="63145">) as input and returns
    the splines that better fit the data.</st> <st c="63207">The knots are placed
    at equidistant values of</st> `<st c="63253">X</st>` <st c="63254">by default,
    but through the</st> `<st c="63283">knots</st>` <st c="63288">parameter, we can
    choose to uniformly distribute them to the quantiles of</st> `<st c="63363">X</st>`
    <st c="63364">instead, or we can pass an array with the specific values of</st>
    `<st c="63426">X</st>` <st c="63427">that should be used</st> <st c="63448">as
    knots.</st>
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62774">在这个菜谱中，我们基于样条函数创建了新的特征。</st> <st c="62833">首先，我们使用一个玩具变量，其值从 -1
    到 11，然后我们从真实数据集中获得了样条函数。</st> <st c="62941">两种情况下的程序都是相同的 – 我们使用了</st> `<st c="62993">SplineTransformer()</st>`
    <st c="63012">从</st> `<st c="63018">scikit-learn</st>`<st c="63030">。 The</st>
    `<st c="63036">SplineTransformer()</st>` <st c="63055">转换器接受多项式的</st> `<st c="63078">degree</st>`
    <st c="63084">属性和节点数（</st>`<st c="63137">n_knots</st>`<st c="63145">）作为输入，并返回更好地拟合数据的样条函数。</st>
    <st c="63207">节点默认放置在</st> `<st c="63253">X</st>` <st c="63254">的等距值上，但通过</st>
    `<st c="63283">knots</st>` <st c="63288">参数，我们可以选择将它们均匀分布到</st> `<st c="63363">X</st>`
    <st c="63364">的百分位数上，或者我们可以传递一个包含</st> `<st c="63426">X</st>` <st c="63427">特定值的数组，这些值应用作节点。</st>
- en: <st c="63457">Note</st>
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63457">注意</st>
- en: <st c="63462">The number, spacing, and position of the knots are arbitrarily
    set by the user and are the parameters that influence the shape of the splines
    the most.</st> <st c="63615">When using splines in regression models, we can optimize
    these parameters in a randomized search</st> <st c="63712">with cross-validation.</st>
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63462">节点数量、间距和位置由用户任意设置，这些是影响样条形状的最主要参数。</st> <st c="63615">在使用回归模型中的样条时，我们可以通过交叉验证进行随机搜索</st>
    <st c="63712">来优化这些参数。</st>
- en: <st c="63734">With</st> `<st c="63740">fit()</st>`<st c="63745">, the</st> <st
    c="63751">transformer computes the knots of the splines.</st> <st c="63798">With</st>
    `<st c="63803">transform()</st>`<st c="63814">, it returns the array of B-splines.</st>
    <st c="63851">The transformer returns</st> `<st c="63875">n_splines=n_knots +
    degree –</st>` `<st c="63904">1</st>`<st c="63905">.</st>
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63734">使用</st> `<st c="63740">fit()</st>`<st c="63745">`，转换器计算样条的节点。</st>
    <st c="63798">使用</st> `<st c="63803">transform()</st>`<st c="63814">`，它返回 B 样条的数组。</st>
    <st c="63851">转换器返回</st> `<st c="63875">n_splines=n_knots + degree –</st>` `<st
    c="63904">1</st>`<st c="63905">。</st>
- en: <st c="63906">Remember that, like most scikit-learn transformers,</st> `<st
    c="63959">SplineTransformer()</st>` <st c="63978">also now has the option to return</st>
    `<st c="64013">pandas</st>` <st c="64019">and polars DataFrames in addition to
    NumPy arrays, a behavior that can be modified through the</st> `<st c="64115">set_output()</st>`
    <st c="64127">method.</st>
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63906">记住，像大多数 scikit-learn 转换器一样，`<st c="63959">SplineTransformer()</st>`
    <st c="63978">现在也有选项返回</st> `<st c="64013">pandas</st>` <st c="64019">和 polars
    DataFrames，除了 NumPy 数组，这种行为可以通过</st> `<st c="64115">set_output()</st>` <st c="64127">方法进行修改。</st>
- en: <st c="64135">Finally, we used</st> `<st c="64153">ColumnTransformer()</st>`
    <st c="64172">to derive splines from a subset of features.</st> <st c="64218">Because
    we set</st> `<st c="64233">remainder</st>` <st c="64242">to</st> `<st c="64246">passthrough</st>`<st
    c="64257">,</st> `<st c="64259">ColumnTransformer</st><st c="64276">()</st>` <st
    c="64280">concatenated the features that were not used to obtain splines to the
    resulting matrix of splines.</st> <st c="64379">By doing this, we fitted a Ridge
    regression with the splines, plus the</st> `<st c="64450">MedInc</st>` <st c="64456">and</st>
    `<st c="64461">Ho</st><st c="64463">useAge</st>` <st c="64470">variables, and
    managed to improve the linear</st> <st c="64516">model’s performance.</st>
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64135">最后，我们使用了</st> `<st c="64153">ColumnTransformer()</st>` <st c="64172">从特征子集中提取样条。</st>
    <st c="64218">因为我们设置了</st> `<st c="64233">remainder</st>` <st c="64242">为</st>
    `<st c="64246">passthrough</st>`<st c="64257">`，`<st c="64259">ColumnTransformer</st><st
    c="64276">()` <st c="64280">将未用于获取样条的特征连接到结果样条矩阵中。</st> <st c="64379">通过这样做，我们使用样条拟合了
    Ridge 回归，加上</st> `<st c="64450">MedInc</st>` <st c="64456">和</st> `<st c="64461">Ho</st><st
    c="64463">useAge</st>` <st c="64470">变量，并成功提高了线性</st> <st c="64516">模型的性能。</st>
- en: <st c="64536">See also</st>
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="64536">另请参阅</st>
- en: <st c="64545">To find out more about the math underlying B-splines, check out
    the</st> <st c="64614">following articles:</st>
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64545">要了解更多关于 B 样条背后的数学知识，请查看以下文章：</st>
- en: <st c="64633">Perperoglou, et al.</st> *<st c="64654">A review of spline function
    procedures in R</st>* <st c="64697">(</st>[<st c="64699">https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3</st>](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3)<st
    c="64777">).</st> <st c="64781">BMC Med Res Methodol 19,</st> <st c="64806">46
    (2019).</st>
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="64633">Perperoglou 等人。</st> *<st c="64654">R 中样条函数过程综述</st>* <st c="64697">(</st>[<st
    c="64699">https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3</st>](https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/s12874-019-0666-3)<st
    c="64777">).</st> <st c="64781">BMC Med Res Methodol 19,</st> <st c="64806">46
    (2019).</st>
- en: <st c="64816">Eilers and Marx.</st> *<st c="64834">Flexible Smoothing with B-splines
    and</st>* *<st c="64872">Penalties</st>* <st c="64881">(</st>[<st c="64883">https://projecteuclid.org/journals/statistical-science/volume-11/issue-2/Flexible-smoothing-with-B-splines-and-penalties/10.1214/ss/1038425655.full</st>](https://projecteuclid.org/journals/statistical-science/volume-11/issue-2/Flexible-smoothing-with-B-splines-and-penalties/10.1214/ss/1038425655.full)<st
    c="65030">).</st>
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="64816">Eilers 和 Marx.</st> *<st c="64834">使用 B 样条和</st>* *<st c="64872">惩罚</st>*
    <st c="64881">(</st>[<st c="64883">https://projecteuclid.org/journals/statistical-science/volume-11/issue-2/Flexible-smoothing-with-B-splines-and-penalties/10.1214/ss/1038425655.full</st>](https://projecteuclid.org/journals/statistical-science/volume-11/issue-2/Flexible-smoothing-with-B-splines-and-penalties/10.1214/ss/1038425655.full)<st
    c="65030">).</st>
- en: <st c="65033">For an example of how to use B-splines to model time series data,
    check out the following page in the</st> `<st c="65136">scikit-learn</st>` <st
    c="65148">library’s</st> <st c="65159">documentation:</st> [<st c="65174">https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#periodic-spline-features</st>](https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#periodic-spline-features)<st
    c="65296">.</st>
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="65033">以下页面展示了如何使用B样条来建模时间序列数据的示例，请查看</st> `<st c="65136">scikit-learn</st>`
    <st c="65148">库的</st> <st c="65159">文档：</st> [<st c="65174">https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#periodic-spline-features</st>](https://scikit-learn.org/stable/auto_examples/applications/plot_cyclical_feature_engineering.html#periodic-spline-features)<st
    c="65296">。</st>
