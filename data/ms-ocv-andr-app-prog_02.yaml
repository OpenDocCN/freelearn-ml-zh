- en: Chapter 2. Detecting Basic Features in Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 在图像中检测基本特征
- en: After reading about the basics of image processing and manipulation in the previous
    chapter, we will take a look at some of the most widely used algorithms used to
    extract meaningful information from the images in the form of edges, lines, circles,
    ellipses, blobs or contours, user defined shapes, and corners. In context of *computer
    vision* and *image processing*, such information is often termed as *features*.
    In this chapter, we will take a look at the various feature detection algorithms,
    such as Edge and Corner detection algorithms, Hough transformations, and Contour
    detection algorithms and their implementations on an Android platform using OpenCV.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章阅读了图像处理和操作的基本知识之后，我们将探讨一些最广泛使用的算法，这些算法用于从图像中提取有意义的信息，形式为边缘、线条、圆形、椭圆形、块或轮廓、用户定义的形状和角落。在*计算机视觉*和*图像处理*的背景下，此类信息通常被称为*特征*。在本章中，我们将探讨各种特征检测算法，如边缘和角落检测算法、霍夫变换和轮廓检测算法，以及它们在
    Android 平台上的实现，使用 OpenCV。
- en: To make our lives simpler, and have a clear understanding of this chapter, we
    will first create a basic Android application to which we will keep adding implementations
    of different feature detection algorithms. This will reduce the amount of extra
    code that we would otherwise have to write for each algorithm in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的生活更简单，并对本章有一个清晰的理解，我们将首先创建一个基本的 Android 应用程序，我们将向其中添加不同特征检测算法的实现。这将减少我们为本章中的每个算法必须编写的额外代码量。
- en: Creating our application
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: Let's create a very basic Android application that will read images from your
    phone's gallery and display them on the screen using the *ImageView* control.
    The application will also have a menu option to open the gallery to choose an
    image.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常基本的 Android 应用程序，该程序将从您的手机相册中读取图像，并使用*ImageView*控件在屏幕上显示它们。该应用程序还将有一个菜单选项打开相册以选择图像。
- en: We will start off by creating a new Eclipse (or an Android Studio) project with
    a blank activity, and let's call our application **Features App**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个新的 Eclipse（或 Android Studio）项目开始，创建一个空白活动，并让我们将我们的应用程序命名为**功能应用**。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before doing anything to the application, initialize OpenCV in your application
    (refer to [Chapter 1](ch01.html "Chapter 1. Applying Effects to Images"), *Applying
    Effects to Images*, on how to initialize OpenCV in an Android project).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在对应用程序进行任何操作之前，请在您的应用程序中初始化 OpenCV（有关如何在 Android 项目中初始化 OpenCV 的信息，请参阅[第 1 章](ch01.html
    "第 1 章. 对图像应用效果")，*对图像应用效果*）。
- en: 'To the blank activity, add an `ImageView` control (used to display the image),
    as shown in the following code snippet:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在空白活动中添加一个`ImageView`控件（用于显示图像），如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the application menu, add an `OpenGallery` menu option to open the phone''s
    gallery and help us pick an image. For this, add a new menu item in the project''s
    menu resource XML file (default location of the file is `/res/menu/filename.xml`),
    as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序菜单中添加一个`OpenGallery`菜单选项以打开手机的相册并帮助我们选择一张图片。为此，在项目的菜单资源 XML 文件中添加一个新的菜单项（文件的默认位置是`/res/menu/filename.xml`），如下所示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more detailed information on menus in Android, refer to [http://developer.android.com/guide/topics/ui/menus.html](http://developer.android.com/guide/topics/ui/menus.html).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Android 中菜单的更详细信息，请参阅[http://developer.android.com/guide/topics/ui/menus.html](http://developer.android.com/guide/topics/ui/menus.html)。
- en: 'Let''s now make the `OpenGallery` menu option functional. Android API exposes
    a `public boolean onOptionsItemSelected(MenuItem item)` function that allows the
    developer to program the option selection event. In this function, we will add
    a piece of code that will open the gallery of your phone to choose an image. Android
    API provides a predefined intent `Intent.ACTION_PICK` just for this task; that
    is, to open the gallery and pick an image. We will use this intent for our application,
    as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让`OpenGallery`菜单选项变得可用。Android API 提供了一个`public boolean onOptionsItemSelected(MenuItem
    item)`函数，允许开发者编程选项选择事件。在这个函数中，我们将添加一段代码，这将打开手机的相册以选择一张图片。Android API 提供了一个预定义的
    intent `Intent.ACTION_PICK`专门用于这个任务；即打开相册并选择一张图片。我们将为此应用程序使用这个 intent，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's modify the `public boolean onOptionsItemSelected(MenuItem item)` function
    and make it function as per our need.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`public boolean onOptionsItemSelected(MenuItem item)`函数，使其按我们的需求工作。
- en: 'The final implementation of the function should look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最终实现应如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code has nothing but a bunch of easy-to-understand if else statements.
    The thing you need to understand here is the `startActivityForResult()` function.
    As you might have realized, we want to bring the image data from `ACTION_PICK
    Intent` in to our application so that we can use it later as an input for our
    feature detection algorithms. For this reason, instead of using the `startActivity()`
    function, we use `startActivityForResult()`. After the user is done with the subsequent
    activity, the system calls the `onActivityResult()` function along with the result
    from the called intent, which is the gallery picker in our case. Our work now
    is to implement the `onActivityResult()` function in accordance with our application.
    Let's first enumerate what we want to do with the returned image. Not much actually;
    correct the orientation of the image and display it on the screen using `ImageView`
    that we added to our activity in the beginning of this section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只有一些易于理解的 if else 语句。这里你需要理解的是 `startActivityForResult()` 函数。正如你可能已经意识到的，我们希望将来自
    `ACTION_PICK Intent` 的图像数据带到我们的应用程序中，以便我们以后可以用作特征检测算法的输入。因此，我们不是使用 `startActivity()`
    函数，而是使用 `startActivityForResult()`。用户完成后续活动后，系统会调用 `onActivityResult()` 函数，并附带从调用意图返回的结果，在我们的例子中是图库选择器。我们现在的工作是实现符合我们应用程序的
    `onActivityResult()` 函数。让我们首先列举一下我们想要对返回的图像做什么。实际上并不多；纠正图像的方向，并使用我们在本节开头添加到活动中的
    `ImageView` 在屏幕上显示它。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must be wondering what is meant by correcting the orientation of an image.
    In any Android phone, there can be multiple sources of images, such as the native
    camera application, the Java camera app, or any other third-party app. Each of
    them might have different ways of capturing and storing images. Now, in your application,
    when you load these images, it may so happen that they are rotated by some angle.
    Before these images can be used in our application, we should correct their orientation
    so that they appear meaningful to your application users. We will take a look
    at the code to do this now.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道什么是纠正图像方向。在任何 Android 手机上，可能有多个图像来源，例如原生的相机应用程序、Java 相机应用程序或任何其他第三方应用程序。每个都可能以不同的方式捕获和存储图像。现在，在你的应用程序中，当你加载这些图像时，它们可能已经以某个角度旋转。在我们将这些图像用于应用程序之前，我们应该纠正它们的方向，以便它们对应用程序用户有意义。我们现在将查看执行此操作的代码。
- en: 'The following is the `onActivityResult()` function for our application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们应用程序的 `onActivityResult()` 函数：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's see what this long piece of code does. First, we do a sanity check and
    see whether the result is coming from the appropriate intent (that is, the gallery
    picker) by checking `requestCode` and `resultCode`. After this is done, we try
    to retrieve the path of the image in your phone's filesystem. From the `ACTION.PICK`
    intent, we get the `Uri` of the selected image, which we will store in `Uri selectedImage`.
    To get the exact path of the image, we make use of the `Cursor` class. We initialize
    a new `Cursor` class object with it pointing toward our `selectedImage`. Using
    `MediaStore.Images.Media.DATA`, we fetch the column index of the selected image,
    and then eventually, the path of the image using the cursor class declared earlier,
    and store it in a string, `picturePath`. After we have the path of the image,
    we create a new Bitmap object temp to store the image. So far, we have been able
    to read the image and store it in a bitmap object. Next we need to correct the
    orientation. For this, we first extract the orientation information from the image
    using the `ExifInterface` class. As you can see in the code, the `ExifInterface`
    class gives us the orientation information through `ExifInterface.TAG_ORIENTATION`.
    Using this orientation information, we rotate our bitmap accordingly using the
    `rotateBitmap()` function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段长代码做了什么。首先，我们进行一次合理性检查，看看结果是否来自适当的意图（即图库选择器），通过检查 `requestCode` 和 `resultCode`。完成这个步骤后，我们尝试从你的手机文件系统中检索图像的路径。从
    `ACTION.PICK` 意图，我们获取所选图像的 `Uri`，我们将将其存储在 `Uri selectedImage` 中。为了获取图像的确切路径，我们使用
    `Cursor` 类。我们使用它初始化一个新的 `Cursor` 类对象，指向我们的 `selectedImage`。使用 `MediaStore.Images.Media.DATA`，我们获取所选图像的列索引，然后最终使用之前声明的
    cursor 类获取图像的路径，并将其存储在一个字符串 `picturePath` 中。在我们得到图像的路径后，我们创建一个新的 Bitmap 对象 temp
    来存储图像。到目前为止，我们已经能够读取图像并将其存储在位图对象中。接下来我们需要纠正方向。为此，我们首先使用 `ExifInterface` 类从图像中提取方向信息。正如你在代码中所见，`ExifInterface`
    类通过 `ExifInterface.TAG_ORIENTATION` 给我们方向信息。使用这个方向信息，我们使用 `rotateBitmap()` 函数相应地旋转我们的位图。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For implementation of the `rotateBitmap()` function, refer to the code bundle
    that accompanies this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`rotateBitmap()`函数的实现，请参考本书附带的代码包。
- en: 'After correcting the orientation, we make two copies of the bitmap: one to
    store the original image (`originalBitmap`) and the other one to store the processed
    bitmaps (`currentBitmap`), that is, to store the outputs of different algorithms
    applied to the original bitmap. The only part left is to display the image on
    the screen. Create a new function `loadImageToView()` and add the following lines
    to it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在纠正方向后，我们创建两个位图的副本：一个用于存储原始图像（`originalBitmap`），另一个用于存储处理过的位图（`currentBitmap`），即存储应用于原始位图的不同算法的输出。剩下的唯一部分是将图像显示在屏幕上。创建一个新的函数`loadImageToView()`，并向其中添加以下行：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line creates an instance of `ImageView` and the second line sets that
    image onto the view. Simple!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个`ImageView`实例，第二行将图像设置到视图中。很简单！
- en: 'One last thing and our application is ready! Since our application is going
    to read data from permanent storage (read images from external storage), we need
    permission. To the `AndroidManifest.xml` file, add the following lines that will
    allow the application to access external storage for reading data:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情，我们的应用程序就准备好了！由于我们的应用程序将要从永久存储中读取数据（从外部存储读取图像），我们需要权限。在`AndroidManifest.xml`文件中添加以下行，这将允许应用程序访问外部存储以读取数据：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have our basic application in place, let's take a look at the different
    feature detection algorithms, starting with Edge and Corner detection, Hough transformation,
    and Contours.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基本的应用程序，让我们来看看不同的特征检测算法，从边缘和角点检测、霍夫变换和轮廓开始。
- en: Edge and Corner detection
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘和角点检测
- en: Edge detection and Corner detection are two of the most basic feature detection
    algorithms, and are very useful ones too. Having information about the edges in
    an image can be of great help in applications, where you want to find boundaries
    of different objects in an image, or you need to find corners in an image when
    you want to analyze how an object rotates or moves in a given sequence of images
    (or videos). In this section, we will take a look at the techniques and implementations
    of various Edge and Corner detection algorithms, such as Difference of Gaussian,
    Canny Edge detector, Sobel Operator, and Harris Corners.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘检测和角点检测是两种最基本的特征检测算法，也是非常有用的算法。了解图像中的边缘信息在许多应用中非常有帮助，在这些应用中，你想要找到图像中不同对象的边界，或者当你想要分析对象在给定的一系列图像（或视频）中的旋转或移动时，你需要找到图像中的角点。在本节中，我们将探讨各种边缘和角点检测算法的技术和实现，例如高斯差分、Canny边缘检测器、Sobel算子和Harris角点。
- en: The Difference of Gaussian technique
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高斯差分技术
- en: Let's start with the easiest and the most rudimentary technique. Before we understand
    how **Difference of Gaussian** (**DoG**) works, let's take a look at what exactly
    edges are. To put it simply, edges are points in an image where the pixel intensity
    changes appreciably. We will exploit this property of edges and by applying Gaussian
    blur on the image, we will compute the edge points (Edges).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单和最基本的技术开始。在我们理解**高斯差分**（**DoG**）是如何工作的之前，让我们看看边缘究竟是什么。简单来说，边缘是图像中像素强度发生显著变化的点。我们将利用边缘的这一特性，通过对图像应用高斯模糊，来计算边缘点（边缘）。
- en: 'Here is a three-step explanation of the algorithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对算法的三个步骤的解释：
- en: Convert the given image to a grayscale image.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将给定的图像转换为灰度图像。
- en: On the grayscale image, perform Gaussian blur using two different blurring radiuses
    (you should have two Gaussian blurred images after this step).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在灰度图像上，使用两个不同的模糊半径进行高斯模糊（在此步骤之后，你应该有两个高斯模糊后的图像）。
- en: Subtract (arithmetic subtraction) the two images generated in the previous step
    to get the resultant image with only edge points (Edges) in it.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一步生成的两个图像中减去（算术减法）以获得只包含边缘点（边缘）的结果图像。
- en: Why does this technique work? How can subtracting two Gaussian blurred images
    give us edge points? A Gaussian filter is used to smooth out an image and the
    extent of smoothening depends on the blurring radius. Consider an image of a chess
    board. When you apply a Gaussian filter to the chess board image, you will observe
    that there is almost no change near the center of the white and black squares,
    whereas the common side of the black and white squares (which is an edge point)
    gets smudged, implying loss of edge information. Gaussian blur makes the edge
    less prominent.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这种技术有效？减去两个高斯模糊图像是如何给我们边缘点的？高斯滤波器用于平滑图像，平滑的程度取决于模糊半径。考虑一个棋盘图像。当你对棋盘图像应用高斯滤波器时，你会观察到在白色和黑色方块的中央几乎没有变化，而黑白方块的公共边（即边缘点）会变得模糊，这意味着边缘信息的丢失。高斯模糊使边缘不那么突出。
- en: According to our technique, we have two Gaussian blurred images with different
    blurring radius. When you subtract these two images, you will lose all the points
    where no smoothening or smudging happened, that is, the center of the black and
    white squares in the case of a chess board image. However, pixel values near the
    edges would have changed because smudging pixel values and subtracting such points
    will give us a non-zero value, indicating an edge point. Hence, you get edge points
    after subtracting two Gaussian blurred images.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的技术，我们有两个具有不同模糊半径的高斯模糊图像。当你从这两个图像中减去时，你会丢失所有没有平滑或模糊的点，即棋盘图像中黑白方块的中央。然而，边缘附近的像素值会发生变化，因为模糊像素值和减去这样的点将给我们一个非零值，这表明是一个边缘点。因此，通过减去两个高斯模糊图像，你得到了边缘点。
- en: Since we are only performing Gaussian blurs on images, it is one of the fastest
    ways of calculating edges. Having said that, it is also true that this technique
    does not return very promising results. This technique might work very well for
    some images and can completely fail in some scenarios. However, it doesn't hurt
    to know one extra algorithm!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只对图像执行高斯模糊，这是计算边缘最快的方法之一。话虽如此，这也确实是真的，这种技术并不总是能给出很有希望的结果。这种技术对于某些图像可能非常有效，但在某些场景中可能会完全失败。然而，了解一个额外的算法并不会有什么坏处！
- en: 'Let''s modify our Features App that we created in the last section and apply
    DoG to it. In the applications menu, we add a new menu option, *Difference of
    Gaussian*, to the menu resource XML file using these lines:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一节中创建的 Features App，并对其应用 DoG 技术。在应用程序菜单中，我们使用以下行在菜单资源 XML 文件中添加一个新的菜单选项，*高斯差分*：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Make a new function `public void DifferenceOfGaussian()`, which will compute
    edges in any given image, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的函数 `public void DifferenceOfGaussian()`，它将计算任何给定图像的边缘，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding piece of code, we first convert the image to a grayscale image.
    Then, we apply the Gaussian filter to the image twice, with two different blurring
    radiuses, using the `Imgproc.GaussianBlur()` function. The first and second parameters
    in this function are input and output images, respectively. The third parameter
    specifies the size of the kernel to be used while applying the filter, and the
    last parameter specifies the value of sigma used in the Gaussian function. Then
    we determine the absolute difference of the images using `Core.absdiff()`. Once
    this is done, we post-process our image to make it comprehensible by applying
    the *Inverse Binary Threshold* operation to set the edge point values to white
    (255). Finally, we convert the bitmap to Mat and display it on the screen using
    `loadImageToView()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先将图像转换为灰度图像。然后，我们使用 `Imgproc.GaussianBlur()` 函数对图像进行两次高斯滤波，使用两个不同的模糊半径。这个函数的前两个参数分别是输入和输出图像，第三个参数指定了应用滤波器时使用的核的大小，最后一个参数指定了高斯函数中使用的
    sigma 值。然后我们使用 `Core.absdiff()` 函数确定图像之间的绝对差异。完成这一步后，我们通过应用 *逆二值阈值* 操作来后处理我们的图像，将边缘点值设置为白色（255）。最后，我们使用
    `loadImageToView()` 函数将位图转换为 Mat 并在屏幕上显示。
- en: 'Here is the resulting image after applying DoG on Lenna:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是应用 DoG 技术到 Lenna 图像后的结果：
- en: '![The Difference of Gaussian technique](img/B02052_02_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![高斯差分技术](img/B02052_02_01.jpg)'
- en: Difference of Gaussian is not often used because it has been superseded by other
    more sophisticated techniques that we are going to discuss later in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯差分并不常用，因为它已经被我们将在本章后面讨论的更复杂的其他技术所取代。
- en: The Canny Edge detector
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Canny 边缘检测器
- en: Canny Edge detection is a widely used algorithm in computer vision and is often
    considered as an optimal technique for edge detection. The algorithm uses more
    sophisticated techniques than Difference of Gaussian, such as intensity gradient
    in multiple directions, and thresholding with hysteresis.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Canny边缘检测是计算机视觉中广泛使用的算法，通常被认为是边缘检测的最佳技术。该算法使用了比高斯差分更复杂的技巧，例如多方向上的强度梯度，以及具有阈值化的滞后效应。
- en: 'The algorithm is broadly divided into four stages:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 算法大致分为四个阶段：
- en: '**Smoothing the image**: This is the first step of the algorithm, where we
    reduce the amount of noise present in the image by performing a Gaussian blur
    with an appropriate blurring radius.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**平滑图像**：这是算法的第一步，通过执行适当的模糊半径的高斯模糊来减少图像中存在的噪声量。'
- en: '**Calculating the gradient of the image**: Here we calculate the intensity
    gradient of the image and classify the gradients as vertical, horizontal, or diagonal.
    The output of this step is used to calculate actual edges in the next stage.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**计算图像的梯度**：在这里，我们计算图像的强度梯度，并将梯度分类为垂直、水平或对角。这一步骤的输出用于在下一阶段计算实际边缘。'
- en: '**Non-maximal supression**: Using the direction of gradient calculated in the
    previous step, we check whether or not a pixel is the local maxima in the positive
    and negative direction of the gradient if not then, we suppress the pixel (which
    means that a pixel is not a part of any edge). This is an edge thinning technique.
    Select edge points with the sharpest change.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非最大抑制**：使用前一步计算的梯度方向，我们检查一个像素是否是梯度正负方向上的局部最大值，如果不是，则抑制该像素（这意味着像素不是任何边缘的一部分）。这是一种边缘细化技术。选择变化最剧烈的边缘点。'
- en: '**Edge selection through hysteresis thresholding**: This is the final step
    of the algorithm. Here we check whether an edge is strong enough to be included
    in the final output, essentially removing all the less prominent edges.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过阈值化选择边缘**：这是算法的最终步骤。在这里，我们检查一个边缘是否足够强，可以包含在最终输出中，本质上移除所有不太显著的边缘。'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Refer to [http://en.wikipedia.org/wiki/Canny_edge_detector](http://en.wikipedia.org/wiki/Canny_edge_detector)
    for a more detailed explanation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下链接以获取更详细的解释：[http://en.wikipedia.org/wiki/Canny_edge_detector](http://en.wikipedia.org/wiki/Canny_edge_detector)。
- en: The following is an implementation of the algorithm using OpenCV for Android.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是使用OpenCV for Android实现的算法。
- en: 'For Difference of Gaussian, first add the *Canny Edges* option to the application
    menu by adding a new item in the menu resource XML file, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高斯差分，首先通过在菜单资源XML文件中添加一个新项将`Canny Edges`选项添加到应用程序菜单中，如下所示：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new function, `public void Canny()`, and add the following lines of
    code to it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的函数`public void Canny()`，并将以下代码行添加到其中：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we first convert our image to a grayscale image, and
    then simply call the `Imgproc.Canny()` function implemented in the OpenCV API
    for Android. The important thing to notice here are the last two parameters in
    `Imgproc.Canny()`. They are for low and high thresholds respectively. In Canny
    Edge detection algorithm, we classify each point in the image into one of three
    classes, `suppressed points`, `weak edge points`, and `strong edge points`. All
    the points that have the intensity gradient value less than the low threshold
    values are classified as suppressed points, points with the intensity gradient
    value between low and high threshold values are classified as weak edge points,
    and points with the intensity gradient value above the high threshold values are
    classified as strong edge points.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先将图像转换为灰度图像，然后简单地调用OpenCV API for Android中实现的`Imgproc.Canny()`函数。这里需要注意的重要事项是`Imgproc.Canny()`函数中的最后两个参数。它们分别代表低阈值和高阈值。在Canny边缘检测算法中，我们将图像中的每个点分类为三类之一，即`抑制点`、`弱边缘点`和`强边缘点`。所有强度梯度值低于低阈值值的点被分类为抑制点，强度梯度值在低阈值和高阈值之间的点被分类为弱边缘点，强度梯度值高于高阈值值的点被分类为强边缘点。
- en: According to the algorithm, we ignore all the suppressed points. They will not
    be a part of any edge in the image. Strong edge points definitely form a part
    of an edge. For weak edge points, we check whether they are connected to any strong
    edge points in the image by checking the eight pixels around that weak point.
    If there are any strong edge points in those eight pixels, we count that weak
    point as a part of the edge. That's Canny Edge detection!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据算法，我们忽略所有被抑制的点。它们不会成为图像中任何边缘的一部分。强边缘点肯定构成边缘的一部分。对于弱边缘点，我们检查它们是否通过检查该弱点周围的八个像素与图像中的任何强边缘点相连。如果那些八个像素中有任何强边缘点，我们将那个弱点计为边缘的一部分。这就是Canny边缘检测！
- en: The Sobel operator
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sobel算子
- en: 'Another technique for computing edges in an image is using the Sobel operator
    (or Sobel filter). As in Canny Edge detection, we calculate the intensity gradient
    of the pixel, but in a different way. Here we calculate the approximate intensity
    gradient by convoluting the image with two 3x3 kernels for horizontal and vertical
    directions each:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 计算图像边缘的另一种技术是使用Sobel算子（或Sobel滤波器）。与Canny边缘检测类似，我们计算像素的强度梯度，但方式不同。在这里，我们通过使用两个3x3核（水平和垂直方向各一个）对图像进行卷积来计算近似强度梯度：
- en: '![The Sobel operator](img/B02052_02_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Sobel算子](img/B02052_02_02.jpg)'
- en: Convolution matrices used in Sobel filter
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Sobel滤波器中使用的卷积矩阵
- en: 'Using the horizontal and vertical gradient values, we calculate the absolute
    gradient at each pixel using this formula:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用水平和垂直梯度值，我们使用此公式计算每个像素的绝对梯度：
- en: '![The Sobel operator](img/B02052_02_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Sobel算子](img/B02052_02_03.jpg)'
- en: 'For an approximate gradient, the following formula is usually used:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于近似梯度，通常使用以下公式：
- en: '![The Sobel operator](img/B02052_02_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Sobel算子](img/B02052_02_04.jpg)'
- en: 'The steps involved in computing edges using a Sobel operator are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Sobel算子计算边缘的步骤如下：
- en: Convert the image to a grayscale image.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像转换为灰度图像。
- en: Calculate the absolute value of the intensity gradient in the horizontal direction.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算水平方向上的强度梯度的绝对值。
- en: Calculate the absolute value of the intensity gradient in the vertical direction.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算垂直方向上的强度梯度的绝对值。
- en: Compute the resultant gradient using the preceding formula. The resultant gradient
    values are essentially the edges.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的公式计算结果梯度。结果梯度值基本上是边缘。
- en: 'Let''s now add a Sobel filter to our Features App. Start by adding a *Sobel
    filter* menu option in the menu''s XML file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将Sobel滤波器添加到我们的Features App中。首先在菜单的XML文件中添加一个*Sobel滤波器*菜单选项：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is a Sobel filter using OpenCV for Android:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Android OpenCV中使用的Sobel滤波器：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this code, we first convert the image to a grayscale image. After this,
    using the grayscale image, we calculate the intensity gradient in the horizontal
    and vertical directions using the `Imgproc.Sobel()` function, and store the output
    in `grad_x` and `grad_y`. As per the formula mentioned in the algorithm, we calculate
    the absolute value of the gradients and add them together to get the resultant
    gradient value (basically the edges). The following code snippet performs the
    described step:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先将图像转换为灰度图像。之后，使用灰度图像，我们使用`Imgproc.Sobel()`函数计算水平和垂直方向上的强度梯度，并将输出存储在`grad_x`和`grad_y`中。根据算法中提到的公式，我们计算梯度的绝对值并将它们相加以获得结果梯度值（基本上是边缘）。以下代码片段执行了描述的步骤：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, we convert the Mat into a bitmap and display it on the screen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将Mat转换为位图并在屏幕上显示。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may also be interested to take a look at the Prewitt operator ([http://en.wikipedia.org/wiki/Prewitt_operator](http://en.wikipedia.org/wiki/Prewitt_operator)).
    It is similar to a Sobel operator, but uses a different matrix for convolution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还感兴趣查看Prewitt算子（[http://en.wikipedia.org/wiki/Prewitt_operator](http://en.wikipedia.org/wiki/Prewitt_operator)）。它与Sobel算子类似，但使用不同的矩阵进行卷积。
- en: Harris Corner detection
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Harris角点检测
- en: In the literal sense of the term, corners are points of intersection of two
    edges or a point which has multiple prominent edge directions in its local neighborhood.
    Corners are often considered as points of interest in an image and are used in
    many applications, ranging from image correlation, video stabilization, 3D modelling,
    and the likes. Harris Corner detection is one of the most used techniques in corner
    detection; and in this section, we will take a look at how to implement it on
    an Android platform.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个术语的字面意义上，角点是两条边或一个在其局部邻域内有多个显著边缘方向的点的交点。角点通常被视为图像中的兴趣点，并被用于许多应用，从图像相关性、视频稳定化、3D建模等。Harris角点检测是角点检测中最常用的技术之一；在本节中，我们将探讨如何在Android平台上实现它。
- en: 'Harris corner detector uses a sliding window over the image to calculate the
    variation in intensity. Since corners will have large variations in the intensity
    values around them, we are looking for positions in the image where the sliding
    windows show large variations in intensity. We try to maximize the following term:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Harris角点检测器在图像上使用滑动窗口来计算强度变化。由于角点周围的强度值变化很大，我们正在寻找图像中滑动窗口显示强度变化大的位置。我们试图最大化以下项：
- en: '![Harris Corner detection](img/B02052_02_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Harris角点检测](img/B02052_02_07.jpg)'
- en: Here, **I** is the image, **u** is the shift in the sliding window in the horizontal
    direction, and **v** is the shift in the vertical direction.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**I**是图像，**u**是滑动窗口在水平方向上的位移，**v**是滑动窗口在垂直方向上的位移。
- en: 'The following is an implementation of Harris Corner using OpenCV:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用OpenCV实现的Harris角点检测的示例：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we start off by converting the image to a grayscale image
    and then use it as an input to the `Imgproc.cornerHarris()` function. The other
    inputs to the function are the block size, kernel size, and a parameter, `k`,
    that is used to solve one of the equations in the algorithm (for details on mathematics,
    refer to OpenCV's documentation on Harris Corner at [http://docs.opencv.org/doc/tutorials/features2d/trackingmotion/harris_detector/harris_detector.html](http://docs.opencv.org/doc/tutorials/features2d/trackingmotion/harris_detector/harris_detector.html)).
    The output of Harris Corner is a 16-bit scalar image, which is normalized to get
    the pixel values in the range 0 to 255\. After this, we run a `for` loop and draw
    all the circles on the image with the centers being points whose intensity value
    is greater than a certain user set threshold.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先将图像转换为灰度图像，然后将其作为`Imgproc.cornerHarris()`函数的输入。函数的其他输入是块大小、核大小以及一个参数`k`，它用于解决算法中的一个方程（有关数学细节，请参阅OpenCV关于Harris角点的文档[http://docs.opencv.org/doc/tutorials/features2d/trackingmotion/harris_detector/harris_detector.html](http://docs.opencv.org/doc/tutorials/features2d/trackingmotion/harris_detector/harris_detector.html)）。Harris角点的输出是一个16位标量图像，它被归一化以获得0到255范围内的像素值。之后，我们运行一个`for`循环，并在图像上绘制所有圆，这些圆的中心是强度值大于某个用户设定的阈值的点。
- en: Hough transformations
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 霍夫变换
- en: So far, we looked at how to detect edges and corners in an image. Sometimes,
    for image analysis apart from edges and corners, you want to detect shapes, such
    as lines, circles, ellipses, or any other shape for that matter. Say for example,
    you want to detect coins in an image, or you want to detect a box or a grid in
    an image. A technique that comes handy in such scenarios is Hough transformations.
    It is a widely used technique that detects shapes in an image using their mathematical
    equations in their parameterized forms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何在图像中检测边缘和角点。有时，除了边缘和角点之外，进行图像分析时，你还想检测形状，如直线、圆、椭圆或任何其他形状。比如说，你想要在图像中检测硬币，或者你想要在图像中检测一个盒子或网格。在这种情况下，一个很有用的技术是霍夫变换。它是一种广泛使用的技术，通过使用它们的参数化形式中的数学方程来检测图像中的形状。
- en: The generalized Hough transformation is capable of detecting any shape for which
    we can provide an equation in the parameterized form. As the shapes start getting
    complex (with an increase in the number of dimensions), such as spheres or ellipsoids,
    it gets computationally expensive; hence, we generally look at standard Hough
    transformations for simple 2D shapes, such as lines and circles.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 广义霍夫变换能够检测任何我们可以提供参数化形式的方程的形状。当形状开始变得复杂（维度增加）时，例如球体或椭球体，计算量会变得很大；因此，我们通常考虑标准霍夫变换来处理简单的二维形状，如直线和圆。
- en: In this section, we will take a look at Hough transformations to detect lines
    and circles, but as mentioned earlier, it can be further extended to detect shapes,
    such as ellipses, and even simple 3D shapes, such as spheres.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨霍夫变换以检测线和圆，但如前所述，它可以进一步扩展以检测形状，例如椭圆，甚至简单的三维形状，例如球体。
- en: Hough lines
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 霍夫线
- en: 'Detecting lines is one of the simplest use cases of Hough transformations.
    In Hough lines, we select a pair of points from our image *(x1, y1)* and *(x2,
    y2)*, and solve the following pair of equations for *(a, m)*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 检测线是霍夫变换的最简单用例之一。在霍夫线中，我们从图像中选择一对点 *(x1, y1)* 和 *(x2, y2)*，并解以下方程组以得到 *(a, m)*：
- en: '*y1 = m(x1) + a*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*y1 = m(x1) + a*'
- en: '*y2 = m(x2) + a*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*y2 = m(x2) + a*'
- en: We maintain a table with two columns *(a, m)* and a count value. The count value
    keeps a record of how many times we get the *(a, m)* value after solving the preceding
    pair of equations. This is nothing but a voting procedure. After calculating the
    *(a, m)* values for all possible pairs of points, we take the *(a, m)* values
    that have count values greater than a certain threshold and these values are the
    desired lines in the image.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们维护一个包含两列 *(a, m)* 和一个计数值的表格。计数值记录了解决前一对方程后我们得到多少次 *(a, m)* 值。这实际上就是一个投票过程。计算了所有可能点对的所有可能的
    *(a, m)* 值后，我们选取计数值大于某个阈值的 *(a, m)* 值，这些值就是图像中期望的线。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For Hough transformations, we never run the algorithm directly on the image.
    First, we compute the edges in the image, and then apply the Hough transformation
    on the edges. The reason being, any prominent line in the image has to be an edge
    (the reverse is not true, every edge in the image will not be a line), and using
    only edges, we are reducing the number of points on which the algorithm runs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于霍夫变换，我们从不直接在图像上运行算法。首先，我们在图像中计算边缘，然后对边缘应用霍夫变换。原因在于，图像中的任何突出线都必须是边缘（反之则不然，图像中的每个边缘都不一定是线），仅使用边缘，我们减少了算法运行的点数。
- en: 'OpenCV provides two implementations of Hough lines: standard Hough lines and
    probabilistic Hough lines. The major difference between the two is that, in probabilistic
    Hough lines, instead of using all edge points, we select a subset of the edge
    points by random sampling. This makes the algorithm run faster since there are
    fewer points to deal with, without compromising on its performance.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了两种霍夫线的实现：标准霍夫线和概率霍夫线。两者之间的主要区别在于，在概率霍夫线中，我们不是使用所有边缘点，而是通过随机采样选择边缘点的一个子集。这使得算法运行得更快，因为要处理的数据点更少，而不会影响其性能。
- en: Time to write some code! First things first, add a new *Hough lines* menu option
    to our application menu. However, try to figure out the code to do this yourself
    this time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候写一些代码了！首先，在我们的应用程序菜单中添加一个新的 *霍夫线* 菜单选项。然而，这次尽量自己找出实现这个功能的代码。
- en: 'Hopefully, the menu option is now in place! Let''s now take a look at a code
    snippet that uses the probabilistic Hough transformation to detect lines in an
    image using OpenCV for Android:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在菜单选项已经到位！现在让我们看看一个使用概率霍夫变换在图像中检测线的代码片段，使用 OpenCV for Android：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As explained earlier, we first compute edges in the image using any edge detection
    technique (the preceding code uses Canny). The output of the Canny Edge detector
    is used as an input to the `Imgproc.HoughLinesP()` function. The first and second
    parameters are input and output respectively. The third and fourth parameters
    specify the resolution of `r` and theta in pixels. The next two parameters are
    the threshold and minimum number of points that a line should have. Lines with
    fewer points than this are discarded.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们首先使用任何边缘检测技术（前面的代码使用 Canny）在图像中计算边缘。Canny 边缘检测器的输出被用作 `Imgproc.HoughLinesP()`
    函数的输入。前两个参数分别是输入和输出。第三个和第四个参数指定了像素中的 `r` 和 theta 的分辨率。接下来的两个参数是线的阈值和线应具有的最小点数。少于这个点数的线将被丢弃。
- en: The `For` loop in the code is used to draw all the lines on the image. This
    is only done to visualize the lines detected by the algorithm.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的 `For` 循环用于在图像上绘制所有线。这只是为了可视化算法检测到的线。
- en: Hough circles
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 霍夫圆
- en: Analogous to Hough lines, Hough circles also follow the same procedure to detect
    circles, only the equations change (the parameterized form of a circle is used
    instead).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与霍夫线类似，霍夫圆也遵循相同的程序来检测圆，只是方程有所变化（使用圆的参数化形式）。
- en: 'Here is an implementation of Hough circles using OpenCV for Android:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 OpenCV for Android 实现霍夫圆的示例：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code is pretty much the same as Hough lines with a few changes. The output
    of `Imgproc.HoughCircles()` is a tuple of center coordinates and the radius of
    the circle (x, y, radius). To draw circles on the image, we use `Core.circle()`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码基本上与霍夫线相同，只有一些改动。`Imgproc.HoughCircles()`的输出是一个包含圆心坐标和半径的元组（x, y, radius）。要在图像上绘制圆，我们使用`Core.circle()`。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A nice coding exercise would be to implement Hough lines/circles without using
    the predefined OpenCV functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不错的编码练习是实现霍夫线/圆，而不使用预定义的OpenCV函数。
- en: Contours
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮廓
- en: We are often required to break down the image into smaller segments to have
    a more focused view of the object of interest. Say for instance, you have an image
    with balls from different sports, such as a golf ball, cricket ball, tennis ball,
    and football. However, you are only interested in analyzing the football. One
    way of doing this could be by using Hough circles that we looked at in the last
    section. Another way of doing this is using contour detection to segment the image
    into smaller parts, with each segment representing a particular ball.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要将图像分解成更小的部分，以便更专注于感兴趣的对象。比如说，你有一个包含不同运动球类的图像，如高尔夫球、板球、网球和足球。然而，你只对分析足球感兴趣。一种方法是在上一节中我们提到的霍夫圆中进行操作。另一种方法是使用轮廓检测将图像分割成更小的部分，每个部分代表一个特定的球。
- en: The next step is to choose the segment having the largest area, that is, your
    football (it is safe to assume that the football would be the largest of all!).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择面积最大的部分，即你的足球（可以安全地假设足球是最大的！）。
- en: Contours are nothing but connected curves in an image or boundaries of connected
    components in an image. Contours are often computed using edges in an image, but
    a subtle difference between edges and contours is that contours are closed, whereas
    edges can be anything. The concept of edges is very local to the point and its
    neighboring pixels; however, contours take care of the object as a whole (they
    return boundaries of objects).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 轮廓不过是图像中的连接曲线或连接组件的边界。轮廓通常通过图像中的边缘来计算，但边缘和轮廓之间有一个细微的区别：轮廓是封闭的，而边缘可以是任何东西。边缘的概念非常局部，与点及其邻近像素相关；然而，轮廓关注的是整个对象（它们返回对象的边界）。
- en: 'Let''s take a look at the implementation of Contour detection using OpenCV
    for Android. Let''s take a look at the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用OpenCV在Android上实现轮廓检测的实现。让我们看看以下代码：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: OpenCV does make our life simple! In this code, we first convert our image to
    a grayscale image (it is not necessary to use the grayscale version of the image,
    you can directly work with colored images as well), and then find edges in it
    using Canny Edge detection. After we have the edges with us, we pass this image
    to a predefined function `Imgproc.findContours()`. The output of this function
    is `List<MatOfPoint>` which stores all the contours computed in that image. The
    parameters passed in to the `Imgproc.findContours()` function are interesting.
    The first and the second parameters are the input images and list of contours
    respectively. The third and the fourth parameters are interesting; they give the
    hierarchy of contours in the image. The third parameter stores the hierarchy,
    while the fourth parameter specifies the nature of hierarchy the users want. The
    hierarchy essentially tells us the overall arrangement of contours in the image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV确实让我们的工作变得简单！在这段代码中，我们首先将图像转换为灰度图像（使用图像的灰度版本不是必需的，你也可以直接处理彩色图像），然后使用Canny边缘检测找到其中的边缘。在我们有了边缘之后，我们将此图像传递给预定义的函数`Imgproc.findContours()`。该函数的输出是`List<MatOfPoint>`，它存储了在该图像中计算出的所有轮廓。传递给`Imgproc.findContours()`函数的参数很有趣。第一个和第二个参数是输入图像和轮廓列表。第三个和第四个参数很有趣；它们给出了图像中轮廓的层次结构。第三个参数存储层次结构，而第四个参数指定用户想要的层次结构性质。层次结构本质上告诉我们图像中轮廓的整体排列。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Refer to [http://docs.opencv.org/master/d9/d8b/tutorial_py_contours_hierarchy.html](http://docs.opencv.org/master/d9/d8b/tutorial_py_contours_hierarchy.html)
    for a detailed explanation of hierarchies in Contours.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[http://docs.opencv.org/master/d9/d8b/tutorial_py_contours_hierarchy.html](http://docs.opencv.org/master/d9/d8b/tutorial_py_contours_hierarchy.html)以获取轮廓层次结构的详细解释。
- en: 'The `for` loop in the code is used to draw contours on a new image. The `Imgproc.drawContours()`
    function draws the contours on the image. In this function, the first parameter
    is a Mat, for where you want to draw the contours. The second parameter is the
    list of contours returned by `Imgproc.findContours()`. The third parameter is
    the index of the contour that we want to draw, and the fourth parameter is the
    color to be used to draw the contour. While drawing contours, you have two options:
    either you draw the boundary of the contour or you fill the entire contour. The
    fifth parameter in the function helps you to specify your choice. A negative value
    means you need to fill the entire contour, whereas any positive value specifies
    the thickness of the boundary.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的 `for` 循环用于在新的图像上绘制轮廓。`Imgproc.drawContours()` 函数在图像上绘制轮廓。在这个函数中，第一个参数是一个
    Mat，表示你想要绘制轮廓的位置。第二个参数是 `Imgproc.findContours()` 返回的轮廓列表。第三个参数是我们想要绘制的轮廓的索引，第四个参数是用于绘制轮廓的颜色。在绘制轮廓时，你有两种选择：要么绘制轮廓的边界，要么填充整个轮廓。函数中的第五个参数帮助你指定你的选择。负值表示你需要填充整个轮廓，而任何正值指定边界的厚度。
- en: Finally, convert `Mat` to `Bitmap` and display it on the screen.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `Mat` 转换为 `Bitmap` 并在屏幕上显示。
- en: With contour detection, we successfully completed our Features App.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过轮廓检测，我们成功完成了我们的特征应用程序。
- en: Project – detecting a Sudoku puzzle in an image
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 – 在图像中检测数独谜题
- en: Let's try to apply our learning from this chapter and create a simple application
    for detecting a Sudoku grid in an image. You see Sudoku puzzles every day in newspapers
    or magazines; sometimes they provide a solution and sometimes they don't. Why
    not build an application for your mobile phone that can click a picture of the
    Sudoku, analyze the numbers, run some intelligent algorithms to solve the puzzle,
    and within seconds, you have the solution on your mobile screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试应用本章所学，创建一个检测图像中数独网格的简单应用程序。你每天都在报纸或杂志上看到数独谜题；有时它们提供解决方案，有时则不提供。为什么不为你自己的手机开发一个应用程序，可以点击数独的照片，分析数字，运行一些智能算法来解决谜题，并在几秒钟内，你就可以在手机屏幕上看到解决方案。
- en: After reading this chapter, we can easily work on the first part of the application;
    that is, localizing (detecting) the Sudoku grid from an image. As you read through
    this book, you will come across algorithms and techniques that will help you build
    the other parts of this application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，我们可以轻松地处理应用程序的第一部分；即从图像中定位（检测）数独网格。随着你阅读这本书，你会遇到一些算法和技术，这些将帮助你构建这个应用程序的其他部分。
- en: 'Let''s break down our problem statement into subproblems and work each one
    out to have a fully functioning Sudoku localizing application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的问题陈述分解成子问题，并逐一解决，以拥有一个完全功能的数独定位应用程序：
- en: Capture the image using a camera or load it from your gallery.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相机捕获图像或从你的相册中加载它。
- en: Preprocess the image by running your favorite edge detection algorithm.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您喜欢的边缘检测算法对图像进行预处理。
- en: Find a rectangular grid in the image. The possible options are to use Hough
    lines to detect lines and then look for four lines that form a rectangle (a little
    tedious), or find contours in the image and assume the largest contours in your
    image to be the Sudoku grid that you were looking for (the assumption made here
    is safe providing you click or load a picture that focuses on the grid more than
    anything else).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像中找到一个矩形网格。可能的选项是使用霍夫线检测线条，然后寻找形成矩形的四条线（有点繁琐），或者找到图像中的轮廓，并假设图像中最大的轮廓是你正在寻找的数独网格（这里做出的假设是安全的，只要你点击或加载的图片比其他任何东西都更专注于网格）。
- en: After you have narrowed down on the grid, create a new image and copy only the
    contour region to the new image.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缩小到网格后，创建一个新的图像，并将仅轮廓区域复制到新图像中。
- en: You have successfully detected the Sudoku grid!
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经成功检测到数独网格了！
- en: 'Here is a sample image with a Sudoku grid in it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个包含数独网格的示例图像：
- en: '![Project – detecting a Sudoku puzzle in an image](img/B02052_02_05.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![项目 – 在图像中检测数独谜题](img/B02052_02_05.jpg)'
- en: 'Here is the narrowed down grid:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是缩小后的网格：
- en: '![Project – detecting a Sudoku puzzle in an image](img/B02052_02_06.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![项目 – 在图像中检测数独谜题](img/B02052_02_06.jpg)'
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This chapter covers everything that one should know about in order to create
    this application. Once you have tried doing it by yourself, you can download the
    code from the Packt Publishing website.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了创建此应用程序所需了解的所有内容。一旦你自己尝试过，你就可以从 Packt Publishing 网站下载代码。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learnt about some basic features in images, such as
    edges, corners, lines, and circles. We have looked at different algorithms, such
    as Canny Edge detection and Harris corners, that can be implemented on an Android
    device. These are the basic set of algorithms that will come handy in many applications
    that we are going to build in the coming chapters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了图像的一些基本特征，例如边缘、角点、线条和圆。我们探讨了不同的算法，如Canny边缘检测和Harris角点检测，这些算法可以在Android设备上实现。这些是我们在接下来的章节中将要构建的许多应用中非常有用的基本算法集。
