- en: Getting Started with OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用OpenCV
- en: In the previous chapter, we were presented with an introduction to computer
    vision, with some examples of the industries that use it extensively to improve
    their services and products. Then, we learned about the most basic concepts used
    in this field, such as images and pixels. We learned about color spaces and finished
    the chapter with a brief discussion of computer vision libraries and frameworks.
    We're going to continue from where we left off, which is with introducing you
    to one of the most powerful and widely used computer vision libraries, called
    **OpenCV**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了计算机视觉的基础知识，并展示了某些行业如何广泛使用它来改善他们的服务和产品。然后，我们学习了该领域最基本的概念，例如图像和像素。我们了解了色彩空间，并在本章结束时简要讨论了计算机视觉库和框架。我们将从上次结束的地方继续，即向您介绍最强大和最广泛使用的计算机视觉库之一，称为**OpenCV**。
- en: OpenCV is a huge collection of classes, functions, modules, and other related
    resources used to build cross-platform computer vision applications. In this chapter,
    we will learn about the structure of OpenCV, the modules that it contains and
    their purposes, and the programming languages that it supports. We will learn
    how and where to get OpenCV and briefly go through the possible tools you can
    use to build applications with it. Then, we'll learn how to use the power of CMake
    to easily create projects that use OpenCV. Even though this means that our main
    focus will be on C++ classes and functions, we'll also cover Python equivalents
    of them wherever it makes sense so that developers familiar with both languages
    can follow the topics that are presented here in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV是一个庞大的类、函数、模块和其他相关资源的集合，用于构建跨平台的计算机视觉应用程序。在本章中，我们将了解OpenCV的结构，它包含的模块及其用途，以及它支持的编程语言。我们将学习如何获取OpenCV，并简要介绍您可以使用它来构建应用程序的可能工具。然后，我们将学习如何使用CMake的强大功能轻松创建使用OpenCV的项目。尽管这意味着我们的主要焦点将是C++类和函数，但
    wherever it makes sense，我们也会涵盖它们的Python等价物，以便熟悉这两种语言的开发者可以跟随本章中介绍的主题。
- en: After learning about the initial stages of using the OpenCV library, we'll move
    on to learn about the `Mat` class. We'll see how all of the concepts that we covered
    in the previous chapter about images are embedded into the structure of the `Mat`
    class in OpenCV. We'll also talk about the various other classes that are compatible
    with (or closely related to) the `Mat` class. OpenCV's method of handling input
    and output parameters in its functions is a very important subject that we'll
    be covering in the later sections of this chapter. Finally, we'll learn how OpenCV
    is used to apply the three steps of input, process, and output in computer vision
    applications. This will require learning about accessing (and writing into) images
    and video files using OpenCV.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了使用OpenCV库的初始阶段之后，我们将继续学习`Mat`类。我们将看到上一章中关于图像的所有概念是如何嵌入到OpenCV中`Mat`类的结构中的。我们还将讨论与`Mat`类兼容（或与之密切相关）的其他各种类。OpenCV在函数中处理输入和输出参数的方法是本章后面部分将要讨论的一个重要主题。最后，我们将学习如何使用OpenCV在计算机视觉应用程序中应用输入、处理和输出的三个步骤。这需要学习使用OpenCV访问（并将数据写入）图像和视频文件。
- en: This chapter, as a direct connection to the previous introductory chapter, will
    lay out the foundations of learning computer vision algorithms using hands-on
    and practical examples.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为对上一章入门章节的直接衔接，将阐述使用动手和实践示例学习计算机视觉算法的基础。
- en: 'In this chapter, we''ll look at the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: What OpenCV is, where to get it, and how to use it?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV是什么，在哪里可以获取它，以及如何使用它？
- en: How to use CMake to create OpenCV projects?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用CMake创建OpenCV项目？
- en: Understanding the `Mat` class and how it is used to access pixels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`Mat`类及其如何用于访问像素
- en: How to use the `Mat_`, `Matx`, and `UMat` classes?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`Mat_`、`Matx`和`UMat`类？
- en: How to use the `imread` and `imwrite` functions to read and write images?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`imread`和`imwrite`函数读取和写入图像？
- en: How to use the `VideoCapture` and `VideoWriter` classes to read and write videos?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`VideoCapture`和`VideoWriter`类读取和写入视频？
- en: How to access cameras and video feeds from a network (using **Real Time Streaming
    Protocol** (**RTSP**))?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过网络（使用**实时流协议**（**RTSP**））访问摄像头和视频流？
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Microsoft Visual Studio, Xcode, or any IDE that can be used to develop C++ programs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio、Xcode或任何可以用于开发C++程序的IDE
- en: Visual Studio Code or any other code editor that can be used to edit CMake files,
    Python source files, and so on
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code 或任何其他可以用来编辑 CMake 文件、Python 源文件等的代码编辑器
- en: Python 3.X
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.X
- en: CMake 3.X
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.X
- en: OpenCV 3.X
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV 3.X
- en: It is always best to try to use a more recent version of the technologies and
    software that you are trying to learn. The topics covered in this book, and computer
    vision in general, are no exception, so make sure to download and install the
    latest versions of the mentioned software.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用您正在尝试学习的最新版本的技术和软件总是最好的。本书涵盖的主题，以及计算机视觉总体来说，也不例外，所以请确保下载并安装所提及软件的最新版本。
- en: 'Wherever necessary, a brief set of instructions are provided for the installation
    and configuration. You can use the following URL to download the source codes
    and examples for this chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在必要时，提供了一组简短的安装和配置说明。您可以使用以下 URL 下载本章的源代码和示例：
- en: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter02)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Algorithms-for-Computer-Vision/tree/master/Chapter02)'
- en: Introduction to OpenCV
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV 简介
- en: '**OpenCV**, or **Open Source Computer Vision**, is a set of libraries, tools,
    and modules that contain classes and functions required for building computer
    vision applications. Downloaded millions of times by computer vision developers
    around the world, the OpenCV library is fast and optimized to be used in real-life
    projects (including commercial). As of the time of writing this book, the most
    recent version of OpenCV is 3.4.1, which is also the version we''ll be using in
    all of the examples in this book. OpenCV supports the C/C++, Python, and Java
    languages, and it can be used to build computer vision applications for desktop
    and mobile operating systems alike, including Windows, Linux, macOS, Android,
    and iOS.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenCV**，或**开源计算机视觉**，是一组包含构建计算机视觉应用程序所需的类和函数的库、工具和模块。OpenCV 库被全球的计算机视觉开发者下载了数百万次，它速度快，经过优化，适用于现实生活中的项目（包括商业项目）。截至本书编写时，OpenCV
    的最新版本是 3.4.1，这也是本书所有示例中使用的版本。OpenCV 支持 C/C++、Python 和 Java 语言，并且可以用于构建适用于桌面和移动操作系统的计算机视觉应用程序，包括
    Windows、Linux、macOS、Android 和 iOS。'
- en: It's important to note that the OpenCV library and OpenCV framework are both
    used to refer to OpenCV, and in the computer vision community the terms are used
    interchangeably most of the time. For the same reason, we will also use the terms
    interchangeably throughout this book. However, strictly speaking, framework is
    usually the term that is used to refer to sets of related libraries and tools
    working toward achieving a common goal, such as OpenCV.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，OpenCV 库和 OpenCV 框架都用来指代 OpenCV，在计算机视觉社区中，这两个术语大多数时候是互换使用的。出于同样的原因，我们在这本书中也将互换使用这些术语。然而，严格来说，框架通常是指用于实现共同目标的关联库和工具集的术语，例如
    OpenCV。
- en: 'OpenCV consists of the following two types of modules:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 由以下两种类型的模块组成：
- en: '**Main modules**: These modules are included in OpenCV release versions by
    default, and they contain all of the core OpenCV functionality along with modules
    that are used for image-processing tasks, filtering, transformation, and many
    more capabilities that we''ll talk about in this section.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要模块**：这些模块默认包含在 OpenCV 发布版本中，它们包含了所有核心 OpenCV 功能以及用于图像处理任务、过滤、转换等更多功能的模块，我们将在本节中讨论这些功能。'
- en: '**Extra modules**: These modules include all of the OpenCV functionalities
    that are not included in the OpenCV library by default and they mostly include
    additional computer vision-related functionalities. For instance, the Extra modules
    include libraries used for text recognition and non-free feature detectors. Note
    that our focus will be on the Main module and covering the functionalities included
    in it but, wherever it might be helpful, we''ll try to also refer to possible
    options in the extra modules for you to research on your own.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外模块**：这些模块包括所有默认不包含在 OpenCV 库中的 OpenCV 功能，它们主要包含额外的计算机视觉相关功能。例如，额外模块包括用于文本识别和非自由特征检测器的库。请注意，我们的重点是主要模块，并涵盖其中的功能，但
    wherever 可能有所帮助，我们也会尝试提及额外模块中的可能选项，供您自行研究。'
- en: The Main modules in OpenCV
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV 中的主要模块
- en: 'As mentioned, OpenCV contains a number of Main modules that contain all of
    its core and default functionalities. Here is a list of those modules:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OpenCV包含多个主模块，其中包含其所有核心和默认功能。以下是这些模块的列表：
- en: '`core`: This contains all of the core OpenCV functionalities. For instance,
    all basic structures, including the `Mat` class (which we''ll learn about in detail
    later) and matrix operations are some of the functionalities embedded into this
    module.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core`: 此模块包含所有核心OpenCV功能。例如，所有基本结构，包括`Mat`类（我们将在后面详细学习）和矩阵运算，都是嵌入到这个模块中的功能之一。'
- en: '`imgproc`: This module contains all image-processing functionalities, such
    as filtering, transformations, and histograms.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imgproc`: 此模块包含所有图像处理功能，如滤波、变换和直方图。'
- en: '`imgcodecs`: This module includes functions that are used for reading and writing
    images.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imgcodecs`: 此模块包括用于读取和写入图像的函数。'
- en: '`videoio`: This is similar to the `imgcodecs` module, but this one is used
    to work with videos, as the name implies.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`videoio`: 此模块与`imgcodecs`模块类似，但根据其名称，它用于处理视频。'
- en: '`highgui`: This module, which we''ll use extensively throughout the book, contains
    all of the functionalities used for displaying results and GUI creation in general.
    Note that even though the `highgui` module is enough for the purpose of this book
    and learning about computer vision algorithms while visualizing the results as
    we move forward, it''s still not meant for full-scale applications. Refer to the
    *Further reading* section at the end of this chapter for more references about
    proper GUI creation tools for full-scale computer vision applications.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`highgui`: 本书将广泛使用此模块，它包含用于显示结果和创建GUI的所有功能。请注意，尽管`highgui`模块对于本书的目的以及在学习计算机视觉算法的同时可视化结果来说已经足够，但它并不适用于全面的应用。请参阅本章末尾的*进一步阅读*部分，以获取更多关于用于全面计算机视觉应用的正确GUI创建工具的参考资料。'
- en: '`video`: Contains video analysis functionalities of OpenCV, such as motion
    detection and tracking, the Kalman filter, and the infamous CAM Shift algorithm
    (used for object tracking).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`video`: 包含OpenCV的视频分析功能，如运动检测和跟踪、卡尔曼滤波以及臭名昭著的CAM Shift算法（用于对象跟踪）。'
- en: '`calib3d`: This module includes calibration and 3D reconstruction functionalities.
    A well-known example of the capabilities of this module is the estimation of transformation
    between two images.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calib3d`: 此模块包括校准和3D重建功能。此模块能力的知名示例是两个图像之间变换的估计。'
- en: '`features2d`: Supported keypoint-detection and descriptor-extraction algorithms
    are included in this module. As we''ll learn in the upcoming chapters, this module
    contains some of the most widely used object detection and categorization algorithms.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`features2d`: 此模块包含支持的关键点检测和描述符提取算法。正如我们将在即将到来的章节中学习的那样，此模块包含一些最广泛使用的对象检测和分类算法。'
- en: '`objdetect`: As the name implies, this module is used for object detection
    using OpenCV. We''ll learn about the functionalities contained within this module
    in the final chapters of this book.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objdetect`: 如其名所示，此模块用于使用OpenCV进行对象检测。我们将在本书的最后一章学习这个模块包含的功能。'
- en: '`dnn`: Similar to the `objdetect` module, this module is also used for object
    detection and classification purposes, among others. The `dnn` module is relatively
    new in the list of the Main modules of OpenCV, and it contains all of the capabilities
    related to deep learning.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnn`: 与`objdetect`模块类似，此模块也用于对象检测和分类等目的。`dnn`模块在OpenCV主模块列表中相对较新，它包含了与深度学习相关的所有功能。'
- en: '`ml`: This machine learning module contains the classes and functions used
    to handle classification and regression. Simply put, all strictly machine learning-related
    capabilities are included in this module.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ml`: 此机器学习模块包含用于处理分类和回归的类和函数。简单来说，所有严格相关的机器学习功能都包含在这个模块中。'
- en: '`flann`: This is OpenCV''s interface to **Fast Library for Approximate Nearest
    Neighbors** (**FLANN**). FLANN contains a wide set of optimized algorithms that
    are used to deal with the nearest neighbor search of high-dimensional features
    in large datasets. The algorithms mentioned here are mostly used in conjunction
    with algorithms in other modules, such as `features2d`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flann`: 这是OpenCV对**快速近似最近邻库**（**FLANN**）的接口。FLANN包含一套广泛的优化算法，用于处理大型数据集中高维特征的最近邻搜索。这里提到的算法大多与其他模块中的算法结合使用，例如`features2d`。'
- en: '`photo`: An interesting module for photography-related computer vision, it
    contains classes and functions that are used to deal with tasks such as denoising,
    HDR imaging, and restoring a region in a photo using its neighborhood.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`photo`：这是一个有趣的模块，用于处理与摄影相关的计算机视觉任务，它包含用于处理去噪、HDR 成像以及使用其邻域恢复照片区域的类和函数。'
- en: '`stitching`: This module contains classes and functions used for image stitching.
    Note that stitching in itself is a very complex task and it requires functions
    for rotation estimation and image warping, all of which are also part of this
    very interesting OpenCV module.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stitching`：此模块包含用于图像拼接的类和函数。请注意，拼接本身是一个非常复杂的任务，它需要旋转估计和图像扭曲等功能，所有这些也都是这个非常有趣的
    OpenCV 模块的一部分。'
- en: '`shape`: This module is used to deal with shape transformation, matching, and
    distance-related topics.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shape`：此模块用于处理形状变换、匹配和距离相关主题。'
- en: '`superres`: Algorithms that fall into the category of resolution enhancement
    are included in the super-resolution module.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`superres`：属于分辨率增强类别的算法包含在超分辨率模块中。'
- en: '`videostab`: This module contains algorithms used for video stabilization.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`videostab`：此模块包含用于视频稳定的算法。'
- en: '`viz`: Otherwise known as the 3D Visualizer module, it contains classes and
    functions that are used to deal with displaying widgets on the 3D visualization
    window. This module will not be part of the topics discussed in this book, but
    we''ll just mention it.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viz`：也称为 3D 可视化模块，它包含用于在 3D 可视化窗口上显示小部件的类和函数。此模块不会成为本书讨论的主题之一，但我们只是提一下。'
- en: Apart from the modules that we just covered, OpenCV also contains a number of
    Main modules that are based on CUDA (an API created by Nvidia). These modules
    are easily distinguished by their names, which start with the word `cuda`. Since
    the availability of these modules totally depends on a specific type of hardware,
    and almost all of the functionalities inside those modules are covered, one way
    or another, by other modules, we're going to skip them for now. But it's worth
    noting that using the OpenCV `cuda` modules can significantly improve the performance
    of your applications, provided that the algorithms you need are implemented in
    them, and that your hardware meets the minimum requirements for them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚刚提到的模块之外，OpenCV 还包含一些基于 CUDA（由 Nvidia 创建的 API）的主模块。这些模块很容易通过其名称区分，名称以单词
    `cuda` 开头。由于这些模块的可用性完全取决于特定类型的硬件，并且几乎所有这些模块中的功能都由其他模块以某种方式覆盖，我们现在将跳过它们。但值得注意的是，如果您需要的算法已经实现在这些模块中，并且您的硬件满足它们的最小要求，那么使用
    OpenCV 的 `cuda` 模块可以显著提高您应用程序的性能。
- en: Downloading and building/installing OpenCV
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和构建/安装 OpenCV
- en: 'OpenCV, for the most part, does not have a prebuilt and ready-to-use version
    (there are some exceptions we''ll cover in this section) and similar to most of
    the open source libraries, it needs to be configured and built from sources. In
    this section, we''ll quickly describe how OpenCV is built (and installed) on a
    computer. But first, you need to get the OpenCV source codes in your computer.
    You can use the following link for this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 大部分没有预构建和可直接使用的版本（本节中我们将讨论一些例外），类似于大多数开源库，它需要从源代码进行配置和构建。在本节中，我们将简要描述如何在计算机上构建（和安装）OpenCV。但首先，您需要将
    OpenCV 源代码获取到您的计算机上。您可以使用以下链接进行此操作：
- en: '[https://opencv.org/releases.html](https://opencv.org/releases.html)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://opencv.org/releases.html](https://opencv.org/releases.html)'
- en: On this page, you can find release versions of OpenCV. The latest version, as
    of the time of writing this book, is 3.4.1 so you should download it, or if there
    is a higher version then just go with that.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本页面上，您可以找到 OpenCV 的发布版本。截至本书编写时，最新版本是 3.4.1，因此您应该下载它，或者如果有更高版本，则直接使用那个版本。
- en: 'As seen in the following screenshot, for each version of the OpenCV release,
    there are various downloadable entries, such as the Win, iOS, and Android packs,
    but you should download Sources and build OpenCV yourself based on the platform
    you want to work with:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，对于 OpenCV 的每个发布版本，都有各种可下载条目，例如 Win、iOS 和 Android 套件，但您应该下载源代码并根据自己的平台自行构建
    OpenCV：
- en: '![](img/00013.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: OpenCV 3.4.1, by default, provides prebuilt versions of the Android, iOS, and
    64-bit MSVC14 and MSVC15 (the same as Microsoft Visual C++ 2015 and Microsoft
    Visual C++ 2017) libraries. So, if you want to build applications for any of these
    platforms, you can download the relevant pack and skip the OpenCV build process
    altogether.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 3.4.1 默认提供 Android、iOS 和 64 位 MSVC14 和 MSVC15（与 Microsoft Visual C++
    2015 和 Microsoft Visual C++ 2017 相同）库的预构建版本。因此，如果您想为这些平台中的任何一个构建应用程序，您可以下载相关的包并完全跳过
    OpenCV 的构建过程。
- en: 'To build OpenCV from sources, you need the following tools on your computer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要从源代码构建 OpenCV，您需要在您的计算机上安装以下工具：
- en: '**C/C++ compiler with C++11 support**: On Windows, this means any of the more
    recent Microsoft Visual C++ compilers, such as MSVC15 (2017) or MSVC14 (2015).
    On Linux operating systems, you can use an up-to-date GCC and, on macOS, you can
    use the command-line tools for Xcode that contain all the required tools.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持 C++11 的 C/C++ 编译器**：在 Windows 上，这意味着任何较新的 Microsoft Visual C++ 编译器，例如
    MSVC15（2017）或 MSVC14（2015）。在 Linux 操作系统上，您可以使用最新的 GCC，而在 macOS 上，您可以使用包含所有必需工具的
    Xcode 命令行工具。'
- en: '**CMake**: Make sure you use the latest version of CMake, such as 3.10, to
    be on the safe side with more recent versions of OpenCV, although you can use
    CMake 3.1 and later.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMake**：确保您使用最新版本的 CMake，例如 3.10，以确保与较新版本的 OpenCV 安全兼容，尽管您可以使用 CMake 3.1
    及以后的版本。'
- en: '**Python**: This is especially important if you are aiming to use the Python
    programming language.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：如果您打算使用 Python 编程语言，这一点尤为重要。'
- en: OpenCV contains a large number of tools and libraries and it's possible to customize
    your build in many different ways. For instance, you can use the Qt Framework,
    Intel **Threading Building Blocks** (**TBB**), **Intel Integrated Performance
    Primitives** (**IPP**), and other third-party libraries to further enhance and
    customize your OpenCV build, but since we'll be using OpenCV with the default
    settings and set of tools, we're ignoring the aforementioned third-party tools
    in the list of requirements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 包含大量工具和库，您可以通过多种方式自定义您的构建。例如，您可以使用 Qt 框架、Intel **线程构建块**（**TBB**）、**Intel
    集成性能原语**（**IPP**）和其他第三方库来进一步增强和自定义您的 OpenCV 构建，但由于我们将使用默认设置和工具集使用 OpenCV，所以我们忽略了上述第三方工具的要求列表。
- en: After getting all of the prerequisites we just mentioned, you can configure
    and build OpenCV by using CMake and the corresponding compilers, depending on
    your operating system and desired platforms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取我们刚才提到的所有先决条件后，您可以通过使用 CMake 和相应的编译器配置和构建 OpenCV，具体取决于您的操作系统和所需的平台。
- en: 'The following screenshot depicts the CMake tool with a default set of configurations
    visible. Usually, you don''t need to make any change to the configurations unless
    you want to apply your own set of customizations to the OpenCV build:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了具有默认配置集的 CMake 工具。通常，除非您想对 OpenCV 的构建应用自己的自定义设置，否则您不需要对配置进行任何更改：
- en: '![](img/00014.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: Note that when CMake is first opened, you need to set the source and build folders,
    which are visible in the preceding screenshot, as Where is the source code: and
    Where to build the binaries:, respectively. After hitting the Configure button,
    you need to set a generator and apply the settings, then press Generate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当首次打开 CMake 时，您需要设置源代码文件夹和构建文件夹，分别如前述截图所示，即“源代码在哪里：”和“在哪里构建二进制文件：”。点击“配置”按钮后，您需要设置一个生成器并应用设置，然后按“生成”。
- en: 'After generation, you can simply switch to the CMake output folder using a
    Terminal or Command Prompt instance and execute the following commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 生成后，您只需使用终端或命令提示符实例切换到 CMake 输出文件夹，并执行以下命令：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Be aware that running each one of these commands can take some time depending
    on your computer's speed and configurations. Also note that the `make` commands
    can be different depending on the set of tools you are aiming to use. For instance,
    if you are using Microsoft Visual Studio, then you need to replace `make` with
    `nmake`, or if you are using MinGW then you have to replace `make` with `mingw32-make`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行这些命令中的每一个可能需要一些时间，具体取决于您的计算机速度和配置。另外，请注意，`make` 命令可能因您打算使用的工具集而异。例如，如果您使用
    Microsoft Visual Studio，那么您需要将 `make` 替换为 `nmake`，或者如果您使用 MinGW，那么您必须将 `make`
    替换为 `mingw32-make`。
- en: After the build process is completed, you can start using OpenCV. The only thing
    you need to take care of is configuring your C++ projects so that they can use
    your set of OpenCV libraries and installation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程完成后，你可以开始使用 OpenCV。你需要注意的是配置你的 C++ 项目，以便它们可以使用你的 OpenCV 库和安装。
- en: On Windows operating systems, you need to make sure OpenCV DLL files are accessible
    by the applications you are building. This can be done either by copying all of
    the required DLLs to the same folder where your applications are being built or
    simply by adding the path of the OpenCV DLL files to the PATH environment variable.
    Make sure to take care of this before proceeding further, otherwise your applications
    will crash when they are executed, even though they might build successfully and
    not report any issues at compile time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统上，你需要确保你正在构建的应用程序可以访问 OpenCV DLL 文件。这可以通过将所有必需的 DLL 文件复制到与你的应用程序构建相同的文件夹中，或者简单地通过将
    OpenCV DLL 文件的路径添加到 PATH 环境变量中来实现。在继续之前，请务必注意这一点，否则即使你的应用程序构建成功且在编译时没有报告任何问题，它们在执行时也可能会崩溃。
- en: 'If you are going to use Python to build computer vision applications, then
    things are going to be extremely simple for you since you can use `pip` (package
    manager) to install OpenCV for Python, using the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算使用 Python 来构建计算机视觉应用程序，那么事情对你来说将会非常简单，因为你可以使用 `pip`（包管理器）来安装 Python 的 OpenCV，使用以下命令：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will automatically get you the latest OpenCV version and all of its dependencies
    (such as `numpy`) or, if you have already installed OpenCV, you can use the following
    command to make sure it''s upgraded to the latest version:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动获取最新的 OpenCV 版本及其所有依赖项（如 `numpy`），或者如果你已经安装了 OpenCV，你可以使用以下命令来确保它升级到最新版本：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It goes without saying that you need a working internet connection for these
    commands to work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，你需要一个正常工作的互联网连接才能使这些命令生效。
- en: Using OpenCV with C++ or Python
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 与 C++ 或 Python
- en: 'In this section, we''ll demonstrate how you can use OpenCV in your C++ or Python
    projects with a very simple example that we''ll call `HelloOpenCV`. You might
    already know that the purpose of such a project is either one of the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一个非常简单的示例来展示你如何在 C++ 或 Python 项目中使用 OpenCV，我们将这个示例称为 `HelloOpenCV`。你可能已经知道，这样的项目的目的是以下之一：
- en: To get started with a new library, such as OpenCV, that you've never used before
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要开始使用一个全新的库，例如你之前从未使用过的 OpenCV
- en: To make sure your OpenCV installation is functional and works fine
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保你的 OpenCV 安装是功能性的并且运行良好
- en: So, even if you are not an OpenCV beginner, it's still worth going through the
    following instructions and running the simple example in this section to test
    your OpenCV build or installation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，即使你不是 OpenCV 的初学者，仍然值得阅读以下说明并运行本节中的简单示例来测试你的 OpenCV 编译或安装。
- en: 'We''ll start with the required steps for using OpenCV in a C++ project:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始使用 OpenCV 的必要步骤，在 C++ 项目中：
- en: Create a new folder named `HelloOpenCV`
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `HelloOpenCV` 的新文件夹
- en: Create two new text files inside this folder and name them `CMakeLists.txt`
    and `main.cpp`
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹内创建两个新的文本文件，并将它们命名为 `CMakeLists.txt` 和 `main.cpp`
- en: 'Make sure the `CMakeLists.txt` file contains the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保文件 `CMakeLists.txt` 包含以下内容：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, you need to replace `"path_to_opencv"` with the path
    to the folder containing the `OpenCVConfig.cmake` and `OpenCVConfig-version.cmake`
    files, which is the same folder where you have installed your OpenCV libraries.
    If you are using the Linux operating system and the prebuilt OpenCV libraries,
    you might not need an exact path to the `OpenCV` folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你需要将 `"path_to_opencv"` 替换为包含 `OpenCVConfig.cmake` 和 `OpenCVConfig-version.cmake`
    文件的文件夹路径，这个文件夹是你安装 OpenCV 库的地方。如果你使用的是 Linux 操作系统并且使用了预构建的 OpenCV 库，你可能不需要 `OpenCV`
    文件夹的精确路径。
- en: 'As for the `main.cpp` file, make sure it contains the following, which is the
    actual C++ code we''ll be running:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于 `main.cpp` 文件，请确保它包含以下内容，这是我们将会运行的实际的 C++ 代码：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll be covering the functions used in the preceding code individually later
    on, in this and the upcoming chapters, however, for now it's worth noting that
    this program is trying to open and display an image saved on disk. If it succeeds,
    the image will be displayed until any key is pressed, otherwise the `Empty image!` message
    will be displayed. Note that this program, under normal circumstances, should
    not crash at all and it should build successfully. So, if the opposite happens
    to you, then you'll need to go through the topics discussed previously in this
    chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节和即将到来的章节中逐一介绍前面代码中使用的函数，然而，目前值得注意的是，这个程序正在尝试打开并显示存储在磁盘上的图像。如果成功，图像将一直显示，直到按下任意键，否则将显示`Empty
    image!`消息。请注意，在正常情况下，这个程序不应该崩溃，并且应该能够成功构建。所以，如果你遇到相反的情况，那么你需要回顾本章前面讨论的主题。
- en: Our C++ project is ready. Now, we can use CMake to generate Visual Studio or
    any other type of project that we want (depending on the platform, compiler, and
    IDE we're going to use) and then build and run it. Note that CMake is simply used
    to make sure a cross-platform and IDE-independent C++ project is created.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的项目已经准备好了。现在，我们可以使用CMake来生成Visual Studio或其他任何我们想要的类型的项目（取决于我们将要使用的平台、编译器和IDE），然后构建并运行它。请注意，CMake只是用来确保创建了一个跨平台且与IDE无关的C++项目。
- en: By running this example project, your input image (in this case `MyImage.png`)
    will be read and displayed until any key on the keyboard is pressed. If any problems
    occur during the reading of the image, then the `Empty image!` message will be
    displayed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此示例项目，你的输入图像（在本例中为`MyImage.png`）将被读取并显示，直到按下键盘上的任意键。如果在读取图像的过程中出现任何问题，则将显示`Empty
    image!`消息。
- en: 'We can create and run the same project in Python by using the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码在Python中创建和运行相同的项目：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The resemblance is quite unmistakable here. The exact same `imshow` and `waitKey`
    functions are also used in the Python version of the same code. As was mentioned
    before, for now don't bother with the exact way of using any of the functions
    and just focus on making sure that you are able to run these programs, either
    in C++ or Python, or both, and that you are able to see the image displayed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，相似之处非常明显。与Python版本中的相同代码完全相同的`imshow`和`waitKey`函数也被使用。正如之前提到的，现在不要担心任何函数的确切使用方式，只需确保你能够运行这些程序，无论是C++还是Python，或者两者都可以，并且能够看到显示的图像。
- en: If you were able to successfully run the `HelloOpenCV` example project in this
    section, then you are ready to take on the next sections of this chapter and the
    next chapters of this book without any problems. If you still face problems with
    the topics discussed so far, or you feel that you need a stronger understanding
    of those topics, you can go through them once again from the start of the chapter,
    or even better, you can refer to the additional books mentioned in the *Further
    reading* section at the end of this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够成功运行本节中的`HelloOpenCV`示例项目，那么你就可以毫无问题地继续学习本章的下一节以及本书的下一章。如果你在讨论的主题上仍然遇到问题，或者你觉得你需要对这些主题有更深入的理解，你可以从章节的开始重新学习它们，或者更好的是，你可以参考本章末尾的“进一步阅读”部分中提到的附加书籍。
- en: Understanding the Mat class
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`Mat`类
- en: Refer back to the description that was provided for an image in computer vision
    from the previous chapter, and that any image is in fact a matrix with a given
    width, height, number of channels, and depth. With this description in mind, we
    can say that the OpenCV `Mat` class can be used to handle image data and it supports
    all properties required by an image, such as width and height. In fact, the `Mat`
    class is an n-dimensional array that can be used to store single or multiple channels
    of data with any given data type, and it contains a number of members and methods
    to create, modify, or manipulate it in many ways.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考上一章中提供的计算机视觉中图像的描述，以及任何图像实际上都是一个具有给定宽度、高度、通道数和深度的矩阵。带着这个描述，我们可以说OpenCV的`Mat`类可以用来处理图像数据，并且它支持图像所需的所有属性，如宽度和高度。实际上，`Mat`类是一个n维数组，可以用来存储具有任何给定数据类型的单通道或多通道数据，并且它包含许多成员和方法，可以以多种方式创建、修改或操作它。
- en: In this section, we're going to learn about some of the most important members
    and methods of the `Mat` class with example use cases and code samples.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过示例用例和代码示例来学习`Mat`类的一些最重要的成员和方法。
- en: The equivalent of the OpenCV C++ `Mat` class in Python is not originally an
    OpenCV class, and it is represented by the `numpy.ndarray` type. NumPy is a Python
    library that contains a wide set of numerical algorithms and mathematical operations,
    and it supports working with large multi-dimensional arrays and matrices. The
    reason why the `numpy.ndarray` type in Python is used as `Mat` is that it offers
    the best (if not the same) set of members and methods required by the OpenCV `Mat`
    class in C++. For a complete list of members and methods supported by `numpy.ndarray`,
    you can refer to NumPy documentation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV C++ `Mat` 类在 Python 中的等效物最初不是 OpenCV 类，它由 `numpy.ndarray` 类型表示。NumPy
    是一个 Python 库，包含广泛的数值算法和数学运算，并支持处理大型多维数组和矩阵。Python 中的 `numpy.ndarray` 类型被用作 `Mat`
    的原因是因为它提供了最佳（如果不是相同的）成员和方法集，这些成员和方法是 OpenCV `Mat` 类在 C++ 中所需的。有关 `numpy.ndarray`
    支持的成员和方法的完整列表，请参阅 NumPy 文档。
- en: Constructing a Mat object
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Mat对象
- en: '`Mat` contains about 20 different constructors that can be used to create instances
    of it, based on what kind of initialization is needed. Let''s see some of the
    most commonly used constructors with some examples.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat` 包含大约 20 个不同的构造函数，可以根据所需的初始化方式创建其实例。让我们看看一些最常用的构造函数和一些示例。'
- en: 'Creating a `Mat` object (or class instance) that has a width of `1920` and
    height of `1080`, with three channels that contain 32-bit floating-point values
    looks as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个宽度为 `1920` 和高度为 `1080`，包含三个通道且包含 32 位浮点值的 `Mat` 对象（或类实例）如下所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that the `type` parameter in the `Mat` constructors accepts a special
    type of parameter, that is, a constant value that contains the depth, type, and
    number of channels. The pattern is seen here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Mat` 构造函数中的 `type` 参数接受一种特殊类型的参数，即包含深度、类型和通道数的常量值。模式如下所示：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`<depth>` can be replaced by 8, 16, 32, or 64, which represent the number of
    bits used to store each element in the pixels. The actual number of bits needed
    for each pixel can be calculated by multiplying this number with the number of
    channels, or in other words, `<channels>`. Finally, `<type>` needs to be replaced
    with `U`, `S`, or `F` for the unsigned integer, signed integer, and floating-point
    values, respectively. For example, you can use the following to create standard
    grayscale and colored images with a width of `800` and height of `600` pixels.
    Notice that only the number of channels is different, and that the depth and type
    parameters represent 8-bit unsigned integers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`<depth>` 可以替换为 8、16、32 或 64，这代表用于存储每个像素中每个元素的位数。每个像素实际需要的位数可以通过将此数字乘以通道数来计算，或者换句话说，`<channels>`。最后，`<type>`
    需要替换为 `U`、`S` 或 `F`，分别代表无符号整数、有符号整数和浮点值。例如，你可以使用以下方式创建宽度为 `800` 和高度为 `600` 像素的标准灰度和彩色图像。请注意，只有通道数不同，深度和类型参数代表
    8 位无符号整数：'
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use the following constructor to create a three-channel RGB image with
    a width of `W`, height of `H`, and 8-bit unsigned integer elements, and then initialize
    all elements with the `R`, `G`, and `B` color value:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下构造函数创建一个宽度为 `W`、高度为 `H`、包含 8 位无符号整数元素的三个通道 RGB 图像，并初始化所有元素为 `R`、`G` 和
    `B` 颜色值：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's important to note that the default order of colors in OpenCV is BGR (instead
    of RGB), which means a swapped `B` and `R` value. This is especially important
    if we're aiming to display our processed images at some point during the application
    run time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，OpenCV 中颜色的默认顺序是 BGR（而不是 RGB），这意味着交换了 `B` 和 `R` 值。如果我们希望在应用程序运行时某点显示处理后的图像，这一点尤为重要。
- en: 'So, the correct way of the scalar initializer in the preceding code would be as
    follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前述代码中标量初始化器的正确方式如下：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we need a `Mat` object with higher dimensions, we can use the following.
    Note that in the following example, a `Mat` object of seven dimensions is created.
    The size of each dimension is provided in the `sizes` array and each element in
    the high dimensional `Mat`, which is called `hdm`, contains two channels of 32-bit
    floating-point values:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更高维度的 `Mat` 对象，可以使用以下方法。注意，在以下示例中，创建了一个七维度的 `Mat` 对象。每个维度的尺寸由 `sizes`
    数组提供，并且高维 `Mat` 中的每个元素，称为 `hdm`，包含两个 32 位浮点值通道：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another way of achieving the same thing would be using C++ vectors, as seen
    in the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现相同功能的方法是使用 C++ 向量，如下所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, you can provide an additional `Scalar` parameter to initialize all
    of the values in `Mat`. Note that the number of values in `Scalar` must match
    the number of channels. For instance, to initialize all of the elements in the
    previous seven-dimensional `Mat`, we can use the following constructor:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以提供一个额外的`Scalar`参数来初始化`Mat`中的所有值。请注意，`Scalar`中的值的数量必须与通道数相匹配。例如，为了初始化前面提到的七维`Mat`中的所有元素，我们可以使用以下构造函数：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Mat` class allows us to use already-stored image data to initialize it.
    Using this constructor, you can make your `Mat` class contain the same data that
    the `data` pointer is pointing to. Note that this constructor does not create
    a completely new copy of the original data, and it only makes this newly created
    `Mat` object point to it. This allows very efficient initialization and construction
    of the `Mat` classes, but has the obvious downside of not taking care of the memory
    cleanup when it is not needed, so you need to be extra careful when using this
    constructor:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mat`类允许我们使用已存储的图像数据来初始化它。使用此构造函数，你可以使你的`Mat`类包含`data`指针指向的数据。请注意，此构造函数不会创建原始数据的完整副本，它只使新创建的`Mat`对象指向它。这允许非常高效地初始化和构建`Mat`类，但显然的缺点是在不需要时没有处理内存清理，因此在使用此构造函数时需要格外小心：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that, unlike the previous constructors and their initializers, `data` here
    is not a `Scalar` but a pointer to a chunk of memory that contains a `1920` by
    `1080` pixel, three-channel image data. This method of initializing a `Mat` object
    with a pointer to a memory space can also be used with higher dimensionalities
    of the `Mat` class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与之前的构造函数及其初始化器不同，这里的`data`不是一个`Scalar`，而是一个指向包含`1920` x `1080`像素，三通道图像数据的内存块的指针。使用指向内存空间的指针初始化`Mat`对象的方法也可以用于`Mat`类的更高维度。
- en: 'One last constructor type, which is also one of the most important constructors
    of the `Mat` class, is the **region of interest** (**ROI**) constructor. This
    constructor is used to initialize a `Mat` object with a region inside another
    `Mat` object. Let''s break this down with an example. Imagine you have an image
    and you want to apply some modifications to a specific region inside that image,
    or in other words to the ROI. You can use the following constructor to create
    a `Mat` class that has access to the ROI, and any changes applied to it will affect
    the same region of the original image. Here''s how you can do that:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种构造函数类型，也是`Mat`类最重要的构造函数之一，是**感兴趣区域**（**ROI**）构造函数。此构造函数用于使用另一个`Mat`对象内的区域初始化`Mat`对象。让我们用一个例子来分解这一点。想象你有一张图片，你想要对该图片中的特定区域进行一些修改，换句话说，就是对ROI进行修改。你可以使用以下构造函数创建一个可以访问ROI的`Mat`类，并且对其所做的任何更改都将影响原始图像的相同区域。以下是你可以这样做的步骤：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the preceding constructor is used while `image` (which itself is a `Mat`
    object) contains the picture on the left side of the following image, then `roi`
    will have access to the region highlighted in that image, and it will contain
    the image seen on the right side:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`image`（它本身是一个`Mat`对象）包含以下图像左侧的图片时使用前面的构造函数，那么`roi`将能够访问该图像中突出显示的区域，并且它将包含右侧看到的图像：
- en: '![](img/00015.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: 'The `Rect` class in OpenCV is used to represent a rectangle that has a top-left
    point, width, and height. For instance, the `Rect` class that was used in the
    preceding code example has a top-left point of `240` and `140`, width of `300`,
    and height of `300` pixels, as seen here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中的`Rect`类用于表示具有左上角点、宽度和高度的矩形。例如，前面代码示例中使用的`Rect`类具有左上角点为`240`和`140`，宽度为`300`像素，高度为`300`像素，如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As was mentioned earlier, modifying the ROI in any way will result in the original
    image being modified. For instance, we can apply something similar to the following
    image-processing algorithm to `roi` (for now don''t bother with the nature of
    the following algorithm, as we''ll learn more about it in the upcoming chapters,
    and just focus on the concept of ROIs):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，以任何方式修改ROI将导致原始图像被修改。例如，我们可以将以下类似图像处理算法应用于`roi`（现在不必担心以下算法的性质，因为我们将在接下来的章节中了解更多关于它的内容，只需关注ROI的概念）：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we attempt to display the image, the result would be similar to the following.
    Notice the area that was highlighted in the previous image is modified (dilated)
    in the following image, even though we applied the change to `roi`, and not the
    image itself:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试显示图像，结果将与以下类似。注意，在先前的图像中突出显示的区域在以下图像中已修改（膨胀），尽管我们是在`roi`上应用了更改，而不是图像本身：
- en: '![](img/00016.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00016.jpeg)'
- en: 'Similar to constructing an ROI `Mat` object using a `Rect` class that corresponds
    to a rectangular region of an image, you can also create an ROI that corresponds
    to a range of columns and rows in the original `Mat` object. For instance, the
    same region in the preceding example can also be accessed with the ranges seen
    in the following constructor:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用对应于图像矩形区域的`Rect`类构造ROI `Mat`对象类似，你也可以创建一个对应于原始`Mat`对象中列和行的ROI。例如，先前的例子中的相同区域也可以使用以下构造函数中看到的范围进行访问：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Range` class in OpenCV represents a range that has `start` and `end`. Depending
    on the values of `start` and `end`, `Range` class can be checked to see whether
    it's empty or not. In the preceding constructor, the first `Range` class corresponds
    to the rows of the original image, from row `140` to row `440`. The second `Range`
    corresponds to the columns of the original image, from column `240` to column
    `540`. The shared space of the provided two ranges is considered to be the resulting
    ROI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV中的`Range`类表示一个具有`start`和`end`的区间。根据`start`和`end`的值，可以检查`Range`类是否为空。在先前的构造函数中，第一个`Range`类对应于原始图像的行，从第`140`行到第`440`行。第二个`Range`对应于原始图像的列，从第`240`列到第`540`列。提供的两个区间的交集被认为是最终的ROI。
- en: Deleting a Mat object
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除Mat对象
- en: A `Mat` object can be cleaned up by using its `release` function, however, since
    `release` is called in the destructor of the `Mat` class, there is usually no
    need to call this function at all. It's important to note that the `Mat` class
    shares the same data between multiple objects that point to it. This has the advantage
    of less data copying and less memory usage, and since all of the reference counting
    is done automatically, you don't usually need to take care of anything.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用其`release`函数来清理`Mat`对象，然而，由于`release`函数在`Mat`类的析构函数中被调用，通常没有必要调用此函数。需要注意的是，`Mat`类在多个指向它的对象之间共享相同的数据。这具有减少数据复制和内存使用的优势，并且由于所有引用计数都是自动完成的，你通常不需要关心任何事情。
- en: The only scenario in which you need to take extra care of how and when your
    objects and data are cleaned up is when you use a data pointer to construct a
    `Mat` object, as mentioned in the previous section. In such cases, calling the
    `release` function of the `Mat` class, or its destructor, will have nothing to
    do with the external data you have used to construct it, and the cleanup will
    be completely on your shoulders.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要特别注意如何以及何时清理你的对象和数据的情况下，你需要格外小心，这种情况发生在你使用数据指针构造`Mat`对象时，如前所述。在这种情况下，调用`Mat`类的`release`函数或其析构函数将与用于构造它的外部数据无关，清理将完全由你负责。
- en: Accessing pixels
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问像素
- en: 'Apart from using an ROI to access the pixels in a rectangular region of an
    image, as we did in the previous sections, there are a few other methods for achieving
    the same goal or even for accessing individual pixels of an image. To be able
    to access any single pixel in an image (in other words, a `Mat` object), you can
    use the `at` function, as seen in the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用ROI访问图像矩形区域的像素，如前几节所述，还有一些其他方法可以实现相同的目标，甚至可以访问图像的个别像素。要能够访问图像中的任何单个像素（换句话说，一个`Mat`对象），你可以使用`at`函数，如下例所示：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, in the usage of the `at` function, `TYPE` must be
    replaced with a valid type name that is in accordance with the number of channels
    and depth of the image. `R` must be replaced with the row number, and `C` with
    the column number of the pixels we want to have access to. Notice that this is
    slightly different from the usual pixel-access methods in many libraries, in which
    the first parameter is *X* (or left) and the second parameter is *Y* (or top).
    So basically, the parameters appear reversed here. Here are some examples of accessing
    individual pixels in different types of `Mat` objects.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用 `at` 函数时，`TYPE` 必须替换为一个有效的类型名，该类型名必须符合图像的通道数和深度。`R` 必须替换为像素的行号，而
    `C` 替换为像素的列号，我们想要访问的像素。请注意，这与许多库中常用的像素访问方法略有不同，其中第一个参数是 *X*（或左），第二个参数是 *Y*（或顶）。所以基本上，参数在这里是颠倒的。以下是一些访问不同类型
    `Mat` 对象中单个像素的示例。
- en: 'Accessing a pixel in a single-channel `Mat` object with 8-bit integer elements
    (grayscale images) is done as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式访问具有 8 位整数元素的单一通道 `Mat` 对象中的像素（灰度图像）：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Accessing a pixel in a single-channel `Mat` object with floating-point elements is
    done as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式访问具有浮点元素的单一通道 `Mat` 对象中的像素：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Access a pixel in a three-channel `Mat` object with 8-bit integer elements as
    follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式访问具有 8 位整数元素的三个通道 `Mat` 对象中的像素：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, the `Vec3b` (vector of 3 bytes) type is used. This and
    various other similar vector types are defined in OpenCV for convenience. Here
    is the pattern of the OpenCV `Vec` types that you can use with the `at` function,
    or for any other purposes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了 `Vec3b`（3 字节向量）类型。OpenCV 定义了各种类似的向量类型以方便使用。以下是您可以使用 `at` 函数或用于其他目的的
    OpenCV `Vec` 类型模式：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`<N>` can be replaced with 2, 3, 4, 6, or 8 (or omitted in the case of 1) and
    it corresponds to the number of channels in a `Mat` object. `<Type>`, on the other
    hand, can be one of the following, which represent the type of the data stored
    in each channel of each pixel:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`<N>` 可以替换为 2、3、4、6 或 8（在 1 的情况下可以省略）并且它对应于 `Mat` 对象中的通道数。另一方面，`<Type>` 可以是以下之一，它们代表了每个像素每个通道中存储的数据类型：'
- en: '`b` for `uchar` (unsigned char)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b` 代表 `uchar`（无符号字符）'
- en: '`s` for `short` (signed word)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 代表 `short`（有符号字）'
- en: '`w` for `ushort` (unsigned word)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` 代表 `ushort`（无符号字）'
- en: '`i` for `int`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i` 代表 `int`'
- en: '`f` for `float`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f` 代表 `float`'
- en: '`d` for `double`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d` 代表 `double`'
- en: 'For instance, `Vec4b` can be used to access the pixels of a four-channel `Mat`
    object with the `uchar` elements, and `Vec6f` can be used to access the pixels
    of a six-channel `Mat` object with the `float` elements. It''s important to note
    that the `Vec` type can be treated like an array to access individual channels
    too. Here''s an example of how to access the second channel of a three-channel
    `Mat` object with the `uchar` elements:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Vec4b` 可以用来访问具有 `uchar` 元素的四个通道 `Mat` 对象的像素，而 `Vec6f` 可以用来访问具有 `float` 元素的六个通道
    `Mat` 对象的像素。重要的是要注意，`Vec` 类型可以像数组一样处理以访问单个通道。以下是一个如何使用 `uchar` 元素访问三个通道 `Mat`
    对象的第二个通道的示例：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It''s important to note that by access we mean both reading and writing to
    a pixel and its individual channels. For instance, the following example is one
    way to apply a sepia filter to an image:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们所说的“访问”既包括读取和写入像素及其各个通道。例如，以下示例是应用棕褐色滤镜到图像的一种方法：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, a few things to note here are the `rows` and `cols` members of the image,
    which basically represent the number of rows (or height) and the number of columns
    (or width) in it. Also notice how the `at` function is used both to extract the
    values of channels and to write updated values into them. Don't worry about the
    values used in this example to multiply and get the correct sepia tone, as they
    are specific to the tone itself, and essentially any type of operation can be
    applied to the individual pixels to change them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里需要注意的几点是图像的 `rows` 和 `cols` 成员，它们基本上代表了图像中的行数（或高度）和列数（或宽度）。同时注意 `at` 函数是如何被用来提取通道值和将更新后的值写入其中的。关于示例中用于乘法以获得正确棕褐色调的值，不必担心，因为它们是针对色调本身特定的，并且基本上任何类型的操作都可以应用于单个像素以改变它们。
- en: 'The following image depicts the result of applying the preceding example code
    on a three-channel color image (left—original image, right—filtered image):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了将前面的示例代码应用于三通道彩色图像的结果（左——原始图像，右——过滤后的图像）：
- en: '![](img/00017.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: 'Another method of accessing the pixels in an image is by using the `forEach`
    function of the `Mat` class. `forEach` can be used to apply an operation on all
    pixels in parallel, instead of looping through them one by one. Here''s a simple
    example that shows how `forEach` is used to divide the value of all pixels by
    `5`, which would result in a darker image if it is executed on a grayscale image:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 访问图像中的像素的另一种方法是使用 `Mat` 类的 `forEach` 函数。`forEach` 可以用来并行地对所有像素应用操作，而不是逐个遍历它们。以下是一个简单的示例，展示了如何使用
    `forEach` 将所有像素的值除以 `5`，如果它在灰度图像上执行，这将导致图像变暗：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, the second parameter, or the position parameter (which
    is not needed and therefore omitted here) is the pointer to the position of the
    pixel.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第二个参数，或位置参数（这里不需要，因此省略）是像素位置的指针。
- en: 'Using the previous `for` loop, we would need to write the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的 `for` 循环，我们需要编写以下代码：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'OpenCV also allows the use of STL-like iterators to access or modify individual
    pixels in an image. Here''s the same example but written using STL-like iterators:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 还允许使用类似于 STL 的迭代器来访问或修改图像中的单个像素。以下是一个使用类似于 STL 的迭代器编写的相同示例：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It''s interesting to note that the same operation in all of the preceding three
    examples can also be done by using the following simple statement:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在前三个示例中的相同操作也可以通过以下简单的语句来完成：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is because the `Mat` object in OpenCV treats this statement as an element-wise
    divide operation, which we''ll learn more about it in the upcoming chapters. The
    following image depicts the result of applying the preceding examples to a grayscale
    image (left—original image, right—modified image):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 OpenCV 中的 `Mat` 对象将此语句视为逐元素除法操作，我们将在接下来的章节中了解更多关于它的内容。以下图像展示了将前面的示例应用于灰度图像的结果（左——原始图像，右——修改后的图像）：
- en: '![](img/00018.gif)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.gif)'
- en: Obviously, `forEach`, the C++ `for` loop, and STL-like iterators can all be
    used to access and modify the pixels within a `Mat` object. We'll suffice to the
    functions and members discussed in this section about the `Mat` class, but make
    sure to explore the huge set of functionalities it provides to work with images
    and their underlying properties in an efficient way.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`forEach`、C++ 的 `for` 循环和类似于 STL 的迭代器都可以用来访问和修改 `Mat` 对象内的像素。我们将满足本节讨论的 `Mat`
    类的函数和成员，但请确保探索它提供的用于以高效方式处理图像及其底层属性的庞大功能集。
- en: Reading and writing images
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入图像
- en: 'OpenCV allows reading an image from a disk into a `Mat` object using the `imread`
    function, which we briefly used in this chapter in a previous example. The `imread`
    function accepts an input image file name and a `flag` parameter, and returns
    a `Mat` object filled with the input image. The input image file must have one
    of the image formats supported by OpenCV. Here are some of the most popular supported
    formats:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 允许使用 `imread` 函数从磁盘读取图像到 `Mat` 对象，我们在本章的前一个示例中简要使用过该函数。`imread` 函数接受一个输入图像文件名和一个
    `flag` 参数，并返回一个填充有输入图像的 `Mat` 对象。输入图像文件必须具有 OpenCV 支持的图像格式之一。以下是一些最受欢迎的支持格式：
- en: '**Windows bitmaps**: `*.bmp`, `*.dib`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 位图**: `*.bmp`, `*.dib`'
- en: '**JPEG files**: `*.jpeg`, `*.jpg`, `*.jpe`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JPEG 文件**: `*.jpeg`, `*.jpg`, `*.jpe`'
- en: '**Portable Network Graphics**: `*.png`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携式网络图形**: `*.png`'
- en: '**Portable Image Format**: `*.pbm`, `*.pgm`, `*.ppm`, `*.pxm`, `*.pnm`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携式图像格式**: `*.pbm`, `*.pgm`, `*.ppm`, `*.pxm`, `*.pnm`'
- en: '**TIFF files**: `*.tiff`, `*.tif`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TIFF 文件**: `*.tiff`, `*.tif`'
- en: Make sure to always check the OpenCV documentation for a complete and updated
    list, and especially for exception cases and notes that might apply to some formats
    on some operating systems. As for the
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保始终检查 OpenCV 文档以获取完整和更新的列表，特别是对于可能适用于某些操作系统上某些格式的异常情况和注意事项。至于
- en: '`flag` parameter, it can be one or a combination of the values from the `ImreadModes`
    enum, which is defined in OpenCV. Here are a few of the most widely used and self-explanatory
    entries:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag` 参数，它可以是 `ImreadModes` 枚举中的一个值或其组合，该枚举在 OpenCV 中定义。以下是一些最广泛使用且易于理解的条目：'
- en: '`IMREAD_UNCHANGED`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_UNCHANGED`'
- en: '`IMREAD_GRAYSCALE`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_GRAYSCALE`'
- en: '`IMREAD_COLOR`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_COLOR`'
- en: '`IMREAD_IGNORE_ORIENTATION`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMREAD_IGNORE_ORIENTATION`'
- en: 'For example, the following code can be used to read an image from a disk, without
    taking the orientation value stored in the EXIF data of the image and also converted
    to grayscale:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码可以用来从磁盘读取图像，而不读取图像 EXIF 数据中存储的朝向值，并将其转换为灰度：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Exchangeable Image File Format** (**EXIF**) is a standard for adding tags
    and additional data (or metadata) to images taken by digital cameras. These tags
    might include the manufacturer and camera model and the orientation of the camera
    while the photo was taken. OpenCV is capable of reading certain tags (such as
    orientation) and interpreting them, or in the case of the preceding sample code,
    ignoring them.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**可交换图像文件格式** (**EXIF**) 是一种标准，用于为数字相机拍摄的照片添加标签和附加数据（或元数据）。这些标签可能包括制造商和相机型号以及拍照时相机的方向。OpenCV
    能够读取某些标签（如方向）并对其进行解释，或者在前面示例代码的情况下，忽略它们。'
- en: After the image is read, you can call `empty` to see whether it was read successfully
    or not. You can also use `channels` to get the number of channels, `depth` to
    get the depth, `type` to get the type of the image, and so on. Alternatively,
    you can call the `imshow` function to display it, as we saw previously in this
    chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取图像后，你可以调用 `empty` 来查看它是否成功读取。你也可以使用 `channels` 来获取通道数，`depth` 来获取深度，`type`
    来获取图像类型，等等。或者，你可以调用 `imshow` 函数来显示它，就像我们在本章前面看到的那样。
- en: Similarly, the `imreadmulti` function can be used to read a multipage image
    into a vector of `Mat` objects. The obvious difference here is that `imreadmulti`
    returns a `bool` value that can be checked for successful reading of the pages
    and fills the `vector<Mat>` object passed to it by reference.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`imreadmulti` 函数可以用来将多页图像读取到 `Mat` 对象的向量中。这里明显的区别是 `imreadmulti` 返回一个 `bool`
    值，可以用来检查页面的成功读取，并通过引用填充传递给它的 `vector<Mat>` 对象。
- en: 'To be able to write an image to a file on disk, you can use the `imwrite` function.
    `imwrite` takes the file name that will be written to, a `Mat` object, and a `vector`
    of `int` values containing the write parameters, which can be ignored in the case
    of default parameters. See the following enums in OpenCV for a complete list of
    parameters that can be used with the `imwrite` function to alter the behavior
    of the write process:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像写入磁盘上的文件，你可以使用 `imwrite` 函数。`imwrite` 函数接受要写入的文件名、一个 `Mat` 对象以及包含写入参数的 `int`
    值 `vector`，在默认参数的情况下可以忽略。请参阅 OpenCV 中的以下枚举，以获取使用 `imwrite` 函数可以使用的完整参数列表，以改变写入过程的行为：
- en: '`ImwriteFlags`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImwriteFlags`'
- en: '`ImwriteEXRTypeFlags`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImwriteEXRTypeFlags`'
- en: '`ImwritePNGFlags`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImwritePNGFlags`'
- en: '`ImwritePAMFlags`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImwritePAMFlags`'
- en: 'The following is an example code that depicts how to write a `Mat` object into
    an image file on disk using the `imwrite` function. Note that the format of the
    image is derived from the extension provided, in this case `png`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码，展示了如何使用 `imwrite` 函数将 `Mat` 对象写入磁盘上的图像文件。请注意，图像的格式是从提供的扩展名派生出来的，在这种情况下是
    `png`：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Besides the `imread` and `imwrite` functions, which are used to read and write
    images from and into image files on disk, you can also use the `imdecode` and
    `imencode` functions to read images stored in a buffer in memory or write into
    them. We'll leave those two functions for you to discover, and move on to the
    next topic, which is accessing videos using OpenCV.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `imread` 和 `imwrite` 函数，这些函数用于从磁盘上的图像文件中读取和写入图像外，你还可以使用 `imdecode` 和 `imencode`
    函数来读取存储在内存缓冲区中的图像或向其写入。我们将这两个函数留给你去发现，并继续下一个主题，即使用 OpenCV 访问视频。
- en: Reading and writing videos
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入视频
- en: 'OpenCV, using its `videoio` module or, to be precise, using the `VideoCapture`
    and `VideoWriter` classes, allows us to read and write video files. The obvious
    difference in the case of videos, is that they contain a consecutive set of images
    (or better yet, frames) as opposed to just a single image. So, they are usually
    read and processed or written in a loop that covers the whole or any desired number
    of the frames in a video. Let''s start with example code that shows how to read
    and play a video using the OpenCV `VideoCapture` class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV，使用其 `videoio` 模块或更确切地说，使用 `VideoCapture` 和 `VideoWriter` 类，允许我们读取和写入视频文件。在视频的情况下，明显的区别是它们包含一系列连续的图像（或者更好的说法，帧），而不是单个图像。因此，它们通常在一个循环中读取和处理或写入，该循环覆盖视频中的全部或任何所需数量的帧。让我们从以下示例代码开始，展示如何使用
    OpenCV 的 `VideoCapture` 类读取和播放视频：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As seen in the preceding code, the video file name is passed to the `VideoCapture`
    class when it is constructed. This automatically leads to the opening of the video
    file, if it exists and if the format is supported by your computer (and OpenCV).
    Consequently, you can check whether the video file was successfully opened or
    not using the `isOpened` function. Right after that, the `get` function of the `VideoCapture`
    class is used to retrieve the **framerate per second** (**FPS**) of the video
    file that has been opened. `get` is an extremely important function of `VideoCapture`
    and it allows us to retrieve a wide range of properties of an opened video file.
    Here are some example parameters that can be provided to the `get` function to
    get the desired result:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，视频文件名在构造 `VideoCapture` 类时传递。如果文件存在且您的计算机（和 OpenCV）支持该格式，则会自动打开视频文件。因此，您可以使用
    `isOpened` 函数检查视频文件是否成功打开。之后，使用 `VideoCapture` 类的 `get` 函数检索已打开的视频文件的 **每秒帧率**（**FPS**）。`get`
    是 `VideoCapture` 的一个极其重要的函数，它允许我们检索打开的视频文件的广泛属性。以下是 `get` 函数可以提供的示例参数，以获取所需的结果：
- en: '`CAP_PROP_POS_FRAMES`: *0*-based index of the frame to be decoded or captured
    next'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_PROP_POS_FRAMES`: 要解码或捕获的下一个帧的基于0的索引'
- en: '`CAP_PROP_FRAME_WIDTH`: Width of the frames in the video stream'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_PROP_FRAME_WIDTH`: 视频流中帧的宽度'
- en: '`CAP_PROP_FRAME_HEIGHT`: Height of the frames in the video stream'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_PROP_FRAME_HEIGHT`: 视频流中帧的高度'
- en: '`CAP_PROP_FPS`: Frame rate of the video'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_PROP_FPS`: 视频的帧率'
- en: '`CAP_PROP_FRAME_COUNT`: Number of frames in the video file'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CAP_PROP_FRAME_COUNT`: 视频文件中的帧数'
- en: For a complete list, you can refer to the `VideoCaptureProperties` enum documentation
    in OpenCV. Back to the preceding example code, after the frame rate is retrieved
    using the `get` function, it is used to calculate the delay needed in between
    two frames, so that it is not too fast or slow when played back. Then, inside
    an infinite loop, the frames are read using the `>>` operator and displayed. Note
    that this operator is essentially the simplified and convenient way of using the `VideoCapture`
    functions, such as `read`, `grab`, and `retrieve`. We are already familiar with
    the `imshow` function and how it's used. `waitKey`, on the other hand, which is
    used slightly differently from what we saw before, can be used to insert delays
    and wait for key presses at the same time. In this case, the desired delay (in
    milliseconds), which was previously calculated, is inserted between displayed
    frames and if the space key is pressed, the loop will break. The `release` function
    in the end is pretty much self-explanatory.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的列表，您可以参考 OpenCV 中 `VideoCaptureProperties` 枚举文档。回到前面的示例代码，在通过 `get` 函数检索到帧率之后，它被用来计算两个帧之间所需的延迟，以便在播放时不会太快或太慢。然后，在一个无限循环中，使用
    `>>` 操作符读取帧并显示。请注意，这个操作符实际上是使用 `VideoCapture` 函数（如 `read`、`grab` 和 `retrieve`）的简化和便捷方式。我们已经熟悉了
    `imshow` 函数及其用法。另一方面，`waitKey` 函数的使用方式与之前略有不同，它可以用来插入延迟并等待按键。在这种情况下，之前计算出的所需延迟（以毫秒为单位）被插入到显示的帧之间，如果按下空格键，循环将中断。最后的
    `release` 函数基本上是自我解释的。
- en: Apart from the way we used the `VideoCapture` class and its methods, we can
    also call its `open` function to open the video file, if we do not want to pass
    the file name to the constructor, or if the video file is not present at the `VideoCapture`
    construction time. Another important function of `VideoCapture` is the `set` function.
    Think of `set` as the exact opposite of the `get` function, in the sense that
    it allows setting the parameters of `VideoCapture` and the opened video file.
    Try experimenting with it for yourself with different parameters, mentioned before
    in the `VideoCaptureProperties` enum.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们使用 `VideoCapture` 类及其方法的方式之外，我们还可以调用其 `open` 函数来打开视频文件，如果我们不想将文件名传递给构造函数，或者如果视频文件在
    `VideoCapture` 构造时不存在。`VideoCapture` 的另一个重要功能是 `set` 函数。将 `set` 视为 `get` 函数的完全相反，因为它允许设置
    `VideoCapture` 和打开的视频文件的参数。尝试使用之前在 `VideoCaptureProperties` 枚举中提到的不同参数进行实验。
- en: 'To be able to write into a video file, you can use the `VideoWriter` class
    in a very similar way. Here''s an example that shows how a `VideoWriter` object
    is created:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够写入视频文件，您可以使用与 `VideoCapture` 类非常类似的方式使用 `VideoWriter` 类。以下是一个示例，展示了如何创建 `VideoWriter`
    对象：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will create a video file at `"C:/output.avi"` with a width of `1920` and
    height of `1080` pixels at `30` frames per second, ready to be filled with frames.
    But what is `fourcc`? **Four Character Code** (**FourCC**) is simply a four-byte
    code of the format (or the codec, to be precise) that will be used to record the
    video file. In this example, we have used one of the most common FourCC values,
    but you can check online for a more comprehensive list of FourCC values and their
    specifications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`"C:/output.avi"`创建一个视频文件，分辨率为`1920` x `1080`像素，每秒`30`帧，准备好填充帧。但什么是`fourcc`？**四字符代码**（**FourCC**）简单地说是一个四字节的代码，表示（或更准确地说，是编解码器）将要用于记录视频文件的格式。在这个例子中，我们使用了一个最常见的FourCC值，但你可以在网上查找更全面的FourCC值及其规格列表。
- en: 'After a `VideoWriter` object is created, you can use the `<<` operator or the `write`
    function to write an image (of the exact same size as the video) into the video
    file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`VideoWriter`对象之后，你可以使用`<<`运算符或`write`函数将图像（与视频大小完全相同）写入视频文件：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or you can also use the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以使用以下代码：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, you can call the `release` function to make sure the video file is
    released, and all of your changes are written into it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以调用`release`函数以确保视频文件被释放，并且所有更改都写入其中。
- en: Apart from the aforementioned methods of using the `VideoCapture` and `VideoWriter`
    classes, you can also set the preferred backend used by them. For more information
    about this, refer to the `VideoCaptureAPIs` enum in the OpenCV documentation.
    When omitted, which was the case in our examples, the default backend supported
    by your computer is used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述使用`VideoCapture`和`VideoWriter`类的方法之外，你还可以设置它们所使用的首选后端。有关更多信息，请参阅OpenCV文档中的`VideoCaptureAPIs`枚举。如果省略，如我们示例中所示，则使用计算机支持的默认后端。
- en: Accessing cameras
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问摄像头
- en: 'OpenCV supports accessing cameras that are available on a system by using the
    same `VideoCapture` class we used for accessing the video files. The only difference
    is that instead of passing a file name to the constructor of the `VideoCapture`
    class or its open function, you must provide a *0*-based index number that corresponds
    to each available camera. For instance, the default webcam on a computer can be
    accessed and displayed by using the following example code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV支持通过使用与访问视频文件相同的`VideoCapture`类来访问系统上可用的摄像头。唯一的区别是，你不需要将文件名传递给`VideoCapture`类的构造函数或其open函数，你必须提供一个对应于每个可用摄像头的基于0的索引号。例如，计算机上的默认摄像头可以通过以下示例代码访问和显示：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, the only difference is in the constructor. This implementation
    of the `VideoCapture` class allows users to treat any type of video source the
    same way, thus writing almost the exact same code to deal with cameras instead
    of video files. This is also the case with network feeds, as described in the
    next section.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，唯一的区别在于构造函数。这个`VideoCapture`类的实现允许用户以相同的方式处理任何类型的视频源，因此处理摄像头而不是视频文件时几乎可以编写相同的代码。这与下一节中描述的网络流的情况相同。
- en: Accessing RTSP and network feeds
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问RTSP和网络流
- en: 'OpenCV allows users to read video frames from a network feed or, to be precise,
    from an RTSP stream located on a network, such as the local network or even the
    internet. To be able to do this, you need to pass the URL of the RTSP stream to
    the `VideoCapture` constructor or its open function, exactly the same way as if
    it were a file on a local hard disk. Here''s the most common pattern and an example
    URL that can be used:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV允许用户从网络流中读取视频帧，或者更确切地说，从位于网络上的RTSP流中读取，例如本地网络或甚至互联网。要能够做到这一点，你需要将RTSP流的URL传递给`VideoCapture`构造函数或其open函数，就像它是一个本地硬盘上的文件一样。以下是最常见的模式和可以使用的示例URL：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this URL, `user` is replaced by the actual username, `password` with the
    password of that user, and so on. In the event that the network feed does not
    require a username and password, they can be omitted.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个URL中，`user`被替换为实际的用户名，`password`为该用户的密码，依此类推。如果网络流不需要用户名和密码，它们可以被省略。
- en: Mat-like classes
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类似于Mat的类
- en: 'Besides the `Mat` class, OpenCV provides a number of other classes that are
    quite similar to `Mat`, but different in how and when they are used. Here are
    the most important `Mat`-like classes that can be used instead of, or together
    with, the `Mat` class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Mat`类之外，OpenCV还提供了一些其他与`Mat`非常相似的类，但它们的使用方式和时机不同。以下是可以替代或与`Mat`类一起使用的最重要的`Mat`类似类：
- en: '`Mat_`: This is a subclass of the `Mat` class, but it provides a better access
    method than the `at` function, that is, using `().Mat_` is a template class and
    obviously needs to be provided with the type of the elements at compile time,
    something that can be avoided with the `Mat` class itself.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mat_`：这是`Mat`类的一个子类，但它提供了比`at`函数更好的访问方法，即使用`().Mat_`是一个模板类，显然需要在编译时提供元素的类型，这是`Mat`类本身可以避免的。'
- en: '`Matx`: This is best used with matrices that have a small size, or to be precise,
    a known and small size at compile time.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Matx`：这最适合用于尺寸较小的矩阵，或者更准确地说，在编译时已知且尺寸较小的矩阵。'
- en: '`UMat`: This is a more recent implementation of the `Mat` class, which allows
    us to use OpenCL for faster matrix operations.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UMat`：这是`Mat`类的一个较新实现，它允许我们使用OpenCL进行更快的矩阵操作。'
- en: Using `UMat` can significantly increase the performance of your computer vision
    applications, but since it is used in exactly the same way as the `Mat` class,
    we'll ignore it throughout the chapters of this book; however, in practice and
    especially in real-time computer vision applications, you must always make sure
    to use classes and functions that are better optimized and more performant, such
    as `UMat`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UMat`可以显著提高您计算机视觉应用程序的性能，但由于它与`Mat`类使用方式完全相同，因此在本书的章节中我们将忽略它；然而，在实际应用中，尤其是在实时计算机视觉应用中，您必须始终确保使用更优化、性能更好的类和函数，例如`UMat`。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We're through all the crucial topics that are needed to easily take on computer
    vision algorithms using hands-on examples and real-life scenarios. We started
    this chapter by learning about OpenCV and its overall structure, including its
    modules and main building blocks. This helped us gain a perspective of the computer
    vision library that we'll be working on, but, more importantly, this gave us an
    overview of what's possible and what to expect when dealing with computer vision
    algorithms in general. We moved on to learn where and how to get OpenCV and how
    to install or build it on our own. We also learned how to create, build, and run
    C++ and Python projects that use the OpenCV library. Then, by learning all about
    the `Mat` class and dealing with pixels in an image, we learned how to alter and
    display an image. The final sections of this chapter included everything we need
    to know about reading and writing images from files saved on disk, whether they
    are single (or multi-page) images or videos files, and also cameras and network
    feeds. We finished the chapter by learning about a few other types from the OpenCV
    Mat family that can help improve our applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了所有关键主题，这些主题使我们能够通过实际示例和真实场景轻松地掌握计算机视觉算法。我们本章从学习OpenCV及其整体结构开始，包括其模块和主要构建块。这帮助我们获得了我们将要工作的计算机视觉库的视角，但更重要的是，这让我们对处理计算机视觉算法时可能发生的情况有了概述。然后，我们学习了在哪里以及如何获取OpenCV，以及如何在我们的系统上安装或构建它。我们还学习了如何创建、构建和运行使用OpenCV库的C++和Python项目。然后，通过学习所有关于`Mat`类以及处理图像中的像素，我们学习了如何修改和显示图像。本章的最后部分包括了我们需要了解的所有关于从磁盘上的文件读取和写入图像的知识，无论是单页（或多页）图像还是视频文件，以及摄像头和网络流。我们通过学习OpenCV
    Mat家族中的一些其他类型来结束本章，这些类型可以帮助提高我们的应用程序。
- en: Now that we are aware of the real nature of an image (that it is, in essence,
    a matrix), we can start with possible operations on matrices and matrix-like entities.
    In the next chapter, we're going to learn all about the matrix and array operations
    that fall into the realm of computer vision. By the end of the next chapter, we'll
    be able to perform tons of pixel-wise and image-wise operations and transformations
    using OpenCV.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了图像的真实本质（即它本质上是一个矩阵），我们可以从矩阵及其类似实体的可能操作开始。在下一章中，我们将学习所有属于计算机视觉领域的矩阵和数组操作。到下一章结束时，我们将能够使用OpenCV执行大量的像素级和图像级操作和转换。
- en: Questions
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name three Extra OpenCV modules along with their usages.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三个额外的OpenCV模块及其用途。
- en: What is the effect of building OpenCV 3 with the `BUILD_opencv_world` flag turned
    on?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用`BUILD_opencv_world`标志构建OpenCV 3会有什么影响？
- en: Using the ROI pixel-access method described in this chapter, how can we construct
    a `Mat` class that can access the middle pixel, plus all of its neighboring pixels
    (the middle nine pixels) in another image?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中描述的ROI像素访问方法，我们如何构建一个`Mat`类，使其能够访问中间像素，以及另一个图像中所有相邻的像素（即中间的九个像素）？
- en: Name another pixel-access method of the `Mat` class besides the ones mentioned
    in this chapter.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了本章中提到的之外，请说出 `Mat` 类的另一种像素访问方法。
- en: Write a program only using the `at` method and a `for` loop, which creates three
    separate color images, each one containing only one channel of an RGB image read
    from disk.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅使用 `at` 方法和 `for` 循环编写一个程序，该程序创建三个单独的颜色图像，每个图像只包含从磁盘读取的 RGB 图像的一个通道。
- en: Using STL-like iterators, calculate the average pixel value of a grayscale image.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类似 STL 的迭代器，计算灰度图像的平均像素值。
- en: Write a program using `VideoCapture`, `waitKey`, and `imwrite`, that displays
    your webcam and saves the visible image when the *S* key is pressed. This program
    will stop the webcam and exit if the spacebar key is pressed.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个使用 `VideoCapture`、`waitKey` 和 `imwrite` 的程序，当按下 *S* 键时显示您的网络摄像头并保存可见图像。如果按下空格键，此程序将停止网络摄像头并退出。
- en: Further reading
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Computer Vision with OpenCV 3 and Qt5*: [https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5](https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 OpenCV 3 和 Qt5 进行计算机视觉*：[https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5](https://www.packtpub.com/application-development/computer-vision-opencv-3-and-qt5)'
- en: '*Learn Qt5*: [https://www.packtpub.com/web-development/learn-qt-5](https://www.packtpub.com/web-development/learn-qt-5)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习 Qt5*：[https://www.packtpub.com/web-development/learn-qt-5](https://www.packtpub.com/web-development/learn-qt-5)'
- en: '*Qt5 Projects*: [https://www.packtpub.com/application-development/qt-5-projects](https://www.packtpub.com/application-development/qt-5-projects)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Qt5 项目*：[https://www.packtpub.com/application-development/qt-5-projects](https://www.packtpub.com/application-development/qt-5-projects)'
