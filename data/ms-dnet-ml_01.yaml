- en: Chapter 1. Welcome to Machine Learning Using the .NET Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。欢迎使用.NET框架的机器学习
- en: 'This is a book on creating and then using **Machine Learning** (**ML**) programs
    using the .NET Framework. Machine learning, a hot topic these days, is part of
    an overall trend in the software industry of analytics which attempts to make
    machines *smarter*. Analytics, though not really a new trend, has perhaps a higher
    visibility than in the past. This chapter will focus on some of the larger questions
    you might have about machine learning using the .NET Framework, namely: What is
    machine learning? Why should we consider it in the .NET Framework? How can I get
    started with coding?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于创建和使用**机器学习**（**ML**）程序的书，这些程序使用.NET框架。机器学习，现在是热门话题，是软件行业分析趋势的一部分，该趋势试图使机器更聪明。虽然分析并不是一个新趋势，但它的可见性可能比过去更高。本章将重点介绍一些关于使用.NET框架进行机器学习可能存在的较大问题，即：什么是机器学习？为什么我们应该在.NET框架中考虑它？我如何开始编码？
- en: What is machine learning?
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是机器学习？
- en: 'If you check out on Wikipedia, you will find a fairly abstract definition of
    machine learning:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看维基百科，你会找到一个相当抽象的机器学习定义：
- en: '*"Machine learning explores the study and construction of algorithms that can
    learn from and make predictions on data. Such algorithms operate by building a
    model from example inputs in order to make data-driven predictions or decisions,
    rather than following strictly static program instructions."*'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “机器学习探索了算法的研究和构建，这些算法可以从数据中学习并做出预测。这些算法通过从示例输入中构建模型来操作，以便进行数据驱动的预测或决策，而不是严格遵循静态程序指令。”
- en: I like to think of machine learning as computer programs that produce different
    results as they are exposed to more information without changing their source
    code (and consequently needed to be redeployed). For example, consider a game
    that I play with the computer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将机器学习想象成计算机程序，它们在接触到更多信息时会产生不同的结果，而无需更改它们的源代码（因此需要重新部署）。例如，考虑我玩的一个与计算机的游戏。
- en: I show the computer this picture ![What is machine learning?](img/00002.jpeg)
    and tell it "Blue Circle". I then show it this picture ![What is machine learning?](img/00003.jpeg)
    and tell it "Red Circle". Next I show it this picture ![What is machine learning?](img/00004.jpeg)
    and say "Green Triangle."
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我向计算机展示这张图片 ![什么是机器学习？](img/00002.jpeg) 并告诉它“蓝色圆圈”。然后我向它展示这张图片 ![什么是机器学习？](img/00003.jpeg)
    并告诉它“红色圆圈”。接下来，我向它展示这张图片 ![什么是机器学习？](img/00004.jpeg) 并说“绿色三角形。”
- en: Finally, I show it this picture ![What is machine learning?](img/00005.jpeg)
    and ask it "What is this?". Ideally the computer would respond, "Green Circle."
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我向它展示这张图片 ![什么是机器学习？](img/00005.jpeg) 并问它“这是什么？”理想情况下，计算机会回答，“绿色圆圈。”
- en: This is one example of machine learning. Although I did not change my code or
    recompile and redeploy, the computer program can respond accurately to data it
    has never seen before. Also, the computer code does not have to explicitly write
    each possible data permutation. Instead, we create models that the computer applies
    to new data. Sometimes the computer is right, sometimes it is wrong. We then feed
    the new data to the computer to retrain the model so the computer gets more and
    more accurate over time—or, at least, that is the goal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是机器学习的一个例子。尽管我没有更改我的代码或重新编译和重新部署，但计算机程序可以准确地响应它以前从未见过的数据。此外，计算机代码不必明确编写每个可能的数据排列。相反，我们创建计算机应用于新数据的模型。有时计算机是对的，有时它是错的。然后我们将新数据喂给计算机以重新训练模型，这样计算机随着时间的推移变得越来越准确——至少，这是目标。
- en: Once you decide to implement some machine learning into your code base, another
    decision has to be made fairly early in the process. How often do you want the
    computer to learn? For example, if you create a model by hand, how often do you
    update it? With every new data row? Every month? Every year? Depending on what
    you are trying to accomplish, you might create a real-time ML model, a near-time
    model, or a periodic model. We will discuss the implications and implementations
    of each of these in several chapters in the book as different models lend themselves
    to different retraining strategies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定将一些机器学习集成到你的代码库中，在过程中还需要做出另一个决定。你希望计算机多久学习一次？例如，如果你手动创建一个模型，你多久更新一次？每次有新的数据行？每月？每年？根据你试图实现的目标，你可能会创建实时ML模型、近实时模型或周期性模型。我们将在本书的几个章节中讨论这些模型的含义和实现，因为不同的模型适合不同的重新训练策略。
- en: Why .NET?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么是.NET？
- en: If you are a Windows developer, using .NET is something you do without thinking.
    Indeed, a vast majority of Windows business applications written in the last 15
    years use managed code—most of it written in C#. Although it is difficult to categorize
    millions of software developers, it is fair to say that .NET developers often
    come from nontraditional backgrounds. Perhaps a developer came to .NET from a
    BCSC degree but it is equally likely s/he started writing VBA scripts in Excel,
    moving up to Access applications, and then into VB.NET/C# applications. Therefore,
    most .NET developers are likely to be familiar with C#/VB.NET and write in an
    imperative and perhaps OO style.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 Windows 开发者，使用 .NET 是你无需思考就能做的事情。事实上，在过去 15 年中编写的绝大多数 Windows 商业应用程序都使用托管代码——其中大部分是用
    C# 编写的。尽管很难对数百万软件开发者进行分类，但可以说，.NET 开发者通常来自非传统背景。也许一个开发者是从 BCSC 学位转向 .NET 的，但同样有可能他/她是从
    Excel 中的 VBA 脚本开始，然后发展到 Access 应用程序，最后进入 VB.NET/C# 应用程序。因此，大多数 .NET 开发者可能熟悉 C#/VB.NET，并以命令式和可能面向对象的方式编写代码。
- en: The problem with this rather narrow exposure is that most machine learning classes,
    books, and code examples are in R or Python and very much use a functional style
    of writing code. Therefore, the .NET developer is at a disadvantage when acquiring
    machine learning skills because of the need to learn a new development environment,
    a new language, and a new style of coding before learning how to write the first
    line of machine learning code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相当狭窄的接触问题在于，大多数机器学习课程、书籍和代码示例都是用 R 或 Python 编写的，并且非常使用函数式编程风格来编写代码。因此，在获取机器学习技能之前，.NET
    开发者需要学习新的开发环境、新的语言和新的编码风格，这使得他们在学习编写第一行机器学习代码时处于不利地位。
- en: If, however, that same developer could use their familiar IDE (Visual Studio)
    and the same base libraries (the .NET Framework), they can concentrate on learning
    machine learning much sooner. Also, when creating machine learning models in .NET,
    they have immediate impact as you can slide the code right into an existing C#/VB.NET
    solution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果同样的开发者能够使用他们熟悉的 IDE（Visual Studio）和相同的基库（.NET 框架），他们可以更早地专注于学习机器学习。此外，在
    .NET 中创建机器学习模型时，他们可以立即产生影响，因为你可以直接将代码滑入现有的 C#/VB.NET 解决方案中。
- en: On the other hand, .NET is under-represented in the data science community.
    There are a couple of different reasons floating around for that fact. The first
    is that historically Microsoft was a proprietary closed system and the academic
    community embraced open source systems such as Linux and Java. The second reason
    is that much academic research uses domain-specific languages such as R, whereas
    Microsoft concentrated .NET on general purpose programming languages. Research
    that moved to industry took their language with them. However, as the researcher's
    role is shifted from data science to building programs that can work at real time
    that customers touch, the researcher is getting more and more exposure to Windows
    and Windows development. Whether you like it or not, all companies which create
    software that face customers must have a Windows strategy, an iOS strategy, and
    an Android strategy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，.NET 在数据科学社区中的代表性不足。关于这一点，有几个不同的原因在流传。第一个原因是，从历史上看，微软是一个专有封闭系统，而学术界则拥抱开源系统，如
    Linux 和 Java。第二个原因是，许多学术研究使用特定领域的语言，如 R，而微软则将 .NET 专注于通用编程语言。转移到工业界的研究将他们的语言也带走了。然而，随着研究人员的角色从数据科学转向构建客户可以实时接触的程序，研究人员越来越多地接触到
    Windows 和 Windows 开发。无论你是否喜欢，所有创建面向客户软件的公司都必须有 Windows 策略、iOS 策略和 Android 策略。
- en: One real advantage to writing and then deploying your machine learning code
    in .NET is that you can get everything with one stop shopping. I know several
    large companies who write their models in R and then have another team rewrite
    them in Python or C++ to deploy them. Also, they might write their model in Python
    and then rewrite it in C# to deploy on Windows devices. Clearly, if you could
    write and deploy in one language stack, there is a tremendous opportunity for
    efficiency and speed to market.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中编写和部署机器学习代码的一个真正优势是，你可以一站式购物获得所有东西。我知道有几家大型公司用 R 编写他们的模型，然后让另一个团队用 Python
    或 C++ 重新编写它们以进行部署。他们还可能在 Python 中编写模型，然后将其重写为 C# 以在 Windows 设备上部署。显然，如果你能够在单一语言堆栈中编写和部署，那么在效率和上市速度方面将有很大的机会。
- en: What version of the .NET Framework are we using?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们使用的是哪个版本的 .NET 框架？
- en: 'The .NET Framework has been around for general release since 2002\. The base
    of the framework is the Common Language Runtime or CLR. The CLR is a virtual machine
    that abstracts much of the OS specific functionality like memory management and
    exception handling. The CLR is loosely based on the **Java Virtual Machine** (**JVM**).
    Sitting on top of the CLR is the **Framework Class Library** (**FCL**) that allows
    different languages to interoperate with the CLR and each other: the FCL is what
    allows VB.Net, C#, F#, and Iron Python code to work side-by-side with each other.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架自 2002 年以来就已经上市。框架的基础是公共语言运行时（CLR）。CLR 是一个虚拟机，它抽象了大部分操作系统特定的功能，如内存管理和异常处理。CLR
    在很大程度上基于 **Java 虚拟机** (**JVM**)。位于 CLR 之上的是 **框架类库** (**FCL**)，它允许不同的语言与 CLR 和彼此进行交互：FCL
    是允许 VB.Net、C#、F# 和 Iron Python 代码能够相互并排工作的原因。
- en: Since its first release, the .NET Framework has included more and more features.
    The first release saw support for the major platform libraries like WinForms,
    ASP.NET, and ADO.NET. Subsequent releases brought in things like **Windows Communication
    Foundation** (**WCF**), **Language Integrated Query** (**LINQ**), and **Task Parallel
    Library** (**TPL**). At the time of writing, the latest version is of the .Net
    Framework is 4.6.2.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自从首次发布以来，.NET 框架已经包含了越来越多的功能。首个版本支持了主要的平台库，如 WinForms、ASP.NET 和 ADO.NET。随后的版本引入了诸如
    **Windows Communication Foundation** (**WCF**)、**Language Integrated Query** (**LINQ**)
    和 **Task Parallel Library** (**TPL**) 等功能。在撰写本文时，.NET 框架的最新版本是 4.6.2。
- en: In addition to the full-Monty .NET Framework, over the years Microsoft has released
    slimmed down versions of the .NET Framework intended to run on machines that have
    limited hardware and OS support. The most famous of these releases was the **Portable
    Class Library** (**PCL**) that targeted Windows RT applications running Windows
    8\. The most recent incantation of this is **Universal Windows Applications**
    (**UWA**), targeting Windows 10.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了完整的 .NET 框架之外，多年来微软还发布了针对硬件和操作系统支持有限的机器的精简版 .NET 框架。其中最著名的是 **可移植类库** (**PCL**)，它针对的是运行
    Windows 8 的 Windows RT 应用程序。这一最新版本是 **通用 Windows 应用程序** (**UWA**)，针对 Windows 10。
- en: At `Connect()`; in November 2015, Microsoft announced GA of the latest edition
    of the .NET Framework. This release introduced the .Net Core 5\. In January, they
    decided to rename it to .Net Core 1.0\. .NET Core 1.0 is intended to be a slimmed
    down version of the full .NET Framework that runs on multiple operating systems
    (specifically targeting OS X and Linux). The next release of ASP.NET (ASP.NET
    Core 1.0) sits on top of .NET Core 1.0\. ASP.NET Core 1.0 applications that run
    on Windows can still run the full .NET Framework.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2015 年 11 月的 `Connect()` 大会上，微软宣布了 .NET 框架最新版本的 GA。这个版本引入了 .Net Core 5。到了
    1 月，他们决定将其重命名为 .Net Core 1.0。.NET Core 1.0 的目的是成为一个精简版的完整 .NET 框架，可以在多个操作系统上运行（特别是针对
    OS X 和 Linux）。ASP.NET 的下一个版本（ASP.NET Core 1.0）位于 .NET Core 1.0 之上。在 Windows 上运行的
    ASP.NET Core 1.0 应用程序仍然可以运行完整的 .NET 框架。
- en: '![What version of the .NET Framework are we using?](img/00006.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![我们正在使用哪个版本的 .NET 框架？](img/00006.jpeg)'
- en: ([https://blogs.msdn.microsoft.com/webdev/2016/01/19/asp-net-5-is-dead-introducing-asp-net-core-1-0-and-net-core-1-0/](https://blogs.msdn.microsoft.com/webdev/2016/01/19/asp-net-5-is-dead-introducing-asp-net-core-1-0-and-net-core-1-0/))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://blogs.msdn.microsoft.com/webdev/2016/01/19/asp-net-5-is-dead-introducing-asp-net-core-1-0-and-net-core-1-0/](https://blogs.msdn.microsoft.com/webdev/2016/01/19/asp-net-5-is-dead-introducing-asp-net-core-1-0-and-net-core-1-0/))
- en: In this book, we will be using a mixture of ASP.NET 4.0, ASP.NET 5.0, and Universal
    Windows Applications. As you can guess, machine learning models (and the theory
    behind the models) change with a lot less frequency than framework releases so
    the most of the code you write on .NET 4.6 will work equally well with PCL and
    .NET Core 1.0\. Saying that, the external libraries that we will use need some
    time to catch up—so they might work with PCL but not with .NET Core 1.0 yet. To
    make things realistic, the demonstration projects will use .NET 4.6 on ASP.NET
    4.x for existing (Brownfield) applications. New (Greenfield) applications will
    be a mixture of a UWA using PCL and ASP.NET 5.0 applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 ASP.NET 4.0、ASP.NET 5.0 和通用 Windows 应用程序的混合。正如你所猜测的，机器学习模型（以及模型背后的理论）的变化频率远低于框架的发布，因此你在
    .NET 4.6 上编写的绝大部分代码都可以与 PCL 和 .NET Core 1.0 一样良好地工作。尽管如此，我们将使用的某些外部库可能需要一些时间才能跟上——因此它们可能适用于
    PCL，但可能还不适用于 .NET Core 1.0。为了使事情更现实，演示项目将使用 .NET 4.6 和 ASP.NET 4.x 来构建现有的（Brownfield）应用程序。新的（Greenfield）应用程序将是一个使用
    PCL 的 UWA 和 ASP.NET 5.0 应用程序的混合体。
- en: Why write your own?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要自己编写？
- en: It seems like all of the major software companies are pitching machine learning
    services such as Google Analytics, Amazon Machine Learning Services, IBM Watson,
    Microsoft Cortana Analytics, to name a few. In addition, major software companies
    often try to sell products that have a machine learning component, such as Microsoft
    SQL Server Analysis Service, Oracle Database Add-In, IBM SPSS, or SAS JMP. I have
    not included some common analytical software packages such as PowerBI or Tableau
    because they are more data aggregation and report writing applications. Although
    they do analytics, they do not have a machine learning component (not yet at least).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来所有主要的软件公司都在推广机器学习服务，例如Google Analytics、Amazon Machine Learning Services、IBM
    Watson、Microsoft Cortana Analytics等。此外，主要的软件公司经常尝试销售具有机器学习组件的产品，例如Microsoft SQL
    Server Analysis Service、Oracle Database Add-In、IBM SPSS或SAS JMP。我没有包括一些常见的分析软件包，如PowerBI或Tableau，因为它们是更数据聚合和报告编写应用程序。尽管它们可以进行分析，但它们没有机器学习组件（至少目前还没有）。
- en: 'With all these options, why would you want to learn how to implement machine
    learning inside your applications, or in effect, write some code that you can
    purchase elsewhere? It is the classic build versus buy decision that every department
    or company has to make. You might want to build because:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些选项中，你为什么还想学习如何在你的应用程序中实现机器学习，或者说，编写一些你可以在其他地方购买的代码呢？这是经典的“建造还是购买”决策，每个部门或公司都必须做出。你可能想自己建造，因为：
- en: You really understand what you are doing and you can be a much more informed
    consumer and critic of any given machine learning package. In effect, you are
    building your internal skill set that your company will most likely prize. Another
    way to look at it, companies are not one tool away from purchasing competitive
    advantage because if they were, their competitors could also buy the same tool
    and cancel any advantage. However, companies can be one hire away or more likely
    one team away to truly have the ability to differentiate themselves in their market.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你真正理解你在做什么，你可以成为任何给定机器学习包的更了解的消费者和评论家。实际上，你正在构建你公司最可能珍视的内部技能集。从另一个角度来看，公司并不是通过购买一个工具就能获得竞争优势，因为如果是这样，他们的竞争对手也可以购买相同的工具并取消任何优势。然而，公司可以通过招聘或更有可能通过组建一个团队来真正有能力在市场上区分自己。
- en: You can get better performance by executing locally, which is especially important
    for real-time machine learning and can be implemented in disconnected or slow
    connection scenarios. This becomes particularly important when we start implementing
    machine learning with **Internet of Things** (**IoT**) devices in scenarios where
    the device has a lot more RAM than network bandwidth. Consider the Raspberry Pi
    running Windows 10 on a pipeline. Network communication might be spotty, but the
    machine has plenty of power to implement ML models.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过本地执行来获得更好的性能，这对于实时机器学习尤为重要，并且可以在断开连接或网络连接缓慢的情况下实现。当我们开始在具有比网络带宽大得多的RAM的物联网（**IoT**）设备场景中实施机器学习时，这一点尤为重要。考虑一下在管道上运行Windows
    10的树莓派。网络通信可能不稳定，但机器有足够的处理能力来实施机器学习模型。
- en: You are not beholden to any one vendor or company, for example, every time you
    implement an application with a specific vendor and are not thinking about how
    to move away from the vendor, you make yourself more dependent on the vendor and
    their inevitable recurring licensing costs. The next time you are talking to the
    CTO of a shop that has a lot of Oracle, ask him/her if they regret any decision
    to implement any of their business logic in Oracle databases. The answer will
    not surprise you. A majority of this book's code is written in F#—an open source
    language that runs great on Windows, Linux, and OS X.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会依赖于任何一家供应商或公司，例如，每次你使用特定供应商实施应用程序而没有考虑如何摆脱该供应商时，你都会使自己更加依赖供应商及其不可避免的重复许可费用。下次你与拥有大量Oracle的商店的CTO交谈时，问问他们是否后悔将任何业务逻辑实施在Oracle数据库中。答案不会让你感到惊讶。本书的大多数代码是用F#编写的——这是一种在Windows、Linux和OS
    X上运行得很好的开源语言。
- en: You can be much more agile and have much more flexibility in what you implement.
    For example, we will often re-train our models on the fly and when you write your
    own code, it is fairly easy to do this. If you use a third-party service, they
    may not even have API hooks to do model training and evaluation, so near-time
    model changes are impossible.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以更加敏捷，并在实现方面拥有更大的灵活性。例如，我们通常会即时重新训练我们的模型，当你自己编写代码时，这样做相对容易。如果你使用第三方服务，他们可能甚至没有API钩子来进行模型训练和评估，因此即时模型更改是不可能的。
- en: Once you decide to go native, you have a choice of rolling your own code or
    using some of the open source assemblies out there. This book will introduce both
    the techniques to you, highlight some of the pros and cons of each technique,
    and let you decide how you want to implement them. For example, you can easily
    write your own basic classifier that is very effective in production but certain
    models, such as a neural network, will take a considerable amount of time and
    energy and probably will not give you the results that the open source libraries
    do. As a final note, since the libraries that we will look at are open source,
    you are free to customize pieces of it—the owners might even accept your changes.
    However, we will not be customizing these libraries in this book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定本地化，你可以选择自己编写代码或者使用一些现成的开源组件。这本书将向你介绍这两种技术，突出每种技术的优缺点，并让你决定如何实施。例如，你可以轻松地编写自己的基本分类器，这在生产中非常有效，但某些模型，如神经网络，可能需要相当多的时间和精力，而且可能无法提供开源库所能提供的结果。最后，由于我们将要查看的库是开源的，你可以自由地定制其中的某些部分——所有者甚至可能接受你的更改。然而，我们不会在这本书中定制这些库。
- en: Why open data?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择开放数据？
- en: Many books on machine learning use datasets that come with the language install
    (such as R or Hadoop) or point to public repositories that have considerable visibility
    in the data science community. The most common ones are Kaggle (especially the
    Titanic competition) and the UC Irvine's datasets. While these are great datasets
    and give a common denominator, this book will expose you to datasets that come
    from government entities. The notion of getting data from government and hacking
    for social good is typically called **open data**. I believe that open data will
    transform how the government interacts with its citizens and will make government
    entities more efficient and transparent. Therefore, we will use open datasets
    in this book and hopefully you will consider helping out with the open data movement.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多关于机器学习的书籍使用随语言安装提供的数据集（如R或Hadoop）或指向数据科学社区中具有相当可见性的公共存储库。最常见的是Kaggle（特别是泰坦尼克号竞赛）和加州大学欧文分校的数据集。虽然这些数据集很棒，并且提供了一个共同的基数，但本书将向你展示来自政府实体的数据集。从政府获取数据并为了社会公益而黑客攻击通常被称为**开放数据**。我相信开放数据将改变政府与公民互动的方式，并使政府实体更加高效和透明。因此，我们将在这本书中使用开放数据集，并希望你能考虑帮助开放数据运动。
- en: Why F#?
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择F#？
- en: As we will be on the .NET Framework, we could use either C#, VB.NET, or F#.
    All three languages have strong support within Microsoft and all three will be
    around for many years. F# is the best choice for this book because it is unique
    in the .NET Framework for thinking in the scientific method and machine learning
    model creation. Data scientists will feel right at home with the syntax and IDE
    (languages such as R are also functional first languages). It is the best choice
    for .NET business developers because it is built right into Visual Studio and
    plays well with your existing C#/VB.NET code. The obvious alternative is C#. Can
    I do this all in C#? Yes, kind of. In fact, many of the .NET libraries we will
    use are written in C#.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用.NET Framework，我们可以使用C#、VB.NET或F#。这三种语言都在微软内部得到强有力的支持，并且都将在很多年内存在。F#是这本书的最佳选择，因为它在.NET
    Framework中独特地适用于科学方法和机器学习模型创建。数据科学家会感到语法和IDE（如R也是函数式第一语言）非常亲切。它是.NET商业开发者的最佳选择，因为它直接集成到Visual
    Studio中，并且与现有的C#/VB.NET代码兼容得很好。明显的替代方案是C#。我能否全部用C#完成？是的，某种程度上可以。实际上，我们将使用的许多.NET库都是用C#编写的。
- en: However, using C# in our code base will make it larger and have a higher chance
    of introducing bugs into the code. At certain points, I will show some examples
    in C#, but the majority of the book is in F#.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的代码库中使用C#会使它变得更大，并且有更高的可能性引入代码中的错误。在某些时候，我会用C#展示一些示例，但本书的大部分内容都是用F#编写的。
- en: Another alternative is to forgo .NET altogether and develop the machine learning
    models in R and Python. You could spin up a web service (such as AzureML), which
    might be good in some scenarios, but in disconnected or slow network environments,
    you will get stuck. Also, assuming comparable machines, executing locally will
    perform better than going over the wire. When we implement our models to do real-time
    analytics, anything we can do to minimize the performance hit is something to
    consider.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种替代方案是完全放弃 .NET，并在 R 和 Python 中开发机器学习模型。你可以启动一个网络服务（如 AzureML），在某些场景下可能很好，但在断开连接或网络环境缓慢的情况下，你会陷入困境。此外，假设机器性能相当，本地执行将比通过网络执行表现更好。当我们实现模型进行实时分析时，任何可以减少性能影响的做法都是需要考虑的。
- en: A third alternative that the .NET developers will consider is to write the models
    in T-SQL. Indeed, many of our initial models have been implemented in T-SQL and
    are part of the SQL Server Analysis Server. The advantage of doing it on the data
    server is that the computation is as close as you can get to the data, so you
    will not suffer the latency of moving large amount of data over the wire. The
    downsides of using T-SQL are that you can't implement unit tests easily, your
    domain logic is moving away from the application and to the data server (which
    is considered bad form with most modern application architecture), and you are
    now reliant on a specific implementation of the database. F# is open source and
    runs on a variety of operating systems, so you can port your code much more easily.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 开发者将考虑的第三种替代方案是在 T-SQL 中编写模型。事实上，我们许多初始模型都是用 T-SQL 实现的，并且是 SQL Server Analysis
    Server 的一部分。在数据服务器上执行的优势是计算尽可能接近数据，因此你不会因为通过网络移动大量数据而遭受延迟。使用 T-SQL 的缺点是难以轻松实现单元测试，你的领域逻辑正从应用程序转移到数据服务器（这在大多数现代应用程序架构中被认为是不良的做法），你现在依赖于数据库的特定实现。F#
    是开源的，可以在各种操作系统上运行，因此你可以更轻松地移植你的代码。
- en: Getting ready for machine learning
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备进行机器学习
- en: In this section, we will install Visual Studio, take a quick lap around F#,
    and install the major open source libraries that we will be using.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装 Visual Studio，快速浏览 F#，并安装我们将要使用的重大开源库。
- en: Setting up Visual Studio
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Visual Studio
- en: To get going, you will need to download Visual Studio on a Microsoft Windows
    machine. As of this writing, the latest (free) version is Visual Studio 2015 Community.
    If you have a higher version already installed on your machine, you can skip this
    step. If you need a copy, head on over to the Visual Studio home page at [https://www.visualstudio.com](https://www.visualstudio.com).
    Download the Visual Studio Community 2015 installer and execute it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你需要在 Microsoft Windows 机器上下载 Visual Studio。截至本文撰写时，最新的（免费）版本是 Visual Studio
    2015 Community。如果你已经在你的机器上安装了更高版本，你可以跳过此步骤。如果你需要一份副本，请访问 Visual Studio 主页 [https://www.visualstudio.com](https://www.visualstudio.com)。下载
    Visual Studio Community 2015 安装程序并执行它。
- en: 'Now, you will get the following screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将看到以下屏幕：
- en: '![Setting up Visual Studio](img/00007.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![设置Visual Studio](img/00007.jpeg)'
- en: 'Select **Custom** installation and you will be taken to the following screen:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **自定义** 安装，你将被带到以下屏幕：
- en: '![Setting up Visual Studio](img/00008.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![设置Visual Studio](img/00008.jpeg)'
- en: Make sure Visual F# has a check mark next to it. Once it is installed, you should
    see Visual Studio in your Windows Start menu.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Visual F#旁边有一个勾选标记。一旦安装，你应该能在你的Windows开始菜单中看到Visual Studio。
- en: Learning F#
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习 F#
- en: 'One of the great features about F# is that you can accomplish a whole lot with
    very little code. It is a very terse language compared to C# and VB.NET, so picking
    up the syntax is a bit easier. Although this is not a comprehensive introduction,
    this is going to introduce you to the major language features that we will use
    in this book. I encourage you to check out [http://www.tryfsharp.org/](http://www.tryfsharp.org/)
    or the tutorials at [http://fsharpforfunandprofit.com/](http://fsharpforfunandprofit.com/)
    if you want to get a deeper understanding of the language. With that in mind,
    let''s create our 1st F# project:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的一个伟大特性是你可以用很少的代码完成很多事情。与 C# 和 VB.NET 相比，它是一个非常简洁的语言，因此学习语法要容易一些。尽管这不是一个全面的介绍，但它将介绍我们将在这本书中使用的语言的主要特性。我鼓励你查看
    [http://www.tryfsharp.org/](http://www.tryfsharp.org/) 或 [http://fsharpforfunandprofit.com/](http://fsharpforfunandprofit.com/)
    上的教程，如果你想要更深入地了解这门语言。考虑到这一点，让我们创建我们的第一个 F# 项目：
- en: Start Visual Studio.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio。
- en: Navigate to **File** | **New** | **Project** as shown in the following screenshot:![Learning
    F#](img/00009.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图导航到**文件** | **新建** | **项目**：![学习F#](img/00009.jpeg)
- en: When the **New Project** dialog box appears, navigate the tree view to **Visual
    F#** | **Windows** | **Console Application**. Have a look at the following screenshot:![Learning
    F#](img/00010.jpeg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现**新建项目**对话框时，在树视图中导航到**Visual F#** | **Windows** | **控制台应用程序**。查看以下截图：![学习F#](img/00010.jpeg)
- en: Give your project a name, hit **OK**, and the Visual Studio Template generator
    will create the following boilerplate:![Learning F#](img/00011.jpeg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的项目命名，点击**确定**，Visual Studio模板生成器将创建以下样板代码：![学习F#](img/00011.jpeg)
- en: Although Visual Studio created a `Program.fs` file that creates a basic console
    `.exe` application for us, we will start learning about F# in a different way,
    so we are going to ignore it for now.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然Visual Studio为我们创建了一个`Program.fs`文件，该文件创建了一个基本的控制台`.exe`应用程序，但我们将以不同的方式学习F#，所以现在我们将忽略它。
- en: Right-click in the **Solution Explorer** and navigate to **Add** | **New Item**.![Learning
    F#](img/00012.jpeg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击，导航到**添加** | **新项**。![学习F#](img/00012.jpeg)
- en: When the **Add New Item** dialog box appears, select **Script File**.![Learning
    F#](img/00013.jpeg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当出现**添加新项**对话框时，选择**脚本文件**。![学习F#](img/00013.jpeg)
- en: The `Script1.fsx` file is then added to the project.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将`Script1.fsx`文件添加到项目中。
- en: '![Learning F#](img/00014.jpeg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![学习F#](img/00014.jpeg)'
- en: 'Once `Script1.fsx` is created, open it up, and enter the following into the
    file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建`Script1.fsx`，打开它，并将以下内容输入到文件中：
- en: '[PRE0]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Highlight that entire row of code, right-click and select **Execute In Interactive**
    (or press *Alt* + *Enter*):![Learning F#](img/00015.jpeg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高亮显示整行代码，右键单击并选择**在交互式环境中执行**（或按*Alt* + *Enter*）：![学习F#](img/00015.jpeg)
- en: 'And the **F# Interactive** console will pop up and you will see this:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，**F#交互式**控制台将弹出，你会看到以下内容：
- en: '![Learning F#](img/00016.jpeg)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![学习F#](img/00016.jpeg)'
- en: The F# Interactive is a type of REPL, which stands for Read-Evaluate-Print-Loop.
    If you are a .NET developer who has spent any time in SQL Server Management Studio,
    the F# Interactive will look very familiar to the Query Analyzer where you enter
    your code at the top and see how it executes at the bottom. Also, if you are a
    data scientist using R Studio, you are very familiar with the concept of a REPL.
    I have used the words REPL and FSI interchangeably in this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: F#交互式是一种REPL，代表读取-评估-打印-循环。如果你是任何在SQL Server Management Studio中花费过时间的.NET开发者，F#交互式将非常熟悉查询分析器，你在顶部输入代码，在底部看到它的执行情况。此外，如果你是使用R
    Studio的数据科学家，你对REPL的概念非常熟悉。我在这本书中交替使用了REPL和FSI这两个词。
- en: 'There are a couple of things to notice about this first line of F# code you
    wrote. First, it looks very similar to C#. In fact, consider changing the code
    to this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意你写的第一行F#代码。首先，它看起来非常类似于C#。事实上，考虑将代码更改为以下内容：
- en: '![Learning F#](img/00017.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![学习F#](img/00017.jpeg)'
- en: It would be perfectly valid C#. Note that the red squiggly line, showing you
    that the F# compiler certainly does not think this is valid.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个完全有效的C#代码。请注意，红色的波浪线显示F#编译器肯定认为这不是有效的。
- en: Going back to the correct code, notice that type of `x` is not explicitly defined.
    F# uses the concept of inferred typing so that you don't have to write the type
    of the values that you create. I used the term *value* deliberately because unlike
    variables, which can be assigned in C# and VB.NET, values are immutable; once
    bound, they can never change. Here, we are permanently binding the name `x` to
    its value, `Hello World`. This notion of immutability might seem constraining
    at first, but it has profound and positive implications, especially when writing
    machine learning models.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回到正确的代码，注意`x`的类型没有明确定义。F#使用推断类型的概念，这样你就不必编写你创建的值的类型。我故意使用术语*值*，因为与C#和VB.NET中的变量不同，变量可以被分配，而值是不可变的；一旦绑定，它们就永远不会改变。在这里，我们永久地将名称`x`绑定到其值`Hello
    World`。这种不可变性的概念一开始可能看起来有些限制，但它具有深刻和积极的影响，尤其是在编写机器学习模型时。
- en: 'With our basic program idea proven out, let''s move it over to a compliable
    assembly; in this case, an `.exe` that targets the console. Highlight the line
    that you just wrote, press *Ctrl* + *C*, and then open up `Program.fs`. Go into
    the code that was generated and paste it in:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基本程序想法得到验证后，让我们将其移动到一个可编译的汇编中；在这种情况下，是一个针对控制台的目标`.exe`。高亮显示你刚刚写的行，按*Ctrl*
    + *C*，然后打开`Program.fs`。进入生成的代码，粘贴进去：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在[http://www.packtpub.com](http://www.packtpub.com)的账户下载这本书的示例代码文件。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接将文件通过电子邮件发送给你。
- en: 'You can download the code files by following these steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下步骤下载代码文件：
- en: Log in or register to our website using your e-mail address and password.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的电子邮件地址和密码登录或注册我们的网站。
- en: Hover the mouse pointer on the **SUPPORT** tab at the top.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在顶部的**支持**标签上。
- en: Click on **Code Downloads & Errata**.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**代码下载 & 错误报告**。
- en: Enter the name of the book in the **Search** box.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**搜索**框中输入书籍的名称。
- en: Select the book for which you're looking to download the code files.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你想要下载代码文件的书籍。
- en: Choose from the drop-down menu where you purchased this book from.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择你购买这本书的地方。
- en: Click on **Code Download**.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**代码下载**。
- en: 'Once the file is downloaded, please make sure that you unzip or extract the
    folder using the latest version of:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件后，请确保使用最新版本解压缩或提取文件夹：
- en: WinRAR / 7-Zip for Windows
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows系统上的WinRAR / 7-Zip
- en: Zipeg / iZip / UnRarX for Mac
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac系统上的Zipeg / iZip / UnRarX
- en: 7-Zip / PeaZip for Linux
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux系统上的7-Zip / PeaZip
- en: 'Then, add the following lines of code around what you just added:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你刚刚添加的内容周围添加以下代码行：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Press the Start button (or hit *F5*) and you should see your program run:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按下“开始”按钮（或按*F5*），你应该会看到你的程序运行：
- en: '![Learning F#](img/00018.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![学习F#](img/00018.jpeg)'
- en: You will notice that I had to bind the return value from `Console.ReadKey()`
    to `y`. In C# or VB.NET, you can get away with not handling the return value explicitly.
    In F#, you are not allowed to ignore the returned values. Although some might
    think this is a limitation, it is actually a strength of the language. It is much
    harder to make a mistake in F# because the language forces you to address execution
    paths explicitly versus accidentally sweeping them under the rug (or into a null,
    but we'll get to that later).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我不得不将`Console.ReadKey()`的返回值绑定到`y`上。在C#或VB.NET中，你可以不显式处理返回值。在F#中，不允许忽略返回值。尽管有些人可能认为这是一个限制，但实际上这是语言的一个优点。在F#中犯错误要难得多，因为语言强制你显式处理执行路径，而不是无意中将它们扫到地毯下（或进入空值，但我们会稍后讨论）。
- en: 'In any event, let''s go back to our script file and enter in another line of
    code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们回到我们的脚本文件并输入另一行代码：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you send that line of code to the REPL, you should see this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这一行代码发送到REPL，你应该会看到以下内容：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is an array, as if you did this in C#:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个数组，就像你在C#中这样做一样：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the separator is a semicolon in F# and not a comma. This differs
    from many other languages, including C#. The comma in F# is reserved for tuples,
    not for separating items in an array. We'll discuss tuples later.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，F#中的分隔符是分号，而不是逗号。这与许多其他语言不同，包括C#。F#中的逗号是为元组保留的，而不是用于分隔数组中的项。我们稍后会讨论元组。
- en: 'Now, let''s sum up the values in our array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下数组中的值：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While sending that line to the REPL, you should see this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这一行代码发送到REPL的过程中，你应该会看到以下内容：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are two things going on. We have the `|>` operator, which is a pipe forward
    operator. If you have experience with Linux or PowerShell, this should be familiar.
    However, if you have a background in C#, it might look unfamiliar. The pipe forward
    operator takes the result of the value on the left-hand side of the operator (in
    this case, `ints`) and pushes it into the function on the right-hand side (in
    this case, `sum`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事情在进行。我们有`|>`运算符，这是一个管道前进运算符。如果你有Linux或PowerShell的经验，这应该很熟悉。然而，如果你有C#的背景，它可能看起来不熟悉。管道前进运算符将运算符左侧（在这种情况下，`ints`）的值的结果推入运算符右侧的函数（在这种情况下，`sum`）。
- en: The other new language construct is `Array.sum`. Array is a module in the core
    F# libraries, which has a series of functions that you can apply to your data.
    The function `sum`, well, sums the values in the array, as you can probably guess
    by inspecting the result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新的语言结构是`Array.sum`。数组是F#核心库中的一个模块，它包含一系列你可以应用于你的数据的函数。函数`sum`，正如你可能通过检查结果所猜测的那样，是对数组中的值求和。
- en: 'So, now, let''s add a different function from the `Array` type:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在，让我们添加`Array`类型中的另一个不同函数：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you send it to the REPL, you should see this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其发送到REPL，你应该会看到以下内容：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Array.map` is an example of a high ordered function that is part of the `Array`
    type. Its parameter is another function. Effectively, we are passing a function
    into another function. In this case, we are creating an anonymous function that
    takes a parameter `i` and returns `i * 2`. You know it is an anonymous function
    because it starts with the keyword `fun` and the IDE makes it easy for us to understand
    that by making it blue. This anonymous function is also called a lambda expression,
    which has been in C# and VB.NET since .Net 3.5, so you might have run across it
    before. If you have a data science background using R, you are already quite familiar
    with lambdas.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.map`是`Array`类型中一个高阶函数的例子。它的参数是另一个函数。实际上，我们正在将一个函数传递给另一个函数。在这种情况下，我们创建了一个匿名函数，它接受一个参数`i`并返回`i
    * 2`。你知道它是一个匿名函数，因为它以关键字`fun`开头，IDE通过将其设置为蓝色使我们更容易理解。这个匿名函数也被称为lambda表达式，它自.Net
    3.5以来就存在于C#和VB.NET中，所以你可能之前遇到过。如果你有使用R的数据科学背景，你对lambda表达式已经很熟悉了。'
- en: Getting back to the higher-ordered function `Array.map`, you can see that it
    applies the lambda function against each item of the array and returns a new array
    with the new values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回到高阶函数`Array.map`，你可以看到它将lambda函数应用于数组的每个元素，并返回一个包含新值的新数组。
- en: '![Learning F#](img/00019.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![学习F#](img/00019.jpeg)'
- en: We will be using `Array.map` (and its more generic kin `Seq.map`) a lot when
    we start implementing machine learning models as it is the best way to transform
    an array of data. Also, if you have been paying attention to the buzz words of
    map/reduce when describing big data applications such as Hadoop, the word map
    means exactly the same thing in this context. One final note is that because of
    immutability in F#, the original array is not altered, instead, multiplied is
    bound to a new array.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始实现机器学习模型时，我们会大量使用`Array.map`（及其更通用的兄弟`Seq.map`），因为这是转换数据数组最佳的方式。此外，如果你注意到了描述大数据应用（如Hadoop）时map/reduce的热门词汇，那么在这个上下文中，map一词意味着完全相同的意思。最后一点是，由于F#中的不可变性，原始数组不会被修改，相反，乘法操作绑定到一个新数组上。
- en: 'Let''s stay in the script and add in another couple more lines of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在脚本中添加几行代码：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you send it to the REPL, you should see this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其发送到REPL，你应该看到这个：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These two lines created a named function called `multiplyByTwo`. The function
    that takes a single parameter `x` and then returns the value of the parameter
    multiplied by `2`. This is exactly the same as our anonymous function we created
    earlier in-line that we passed into the `map` function. The syntax might seem
    a bit strange because of the `->` operator. You can read this as, "the function
    `multiplyByTwo` takes in a parameter called `x` of type `int` and returns an `int`."
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行创建了一个名为`multiplyByTwo`的命名函数。该函数接受一个参数`x`，然后返回参数乘以`2`的值。这与我们之前在`map`函数中创建的匿名函数完全相同。由于`->`操作符，语法可能看起来有点奇怪。你可以把它读作，“函数`multiplyByTwo`接受一个名为`x`的参数，其类型为`int`，并返回一个`int`。”
- en: 'Note three things here. Parameter `x` is inferred to be an `int` because it
    is used in the body of the function as multiplied to another `int`. If the function
    reads `x * 2.0`, the `x` would have been inferred as a float. This is a significant
    departure from C# and VB.NET but pretty familiar for people who use R. Also, there
    is no return statement for the function, instead, the final expression of any
    function is always returned as the result. The last thing to note is that whitespace
    is important so that the indentation is required. If the code was written like
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意三点。参数`x`被推断为`int`类型，因为它在函数体中被乘以另一个`int`。如果函数读取`x * 2.0`，则`x`将被推断为浮点数。这与C#和VB.NET有显著的不同，但对于使用R的人来说很熟悉。另外，该函数没有返回语句，相反，任何函数的最终表达式总是作为结果返回。最后要注意的是，空白很重要，因此需要缩进。如果代码写成这样：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The compiler would complain:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会报错：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since F# does not use curly braces and semicolons (or the end keyword), such
    as C# or VB.NET, it needs to use something to separate code. That separation is
    whitespace. Since it is good coding practice to use whitespace judiciously, this
    should not be very alarming to people having a C# or VB.NET background. If you
    have a background in R or Python, this should seem natural to you.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于F#不使用花括号和分号（或结束关键字），例如C#或VB.NET，它需要使用某种东西来分隔代码。这种分隔是空白。由于合理使用空白是良好的编码实践，因此对于有C#或VB.NET背景的人来说，这不应该非常令人惊讶。如果你有R或Python的背景，这对你来说应该很自然。
- en: 'Since `multiplyByTwo` is the functional equivalent of the lambda created in
    `Array.map (fun i -> i * 2)`, we can do this if we want:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`multiplyByTwo`是`Array.map (fun i -> i * 2)`中创建的lambda的函数等价物，如果我们想这样做的话，我们可以这样做：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you send it to the REPL, you should see this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它发送到REPL中，你应该会看到这个：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Typically, we will use named functions when we need to use that function in
    several places in our code and we use a lambda expression when we only need that
    function for a specific line of code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们需要在代码的多个地方使用该函数时，我们会使用命名函数；而当我们只需要在特定代码行中使用该函数时，我们会使用lambda表达式。
- en: There is another minor thing to note. I used the tick notation for the value
    multiplied when I wanted to create another value that was representing the same
    idea. This kind of notation is used frequently in the scientific community, but
    can get unwieldy if you attempt to use it for a third or even fourth (multiplied'''')
    representation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一件需要注意的小事。当我想要创建一个代表相同概念的新值时，我使用了tick符号来表示乘法值。这种符号在科学界经常被使用，但如果尝试用它来表示第三或第四（乘法'''）表示，可能会变得难以控制。
- en: 'Next, let''s add another named function to the REPL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在REPL中添加另一个命名函数：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you send it to the REPL, you should see this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它发送到REPL中，你应该会看到这个：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a function named `isEven` that takes a single parameter `x`. The body
    of the function uses a pattern-matching statement to determine whether the parameter
    is odd or even. When it is odd, then it returns the string `odd`. When it is even,
    it returns the string `even`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为`isEven`的函数，它接受一个参数`x`。函数体使用模式匹配语句来确定参数是奇数还是偶数。如果是奇数，则返回字符串`odd`；如果是偶数，则返回字符串`even`。
- en: 'There is one really interesting thing going on here. The match statement is
    a basic example of pattern matching and it is one of the coolest features of F#.
    For now, you can consider the match statement much like the switch statement that
    you may be familiar within R, Python, C#, or VB.NET, but we will see how it becomes
    much more powerful in the later chapters. I would have written the conditional
    logic like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常有趣的现象。match语句是模式匹配的基本示例，也是F#中最酷的特性之一。目前，你可以将match语句视为你可能熟悉的R、Python、C#或VB.NET中的switch语句，但我们在后面的章节中会看到它如何变得更加强大。我可能会像这样编写条件逻辑：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But I prefer to use pattern matching for this kind of conditional logic. In
    fact, I will attempt to go through this entire book without using an `if…then`
    statement.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但我更喜欢使用模式匹配来进行这种条件逻辑。实际上，我将尝试在整个书中不使用`if…then`语句。
- en: 'With `isEven` written, I can now chain my functions together like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEven`函数编写完成后，我现在可以像这样将我的函数链接起来：'
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you send it to REPL, you should see this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它发送到REPL中，你应该会看到这个：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this case, the resulting array from the first pipe `Array.map (fun i ->
    multiplyByTwo i))` gets sent to the next function `Array.map (fun i -> isEven
    i)`. This means we might have three arrays floating around in memory: ints which
    is passed into the first pipe, the result from the first pipe that is passed into
    the second pipe, and the result from the second pipe. From your mental model point
    of view, you can think about each array being passed from one function into the
    next. In this book, I will be chaining pipe forwards frequently as it is such
    a powerful construct and it perfectly matches the thought process when we are
    creating and using machine learning models.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个管道`Array.map (fun i -> multiplyByTwo i)`的结果被发送到下一个函数`Array.map (fun
    i -> isEven i)`。这意味着我们可能在内存中漂浮着三个数组：传入第一个管道的ints，第一个管道的结果传递到第二个管道，以及第二个管道的结果。从你的心理模型角度来看，你可以将每个数组视为从一个函数传递到下一个函数。在这本书中，我会频繁地使用管道链，因为它是一个非常强大的结构，并且它与我们在创建和使用机器学习模型时的思维过程完美匹配。
- en: You now know enough F# to get you up and running with the first machine learning
    models in this book. I will be introducing other F# language features as the book
    goes along, but this is a good start. As you will see, F# is truly a powerful
    language where a simple syntax can lead to very complex work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经掌握了足够的F#知识，可以开始运行本书中的第一个机器学习模型。随着本书的进行，我会介绍其他F#语言特性，但这是一个良好的开端。正如你将看到的，F#确实是一种强大的语言，简单的语法可以导致非常复杂的工作。
- en: Third-party libraries
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方库
- en: The following are a few third-party libraries that we will cover in our book
    later on.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本书后面部分介绍的一些第三方库。
- en: Math.NET
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Math.NET
- en: Math.NET is an open source project that was created to augment (and sometimes
    replace) the functions that are available in `System.Math`. Its home page is [http://www.mathdotnet.com/](http://www.mathdotnet.com/).
    We will be using Math.Net's `Numerics` and `Symbolics` namespaces in some of the
    machine learning algorithms that we will write by hand. A nice feature about Math.Net
    is that it has strong support for F#.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Math.NET 是一个开源项目，它被创建用来增强（有时替换）`System.Math` 中可用的函数。它的主页是 [http://www.mathdotnet.com/](http://www.mathdotnet.com/)。我们将使用
    Math.Net 的 `Numerics` 和 `Symbolics` 命名空间来编写一些机器学习算法。Math.Net 的一个优点是它对 F# 有很强的支持。
- en: Accord.NET
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Accord.NET
- en: Accord.NET is an open source project that was created to implement many common
    machine learning models. Its home page is [http://accord-framework.net/](http://accord-framework.net/).
    Although the focus of Accord.NET was for computer vision and signal processing,
    we will be using Accord.Net extensively in this book as it makes it very easy
    to implement algorithms in our problem domain.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Accord.NET 是一个开源项目，它被创建用来实现许多常见的机器学习模型。它的主页是 [http://accord-framework.net/](http://accord-framework.net/)。尽管
    Accord.NET 的重点是计算机视觉和信号处理，但我们将在这本书中广泛使用 Accord.Net，因为它使得在我们的问题域中实现算法变得非常简单。
- en: Numl
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Numl
- en: Numl is an open source project that implements several common machine learning
    models as experiments. Its home page is [http://numl.net/](http://numl.net/).
    Numl is newer than any of the other third-party libraries that we will use in
    the book, so it may not be as extensive as the other ones, but it can be very
    powerful and helpful in certain situations. We will be using Numl in several chapters
    of the book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Numl 是一个开源项目，它实现了几个常见的机器学习模型作为实验。它的主页是 [http://numl.net/](http://numl.net/)。Numl
    比我们将在书中使用的其他任何第三方库都要新，所以它可能不像其他那些那么全面，但在某些情况下它可以非常强大和有帮助。我们将在本书的几个章节中使用 Numl。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of ground in this chapter. We discussed what machine learning
    is, why you want to learn about it in the .NET stack, how to get up and running
    using F#, and had a brief introduction to the major open source libraries that
    we will be using in this book. With all this preparation out of the way, we are
    ready to start exploring machine learning.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了大量的内容。我们讨论了什么是机器学习，为什么你想要在 .NET 堆栈中学习它，如何使用 F# 来入门，并对我们将在这本书中使用的几个主要开源库进行了简要介绍。在完成所有这些准备工作后，我们准备开始探索机器学习。
- en: In the next chapter, we will apply our newly found F# skills to create a simple
    linear regression to see if we can help AdventureWorks improve their sales.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将应用我们新发现的 F# 技能来创建一个简单的线性回归，看看我们是否可以帮助 AdventureWorks 提高他们的销售额。
