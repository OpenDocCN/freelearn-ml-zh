- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Refactoring Your Monolith
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构单体
- en: Now we have decided that MSA is the right architectural style for our organization,
    what’s next?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经决定MSA是我们组织正确的架构风格，接下来是什么？
- en: In a recent report, *2022 APIs & Microservices Connectivity Report*, published
    by Kong Inc., 75% of organizations have a lack of innovation and technology adoption.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kong Inc.最近发布的报告《2022年API与微服务连接性报告》中，75%的组织缺乏创新和技术采用。
- en: The need for an IT system that quickly responds to customer and market needs
    has never been higher. Monolithic applications can no longer respond to high-paced
    market updates and needs. That’s one main reason for organizations to look to
    update their IT system, to stay in business.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个能够快速响应客户和市场需求的IT系统的需求从未如此之高。单体应用程序无法再应对快速的市场更新和需求。这就是组织寻求更新其IT系统以保持业务运营的主要原因之一。
- en: MSA is a primary enabler for a flexible and reliable enterprise system. Transitioning
    from a monolithic architecture into MSA is, therefore, becoming essential to modernizing
    an organization’s IT systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: MSA是灵活和可靠的企业系统的主要推动者。因此，从单体架构过渡到MSA对于现代化组织的IT系统变得至关重要。
- en: We will discuss, in this chapter, how to break up the business requirements
    of an existing running monolithic application in to microservices, and the steps
    necessary to transition toward MSA applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何将现有运行中的单体应用程序的业务需求分解为微服务，以及过渡到MSA应用程序所需的步骤。
- en: 'We will cover the following areas as we go over the chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览本章内容时，我们将涵盖以下领域：
- en: Identifying the system’s microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别系统的微服务
- en: The ABC monolith
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABC单体
- en: Function decomposition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能分解
- en: Data decomposition
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据分解
- en: Request decomposition
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求分解
- en: Identifying the system’s microservices
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别系统的微服务
- en: Whether it is a brownfield or greenfield enterprise system implementation, we
    still need to break up business requirements into basic functions as granularly
    as possible. This will later help us identify each microservice and successfully
    integrate it into our enterprise system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是现有系统的棕色地带还是绿色地带企业系统实施，我们仍然需要尽可能细致地将业务需求分解为基本功能。这将有助于我们识别每个微服务并将其成功集成到我们的企业系统中。
- en: In a brownfield system, business and system requirements have already been identified
    and implemented. They may, however, need to be revisited and updated according
    to new business criteria, changes, and requirements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有系统中，业务和系统需求已经被识别和实现。然而，根据新的业务标准、变化和要求，它们可能需要被重新审视和更新。
- en: The objective of refactoring your application into simple services is to form
    highly granular functions that will eventually be built (or acquired) as microservices.
    You are very likely to add new functions to your new MSA in addition to some of
    the functions you will already extract from the monolithic system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的应用程序重构为简单服务的目标是形成高度细粒度的功能，这些功能最终将被构建（或获取）为微服务。您很可能在从单体系统中提取的一些功能之外，在新的MSA中添加新功能。
- en: 'We, therefore, split the migration process into the following high-level steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将迁移过程分为以下高级步骤：
- en: Define the to-be MSA system and the functions needed to build that MSA.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义待MSA系统和构建该MSA所需的功能。
- en: Identify what existing functions in the current monolithic system are to be
    reused in the new MSA and implemented as microservices.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定在当前单体系统中哪些现有功能将在新的MSA中重用，并作为微服务实现。
- en: Identify the delta between the existing functions to be reused and the functions
    needed to get to the to-be MSA system. These are the new functions to be implemented
    in the new MSA system.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定现有要重用的功能和需要达到待MSA系统所需的功能之间的差异。这些是新MSA系统中要实现的新功能。
- en: From the functions list identified in *step 3*, identify which functions will
    be developed as a microservice in-house, and the ones that can be acquired through
    third parties.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤3中确定的功能列表中，确定哪些功能将作为内部微服务开发，哪些可以通过第三方获取。
- en: Decomposing the monolith using a function-driven approach is a good starting
    point; nevertheless, using that approach alone is not enough. Since data stores
    are centralized in the monolith, data dependencies will still be a big concern
    in maintaining the microservices’ autonomy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以功能驱动的分解方法来分解单体是一个好的起点；然而，仅使用这种方法是不够的。由于数据存储在单体中是集中的，因此在维护微服务的自主性时，数据依赖仍然是一个很大的问题。
- en: The interaction between the different functions in the monolith is another concern.
    We will need to look into how the function calls are being processed and handled,
    what data is being shared between these functions, and what data is being returned.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单体中不同功能之间的交互是另一个关注点。我们需要调查函数调用是如何被处理和处理的，这些功能之间共享了什么数据，以及返回了什么数据。
- en: Examining monolithic system functions, data, and function calls (requests) during
    the refactoring process is essential for maintaining the autonomy of microservices
    and achieving the desired level of granularity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构过程中检查单体系统的功能、数据和函数调用（请求）对于维护微服务的自治性和实现期望的粒度级别至关重要。
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Bear in mind that we must maintain the microservices autonomy principle during
    the entire monolith decomposition process. Too many microservices would cause
    a **Nano-service anti-pattern** effect, while too few would still leave your system
    with the same issues as a monolithic system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在整个单体分解过程中，我们必须维护微服务的自治原则。过多的微服务会导致 **Nano-service 反模式** 效应，而微服务过少则仍然会使你的系统面临与单体系统相同的问题。
- en: The Nano-service anti-pattern creates too many expectations for most systems’
    operations, which can in turn further complicate your MSA system and create a
    lack of stability, decreased reliability, and other system performance issues.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Nano-service 反模式对大多数系统的操作产生了过多的期望，这反过来又可能进一步复杂化你的 MSA 系统，并导致稳定性降低、可靠性下降和其他系统性能问题。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: As a general rule, apply the **Common Closure Principle**, where microservices
    that change for the same exact reason are better off packaged together in a single
    microservice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，应用 **共同封闭原则**，即由于相同原因而更改的微服务最好打包在单个微服务中。
- en: To better explain the monolith transformation process to an MSA, in the following
    sections, we will design a simple hypothetical monolithic system, break up the
    system using the already mentioned three stages of system decomposition, build
    the different microservices, and then organize them together to build the MSA.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释单体向 MSA 的转换过程，在接下来的章节中，我们将设计一个简单的假设单体系统，使用已经提到的系统分解三个阶段来分解系统，构建不同的微服务，然后将它们组织起来构建
    MSA。
- en: The ABC monolith
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ABC 单块
- en: ABC is a simplified hypothetical product-ordering monolithic system built specifically
    to demonstrate the process and the steps needed in refactoring a monolithic application
    into an MSA. We will be using this ABC system throughout this book to demonstrate
    some examples of how to apply the concepts and methodologies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ABC 是一个简化的假设产品订购单体系统，专门用于演示将单体应用程序重构为 MSA 所需的过程和步骤。我们将在这本书中使用这个 ABC 系统来演示如何应用概念和方法的一些示例。
- en: Please note that we put the ABC-Monolith system together for demo purposes only
    and our aim here is not to discuss how the ABC-Monolith can be designed or structured
    better. We are more focused on the ABC-Monolith system refactoring process itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们仅为了演示目的而将 ABC-Monolith 系统组合在一起，我们的目标不是讨论如何更好地设计或结构化 ABC-Monolith。我们更关注
    ABC-Monolith 系统重构的过程本身。
- en: In the ABC-Monolith, the user can place an order from an existing product catalog
    and track the order’s shipping status. For simplicity, all sales are final, and
    products cannot be returned.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ABC-Monolith 中，用户可以从现有的产品目录下订单并跟踪订单的运输状态。为了简化，所有销售均为最终销售，产品不能退货。
- en: The system will be able to clear the order payment, assign a shipping courier
    to the order, and track all order and shipping updates.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 系统将能够处理订单支付，为订单分配运输快递，并跟踪所有订单和运输更新。
- en: The following diagram shows the high-level ABC-Monolith architecture. A user
    portal is used to add items to the cart, then send the order details to the ABC-Monolith.
    The ABC-Monolith has different tightly coupled functions with a centralized database,
    all to process the order from payment to delivery. The user is notified of all
    order and shipping updates throughout the order fulfillment process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了 ABC-Monolith 的高级架构。用户门户用于将项目添加到购物车，然后将订单详情发送到 ABC-Monolith。ABC-Monolith
    有不同的紧密耦合功能与集中式数据库，所有这些都是为了处理从支付到交付的订单。在整个订单履行过程中，用户会收到所有订单和运输更新的通知。
- en: '![Figure 2.1: The ABC-Monolith architecture](img/B18934_02_1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：ABC-Monolith 架构](img/B18934_02_1.jpg)'
- en: 'Figure 2.1: The ABC-Monolith architecture'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：ABC-Monolith 架构
- en: To further understand the monolith, we will next go over the system As-Is state
    by discussing the existing monolith’s functions, the monolith database structure,
    and the workflow of the order placement process. We will close this section by
    comparing the As-Is to the To-Be state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解单体，我们将通过讨论现有单体的函数、单体数据库结构和订单放置过程的流程来回顾系统的当前状态。我们将通过比较当前状态和预期状态来结束本节。
- en: The ABC-Monolith’s current functions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABC-Monolith的当前函数
- en: 'It is imperative to start by understanding what current functions are implemented
    in the monolith and what their role is in the overall system. The following table
    lists the system functions we need to consider later in our system refactoring:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先理解单体中实现了哪些当前函数以及它们在整体系统中的作用是至关重要的。以下表格列出了我们稍后需要在系统重构中考虑的系统函数：
- en: '| Function | Description |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| `place_order()` | A function to create a record with all order information,
    and mark the order as “pending” awaiting the rest of the order placement process.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `place_order()` | 创建包含所有订单信息的记录，并将订单标记为“待处理”，等待订单放置过程的其余部分。|'
- en: '| `check_inventory()` | To check the availability of an item in the placed
    order. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `check_inventory()` | 检查已放置订单中项目的可用性。|'
- en: '| `process_payment()` | Verify the payment of the total order amount. Will
    return an error code if the payment is not cleared. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `process_payment()` | 验证订单总金额的支付。如果支付未完成，将返回错误代码。|'
- en: '| `update_inventory()` | Once an order is verified and the payment is successfully
    processed, the item inventory should be updated accordingly. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `update_inventory()` | 一旦订单得到验证并且支付成功处理，应相应地更新项目库存。|'
- en: '| `create_order()` | The order is now successfully processed; time to change
    the order status, and kick off the order preparation process (packing, etc.).
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `create_order()` | 订单现在已成功处理；是时候更改订单状态并启动订单准备过程（包装等）。|'
- en: '| `create_shipping_request()` | Starts the order shipping request and notifies
    the courier with an available order for shipping. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `create_shipping_request()` | 启动订单运输请求，并通知快递员有可运输的订单。|'
- en: '| `order_status_update()` | A function to update the order status with any
    changes such as preparing, shipping, exception, received, and so on. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `order_status_update()` | 一个用于更新订单状态并记录任何更改（如准备、运输、异常、已接收等）的函数。|'
- en: '| `shipment_status_update()` | A function to update the shipping status with
    any changes such as, pending pickup, picked up, en route, exception, received,
    and so on. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `shipment_status_update()` | 一个用于更新运输状态并记录任何更改（如待取货、已取货、在途中、异常、已接收等）的函数。|'
- en: '| `notify_user()` | To notify the user of any changes or updates to the placed
    order. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `notify_user()` | 通知用户任何关于已放置订单的更改或更新。|'
- en: '| `register_customer()` | A function that creates customer record information
    with a full name, address, phone, and other details. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `register_customer()` | 一个使用全名、地址、电话和其他详细信息创建客户记录信息的函数。|'
- en: 'Table 2.1: The ABC-Monolith functions list'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1：ABC-Monolith函数列表
- en: In the preceding table, we focused our description on the role of the function
    itself regardless of what the parameter passing is, or what the return values
    are.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，我们专注于描述函数本身的作用，而不考虑参数传递的方式或返回值。
- en: The ABC-Monolith’s database
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABC-Monolith的数据库
- en: 'All the functions identified in the monolith share a centralized database.
    The following are the database tables being accessed by the functions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单体中识别的所有函数都共享一个集中式数据库。以下是被函数访问的数据库表：
- en: '| Database Table | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 数据库表 | 描述 |'
- en: '| `CUSTOMER` | A table holding all customer information such as name, email,
    and phone. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `CUSTOMER` | 存储所有客户信息的表，如姓名、电子邮件和电话。|'
- en: '| `ITEM` | The product information is in the catalog. Product information includes
    product name, price, and stock quantity. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `ITEM` | 产品信息在目录中。产品信息包括产品名称、价格和库存数量。|'
- en: '| `ORDER` | Information on orders placed. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `ORDER` | 订单信息。|'
- en: '| `ORDER_ITEM` | A many-to-many relationship normalization table between the
    `ORDER` and `ITEM` tables. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `ORDER_ITEM` | `ORDER`和`ITEM`表之间多对多关系规范化的表。|'
- en: '| `ORDER_STATUS` | The status of each placed order, with a reference to `status_code`.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `ORDER_STATUS` | 每个已放置订单的状态，并参考`status_code`。|'
- en: '| `STATUS_CODE` | Lookup table for order and shipment status codes. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `STATUS_CODE` | 订单和运输状态代码的查找表。|'
- en: '| `COURIER` | Shipping courier information, including courier name, contact,
    and so on. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `COURIER` | 运输快递信息，包括快递名称、联系方式等。|'
- en: '| `SHIPMENT_REQUEST` | A list of all shipping requests for orders placed. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `SHIPMENT_REQUEST` | 订单放置的所有运输请求列表。|'
- en: '| `SHIPMENT_REQUEST_STATUS` | The status of each shipment request, with a reference
    to `status_code`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `SHIPMENT_REQUEST_STATUS` | 每个运输请求的状态，包含对`status_code`的引用。|'
- en: 'Table 2.2: The ABC-Monolith database tables list'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2：ABC-Monolith数据库表列表
- en: 'The following is ABC’s **Entity Relationship Diagram** (**ERD**). Note that
    we needed to create the **ORDER_ITEM** normalization table to break up the many-to-many
    relationship between both the **ORDER** and **ITEM** tables:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容是ABC的**实体关系图**（**ERD**）。请注意，我们需要创建**ORDER_ITEM**规范化表来分解**ORDER**和**ITEM**表之间的多对多关系：
- en: '![Figure 2.2: The ABC-Monolith ERD](img/B18934_02_2.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：ABC-Monolith的实体关系图](img/B18934_02_2.jpg)'
- en: 'Figure 2.2: The ABC-Monolith ERD'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：ABC-Monolith的实体关系图
- en: Keep in mind that some of the monolith’s functions require full read/write access
    to specific tables with access to all fields in the table, while some other functions
    need only access to specific fields in the table. This information is important
    in system refactoring.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，单体应用中的一些功能需要完全的读写访问特定表，并访问表中所有字段，而其他一些功能只需要访问表中的特定字段。这些信息在系统重构中非常重要。
- en: In the following section, we will go over the workflow to identify the ABC-Monolith
    As-Is state and determine how we can transition into the To-Be state. Along with
    the workflow information, the function database access requirements will help
    us refactor the monolith database into individual MSA databases for each microservice.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论工作流程以识别ABC-Monolith的当前状态（As-Is）并确定我们如何过渡到待实现状态（To-Be）。除了工作流程信息外，功能数据库访问需求将帮助我们重构单体数据库，将其分解为每个微服务的独立MSA数据库。
- en: The ABC workflow and current function calls
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这是ABC的工作流程和当前功能调用
- en: 'We know so far what functions are used in the monolith and how the monolith’s
    database is structured. The next step is to examine the order placement workflow:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前已知在单体应用中使用了哪些功能以及单体数据库的结构是如何组织的。下一步是检查订单放置的工作流程：
- en: '![Figure 2.3: The ABC-Monolith function requests/workflow](img/B18934_02_3.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：ABC-Monolith的功能请求/工作流程](img/B18934_02_3.jpg)'
- en: 'Figure 2.3: The ABC-Monolith function requests/workflow'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：ABC-Monolith的功能请求/工作流程
- en: As shown in the preceding workflow diagram, the individual functions are all
    executed sequentially. Since it is all one tightly coupled system, there are no
    synchronization issues expected, and hence no orchestration is needed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的工作流程图所示，各个功能都是顺序执行的。由于这是一个紧密耦合的系统，预期不会有同步问题，因此不需要编排。
- en: As we move toward the ABC-MSA, however, the decoupling of services creates the
    need to have a centralized point for managing the execution of these services
    in a specific sequence.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们朝着ABC-MSA迈进时，服务的解耦产生了在特定顺序中管理这些服务执行的需要。
- en: Shown in the following diagram are ABC’s As-Is and To-Be states. No centralized
    management in the As-Is state is needed; however, an orchestrator component is
    introduced in the To-Be state to manage the process flows between the services.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图中展示了ABC的当前状态（As-Is）和待实现状态（To-Be）。在当前状态（As-Is）中不需要集中管理；然而，在待实现状态中引入了一个编排器组件来管理服务之间的流程。
- en: Each of the individual services in the To-Be states has a dedicated database,
    as shown in the diagram. In the As-Is state, on the other hand, the database is
    centralized.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在待实现状态下，每个单独的服务都有一个专门的数据库，如图所示。相反，在当前状态（As-Is）中，数据库是集中的。
- en: '![Figure 2.4: The ABC As-Is and To-Be states](img/B18934_02_4.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：ABC的当前状态（As-Is）和待实现状态（To-Be）](img/B18934_02_4.jpg)'
- en: 'Figure 2.4: The ABC As-Is and To-Be states'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：ABC的当前状态（As-Is）和待实现状态（To-Be）
- en: Now that we know how our current ABC-Monolith is structured, and what both the
    as-is and to-be states are, it is time to start the ABC-Monolith refactoring process
    to transform into the ABC-MSA.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了当前的ABC-Monolith是如何组织的，以及当前状态（As-Is）和待实现状态（To-Be）是什么，那么现在是时候开始ABC-Monolith的重构过程，以转化为ABC-MSA。
- en: We will refactor the monolith in three stages. First, we will decompose the
    monolith functions and map these functions to microservices. Then, we will decompose
    the data to see how the individual databases will be designed. Finally, out of
    the monolith’s workflow, we will analyze the function requests, and build our
    MSA sagas from there.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分三个阶段重构单体应用。首先，我们将分解单体功能并将这些功能映射到微服务上。然后，我们将分解数据以查看如何设计各个数据库。最后，从单体应用的工作流程中，我们将分析功能请求，并据此构建我们的MSA叙事。
- en: Function decomposition
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能分解
- en: The first step in refactoring the ABC-monolith is to create the microservices
    based on the system functions we previously identified. This is a straightforward
    mapping between the existing functions and the microservices.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重构ABC单体应用的第一步是根据我们之前确定的应用系统功能创建微服务。这是现有功能和微服务之间的一种直接映射。
- en: The key point here is that, by looking only at each function by itself without
    considering any function calls or data connections, you need to be as granular
    as possible in your function decomposition.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，仅通过单独查看每个函数，而不考虑任何函数调用或数据连接，你在函数分解中需要尽可能细化。
- en: At first glance, the `notify_user()` function is doing too many things for a
    microservice, displaying a web user message status/update, notifying the user
    by email, and/or notifying the user by SMS. Each of these functions can have its
    own rules, design, issues, and concerns. Splitting the `notify_user()` function
    into three functions is a better approach from an MSA perspective to achieve the
    separation of concerns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，`notify_user()` 函数对于一个微服务来说做了太多事情，包括显示网络用户消息状态/更新，通过电子邮件通知用户，以及/或者通过短信通知用户。每个这些功能都可以有自己的规则、设计、问题和关注点。从微服务架构（MSA）的角度来看，将
    `notify_user()` 函数拆分为三个函数是一个更好的方法，以实现关注点的分离。
- en: 'Accordingly, we split the `notify_user()` function into one function for handling
    web messages and notifications, one for handling email notifications, and one
    for SMS message notifications:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将 `notify_user()` 函数拆分为一个处理网络消息和通知的函数，一个处理电子邮件通知的函数，以及一个处理短信消息通知的函数：
- en: '`web_msg_notification()`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web_msg_notification()`'
- en: '`email_notification()`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email_notification()`'
- en: '`sms_notification()`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sms_notification()`'
- en: 'Similarly, the `process_payment()` function can also be split into two different,
    more granular functions, one for handling direct credit card payments and one
    for handling PayPal payments:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`process_payment()` 函数也可以拆分为两个不同的、更细粒度的函数，一个用于处理直接信用卡支付，另一个用于处理PayPal支付：
- en: '`verify_cc_payment()`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verify_cc_payment()`'
- en: '`verify_paypal_payment()`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verify_paypal_payment()`'
- en: The following diagram shows how the ABC-Monolith is broken up so far. We haven’t
    yet looked into how the system’s functions are interacting with each other. The
    function interactions and the order fulfillment’s overall workflow will be handled
    at a later stage.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了ABC-Monolith目前的拆分情况。我们还没有研究系统函数之间是如何相互作用的。函数交互和整体订单履行的流程将在稍后的阶段处理。
- en: '![Figure 2.5: The ABC-Monolith function decomposition](img/B18934_02_5.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5：ABC-Monolith功能分解](img/B18934_02_5.jpg)'
- en: 'Figure 2.5: The ABC-Monolith function decomposition'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：ABC-Monolith功能分解
- en: At this point, we are satisfied with the current level of granularity so far
    and we are ready to examine how the database tables are being accessed to see
    whether further decomposition is needed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们对目前的粒度水平感到满意，并准备检查数据库表是如何被访问的，以查看是否需要进一步的分解。
- en: Data decomposition
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分解
- en: During this stage, we need to look at how each function is accessing the database
    and what tables and even which parts of the database tables are accessed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们需要查看每个函数是如何访问数据库的，以及访问了哪些表，甚至数据库表的哪些部分。
- en: The following diagram shows what parts of the database the ABC-Monolith functions
    access. It is essential to know exactly which tables are accessed by which function
    and why. This will help us identify database dependencies, in order to later eliminate
    these dependencies and split the centralized ABC-Monolith database into separate
    data stores, each data store dedicated to each microservice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了ABC-Monolith函数访问数据库的哪些部分。确切知道哪个函数访问了哪些表以及为什么是至关重要的。这将帮助我们识别数据库依赖关系，以便稍后消除这些依赖关系，并将集中的ABC-Monolith数据库拆分为单独的数据存储，每个数据存储都专门用于每个微服务。
- en: '![Figure 2.6: ABC-Monolith database access](img/B18934_02_6.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6：ABC-Monolith数据库访问](img/B18934_02_6.jpg)'
- en: 'Figure 2.6: ABC-Monolith database access'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：ABC-Monolith数据库访问
- en: We are still bound by the microservice autonomy rule. The challenging part in
    the diagram and this refactoring phase is the shared tables. Sharing a table between
    two microservices creates coupling that would clearly violate the autonomy rule.
    On the other hand, creating multiple copies of the table across different microservices
    will create serious data consistency issues. So, how do we solve this conundrum?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然受限于微服务自治规则。在图表和这个重构阶段中具有挑战性的部分是共享的表。在两个微服务之间共享一个表会创建违反自治规则的耦合。另一方面，在多个微服务中创建表的多个副本将导致严重的数据一致性问题。那么，我们如何解决这个难题呢？
- en: Remember the `ORDER` table, for example, across the `place_order()`, `create_order()`,
    and `process_payment()` services of the ABC-MSA system. A similar approach is
    taken for `check_inventory()`, `update_inventory()`, and so on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，记住`ORDER`表，它在ABC-MSA系统的`place_order()`、`create_order()`和`process_payment()`服务中。对于`check_inventory()`、`update_inventory()`等，采取类似的方法。
- en: So, with saga patterns in mind, let’s reexamine the ABC-Monolith database access
    shown in the preceding diagram, to build a new database access diagram for services
    in the ABC-MSA system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到叙事模式，让我们重新审视前面图表中显示的ABC-Monolith数据库访问，为ABC-MSA系统中的服务构建一个新的数据库访问图表。
- en: There are two ways to coordinate the data transactions, choreography and orchestration.
    In choreography, the ABC-MSA saga participant services will have to coordinate
    data transactions among themselves. In orchestration, a centralized orchestrator
    performs the coordination process and handles all workflow transactions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 协调数据事务有两种方式，即协调和编排。在协调中，ABC-MSA叙事参与者服务将不得不自行协调数据事务。在编排中，一个集中的编排器执行协调过程并处理所有工作流事务。
- en: Certainly, we can choose either coordination methodology, but in our example,
    we would argue that orchestration creates a better decoupling model over choreography.
    For that reason, and to keep our example simple, we will be using orchestration
    for our ABC-MSA saga patterns.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以选择任何一种协调方法，但在我们这个例子中，我们会认为编排比协调提供了更好的解耦模型。因此，为了保持我们的例子简单，我们将使用编排来构建我们的ABC-MSA叙事模式。
- en: The following diagram shows the ABC-MSA service database access. As you can
    see in the diagram, there are a few database tables that have been copied across
    the system. We will, in the next section, use saga patterns to maintain data consistency
    across the copied tables.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了ABC-MSA服务数据库访问。如图所示，系统中已经复制了一些数据库表。在下一节中，我们将使用叙事模式来维护复制表之间的数据一致性。
- en: '![Figure 2.7: ABC-MSA database access](img/B18934_02_7.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7：ABC-MSA数据库访问](img/B18934_02_7.jpg)'
- en: 'Figure 2.7: ABC-MSA database access'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：ABC-MSA数据库访问
- en: We notice in other services, such as `notify_user()` function may not be a good
    idea anyway. You should only see small database access similarities between these
    different services, not a completely identical database. In a real scenario, we
    are better off combining these three services into only one service as it originally
    was.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到在其他服务中，例如`notify_user()`函数可能根本不是一个好主意。在这些不同的服务之间，你应该只看到小的数据库访问相似性，而不是完全相同的数据库。在现实场景中，我们最好将这三个服务合并成一个最初的服务。
- en: Similarly, in a real-life scenario, the `process_payment()` function is likely
    to be mapped to a single service that includes clearing the payment overall, regardless
    of whether it is a credit card, PayPal, or any other form of payment. For demo
    purposes, we will split `notify_user()` and `process_payment()` into three and
    two different services respectively.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在现实场景中，`process_payment()`函数可能被映射到包含整体清除支付的单个服务，无论它是信用卡、PayPal还是任何其他支付形式。为了演示目的，我们将`notify_user()`和`process_payment()`分别拆分为三个和两个不同的服务。
- en: So far, we have been able to build the ABC-MSA’s microservices from the ABC-Monolith
    functions, identify data access in the monolith, and decompose the monolith into
    separate microservices, each with its own database. In the next section, we will
    focus more on how to ensure isolation and separation of concerns for the microservices
    by looking into how the service requests are orchestrated in the new ABC-MSA system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够从ABC-Monolith函数构建ABC-MSA的微服务，识别单体中的数据访问，并将单体分解为独立的微服务，每个微服务都有自己的数据库。在下一节中，我们将更多地关注如何通过查看新ABC-MSA系统中服务请求的编排来确保微服务的隔离和关注点分离。
- en: Request decomposition
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求分解
- en: The ABC-Monolith function request flow has already been identified and shown
    in *Figure 1**.3*. We will now see how this flow is going to work in the ABC-MSA.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ABC-Monolith 功能请求流程已经确定并显示在 *图 1**.3* 中。我们现在将看到这个流程在 ABC-MSA 中是如何工作的。
- en: In the ABC-MSA, the sagas are programmed and configured in the centralized orchestrator.
    The orchestrator will initiate separate API calls to each service in the saga,
    in either a synchronous or asynchronous fashion, depending on the defined workflow,
    and wait for a response from each API call to determine what other API call(s)
    to initiate next and how.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ABC-MSA 中，sagas 是在集中式协调器中编程和配置的。协调器将根据定义的工作流程以同步或异步的方式对 sagas 中的每个服务发起单独的
    API 调用，并等待每个 API 调用的响应，以确定接下来要发起的其他 API 调用以及如何进行。
- en: The following diagram shows how the workflow would be in the ABC-MSA. Please
    note that all API calls in our scenario are being initiated from the orchestrator.
    As you can see from the sequence number, there are some API calls initiated in
    parallel, and in some other cases, the orchestrator decides the next course of
    action based on the response it receives from a previously executed service.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了 ABC-MSA 中工作流程的形态。请注意，我们场景中的所有 API 调用都是从协调器发起的。如您从序列号中看到的那样，有一些 API
    调用是并行发起的，而在其他情况下，协调器根据从先前执行的服务收到的响应来决定下一步的行动。
- en: '![Figure 2.8: The ABC-MSA workflow](img/B18934_02_8.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8：ABC-MSA 工作流程](img/B18934_02_8.jpg)'
- en: 'Figure 2.8: The ABC-MSA workflow'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：ABC-MSA 工作流程
- en: The user in the ABC-MSA workflow diagram initiates the order fulfillment process
    from a web interface, which will kick off the workflow from the orchestrator.
    Both the **place_order** and **check_inventory** services are launched at the
    same time by the orchestrator. **place_order** creates the order with all its
    information and marks its state as **pending**, waiting for the rest of the workflow
    to be processed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ABC-MSA 工作流程图中的用户从网页界面启动订单履行过程，这将从协调器启动工作流程。协调器同时启动 **place_order** 和 **check_inventory**
    服务。**place_order** 创建带有所有信息的订单，并将其状态标记为 **pending**，等待工作流程的其余部分处理。
- en: The **check_inventory** service checks the inventory of items ordered and sends
    back a **true** or **false** response depending on whether the item is available
    or not. If any of the items ordered are not available, the **web_msg_notification**,
    **email_notification**, and **sms_notification** services are triggered.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**check_inventory** 服务检查已订购项目的库存，并根据项目是否可用发送 **true** 或 **false** 的响应。如果任何订购的项目不可用，则触发
    **web_msg_notification**、**email_notification** 和 **sms_notification** 服务。'
- en: 'Now, here is the first challenge: all three notification services will require
    access to the `CUSTOMER` database in order to get the customer’s name, email address,
    phone number, and so on. But having one database for all three services creates
    undesired coupling that would violate the microservices autonomy principle. As
    we discussed earlier, we should instead create copies of that `CUSTOMER` database
    across all services to avoid service coupling. But how do we do that?'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个挑战：所有三个通知服务都需要访问 `CUSTOMER` 数据库以获取客户姓名、电子邮件地址、电话号码等。但是，为所有三个服务使用一个数据库会创建不希望的耦合，这会违反微服务自治原则。正如我们之前讨论的，我们应该在所有服务中创建该
    `CUSTOMER` 数据库的副本，以避免服务耦合。但我们如何做到这一点呢？
- en: '![Figure 2.9: Maintaining database consistency across MSA](img/B18934_02_9.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9：在 MSA 中维护数据库一致性](img/B18934_02_9.jpg)'
- en: 'Figure 2.9: Maintaining database consistency across MSA'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：在 MSA 中维护数据库一致性
- en: The `CUSTOMER` database is mainly managed by the `CUSTOMER` database whenever
    a record is edited, created, or deleted.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUSTOMER` 数据库在编辑、创建或删除记录时主要由 `CUSTOMER` 数据库管理。'
- en: The orchestrator will need to wait for a success confirmation from all four
    services, `CUSTOMER` database fails? You will end up with data inconsistency,
    which can be a serious issue later on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 协调器需要等待来自所有四个服务的成功确认，`CUSTOMER` 数据库失败？你最终会得到数据不一致，这可能会成为以后的一个严重问题。
- en: That’s why all saga participants’ local transactions will need to have a set
    of compensating transactions to ensure a rollback in case of any failures in executing
    the transaction. In our example, the orchestrator will need to undo updates to
    the `CUSTOMER` database for all the other services.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有参与 sagas 的本地事务都需要有一组补偿事务，以确保在执行事务过程中出现任何故障时能够回滚。在我们的示例中，协调器需要撤销对其他所有服务的
    `CUSTOMER` 数据库的更新。
- en: The following diagram shows how a failure to update the `CUSTOMER` database
    should be rolled back using saga patterns.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了如何使用叙事模式回滚更新`CUSTOMER`数据库的失败。
- en: '![Figure 2.10: Compensating transactions for registering new customer information
    and placing an order](img/B18934_02_10.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10：为注册新客户信息和下订单进行补偿事务](img/B18934_02_10.jpg)'
- en: 'Figure 2.10: Compensating transactions for registering new customer information
    and placing an order'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：为注册新客户信息和下订单进行补偿事务
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were able to go over the main steps of refactoring a monolith
    into an MSA, the steps necessary, the main things to consider, and the methodology
    of doing so. The simplified ABC-Monolith system was a good example; however, as
    systems get more complicated and the workflow gets more involved, data and process
    synchronization challenges start to arise.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够回顾将单体架构重构为微服务架构（MSA）的主要步骤，包括必要的步骤、需要考虑的主要事项以及实现的方法。简化的ABC单体系统是一个很好的例子；然而，随着系统变得更加复杂，工作流程变得更加复杂，数据和处理同步的挑战开始出现。
- en: In [*Chapter 1*](B18934_01.xhtml#_idTextAnchor014), we briefly discussed the
    challenges and the methodologies to be applied to overcome these challenges. In
    the next chapter, we will start applying the methodology to the ABC system we
    are trying to refactor.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18934_01.xhtml#_idTextAnchor014)中，我们简要讨论了面临的挑战以及应用的方法来克服这些挑战。在下一章中，我们将开始将这种方法应用到我们试图重构的ABC系统上。
- en: In the next chapter, we will discuss how we can further maintain microservices’
    autonomy and MSA stability and overcome some other operational challenges, and
    the role of API gateways, orchestrators, and microservice aggregators.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何进一步维护微服务的自主性和MSA的稳定性，克服一些其他操作挑战，以及API网关、编排器和微服务聚合器的作用。
