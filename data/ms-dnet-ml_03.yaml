- en: Chapter 3. More AdventureWorks Regression
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。更多AdventureWorks回归
- en: In the last chapter, you had your software developer hat on and you stuck your
    toe into machine learning waters. You created a simple linear regression and implemented
    it in your website. The regression attempted to explain how customer reviews affected
    bike sales quantity to retail shops. In this chapter, we are going to pick up
    where we left off and use a multiple linear regression to explain bike sales with
    more precision. Then we will switch over to a logistic regression to see if we
    can predict whether an individual customer will or will not purchase a bike based
    on the same factors. We will then consider how to implement the regression in
    an experiment that will help with the model's accuracy and repeatability. Finally,
    we will wrap up by considering some of the strengths and weaknesses of regressions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你戴着软件开发者的帽子，你试探性地进入了机器学习的水域。你创建了一个简单的线性回归并将其应用于你的网站。这个回归试图解释顾客评论如何影响零售店的自行车销量。在这一章中，我们将继续上一章的内容，使用多元线性回归来更精确地解释自行车销量。然后我们将切换到逻辑回归，看看我们是否可以根据相同因素预测单个顾客是否会购买自行车。然后我们将考虑如何在一个有助于模型准确性和可重复性的实验中实现回归。最后，我们将总结一些回归的优缺点。
- en: Introduction to multiple linear regression
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多元线性回归简介
- en: 'A multiple linear regression has the same concept as a simple linear regression,
    in that we are trying to find the best fit. The major difference is that we have
    more than one independent variable that is trying to explain the dependent variable.
    If you remember from the last chapter, we made a regression like this: *Y = x0
    + E*, where *Y* was bike sales and *x0* was average ratings.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 多元线性回归与简单线性回归具有相同的概念，即我们试图找到最佳拟合。主要区别在于我们有多于一个的自变量试图解释因变量。如果你还记得上一章，我们做了如下回归：*Y
    = x0 + E*，其中*Y*是自行车销量，*x0*是平均评分。
- en: If we want to see whether there is a relationship between average rating and
    price of the bike on bike sales, we can use the formula *Y = x0 + x1 + E*, where
    *Y* is bike sales, *x0* is the average ratings, and *x1* is the price of the bike.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想看看平均评分和自行车销售价格之间是否存在关系，我们可以使用公式*Y = x0 + x1 + E*，其中*Y*是自行车销量，*x0*是平均评分，*x1*是自行车的价格。
- en: Intro example
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍示例
- en: Before diving into actual data, let's dissect a multiple linear regression.
    Open up Visual Studio and create a new F# library project. Add a script file called
    `AccordDotNet.fsx`. Next, add a NuGet reference to `Accord.Statistics`. If you
    are unfamiliar with how to do any of those tasks, review [Chapter 1](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055
    "Chapter 1. Welcome to Machine Learning Using the .NET Framework"), *Welcome to
    Machine Learning Using the .NET Framework*, and [Chapter 2](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 2. AdventureWorks Regression"), *AdventureWorks Regression*, where each
    step is detailed using screenshots.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究实际数据之前，让我们剖析一下多元线性回归。打开Visual Studio并创建一个新的F#库项目。添加一个名为`AccordDotNet.fsx`的脚本文件。接下来，添加对`Accord.Statistics`的NuGet引用。如果你不熟悉如何执行这些任务中的任何一项，请回顾[第1章](part0015_split_000.html#E9OE1-a18db0be6c20485ba81f22e43ca13055
    "第1章。使用.NET框架进行机器学习欢迎")，*使用.NET框架进行机器学习欢迎*，以及[第2章](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "第2章。AdventureWorks回归")，*AdventureWorks回归*，其中每个步骤都使用截图进行了详细说明。
- en: 'At the top of your script, add in the following references:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部添加以下引用：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, let's create a dummy dataset. In this case, let's see if there is a relationship
    between a student's age, their IQ, and their GPA. Since there are two independent
    variables (`x0` and `x1`), we will create an input value called, well, `xs` and
    see it with five observations. Since there are two values for each observation,
    `xs` is a jagged array.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个虚拟数据集。在这种情况下，让我们看看学生的年龄、智商和GPA之间是否存在关系。由于有两个自变量（`x0`和`x1`），我们将创建一个名为`xs`的输入值，并用五个观察值来查看它。由于每个观察值有两个值，`xs`是一个锯齿数组。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Sending it to the REPL, we get:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们得到：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this dataset, the first observation is a 15 year old with a 130 IQ, the
    second is an 18 year old with a 127 IQ, and so on. With the inputs taken care
    of, let''s create the `y`, which is the student''s GPA:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数据集中，第一个观察对象是一个15岁的130智商的个体，第二个是一个18岁的127智商的个体，以此类推。在处理完输入后，让我们创建`y`，即学生的GPA：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Sending to the REPL, we get:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL，我们得到：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first student has a 3.6 GPA, the second has a 3.5, and so on. Notice that
    since our output is a single number, we only need a simple array to hold the values.
    With our inputs taken care of, let''s create a multiple linear regression with
    our `xs` and `y`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个学生的GPA是3.6，第二个是3.5，以此类推。请注意，由于我们的输出是一个单一的数字，我们只需要一个简单的数组来保存这些值。处理完输入后，让我们使用我们的`xs`和`y`创建一个多重线性回归：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Sending this to the REPL, we get:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are a couple of things to notice. First, Accord printed the formula of
    our multiple linear regression for us as `y(x0, x1) = 0.0221298495645295*x0 +
    0.0663103721298495*x1 + -5.20098970704672`. The key thing to notice is that you
    cannot interpret the results of multiple regressions the same as the simple regression,
    for example, summing `x1` and `x2` together to be the slope of a line would be
    incorrect. Rather, each `x` is the slope of the line if the other `x` is held
    constant. So, in this case, if `x1` is held constant, each change of one unit
    of `x0` changes `y` `.022`. Back to our example, we can say that if we increase
    a person's age by one year, a person's GPA increases by .022, holding the IQ constant.
    Similarly, we can say that for every one point drop in a person's IQ, the person's
    GPA drops 0.066, holding the person's age constant. We can't use a scatterplot
    to show all of the results of a multiple regression the way we can with a simple
    regression because you would need an axis for each `x` value and that quickly
    will get unwieldy, if not impossible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意。首先，Accord为我们打印了多重线性回归的公式`y(x0, x1) = 0.0221298495645295*x0 + 0.0663103721298495*x1
    + -5.20098970704672`。需要注意的关键点是，你不能像简单回归那样解释多重回归的结果，例如，将`x1`和`x2`相加来作为线的斜率是不正确的。相反，每个`x`是如果其他`x`保持不变时的线的斜率。所以，在这种情况下，如果`x1`保持不变，`x0`每增加一个单位，`y`就会增加`.022`。回到我们的例子，我们可以这样说，如果我们增加一个人的年龄一年，一个人的GPA会增加`.022`，同时保持智商不变。同样，我们可以这样说，对于一个人的智商每下降一个点，这个人的GPA会下降0.066，同时保持年龄不变。我们不能像简单回归那样使用散点图来展示多重回归的所有结果，因为你需要为每个`x`值设置一个轴，这很快就会变得难以控制，甚至不可能。
- en: 'Next, let''s see how good our regression is using our old friends `r2` and
    `rmse`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的回归效果如何，使用我们熟悉的老朋友`r2`和`rmse`：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sending this to the REPL, we get:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that `sse` is the same as the error from above. Accord.NET returns `sse`
    as an error, so I will just use that in the future. Also, looking at our result,
    we can see that we have an `r2` of `.79`, which is pretty good and that our `rmse`
    is `.18`, which is also low enough that the regression is a viable one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sse`与上面的误差相同。Accord.NET将`sse`作为误差返回，所以我会以后只使用它。此外，查看我们的结果，我们可以看到我们的`r2`是`.79`，这相当不错，而且我们的`rmse`是`.18`，这也足够低，使得回归是可行的。
- en: Keep adding x variables?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续添加x变量？
- en: 'If two `x` variables are good, are three better? Let''s take a look. Let''s
    add another variable, in this case, the student''s prior year GPA as a third `x`
    value. Go back to the REPL and add this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个`x`变量是好的，那么三个会更好吗？让我们看看。让我们添加另一个变量，在这种情况下，学生的前一年GPA作为第三个`x`值。回到REPL并添加以下内容：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sending this to the REPL, we get:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们得到：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So the `r2` is now up to 99%, which means we can explain 99% of the change in
    a person's GPA using their age, IQ, and prior year GPA. Also, note that the `rmse`
    is `.04`, which is nice and low. We have a pretty good model.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`r2`现在达到了99%，这意味着我们可以用一个人的年龄、智商和前一年GPA来解释99%的GPA变化。此外，请注意，`rmse`是`.04`，这很好，也很低。我们有一个相当好的模型。
- en: AdventureWorks data
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AdventureWorks数据
- en: 'With the demo out of the way, let''s implement a multiple linear regression
    back at the bike company. Since we are using more realistic data, I don''t think
    we will get a 99% `r2`, but we can hope. In your **Solution Explorer**, add another
    F# script called `AccordDotNet2.fsx`. Then, add a reference to `System.Transactions`
    so that we can use ADO.NET to access our data. Go back to `AccordDotNet2.fsx`
    and add the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成演示后，让我们回到自行车公司实现多重线性回归。由于我们使用的是更真实的数据，我认为我们不会得到99%的`r2`，但我们可以期待。在你的**解决方案资源管理器**中，添加另一个名为`AccordDotNet2.fsx`的F#脚本。然后，添加对`System.Transactions`的引用，以便我们可以使用ADO.NET访问我们的数据。回到`AccordDotNet2.fsx`并添加以下代码：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that this is very similar to the code that you wrote in the prior chapter.
    In fact, you might want to copy and paste that code and make the following changes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与你在上一章中编写的代码非常相似。事实上，你可能想要复制并粘贴那段代码，并做出以下更改：
- en: Add a `ListPrice` field to the `ProductInfo` record type.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductInfo`记录类型中添加一个`ListPrice`字段。
- en: Update the query to add a clause to pull down the list price of the bike.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新查询以添加一个子句来获取自行车的零售价。
- en: Update `productInfos`. Add a method to include the third value we are bringing
    down.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `productInfos`。添加一个方法来包含我们正在带来的第三个值。
- en: 'The code itself shapes a data frame of a number of orders, average reviews,
    and average price by `productId` in SQL and brings it local. Sending this code
    to the REPL, we get the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身在 SQL 中创建了一个包含多个订单、平均评论和按 `productId` 计算的平均价格的 DataFrame，并将其本地化。将此代码发送到
    REPL，我们得到以下结果：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With the data down, let''s create a multiple linear regression. Add the following
    code to the script file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备好后，让我们创建一个多元线性回归。将以下代码添加到脚本文件中：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Sending this code to the REPL, we get:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码发送到 REPL，我们得到以下结果：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By adding the price of the bike, our `r2` moves from `.29` to `.35`. Also, our
    `rmse` moves from `2.77` to `2.65`. This change means we have a more accurate
    model with a smaller amount of error. Because this is better, let's add this to
    our production application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加自行车的价格，我们的 `r2` 从 `.29` 提高到 `.35`。我们的 `rmse` 也从 `2.77` 降低到 `2.65`。这种变化意味着我们有一个更精确的模型，误差更小。因为这是更好的，所以让我们将其添加到我们的生产应用程序中。
- en: Adding multiple regression to our production application
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多元回归添加到我们的生产应用程序中
- en: Open up the `AdventureWorks` solution that you started working on in the last
    chapter. In the **Solution Explorer**, navigate to the `AdventureWorks.MachineLearning`
    project and open `OrderPrediction.fs`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你在上一章开始工作的 `AdventureWorks` 解决方案。在 **解决方案资源管理器** 中，导航到 `AdventureWorks.MachineLearning`
    项目并打开 `OrderPrediction.fs`。
- en: 'Locate the `ProductReview` type and replace it with this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到 `ProductReview` 类型并将其替换为以下内容：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, go into the `OrderPrediction` type and find the line where the reviews
    value is assigned and replace it with this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入 `OrderPrediction` 类型并找到分配评论值的行，将其替换为以下内容：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, locate the query value and replace its contents with this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定位查询值并将其内容替换为以下内容：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, scroll down to the `PredictQuantity` function and locate the `reader.Read()`
    line of codes. Replace it with this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向下滚动到 `PredictQuantity` 函数并找到 `reader.Read()` 代码行。将其替换为以下内容：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, remove all of the remaining code in the `PredictQuantity` function
    starting with:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从以下内容开始删除 `PredictQuantity` 函数中剩余的所有代码：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Replace it with this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为以下内容：
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice we have to create a jagged array even though we are only entering in
    one `productInfo` for the final `regression.Compute()`. Also, notice that the
    `Compute` function returns an array, but since we are only entering in one value,
    the resulting array will always have a length of one. We used the `Seq.head` to
    pull the first value of the array. The head function comes in quite handy at certain
    times and we will be seeing it again in this book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使我们只为最终的 `regression.Compute()` 输入一个 `productInfo`，我们仍然需要创建一个交错数组。此外，注意
    `Compute` 函数返回一个数组，但由于我们只输入一个值，因此结果数组始终只有一个长度。我们使用了 `Seq.head` 来获取数组的第一个值。在某些时候，这个头函数非常有用，我们将在本书中再次看到它。
- en: 'Build the project and open up the UI; you can see that our prediction has been
    adjusted:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目并打开 UI；你可以看到我们的预测已经被调整：
- en: '![Adding multiple regression to our production application](img/00053.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![将多元回归添加到我们的生产应用程序中](img/00053.jpeg)'
- en: Considerations when using multiple x variables
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个 x 变量时的注意事项
- en: At this point, you might be thinking, "This is great! I can keep adding more
    and more variables to my multiple linear regression and I will get a better and
    better `r2` and a lower `rmse`." As Lee Corso might say, "Not so fast!" Without
    getting too far into the details, every time you add a new feature of a linear
    multiple regression, you will always get a better result, or, at least, not a
    worse result. This means, if you add in the average temperature from different
    cities on June 29, 1999, the model might improve. Also, as you increase the number
    of features, the chance of introducing unwanted side effects into your model increases;
    we will talk about that in a little bit. In fact, I have seen some models where
    the number of features outnumber the number of observations. As a rule, this is
    a not a good idea.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能正在想，“这太棒了！我可以不断地添加更多的变量到我的多元线性回归中，并且我会得到更好的 `r2` 和更低的 `rmse`。”正如李·科索可能会说的，“别那么快！”在不深入细节的情况下，每次你添加一个新的线性多元回归特征，你总是会得到更好的结果，或者至少不会更差的结果。这意味着，如果你在1999年6月29日添加了不同城市的平均温度，模型可能会改进。此外，随着特征数量的增加，将不希望的影响引入模型的风险也会增加；我们将在稍后讨论这一点。实际上，我见过一些模型，其特征数量超过了观察数量。一般来说，这不是一个好主意。
- en: To combat feature growth, you can take two approaches. First, you can combine
    common sense with Occam's Razor. Occam's Razor is the notion that given a choice
    of possible solutions, the simplest one should always be chosen. This combination
    of sense and simplicity is more common and powerful than most people realize.
    The gray matter between the ears is a pretty powerful computer in its own right
    and can do a good job of seeing patterns and making relationships.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对抗特征增长，你可以采取两种方法。首先，你可以将常识与奥卡姆剃刀原理结合起来。奥卡姆剃刀原理是指，在给定可能的解决方案选择时，应该总是选择最简单的一个。这种常识与简洁的结合比大多数人意识到的更为常见和强大。我们大脑中的灰色物质本身就是一台相当强大的计算机，能够很好地识别模式和建立关联。
- en: Indeed, the business analyst who has spent time in the domain might know of
    relationships that are not apparent to an external data scientist looking at a
    laundry list of features or a basic machine learning model that is thrown at the
    data. Granted, humans do have biases and sometimes miss relationships, but on
    the whole, they are still good at matching patterns. Applying Occam's Razor to
    feature selection means that you are trying to find the fewest number of features
    that has the greatest impact on the model's predictability.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在特定领域投入过时间的商业分析师可能知道一些对外部数据科学家来说并不明显的关联关系。这些数据科学家面对的是一系列特征列表或被应用于数据的简单机器学习模型。诚然，人类确实存在偏见，有时会错过关联关系，但总体来说，他们仍然擅长匹配模式。将奥卡姆剃刀原理应用于特征选择意味着你正在尝试找到对模型可预测性影响最大的最少特征数量。
- en: Let's head over to our friendly business analyst at AdventureWorks and ask him
    what he thinks influences the quantity of bicycles purchased by our resellers.
    He says, "Well, I think that price and customer reviews are certainly very important,
    but I think that the weight of the bike influences our resellers. The heavier
    the bike, the less likely they are to order some."
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向我们的朋友，位于AdventureWorks的商业分析师，询问他认为什么因素影响了我们的经销商购买自行车的数量。他说：“嗯，我认为价格和客户评价当然非常重要，但我认为自行车的重量也会影响我们的经销商。自行车越重，他们订购的可能性就越小。”
- en: Adding a third x variable to our model
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的模型添加第三个x变量
- en: 'With the business analyst''s idea in mind, let''s add a third independent variable
    to our model, bike weight. Go back to the **Solution Explorer** and add another
    script file. Add the following code to the script:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 带着商业分析师的想法，让我们在我们的模型中添加第三个独立变量，即自行车重量。回到**解决方案资源管理器**，添加另一个脚本文件。将以下代码添加到脚本中：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Sending this to the REPL, notice that our `r2` goes to `.36` and our `rmse`
    drops to `2.63`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到交互式编程环境（REPL），你会发现我们的`r2`值上升到`.36`，而`rmse`值下降到`2.63`：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our analyst's intuition about price and customer reviews was spot on, the weight…not
    so much. Using Occam's Razor, we can use price and customer reviews for our model
    and ignore the weight variable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析师对价格和客户评价的直觉非常准确，而重量……则不然。使用奥卡姆剃刀原理，我们可以使用价格和客户评价来构建我们的模型，并忽略重量变量。
- en: Logistic regression
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑回归
- en: Now that we are becoming more comfortable with regressions, let's introduce
    another type of regression—the logistic regression. Up to this point, the regressions
    have had a numeric output value—like predicting a person's GPA or predicting the
    number of bikes sold. Logistic regressions use the same technique of fitting a
    group of independent features to a line, but they do not attempt to predict a
    number. Rather, a logistic regression attempts to predict a binary value (yes/no,
    true/false, tastes great/less filling) and then assigns a probability to that
    value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对回归越来越熟悉了，让我们介绍另一种回归类型——逻辑回归。到目前为止，回归都有数值输出值——比如预测一个人的GPA或预测自行车销量。逻辑回归使用与拟合一组独立特征到直线相同的技巧，但它们并不试图预测一个数值。相反，逻辑回归试图预测一个二元值（是/否、真/假、味道好/不好），然后为该值分配一个概率。
- en: Intro to logistic regression
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑回归简介
- en: 'Since you have already had an introduction to regressions, we can skip straight
    to the code and see one in action. Open up the regression project and add a script
    called `AccordDotNet7.fsx`. Copy in the following lines of code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经对回归有了初步的了解，我们可以直接进入代码，看看一个实际的例子。打开回归项目，添加一个名为`AccordDotNet7.fsx`的脚本。复制以下代码行：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sending this to the REPL gives us:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到交互式编程环境（REPL）后，我们得到：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I pulled this dataset from Wikipedia and it represents 20 students, how many
    hours of studying they did the day before an exam, and whether they passed the
    exam represented as `0.0` for failure and `1.0` for pass. Looking at the `xs`,
    student 0 studied 0.5 hours and looking at the `y`, we can see that s/he did not
    pass the exam.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我从维基百科中提取了这个数据集，它代表了20名学生，他们在考试前一天学习的小时数，以及他们是否通过考试，用`0.0`表示失败，用`1.0`表示通过。查看`xs`，学生0学习了0.5小时，查看`y`，我们可以看到他没有通过考试。
- en: 'Next, let''s create our regression analysis and look at some results:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的回归分析并查看一些结果：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Sending this to the REPL gives this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL得到以下结果：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are plenty of new things going on here, so let''s take a look at them
    in turn. After we create an analysis, we compute the regression. The next item
    is `pValue`. `pValue` is a common measure of accuracy for logistic regressions.
    As we saw earlier, linear regressions typically use `rmse` and `r2` as a way to
    measure model accuracy. Logistic regressions can use those measures, but usually
    don''t. Unlike the linear regression where the model spits out an exact number
    using something called *least-squares*, the logistic regression uses something
    called *maximum-likelihood* where the regression iterates and tries different
    combinations of the input values to maximize the likelihood of the result. Therefore,
    the logistic regression needs to be run many times over the dataset and we can
    configure how precise we want the model to be. Graphically, it looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新的事情在进行中，所以让我们依次查看它们。在我们创建分析后，我们计算回归。下一个项目是`pValue`。`pValue`是逻辑回归中衡量准确度的常用指标。正如我们之前看到的，线性回归通常使用`rmse`和`r2`作为衡量模型准确度的方法。逻辑回归可以使用这些指标，但通常不使用。与使用称为*最小二乘法*的精确数字输出的线性回归不同，逻辑回归使用称为*最大似然法*的方法，其中回归会迭代并尝试不同的输入值组合以最大化结果的可能性。因此，逻辑回归需要在数据集上多次运行，我们可以配置我们希望模型有多精确。从图形上看，它看起来像这样：
- en: '![Intro to logistic regression](img/00054.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![逻辑回归简介](img/00054.jpeg)'
- en: Coming back to `pValue`, it is a measure of how well our model compares to the
    `null` hypothesis, or basically, how well our model compares to a completely random
    model. If the `pValue` is less than 0.05, our model is valid. If the number is
    above 0.05, the model is no better than a random one. You might be asking yourself,
    "What is so special about 0.05?" The exact answer resides in some low-level mathematical
    functions that are beyond the scope of this book. The rough answer is, well, that
    is what everyone uses so that is what Accord baked in. If you don't find that
    explanation satisfactory, take a look at this post on Wikipedia ([https://en.wikipedia.org/wiki/P-value](https://en.wikipedia.org/wiki/P-value)).
    In any event, the 0.0006 is very good.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`pValue`，它是衡量我们的模型与`null`假设相比有多好的指标，或者说，我们的模型与一个完全随机的模型相比有多好。如果`pValue`小于0.05，我们的模型是有效的。如果数字高于0.05，模型与随机模型没有区别。你可能想知道，“0.05有什么特别之处？”确切的答案在于一些超出本书范围的底层数学函数。粗略的答案是，这是大家都在使用的，所以Accord内置了这个值。如果你觉得这个解释不满意，可以查看维基百科上的这篇帖子（[https://en.wikipedia.org/wiki/P-value](https://en.wikipedia.org/wiki/P-value)）。无论如何，0.0006是一个非常好的结果。
- en: 'Moving on to the next values, we see `GetOddsRatio` results:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来查看下一个值，我们看到`GetOddsRatio`的结果：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What this means is that if we didn''t study at all, we would have 1.6% chance
    of passing the exam. If we want to pass the exam, we need to study 4.5 hours.
    Next, take a look at the coefficients:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们完全不学习，我们通过考试的概率将是1.6%。如果我们想通过考试，我们需要学习4.5小时。接下来，看一下系数：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Accord.NET passes back an array for the coefficients, with the first value
    being the intercept. With these, you can create a formula to predict if a student
    can pass the exam given any input of hours of studying. For example, here are
    the predictions from our base dataset:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Accord.NET返回一个包含系数的数组，第一个值是截距。有了这些，你可以创建一个公式来预测给定任何学习小时数的学生是否能通过考试。例如，以下是我们的基础数据集的预测结果：
- en: '![Intro to logistic regression](img/00055.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![逻辑回归简介](img/00055.jpeg)'
- en: 'If we want to start playing with beer and hours of studying combinations (for
    example, "Will I pass if I study for 4.5 hours?"), we can do that using the `Compute`
    function. At the bottom of the script file, enter in:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想开始尝试啤酒和学习小时数的组合（例如，“如果我学习4.5小时，我会通过吗？”），我们可以使用`Compute`函数做到这一点。在脚本文件的底部输入：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Send it to the REPL for this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL进行以下操作：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So you have an 82% chance of passing if you study for 3.75 hours.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学习3.75小时，你有82%的通过率。
- en: Adding another x variable
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加另一个x变量
- en: 'Next, let''s add in another variable to our model—the number of beers you drank
    the night before the exam. Go back to your script file and add this to the bottom:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向我们的模型添加另一个变量——考试前一晚你喝了多少杯啤酒。回到你的脚本文件，并将其添加到底部：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Sending this to the REPL, we see:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，我们看到：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Evaluating the results, we still need to study 4.59 hours to pass, holding the
    number of beers constant. Also, we will need to drink less than .74 of a beer
    to pass. Notice that the odds ratio is positive, even though consuming more beer
    actually decreases our chance to pass. We know that there is an inverse relationship
    between the number of beers and the odds of passing because the coefficient for
    beer (-.029986) is negative.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 评估结果，我们仍然需要学习4.59小时才能通过，保持啤酒数量不变。此外，我们还需要喝不到0.74杯啤酒才能通过。请注意，即使喝更多的啤酒实际上降低了我们通过的机会，但几率比是正的。我们知道啤酒数量和通过几率之间存在反向关系，因为啤酒的系数（-0.029986）是负的。
- en: 'Now, we can start trading off studying hours and drinking beer on the chance
    of us passing the exam. Go to the script file and add in studying 4.5 hours and
    drinking one beer:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始权衡学习时间和喝酒的机会，以增加我们通过考试的可能性。转到脚本文件，并添加学习4.5小时和喝一杯啤酒的内容：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Sending it to the REPL:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将其发送到REPL：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So you have a 95% chance of passing if you drink a beer and study 4.5 hours.
    To further cement your odds, try filling out "B" on question 4 to push you over
    the top—that always worked for me in middle school.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你喝一杯啤酒并学习4.5小时，你有95%的通过率。为了进一步巩固你的机会，尝试在第四题中填写“B”，以帮助你冲过顶端——这在中学时对我总是有效。
- en: Applying a logistic regression to AdventureWorks data
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将逻辑回归应用于AdventureWorks数据
- en: 'So going back to a more realistic dataset, let''s take a look at AdventureWorks.
    Go ahead and add a new script file to the project. Call it `AccordDotNet8.fsx`.
    Copy and paste the following code into the script file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以回到一个更现实的数据库集，让我们看看AdventureWorks。请向项目中添加一个新的脚本文件。命名为`AccordDotNet8.fsx`。将以下代码复制并粘贴到脚本文件中：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Sending this to the REPL, you should see:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，你应该看到：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There's no new code here, so we can safely press on. However, I would like to
    note that this query might take a bit longer than any other query we have run
    against the database so far. This has an implication for how we architect our
    code when we integrate it to our application. We will discuss this in length in
    [Chapter 5](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055 "Chapter 5. Time
    Out – Obtaining Data"), *Time Out – Obtaining Data*, but for now, we just want
    to note it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的代码，所以我们可以安全地继续。然而，我想指出，这个查询可能比我们迄今为止对数据库进行的任何其他查询都要长一些。这会影响我们将代码集成到应用程序时的架构设计。我们将在[第5章](part0036_split_000.html#12AK81-a18db0be6c20485ba81f22e43ca13055
    "第5章。时间到——获取数据")中详细讨论这个问题，*时间到——获取数据*，但现在我们只想提一下。
- en: 'Going back to the script file, go ahead and add this code to the bottom:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 回到脚本文件，请将以下代码添加到底部：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Sending this to the REPL, you should get:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将此发送到REPL，你应该得到：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are some new pieces of code to look at and two new concepts. First, notice
    that a new record type was created for `ProductInfo` and the colors are broken
    out from a single column (`ProductType.Color`) to a series of 0.0/1.0 columns
    (`ProductType'.BlackInd`, `ProductType'BlueInd`, and so on). The reason I did
    not make the columns bool is that Accord.NET expects inputs to be a float and
    0.0/1.0 serves the purpose just as well. These columns are called "dummy" variables
    and they are used by logistic regressions to accommodate categorical data. At
    this point, you are probably asking, "What the heck is categorical data?" Fair
    question.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些新的代码片段需要查看，以及两个新的概念。首先，注意为`ProductInfo`创建了一个新的记录类型，颜色从单个列（`ProductType.Color`）拆分出来，变成一系列0.0/1.0列（`ProductType'.BlackInd`、`ProductType'BlueInd`等等）。我没有将这些列设置为bool类型的原因是Accord.NET期望输入为浮点数，而0.0/1.0同样可以满足这个目的。这些列被称为“虚拟变量”，它们被逻辑回归用来适应分类数据。此时，你可能正在问，“分类数据是什么东西？”这是一个合理的问题。
- en: Categorical data
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类数据
- en: 'You might not have noticed, but all of the `x` variables that we have used
    until this last query have been numeric—number of bikes sold, average reviews,
    number of beers drank, and the like. These values are considered continuous because
    they can be of infinite value. I can have one, two, or three beers. Similarly,
    the average reviews of a bike can be 3.45, 3.46, and so on. Because these values
    are treated as numbers, they can be added, averaged, and manipulated in all of
    the ways that you''ve learned since first grade. Note that continuous values can
    be range-bound: the average review can only be between 0.0 and 5.0 because that
    is what we limited users to enter.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到，但我们直到最后一个查询所使用的所有`x`变量都是数值型的——卖出的自行车数量、平均评论、喝下的啤酒数量等等。这些值被认为是连续的，因为它们可以是无限大的值。我可以喝一杯、两杯或三杯啤酒。同样，自行车的平均评论可以是3.45、3.46等等。因为这些值被视为数字，所以它们可以被相加、平均，并以你从一年级开始学习以来所有的方式操作。请注意，连续值可以有范围限制：平均评论只能介于0.0到5.0之间，因为这是我们限制用户输入的范围。
- en: 'Categorical values are different. Typically, they are integers that stand in
    for a non-numeric concept. For example, 0 might be male and 1 might be female.
    Similarly, the status of the sales order might be 1 for open, 2 for pending, 3
    for closed, and 4 for returned. Although these values are stored in the database
    as integers, they cannot be added, averaged, or otherwise manipulated. Categorical
    values may also be stored as strings, like we have seen for a bike color: "black",
    "blue", and the like. In this case, the range of strings is limited to a set from
    which numbers can be chosen.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 分类别值是不同的。通常，它们是代表非数字概念的整数。例如，0可能代表男性，1可能代表女性。同样，销售订单的状态可能是1表示开放，2表示待定，3表示关闭，4表示退货。尽管这些值在数据库中以整数形式存储，但它们不能被相加、平均或以其他方式操作。类别值也可以存储为字符串，就像我们看到的自行车颜色：“黑色”、“蓝色”等等。在这种情况下，字符串的范围被限制在可以从其中选择数字的集合中。
- en: 'Going back to our analysis, we have the bike color, which is a categorical
    value and is being stored as a string. We can''t send this string to Accord.NET
    as a single `x` variable because the `LogisticRegressionAnalysis` only takes in
    floats in the array. Note that in other statistical packages like R or SAS, you
    can pass in a string because there is behind-the-scenes code that translates those
    string values to numeric. So, back to color. We want to use it, but it has to
    become a float. We could create a new field called `ColorId` and hook up a translation
    function that turns each of the colors to a numeric representation like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的分析，我们有自行车颜色，这是一个类别值，正以字符串的形式存储。我们不能将这个字符串作为一个单独的`x`变量发送给Accord.NET，因为`LogisticRegressionAnalysis`只接受数组中的浮点数。请注意，在其他统计软件包如R或SAS中，你可以传递字符串，因为背后有代码将这些字符串值转换为数字。所以，回到颜色。我们想使用它，但必须将其转换为浮点数。我们可以创建一个新的字段`ColorId`，并连接一个转换函数，将每种颜色转换为如下的数字表示：
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And we will do that in other places in the book. However, using those numeric
    values makes no sense in our logistic regression because there is no real meaning
    in comparing values: an `oddsRatio` of 2.3 means what? In fact, no type of regression
    can make sense of categorical data coded in this way. Instead of building nonsensical
    values, we create dummy variables that can be interpreted with meaning in a regression.
    For each of the possible values of our categorical variable, we create a bool
    column that indicates whether that particular record has that value. Technically,
    we can create one less than the total possible values, but I find it easier to
    reason and display a column for each value. We can then pass these dummy variables
    into a regression and get a meaningful response.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其他地方这样做。然而，使用这些数值在我们的逻辑回归中是没有意义的，因为没有实际的意义来比较值：2.3的`oddsRatio`意味着什么？事实上，没有任何类型的回归能够理解以这种方式编码的类别数据。而不是构建无意义的值，我们创建虚拟变量，这些变量可以在回归中具有意义。对于我们的类别变量的每个可能值，我们创建一个bool列，表示该特定记录是否有该值。技术上，我们可以创建少于总可能值的列，但我发现为每个值创建一个列更容易推理和显示。然后我们可以将这些虚拟变量传递给回归，并得到有意义的响应。
- en: 'Also notice that I did the pattern matching for the colors assignment on one
    line like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我像这样在一行中做了颜色分配的模式匹配：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There is some heated controversy in the F# community about whether this is
    considered bad form: some people want to see each possible outcome of the pattern
    matching statement to be on one line, and others do not. I find it much more readable
    to keep everything on one line in cases like this, but I acknowledge it is a bit
    harder for someone new to F# from a curly-braced language like C#. If, however,
    you use ternary operators you should be comfortable with the syntax.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#社区中，关于这一点是否被视为不良做法存在一些激烈的争议：有些人希望看到模式匹配语句的每个可能结果都在一行上，而有些人则不这样认为。我发现在这种情况下，将所有内容保持在同一行上更容易阅读，但我承认这对从类似C#这样的花括号语言新接触F#的人来说可能有点困难。然而，如果你使用三元运算符，你应该对语法感到舒适。
- en: 'Also, notice that we changed our continuous variable of `Markup` to `High Margin`
    using this line of code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们使用这一行代码将连续变量`Markup`更改为`High Margin`：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Attachment point
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附件点
- en: 'Since logistic regressions need to have a 0.0 or 1.0 as a `y` variable, we
    need a way of splitting the data into something that has both business meaning
    and can be evaluated into 0.0 or 1.0\. How did I pick $800? I eyeballed it after
    doing this in the database:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逻辑回归需要将`y`变量设置为0.0或1.0，我们需要一种方法将数据分割成既有商业意义又能被评估为0.0或1.0的东西。我是怎么选择800这个数字的呢？我在数据库中做了这个操作后，凭直觉估计的：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That $800 number is often called the "attachment point" and is often the most
    discussed part of any logistic regression model. In the real world, that number
    is often set by the President of a small company on the back of a napkin, or,
    in a large company, a multi-disciplinary team that takes six weeks. The key thing
    to remember is that you want that number in your `config` file (if you are running
    your regression at real-time) or a separate variable at the top of your script
    (if doing it ad hoc). Note that to make our script even smarter, it is possible
    to inject in another model that determines the attachment point dynamically, so
    it will not require a human to update it, but that will be an exercise for another
    day.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个800的数字通常被称为“附件点”，并且通常是任何逻辑回归模型中最常讨论的部分。在现实世界中，这个数字通常是由小公司的总裁在餐巾纸上随意设定的，或者在大公司，一个跨学科团队可能需要六周时间。要记住的关键点是，你希望这个数字出现在你的`config`文件中（如果你是在实时运行回归）或者脚本顶部的单独变量中（如果你是临时做这件事）。请注意，为了让我们的脚本更加智能，我们可以在其中注入另一个模型来动态确定附件点，这样就不需要人工更新它，但这将是另一天的练习。
- en: Analyzing results of the logistic regression
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析逻辑回归的结果
- en: Notice that the colors are ordered in a random manner and are placed after the
    customer selects the model. What if we moved the colors to the first selection
    to get the user in the "black frame of mind" and then offer models? Also, perhaps
    we should move the color selection so that black is on top?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，颜色是以随机顺序排列的，并且在客户选择型号之后才出现。如果我们把颜色选项移到第一个选择，让用户进入“黑色思维模式”然后再提供型号，会怎样呢？也许我们还应该把颜色选择调整一下，让黑色位于顶部？
- en: While this is pretty good, this is a book about machine learning and there is
    little machine learning here to this point (unless you count the logistic regression's
    methodology in determining the answer, which I don't). How can we update our site
    automatically as customers' preferences change? What if all the cool kids started
    riding silver bikes? How can we quickly take advantage of this? How can the machine
    learn faster than the research analysts running the model periodically?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这已经相当不错了，但这本书是关于机器学习的，到目前为止这里几乎没有机器学习的内容（除非你把逻辑回归在确定答案时的方法算作机器学习，我不这么认为）。我们如何随着客户偏好的变化自动更新我们的网站？如果所有时髦的年轻人开始骑银色自行车，我们如何快速利用这一点？机器学习如何比定期运行模型的研究分析师学习得更快？
- en: We could do what we did in the last chapter and run the model on each page creation,
    create an evaluator of the model, and then populate the select list. However,
    if you remember about how long it took to run, it is a suboptimal solution because
    by the time it takes to run the model, most of our customers would abandon the
    site (though if they were using a mobile device, we can always blame the network
    connection; developers have never done this before). As an alternative, what if
    we created a process when the website started that constantly runs the model and
    caches the result? This way, each time the page is created, the data behind the
    select list is as fresh as it can be. Let's drop into Visual Studio and make it
    happen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像上一章所做的那样，在每一页创建时运行模型，创建模型的评估器，然后填充选择列表。然而，如果你还记得运行所需的时间，这并不是一个最优解，因为当模型运行时，我们的大部分客户可能会放弃网站（尽管如果他们使用的是移动设备，我们总是可以责怪网络连接；开发者以前从未这样做过）。作为替代方案，如果我们创建一个在网站启动时不断运行模型并缓存结果的进程会怎样？这样，每次创建页面时，选择列表背后的数据都将是最新鲜的。让我们进入
    Visual Studio 并让它实现。
- en: Adding logistic regression to the application
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向应用程序添加逻辑回归
- en: 'Open up the `AdventureWorks` solution and go to the `AdventureWorks.MachineLearning`
    project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `AdventureWorks` 解决方案，并转到 `AdventureWorks.MachineLearning` 项目：
- en: '![Adding logistic regression to the application](img/00057.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![向应用程序添加逻辑回归](img/00057.jpeg)'
- en: 'Add a new F# source file and name it `ColorPrediction.fs`. You will notice
    that it is placed at the bottom of the project. The order of the files is important
    in an F# project because of the type inference system. What you can do is right-click
    on the file and move it up above the `.config` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的 F# 源文件，并将其命名为 `ColorPrediction.fs`。你会注意到它被放置在项目的底部。在 F# 项目中，文件的顺序很重要，因为这是由于类型推断系统。你可以做的操作是右键单击文件，并将其移动到
    `.config` 文件之上：
- en: '![Adding logistic regression to the application](img/00058.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![向应用程序添加逻辑回归](img/00058.jpeg)'
- en: The Move Up option
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到上方选项
- en: 'Go into the `ColorPrediction.fs` file and replace all the existing code with
    the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `ColorPrediction.fs` 文件，并将所有现有代码替换为以下代码：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, let''s add in the types that we created in the regression project and
    the one type we need for this compiled assembly. While we''re at it, add in the
    list of `ProductInfos` and the connection string and query values from the regression
    project:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加在回归项目中创建的类型以及我们需要为此编译的汇编类型。在此过程中，添加 `ProductInfos` 列表以及回归项目中的连接字符串和查询值：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, let''s add a method that will return an ordered list of colors with the
    most important one on top:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个将返回按重要性排序的颜色列表的方法，最重要的颜色在顶部：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Most of the code is the same as the work we did in the regression project,
    but there is some new code that needs some explanation. There is now a string
    array called `colors` that lists all of the colors that we sent to our regression.
    After the `analysis.Compute()` is called, we remove the first value from the `analysis.CoefficientValues`
    via this line:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码与我们在回归项目中做的工作相同，但有一些新的代码需要解释。现在有一个名为 `colors` 的字符串数组，列出了我们发送给回归的所有颜色。在调用
    `analysis.Compute()` 之后，我们通过以下行从 `analysis.CoefficientValues` 中移除第一个值：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Skip is a handy function that allows us to, well, skip the first rows of `Seq`.
    We are calling it here because the `analysis.CoefficientValues` returns the coefficient
    in the first value of the array.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Skip 是一个方便的函数，允许我们跳过 `Seq` 的前几行。我们在这里调用它是因为 `analysis.CoefficientValues` 返回数组的第一值作为系数。
- en: 'Next, we call the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用以下内容：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have seen `Seq.zip` before. We are gluing together the colors array with
    the coefficient values array so each row is a tuple of the color name and its
    coefficient. With that array set up, we then implement the final transformation
    pipeline:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过 `Seq.zip`。我们正在将颜色数组和系数值数组粘合在一起，这样每一行就是一个颜色名称及其系数的元组。有了这个数组，我们接下来实现最终的转换管道：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first step is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步如下：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This applies a `mapi` function to `colors`. `Seq.mapi` is a high order function
    that is just like the `Seq.map` function with one extra parameter, the index of
    each row. So the index `i` is passed in and then the tuple `(c,cv)`, which is
    the color and the `coefficientValue`. We return a tuple with the color, a -1 or
    +1 depending on the sign of the `coefficientValue`, and the odds ratio ->, which
    we look up based on the index.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这对`colors`应用了一个`mapi`函数。`Seq.mapi`是一个高阶函数，它就像带有额外参数的`Seq.map`函数，该参数是每一行的索引。所以索引`i`被传递进去，然后是元组`(c,cv)`，即颜色和`coefficientValue`。我们返回一个包含颜色、一个根据`coefficientValue`符号的-1或+1，以及odds
    ratio ->的元组，我们根据索引查找它。
- en: 'The next step is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步如下：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This applies another function that returns the color and a signed odds ratio.
    If you remember from before, `Regression.GetOddsRatio` is always positive. We
    are applying the sign so we can order the ratios from most probable to the least
    probable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这应用了另一个返回颜色和有符号odds ratio的函数。如果您还记得之前的内容，`Regression.GetOddsRatio`总是正的。我们应用符号以便我们可以按最可能到最不可能的顺序对比率进行排序。
- en: 'The next step is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步如下：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This applies a function that sorts the array based on the odds ratio so that
    the tuple with the highest `oddsRatio` is on top.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这应用了一个根据odds ratio对数组进行排序的函数，使得具有最高`oddsRatio`的元组位于顶部。
- en: 'The next two steps turn the tuple into a simple string. The color name then
    transforms our `Seq` to an array:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个步骤将元组转换为简单的字符串。颜色名称然后将我们的`Seq`转换为数组：
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With the code in place, let''s hop over to our MVC project and implement it.
    Find the `Global.asax` file and open it up. Replace the code with the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码就位后，让我们跳转到我们的MVC项目并实现它。找到`Global.asax`文件并打开它。用以下代码替换代码：
- en: '[PRE53]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Some of this code might be new, so let''s take a closer look. First, we created
    two class-level variables: `_lock` and `_timer`. We use `_lock` to prevent our
    color array to be read while our regression could be updating it. You can see
    `_lock` in action in the public property that exposes the color array:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码可能有些新，让我们仔细看看。首先，我们创建了两个类级别变量：`_lock`和`_timer`。我们使用`_lock`来防止在回归更新颜色数组时读取颜色数组。您可以在公开属性中看到`_lock`的作用，该属性公开了颜色数组：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we create a method that will be called when our timer fires:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个当定时器触发时将被调用的方法：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice that we are creating an instance of our `ColorPrediction` class, which
    then invokes the `GetColors` method. We assign the `BikeColors` property with
    the return of our recently-calculated solution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在创建我们的`ColorPrediction`类的实例，然后调用`GetColors`方法。我们将`BikeColors`属性分配给最近计算出的解决方案的返回值。
- en: 'Finally, we instantiate the `_timer` variable in the `Application.Start` method,
    passing in the method that gets invoked when the timer counts down:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Application.Start`方法中实例化`_timer`变量，传入当定时器倒计时时的调用方法：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This means, every minute we call the color prediction to run the logistic regression
    based on the most recent data. Meanwhile, clients will be calling our website
    continuously and they will be getting an array of colors based on the most recent
    calculation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，每分钟我们都会调用颜色预测来运行基于最新数据的逻辑回归。同时，客户会持续调用我们的网站，并根据最新的计算结果获得一系列颜色。
- en: 'Next, go to the `.config` file and add the attachment point to the `appSettings`
    section:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到`.config`文件，并将附件点添加到`appSettings`部分：
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, open the `individualOrder` controller and replace the hardcoded values
    of colors with our generated one in the `Create` method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开`individualOrder`控制器，并在`Create`方法中将颜色的硬编码值替换为我们生成的值：
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the site and you will see that our color list has changed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 运行网站，您会看到我们的颜色列表已更改：
- en: '![Adding logistic regression to the application](img/00059.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![将逻辑回归添加到应用中](img/00059.jpeg)'
- en: We now have a pretty good model that seems to be working in production, without
    a major performance hit. However, our solution so far has a fatal flaw. We are
    guilty of overfitting. As mentioned in [Chapter 2](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "Chapter 2. AdventureWorks Regression"), *AdventureWorks Regression*, overfitting,
    is the notion that the model we create only works against the data we have on
    hand and fails miserably when we introduce it to new data. Every machine learning
    technique has a problem with overfitting, and there are some common ways to mitigate
    its impact. We will look at that in the coming chapters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个相当不错的模型，似乎在生产环境中运行良好，没有造成重大的性能损失。然而，我们迄今为止的解决方案有一个致命的缺陷。我们犯了过度拟合的错误。正如[第二章](part0024_split_000.html#MSDG2-a18db0be6c20485ba81f22e43ca13055
    "第二章. AdventureWorks回归")中提到的，*AdventureWorks回归*，过度拟合是指我们创建的模型只适用于我们手头的数据，当我们将它引入新数据时，表现糟糕。每种机器学习技术都存在过度拟合的问题，有一些常见的方法可以减轻其影响。我们将在接下来的章节中探讨这一点。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot of ground in this chapter. We looked at multiple linear regressions,
    logistic regressions, and then considered a couple of techniques to normalize
    our dataset. Along the way, we learned some new F# code and learned a way to update
    a machine learning model without impact on our end user experience.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了大量的内容。我们探讨了多元线性回归、逻辑回归，然后考虑了几种对数据集进行归一化的技术。在这个过程中，我们学习了一些新的F#代码，并了解了一种在不影响最终用户体验的情况下更新机器学习模型的方法。
- en: In the next chapter, we take a break from AdventureWorks and line of business
    development and start working with some open data as a data scientist using a
    decision tree. As Dick Clark used to say, "The hits just keep coming."
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从AdventureWorks和业务线开发中暂时休息一下，开始作为数据科学家使用决策树处理一些公开数据。正如迪克·克拉克曾经说过，“好歌源源不断。”
