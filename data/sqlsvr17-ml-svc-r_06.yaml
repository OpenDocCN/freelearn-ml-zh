- en: Predictive Modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测建模
- en: 'Predictive modeling is a process that is using advanced statistics and probability
    algorithms to predict outcomes, based on a pretrained and built model or function.
    These algorithms can be groups in a family of algorithms based on the outcome
    of the predicted variable. The outcome is usually the forecasted value that explains
    the future behavior. Several variables or input data consist of a mathematical
    function, also called the model (hence also data modeling), and these input data
    are trying to explain or predict the outcome. To better understand predictive
    modeling, the chapter will consist of the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 预测建模是一个过程，它使用高级统计和概率算法来预测结果，基于预训练和构建的模型或函数。这些算法可以根据预测变量的结果分为算法家族。结果通常是预测的值，它解释了未来的行为。几个变量或输入数据组成一个数学函数，也称为模型（因此也称为数据建模），这些输入数据试图解释或预测结果。为了更好地理解预测建模，本章将包括以下主题：
- en: Data modeling
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据建模
- en: Advanced predictive algorithms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级预测算法
- en: Predictive analytics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测分析
- en: Deploying and using predictive solutions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和使用预测解决方案
- en: Performing prediction with R Services in SQL Server database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SQL Server数据库中使用R服务进行预测
- en: 'The focus in this chapter will be on delivering insight into understanding
    how predictive modeling can be used in SQL Server 2016/2017, using R on your typical
    business problem. In the enterprise environment, a business problem can be defined
    in a very broad aspect. For example, in medicine, a typical problem that predictive
    modeling can help understand and solve is, will the change of the ingredient A
    and B for the medicine C, help cure the disease? Furthermore, in the metallurgic
    industry, can we simulate how an anti-corrosion coating paint will age through
    time—or in retails, how can a customer select a better product in a store based
    on their needs or behavior? One can say, our everyday life is intertwined with
    predictions and forecast. Usually, every logistical problem all of us are facing
    is a simple question on a potentially very relevant topic: if I leave home for
    work 5 minutes later, will this affect my driving time if I take one shortcut
    and so on and so forth. Literally, we can say, our everyday decisions are the
    sum of all actions we take with a given output.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将在于深入探讨如何在SQL Server 2016/2017中使用R来解决典型的商业问题，以了解预测建模的应用。在企业环境中，一个商业问题可以从一个非常广泛的方面来定义。例如，在医学领域，预测建模可以帮助理解和解决的一个典型问题可能是：药物C中成分A和B的变化是否有助于治愈疾病？此外，在冶金行业，我们能否模拟防腐蚀涂料漆随时间老化的过程——或者在零售业，顾客如何根据他们的需求或行为在商店中选择更好的产品？可以说，我们的日常生活与预测和预测息息相关。通常，我们所有人面对的每一个物流问题都是一个关于可能非常相关主题的简单问题：如果我晚5分钟离开家去上班，如果我走一条捷径，这会影响我的驾驶时间吗？等等。实际上，我们可以说，我们的日常决策是我们采取的所有行动的输出总和。
- en: Data modeling
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据建模
- en: Data modeling is a process where we try to find a function (or the so-called
    model) with a set of independent variables or input data. Just like in data warehousing,
    where modeling is referring to establishing the conceptual framework based on
    the physical data structure and with the help of ORM or UML (even CRC) diagrams
    one explores the structures in data the same is seen with exploring the structures
    when doing predictive analysis. In case of the latter, data modeling is exploring
    the structures (or relations) between two or more variables. These relations can
    be presented as a function and are essentially stored as a model.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据建模是一个过程，我们试图找到一组独立变量或输入数据的一个函数（或所谓的模型）。就像在数据仓库中，建模是指基于物理数据结构建立概念框架，并在ORM或UML（甚至CRC）图的帮助下探索数据结构，这与在预测分析中探索结构时看到的是一样的。在后一种情况下，数据建模是探索两个或多个变量之间的结构（或关系）。这些关系可以表示为一个函数，并且本质上存储为模型。
- en: 'To start modeling, we will use some of the Microsoft data available at the
    following GitHub repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始建模，我们将使用以下GitHub仓库中可用的Microsoft数据：
- en: '[https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/machine-learning-services/python/getting-started/rental-prediction](https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/machine-learning-services/python/getting-started/rental-prediction)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/machine-learning-services/python/getting-started/rental-prediction](https://github.com/Microsoft/sql-server-samples/tree/master/samples/features/machine-learning-services/python/getting-started/rental-prediction)'
- en: 'Do not get confused at this Python example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在这个Python示例中感到困惑：
- en: '![](img/00087.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: Downloading this database will download the `TutorialDB.bak` file, which you
    simply restore to your SQL Server instance, where R in-database is installed.
    This database is included as part of the accompanying code that comes with this
    chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下载此数据库将下载`TutorialDB.bak`文件，你只需将其恢复到已安装R in-database的SQL Server实例中。此数据库是本章附带代码的一部分。
- en: 'Part of modeling data is to set up the understanding of how predictions at
    a later phase will work. Therefore, in this phase, we will create an understanding
    of the variables and their relation to each other. Create restore from the downloaded
    file and run the following restore from the backup T-SQL command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 建模数据的一部分是设置对后续预测工作方式的了解。因此，在这个阶段，我们将创建对变量及其相互关系的理解。从下载的文件中创建恢复，并运行以下从备份T-SQL命令的恢复：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can simply use the `RESTORE` command in SSMS:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在SSMS中简单地使用`RESTORE`命令：
- en: '![](img/00088.gif)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.gif)'
- en: You will now have the database restored and the `dbo.rental_data` table at your
    use. For now, this will be enough.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将拥有已恢复的数据库和`dbo.rental_data`表可供使用。目前，这已经足够了。
- en: 'With the dataset ready, we can now start modeling the data by exploring and
    understanding the variables and the relations among them. This quick exploration
    can be performed in SQL Operation Studio (link to download: [https://docs.microsoft.com/en-us/sql/sql-operations-studio/download](https://docs.microsoft.com/en-us/sql/sql-operations-studio/download)),
    where we will use a simple query:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集准备就绪后，我们现在可以通过探索和理解变量及其相互关系来开始建模数据。这种快速探索可以在SQL Operation Studio中进行（下载链接：[https://docs.microsoft.com/en-us/sql/sql-operations-studio/download](https://docs.microsoft.com/en-us/sql/sql-operations-studio/download))，我们将使用一个简单的查询：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Besides the standard table view of the results, this will also give a nice
    chart viewer, where a simple graphical representation of variables will give you
    better insights into the data:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的表格视图结果外，这还将提供一个很好的图表查看器，其中变量的简单图形表示将帮助你更好地了解数据：
- en: '![](img/00089.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: 'But without the general understanding of descriptive statistics, we will not
    continue. So, using the `rxSummary` function from the `RevoScaleR` package will
    give the desired results:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果没有对描述性统计学的总体理解，我们就不会继续。因此，使用`RevoScaleR`包中的`rxSummary`函数将得到期望的结果：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following are the results as a simple descriptive statistics table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的描述性统计表格的结果：
- en: '![](img/00090.gif)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.gif)'
- en: 'Exploring the uni- and bi-variate statistics was part of the previous [Chapter
    5](part0081.html#2D7TI0-e3f81285367248f4bbc6431bcd4f926d),* RevoScaleR Package,*
    but here we will focus more on bi- and multi-variate statistics. Before we begin,
    let''s explore the correlations some more. Based on exploring the variable names
    and descriptive statistics, common sense will tell us that during the holidays,
    the rental count should be higher. Checking this can be done using the correlation
    coefficient. The following is a simple example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 探索单变量和多变量统计是前一章[第5章](part0081.html#2D7TI0-e3f81285367248f4bbc6431bcd4f926d)，“RevoScaleR包”的一部分，但在这里我们将更多地关注双变量和多变量统计。在我们开始之前，让我们进一步探索相关性。根据探索变量名称和描述性统计，常识会告诉我们，在假期期间，租赁数量应该更高。可以通过相关系数来检查这一点。以下是一个简单的例子：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will give you the idea of the bi-variate relationship of `0.332`. This
    is a weak correlation but a positive one:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出`0.332`的双变量关系的概念。这是一个弱相关性，但却是正相关的：
- en: '![](img/00091.gif)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.gif)'
- en: This simply means that if the `RentalCount` variable gets higher, the number
    of holidays also increases. This indeed makes sense, since if more holidays are
    coming, more rentals are expected.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅意味着，如果`RentalCount`变量值增加，假期的数量也会增加。这确实是有道理的，因为如果假期越来越多，预期的租赁数量也会增加。
- en: 'Now we can continue exploring and searching for the correlations by combining
    each of the variables. This is similar to making a CROSS JOIN, but there are easier
    ways to do this. One is, of course, by using common sense and selecting the meaningful
    correlations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过结合每个变量来继续探索和寻找相关性。这类似于进行CROSS JOIN，但还有更简单的方法来做这件事。其中一种方法当然是，当然，通过使用常识并选择有意义的关联：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And we get the following results as shown in the figure below. Interpretation
    and understanding of the results is of high importance. So, the holiday time is
    by far the most correlative variable with rental count variable. Neither the day
    of the week, nor the year, play any significant role. There is a very tiny, yet
    negative correlation of `-0.110` between `Month` and `RentalCount`, which can
    be understood as higher months might have lower rental counts and vice versa.
    Since this correlation is so weak, it is meaningless to make a fuss over of this
    particular correlation (even if it makes or does not make any sense):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，我们得到了以下结果。对结果的理解和解释非常重要。因此，假期时间到目前为止是与租赁计数变量最相关的变量。无论是星期几还是年份，都没有起到任何显著的作用。`Month`和`RentalCount`之间存在一个非常微小的负相关性`-0.110`，这可以理解为月份较高的月份可能有较低的租赁计数，反之亦然。由于这种相关性非常弱，因此没有必要对这种特定的相关性大惊小怪（即使它有意义或没有意义）：
- en: '![](img/00092.gif)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00092.gif)'
- en: 'Similarly, one can explore the distribution of the values within each variable
    by plotting the boxplots:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以通过绘制箱线图来探索每个变量中值的分布：
- en: '![](img/00093.gif)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00093.gif)'
- en: 'The second way is to plot the diagram of correlations between the variables.
    One way to do it is to invoke the `corrplot` R library, which gives you a very
    powerful and useful visualization of correlation. I tend to create the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是绘制变量之间的相关性图。一种方法是调用`corrplot` R库，它为你提供了一个非常强大和有用的可视化。我倾向于创建以下代码：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Code copied and slightly changed from the corrplot lattice documentation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从corrplot lattice文档复制并稍作修改的代码。
- en: 'This procedure can be directly implemented and used in SSRS or in Power BI
    suit or Excel; the visual is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以直接在SSRS或Power BI套件或Excel中实现和使用；可视化效果如下：
- en: '![](img/00094.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00094.jpeg)'
- en: In a single graph, a trained eye will immediately see the correlations and their
    statistical significance. So, the `0.33 RentalCount` and `Holiday` is visible
    here, but also the `RentalCount` and `Snow` is of `0.19` positive correlation.
    But if we want to explore the behavior of the values dispersion (variance), we
    can also include the analysis of variance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一图表中，有经验的眼睛会立即看到相关性和它们的统计显著性。因此，这里可以看到`0.33 RentalCount`和`Holiday`的相关性，同时`RentalCount`和`Snow`也有`0.19`的正相关性。但如果我们想探索值分散（方差）的行为，我们也可以包括方差分析。
- en: 'If you are working with large datasets or XDF data formats, `RevoScaleR` package
    also comes equipped with functions that compute and calculate correlation matrixes.
    Here is an R code using `rxCovCor` (or, alternatively, one can use `rxCor` or
    `rxCov`):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理大型数据集或XDF数据格式，`RevoScaleR`包还配备了计算和计算相关矩阵的函数。以下是一个使用`rxCovCor`（或者，也可以使用`rxCor`或`rxCov`）的R代码：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This gives the same results as all the previous calculation of correlations:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了与所有之前计算的相关性相同的结果：
- en: '![](img/00095.gif)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00095.gif)'
- en: This output also has the ability to see the standard deviations, means and sum
    of weights, but the best part is that it stores the results in a data frame, which
    can be easily imported or used with other T-SQL tables. The results can be invoked
    using `allCov$CovCor` (R language stores the results as an object of lists and
    each list can be retrieved by using a dollar sign `$` and referencing the name
    of the list—in this case, `CovCor`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出还具有查看标准差、平均值和权重总和的能力，但最好的部分是它将结果存储在数据框中，可以轻松导入或与其他T-SQL表一起使用。结果可以使用`allCov$CovCor`（R语言将结果存储为列表对象，可以通过使用美元符号`$`并引用列表名称来检索每个列表——在这种情况下，`CovCor`）来调用。
- en: 'When we want to further investigate our so-far highest correlation between
    the `RentalCount` and `Holiday`, **Analysis Of Variance **(**ANOVA**) will be
    the appropriate method. We will compare two groups (or levels) of variable `Holiday`
    (`0` is not a holiday while `1 ` is a holiday) and whether there is a difference
    between the rental counts. By doing so, calculating F-statistics and its significance
    will tell us the ratio of between-group variance to within-group variance:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要进一步调查到目前为止最高的`RentalCount`和`Holiday`之间的相关性时，**方差分析（ANOVA**）将是适当的方法。我们将比较变量`Holiday`的两个组（或水平）（`0`不是假期，而`1`是假期）之间的租赁计数是否有差异。通过这样做，计算F统计量和其显著性将告诉我们组间方差与组内方差的比率：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After running the T-SQL code with R code for statistical calculation of ANOVA,
    the output result is created in such manner that it returns the F-Statistic and
    statistical significance. The following figure shows results returned:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 R 代码运行 T-SQL 代码进行 ANOVA 统计计算后，输出结果以这种方式创建，返回 F 统计量和统计显著性。以下图显示了返回的结果：
- en: '![](img/00096.gif)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.gif)'
- en: Results tell us that the F-Statistic is statistically significant—even though
    it is small—and this means that the means are most likely not equal (and we would
    be, in this case, rejecting the null hypothesis). To find where the difference
    lies, `TukeyHDS` test would give us further information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果告诉我们，F 统计量在统计上具有显著性——尽管它很小——这意味着均值很可能不相等（在这种情况下，我们会拒绝零假设）。要找到差异所在，`TukeyHDS`测试会给我们更多信息。
- en: 'Just to illustrate the difference, since we will not go into the details, we
    can use the `stripchart` visualization of the difference between the holiday distribution
    of the rentals:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了说明差异，因为我们不会深入细节，我们可以使用租赁的假日分布差异的`stripchart`可视化：
- en: '![](img/00097.gif)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.gif)'
- en: 'With the R code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 R 代码：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The distribution of the cases can tell us that on holidays an average of `400`
    or higher rental counts are made, whereas on a normal day, there is a huge density
    of counts between `10` and `50`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 案例的分布可以告诉我们，在假日，平均租赁次数为`400`或更高，而在正常日子里，`10`到`50`之间有大量的计数密度。
- en: 'When determining which features (variables) are good for further analysis and
    predictive algorithms, we can use the Decrease Gini mean calculation. One of the
    Gini mean functions is available in `randomForest` package, so, let''s call the
    function and see which variables are to be used:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定哪些特征（变量）适合进一步分析和预测算法时，我们可以使用减少基尼均值的计算。`randomForest`包中有一个 Gini 均值函数可用，因此，让我们调用该函数并查看要使用的变量：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With T-SQL code we are returning the decreased Gini coefficient:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 T-SQL 代码，我们返回减少的基尼系数：
- en: '![](img/00098.gif)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.gif)'
- en: '`Gini` coefficient can also be represented visually as a scatter plot, so that
    the user can immediately determine which variables contribute most to the model.
    For the sake of brevity, the code for this graph is included in the code but not
    in the book.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`基尼系数`也可以用散点图的形式直观表示，这样用户可以立即确定哪些变量对模型贡献最大。为了简洁起见，此图的代码包含在代码中，但不在书中。'
- en: '![](img/00099.gif)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.gif)'
- en: One can now determine, which of the following variables play any role or contribute
    gain in the model. The **MeanDecreaseGini** was drawn as `varImpPlot(fit_RF)`.
    Technically, this is how one can determine which variables or input parameters
    have the least or most impact, but each of these techniques will give you some
    of the aspects—what can be good in the model, and what may not. Comparing the
    `Holiday` variable in the correlation matrix and mean decrease plot, you can see
    that it gives different methods and different results. Most significant are the
    ones where particular variables do not play any importance whatsoever through
    several different methods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以确定以下哪些变量在模型中扮演任何角色或有所贡献。**MeanDecreaseGini**被绘制为`varImpPlot(fit_RF)`。从技术上讲，这是确定哪些变量或输入参数影响最小或最大的方法，但每种技术都会给出一些方面——模型中可能好的，以及可能不好的。比较相关矩阵和平均减少图中的`Holiday`变量，你可以看到它给出了不同的方法和不同的结果。最显著的是那些通过几种不同的方法，特定变量根本不起任何重要作用的情况。
- en: Advanced predictive algorithms and analytics
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级预测算法和分析
- en: So far, we have examined the data preparation and data exploration functions
    available in the `RevoScaleR` package. Besides these functions, predicting classification
    or regression problems can also be done, especially when dealing with large datasets.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经检查了`RevoScaleR`包中可用的数据准备和数据分析函数。除了这些函数之外，预测分类或回归问题也可以完成，尤其是在处理大型数据集时。
- en: 'I will mention only few of these. The complete list is available online ([https://docs.microsoft.com/en-us/machine-learning-server/r-reference/revoscaler/revoscaler](https://docs.microsoft.com/en-us/machine-learning-server/r-reference/revoscaler/revoscaler))
    and some of the points are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我将只提及其中的一些。完整的列表可在网上找到（[https://docs.microsoft.com/en-us/machine-learning-server/r-reference/revoscaler/revoscaler](https://docs.microsoft.com/en-us/machine-learning-server/r-reference/revoscaler/revoscaler)），以下是一些要点：
- en: '`rxLinMod`: This is used for building and predicting a linear model'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxLinMod`：这是用于构建和预测线性模型'
- en: '`rxLogit`: This is used for building and predicting the logistic regression
    model'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxLogit`：这个函数用于构建和预测逻辑回归模型'
- en: '`rxGlm`: This is used for creating a generalized linear model'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxGlm`：这个函数用于创建广义线性模型'
- en: '`rxDTree`: This is used for creating a classification or regression tree'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxDTree`：这个函数用于创建分类或回归树'
- en: '`rxBTrees`: This is used for building a classification or regression decision
    forest—that is using a stochastic gradient boosting algorithm'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxBTrees`：这个函数用于构建分类或回归决策森林——即使用随机梯度提升算法'
- en: '`rxDForest`: This is used for building a classification or regression decision
    forest model'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxDForest`：这个函数用于构建分类或回归决策森林模型'
- en: '`rxNaiveBayes`: This is used for building a Naive Bayes classification model'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rxNaiveBayes`：这个函数用于构建朴素贝叶斯分类模型'
- en: All these algorithms are part of a family of supervised algorithms, where the
    only unsupervised (or undirected) algorithm available in `RevoScaleR` package
    is `rxKMeans`, which is used for dealing with clustering.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些算法都是监督算法家族的一部分，其中`RevoScaleR`包中唯一的无监督（或非指导）算法是`rxKMeans`，它用于处理聚类。
- en: 'Using the same dataset as we did earlier, we plug in and start using `rxLinMod`
    and `rxGlm` for demonstrating how this can be used within T-SQL:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前使用的相同数据集，我们插入并开始使用`rxLinMod`和`rxGlm`来演示如何在T-SQL中使用它们：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Both will give you the predicted values based on the inputted dataset, along
    with the newly predicted values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都会根据输入的数据集提供预测值，以及新的预测值：
- en: '![](img/00100.gif)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.gif)'
- en: 'A curious eye will tell you that the predicted values are far-off from the
    original values. So, the prediction formula in both cases was trying to predict
    variable `RentalCount` based on variables: `Year`, `Month`, `Day`, `WeekDay`,
    `Snow`, and `Holiday`. The formula is set as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好奇的眼睛会告诉你，预测值与原始值相差甚远。因此，两种情况下的预测公式都在尝试根据变量：`Year`（年）、`Month`（月）、`Day`（日）、`WeekDay`（星期几）、`Snow`（雪）和`Holiday`（假日）来预测变量`RentalCount`。公式设置如下：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Comparing the variables `RentalCount_Pred` and `RentalCount` will show the difference/offset
    from the real and predicted values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 比较变量`RentalCount_Pred`和`RentalCount`将显示真实值和预测值之间的差异/偏移量。
- en: 'In the preceding sample, you can also compare the results of all the three
    algorithms. If you run comparison with all three datasets, observation by observation,
    you can see immediately which algorithms performed best:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您还可以比较所有三个算法的结果。如果您对所有三个数据集进行逐个观察的比较，您可以立即看到哪些算法表现最好：
- en: '![](img/00101.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: So, the yellow bar represents the original values, and by far the best hit is
    the decision trees algorithm, given the upper formula and understanding the insights
    of the data. The graph just represents a randomly taken observation. This can
    also be achieved by calculating the accuracy or measure that calculates how much
    deviation had accrued from the original values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，黄色条形表示原始值，迄今为止，决策树算法在给定上述公式并理解数据洞察的情况下，是最准确的。图表仅代表随机选取的观察结果。这也可以通过计算准确度或衡量标准来实现，该标准计算了与原始值之间的偏差程度。
- en: Deploying and using predictive solutions
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和使用预测解决方案
- en: When developing the in-database solution and creating it for continuous development
    (and also deployment), several aspects should be taken into consideration. First
    of all, the environment where data scientists will be working. You might give
    them a powerful, standalone server or even allocate proper seats in the cloud.
    They will need it, especially when training the model. This is extremely important,
    as you don't want to have your highly-paid statisticians and mathematicians wait
    for the models to compute and generate. So, enabling the route to a highly scalable
    CPU and RAM powerful computations is a must. Second to this, you have to get the
    data there. Whether it's on cloud or on premises, getting data there (and later
    also, back) should not be overlooked, as this might also be the point where you
    will lose precious time. And, lastly, having the environment set with proper settings,
    environment variables, packages, and all paths to proprietary software enabled
    is also of importance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发数据库内解决方案并为其持续开发（以及部署）创建时，应考虑几个方面。首先，数据科学家将工作的环境。你可能给他们一个强大的独立服务器，甚至在云中分配适当的座位。他们需要它，尤其是在训练模型时。这非常重要，因为你不希望你的高薪统计学家和数学家等待模型计算和生成。因此，启用通往高度可扩展的CPU和RAM强大计算的路是由必要的。其次，你必须将数据放在那里。无论是在云中还是在本地，将数据放在那里（以及稍后返回）不应被忽视，因为这可能是你失去宝贵时间的地方。最后，拥有设置正确的环境、环境变量、包以及所有专有软件路径的启用也是非常重要的。
- en: '`RevoScaleR` package comes equipped with a function for easily switching the
    computational environments. We will now invoke a simple command in R:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`RevoScaleR`包自带了一个用于轻松切换计算环境的函数。我们现在将在R中调用一个简单的命令：'
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By doing this, you can set the local computational environment (that is, the
    client's machine) or the server side, where—in this case—a standalone R Server
    would reside. With a simple function call, the computational context (or simple
    environment) is switched, as course, keeping in mind that all the data resides
    on both sides (so that you avoid the unneeded data transferring) and that all
    the server environment variables are set correctly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你可以设置本地计算环境（即客户端的机器）或服务器端，在这种情况下，一个独立的R服务器将驻留。通过简单的函数调用，计算上下文（或简单环境）就会切换，当然，要考虑到所有数据都存储在两边（这样你可以避免不必要的传输），并且所有服务器环境变量都设置正确。
- en: For training the model, several good practices can be chosen. Splitting the
    data for training, testing or training, and testing and validating are several
    practices. Also, a very good practice is to test the percentage of training/testing/validating
    datasets. You might get a 50/50 or 60/40 or 70/30 percentage, but usually you
    carry out and decide this when mining the data. After that, you should also consider
    validation of the data; several aspects are available, from **leave one out**
    (**LOO**) or 10-folds or 5-folds for choosing the validation data for validating
    the results.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于训练模型，可以选择一些良好的实践。将数据分割用于训练、测试或训练、测试和验证是几种实践。此外，一个非常好的实践是测试训练/测试/验证数据集的百分比。你可能得到50/50或60/40或70/30的百分比，但通常你会在挖掘数据时进行这项操作并做出决定。之后，你还应该考虑数据的验证；有几种方法可供选择，从**留一法**（**LOO**）或10折法或5折法来选择用于验证结果的数据。
- en: Not going into the topic too deep, and to make this demo simpler, we can decide
    to do a 70/30 percentage on the spot. Since we have the pleasure of the T-SQL
    database here, we can select and store the training subset in a table, or create
    a view, or decide which 70% we want to take.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨这个主题，为了使这个演示更简单，我们可以现场决定采用70/30的百分比。由于我们有幸使用T-SQL数据库，我们可以选择并将训练子集存储在表中，或者创建一个视图，或者决定我们想要取的70%。
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This also heavily depends on your business model. The first approach simply
    takes 70% of the data from the original dataset, whereas the second select statement
    takes roughly 70% of the original data, but makes a split based on the year of
    the rental. This might have a crucial impact on how the model will behave and
    also how you want the decision to be affected by this, especially the business
    model.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这也严重依赖于你的商业模式。第一种方法简单地从原始数据集中取出70%的数据，而第二种选择语句大致取出原始数据的70%，但基于租赁年份进行分割。这可能会对模型的行为产生关键影响，也会影响你希望决策如何受到这种影响，尤其是商业模式。
- en: 'Once this is cleared and covered, a best practice is to store the trained model
    in the tables for faster predictions. We will now create a table as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰并覆盖这些内容后，一个最佳实践是将训练好的模型存储在表中以实现更快的预测。现在我们将创建一个如下所示的表：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the `set.seed` is defined, you will always get the same subset, wherever
    you run this code. If you want to get different results, you should comment it
    out.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`set.seed`已被定义，无论你在哪里运行此代码，你都将始终得到相同的子集。如果你想得到不同的结果，你应该将其注释掉。
- en: 'Once the sampling is done again, based on the problem you are predicting, you
    need to define your prediction formula. In this case, I am using a formula converter
    to create a proper formula:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 采样再次完成后，根据你预测的问题，你需要定义你的预测公式。在这种情况下，我正在使用公式转换器来创建一个合适的公式：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a formula through a procedure, making it not hard coded, is also a
    very useful approach, especially in the corporate environment where data scientists
    will set up the pool of independent variables and later the data engineer would
    choose which to include, prior to pushing the data to compute the model and deploy
    it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个过程创建公式，使其不是硬编码的，也是一种非常实用的方法，尤其是在企业环境中，数据科学家会设置独立变量的池，然后在数据工程师选择要包含哪些变量之前，将数据推送到计算模型并部署它。
- en: The process of bi-variate and multi-variate statistics can also give the data
    engineers and stewards better insights and understanding of what and how the data
    is operating and correlating, and that there are no unwanted correlations or variables
    that just do not function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 双变量和多变量统计过程也可以给数据工程师和管理员提供更好的洞察力和理解，了解数据和如何操作以及相关性，以及没有不想要的关联或不起作用的变量。
- en: 'With this cleared up, we can set up and build the procedures that will run
    the model training and have the models stored in the database. Due to the space
    limits of this chapter, I will only show the creation of one procedure; the rest
    of the procedures can be found in the accompanying chapter materials:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰地了解这一点后，我们可以设置和构建运行模型训练并存储在数据库中的过程。由于本章篇幅有限，我将只展示创建一个过程的示例；其余的过程可以在配套的章节材料中找到：
- en: 'The procedure for random forest in T-SQL would look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: T-SQL中随机森林的流程看起来是这样的：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I have added something extra to the procedure, such that every time the model
    is trained, an extra is added. This is accuracy, which will also give the data
    engineer and stewards in the later phases a good insight into deciding which model
    outperforms the others.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我在过程中添加了一些额外的东西，这样每次训练模型时都会添加一些额外的信息。这是准确性，它也会让数据工程师和后期阶段的管理员对决定哪个模型优于其他模型有很好的洞察力。
- en: 'You can simply run the procedure as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地按照以下方式运行该过程：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will populate the destination table where the models are kept. The results
    should be stored in the table `[dbo].[Rental_data_models]`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将填充存储模型的目标表。结果应存储在表 `[dbo].[Rental_data_models]` 中：
- en: '![](img/00102.gif)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.gif)'
- en: Once this is done, you need to have the evaluation procedure set as well that
    will help determine which model functions the best. However, this part can be
    done using Power BI, or reporting services, or simply just R.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你需要设置评估过程，这将有助于确定哪个模型表现最好。然而，这部分可以使用Power BI、报告服务或简单地使用R来完成。
- en: 'This is part of R code that can be included in your visualization tool for
    easier comprehension:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是R代码的一部分，可以包含在你的可视化工具中以便更容易理解：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The observed values should tell you which model is performing best. Once you
    have done this, you can choose the model and see how the predictions can be done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到的值应该告诉你哪个模型表现最好。一旦你完成了这个，你就可以选择模型并查看预测是如何进行的。
- en: Performing predictions with R Services in the SQL Server database
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SQL Server数据库中使用R服务进行预测
- en: Calling stored procedures is the easiest way to organize your code and start
    predicting right away.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 调用存储过程是组织代码并立即开始预测的最简单方法。
- en: 'Again, only a sample will be shown here of how to create a stored procedure
    to predict new datasets:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里只展示如何创建一个存储过程来预测新的数据集的示例：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once this is done, you can start predicting using the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你可以开始使用以下代码进行预测：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And, as a result, you will get a predicted value for the variables of `Year`,
    `Month`, `Day`, `WeekDay`, `Holiday`, and `Snow`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，你将得到`Year`、`Month`、`Day`、`WeekDay`、`Holiday`和`Snow`变量的预测值：
- en: '![](img/00103.gif)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.gif)'
- en: 'Intentionally, the field `OrigPredictedCount` was set to `0`, but the new predicted
    value is the value of `278.996` and that is based on the input variables. While
    checking how the model learned, it is best to also check the original value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 故意将字段`OrigPredictedCount`设置为`0`，但新的预测值是`278.996`，这是基于输入变量的。在检查模型学习情况时，最好也检查原始值：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We see that there is no values in month`= 5`, so the model must have it learned
    from other values:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到在`month`= 5`中没有值，因此模型必须从其他值中学习：
- en: '![](img/00104.gif)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.gif)'
- en: Now that we have covered the supervised predictive algorithms, let's quickly
    jump into the cluster—part of the functions that `RevoScaleR` package supports
    as the only undirected algorithm.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了监督预测算法，让我们快速跳入聚类——`RevoScaleR`包支持的唯一无向算法的一部分。
- en: 'The following is the example of how to create a simple clustering:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建简单聚类的示例：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the output, which is the presentation of the clusters:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是聚类的展示：
- en: '![](img/00105.gif)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.gif)'
- en: To explore the clustering and play with different number of clusters, one thing
    for sure would be to use R code directly or to create a report for exploring the
    characteristics of clusters using Power BI, Excel, or SSRS.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索聚类并尝试不同的聚类数量，直接使用R代码或创建一个报告来使用Power BI、Excel或SSRS探索聚类特征，这是肯定的事情。
- en: Adding some additional information on cluster centers, statistics as `withinSS`,
    `betweenSS`, `totSS`, and others will also help us to understand the clusters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加有关聚类中心、统计信息如`withinSS`、`betweenSS`、`totSS`等额外信息也将帮助我们理解聚类。
- en: Scree plot is also an additional and very nice presentation of choosing the
    correct number of clusters. Adding such graphics into a report will also help
    the user choose the right number of clusters and help them understand what and
    how clusters are formed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Scree图也是选择正确聚类数量的额外且非常棒的表现方式。将此类图形添加到报告中也有助于用户选择正确的聚类数量，并帮助他们理解聚类是如何形成的。
- en: 'Scree plot R code is used for determining where elbow is happening and does
    whether it has the right number of clusters; if so, three clusters would be an
    optimum number:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Scree图R代码用于确定肘部在哪里发生，以及它是否有正确的聚类数量；如果是的话，三个聚类将是一个最佳数量：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On this plot we can see where the elbow is being created and we can determine
    that the best solution is three clusters:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们可以看到肘部在哪里形成，我们可以确定最佳解决方案是三个聚类：
- en: '![](img/00106.gif)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.gif)'
- en: 'Putting everything together into a report (SSRS report) makes exploring even
    better:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合到报告中（SSRS报告）使探索更加完善：
- en: '![](img/00107.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.jpeg)'
- en: 'The user can change the number of clusters by selecting the desired number
    and the report will change accordingly. The report is based on three additional
    procedures that export the graphs based on the inputted number of clusters:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过选择所需的聚类数量来更改聚类数量，报告将相应地更改。该报告基于三个额外的过程，这些过程基于输入的聚类数量导出图形：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running this in SSMS will give you a var binary string, but adding the result
    of this procedure as an image in SSRS or Power BI/Excel will yield a plot derived
    from R.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSMS中运行此操作将给出一个var binary字符串，但将此过程的结果作为图像添加到SSRS或Power BI/Excel中，将得到一个由R生成的图表。
- en: Adding a nice visualization to your exploratory project upon building a predictive
    analytics system is definitely a very nice wrap-up for business and end users,
    as well as for the data wranglers and engineers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建预测分析系统后，为探索性项目添加一个漂亮的可视化效果，对于商业用户、数据整理员和工程师来说，无疑是一个非常好的总结。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered the extensible functionalities of the `RevoScaleR`
    package to deliver fast and good predictions based on the explored datasets. In
    the previous chapter *Statistical learning with RevoScaleR package*, we have covered
    data exploration, preparation and simple and bi-variate statistics. This chapter
    showed how `RevoScaleR` package was designed to work with large datasets (that
    overcome the limitations of RAM and single CPU), enabling spill to disk and multi
    threading. The same procedures can be used as well in database instances of R,
    for delivering the predictions to your business and data residing in the database.
    We have covered this aspect as well, exploring different algorithms and comparing
    the solutions. Once you have your model selected, you may want to use the `PREDICT`
    clause. which is a new feature in SQL Server 2017 with a slightly altered architecture.
    Please note that currently (at the time of writing this chapter) the model size
    can not exceed 100 MB if you want to use `PREDICT` clause. Currently, only `RevoScaleR`
    and `MicrosoftML` packages are supported to use this clause, and not even all
    `RevoScaleR` (and MicrosoftML) algorithms are supported—currently supported are
    `rxLinMod`, `rxLogit`, `rxBTrees`, `rxDtree`, `rxdForest`. However, this real-time
    scoring with `PREDICT` clause will definitely develop and evolve in the next release
    of SQL Server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了`RevoScaleR`包的可扩展功能，以便基于探索的数据集提供快速和良好的预测。在上一章《使用RevoScaleR包进行统计学习》中，我们介绍了数据探索、准备以及简单和双变量统计。本章展示了`RevoScaleR`包是如何设计用来处理大型数据集的（克服了RAM和单CPU的限制），实现了数据溢出到磁盘和多线程。同样的程序也可以在R的数据库实例中使用，以便将预测结果发送到你的业务和数据库中的数据。我们也涵盖了这一方面，探索了不同的算法并比较了解决方案。一旦你选定了模型，你可能想使用`PREDICT`子句。这是SQL
    Server 2017的一个新特性，具有略微不同的架构。请注意，目前（在撰写本章时）如果你想使用`PREDICT`子句，模型大小不能超过100 MB。目前，只有`RevoScaleR`和`MicrosoftML`包支持使用这个子句，而且并不是所有的`RevoScaleR`（和MicrosoftML）算法都支持——目前支持的是`rxLinMod`、`rxLogit`、`rxBTrees`、`rxDtree`、`rxdForest`。然而，使用`PREDICT`子句进行的实时评分将在SQL
    Server的下一个版本中肯定会有发展和演变。
- en: We need to predict a classification or regression problem. The majority of the
    problems can be supported using `RevoScaleR` package and many of these algorithms
    were also empowered by a new set of additional classifiers available in the `MicrosoftML`
    package. Exploring both packages will give your decision-making a much-needed
    boost. Also, storing serialized models into the database is an optimal way of
    storing and calling trained models (functions) that can be retrained by adding
    a simple logic implementation using SQL Server agents or triggers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要预测一个分类或回归问题。大多数问题都可以使用`RevoScaleR`包来支持，其中许多算法也得到了`MicrosoftML`包中提供的新附加分类器的支持。探索这两个包将给你的决策提供急需的推动。此外，将序列化的模型存储到数据库中是存储和调用经过训练的模型（函数）的最佳方式，这些模型可以通过添加简单的逻辑实现使用SQL
    Server代理或触发器进行重新训练。
- en: In [Chapter 07](part0102.html#318PC0-e3f81285367248f4bbc6431bcd4f926d), *Operationalizing
    R Code*, you will learn how to operationalize your model and solution and explore
    different ways how to do it and some good practices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第07章](part0102.html#318PC0-e3f81285367248f4bbc6431bcd4f926d)《将R代码投入运行》中，你将学习如何将你的模型和解决方案投入运行，并探索不同的实现方法和一些良好的实践。
