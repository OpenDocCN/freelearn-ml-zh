- en: Chapter 5. Automated Optical Inspection, Object Segmentation, and Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 自动光学检测，对象分割和检测
- en: In the previous chapter, we learned about histograms and filters that allowed
    us to understand image manipulation and create a photo application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了直方图和过滤器，这些使我们能够理解图像处理并创建一个照片应用程序。
- en: In this chapter, we will introduce you to the basic concepts of object segmentation
    and detection, which means isolation the objects that appear in an image for future
    processing and analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍对象分割和检测的基本概念，这意味着隔离图像中出现的对象，以便进行未来的处理和分析。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Noise removal
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 噪声消除
- en: The basics of light/background removal
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光/背景去除的基本原理
- en: The thresholding operation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阈值操作
- en: A connected component for object segmentation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象分割的连通分量
- en: Finding contours for object segmentation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找对象分割的轮廓
- en: The industry sector uses complex Computer Vision systems and hardware. Computer
    Vision tries to detect the problems and minimizes errors produced in the production
    process and increases the quality of final products.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 行业领域使用复杂的计算机视觉系统和硬件。计算机视觉试图检测生产过程中的问题，并最小化产生的错误，提高最终产品的质量。
- en: In this sector, the name for Computer Vision tasks is **Automated Optical Inspection**
    or AOI. This name appears in the inspection of printed circuit board manufacturers,
    where one or more cameras scan each circuit to detect critical failures and quality
    defects. This nomenclature was used by other manufacturers to use optical camera
    systems and Computer Vision algorithms to increase the product quality. Nowadays,
    the use of optical inspection using different camera types such as infrared, 3D
    cameras, and so on depends on the problem requirements, such as measure objects,
    detect surface effects, and so on; and complex algorithms are used in thousands
    of industries for different purposes, such as defects detection, recognition,
    classification, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域，计算机视觉任务的名称是**自动光学检测**或AOI。这个名字出现在印刷电路板制造商的检测中，其中一台或多台相机扫描每个电路以检测关键故障和质量缺陷。其他制造商使用光学相机系统和计算机视觉算法来提高产品质量。如今，使用不同类型的相机（如红外相机、3D相机等）进行光学检测，这取决于问题要求，例如测量对象、检测表面效应等；并且复杂算法在成千上万的行业中用于不同的目的，如缺陷检测、识别、分类等。
- en: Isolating objects in a scene
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景中隔离对象
- en: In this section, we will introduce you to the first step of any AOI algorithm,
    that is, isolating different parts or objects in a scene.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍任何AOI算法的第一步，即在场景中隔离不同的部分或对象。
- en: 'We will take the example of object detection and classification of three object
    types: a screw, a packing ring, and a nut and develop these in this chapter and
    [Chapter 6](ch06.html "Chapter 6. Learning Object Classification"), *Learning
    Object Classification*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以三种对象类型（螺丝、包装环和螺母）的对象检测和分类为例，并在本章和[第6章](ch06.html "第6章 学习对象分类") *学习对象分类*
    中进行开发。
- en: 'Let''s say we are in a company that produces these three objects. All of them
    are in the same carrier tape, and our objective is to detect each object in the
    carrier tape and classify each one to allow a robot to put each object on the
    correct shelf:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们是一家生产这些三个对象的公司。所有这些都在同一载体带上，我们的目标是检测载体带上的每个对象，并将每个对象分类，以便机器人将每个对象放在正确的货架上：
- en: '![Isolating objects in a scene](img/B04283_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![场景中隔离对象](img/B04283_05_01.jpg)'
- en: In this chapter, we will isolate each object and detect its position in the
    image in pixels. In the next chapter, we will classify each isolated object to
    check whether it is a nut, a screw, or a packing ring.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将隔离每个对象并在图像中以像素为单位检测其位置。在下一章中，我们将对每个隔离对象进行分类，以检查它是否是螺母、螺丝或包装环。
- en: In the following image, we show our desired result where there are a few objects
    in the left-hand side image, and in the right-hand side image, we draw each one
    in different colors. We can show different features such as the area, height,
    width, countour size, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，我们展示了我们期望的结果，其中左侧图像中有几个对象，而在右侧图像中，我们用不同的颜色绘制每一个。我们可以展示不同的特征，如面积、高度、宽度、轮廓大小等。
- en: '![Isolating objects in a scene](img/B04283_05_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![场景中隔离对象](img/B04283_05_02.jpg)'
- en: 'To achieve this result, we will follow different steps that allow us to better
    understand and organize our algorithm, as shown in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此结果，我们将遵循不同的步骤，这些步骤使我们能够更好地理解和组织我们的算法，如下面的图所示：
- en: '![Isolating objects in a scene](img/B04283_05_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![场景中的隔离对象](img/B04283_05_03.jpg)'
- en: Our application is divided into two chapters. In this chapter, we will develop
    and understand the preprocessing and segmentation steps. In [Chapter 6](ch06.html
    "Chapter 6. Learning Object Classification"), *Learning Object Classification,*
    we will extract the characteristics of each segmented object and train our machine
    learning system/algorithm to identify each object class to allow you to classify
    our objects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序分为两个章节。在本章中，我们将开发和理解预处理和分割步骤。在[第6章](ch06.html "第6章。学习对象分类") *学习对象分类*
    中，我们将提取每个分割对象的特征，并训练我们的机器学习系统/算法以识别每个对象类别，以便您可以对对象进行分类。
- en: 'Our preprocessing steps are divided into three more substeps, which are as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将预处理步骤分为三个更小的子步骤，如下所述：
- en: Noise removal
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 噪声去除
- en: Lighting removal
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光照去除
- en: Binarization
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二值化
- en: 'In the segmentation step, we will use two different algorithms, which are as
    follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在分割步骤中，我们将使用两种不同的算法，如下所述：
- en: The contour detection algorithm
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘检测算法
- en: The connected component extraction (labeling)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连通组件提取（标记）
- en: 'We can see these substeps in the following diagram along with the application
    flow:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图中看到这些子步骤以及应用程序流程：
- en: '![Isolating objects in a scene](img/B04283_05_04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![场景中的隔离对象](img/B04283_05_04.jpg)'
- en: Now, it's time to start the preprocessing step to get the best binarization
    image by removing the noise and lighting effects in order to minimize the possible
    detection errors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始预处理步骤，通过去除噪声和光照效果来获取最佳的二值化图像，以最大限度地减少可能的检测错误。
- en: Creating an application for AOI
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AOI应用程序
- en: 'To create our new application, we require a few input parameters when the user
    executes them; all of them are optional, excluding the input image to be processed:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的新应用程序，当用户执行它们时，我们需要一些输入参数；所有这些都是可选的，除了要处理的输入图像：
- en: An input image to be processed
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要处理的输入图像
- en: The light image pattern
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光照图像模式
- en: 'The light operation, where the user can choose between difference or division
    operations:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光照操作，用户可以在差分或除法操作之间选择：
- en: If the input value of the user is set to `0`, then a difference operation is
    applied
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入的值设置为 `0`，则应用差分操作
- en: If the input value of the user is set to `1`, then a division operation is applied
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入的值设置为 `1`，则应用除法操作
- en: 'Segmentation, where the user can choose between connected components with or
    without statistics and `findContours` methods:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割，用户可以在具有或不具有统计的连通组件和 `findContours` 方法之间选择：
- en: If the input value of the user is set to `1`, then the connected `components`
    method for the segment is applied
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入的值设置为 `1`，则应用分割的连通 `组件` 方法
- en: If the input value of the user is set to `2`, then the connected components
    with the statistics area is applied
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入的值设置为 `2`，则应用具有统计面积的连通组件
- en: If the input value of the user is set to `3`, then the `findContours` method
    is applied to the segmentation
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入的值设置为 `3`，则将 `findContours` 方法应用于分割
- en: 'To enable this user selection, we will use the command line `parser` class
    with these keys:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用此用户选择，我们将使用带有这些键的命令行 `parser` 类：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use the command line `parser` class that checks the parameters in the `main`
    function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命令行 `parser` 类在 `main` 函数中检查参数：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After `parser` class our command line user data, we check whether the input
    image is correctly loaded, and then we load the image and check whether it has
    data:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `parser` 类之后，我们检查命令行用户数据是否正确加载，然后加载图像并检查它是否有数据：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we are ready to create our AOI process of segmentation. We will start with
    the preprocessing task.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好创建我们的AOI分割过程。我们将从预处理任务开始。
- en: Preprocessing the input image
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理输入图像
- en: This section introduces you to some of the most common techniques that can be
    applied to preprocess images in the context of object segmentation/detection.
    The preprocess is the first change that we make in a new image before we start
    with our work and extract the information that we require from it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您介绍一些最常用的技术，这些技术可以在对象分割/检测的上下文中应用于预处理图像。预处理是我们开始工作并从图像中提取所需信息之前对新的图像所做的第一个更改。
- en: Normally, in the preprocessing step, we try to minimize the image noise, light
    conditions, or image deformations due to the camera lens. These steps minimize
    the errors when you try to detect objects or segment our image.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在预处理步骤中，我们试图最小化图像噪声、光照条件或由于相机镜头引起的图像变形。这些步骤在尝试检测对象或分割我们的图像时最小化错误。
- en: Noise removal
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 噪声去除
- en: 'If we don''t remove the noise, we can detect more objects than we expect because
    normally noise is represented as a small point in the image and can be segmented
    as an object. The sensor and scanner circuit normally produce this noise. This
    variation of brightness or color can be represented in different types, such as
    Gaussian noise, spike noise, and shot noise. There are different techniques that
    can be used to remove the noise. We will use a smooth operation, but depending
    of the type on the noise, we will use some that are better than others. For example,
    a median filter is normally used to remove the salt-pepper noise:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不去除噪声，我们可以检测到比预期更多的对象，因为通常噪声在图像中表示为一个小点，可以被分割为对象。传感器和扫描仪电路通常会产生这种噪声。这种亮度或颜色的变化可以表示为不同的类型，如高斯噪声、尖峰噪声和闪烁噪声。有不同技术可以用来去除噪声。我们将使用平滑操作，但根据噪声的类型，我们将使用一些比其他更好的技术。例如，中值滤波器通常用于去除椒盐噪声：
- en: '![Noise removal](img/B04283_05_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![噪声去除](img/B04283_05_05.jpg)'
- en: The left-hand side image is the original input with a salt-pepper noise. If
    we apply a median blur, we get an awesome result where we lose small details.
    For example, the borders of a screw for which we maintain the perfect edges. Refer
    to the top-right figure. If we apply a box filter or a Gaussian filter, the noise
    if not removed. It is just smoothed and the details of objects are loosed and
    smoothed as well. Refer to the bottom-right figure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧图像是带有椒盐噪声的原始输入图像。如果我们应用中值模糊，我们会得到一个很棒的结果，但会丢失一些细节。例如，我们保持完美的边缘的螺丝的边缘。参见图表右上角。如果我们应用盒式滤波器或高斯滤波器，噪声不会被去除。它只是被平滑，物体的细节也会变得松散和平滑。参见图表右下角。
- en: 'OpenCV provides us with the `medianBlur` function that requires the following
    three parameters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV为我们提供了`medianBlur`函数，该函数需要以下三个参数：
- en: An input image with a 1, 3, or 4 channel image. When the kernel size is greater
    than `5`, the image depth can only be `CV_8U`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入图像具有1、3或4个通道。当核大小大于`5`时，图像深度只能为`CV_8U`。
- en: An output image,which is the resulting image, that has the same type and depth
    as that of the input.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出图像，即结果图像，其类型和深度与输入图像相同。
- en: The kernel size that has the aperture size greater than `1` and an odd value.
    For example, 3, 5, 7.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核大小大于`1`且为奇数的孔径大小。例如，3、5、7。
- en: 'This piece of code used to remove the noise looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段用于去除噪声的代码看起来像这样：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Removing the background using the light pattern for segmentation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用光模式进行分割以去除背景
- en: In this section, we will develop a basic algorithm that enables us to remove
    the background using a light pattern. This preprocessing gives us better segmentation.
    Refer to the following figures. The top-left figure is the input image without
    noise, and the top-right figure is the result of applying a thresholding operation;
    we can see the top artifact. The bottom-left figure is the input image after the
    removal of the background, the bottom-right figure is the thresholding result
    where there are no artifacts in it and it's better to segment it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个基本算法，使我们能够使用光模式去除背景。这种预处理使我们能够获得更好的分割。参见图表。左上角图是未添加噪声的输入图像，右上角图是应用阈值操作的结果；我们可以看到顶部的伪影。左下角图是去除背景后的输入图像，右下角图是没有伪影的阈值结果，它更适合分割。
- en: '![Removing the background using the light pattern for segmentation](img/B04283_05_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用光模式进行分割去除背景](img/B04283_05_06.jpg)'
- en: 'How can we remove the light from our image? It is very simple; we only need
    a picture of our scenario without any object that is taken from exactly the same
    position from where the other images have been taken, and to have the same light
    conditions. This is a very common technique in AOI because the external conditions
    are supervised and known. The image result of our case is similar to the following
    figure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从我们的图像中去除光线？这非常简单；我们只需要一张没有物体的场景照片，这张照片是从与其他图像相同的精确位置拍摄的，并且具有相同的光照条件。这在AOI中是一个非常常见的技巧，因为外部条件是受监督和已知的。我们案例的图像结果类似于以下图：
- en: '![Removing the background using the light pattern for segmentation](img/B04283_05_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![使用光模式进行分割以去除背景](img/B04283_05_07.jpg)'
- en: 'Then, with a simple mathematical operation, we can remove this light pattern.
    There are two options to remove it, which are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过简单的数学运算，我们可以去除这个光模式。有两种去除它的方法，如下所示：
- en: Difference
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差分
- en: Division
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法
- en: 'The difference images are the simplest approach. If we have the light pattern
    *L* and the image picture *I,* the removal *R* result is the difference between
    them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 差分图像是最简单的方法。如果我们有光模式*L*和图像图片*I*，去除*R*的结果是它们之间的差：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This division is a bit more complex but simple at the same time. If we have
    the light pattern matrix *L* and the image picture matrix *I,* the removal *R*
    result is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种除法稍微复杂一些，但同时也很简单。如果我们有光模式矩阵*L*和图像图片矩阵*I*，去除*R*的结果如下：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, we divide the image by the light pattern. We make the assumption
    that if our light pattern is white and the objects are darker than the background
    carrier tape, then the image pixel values will always remain the same or will
    be lower than the light pixel values. Then, the result that we obtain from *I/L*
    is between `0` and `1`. Finally, we invert the result of this division to get
    the same color direction range and multiply it by 255 to get values between the
    `0-255` range.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过光模式除以图像。我们假设如果我们的光模式是白色，而物体比背景载体胶带暗，那么图像像素值将始终保持不变或低于光像素值。然后，从*I/L*获得的我们得到的结果在`0`和`1`之间。最后，我们反转这个除法的结果，以获得相同颜色方向范围，并将其乘以255以获得`0-255`范围内的值。
- en: 'In our code, we will create a new function called `removeLight` with the following
    parameters:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将创建一个名为`removeLight`的新函数，具有以下参数：
- en: An input image to remove the light/background
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于去除光/背景的输入图像
- en: Light pattern mat
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光模式矩阵
- en: Method, `0` is difference, `1` division
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法，`0`是差分，`1`是除法
- en: The output is a new image matrix without the light/background.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个没有光/背景的新图像矩阵。
- en: 'The following code implements the background removal using the light pattern:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了使用光模式去除背景：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's try to understand this. After creating the `aux` variable, in order to
    save the result, we select the method that is chosen by the user and passed via
    a parameter to the function. If the method selected is `1`, we apply the `division`
    method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解这一点。在创建`aux`变量之后，为了保存结果，我们选择用户选择的方法，并通过参数传递给函数。如果选择的是`1`，我们应用除法方法。
- en: 'The `division` method requires a 32-bit float image to allow us to divide the
    images. The first step is to convert the image and light pattern mat to 32-bit
    depth:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`division`方法需要一个32位浮点图像，这样我们才能进行图像除法。第一步是将图像和光模式矩阵转换为32位深度：'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can perform the mathematical operations in our matrix, as described,
    dividing the image by the pattern and inverting the result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行描述中的矩阵中的数学运算，即通过模式除以图像，并反转结果：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we have the result, but we need to return an 8-bit depth image, and then,
    use the `convert` function, as we did previously, to convert it to a 32-bit float:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经得到了结果，但我们需要返回一个8位深度的图像，然后，使用`convert`函数，就像我们之前做的那样，将其转换为32位浮点数：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can return the `aux` variable with the result. For the difference method,
    the development is very easy because we don''t have to convert our images, we
    only need to perform the difference and return. If we don''t assume that the pattern
    is equal to or greater than the image, then we will require a few checks and truncate
    values that can be less than `0` or greater than `255`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`aux`变量与结果一起返回。对于差分法，其展开非常简单，因为我们不需要转换我们的图像，我们只需要执行差分并返回。如果我们不假设模式等于或大于图像，那么我们将需要执行一些检查，并截断可能小于`0`或大于`255`的值：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following figure is the result of applying the image light pattern to our
    input image:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是应用图像光模式到我们的输入图像的结果：
- en: '![Removing the background using the light pattern for segmentation](img/B04283_05_08.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![使用光模式进行分割以去除背景](img/B04283_05_08.jpg)'
- en: In the results that we obtain, we can check how the light gradient is removed
    and the possible artifacts are removed as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得的结果中，我们可以检查光梯度是如何被去除的，以及可能的伪影是如何被去除的。
- en: However, what happens when we don't have a light/background pattern? There are
    a few different techniques to do this, and we are going to present the most basic
    one. Using a filter, we can create one that can be used, but there are better
    algorithms from which you can learn the background from a few images, where the
    pieces appear in different areas. This technique sometimes requires a background
    estimation image initialization, where our basic approach can play very well.
    These advanced techniques are explored in the video surveillance chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们没有光/背景模式时会发生什么？有几种不同的技术可以做到这一点，我们将介绍最基本的一种。使用一个过滤器，我们可以创建一个可以使用的过滤器，但还有更好的算法，你可以从中学习如何从几个图像中学习背景，其中碎片出现在不同的区域。这种技术有时需要背景估计图像初始化，其中我们的基本方法可以发挥很好的作用。这些高级技术将在视频监控章节中探讨。
- en: 'To estimate the background image, we will use a blur with a large kernel size
    that is applied to our input image. This is a common technique used in OCR where
    the letters are thin and small relative to the whole document, and allows us to
    perform an approximation of the light patterns in the image. We can see the light/background
    pattern reconstruction on the left-hand side figure and the ground truth on the
    right-hand side figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了估计背景图像，我们将使用一个大型核大小的模糊，该模糊应用于我们的输入图像。这是一种在OCR中常用的常见技术，其中字母相对于整个文档又薄又小，并允许我们对图像中的光模式进行近似。我们可以在左侧图上看到光/背景模式重建，在右侧图上看到真实情况：
- en: '![Removing the background using the light pattern for segmentation](img/B04283_05_09.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![使用光模式进行分割以移除背景](img/B04283_05_09.jpg)'
- en: We can see that there are minor differences in the light patterns, but this
    result is enough to remove the background, and we can see the result in the following
    figure using difference images.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到光模式之间存在一些细微的差异，但这个结果足以移除背景，我们可以在以下图使用差异图像中看到结果。
- en: 'In the following figure, we can see the result of applying the image difference
    between the original input image and the estimated background image that are computed
    with the previous approach:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到使用先前方法计算的原输入图像和估计的背景图像之间的图像差异的结果：
- en: '![Removing the background using the light pattern for segmentation](img/B04283_05_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![使用光模式进行分割以移除背景](img/B04283_05_10.jpg)'
- en: 'The `calculateLightPattern` function creates this light pattern or background
    approximation:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateLightPattern` 函数创建这个光模式或背景近似：'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This `basic` function applies a blur to an input image using a big kernel size
    relative to the image size. From the code, it is one-third of the original width
    and height.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `basic` 函数使用相对于图像大小的大核大小对输入图像进行模糊处理。从代码中可以看出，它是原始宽度和高度的三分之一。
- en: The thresholding operation
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阈值操作
- en: 'After removing the background, we only have to binarize the image for future
    segmentation. Now, we will apply the `threshold` function using two different
    threshold values: a very low value when we remove the light/background because
    all non-interest regions are black or very low values, and a medium value when
    we do not use a light removal method because we have a white background and the
    object images have lower values. This last option allows us to check the results
    with and without the background removal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除背景后，我们只需要对图像进行二值化以便进行未来的分割。现在，我们将使用 `threshold` 函数并应用两个不同的阈值值：当我们移除光/背景时使用一个非常低的值，因为所有非感兴趣区域都是黑色或非常低的值，而在我们不使用光移除方法时使用中等值，因为我们有一个白色背景，而目标图像的值较低。这个最后的选项允许我们检查带有和不带有背景移除的结果：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will continue with the most important part of our application: the
    segmentation. We will use two different approaches or algorithms: connected components
    and contours.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续到我们应用程序最重要的部分：分割。我们将使用两种不同的方法或算法：连通分量和轮廓。
- en: Segmenting our input image
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对输入图像进行分割
- en: 'Now, we will introduce you to the following two techniques used to segment
    our thresholded image:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍用于分割我们的阈值图像的以下两种技术：
- en: The connected components
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连通分量
- en: The `findContours` function
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findContours` 函数'
- en: With these two techniques, we will be allowed to extract each region of interest
    of our image where our target objects appear; in our case, a nut, screw, and ring.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种技术，我们将能够提取图像中每个感兴趣区域，其中我们的目标对象出现；在我们的案例中，是一个螺母、螺丝和环。
- en: The connected component algorithm
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连通分量算法
- en: 'The connected component is a very common algorithm used to segment and identify
    parts in binary images. A connected component is an iterative algorithm used for
    the purpose of labeling an image using an 8- or 4-connectivity pixel. Two pixels
    are connected if they have the same value and are neighbors. In the following
    figure, each pixel has eight neighbor pixels:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 连通分量是一个非常常用的算法，用于在二值图像中分割和识别部分。连通分量是一个迭代算法，用于使用8-或4-连通性像素标记图像。如果两个像素具有相同的值并且是邻居，则它们是连通的。在以下图中，每个像素有八个邻居像素：
- en: '![The connected component algorithm](img/B04283_05_11.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![连通分量算法](img/B04283_05_11.jpg)'
- en: A 4-connectivity means that only the 2, 4, 5, and 7 neighbors can be connected
    to the center if they have the same value. In the case of 8-connectivity, 1, 2,
    3, 4, 5, 6, 7, and 8 can be connected if they have the same value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 4-连通性意味着如果中心像素的邻居像素（2、4、5和7）具有相同的值，则它们可以连接到中心。在8-连通性情况下，如果它们具有相同的值，则1、2、3、4、5、6、7和8可以连接。
- en: 'In the following example, we can see the difference between an eight and four
    connectivity algorithm. We will apply each algorithm to the next binarized image.
    We used a small 9 X 9 image and zoomed it to show how connected components, and
    the difference between an 4- and 8-connectivity, work:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到八连通性和四连通性算法之间的区别。我们将对下一个二值化图像应用每个算法。我们使用了一个小的9 X 9图像，并将其放大以显示连通分量以及4-连通性和8-连通性之间的区别是如何工作的：
- en: '![The connected component algorithm](img/B04283_05_12.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![连通分量算法](img/B04283_05_12.jpg)'
- en: 'The 4-connectivity algorithm detects two objects, as shown on the left-hand
    side image. The 8-connectivity algorithm detects only one object (the right-hand
    side image) because two diagonal pixels are connected, whereas in a 4-connectivity
    algorithm, only vertical and horizontal pixels are connected. We can see the result
    in the following figure, where each object has a different gray color value:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 4-连通性算法检测到两个对象，如图中左侧图像所示。8-连通性算法只检测到一个对象（右侧图像），因为两个对角像素是连通的，而在4-连通性算法中，只有垂直和水平像素是连通的。我们可以在以下图中看到结果，其中每个对象都有不同的灰度颜色值：
- en: '![The connected component algorithm](img/B04283_05_13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![连通分量算法](img/B04283_05_13.jpg)'
- en: 'OpenCV 3 introduces you to the connected components algorithm with the following
    two different functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 3通过以下两个不同的函数介绍了连通分量算法：
- en: '`connectedComponents(image, labels, connectivity=8, type=CV_32S)`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connectedComponents(image, labels, connectivity=8, type=CV_32S)`'
- en: '`connectedComponentsWithStats(image, labels, stats, centroids, connectivity=8,
    ltype=CV_32S)`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connectedComponentsWithStats(image, labels, stats, centroids, connectivity=8,
    ltype=CV_32S)`'
- en: Both the functions return an integer with the number of detected labels, where
    the label `0` represents the background.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都返回一个整数，表示检测到的标签数量，其中标签`0`代表背景。
- en: 'The difference between these two functions is basically the information that
    returns each one. Let''s check the parameters of each one. The `connectedComponents`
    function give us the following parameters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数之间的区别基本上是每个函数返回的信息。让我们检查每个函数的参数。`connectedComponents`函数提供了以下参数：
- en: '**Image**: This is the input image to be labeled.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：这是要标记的输入图像。'
- en: '**Labels**: This is a `mat` output with the same size of an input image, where
    each pixel has the value of its label, and all `0`''s represent the background,
    the pixels that have `1` as values represent the first connected component object,
    and so on.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：这是一个与输入图像大小相同的`mat`输出，其中每个像素的值为其标签，所有`0`表示背景，值为`1`的像素表示第一个连通分量对象，依此类推。'
- en: '**Connectivity**: This has two possible values: `8` or `4` that represents
    the connectivity we want to use.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连通性**：有两个可能的值：`8`或`4`，表示我们想要使用的连通性。'
- en: '**Type**: This is the type of the label image that we would want to use: only
    two types are allowed, `CV32_S` or `CV16_U`. By default, it is `CV32_S`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：这是我们想要使用的标签图像类型：只允许两种类型，`CV32_S`或`CV16_U`。默认情况下，它是`CV32_S`。'
- en: 'The `connectedComponentsWithStats` function has two more parameters that are
    defined: stats and centroids parameters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectedComponentsWithStats`函数有两个额外的参数被定义：stats和centroids参数：'
- en: '`Stats`: This is an output parameter for each label, including the background
    label. The following statistics values can be accessed via stats (label, column),
    where columns are defined as well, as follows:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stats`：这是每个标签的输出参数，包括背景标签。可以通过stats（标签，列）访问以下统计值，其中列也被定义为如下：'
- en: '`CC_STAT_LEFT`: This is the leftmost x coordinate of a connected component
    object'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC_STAT_LEFT`: 这是连通分量对象的最左侧x坐标'
- en: '`CC_STAT_TOP`: This is the topmost y coordinate of a connected component object'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC_STAT_TOP`: 这是连通分量对象的最上侧y坐标'
- en: '`CC_STAT_WIDTH`: This is the width of a connected component object defined
    by its bounding box'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC_STAT_WIDTH`: 这是通过其边界框定义的连通分量对象的宽度'
- en: '`CC_STAT_HEIGHT`: This is the height of a connected component object defined
    by its bounding box'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC_STAT_HEIGHT`: 这是通过其边界框定义的连通分量对象的高度'
- en: '`CC_STAT_AREA`: This is the number of pixels (area) of the connected component
    object'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC_STAT_AREA`: 这是连通分量对象的像素数（面积）'
- en: '`Centroids`: The centroid points in `float` type for each label inclusive of
    the background'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Centroids`: 每个标签（包括背景）的质心点以`float`类型表示'
- en: In our example application, we will create two functions that are to be applied
    to these two OpenCV algorithms and show the user the obtained result in a new
    image with colored objects in the basic algorithm and draw the area of the stats
    algorithm for each object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们将创建两个函数，这些函数将应用于这两个OpenCV算法，并将用户通过一个新图像显示基本算法中带有彩色对象的结果，并绘制每个对象的统计算法区域。
- en: 'Let''s define the basic drawing of the connected `component` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义连通`分量`的基本绘制函数：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First of all, we call the OpenCV `connectedComponents` function that returns
    the number of objects detected. If the number of objects is less than two, this
    means that only the background object is detected, and then, we don''t need to
    draw anything and finish. If the algorithm detects more than one object, then
    we show the number of objects detected via the terminal:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用OpenCV的`connectedComponents`函数，该函数返回检测到的对象数量。如果对象数量少于两个，这意味着只检测到了背景对象，那么我们不需要绘制任何内容并结束。如果算法检测到多个对象，那么我们通过终端显示检测到的对象数量：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we will draw all the detected objects in a new image with different colors,
    and then we need to create a new black image with the same input size and three
    channels:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用不同颜色在一张新图像中绘制所有检测到的对象，然后我们需要创建一个与输入大小相同且具有三个通道的新黑色图像：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we need to loop over each label, except the *0* value because it''s the
    background label:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要遍历每个标签，除了*0*值，因为它代表背景标签：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To extract each object from the label image, we need to create a mask for each
    label `i` using a comparison, and save it in a new image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从标签图像中提取每个对象，我们需要为每个标签`i`创建一个掩码，使用比较并保存到新图像中：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we set a pseudo-random color to the output image using the mask:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用掩码将伪随机颜色设置到输出图像中：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After we loop all images, we have all the objects with different colors in
    our output image, and we only have to show the output image:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们遍历所有图像后，我们输出图像中就有了不同颜色的所有对象，我们只需要显示输出图像：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the result where each object is painted with a different color or gray
    value:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果，每个对象都使用不同的颜色或灰度值进行着色：
- en: '![The connected component algorithm](img/B04283_05_14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![连通分量算法](img/B04283_05_14.jpg)'
- en: 'Now, we will explain how to use the connected components with the stats OpenCV
    algorithm and show some more information in the output result image. The following
    function implements this functionality:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将解释如何使用带有统计信息的OpenCV连通分量算法，并在输出结果图像中显示更多信息。以下函数实现了这一功能：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s understand the code, as we did in the non-stats function. We call the
    connected components algorithm; but, in this case, using the `stats` function,
    we check whether we can detect more than one object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解代码，就像我们在非统计函数中做的那样。我们调用连通分量算法；但在这个情况下，使用`stats`函数，我们检查是否可以检测到多个对象：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we have two more output results: the `stats` and `centroids` variables.
    Then, for each label that we detect, we will show its centroid and area via the
    command line:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还有两个额外的输出结果：`stats`和`centroids`变量。然后，对于每个检测到的标签，我们将通过命令行显示其质心和面积：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can check the call to the `stats` variable in order to extract the area
    using the `stats.at<int>(I, CC_STAT_AREA)` column constant.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过检查`stats`变量的调用来提取面积，使用`stats.at<int>(I, CC_STAT_AREA)`列常量。
- en: 'Now, as mentioned earlier, we paint the output image of the object labeled
    with the `i` number:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如前所述，我们用`i`号标记的对象的输出图像进行着色：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we need to add over the image, in the centroid of the object segmented,
    some info like the area. To do this, we use the `stats` and `centroid` variables
    using the `putText` function. First, we need to create a stringstream to add the
    stats area information:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在分割对象的质心处添加一些信息，如面积。为此，我们使用`stats`和`centroid`变量以及`putText`函数。首先，我们需要创建一个stringstream来添加统计面积信息：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, use the `putText` using the centroid as the text position:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用质心作为文本位置来调用`putText`：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result of this function looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的结果看起来像这样：
- en: '![The connected component algorithm](img/B04283_05_15.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![连接组件算法](img/B04283_05_15.jpg)'
- en: The findContours algorithm
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The findContours algorithm
- en: 'The `findContours` algorithm is one of the most frequently used OpenCV algorithms
    to segment objects. This algorithm has been included in OpenCV since its first
    version and provides more information and descriptors, such as shapes, topological
    organizations, and so on, to the developers:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`findContours`算法是OpenCV中最常用的算法之一，用于分割对象。这个算法自OpenCV的第一个版本以来就被包含在内，并为开发者提供了更多信息和描述符，如形状、拓扑组织等：'
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s explain each parameter, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个解释每个参数，如下所示：
- en: '**Image**: This is the input binary image.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：这是输入的二值图像。'
- en: '**Contours**: This is the contours output where each detected contour is a
    vector of points.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮廓**：这是轮廓输出，其中每个检测到的轮廓都是一个点的向量。'
- en: '**Hierarchy**: This is the optional output vector where we store the hierarchy
    of contours. This is the topology of the image where we can get the relations
    between each contour.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**：这是可选的输出向量，用于存储轮廓的层次结构。这是图像的拓扑结构，其中我们可以获取每个轮廓之间的关系。'
- en: '**Mode**: This is the method used to retrieve the contours:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式**：这是检索轮廓的方法：'
- en: '`RETR_EXTERNAL`: This retrieves only the external contours.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RETR_EXTERNAL`: 这只检索外部轮廓。'
- en: '`RETR_LIST`: This retrieves all the contours without establishing the hierarchy.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RETR_LIST`: 这将检索所有轮廓而不建立层次结构。'
- en: '`RETR_CCOMP`: This retrieves all the contours with two levels of hierarchy:
    external and holes. If another object is inside one hole, then this is put on
    the top of the hierarchy.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RETR_CCOMP`: 这检索所有具有两个层次结构的轮廓：外部和孔洞。如果一个对象在孔洞内部，那么它将位于层次结构的顶部。'
- en: '`RETR_TREE`: This retrieves all the contours that create a full hierarchy between
    contours.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RETR_TREE`: 这检索创建轮廓之间完整层次结构的所有轮廓。'
- en: '**Method**: This allows you to perform the approximation method to retrieve
    the contours'' shapes:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：这允许你执行近似方法以检索轮廓的形状：'
- en: '`CV_CHAIN_APPROX_NONE:` This does not apply any approximation to the contours
    and stores all the contours points.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_CHAIN_APPROX_NONE:` 这不对轮廓应用任何近似，并存储所有轮廓点。'
- en: '`CV_CHAIN_APPROX_SIMPLE`: This compresses all the horizontal, vertical, and
    diagonal segments that store only the start and end points.'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_CHAIN_APPROX_SIMPLE`: 这压缩了所有只存储起点和终点的水平、垂直和对角线段。'
- en: '`CV_CHAIN_APPROX_TC89_L1,CV_CHAIN_APPROX_TC89_KCOS` This applies the Teh-Chin
    chain approximation algorithm.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CV_CHAIN_APPROX_TC89_L1,CV_CHAIN_APPROX_TC89_KCOS` 这应用了Teh-Chin链近似算法。'
- en: '**Offset**: This is the optional point value used to shift all the contours.
    This is very useful when we work in a ROI and is required to retrieve the global
    positions.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏移量**：这是用于移动所有轮廓的可选点值。当我们在一个ROI中工作时，这非常有用，并且需要检索全局位置。'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The input image is modified by the `findContours` function. Create a copy of
    your image before it is sent to this function if you need it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输入图像被`findContours`函数修改。如果你需要它，在将其发送到该函数之前创建图像的副本。
- en: 'Now that we know the parameters of the `findContours` function, let''s apply
    them to our example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`findContours`函数的参数，让我们将它们应用到我们的示例中：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's understand our implementation line by line.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行理解我们的实现。
- en: 'In our case, we don''t require any hierarchy, so we will retrieve only the
    external `contours` of all possible objects. To do this, we use the `RETR_EXTERNAL`
    mode, and we use the basic contour encoding scheme using the `CHAIN_APPROX_SIMPLE`
    method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们不需要任何层次结构，因此我们将只检索所有可能对象的`contours`的外部轮廓。为此，我们使用`RETR_EXTERNAL`模式，并使用`CHAIN_APPROX_SIMPLE`方法的基本轮廓编码方案：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similar to the connected components examples mentioned earlier, we first check
    how many `contours` we have retrieved. If there are none, then we exit from our
    function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面提到的连接组件示例类似，我们首先检查我们检索了多少`contours`。如果没有，则从我们的函数中退出：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we draw each detected `contour` that we detect, and we draw it in
    our output image with a different color. To do this, OpenCV provides us with a
    function to draw the result of the find `contours` image:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绘制了我们检测到的每个`等高线`，并在输出图像中以不同的颜色绘制它们。为此，OpenCV为我们提供了一个函数来绘制查找`等高线`图像的结果：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `drawContours` function allows the following parameters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawContours` 函数允许以下参数：'
- en: '**Image**: This is the output image used to draw the contours.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：这是用于绘制等高线的输出图像。'
- en: '**Contours**: This is the vector of contours.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等高线**：这是等高线向量。'
- en: '**Contour index**: This is a number that indicates the contour to be drawn;
    if it is negative, all the contours are drawn.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等高线索引**：这是一个指示要绘制的等高线的数字；如果它是负数，则绘制所有等高线。'
- en: '**Color**: This is the color used to draw the contour.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：这是绘制等高线所用的颜色。'
- en: '**Thickness**: If this is negative, then the contour is filled with the color
    chosen.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**厚度**：如果这个值为负，则等高线将用所选颜色填充。'
- en: '**Line type**: This is used when we want draw with antialiasing, or other drawing
    methods.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线型**：当我们想要使用抗锯齿或其他绘图方法时使用。'
- en: '**Hierarchy**: This is an optional parameter and is only needed if you want
    to draw only some of the contours.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**：这是一个可选参数，只有在你想只绘制一些等高线时才需要。'
- en: '**Max level**: This is an optional parameter and taken into account only when
    the hierarchy parameter is available. If it is set to 0, only the specified contour
    is drawn, and if it is set to 1, the function draws the current contour and the
    nested as well. If it is set to 2, then the algorithm draws all the specified
    contour hierarchies.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大层级**：这是一个可选参数，仅在存在层次结构参数时才考虑。如果设置为0，则只绘制指定的等高线；如果设置为1，则函数绘制当前等高线和嵌套的等高线；如果设置为2，则算法绘制所有指定的等高线层级。'
- en: '**Offset**: This is an optional parameter used to shift the contours.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏移量**：这是一个可选参数，用于移动等高线。'
- en: 'The result of our example can be shown in the following image:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果可以在以下图像中显示：
- en: '![The findContours algorithm](img/B04283_05_16.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![findContours 算法](img/B04283_05_16.jpg)'
- en: After a binarized image, we can see the three different algorithms that are
    used to divide and separate each object of an image, allowing us to isolate each
    object in order to manipulate or extract features.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在二值化图像之后，我们可以看到三种不同的算法被用来分割和分离图像中的每个对象，使我们能够隔离每个对象以便进行操作或提取特征。
- en: 'We can see the entire process in the following image:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图像中看到整个过程：
- en: '![The findContours algorithm](img/B04283_05_17.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![findContours 算法](img/B04283_05_17.jpg)'
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the basics of object segmentation in a controlled
    situation, where a camera take pictures of different objects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在受控情况下进行对象分割的基础，其中摄像机拍摄不同对象的图片。
- en: We learned how to remove the background and light in order to allow us to binarize
    our image by minimizing the noise and also three different algorithms used to
    divide and separate each object of an image, allowing us to isolate each object
    in order to manipulate or extract features. Finally, we extracted all the objects
    on an image, where we are going to extract characteristics of each of these objects
    to train a machine learning system.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何去除背景和光线，以便通过最小化噪声来二值化我们的图像，以及三种不同的算法用于分割和分离图像中的每个对象，使我们能够隔离每个对象以便进行操作或提取特征。最后，我们在图像中提取了所有对象，我们将从这些对象中提取特征来训练机器学习系统。
- en: In the next chapter, we are going to predict the class of any of objects in
    an image, and then call to a robot or any other system to pick any of them, or
    detect an object that is not in the correct carrier tape, and then notify to a
    person to pick it up.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将预测图像中任何对象的类别，然后调用机器人或其他系统来选择其中的任何一个，或者检测不在正确载体带上的对象，然后通知人员将其取走。
