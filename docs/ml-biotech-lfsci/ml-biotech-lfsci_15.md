# 第十二章：将应用程序部署到云

在上一章中，我们专注于将我们的模型集成到**Flask**框架中，以开发两种向最终用户提供服务的主要方法：**图形用户界面**（**GUIs**）和**应用程序编程接口**（**APIs**）。使用 Flask 框架，我们成功地将我们的模型仅用于开发目的进行本地部署。在本章中，我们将迈出下一步，将我们的模型部署到云中，使其不仅对我们本地可用，而且对网络上的许多其他用户也可用。

目前有许多不同的部署平台，例如**亚马逊网络服务**（**AWS**）、**谷歌云平台**（**GCP**）、Azure 和 Heroku，每个平台都旨在满足多种需求。在这些平台中的每一个，都有许多解决方案，每个解决方案都有其各自的优缺点。对于这些解决方案中的每一个，我们都有许多方法可以在其中部署一个框架。本质上，部署解决方案的可能方式数量实际上是无法计数的，因此用户可能会感到容易不知所措。在本章的整个过程中，我们将探讨新开发者通常采取的一些最常见和最直接的方法来部署他们的应用程序。

在接下来的几节中，我们将涵盖以下主题：

+   探索当前的云计算平台

+   理解容器和镜像

+   教程 – 将容器部署到 AWS（Lightsail）

+   教程 – 将应用程序部署到 GCP（App Engine）

+   教程 – 将应用程序代码部署到 GitHub

带着这些目标，让我们继续前进，开始吧！

# 探索当前的云计算平台

在过去几年中，最显著的技术趋势之一是转向云计算。尽管大多数公司过去更喜欢拥有、运营和维护自己的数据中心和基础设施，但现在全球大多数企业都采用以云为先的方法。公司选择这条道路的原因有很多，比如成本降低、可扩展性、安全性等等。鉴于对云计算能力的需求激增，许多云计算平台开始响应这一数字世界的重大运动而增长和扩张。

在过去几年中，许多这些云计算平台不仅开始开发解决方案以满足主要的基础设施需求，而且开始专注于数据科学领域内的特定需求。主要平台是**AWS**、**GCP**和**微软 Azure**，如下面的图所示：

![图 12.1 – 一些常见的云计算平台](img/B17761_12_001.jpg)

图 12.1 – 一些常见的云计算平台

世界各地的许多公司通常以**企业级**的运营水平使用这些提供商之一来保持一致性。从数据科学家和开发者的角度来看，这些平台几乎相同，因为它们通常包含非常相似的工具来满足我们的需求。

这些平台中的每一个都包含了许多旨在部署框架并将它们以某种形式提供给最终用户的解决方案。这些资源提供给最终用户程度的不同，通常就是这些平台之间的区别。例如，开发者可能期望特定 Web 应用有很高的活动量，因此可能会决定使用**AWS Elastic Beanstalk**或**Amazon** **Elastic Container Service**（**ECS**）来部署他们的模型。另一方面，另一个用户可能只想以最简单的方式将他们的 Web 应用部署给少数用户，因此会选择使用**Amazon Elastic Compute Cloud**（**EC2**）。在任何情况下，开发者选择的特定解决方案通常是基于具体需求来选择的。让我们继续看看以下截图中所描述的一些最受欢迎的解决方案：

![图 12.2 – 部署 Web 应用的一些最常用工具](img/B17761_12_002.jpg)

图 12.2 – 部署 Web 应用的一些最常用工具

当谈到部署**Flask**应用时，近年来在数据科学社区中，三种部署方案已经获得了很大的影响力。每个方案都有其各自的优缺点，确保特定 Web 应用的业务需求与这些平台中任何一个最佳解决方案相匹配，这是数据科学家或开发者的责任。

随着 Web 应用的普及，很快变得明显的是，应用内部的一致性是必要的，以确保开发者在某个平台上创建和部署的应用可以轻松地以最小的更改在另一个平台上部署。在下一节中，我们将通过一个名为**Docker**的例子来讨论容器化的概念。

# 理解容器和镜像

构建和部署 Web 应用的最简单方法之一是通过使用**容器**。我们可以将容器视为包含构成 Web 应用所有项目的桶或容器，但以**操作系统**（**OS**）**虚拟化**的形式。回想一下上一章——*第十一章*，*使用 Flask 部署模型*——我们在其中创建了一个虚拟环境来更好地维护为应用安装所需的包。容器可以以相当类似的方式思考，只是在操作系统级别。

容器由许多项目组成，如可执行文件、库、二进制代码等等。鉴于它们不包含服务器通常具有的一些较重的项目，如操作系统镜像，因此被认为开销较小，更轻量。由于这些轻量级容器被认为是打包好并随时可用的，因此开发人员（或自动化系统）能够轻松部署多个容器实例以满足特定网站或应用增加的流量需求。

## 理解容器的好处

在管理和部署 Web 应用时，使用容器有许多好处，尤其是在企业规模上。最终，它们提供了一种一致且高效的构建、部署和管理多个应用的方式。以下是一些主要好处：

+   **更大的可扩展性**—轻松部署更多实例以满足特定需求。

+   **提高可移植性**—部署到不同的平台和操作系统。

+   **降低开销**—比传统方法使用更少的资源。

容器在许多不同领域都非常有效——特别是两个领域属于微服务和自动化。在微服务的情况下，应用通常被分解成更小的组件，每个组件都需要独立于其他组件部署和扩展。在这种情况下，容器是解决该问题的绝佳解决方案并不令人惊讶。另一方面，在自动化的情况下，容器可以轻松地以自动化的方式创建或删除，这使得它们对于可扩展性以及**持续集成/持续部署**（**CI/CD**）管道非常有用。

重要提示

我们可以将 CI/CD 管道视为自动化软件交付的方法，以标准化流程并减少人为错误。任何给定的 CI/CD 管道通常有四个阶段：将新代码推送到 GitHub 等存储库（我们将在本章后面看到），构建脚本构建或编译代码，测试脚本测试代码的某些部分，最后是托管最终产品的部署平台。

在接下来的教程中，我们将探讨部署容器的过程——具体来说，是将 Docker 容器部署到 AWS Lightsail。

# 教程 - 将容器部署到 AWS（Lightsail）

**AWS Lightsail**是一个管理云平台，由于其简单的界面和快速的部署能力，近年来获得了极大的普及，并且是使用 AWS 部署应用时入门的绝佳方式。与 AWS 的其他产品或解决方案相比，使用 Lightsail 的一些最常见用例包括简单的**机器学习**（**ML**）Web 应用（如我们的应用！），静态投资组合网站，动态电子商务网站，以及简单的 API。

在本教程的过程中，我们将使用 AWS **命令行界面**（**CLI**）将我们的 Flask 应用程序部署到 AWS Lightsail。您可以通过访问 AWS CLI 页面（[`docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html`](https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html)）来安装 CLI，选择感兴趣的操作系统，并按照安装说明进行操作。您可以通过运行以下命令来确认 CLI 是否正确安装：

```py
$ aws configure --profile 
```

如果安装完成正确，您将进入配置过程。请继续按照需要配置 CLI。此过程可能需要请求 **身份和访问管理**（**IAM**）凭据——请提供我们之前示例中的正确凭据，或者准备一套新的凭据，就像我们在 *第九章* 的 *自然语言处理* 部分，特别是 *处理非结构化数据* 部分中所做的那样。

在 CLI 和凭据都设置好的情况下，现在让我们再次专注于应用程序，从内容开始。如果您还记得从 *第十一章* 的 *使用 Flask 应用程序部署模型*，应用程序的内容现在应包括虚拟环境、`styles.css`、`index.html`，当然还有 `app.py`，如下面的截图所示：

![图 12.3 – 当前工作目录的内容](img/B17761_12_003.jpg)

图 12.3 – 当前工作目录的内容

为了部署我们的应用程序，我们还需要一些文件，我们将很快探索这些文件，以帮助部署过程和容器化过程。除了 AWS Lightsail，我们还将使用 **Docker**——这是一个常用的工具，允许用户在隔离的容器中创建、部署和运行应用程序。您可以通过访问 Docker 网站下载适用于您特定操作系统的 Docker ([`docs.docker.com/get-docker/`](https://docs.docker.com/get-docker/))。让我们继续探索这些新文件，它们的内容以及它们如何在应用程序中使用。

首先，我们从 Dockerfile 开始，它包含一系列准备应用程序环境的指令。这些指令包括 Python 版本、设置工作目录、复制感兴趣的文件，当然还有安装需求。代码如下所示：

```py
FROM python:3.8
EXPOSE 5000/tcp
WORKDIR /app
COPY requirements.txt .
COPY models/ch10_scaler.pickle /models/ch10_scaler.pickle
COPY models/ch10_scaler.pickle /models/ch10_rfc_clf.pickle
COPY styles /app/styles
COPY models /app/models
COPY templates /app/templates
COPY app.py .
ENV IN_DOCKER_CONTAINER Yes
RUN pip install --upgrade pip
RUN pip3 install -r requirements.txt
CMD [ "python", "./app.py" ]
```

在准备好的 Dockerfile 之后，我们现在可以继续构建容器镜像。我们可以使用之前安装的 Docker 来构建容器，通过执行以下命令：

```py
$ docker build -t flask-container .
```

执行此命令（不要忘记末尾的 `.`，它表示当前目录！）后，Docker 将构建一个标记为 `flask-container` 的容器。

我们下一步将使用 AWS CLI 创建一个容器服务。我们可以通过执行以下代码来完成此操作，其中我们指定了 `service-name`、`power` 和 `scale` 参数。请注意，这些参数指定了服务的容量：

```py
$ aws lightsail create-container-service --service-name flask-service --power small --scale 1
```

执行此命令后，你应该能够监控进度。一旦服务从 `pending` 状态变为 `active`，你可以执行下一个命令，该命令推送容器镜像：

```py
$ aws lightsail push-container-image --service-name flask-service
--label flask-container --image flask-container
```

执行此命令后，你将在结果中看到以下值：

```py
":flask-service.flask-container.X"
```

请注意，`X` 应该是一个与将镜像推送到容器服务时的时间相对应的数值。如果你是第一次这样做，该值应该是 `1`。

接下来，我们需要创建一个名为 `containers.json` 的文件，指定 Flask 镜像以及端口，包含以下代码：

```py
{
    "flask": {
        "image": ":flask-service.flask-container.X",
        "ports": {
            "5000": "HTTP"
        }
    }
}
```

将 `X` 替换为你之前收到的数值。再次提醒，如果你是第一次部署容器，该值应该是 `1`。完成这些后，我们现在可以继续创建我们的最终文件 `public-endpoint.json`，该文件指定了容器名称和端口，包含以下代码：

```py
{
    "containerName": "flask",
    "containerPort": 5000
}
```

到目前为止，目录的层次结构应包括所有之前的文件，以及 `containers.json`、`Dockerfile` 和 `public-endpoint.json`，如图下所示：

![图 12.4 – 当前工作目录的内容](img/B17761_12_004.jpg)

图 12.4 – 当前工作目录的内容

现在文件和容器都已就绪，我们可以继续进行将容器部署给最终用户的最后步骤。为此，我们可以使用 `create-container-service-deployment` 命令，以下代码：

```py
$ aws lightsail create-container-service-deployment --service-name flask-service --containers file://containers.json --public-endpoint file://public-endpoint.json
```

执行代码后，你应该会看到应用程序的状态被列为 `get-container-services` 命令，通过执行以下命令来监控当前应用程序：

```py
$ aws lightsail get-container-services --service-name flask-service
```

命令完成后，你将看到一个**统一资源定位符**（**URL**）作为输出。前往列出的 URL，你应该能够看到我们开发的在线应用程序，并且可供我们的最终用户使用。以下是一个示例截图：

![图 12.5 – 在 AWS Lightsail 上运行的 Web 应用程序](img/B17761_12_005.jpg)

图 12.5 – 在 AWS Lightsail 上运行的 Web 应用程序

或者，你可能想通过 AWS 上的管理控制台查看应用程序。为此，导航到控制台并搜索 AWS Lightsail。你应该会被重定向到 AWS Lightsail 页面，在那里你应该能看到你的实例和容器，如图下所示：

![图 12.6 – AWS Lightsail 管理控制台](img/B17761_12_006.jpg)

图 12.6 – AWS Lightsail 管理控制台

在本教程中，我们成功地将我们的本地 Flask 实现部署为 Web 应用程序到 AWS。在下一个教程中，我们将部署相同的应用程序到 GCP 的 App Engine。

# 教程 - 将应用程序部署到 GCP（App Engine）

在本教程中，我们将部署相同的应用程序到 GCP 的 App Engine。与大多数其他云平台相比，GCP 最大的好处是易于使用，同时确保用户可以以最小的问题和错误部署模型。考虑到这一点，让我们继续将我们的应用程序部署到 GCP。

我们可以从安装`y`键开始，如下所示：

```py
You must log in to continue. Would you like to log in (Y/n)?  y
```

您将被重定向到浏览器，您可以使用您的 Google 账户登录。请使用与我们在上一章*第七章*，“监督式机器学习”，关于 GCP 所使用的相同 Google 凭证登录。

登录后，您将被提示选择一个项目。选择您在本书中之前创建的项目。请继续完成任何其他剩余的项目，如默认区域，并完成配置。

完成后，您应该在您的系统上安装了`gcloud` CLI。请确保重新启动您正在使用的命令行窗口，因为一些`PATH`变量可能需要刷新。

现在 CLI 已安装并运行，我们可以继续开始。导航到附带的代码中找到的`flask_cancer_ae`目录。我们需要在我们的目录中创建一个名为`app.yaml`的新文件，包含以下代码：

```py
runtime: python37
```

这将简单地指定我们应用程序的运行时间。保存此文件后，我们可以继续进行一些初步配置。我们首先需要设置项目**标识符**（**ID**），如果我们还没有这样做，可以使用以下命令：

```py
$ gcloud config set project GCP-PROJECT-ID
```

请确保将`GCP-PROJECT-ID`替换为您关联的项目 ID。设置完成后，我们现在需要启用**Cloud Build CLI**，它用于使用我们的文件创建应用程序的容器，以下命令：

```py
$ gcloud services enable cloudbuild.googleapis.com
```

接下来，我们将为此特定项目在**App Engine**中初始化应用程序。我们可以使用以下命令来完成：

```py
$ gcloud app create --project= GCP-PROJECT-ID
```

请确保将`GCP-PROJECT-ID`替换为您特定的项目 ID。最后，为了继续部署项目，我们可以使用以下命令：

```py
$ gcloud app deploy
```

一旦过程完成，项目将被部署到 GCP！我们可以使用以下命令检查应用程序，如下所示：

```py
$ gcloud app browse
```

除了使用 CLI 之外，我们还可以访问 GCP 控制台中找到的**App Engine 仪表板**以完成以下任务：

+   访问应用程序。

+   监控流量。

+   检查账单。

+   …以及更多！

GCP 拥有许多令人惊叹的功能，在部署应用程序、管理数据和监控流量方面为用户提供极佳的体验。如果您对学习更多关于 GCP 感兴趣，我强烈建议您关注并完成 GCP 平台提供的许多优秀教程。

现在我们已经将应用程序部署到 GCP，我们的下一步将是探索将我们的代码发送到其他地方的不同方式：通过`git` CLI。在下一节中，我们将探讨将代码推送到 GitHub 的过程。

# 教程 – 将应用程序代码部署到 GitHub

在过去的两个教程中，我们将我们的应用程序部署到云平台，以便用户可以使用 Flask 框架与我们的模型进行交互。在第一个平台中，我们使用了 AWS Lightsail，在第二个平台中，我们使用了 GCP 的 App Engine。在这个教程中，我们的目标将是部署我们的代码，不是为了使模型对用户可用，而是为了向其他数据科学家以及潜在的未来雇主展示我们的代码和辛勤工作。我们将通过使用**GitHub**来部署我们的代码来实现这一点。

本书中的所有编码示例和教程都已通过 GitHub 在线提供。如果您还没有这样做，我强烈建议您创建自己的账户。您可以将 GitHub 视为程序员的 LinkedIn——一个展示您辛勤工作的空间。

您可以通过访问他们的官方网站([`github.com/`](https://github.com/))并注册为新用户来创建一个免费的 GitHub 账户。一旦您注册成功，您就可以保存您的代码并与项目或仓库一起工作。您可以将仓库视为一个保存您工作的空间，其中保存了多个版本，以便用户在需要时可以回滚到旧代码。

这种方式是用户将在他们的计算机上本地有一个给定项目或仓库的实例或副本。每当取得重大进展时，用户可以做出更新或提交，然后将这些新更改推送到远程仓库以进行备份，如图所示：

![图 12.7 – 本地与远程仓库](img/B17761_12_007.jpg)

图 12.7 – 本地与远程仓库

在创建好您的个人资料后，让我们继续在命令行上安装`git`。我们可以通过导航到[`git-scm.com/book/en/v2/Getting-Started-Installing-Git`](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)并为您的操作系统安装`git`来开始操作。您可以通过在命令行上运行`git`命令来确认安装是否成功，它应该会返回一个命令和可能的参数列表。

让我们继续使用命令行导航到我们之前部署的一个应用程序。根据您在本地计算机上创建应用程序的位置，您的路径可能看起来像这样：

```py
C:\Users\Username\Documents\GitHub\Machine-Learning-in-Biotechnology-using-Python\chapters\chapter12\flask_cancer_ls
```

通过命令行窗口或使用**Visual Studio Code**（**VSC**）导航到您的目录。一旦到达那里，使用以下命令**初始化**一个新的仓库：

```py
$ git init
```

一旦仓库初始化完成，我们将在您的 GitHub 账户上创建一个仓库（稍后连接到它）。我们可以通过以下简单步骤来完成：

1.  登录到您的新**GitHub**账户，如图所示：![图 12.8 – GitHub 登录页面](img/B17761_12_008.jpg)

    图 12.8 – GitHub 登录页面

1.  在主页面上，点击屏幕左侧的**新建**按钮，如图所示：![图 12.9 – 创建新仓库](img/B17761_12_009.jpg)

    图 12.9 – 创建新仓库

1.  给新仓库起一个名字，例如`flask-cancer-ls`。在保留所有其他字段为默认值的情况下，点击**创建仓库**，如图所示：

![图 12.10 – 创建新仓库（继续）](img/B17761_12_010.jpg)

图 12.10 – 创建新仓库（继续）

一旦创建完成，您将被重定向到一个新页面，其中包含一些供您使用的示例代码。鉴于我们已经创建了一个新的仓库，我们不需要再次进行这一步骤。如果我们回到命令行，我们可以继续运行以下命令，将我们的文件添加到`git`中，以便`git`确定需要发送到`add`命令的任何新更改，如下所示：

```py
$ git add app.py
```

或者，我们可以使用点表示法添加所有文件，如下所示：

```py
$ git add .
```

通常认为，逐个添加文件是更好的做法，因为这样出错的可能性较小。请相信我！

使用`add`命令将文件添加到**暂存区**后，我们的下一步是提交它们。我们可以将暂存区视为一个空间，用于存放即将发送到远程仓库的新代码。我们可以使用`commit`命令，并附上一个描述当前提交的有用消息，如下面的代码片段所示。您可以使用消息简要描述提交中的更改。这将使得在查看旧代码时，尝试在 GitHub 网站上找到特定的更改变得容易得多：

```py
$ git commit -m "This is my first commit"
```

执行此代码后，您可能会遇到一个错误，要求您指定您的姓名和电子邮件地址。请使用以下命令完成此操作：

```py
$ git config --global user.email "you@example.com"
$ git config --global user.name "Your Name"
```

在保存您的凭据并完成提交后，我们现在可以继续使用以下命令将我们的**本地仓库**和**远程仓库**链接起来：

```py
$ git remote add origin https://github.com/username/reponame.git
```

请确保将`username`和`reponame`替换为您各自的值！一旦完成，您可以继续完成最后一步，即使用以下命令将您的代码推送到 GitHub：

```py
$ git push origin master
```

完成这一步后，如果你导航回 GitHub 网站，你将能够在这里看到你的代码！与最后两个教程不同，在那里我们将代码以应用程序的形式部署到在线网站，供最终用户交互，这里的目的是将我们的代码和其他内容存储在一个安全的空间中。我们有选择让其他用户看到我们的代码或将其保留为私有的选项。此外，还有一些平台，如 Heroku，只需提供仓库链接，就能简单地部署应用程序。

# 摘要

在本章中，我们回顾了将我们的应用程序部署到云端最终用户的一些方法。首先，我们探讨了使用 AWS Lightsail，它允许我们以在线 Web 应用程序的形式部署我们的代码，使用 Docker 容器。接下来，我们探讨了使用 GCP 的 App Engine 来部署我们的代码，再次以在线 Web 应用程序的形式，使用其用户友好和抽象的方法。最后，我们将代码以仓库的形式部署到 GitHub，使我们能够向用户、专业人士和潜在的雇主 alike 暴露内容。

恭喜！随着本教程的最后部分完成，我们已到达这本书的结尾。回顾过去 12 章，我们在众多不同领域涵盖了众多不同主题。起初，我们学习了新的语言，如 Python 和**结构化查询语言**（**SQL**），并使用它们来分析和可视化我们的数据。然后，我们探索了最常见的一些机器学习（**ML**）和**深度学习**（**DL**）架构，并使用它们来开发强大的预测模型。接着，我们将注意力转向一些特定的应用领域，例如**自然语言处理**（**NLP**）和时间序列。最后，我们探索了几种使用 AWS 和 GCP 将我们的应用程序部署给最终用户的方法。尽管我们在本书中涵盖了大量的内容，但外面还有浩瀚的知识和信息宇宙等待你去探索。在你迈向下一个伟大冒险之前，有三件事你应该永远记住：

+   最简单的解决方案通常是最好的解决方案。如果你不需要，永远不要过度复杂化模型。

+   永远不要停止学习。我们生活在一个数字时代，新的发现正以前所未有的速度实现。

+   指标是你的最佳朋友。它们将引导你贯穿整个开发过程，并帮助你作为数据科学家提出论点。记住——一切都是推销。

现在有了这三件事，勇敢地去做数据科学吧！
