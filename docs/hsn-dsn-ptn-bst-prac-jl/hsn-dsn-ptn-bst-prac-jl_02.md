# 第一章：设计模式和相关的原则

现在，学习和应用设计模式是软件工程的一个重要方面。设计模式就像水一样——没有它们你无法生存。你不相信吗？只需问问招聘经理，你就会发现他们中的许多人不仅在职位发布中提到了设计模式，而且在面试中也提出了相关问题。人们普遍认为，设计模式是软件开发的重要成分，每个人都应该了解它们。

在本章中，我们将提供一些关于为什么设计模式是有用的以及它们在过去几十年里是如何为我们服务的背景信息。通过理解设计模式背后的动机，我们将能够提出一套指导原则，用于软件开发。本章将讨论以下主题：

+   设计模式的起源

+   软件设计原则

+   软件质量目标

让我们开始吧！

# 设计模式的起源

设计模式对计算机程序员来说不是一个新概念。自从 20 世纪 80 年代个人电脑变得价格更合理且更受欢迎以来，编程职业蓬勃发展，并为各种应用编写了大量代码。

我记得，当我 14 岁的时候，学习 BASIC 程序的 GOTO 语句是我觉得最酷的事情之一。它实际上允许我在任何时候将控制流程带到代码的另一个部分。也许并不令人惊讶，当我上大学时学习了结构化编程和 Pascal 语言，我开始意识到 GOTO 语句会产生混乱的意大利面代码。用 GOTO 进行分支是一个模式。它只是一个很糟糕的模式，因为它使得代码难以理解、跟踪和调试。在今天的*通用语言*中，我们称它们为反模式。当涉及到结构化编程技术时，将代码组织成小函数也是一个模式，这是编程课程中作为主流主题教授的内容。

当我从大学毕业时，我开始我的编程生涯，并花费了大量时间进行*黑客攻击*。我有机会进行各种研究，并了解系统是如何设计的。例如，我意识到 Unix 操作系统有一个美丽的设计。那是因为它由许多小程序组成，这些程序本身并没有很多功能，但你可以用任何数量的方式将它们组合起来，以解决更复杂的问题。我也非常喜欢 Scheme 编程语言，它起源于麻省理工学院的 AI 实验室。这种语言的简洁性和多功能性至今仍让我感到惊奇。Scheme 的遗产可以追溯到 Lisp，这对 Julia 语言的设计产生了一定的影响。

# 设计模式的出现

1994 年，当我深入到 C++和分布式计算中，为金融应用程序开发时，四位软件专业人士，也被称为四人帮或 GoF，聚集在一起并出版了一本关于设计模式的书，该书在面向对象编程社区中引起了轰动。该小组收集和分类了在开发大型系统时常用的 23 个设计模式。他们还选择使用**统一建模语言**（**UML**）和 C++、Smalltalk 来解释这些概念。

首次，一套设计模式被收集、组织、解释并广泛分发给软件开发者。也许该小组做出的最重大决定之一就是将这些模式组织成高度结构化和易于消费的格式。从那时起，程序员们可以轻松地相互交流他们如何设计软件。此外，他们可以使用通用符号直观地展示软件设计。当一个人谈论单例模式时，另一个人可以立即理解和甚至在自己的脑海中可视化该组件的工作方式。这不是很方便吗？

更令人惊讶的是，设计模式在构建优秀软件时突然成为了圣经。在某种程度上，使用它们甚至被视为编写优秀软件的唯一途径。GoF 模式在开发社区中被广泛传播，以至于许多人滥用它们，没有合理的理由就将它们应用到各个地方。问题是——*当你只有一把锤子时，一切看起来都像钉子！*并非所有问题都可以或应该用相同的模式来解决。当设计模式被过度使用或误用时，代码变得更加抽象、复杂，也更难以管理。

那么，我们从过去学到了什么？我们认识到，每个抽象都伴随着成本。每个设计模式都有其自身的优缺点。本书的主要目标之一不仅是讨论如何使用，还要讨论为什么使用或不使用，以及在什么情况下应该使用或不使用某个模式。作为软件专业人士，我们将装备所需的信息，以便在何时应用这些模式时做出良好的判断。

# 关于 GoF 模式的更多思考

GoF 设计模式分为三大类：

+   **创建型模式**：这些模式涵盖了以各种方式构建对象的方法。由于面向对象编程将数据和操作结合在一起，并且一个类可能继承祖先类的结构和行为，因此在构建大型应用程序时涉及一些复杂性。创建型模式有助于在各种情况下标准化对象创建方法。

+   **结构型模式**：这些模式涵盖了如何扩展或组合对象以形成更大的事物。这些模式的目的在于使软件组件更容易重用或替换。

+   **行为模式**：这涵盖了如何设计对象以执行单独的任务并相互通信。大型应用程序可以被分解成独立的组件，从而使代码更容易维护。面向对象编程范式要求对象之间有坚实的交互。这些模式的目的在于使软件组件更加灵活，并更方便彼此协作。

一种观点是，设计模式是为了解决各自编程语言中的局限性而创建的。在 GoF 书籍出版两年后，彼得·诺维格发表了一项研究，表明 23 个设计模式中的 16 个要么是不必要的，或者可以在像 Lisp 这样的动态编程语言中简化。

*这是一个不容忽视的观察结果*。在面向对象编程的背景下，从类层次结构中抽象出额外的抽象需要软件设计者思考对象是如何实例化和相互交互的。在一个强大、静态类型语言如 Java 中，对对象的行为和交互进行推理就更加必要了。在第十一章，*传统面向对象模式*中，我们将回到这个话题，并讨论 Julia 与面向对象编程相比是如何不同的。

目前，我们将从基础知识开始，回顾一些软件设计原则。这些原则就像北极星，在我们构建应用程序时指引我们。

# 我们如何在本书中描述模式？

如果你刚开始学习 Julia 编程，这本书将帮助你理解如何编写更符合 Julia 习惯的代码。我们还将专注于描述一些在现有的开源 Julia 生态系统中被广泛使用的最有用的模式。这包括 Julia 自己的 Base 和 `stdlib` 包，因为 Julia 运行时大部分是用 Julia 编写的。我们还将参考其他用于数值计算和网络编程的包。

为了便于参考，我们将按名称组织我们的模式。例如，神圣特质模式指的是实现特质的具体方法。领域特定语言模式讨论了如何构建新的语法来表示特定的领域概念。拥有名称的唯一目的是为了便于参考。

当我们在本书中讨论这些设计模式时，我们将试图理解其背后的动机。我们试图解决什么具体问题？在现实世界中，什么样的场景会用到这样的模式？然后，我们将深入探讨如何解决这些问题。有时，解决同一个问题可能有几种方法，在这种情况下，我们将研究每种可能的解决方案，并讨论其优缺点。

话虽如此，了解使用设计模式的最终目标对我们来说很重要。我们为什么要首先使用设计模式？为了回答这个问题，首先了解一些关键的软件设计原则会有所帮助。

# 软件设计原则

虽然这本书没有涵盖面向对象编程，但一些面向对象的设计原则是通用的，可以应用于任何编程语言和范式。在这里，我们将探讨一些最著名的设计原则。特别是，我们将涵盖以下内容：

+   **SOLID**: 单一职责、开放/封闭、李斯克夫替换、接口隔离、依赖倒置

+   **DRY**: 不要重复自己

+   **KISS**: 简单就是美！

+   **POLA**: 最小惊讶原则

+   **YAGNI**: 你不会需要它

+   **POLP**: 最小权限原则

让我们从 SOLID 开始。

# SOLID

SOLID 原则由以下内容组成：

+   **S**: 单一职责原则

+   **O**: 开放/封闭原则

+   **L**: 李斯克夫替换原则

+   **I**: 接口隔离原则

+   **D**: 依赖倒置原则

让我们详细了解每个概念。

# 单一职责原则

单一职责原则指出，每个模块、类和函数都应该只负责一个功能目标。应该只有一个理由去修改任何东西。

这个原则的好处如下：

+   在开发过程中，程序员可以专注于单一上下文。

+   每个组件的大小更小。

+   代码更容易理解。

+   代码更容易测试。

# 开放/封闭原则

开放/封闭原则指出，每个模块应该对扩展开放，但对修改封闭。区分增强和扩展是必要的——增强指的是现有模块的核心改进，而扩展被认为是提供额外功能的附加组件。

以下是这个原则的好处：

+   现有的组件可以很容易地重用来派生新的功能。

+   组件松散耦合，因此更容易替换而不影响现有功能。

# 李斯克夫替换原则

李斯克夫替换原则指出，一个接受类型*T*的程序也可以接受类型*S*（它是*T*的子类型），而不改变行为或预期结果。

以下是这个原则的好处：

+   函数可以用于任何传入参数的子类型。

# 接口隔离原则

接口隔离原则指出，客户端不应该被迫实现它不需要使用的接口。

以下是这个原则的好处：

+   软件组件更模块化和可重用。

+   新的实现可以更容易地创建。

# 依赖倒置原则

依赖倒置原则指出，高级类不应该依赖于低级类；相反，高级类应该依赖于低级类实现的抽象。

以下是这个原则的好处：

+   组件更加解耦。

+   系统变得更加灵活，可以更容易地适应变化。低级组件可以被替换，而不会影响高级组件。

# DRY

我们现在将介绍 DRY 原则：

+   **D**: 不要

+   **R**: 重复

+   **Y**: 自己

这个缩写是一个很好的方式来提醒程序员，重复代码是坏事。显然，重复代码可能难以维护——每当逻辑发生变化时，代码中的多个地方都会受到影响。

当我们发现重复代码时，我们该怎么办？消除它，并创建一个可以从多个源文件复用的通用函数。

此外，有时代码并不是 100%重复的，而是 90%相似。这种情况并不少见。在这种情况下，考虑重新设计相关组件，可能需要将代码重构到公共接口。

# KISS

让我们谈谈 KISS 原则：

+   **K**: 保持

+   **I**: 它

+   **S**: 简单

+   **S**: 愚蠢！

经常，当我们设计软件时，我们喜欢提前思考并尝试处理各种未来的场景。构建这种**防未来的**软件的麻烦在于，它需要指数级更多的努力来设计和编码。从实际的角度来看，这是一个难题——因为技术会变化，业务会变化，人也会变化，所以没有 100%的防未来解决方案。此外，过度设计可能会导致过度抽象和间接，使系统更难测试和维护。

此外，当使用敏捷软件开发方法时，我们重视快速和高质的交付，而不是完美或过度工程。保持设计和代码简单是每个程序员都应该记住的美德。

# POLA

让我们看看 POLA 原则：

+   **P**: 原则

+   **O**: 的

+   **L**: 最小化

+   **A**: 惊讶

POLA 原则指出，软件组件应该易于理解，其行为永远不应该让客户感到惊讶（或者更准确地说，*震惊*）。我们如何做到这一点？

以下是一些需要注意的事项：

+   确保模块、函数或函数参数的名称清晰且无歧义。

+   确保模块大小适中且维护良好。

+   确保接口小且易于理解。

+   确保函数具有很少的位置参数。

# YAGNI

让我们继续讨论 YAGNI 原则：

+   **Y**: 你

+   **A**: 不

+   **G**: 将来

+   **N**: 需要

+   **I**: 它

YAGNI 原则指出，你应该只开发今天需要的软件。这个原则来自**极限编程**（**XP**）。看看极限编程的共同创始人 Ron Jeffries 在他的博客中写了什么：

“总是在你需要的时候实现事物，而不是仅仅预见你需要它们的时候。”

软件工程师有时会诱惑开发他们认为客户将来会需要的功能。一次又一次地证明，这并不是开发软件最有效的方法。考虑以下场景：

+   功能永远不会被客户需要，因此代码永远不会被使用。

+   商业环境发生变化，系统需要重新设计或替换。

+   技术发生变化，系统需要升级以使用新的库、新的框架或新的语言。

代价最低的软件是你没有写的那部分。*你不会需要它！*

# POLP

现在，让我们来看看 POLP：

+   **P**：原则

+   **O**：的

+   **L**：最小

+   **P**：权限

POLP 指出，客户端只能访问他们需要的或功能。POLP 是构建安全应用最重要的支柱之一，并且被像亚马逊、微软和谷歌这样的云基础设施供应商广泛采用。

当应用 POLP 时，有很多好处：

+   敏感数据受到保护，不会暴露给非特权用户。

+   由于用例数量有限，系统可以更容易地进行测试。

+   由于只提供了有限的访问权限并且接口更简单，系统不太可能被误用。

我们迄今为止学到的软件设计原则是伟大的工具。尽管 SOLID、DRY、KISS、POLA、YAGNI 和 POLP 看起来只是一堆缩写，但在设计更好的软件时它们是有用的。虽然 SOLID 原则来自面向对象编程范式，但 SOLID 的概念仍然可以应用于其他语言和环境。随着我们在本书的其余章节中继续前进，我鼓励你记住它们。

在下一节中，我们将讨论设计软件时的几个软件质量目标。

# 软件质量目标

每个人都喜欢美好的设计。我也一样。但是，使用设计模式的目的不仅仅是让某物看起来好看。我们做的每一件事都应该有目的。

GoF 将面向对象设计模式分为创建型、结构型和行为型。对于 Julia，让我们从不同的角度出发，根据各自的软件质量目标对模式进行分类，如下所示：

+   可重用性

+   性能

+   维护

+   安全性

让我们在接下来的章节中了解每个概念。

# 可重用性

当设计软件时，人们经常谈论自顶向下和自底向上的方法。

**自顶向下的方法**从一个大问题开始，将其分解成一系列较小的问题。然后，如果问题不够小，正如我们在查看单一职责原则时所讨论的，我们将进一步将问题分解成更小的问题。这个过程会重复进行，最终问题足够小，可以设计和编码。

**自底向上的方法**是相反的方向。给定领域知识，你可以开始创建构建块，然后通过组合这些构建块创建更复杂的构建块。

无论采用何种方式，最终都会有一组相互协作的组件，从而形成应用程序的基础。

我喜欢这个比喻。即使是 5 岁的孩子也能仅用几种乐高积木块搭建出各种结构。想象力是无限的。你是否曾想过为什么它如此强大？好吧，如果你还记得，每个乐高积木块都有一个标准的连接器集合：一个、两个、四个、六个、八个或更多。使用这些连接器，每个积木块可以轻松地插入另一个积木块。当你创建一个新的结构时，你可以将其与其他结构结合，以创建更大、更复杂的结构。

在构建应用程序时，关键的设计原则是创建可插拔的接口，以便每个组件都可以轻松重用。

# 可重用组件的特征

以下是可以重用组件的重要特征：

+   每个组件只服务于单一目的（SOLID 中的 S）。

+   每个组件都定义良好，并准备好重用（SOLID 中的 O）。

+   为父-子关系设计了抽象类型层次结构（SOLID 中的 L）。

+   接口被定义为一个小集合的函数（SOLID 中的 I）。

+   使用接口在组件之间建立桥梁（SOLID 中的 D）。

+   模块和函数的设计考虑了简洁性（KISS 原则）。

可重用性很重要，因为它意味着我们可以避免代码重复和浪费精力。我们编写的代码越少，维护软件所需的工作就越少。这包括开发工作，也包括测试、打包和升级的时间。可重用性也是开源软件之所以成功的原因之一。特别是，Julia 生态系统包含许多开源包，它们往往相互借用功能。

接下来，我们将讨论另一个软件质量目标——性能。

# 性能

Julia 语言是为高性能计算设计的。然而，这并非免费。在性能方面，编写更符合编译器友好的代码需要实践，这使得程序更可能被转换为优化的机器代码。

在过去几十年里，计算机似乎每年都在变得越来越快。过去曾是性能瓶颈的问题，现在使用今天的硬件更容易解决。同时，我们也面临着更多挑战，因为数据的爆炸性增长。一个很好的例子是大数据和数据科学领域。随着数据量的增长，我们需要更多的计算能力来处理这些新的用例。

不幸的是，计算机的速度增长并没有像过去那样快。摩尔定律指出，芯片上晶体管的数量大约每 18 个月翻一番，自 1960 年以来，它与 CPU 速度的增长相关。然而，众所周知，由于物理限制，摩尔定律很快将不再适用：芯片上可以容纳的晶体管数量和制造过程的精度。

为了应对今天的计算需求，特别是在人工智能、机器学习和数据科学的世界中，从业者一直在转向一种利用多台服务器上多个 CPU 核心的 *扩展* 策略，并研究利用 GPU 和 TPU 的效率。

# 高性能代码的特性

以下是一些高性能代码的特性：

+   函数较小，易于优化（SOLID 中的 S）。

+   函数包含简单的逻辑而不是复杂的逻辑（KISS）。

+   数字数据被布局在连续的内存空间中，以便编译器可以充分利用 CPU 硬件。

+   应将内存分配保持在最低限度，以避免过多的垃圾回收。

性能是任何软件项目的重要方面。对于数据科学、机器学习和科学计算用例来说，尤其重要。一个小设计变更可能会带来很大的差异——根据情况，它可能将 24 小时的过程缩短到 30 分钟，也可能在使用 Web 应用时为用户提供实时体验，而不是请等待... 对话框。

接下来，我们将讨论软件的可维护性作为另一个软件质量目标。

# 可维护性

当软件设计得当，维护起来会更加容易。一般来说，如果你能够有效地使用之前列出的设计原则（SOLID、KISS、DRY、POLA、YAGNI 和 POLP），那么你的应用程序更有可能具有良好的架构和长期维护的设计。

可维护性是大型应用程序的重要成分。一个研究生项目可能不会持续很长时间。相反，一个企业应用程序可能持续数十年。最近，我从一个同事那里听说 COBOL 仍在使用，COBOL 程序员仍然能过上好日子。

我们经常听到技术债务。与现实生活中货币债务类似，技术债务是每次代码更改时你必须支付的东西。而且，技术债务存在的时间越长，你付出的努力就越多。

为了理解为什么，考虑一个充斥着重复代码或不必要的依赖的模块。每当添加新功能时，你必须更新源代码的多个部分，并且需要对系统更大的区域进行回归测试。因此，每次代码更改时，你都要为债务付出（从编程时间和努力的角度来看）直到债务完全偿还（即，直到代码完全重构）。

# 可维护代码的特性

以下是一些可维护代码的特性：

+   不使用未使用的代码（YAGNI）。

+   不重复代码（DRY）。

+   代码简洁简短（KISS）。

+   代码清晰易懂（KISS）。

+   每个函数都有一个单一的目的（SOLID 中的 S）。

+   每个模块都包含相互关联并协同工作的函数（SOLID 中的 S）。

可维护性是任何应用程序的重要方面。当设计得当，即使是大型应用程序也可以频繁且容易地更改，而不必担心。应用程序也可以长时间运行，从而降低软件的成本。

接下来，我们将讨论软件安全性作为另一个质量目标。

# 安全性

“安全性——指免受伤害、受伤或损失的状态。”

– 梅里厄姆-韦伯斯特词典

预期应用程序能够正确运行。当应用程序出现故障时，可能会产生不希望的结果，其中一些可能是致命的。考虑一下美国宇航局使用的至关重要的火箭发射子系统。一个缺陷可能导致发射延迟；或者，在最坏的情况下，它可能导致火箭在空中爆炸。

编程语言被设计为允许灵活性，同时提供安全特性，以便软件工程师犯更少的错误。例如，编译器的静态类型检查确保将正确的类型传递给期望这些类型的函数。此外，大多数计算机程序在数据上操作，正如我们所知，数据并不总是干净或可用的。因此，处理不良或缺失数据的能力是重要的软件质量。

# 安全应用程序的特征

安全应用程序的一些特征如下：

+   每个模块都公开一组最小的类型、函数和变量。

+   每个函数都使用参数调用，使得相应的类型实现函数的预期行为（SOLID 中的 L；POLA）。

+   函数的返回值清晰并已记录（POLA）。

+   正确处理缺失数据（POLA）。

+   变量限制在最小的范围内。

+   异常被捕获并相应处理。

安全性在这里是最重要的目标之一。一个错误的应用程序可能造成重大灾难。它甚至可能使公司损失数百万美元。2010 年，丰田因防抱死制动系统（**ABS**）的软件缺陷召回超过 40 万辆 Prius 混合动力汽车。1996 年，欧洲航天局发射的阿丽亚娜 5 火箭在发射后 40 秒爆炸。当然，这些只是几个更极端的例子。通过利用最佳实践，我们可以避免陷入这类尴尬且代价高昂的事件。

现在，我们理解了软件设计原则和软件质量目标的重要性。

# 摘要

在本章中，我们首先回顾了设计模式的历史，讨论了为什么设计模式对软件专业人士有用，以及根据我们过去学到的知识，我们如何希望组织本书中的设计模式。

我们回顾了几个可以在任何编程语言中普遍应用的软件设计原则，这在开发代码和应用 Julia 的设计模式时非常重要。我们涵盖了 SOLID、DRY、KISS、POLA、YAGNI 和 POLP。这些设计原则在面向对象编程社区中广为人知，并且受到好评。

最后，我们讨论了一些我们希望通过使用设计模式来实现的软件质量目标。在这本书中，我们决定专注于可重用性、可维护性、性能和安全目标。我们还欣赏了这些目标的好处，并回顾了一些实现这些目标的一般性指南。

下一章将会非常精彩！我们将深入探讨 Julia 程序的组织方式以及如何使用 Julia 的类型系统，同时还会介绍一些关于 Julia 的基础知识。

# 问题

回顾以下问题，以加强你对本章主题的理解。答案在书的后面提供：

1.  使用设计模式有哪些好处？

1.  列举一些关键的设计原则。

1.  开放/封闭原则解决了什么问题？

1.  为什么接口隔离对于软件的可重用性很重要？

1.  保持应用程序可维护性的最简单方法是什么？

1.  避免过度设计和臃肿软件的好习惯是什么？

1.  内存使用如何影响系统性能？
